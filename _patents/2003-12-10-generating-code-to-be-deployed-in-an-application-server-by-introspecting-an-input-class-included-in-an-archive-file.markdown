---
title: Generating code to be deployed in an application server by introspecting an input class included in an archive file
abstract: A system and method for generating code that reduces the cost for large projects and that provides easier and quicker ways of finding errors and making modifications is disclosed. A method of generating code to be deployed in an application server comprises the steps of receiving an archive file to be deployed, introspecting an input class included in the archive file to generate information relating to the input class, generating a markup language description of the input class based on the generated information relating to the input class, creating an event handler for a method node found in the markup language description, registering the event handler, parsing the markup language description and invoking the registered event handler, and generating output code using the invoked event handler.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07865871&OS=07865871&RS=07865871
owner: Oracle International Corporation
number: 07865871
owner_city: Redwood Shores
owner_country: US
publication_date: 20031210
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present invention relates to a method, system, and computer program product for generating code from compiled code deployed to an application server.","Many JAVA\u00ae technologies currently require the generation of classes based on some input class. A prime example is ENTERPRISE JAVA BEANS\u00ae (EJBs\u00ae), which require the generation of a particular application server's container classes to wrap the developer supplied bean class.","To date this process of code generation has largely been undertaken with invocations of methods that use printout statements to build the required files, generally one file at a time. In addition, most of these generation facilities attempt to create a complete file at once rather than taking a more modular approach to the assembly of the generated file. Although this process works for small projects, it quickly becomes unwieldy for larger projects, leading to increased expense. In addition, tracking down errors in code generation or making modifications to accommodate new requirements is a difficult, expensive, and time-consuming process since the correct method and the correct print statement needs to be found amongst many similar looking statements. A need arises for a technique by which code can be generated that reduces the cost for large projects and that provides easier and quicker ways of finding errors and making modifications.","The present invention is a system and method for generating code that reduces the cost for large projects and that provides easier and quicker ways of finding errors and making modifications. Whereas the prior art techniques were rather unwieldy and cumbersome, the present invention provides a modular approach to code generation\u2014event handlers handle precise segments of the code generation process rather than attempting to create a complete file. Thus, the whole code generation engine within an application becomes more maintainable and reliable, reducing cost and time spent.","A more maintainable and reliable code generation facility provides the capability to significantly decrease any generation errors that may occur and that may ultimately lead to customer dissatisfaction. In addition, the ability to quickly and effectively modify the code generation process will allow the server to adapt to new generation requirements for particular technologies quickly, thus significantly cutting down on time-to-market for new generation dependent features.","In addition the present invention has potential applicability in many code generation arenas such as CORBA ORBs, XML code bindings such as JAXB, etc.","In one embodiment of the present invention, a method of generating code to be deployed in an application server comprises the steps of receiving a compiled file to be deployed, introspecting this input class to generate information relating to the input class, generating a markup language description of the input class based on the generated information relating to the input class, creating an event handler for a method node found in the markup language description, registering the event handler, parsing the markup language description and invoking the registered event handler, and generating output code using the invoked event handler.","In one aspect of the present invention, the archive file is a compiled ENTERPRISE JAVA BEAN\u00ae (EJB\u00ae) file. The step of introspecting an input class included in the archive file may comprise the steps of extracting information identifying methods included in the input class and for each method, extracting information relating to parameters of the method and exceptions generated by the method. The step of generating a markup language description of the input class may comprise the step of generating an Extensible Markup Language description of the input class based on the generated information relating to the input class. The step of creating an event handler may comprise the step of creating a programming language implementation of a Simple Application Programming Interface for Extensible Markup Language (SAX) event handler for a method node found in the class' XML description. The step of parsing the XML description and invoking the registered event handlers may comprise the step of parsing the markup language description using a SAX parser and invoking the registered SAX event handlers.","In one aspect of the present invention, the step of creating an event handler comprises the step of creating a plurality of event handlers for a method node found in the markup language description. The step of registering the event handler may comprise the step of registering each of the plurality of event handlers. The step of parsing the markup language description and invoking the registered event handler may comprise the step of parsing the markup language description and invoking each of the plurality of registered event handlers. The step of generating output code may comprise the step of generating output code using each of the plurality of invoked event handlers in parallel.","The present invention is a system and method for generating code that reduces the cost for large projects and that provides easier and quicker ways of finding errors and making modifications. In a preferred embodiment, the present invention relies on the Simple API for XML (SAX) to drive the generation of code. SAX is an event-driven, serial-access mechanism for accessing XML documents. SAX was the first widely adopted API for XML in JAVA\u00ae, and is a \u201cde facto\u201d standard. A typical version of SAX contains a number of core classes and interfaces together with optional helper classes and demonstration classes. SAX is described in greater detail below.","An exemplary block diagram of an application server , in which the present invention may be implemented, is shown in . The exemplary application server shown in  is based on the well-known ORACLE\u00ae application server. However, this application server is merely an example. The present invention is applicable to other application servers as well, such as those from IBM\u00ae, MICROSOFT\u00ae, etc.","An Application Server generally interacts with both clients  (including browser  and standalone ) and back-end EIS systems . The application server provides an Enterprise Java Bean (EJB) container  to facilitate access to EIS and\/or database systems . A container is a controlled run-time environment for an application component (e.g., an EJB ) that also provides an interface to components executing within the container. Also, containers provide basic management functionality such as life cycle management of the components, security, deployment, threading, etc. An EJB  is a software component that implements the interfaces defined by its respective container. The interfaces of the EJB  are defined in a manner that permits the functionality of the respective EJB  to be accessed in a modular and dynamic manner.","The application server  also provides a Web container . The Web container  may provide a controlled run-time environment for components that interact with a client. For example, servlet components  (persistent Web server processes that are capable of processing multiple requests) may be implemented to dynamically create hypertext markup language (HTML) or XML responses to requests from clients. Other suitable components may be implemented within the Web container.","In general, the middle tier may be implemented utilizing \u201cmiddleware servers\u201d or \u201capplication servers.\u201d An application server typically includes many dissimilar services that are appropriate to create a stable and robust environment for enterprise applications. A service represents a predefined task that is provided by a piece of software in a well defined and predicable manner. Typically, an application server may comprise services that implement management functionality, such as MBean server , in which management services may be implemented as MBeans . The management services of the application server may be responsible for starting, registering, monitoring, and stopping services. Management services may perform other tasks such as thread pooling, security management, state management, class loading, load-balancing, dynamic application launching, and\/or the like. Secondly, an application server may provide a basic set of services that may be commonly utilized by a wide range of enterprise applications (e.g., hypertext transfer protocol (HTTP) processing). Third, an application server may comprise application specific services that implement the business or other logic of a given enterprise application.","An exemplary flow diagram of a process  for generating code according to the present invention is shown in . Typically, a bean archive file is deployed to an application server. For example, if the bean archive file contains an ENTERPRISE JAVA BEAN\u00ae (EJB\u00ae) implementation, the archive file includes one or more classes of objects. Process  begins with step , in which the input class, that is the object class included in the archive file, is introspected. Introspection involves extracting information relating to the objects, methods, etc., that are included in the class. For example, information identifying methods included in the input class may be extracted and for each method, information relating to parameters of the method are extracted. In JAVA\u00ae, introspection may be performed using the JAVA\u00ae Reflection API.","In step , an XML description of the JAVA\u00ae bean class is generated based on the class information gathered via the introspection performed in step . For example,",{"@attributes":{"id":"p-0023","num":"0022"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<bean name=\u201cMyBean\u201d package=\u201cMyPackage\u201d>"]},{"entry":[{},"<method name=\u201cmethod1\u201d>"]},{"entry":[{},"<param type=\u201cjava.lang.String\u201d name=\u201cparam1\u201d\/>"]},{"entry":[{},"<exception type=\u201cMyPackage.MyException\u201d\/>"]},{"entry":[{},"<return type=\u201cvoid\u201d\/>"]},{"entry":[{},"<\/method>"]},{"entry":[{},"<\/bean>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In step , SAX event handlers are created for the appropriate nodes in the XML code. For example, in the example above, a <method> node handler would be at least one of the handlers registered. These event handlers can then drive the generation of the code by analyzing the information of the node and any relevant child nodes. Based on this analysis the code can drive the generation process in any way a developer would see fit, such as:","Invocations of print statements","Templating technologies such as XSL.","In step , the event handlers are registered with a SAX parser and, in step , the parsing of the JAVA\u00ae bean class XML descriptor commences. As the event handlers are invoked by the parser, step , the code generation proceeds. Note that this facility could potentially be leveraged to generate more than one file in parallel if, for example, an event handler leverages multiple templates. For example, if a method affects multiple files, all handlers for a method may be invoked at once and the code for each file generated in parallel.","An exemplary block diagram of a computer system , in which an application server, such as that shown in , may be implemented, is shown in . System  is typically a programmed general-purpose computer system, such as a personal computer, workstation, server system, and minicomputer or mainframe computer. System  includes one or more processors (CPUs) A-N, input\/output circuitry , network adapter , and memory . CPUs A-N execute program instructions in order to carry out the functions of the present invention. Typically, CPUs A-N are one or more microprocessors, such as an INTEL PENTIUM\u00ae processor.  illustrates an embodiment in which System  is implemented as a single multi-processor computer system, in which multiple processors A-N share system resources, such as memory , input\/output circuitry , and network adapter . However, the present invention also contemplates embodiments in which System  is implemented as a plurality of networked computer systems, which may be single-processor computer systems, multi-processor computer systems, or a mix thereof.","Input\/output circuitry  provides the capability to input data to, or output data from, database\/System . For example, input\/output circuitry may include input devices, such as keyboards, mice, touchpads, trackballs, scanners, etc., output devices, such as video adapters, monitors, printers, etc., and input\/output devices, such as, modems, etc. Network adapter  interfaces database\/System  with Internet\/intranet . Internet\/intranet  may include one or more standard local area network (LAN) or wide area network (WAN), such as Ethernet, Token Ring, the Internet, or a private or proprietary LAN\/WAN.","Memory  stores program instructions that are executed by, and data that are used and processed by, CPU  to perform the functions of system . Memory  may include electronic memory devices, such as random-access memory (RAM), read-only memory (ROM), programmable read-only memory (PROM), electrically erasable programmable read-only memory (EEPROM), flash memory, etc., and electro-mechanical memory, such as magnetic disk drives, tape drives, optical disk drives, etc., which may use an integrated drive electronics (IDE) interface, or a variation or enhancement thereof, such as enhanced IDE (EIDE) or ultra direct memory access (UDMA), or a small computer system interface (SCSI) based interface, or a variation or enhancement thereof, such as fast-SCSI, wide-SCSI, fast and wide-SCSI, etc, or a fiber channel-arbitrated loop (FC-AL) interface.","In the example shown in , memory  includes HTTP listener layer , virtual path manager , application server layer , applications layer , ORB , code generation objects , SAX objects , and operating system . HTTP listener layer  is made up of listeners, the adapter interface, and dispatchers. Listeners are HTTP servers; they handle incoming requests and route them to the dispatcher. The dispatcher forwards requests to the virtual path manager . The virtual path manager maps a request to a cartridge type and passes this information back to the dispatcher. The virtual path manager also passes back authentication requirements to the dispatcher. The Application Server layer  provides resource management in handling requests for applications deployed as cartridges on the server. It provides a common set of components for managing these applications. These components include load balancing, logging, automatic failure recovery, security, directory, and transaction components. The Applications layer  is made up of applications, cartridges, and cartridge servers. Applications and cartridges are the two main objects that you use when building applications for the application server environment. ORB  acts as the middleware between clients and servers. Code generation objects  perform the steps of and store the data for code generation process , shown in . SAX objects  implement the SAX functionality, described below. Operating system  provides overall system functionality.","As shown in , the present invention contemplates implementation on a system or systems that provide multi-processor, multi-tasking, multi-process, and\/or multi-thread computing, as well as implementation on systems that provide only single processor, single thread computing. Multi-processor computing involves performing computing using more than one processor. Multi-tasking computing involves performing computing using more than one operating system task. A task is an operating system concept that refers to the combination of a program being executed and bookkeeping information used by the operating system. Whenever a program is executed, the operating system creates a new task for it. The task is like an envelope for the program in that it identifies the program with a task number and attaches other bookkeeping information to it. Many operating systems, including UNIX\u00ae, OS\/2\u00ae, and WINDOWS\u00ae, are capable of running many tasks at the same time and are called multitasking operating systems. Multi-tasking is the ability of an operating system to execute more than one executable at the same time. Each executable is running in its own address space, meaning that the executables have no way to share any of their memory. This has advantages, because it is impossible for any program to damage the execution of any of the other programs running on the system. However, the programs have no way to exchange any information except through the operating system (or by reading files stored on the file system). Multi-process computing is similar to multi-tasking computing, as the terms task and process are often used interchangeably, although some operating systems make a distinction between the two.","SAX is an event-driven, serial-access mechanism for accessing XML documents. SAX was the first widely adopted API for XML in JAVA\u00ae, and is a \u201cde facto\u201d standard. A typical version of SAX contains a number of core classes and interfaces together with optional helper classes and demonstration classes.","An exemplary architecture of a SAX implementation  is shown in . The parser  wraps a SAXReader object . When the parser's  parse( ) method is invoked, the reader  invokes one of several callback methods implemented in the application. Those methods are defined by the interfaces ContentHandler , ErrorHandler , DTDHandler , and EntityResolver .","Here is a summary of the key SAX APIs:","SAXParserFactory ","A SAXParserFactory  object creates an instance of the parser determined by the system property, javax.xml.parsers.SAXParserFactory.","SAXParser ","The SAXParser interface  defines several kinds of parse( ) methods. In general, you pass an XML data source  and a DefaultHandler object to the parser, which processes the XML  and invokes the appropriate methods in the handler object.","SAXReader ","The SAXParser  wraps a SAXReader . Typically, you don't care about that, but every once in a while you need to get hold of it using SAXParser's getXMLReader( ), so you can configure it. It is the SAXReader  that carries on the conversation with the SAX event handlers you define.","DefaultHandler","Not shown in , a DefaultHandler implements the ContentHandler , ErrorHandler , DTDHandler , and EntityResolver  interfaces (with null methods), so you can override only the ones you're interested in.","ContentHandler ","Methods like startDocument, endDocument, startElement, and endElement are invoked when an XML tag is recognized. This interface also defines methods characters and processing instruction, which are invoked when the parser encounters the text in an XML element or an inline processing instruction, respectively.","ErrorHandler ","Methods error, fatalError, and warning are invoked in response to various parsing errors. The default error handler throws an exception for fatal errors and ignores other errors (including validation errors). That's one reason you need to know something about the SAX parser, even if you are using the DOM. Sometimes, the application may be able to recover from a validation error. Other times, it may need to generate an exception. To ensure the correct handling, you'll need to supply your own error handler to the parser.","DTDHandler ","Defines methods you will generally never be called upon to use. Used when processing a DTD to recognize and act on declarations for an unparsed entity.","EntityResolver ","The resolveEntity method is invoked when the parser must identify data identified by a URI. In most cases, a URI is simply a URL, which specifies the location of a document, but in some cases the document may be identified by a URN\u2014a public identifier, or name, that is unique in the Web space. The public identifier may be specified in addition to the URL. The EntityResolver can then use the public identifier instead of the URL to find the document, for example to access a local copy of the document if one exists. A typical application implements most of the ContentHandler methods, at a minimum. Since the default implementations of the interfaces ignore all inputs except for fatal errors, a robust implementation may want to implement the ErrorHandler methods, as well.","These SAX classes and interfaces fall into groups:","Interfaces implemented by the parser:\n\n","Interfaces implemented by the application:\n\n","Standard SAX classes:\n\n","Optional JAVA\u00ae-specific helper classes:\n\n","JAVA\u00ae demonstration classes in the nul package:\n\n","A SAX-conformant XML parser needs to implement only two or three simple interfaces; in fact, it is even possible (and quite common) to implement all of these interfaces in a single class, if desired.","Parser","This is the main interface to a SAX parser: it allows the user to register handlers for callbacks, to set the locale for error reporting, and to start an XML parse.","AttributeList","This simple interface allows users to iterate through an attribute list\u2014the parser can implement it in the same class as the SAX driver, or implement it in a separate class (it does not need to be persistent). There is a convenience implementation available in the org.xml.sax.helpers.AttributeListlmpl.","Locator","This simple interface allows users to find the current location in the XML source document\u2014the parser can implement it in the same class as the driver, or implement it in a second class (it does not need to be persistent).","Interfaces for Application Writers","A SAX application may implement any or none of the following interfaces, as required (simple XML applications may need only DocumentHandler and possibly ErrorHandler). An application can implement all of these interfaces in a single class, if desired.","DocumentHandler","This is the interface that applications will probably use the most\u2014in many cases, it is the only one that they will need to implement. If an application provides an implementation of this interface, it will receive notification of basic document-related events like the start and end of elements. It is this interface that will be implemented to drive the code generation in this invention.","ErrorHandler","If an application needs to use special error handling, then it must provide an implementation of this interface.","DTDHandler","If an application needs to work with notations and unparsed (binary) entities, it must implement this interface to receive notification of the NOTATION and ENTITY declarations.","EntityResolver","If an application needs to do redirection of URIs in documents (or other types of custom handling), it must provide an implementation of this interface.","Standard SAX Classes","SAX consists mostly of interfaces rather than classes, but the interfaces refer to two standard exception classes, and a third is provided for universal convenience. These classes are useful for both parser and application writers.","InputSource","This class contains all of the necessary information for a single input source, including a public identifier, system identifier, byte stream, and character stream (as appropriate). The application must instantiate at least one InputSource for the Parser, and the EntityHandler may instantiate others.","SAXException","This class represents a general SAX exception.","SAXParseException","This class represents a SAX exception tied to a specific point in an XML source document.","HandlerBase","This class provides default implementations for DocumentHandler, ErrorHandler, DTDHandler, and EntityResolver: parser writers can use this to provide a default implementation when the user does not specify handlers, and application writers can subclass this to simplify handler writing.","JAVA\u00ae-Specific Helper Classes","These classes are not part of the core SAX distribution, and may not be available in SAX implementations in other languages: they are provided simply as a convenience for JAVA\u00ae programmers.","ParserFactory","An application can use the static methods in this class to load SAX parsers dynamically at run time, based on the class name.","AttributeListImpl","An application can use this convenience class to make a persistent copy of an AttributeList, or parser can use it to supply a default implementation of AttributeList to the application.","LocatorImpl","An application can use this convenience class to make a persistent snapshot of a Locator's values at a specific point in the parse.","It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable-type media such as floppy disc, a hard disk drive, RAM, and CD-ROM's, as well as transmission-type media, such as digital and analog communications links.","Although specific embodiments of the present invention have been described, it will be understood by those of skill in the art that there are other embodiments that are equivalent to the described embodiments. Accordingly, it is to be understood that the invention is not to be limited by the specific illustrated embodiments, but only by the scope of the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The details of the present invention, both as to its structure and operation, can best be understood by referring to the accompanying drawings, in which like reference numbers and designations refer to like elements.",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
