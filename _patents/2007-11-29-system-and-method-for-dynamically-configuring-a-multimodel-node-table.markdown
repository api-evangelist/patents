---
title: System and method for dynamically configuring a multi-model node table
abstract: A system and method are described for dynamically generating a table containing data from multiple model nodes. For example, a computer-implemented method according to one embodiment of the invention comprises: displaying a plurality of attributes from multiple different nodes of an application; providing a user interface allowing a user to select attributes from the plurality of attributes to be displayed as columns within a table; receiving an identification of a set of attributes within the plurality of attributes selected by the user; and storing the identification of the set of attributes as configuration data within local data storage, the local data storage being separate from a system data storage in which program code and data for the application is maintained.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08589394&OS=08589394&RS=08589394
owner: SAP AG
number: 08589394
owner_city: Walldorf
owner_country: DE
publication_date: 20071129
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS"],"p":["1. Field of the Invention","This invention relates generally to the field of data processing systems. More particularly, the invention relates to a system and method for dynamically configuring a table with data from multiple model nodes.","2. Description of the Related Art","Multi-Tiered Enterprise Computing Systems","Traditional client-server systems employed a two-tiered architecture such as that illustrated in . Applications  executed on the client side  of the two-tiered architecture are comprised of a monolithic set of program code including a graphical user interface component, presentation logic, business logic and a network interface that enables the client  to communicate over a network  with one or more servers . A database  maintained on the server  provides non-volatile or \u201cpersistent\u201d storage for the data accessed and\/or processed by the application .","The \u201cbusiness logic\u201d component of the application represents the core program code of the application, i.e., the rules governing the underlying business process (or other functionality) provided by the application. The \u201cpresentation logic\u201d describes the specific manner in which the results of the business logic are formatted for display on the user interface. The \u201cdatabase\u201d  includes data access logic used by the business logic to store and retrieve data.","The limitations of the two-tiered architecture illustrated in become apparent when employed within a large enterprise. For example, installing and maintaining up-to-date client-side applications on a large number of different clients is a difficult task, even with the aid of automated administration tools. Moreover, a tight coupling of business logic, presentation logic and the user interface logic makes the client-side code very brittle. Changing the client-side user interface of such applications is extremely hard without breaking the business logic, and vice versa. This problem is aggravated by the fact that, in a dynamic enterprise environment, the business logic may be changed frequently in response to changing business rules. Accordingly, the two-tiered architecture is an inefficient solution for enterprise systems.","In response to limitations associated with the two-tiered client-server architecture, a multi-tiered architecture has been developed, as illustrated in . In the multi-tiered system, the presentation logic , business logic  and database  are logically separated from the user interface  of the application. These layers are moved off of the client  to one or more dedicated servers on the network . For example, the presentation logic , the business logic , and the database  may each be maintained on separate servers, ,  and , respectively.","This separation of logical components and the user interface provides a more flexible and scalable architecture compared to that provided by the two-tier model. For example, the separation ensures that all clients  share a single implementation of business logic . If business rules change, changing the current implementation of business logic  to a new version may not require updating any client-side program code. In addition, presentation logic  may be provided which generates code for a variety of different user interfaces , which may be standard browsers such as Internet Explorer\u00ae or Netscape Navigator\u00ae.","The multi-tiered architecture illustrated in may be implemented using a variety of different application technologies at each of the layers of the multi-tier architecture, including those based on the Java 2 Enterprise Edition\u2122 (\u201cJ2EE\u201d) standard, the Microsoft .NET standard and\/or the Advanced Business Application Programming (\u201cABAP\u201d) standard developed by SAP AG. For example, as described below, in a J2EE environment, the business layer , which handles the core business logic of the application, is comprised of Enterprise Java Bean (\u201cEJB\u201d) components with support for EJB containers. Within a J2EE environment, the presentation layer  is responsible for generating servlets and Java Server Pages (\u201cJSP\u201d) interpretable by different types of browsers at the user interface layer .","J2EE Application Server Architecture",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1","i":"c ","b":["200","211","201","219","209","217"]},"As illustrated in each layer of the J2EE architecture includes multiple containers. The Web container , for example, is itself comprised of a servlet container  for processing servlets and a Java Server Pages (\u201cJSP\u201d) container  for processing Java server pages. The EJB container  includes three different containers for supporting three different types of enterprise Java beans: a session bean container  for session beans, a entity bean container  for entity beans, and a message driven bean container  for message driven beans. A more detailed description of J2EE containers and J2EE services can be found in RGKK, SAMS TYEJB 21 D(2003) (see, e.g., pages 353-376).","A system and method are described for dynamically generating a table containing data from multiple model nodes. For example, a computer-implemented method according to one embodiment of the invention comprises: displaying a plurality of attributes from multiple different nodes of an application; providing a user interface allowing a user to select attributes from the plurality of attributes to be displayed as columns within a table; receiving an identification of a set of attributes within the plurality of attributes selected by the user; and storing the identification of the set of attributes as configuration data within local data storage, the local data storage being separate from a system data storage in which program code and data for the application is maintained.","Described below is a system and method for dynamically configuring a table with data from multiple model nodes. Throughout the description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, to one skilled in the art that the present invention may be practiced without some of these specific details. In other instances, well-known structures and devices are shown in block diagram form to avoid obscuring the underlying principles of the present invention.","The display of data records in tables and forms, and the associated editing of the tables and forms (e.g., selecting, deleting, sorting, etc) by clients are central functions in Web-based applications. Thus, various techniques are provided within the J2EE architecture for creating and working with tables in response to client requests. In particular, under a model-view-controller (\u201cMVC\u201d) architecture, illustrated in Web-based content using tables may be created within the Web Container  using \u201ccontrollers\u201d  and \u201cviews\u201d - that operate in conjunction with \u201cmodels\u201d  within the EJB container . A detailed description of the MVC architecture is beyond the scope of the present application but, briefly, the controller  manages the underlying table structure and data, referred to in as a context node . The table structure is presented to Web clients  in the form of one or more \u201cviews\u201d - which indicate, for example, how the table is presented within a Web page. Controllers may be implemented by servlets and views by Java server pages. The model  within the EJB container  provides an interface between the controller  and the underlying table data stored within the database . See, e.g., Gand Kmentioned above for additional detail on the MVC architecture at pages 148-152.","The view ,  may be a table, in which case the table receives its data from a \u201cmulti element context node.\u201d At runtime, each element of the node is mapped to a table row. Thus, the number of table rows is identical to the number of node elements. The table columns are mapped to the context node attributes.","Various existing application server platforms employ a Model View Controller architecture to generate views for requesting clients. For example, \u201cWeb Dynpro\u201d is a programming paradigm developed by SAP AG (the assignee of the present application) which implements a Model View Controller architecture for generating and displaying views (e.g., tables) to end users. While certain embodiments of the invention are described herein within the context of Web Dynpro, it should be noted that the underlying principles of the invention are not limited to any particular programming paradigm.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 2","i":"b ","b":["275","275","274","271","273"]},"A table view  shows data typically obtained from a persistent layer, illustrated as remote system  and system database  in . In one embodiment, the remote system  is an R\/3 system designed by SAP AG (the assignee of the present application). The data are obtained from the remote system  using a Remote Function Call (\u201cRFC\u201d) or Business Application Programming Interface (BAPI) . While the remainder of this application will refer to an RFC, the underlying principles of the invention are not limited to any particular protocol.","A called RFC  populates a model node - with data.  illustrates an exemplary context model node  from an RFC called Ua_Rfc_Pdece_Tree_Query_Childrn_Input, which is made of input nodes  (ending in \u201cITQC\u201d in the example), and output nodes  (ending in \u201cOTQC\u201d). A remote system  provides data that are located in the RFC output models nodes. In the example shown in , the RFC returns data in five output nodes . Rather than containing data, one of the nodes, Bapiret2_OTQC, has messages that indicate if the RFC call has been successful or has failed.","In certain architectures such as Web Dynpro, a table can only receive data from a single context node. Thus, if an RFC returns data that needs to be shown in more than one node, a value node  (illustrated in ) is created used as the source node of the table. The value node  is populated with data from the RFC output model nodes -. In the example shown in , the value node , called \u201cTableExploded,\u201d receives data from three different model nodes  from the same RFC output: Et_Object_OTQC, Et_Edge_OTQC, and Et_Tnode_OTQC. The data are transferred from these three RFC output model nodes to the table value node , TableExploded, in order to be displayed in one table .","In sum, a table is mapped to one and only one context node which is a value node if the table contains data provided by an RFC call which results in multiple output model nodes.","\u201cPersonalization\u201d allows users or administrators adapt an application to their personal requirements. Current systems offer some personalization options at the table level and table column level. For example, an end user may hide or rearrange columns (e.g., moving columns left or right). However, the personalization tools used in current configurations do not allow users to add new columns.","Certain Collaborative Cross-Applications, or \u201cxApps,\u201d designed by SAP AG offer an application called the \u201cConfigurator\u201d that allows a user to create a table from an RFC call. The table is directly mapped to all elements of one output node of the RFC call, and the elements not intended to be shown are ignored. The table configuration is saved in a permanent data layer (e.g., within a system database ). When it is time to generate the table, the configuration is called and the columns to be shown are built dynamically. One significant limitation, however, if that the Configurator allows a table to be mapped one and only one RFC output model node.","In contrast, the embodiments of the invention described herein allow an application administrator (or other user) to add new columns to a table whose data comes from any number of different RFC calls. One embodiment of a method implemented by the dynamic table generation logic  to perform this function is illustrated in . At , the attributes from a variety of different output model nodes are displayed for the user. One embodiment of a user interface for allowing the user to select attributes from multiple model nodes is illustrated in  (described below). At step the user's attribute selections are detected and at  unique identifiers are generated for each attribute selected by the user. As described below, in one embodiment, the unique identifier comprises the name of the context node combined with (e.g., appended to) the attribute name. At , configuration data containing the selected attributes is stored within a local storage such as the local database  shown in ","In response to a user request from a client  at runtime, at , the dynamic table generation logic  dynamically builds the context node attributes of the table using the configuration data stored within the local database . In one embodiment, the new built attribute name is the name of the unique identifier generated in . At , the dynamic table generation logic  dynamically populates each newly created attribute by using its unique name. Its name indicates under which RFC output model node and attribute to select to retrieve the data. At , the dynamic table generation logic  dynamically builds the new table columns. In one embodiment, each new column has its own cell editor mapped to the corresponding attribute created in . As is known by those of skill in the art, the cell editor allows an end user or administrator to edit the contents of a cell when the table is not in \u201cread only\u201d mode.","One embodiment of the invention will be described with respect to . This example employs six RFC output model nodes ,  which are labeled Et_Edge_OTQC, Et_Hier_OTQC, Et_Node_OTOC, Et_Object_OTOC, Et_Tnode_OTQC, Et_Tline_OTQS. Note that all nodes whose names end with OTQC (identified as  in ) are output model nodes from one RFC call, and the node which ends with OTQS (identified as  in ) is an output model node from another RFC call. Consequently, this example uses output model nodes from two different RFC calls.","If the administrator does not know the name of the node, he can run a small help program that shows in the logger the names of all context nodes. The original table (prior to editing by the administrator) is illustrated in . A first series of columns  are provided for attributes from RFC call # and a second series of columns  are provided for attributes from RFC call #. The columns  of the RFC call # are grouped columns under the header \u201cPrices.\u201d By default, the RFC call # provides data for the two columns that are named \u201cRow Type\u201d and \u201cMoQ\u201d (Minimum Order Quantity).","In one embodiment, the dynamic table generation logic  shows all possible attributes of all nodes mentioned in the application property. In , the administrator selects the table node he wants to modify from drop down menu . In the illustrated example, the administrator has selected TableExploded. Once the table node selected from the drop down menu , all attributes of the nodes associated with the table in the application property are displayed. Columns are displayed for node name , attribute name , attribute text , selection boxes  (for selecting particular attributes), and header . In the illustrated example, the nodes have a total of 316 attributes (although only 10 attributes\/rows are displayed in ).","In one embodiment, the administrator selects the additional attributes to add to the table  as columns by checking selection boxes  for the rows associated with the attributes. For example, in , the attribute Node_Id of node Et_Hier_OTQC has been selected by checking the checkbox within row . Once a set of attributes has been selected in this manner, the administrator saves the configuration by selecting the save button . The configuration, including the newly-selected attributes, is then saved within the local database  and subsequently used to generate the table. If the administrator wants to modify the configuration in the future, he recalls the configuration by using the \u201cLoad Config\u201d Button . In the illustrated example, the administrator has chosen seven new columns, each column from a different output node except for the output node Et_Tline_OTQS that has two new columns (\u201cMaterial Price\u201d and \u201cValid From\u201d). The administrator can also change the header of the new columns. In one embodiment, the header of a new column is the name of the attribute of the RFC output model node. The default column name is listed under the column \u201cAttribute Text\u201d . In this example, the administrator has changed the header of the new columns by changing the name under the \u201cHeader\u201d column .","In one embodiment, the unique identifier used to identify each attribute selected by the administrator comprises the node name combined with the attribute name. For example, the last selection shown in  is the attribute Cost_Datval from the node Et_Tline_OTQS, so in this embodiment its unique identifier is Et_Tline_OTQS_Cos_Datval. Regardless of the format used, the unique identifier indicates exactly under which attribute and which model node the data for this column are maintained in the context. As previously mentioned, in one embodiment, the unique identifiers are stored within the configuration data on the local database . Subsequently, during runtime, the unique identifiers are retrieved to identify all attributes from all model nodes which are to be included within the table.","Specifically, at runtime, the dynamic table generation logic  reads the configuration data from the local database  and dynamically creates and populates the new table node attributes. The dynamic table generation logic  also dynamically creates the table columns and dynamically maps the cell editors of the table columns to their respective new attributes. Returning to the above example, the \u201cTableExploded\u201d node has its new attributes built dynamically and the names of the new attributes are their unique identifiers. For example, the attribute Cos_Datval of node Et_Line_OTQS is built dynamically using its unique identifier Et_Tline_OTQS_Cos_Datval. The six other attributes illustrated in  are built according their unique identifiers in the same manner.","Once the dynamic attributes and all other table node attribute are populated, the new table columns are built dynamically. As illustrated in , in the above example, the new table has the seven new columns -, two of them are from the Et_Line_OTS RFC output model node and are placed under the column grouped header \u201cPrice.\u201d Using portal personalization, the administrator can rearrange, if desired, the order of the columns, including the new columns.","In summary, the system and method described above allows application administrator or other user to add new columns to a table. The new columns can be created from any output model node of any RFC call. The additional configuration of the new columns is saved in a permanent layer which is separate from the system database . In the embodiments described above, the permanent layer is a local database  containing configuration data associated with the application. Because the configuration data is stored separately and used only at runtime, the underlying program code and data for the application (e.g., maintained on the remote system ) does not need to be modified.","It should be noted that a formal database structure is not required for local storage of the configuration data. For example, the configuration data may be stored within a file system in any type of file format (e.g., text, XML, etc) while still complying with the underlying principles of the invention.","Each new column is identified by a unique identifier which indicates from which RFC output model node, and from which attribute the data for this new column is retrieved. At runtime the following steps take place:","The saved configuration of the new columns is called and read.","The appropriate new attributes of the table node are created dynamically according to the saved configuration.","Each new attribute is populated with the correct data using the unique attribute identifier that indicates where the data are located (i.e., under which RFC model output node and which attribute).","The table columns are built dynamically, one column per new attribute, and their cell editors are respectively mapped to the corresponding attribute.","In addition, one embodiment of the invention also uses the portal personalization techniques described above that allow the administrator to rearrange and hide table columns, thereby increasing the customization possibilities of any tables shown in an application.","A system architecture on which embodiments of the invention may be implemented is illustrated in . The architecture includes a plurality of application server \u201cinstances\u201d  and . The application server instances  and  each include a group of worker nodes - and - (also sometimes referred to herein as \u201cserver nodes\u201d), respectively, and a dispatcher  and , respectively. The application server instances ,  communicate through a central services instance  using message passing. In one embodiment, the central services instance  includes a locking service and a messaging service (described below). The combination of all of the application server instances  and  and the central services instance  is referred to herein as a \u201ccluster.\u201d Although the following description will focus solely on instance  for the purpose of explanation, the same principles apply to other instances within the cluster.","The worker\/server nodes - within instance  provide the business and presentation logic for the network applications supported by the system including, for example, the model-video controller architecture described herein. Each of the worker nodes - within a particular instance may be configured with a redundant set of programming logic and associated data, represented as virtual machines - in . In one embodiment, the dispatcher  distributes service requests from clients to one or more of the worker nodes - based on the load on each of the servers. For example, in one embodiment, the dispatcher maintains separate queues for each of the - in a shared memory . The dispatcher  fills the queues with client requests and the worker nodes - consume the requests from each of their respective queues. The client requests may be from external clients (e.g., browser requests) or from other components\/objects within the instance  or cluster.","In one embodiment, the worker nodes - may be Java 2 Enterprise Edition (\u201cJ2EE\u201d) worker nodes which support Enterprise Java Bean (\u201cEJB\u201d) components and EJB containers (at the business layer) and Servlets and Java Server Pages (\u201cJSP\u201d) (at the presentation layer). In one embodiment, JSPs are used to implement the different views  described above, and servlets are used to implement the controllers . In this embodiment, the virtual machines - implement the J2EE standard (as well as the additional non-standard features described herein). It should be noted, however, that certain high-level features described herein may be implemented in the context of different software platforms including, by way of example, Microsoft .NET platforms and\/or the Advanced Business Application Programming (\u201cABAP\u201d) platforms developed by SAP AG, the assignee of the present application.","In one embodiment, communication and synchronization between each of the instances ,  is enabled via the central services instance . As mentioned above, the central services instance  includes a messaging service and a locking service. The message service allows each of the servers within each of the instances to communicate with one another via a message passing protocol. For example, messages from one server may be broadcast to all other servers within the cluster via the messaging service (e.g., such as the cache configuration messages described below). Alternatively, messages may be addressed directly to specific servers within the cluster (i.e., rather than being broadcast to all servers). In one embodiment, the locking service disables access to (i.e., locks) certain specified portions of configuration data and\/or program code stored within a central database . The locking service locks data on behalf of various system components which need to synchronize access to specific types of data and program code. In one embodiment, the central services instance  is the same central services instance as implemented within the Web Application Server version 6.3 and\/or 6.4 developed by SAP AG. However, the underlying principles of the invention are not limited to any particular type of central services instance.","In addition, unlike prior systems, one embodiment of the invention shares objects across virtual machines -. Specifically, in one embodiment, objects such as session objects which are identified as \u201cshareable\u201d are stored within a shared memory region ,  and are made accessible to multiple virtual machines -. Creating new object instances from scratch in response to client requests can be a costly process, consuming processing power and network bandwidth. As such, sharing objects between virtual machines as described herein improves the overall response time of the system and reduces server load.","In a shared memory implementation, a shared memory area ,  or \u201cheap\u201d is used to store data objects that can be accessed by multiple virtual machines -. The data objects in a shared memory heap should generally not have any pointers or references into any private heap (e.g., the private memory regions\/heaps of the individual virtual machines). This is because if an object in the shared memory heap had a member variable with a reference to a private object in one particular virtual machine, that reference would be invalid for all the other virtual machines that use that shared object.","More formally, this restriction can be thought of as follows: For every shared object, the transitive closure of the objects referenced by the initial object should only contain shared objects at all times. Accordingly, in one implementation of the invention, objects are not put into the shared memory heap by themselves\u2014rather, objects (such as the session objects described herein) are put into the shared memory heap in groups known as \u201cshared closures.\u201d A shared closure is an initial object plus the transitive closure of all the objects referenced by the initial object.","Embodiments of the invention may include various steps as set forth above. The steps may be embodied in machine-executable instructions which cause a general-purpose or special-purpose processor to perform certain steps. Alternatively, these steps may be performed by specific hardware components that contain hardwired logic for performing the steps, or by any combination of programmed computer components and custom hardware components.","Elements of the present invention may also be provided as a machine-readable medium for storing the machine-executable instructions. The machine-readable medium may include, but is not limited to, flash memory, optical disks, CD-ROMs, DVD ROMs, RAMs, EPROMs, EEPROMs, magnetic or optical cards.","Throughout the foregoing description, for the purposes of explanation, numerous specific details were set forth in order to provide a thorough understanding of the invention. It will be apparent, however, to one skilled in the art that the invention may be practiced without some of these specific details. For example, although many of the embodiments set forth above relate to a Web Dynpro, Java or J2EE implementation, the underlying principles of the invention may be implemented in virtually any client-server environment. Moreover, although some of the embodiments set forth above are implemented within a shared memory environment, the underlying principles of the invention are equally applicable to a non-shared memory environment. Finally, it should be noted that the terms \u201cclient\u201d and \u201cserver\u201d are used broadly to refer to any applications, components or objects which interact over a network.","Accordingly, the scope and spirit of the invention should be judged in terms of the claims which follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A better understanding of the present invention can be obtained from the following detailed description in conjunction with the following drawings, in which:",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1","i":"a "},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1","i":"b "},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1","i":"c "},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIGS. 2","i":["a","b "]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
