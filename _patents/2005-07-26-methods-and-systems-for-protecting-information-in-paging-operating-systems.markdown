---
title: Methods and systems for protecting information in paging operating systems
abstract: The inventive methods and systems provide an approach to protecting unencrypted sensitive information from being paged out to secondary storage, such as a hard disk, during paging operations. In the described embodiment, a key is provided and is maintained in the main memory of a virtual memory system. Measures are taken to protect the key such as page-locking the key in the main memory to ensure that it never gets paged out to the secondary storage. The described key is a desirably large key that is randomly generated by the operating system. When sensitive information is to be placed in the main memory, it is encrypted with the page-locked key. The encrypted sensitive information can then be paged out to secondary storage without concern about its security. When the encrypted sensitive information is needed by a process or application, it is retrieved from secondary storage and decrypted using the page-locked key. For further protection, the sensitive information can be decrypted into a page-locked page of main memory. More than one key can be used to encrypt and/or decrypt the sensitive information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07293173&OS=07293173&RS=07293173
owner: Microsoft Corporation
number: 07293173
owner_city: Redmond
owner_country: US
publication_date: 20050726
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["PRIORITY APPLICATION","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application stems from and claims priority to U.S. Provisional Patent Application No. 60\/143,438, filed on Jul. 13, 1999, the disclosure of which is hereby incorporated by reference. This application is also a continuation of and claims priority to U.S. patent application Ser. No. 09\/489,192, filed on Jan. 20, 2000 now abandoned, the disclosure of which is incorporated by reference herein.","This invention relates to paging operating systems and, more particularly, to methods and systems of protecting information within paging operating systems.","Computer systems, in general, include a main memory (also known as the computer's \u201cphysical memory\u201d) for storing data and instructions of currently executing programs (\u201cprocess threads\u201d). Typically, the main memory is organized as a plurality of sequentially numbered storage units, each containing a fixed size quantity (e.g. an 8-bit byte in byte oriented computers). The numbering of the storage units (typically in binary or hexadecimal values starting from zero up to the total number of storage units minus one) serve as addresses by which a particular storage unit can be referenced for reading or writing the data contained therein. The set of numbers by which the storage units are addressed is known as the \u201cphysical address space\u201d of the main memory. Main memory typically is realized using semiconductor memory which provides fast, random-access to the various storage units, but requires constant application of electrical energy for operation (i.e. the memory is volatile).","Computer systems also typically provide one or more secondary storage or memory devices which are generally slower than the main memory, but have a much greater storage capacity than the main memory. The secondary storage devices typically store data on a magnetic or optical media that is non-volatile, such as a hard disk. Secondary storage devices generally store data in the form of files or sequential data streams.","Due to the greater speed at which data can be accessed in main memory, data that is currently in use by process threads running on the computer system is desirably stored in the main memory. Due to the smaller storage capacity of the main memory, however, main memory may be unable to store all the information needed by process threads. Accordingly, data that is no longer currently in use is desirably removed from the main memory, or moved from the main memory to the secondary storage devices.","Techniques to efficiently manage the use of the main memory (\u201cmemory management techniques\u201d) by process threads are conventionally known. One standard technique, commonly known as \u201cvirtual memory,\u201d is implemented by many operating systems, usually in cooperation with a computer system's processor. Virtual memory techniques create a separate address space, referred to as the \u201cvirtual address space\u201d or \u201cprocess address space\u201d by which process threads access data in memory. The operating system and processor translates or maps a subset of the virtual addresses in the virtual address space to actual physical addresses in the main memory's physical address space. When a process thread reads or writes data to a virtual address in its virtual address space, the operating system and\/or processor translates the virtual address to a corresponding physical address of a storage unit in the main memory where the data is to be read or written. In Microsoft Corporation's Windows NT operating system, for example, a component called the virtual memory manager implements a separate virtual address space for each process in cooperation with the computer's processor.","Since the virtual address space is typically much larger than the physical address space of the main memory, only a subset of the virtual address space can be resident in main memory at one time. Data not resident in main memory is temporarily stored in a \u201cbacking store\u201d or \u201cpaging\u201d file on the computer's hard disk. When the main memory becomes over committed (i.e. its storage capacity is exceeded), the operating system begins swapping some of the contents of the main memory to the \u201cbacking store\u201d file. When the data is again required by a process thread, the operating system transfers the data back into the main memory from the backing store file. By swapping data that is no longer needed to the hard disk, virtual memory allows programmers to create and run programs that require more storage capacity than is available in the main memory alone.","Moving data between the main memory and the hard disk is most efficiently performed in larger size blocks (as compared to bytes or words). Accordingly, virtual memory techniques generally perform swapping in large size blocks. Microsoft Corporation's Windows NT operating system, for example, divides the virtual address space of each process thread into equal size blocks referred to as \u201cpages.\u201d The main memory also is divided into similar size blocks called \u201cpage frames,\u201d which contain the pages mapped into the main memory. The page size in the Windows NT operating system can vary depending on the requirements of the particular computer on which it is run.","In the Windows NT operating system, each process has a set of pages from its virtual address space that are present in physical memory at any given time. Pages that are currently in the main memory and immediately available are termed \u201cvalid pages.\u201d Pages that are stored on disk (or in memory but not immediately available) are called \u201cinvalid pages.\u201d When an executing thread accesses a virtual address in a page marked \u201cinvalid\u201d, the processor issues a system trap called a \u201cpage fault.\u201d The operating system then locates the required page on the hard disk and loads it into a free page frame in the main memory. When the number of available page frames runs low, the virtual memory system selects page frames to free and copies their contents to the hard disk. This activity, known as \u201cpaging,\u201d is imperceptible to the programmer.","One of the problems that continues to confront so-called paging operating systems, such as the one described above, concerns the treatment of sensitive information (e.g. passwords to access network resources, credit card information used during an Internet shopping session, and the like). For example, when an individual, using a password, logs onto an operating system such as Windows NT, the individual's password can typically be kept in memory for various reasons. For example, if the user locks a work station and wants to later unlock it, the operating system needs to validate against something. Thus, the operating system goes out to main memory and compares what is typed in by a user with what is sitting in the memory. Between these two points in time, however, the password may have entered the paging file because the operating system may have decided that the logon process was idle. Having the password in the paging file can leave it open to attack, e.g. if the machine on which the paging file is located were to be physically stolen. Thus, because of the nature of paging operating systems, sensitive information can sometimes be undesirably placed in a paging file in secondary memory. In security-sensitive installations, preventing the sensitive information from reaching the paging file may be advantageous.","There have been attempts in the past to address the situation of sensitive information making it into the paging file. These attempts have been successful in some respects, but still fall short of the mark insofar as providing a system that is desirably secure and economical to use.","One past approach has been to designate certain pages of the main memory as \u201cpage locked,\u201d and to place sensitive information only in page-locked pages. The \u201cpage locked\u201d designation is a flag that tells the memory manager that the designated page is never to be moved to the paging file. While this ensures that the sensitive information does not make its way to the paging file, it consumes valuable main memory. Because there is a finite amount of main memory available, this approach is not optimal.","Another approach has been to configure the operating system to zero portions of the page file which are no longer associated with allocated memory when the operating system is shut down. This approach is problematic in the event that any of the following two events occurs: (1) power loss\u2014induced or accidental, and (2) pages of memory are still allocated and active that contain sensitive information. In the former case, once power loss has occurred, an attacker can analyze the page file and \u201cundo\u201d any obfuscation as necessary. The operating system never had a change to zero the page file which would normally occur during clean shutdown of the operating system. In the latter case, if the pages of memory are still allocated and active, the operating system will be unable to zero the sensitive information that is contained in such pages.","Yet another approach has been to encrypt the sensitive information with a key that is hard-coded somewhere in the operating system. When the sensitive information is then sent to the hard disk, it will be encrypted and theoretically safe. This approach is not optimal because it is still subject to attack. Specifically, an attacker who accesses the hard disk need only look for data that appears to have been obfuscated with a key and then set about to break the key. Obfuscated or encrypted information can be recognized using a variety of approaches, for example, measuring the entropy of blocks of data. Once the key is broken, all of the encrypted information can be accessed. And, because the key is hard-coded, it never changes. Thus, once it is discovered by an attacker, the attacker can have access to all information that has been or will be encrypted using the hard-coded key.","This invention arose out of concerns associated with providing improved methods and systems for protecting information that is used in paging operating systems.","The inventive methods and systems provide an approach to protecting unencrypted sensitive information from being paged out to secondary memory, such as a hard disk, during paging operations. In the described embodiment, a key is provided and is maintained in the main memory of a virtual memory system. Measures are taken to protect the key such as page-locking the key in the main memory to ensure that it never gets paged out to the secondary memory. The illustrated key is a desirably large key that is randomly generated by the operating system. When sensitive information is to be placed in the main memory, it is encrypted with the page-locked key. The encrypted sensitive information can then be paged out to secondary memory without concern about its security. When the encrypted sensitive information is needed by a process or application, it is retrieved from secondary memory and decrypted using the page-locked key. For further protection, the sensitive information can be decrypted into a page-locked page of main memory. More than one key can be used to encrypt and\/or decrypt the sensitive information.","In one aspect, the encryption\/decryption process can be initiated by one or more applications. The applications initiate the encryption process by calling a software component that handles the encryption\/decryption. In the described embodiment, the software component comprises the operating system kernel. The software component retrieves the page-locked key and performs the encryption on the sensitive information.","In another aspect, the memory manager is closely integrated with the encryption\/decryption process. Specifically, each page in main memory has an attribute that can indicate that it is a secure page. When the memory manager handles secure pages, it is programmed to ensure that the page is encrypted before paging it out to the paging file. All encryption\/decryption thus takes place through the memory manager.","Exemplary Computer System",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 1","b":["130","130","132","134","136","134","132","136","134","138","140","142","130","138"]},"Computer  further includes a hard disk drive  for reading from and writing to a hard disk (not shown), a magnetic disk drive  for reading from and writing to a removable magnetic disk , and an optical disk drive  for reading from or writing to a removable optical disk  such as a CD ROM or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the bus  by an SCSI interface  or some other appropriate interface. The drives and their associated computer-readable media provide nonvolatile storage of computer-readable instructions, data structures, program modules and other data for computer . Although the exemplary environment described herein employs a hard disk, a removable magnetic disk  and a removable optical disk , it should be appreciated by those skilled in the art that other types of computer-readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, random access memories (RAMs), read only memories (ROMs), and the like, may also be used in the exemplary operating environment.","A number of program modules may be stored on the hard disk , magnetic disk , optical disk , ROM , or RAM , including an operating system , one or more application programs , other program modules , and program data . A user may enter commands and information into computer  through input devices such as a keyboard  and a pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are connected to the processing unit  through an interface  that is coupled to the bus . A monitor  or other type of display device is also connected to the bus  via an interface, such as a video adapter . In addition to the monitor, personal computers typically include other peripheral output devices (not shown) such as speakers and printers.","Computer  commonly operates in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be another personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet.","When used in a LAN networking environment, computer  is connected to the local network  through a network interface or adapter . When used in a WAN networking environment, computer  typically includes a modem  or other means for establishing communications over the wide area network , such as the Internet. The modem , which may be internal or external, is connected to the bus  via a serial port interface . In a networked environment, program modules depicted relative to the personal computer , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Generally, the data processors of computer  are programmed by means of instructions stored at different times in the various computer-readable storage media of the computer. Programs and operating systems are typically distributed, for example, on floppy disks or CD-ROMs. From there, they are installed or loaded into the secondary memory of a computer. At execution, they are loaded at least partially into the computer's primary electronic memory. The invention described herein includes these and other various types of computer-readable storage media when such media contain instructions or programs for implementing the steps described below in conjunction with a microprocessor or other data processor. The invention also includes the computer itself when programmed according to the methods and techniques described below.","For purposes of illustration, programs and other executable program components such as the operating system are illustrated herein as discrete blocks, although it is recognized that such programs and components reside at various times in different storage components of the computer, and are executed by the data processor(s) of the computer.","Exemplary Operating System","The described embodiment is illustrated in the context of Microsoft Corporation's Windows NT operating system. For a complete discussion of the Windows NT operating system see \u201cInside Windows NT\u201d, by Helen Custer, Microsoft Press, 1993. A brief overview of part of the general operation of the Windows NT operating system and associated terminology is provided below before discussing the details of the described embodiment.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 2","b":["50","54","56"]},"The kernel mode  is a privileged processor mode in which the operating system code runs with access to system data and to the hardware. Depicted as part of the kernel mode  is the physical computer hardware  itself (e.g. part or all of the computer system of ), since it is only through the kernel mode that these resources can be accessed.","The portion of the operating system depicted as part of the kernel mode  is called the \u201cexecutive\u201d . The executive comprises modules that implement object (resource) management portions of the security system process manager interprocess communication virtual memory management I\/O manager and the cache manager ","The bottommost portions of the executive are called the \u201ckernel\u201d  and the \u201chardware abstraction layer\u201d (\u201cHAL\u201d) . The kernel  performs low-level operating system functions, such as thread scheduling, interrupt and exception dispatching, and multiprocessor synchronization. The hardware abstraction layer (HAL)  is a layer of code that isolates the kernel and the rest of the executive from platform-specific hardware differences. The HAL thus hides hardware-dependent details such as I\/O interfaces, interrupt controllers, and multiprocessor communication mechanisms. Rather than access hardware directly, the components of the executive maintain portability by calling the HAL routine when platform-specific information is needed.","The user mode  is a nonprivileged processor mode in which subsystems\/servers (e.g. subsystem  and Win32 subsystem ) and application programs  and client programs  (hereafter \u201capplications\u201d and \u201cclients,\u201d respectively) run, with a limited set of interfaces available and with limited access to system data.","Each subsystem implements a single set of services, for example, memory services, process creation services, or processor scheduling services. The illustrated Win32 subsystem , for example, makes a 32-bit application programming interface (API) available to application programs. Each subsystem runs in user mode, executing a processing loop that checks whether a client  has requested one of its services. The client  may be another operating system component or an application program.","The executive  is a series of components, each of which implements two sets of functions: system services , which can be called from client programs as well as other executive components, and internal routines, which are available only to components within the executive. System services include (a) the object manager , which is responsible for creating, managing and deleting objects (objects are abstract data structures used to represent operating system resources); (b) the process manager , which is responsible for creating\/terminating processes and threads, and for suspending\/resuming execution of threads; and (c) the I\/O manager , which is responsible for implementing device-independent I\/O facilities as well as device-dependent I\/O facilities.","The client  requests a service by sending a message to a subsystem , as represented by the solid arrow between the depicted Win32 client  and the Win32 subsystem . The message passes through system services  and the executive , which delivers the message to the subsystem. After the subsystem  performs the operation, the results are passed to the client  in another message, as represented by the arrow between the Win32 subsystem and the Win32 client .","In Windows NT, shareable resources, such as files, memory, processes and threads, are implemented as \u201cobjects\u201d and are accessed by using \u201cobject services.\u201d As is well known in the art, an \u201cobject\u201d is a data structure whose physical format is hidden behind a type definition. Data structures, also referred to as records or formats, are organization schemes applied to data so that it can be interpreted and so that specific operations can be performed on that data. Such data structures impose a physical organization on the collection of data stored within computer memory and represent specific electrical or magnetic elements.","An \u201cobject type,\u201d also called an \u201cobject class,\u201d comprises a data-type, services that operate on instances of the data type, and a set of object attributes. An \u201cobject attribute\u201d is a field of data in an object that partially defines that object's state. An \u201cobject service\u201d implements and manipulates objects, usually by reading or changing the object attributes. The object manager is responsible for creating, deleting, protecting, and tracking user application visible objects.","The Windows NT operating system allows users to execute more than one program at a time by organizing the many tasks that it must perform into \u201cprocesses\u201d. The operating system allocates a portion of the computer's resources to each process and ensures that each process's program is dispatched for execution at the appropriate time and in the appropriate order. This function is implemented by the process manager ","Processes can be implemented as objects. A process object comprises the following elements: an executable program; a private address space; system resources (e.g., communication ports and files) that the operating system allocates to the process as the program executes; and at least one \u201cthread of execution.\u201d","A \u201cthread\u201d is the entity within a process that the kernel schedules for execution. As is well known in the art, each thread has an associated \u201ccontext\u201d which is the volatile data associated with the execution of the thread. A thread's context includes the contents of system registers and the virtual address belonging to the thread's process. Thus, the actual data comprising a thread's context varies as it executes. Periodically, a thread may stop executing while, for example, a slow I\/O device completes a data transfer or while another thread is using a resource it needs. Because it would be inefficient to have the processor remain idle while the thread is waiting, a multi-tasking operating system will switch the processor's execution from one thread to another in order to take advantage of processor cycles that otherwise would be wasted. This procedure is referred to as \u201ccontext switching.\u201d When the I\/O device completes its data transfer or when a resource needed by the thread becomes available, the operating system will eventually perform another context switch back to the original thread. Because of the speed of the processor, both of the threads appear to the user to execute at the same time. Threads that execute programs in the user mode, such as the server , the subsystem , the application program , and the client program , are referred to as user mode threads. Threads that execute only operating system components in kernel mode are referred to as kernel mode threads.","The Encryption\/Decryption Key(s)","In the described embodiment, use is made of an encryption\/decryption key(s). The illustrated and described key is a randomly-generated key that is used to encrypt information that might be paged out to the paging file. The key is maintained in main memory and is page-locked so that it cannot be paged out to the secondary memory. Any generation techniques or generators can be used to generate the random key. An exemplary technique comprises RSA RC4 which is used for encryption and decryption using a random 2048 bit (256 byte) cryptographic key. In the described embodiment, this key is used to both encrypt and decrypt the pageable information. It is to be understood, however, that one key might be used to encrypt the information while another key might be used to decrypt the information. In addition, different keys might be used for different purposes. For example, each separate process might have its own unique key that is associated with the process. In addition, identifying information might be encrypted along with the encrypted information to uniquely identify the process that is associated with the particular encrypted information. Then, only the process that is associated with the particular encrypted information can decrypt it.","In the described embodiment, the information-protection process takes place in three separate but related phases\u2014an initialization phase, a protection phase, and an access phase.","Initialization Phase","The initialization phase is described with reference to .  shows an exemplary process address space , main memory , and second memory (paging file) .  shows a flow diagram that describes steps in an initialization method in accordance with the described embodiment. It is to be understood that the described initialization phase constitutes but one way of initializing the protection process and is not intended to limit the scope of protection afforded by this patent.","Step  () begins the boot up process for the computer system. During boot up, the operating system kernel  () allocates a single page of non-pageable memory (step ). In the described embodiment, access to the allocated page is restricted to the software component that does the encryption\/decryption\u2014here, the kernel . Thus, user-mode applications cannot access this memory page. Step  generates an encryption key. An exemplary encryption key was mentioned above. After the encryption key has been generated, step  stores the encryption key in a non-pageable page (i.e. page-locked) of main memory .  shows an exemplary page-locked key at ","The implication of having the key stored in a page-locked page in main memory is that the key can never be paged out to the paging file. This aspect, combined with the nature of the key (i.e. a very large random key) provides a degree of protection that previously was not afforded. For example, if the key cannot be paged out to the paging file, then it is not susceptible to capture. Additionally, because access to the key is restricted to only the kernel , it is further insulated from attack. Moreover, even if the memory protected by the key were to be paged out to the paging file, the sheer size of the key alone would make breaking the protected memory mathematically infeasible in a reasonable amount of time. And, because the key is randomly generated each time the computer is booted up, there is a different key for each new computer session. In addition, in the event of a power loss, the key will be lost from volatile main memory so that any information that is encrypted and present in the secondary memory will effectively be lost as well. All of these factors combine to provide a level of protection that greatly improves on those methods used in the past.","Protection Phase","Once the encryption key has been created and stored as described above, information can now be protected.  shows an example of how this can take place. There, a quantity of information is designated as \u201csensitive information\u201d. Such sensitive information is encrypted with the page-locked key to provide encrypted information The encrypted information is then placed into main memory  in a pageable page. Thus, if and when the pageable page that holds the encrypted information is paged out, it is protected in the paging file .","The information-protection process can be initiated at the application level or at the memory manager level.","Application-Level Initiation",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 5","b":["62","62","62","62"],"i":["a ","b. "]},{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 6","FIG. 5","FIG. 3"],"b":["62","62","208","62","210","102","212","62"],"i":"a "},"Memory Manager-Level Initiation","When the information protection process is initiated at the memory manager level, the memory manager, as  implies, makes the calls to the protect memory interface of kernel . This approach achieves tighter integration with the memory manager. This method alleviates the need for application intervention when dealing with sensitive data.",{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIG. 7","FIG. 3"],"b":["102","214","60","60","216","62","218"],"i":["e ","e ","a "]},"Access Phase","The access phase for accessing a page that has been encrypted and paged out to the paging file is described with reference to . When a process requires use of information that has been encrypted and paged out to the paging file, step  () accesses the encrypted information Step  accesses the page-locked key and uses it to decrypt (step ) the encrypted information. The decrypted information is then placed in main memory  where it can be used by the process.","In the described embodiment, decryption can be initiated at the application level or at the memory manager level. At the application level, the application can call the unprotect memory interface () of kernel . This call causes the kernel to retrieve the information from the paging file, decrypt it using the page-locked key, and then turn the information over to the application or process. At the memory manager level, when the memory manager retrieves an encrypted page from the paging file, it recognizes the designation (i.e. attribute) on the page and calls the unprotect memory interface of the kernel . This call causes the kernel to decrypt the information as mentioned above.","When the information is decrypted and placed into main memory, the page into which it is placed should be zeroed as soon as possible to avoid page file exposure. As an added measure of safety, the decrypted information can be placed into a page-locked page to ensure that it does not inadvertently get paged out to the paging file; when the application is finished with the data, it would zero the memory, and then unlock the memory page, assuming it were locked.","Conclusion","The inventive methods and systems provide degrees of protection for information that might be paged out to a paging file which were heretofore unavailable. The size, nature and handling of the key(s) that is (are) used for encryption greatly increases the protection of pageable information.","Although the invention has been described in language specific to structural features and\/or methodological steps, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or steps described. Rather, the specific features and steps are disclosed as preferred forms of implementing the claimed invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
