---
title: Smart bookmarks for small footprint device applications
abstract: Users of small footprint devices such as smart cellular phones, personal data assistants, etc. may create and store bookmarks referencing various types of objects and/or data sources. Each bookmark may comprise a Uniform Resource Locator (URL) which may be used to refer to the object/data source. The bookmark system may be open-ended, allowing virtually any type of object or data source to be bookmarked. The bookmarks may later be used by a user or application to reference the respective data source to perform some type of action on the data source, such as displaying or editing it. A lightweight application/service containment framework is described which enables services to run on small footprint devices. A bookmark service may cooperate with an activation framework capable of encapsulating various types of entities. In one embodiment, a bookmark service operates in conjunction together with the JavaBeansâ„¢ Activation Framework (JAF) to implement the bookmark functionality.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07017159&OS=07017159&RS=07017159
owner: Sun Microsystems, Inc.
number: 07017159
owner_city: Santa Clara
owner_country: US
publication_date: 19990615
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["1. Field of the Invention","This invention relates generally to computer application programs and small footprint devices. More particularly, the invention comprises a system and method for bookmarking various types of data source objects for use by applications and services running on a small footprint device.","2. Description of the Relevant Art","The field of \u201csmart\u201d small footprint devices is growing and changing rapidly. Small footprint devices include handheld computers, personal data assistants (PDAs), cellular phones, global positioning system (GPS) receivers, game consoles, and many more such devices. These devices are becoming more intelligent and interconnected. Technologies such as Jini\u2122 from Sun Microsystems, Inc. and initiatives such as the Open Service Gateway Initiative (OSGI) are expanding the traditional concepts of computer networks to include small footprint devices.","This increased device interconnection has introduced a need for both new types of computing services and new ways to integrate computing services, both inter-device-based and intra-device-based services. A \u201cservice\u201d is an entity implemented within or accessible from a device that can be used by a person, an application, or another service. The concept of a service is broad and can be considered at many different scales. For example, services include familiar network-based services such as shared printing, email, telephony, etc. Services also include less familiar examples such as an energy management service which may control the power consumption of devices within a local network, a diagnostic service which allows a device to send information to a service technician when an error occurs, a health-monitoring service which immediately notifies health professionals of an emergency, etc.","Services also include modules or applications located and executable within a local machine or device. For example, local application programs may utilize a service to communicate with an HTTP server, an HTML render engine service, a bookmark service, a user interface service, etc. In this example, an application program may use these services together to implement a web browser program.","It is becoming more common today to execute multiple services and applications together in a single small footprint device. However, since memory, processing power, and other resources are typically very limited in small footprint devices, a specialized lightweight service\/application containment framework is necessary to achieve the desired integration of services and applications. It is also desirable that the containment framework be flexible and extendable enough to provide a framework for any types of services and applications for any kind of small footprint device. A further goal may be that the containment framework be compatible and integrated with off-device services such as services available to devices in a Jini\u2122 network. The containment framework described herein achieves the above-stated goals.","The lightweight containment framework may enable small footprint devices such as personal data assistants, smart cellular phones, etc. to run the types of multi-purpose application programs traditionally associated with desktop computing environments. For example, the Personal Applications suite available from Sun Microsystems, Inc. is built around one embodiment of the containment framework. The Personal Applications suite comprises an integrated set of compact, memory-efficient applications, including the Personal Applications Browser, the Personal Applications Email Client, and the Personal Organizer.","As these types of applications become available for small footprint devices, it becomes increasingly desirable to provide a general mechanism to integrate and abstract entities, objects, and data sources used by or implemented in various applications or services. One approach for enabling this type of abstraction and integration is to enable a bookmark service to provide a persistent reference to any of various types of entities, objects, and data sources which may be created or used in application programs or services. For example, a user may bookmark a particular piece of email or a particular contact entry from a contact list for convenient reference later.","Enabling this type of bookmark system is particularly desirable within a small footprint device environment. Such a system may significantly reduce the level of difficulty involved in performing particular operations, since the means for user input on a small footprint device are often very limited. However, implementing this type of bookmark system is also a particular challenge for a small footprint device environment, since a certain level of software infrastructure is necessary to achieve the desired abstraction and generality, yet the software infrastructure must be sufficiently lightweight to run on a small footprint device. A system and method for implementing this type of bookmark system for a small footprint device is described herein.","The present invention enables small footprint device users to create and store bookmarks referencing various types of objects and\/or data sources (collectively referred to herein as data sources). Each bookmark may comprise a Uniform Resource Locator (URL) which may be used to refer to the object\/data source. The bookmark system may be open-ended, allowing virtually any type of object or data source to be bookmarked. The bookmarks may later be used by a user or application to reference the respective data source to perform some type of action on the data source, such as displaying or editing it.","For example, a user may bookmark a particular piece of email from within an email client. In this case, the bookmark may reference some type of encapsulating object, referred to as a data source, which comprises data representing the email. Thus, the bookmark service may cooperate with an activation framework capable of encapsulating various types of entities. The activation framework may assign a type to a data source which distinguishes it from other kinds of data sources. The activation framework may also allow particular \u201cverbs\u201d to be associated with a data source type, and a particular executable module or routine may be associated with a data source type and verb, where the executable module may be invoked to perform the action designated by the verb for a particular data source.","A bookmark service module executes within an application\/service containment framework of a small footprint device, which may be invoked by other applications\/services in order to create and store a bookmark referencing a particular data source. A lightweight application\/service framework for small footprint devices is described below. The bookmark service may operate in conjunction with an activation framework, as described above. In one embodiment, the bookmark service operates in conjunction together with the JavaBeans\u2122 Activation Framework (JAF) to implement the described functionality.","While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and are herein described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.","FIG. \u2014Data Source Examples",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 1","FIG. 1"]},"As illustrated in , a user may bookmark a particular piece of email . For example, the user may select a particular command while reading an email on an email client  which creates a bookmark for the email. The user may later quickly refer to the email using the bookmark. For example, the user may invoke a bookmark service which displays a list of bookmarks.  shows other data sources which may be bookmarked, such as a web page  bookmarked from within a web browser  and an appointment entry  bookmarked from within a personal information manager program .","Bookmarks may be organized in various ways. For example, a system may have a central list  where all bookmarks are kept, or separate applications may have their own bookmark lists, or various combinations of these approaches may be taken. The request to create a bookmark may occur in various situations, such as invoking a bookmark service and selecting a data source to bookmark, or issuing a command from within an application which invokes a bookmark service, etc. In one embodiment, bookmarks may be imported from another system.","The bookmarks of  may reference local or remote data sources. For example, the web page bookmark shown may reference an HTML page stored on a remote server, or the email bookmark shown may reference an email stored on another system.","FIG. \u2014Creating a Bookmark",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 2","FIG. 2"]},"In step  of , the user invokes a bookmark service. For example, a user may issue a pulldown menu command to invoke a bookmark service, and a graphical user interface for the bookmark service may then appear on the display. In step , the user selects a particular data source to bookmark. For example, the user may browse through a directory structure to find a file comprising a particular type of data source, such as a virtual business card, an image, etc. Step  and step  may be combined into a single step. For example, the user may issue a command from within an application which instructs the bookmark service to bookmark a currently selected data source.","In step , the bookmark service creates a bookmark entry referencing the data source selected in step . The bookmark entry comprises information which identifies the particular data source selected in step . In one embodiment the bookmark entry comprises a URL.","In step , the bookmark service stores the bookmark entry created in step . For example, in one embodiment the bookmark entry may be stored in a central list of bookmarks which is accessible from the bookmark service itself and also accessible from other applications running in the system. In another embodiment, the system may maintain separate bookmark lists for different applications or data source types.","FIG. \u2014Referencing a Bookmarked Data Source",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 3","FIG. 3"]},"In step  the user selects a bookmark entry. The bookmark selection may occur in various situations. For example, the user may invoke a bookmark service and select a particular bookmark entry from a list presented to the user by the bookmark service. The user may also select a particular bookmark from within an application, e.g., by selecting a particular menu item from a bookmark menu.","In step  the user selects an action to perform on the data source referenced by the bookmark entry selected in step . For example, a user may select an \u201cedit\u201d action for a bookmarked email, or a \u201cview\u201d action for a bookmarked image, etc. The user may select the action to perform by selecting from a list of possible actions, or the action to perform may be implicit from the context of the user's actions.","In step  an appropriate program module is invoked in order to perform the action specified in step  on the data source referenced by the bookmark entry selected in step . Steps  and  assume that an activation framework is present which enables actions to be defined for data source types and enables particular program modules to be mapped to those actions. In one embodiment, the bookmark service and\/or application programs running within a small footprint device utilize the JavaBeans\u2122 Activation Framework (JAF) to implement steps  and . The JavaBeans\u2122 Activation Framework is described below.","Steps , , and  may be combined into a single step. For example, a user may access a menu from within a personal contact list service which displays a list of bookmarked personal contact entries. A user may then choose a contact entry from the menu, which causes the application to display the contact entry.","JavaBeans\u2122 Application Framework","In one embodiment, the JavaBeans\u2122 Activation Framework (JAF) is utilized to provide the infrastructure to encapsulate data sources, define actions for data sources, etc. This section describes the JavaBeans\u2122 Activation Framework.","The JAF implements several related services including: determining the type of arbitrary data, encapsulating access to data, discovering the operations available on a particular type of data, and instantiating the software component that corresponds to the desired operation on a particular piece of data. The JAF is packaged as a Standard Extension to the Java\u2122 platform.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 4","b":"60"},"The DataHandler  class shown in  provides a consistent interface between JAF-aware clients and other subsystems.","The DataSource  interface encapsulates an object that contains data, and that can return both a stream providing data access, and a string defining the MIME type describing the data. Classes can be implemented for common data sources (web, file system, IMAP, ftp etc.). The DataSource interface can also be extended to allow per data source user customizations. Once the DataSource is set in the DataHandler, the client can determine the operations available on that data.","The JAF includes two DataSource class implementations for convenience:\n\n","The CommandMap  provides a service that allows consumers of its interfaces to determine the \u2018commands\u2019 available on a particular MIME Type as well as an interface to retrieve an object that can operate on an object of a particular MIME Type (effectively a component registry). The Command Map can generate and maintain a list of available capabilities on a particular data type by a mechanism defined by the implementation of the particular instance of the CommandMap.","The JavaBeans\u2122 package provides the programming model for the software components that implemented the commands. Each JavaBeans\u2122 component can use externalization, or can implement the CommandObject interface to allow the typed data to be passed to it.","The JAF defines the CommandMap interface, which provides a flexible and extensible framework for the CommandMap. The CommandMap interface allows developers to develop their own solutions for discovering which commands are available on the system. A possible implementation can access the \u2018types registry\u2019 on the platform or use a server-based solution. The JAF provides a simple default solution based on RFC 1524 (.mailcap) like functionality.","Beans extend the CommandObject  interface in order to interact with JAF services. JAF-aware JavaBeans\u2122 components can directly access their DataSource and DataHandler objects in order to retrieve the data type and to act on the data.","Using the JAF Framework","The \u2018canonical\u2019 consumer of the JAF framework accesses it through the DataHandler (although the major subsystems are designed to also operate independently). An underlying DataSource object is associated with the DataHandler when the DataHandler class is constructed. The DataHandler retrieves the data typing information from the DataSource or gets the data type directly from the constructor. Once this initialization step is complete, request a list of commands that can be performed on the data item can be accessed from the DataHandler.","When an application issues a request for this list, the DataHandler uses the MIME data type specifier returned, in order to request a list of available commands from the CommandMap object. The CommandMap has knowledge of available commands (implemented as Beans) and their supported data types. The CommandMap returns a subset of the full list of all commands based on the requested MIME type and the semantics of the CommandMap implementation, to the DataHandler.","Ultimately when the application wishes to apply a command to some data, it is accomplished through the appropriate DataHandler interface which uses the CommandMap to retrieve the appropriate Bean which is used to operate on the data. The container (user of the framework) makes the association between the data and the Bean.","JAF Usage Scenarios","This scenario uses the example of a hypothetical file viewer application in order to illustrate the normal flow of tasks involved when implementing the JAF. The file viewer is similar to CDE's \u2018dtfile,\u2019 or to the Windows 95 Explorer utility. When launched, it presents the user with a display of available files. It includes a function like CDE's dtfile or Explorer's \u2018right mouse\u2019 menu, where all operations that can be performed on a selected data item are listed in a popup menu for that item.","A typical user launches this application to view a directory of files. When the user specifies a file by clicking on it, the application displays a popup menu which lists the available operations on that file. File system viewer utilities normally include \u2018edit,\u2019 \u2018view,\u2019 and \u2018print\u2019 commands as available operations. For instance selecting \u2018view\u2019 causes the utility to open the selected file in a viewer which can display data of the data type held in that file.","Description of tasks performed by the application is broken down into three discrete steps, for clarity:\n\n","One of the interfaces mentioned below is the \u2018DataSource\u2019 object. The DataSource object encapsulates the underlying data object in a class that abstracts the underlying data storage mechanism, and presents its consumers with a common data access and typing interface. The file viewer application queries the file system for its contents.","The viewer instantiates a DataSource object for each file in the directory. Then it instantiates a a DataHandler with the DataSource as its constructor argument. A DataHandler cannot be instantiated without a DataSource. The DataHandler object provides the client application with access to the CommandMap, which provides a service that enables access to commands that can operate on the data. The application maintains a list of the DataHandler objects, queries them for their names and icons to generate its display.","\/\/ for each file in the directory:","File file=new File(file_name);","DataSource ds=new FileDataSource(file);","DataHandler dh=new DataHandler(ds);","Getting the Command List","Once the application has been initialized and has presented a list of files to the user, the user can select a file on the list. When the user selects a file, the application displays a popup menu that lists the available operations on that file.","The application implements this functionality by requesting the list of available commands from the DataHandler object associated with a file. The DataHandler retrieves the MIME Type of the data from the DataSource object and queries the CommandMap for operations that are available on that type. The application interprets the list and presents it to the user on a popup menu. The user then selects one of the operations from that list.",{"@attributes":{"id":"p-0066","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ get the command list for an object"]},{"entry":[{},"CommandInfo cmdInfo[ ] = dh.getPreferredCommands( );"]},{"entry":[{},"PopupMenu popup = new PopupMenu(\u201cItem Menu\u201d);"]},{"entry":[{},"\/\/ populate the popup with available commands"]},{"entry":[{},"for(i = 0; i < cmdInfo.length; i++)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"popup.add(cmdInfo[i].getCommandName( ));"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ add and show popup"]},{"entry":[{},"add(popup);"]},{"entry":[{},"popup.show(x_pos, y_pos);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"After the user has selected a command from the popup menu, the application uses the appropriate CommandInfo class to retrieve the Bean that corresponds to the selected command, and associates the data with that Bean using the appropriate mechanism (DataHandler, Externalization etc.). Some CommandObjects (viewers for instance) are subclassed from java.awt.Component and require that they are given a parent container. Others (like a default print Command) might not present a user interface. This allows them to be flexible enough to function as stand alone viewer\/editors, or perhaps as components in a compound document system. The \u2018application\u2019 is responsible for providing the proper environment (containment, life cycle, etc.) for the CommandObject to execute in.",{"@attributes":{"id":"p-0068","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ get the command object"]},{"entry":[{},"Object cmdBean = cmdInfo[cmd_id].getCommandObject(dh,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"this.getClassLoader( ));"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"... \/\/ use serialization\/externalization where appropriate"]},{"entry":[{},"my_awt_container.add((Component)cmdBean);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"The first scenario was the \u2018canonical\u2019 case. There are also circumstances where the application has already created objects to represent its data. In this case creating an in-memory instance of a DataSource that converted an existing object into an InputStream is an inefficient use of system resources and can result in a loss of data fidelity.","In these cases, the application can instantiate a DataHandler, using the DataHandler(Object obj, String mimeType) constructor. DataHandler implements the Transferable interface, so the consuming Bean can request representations other than InputStreams. The DataHandler also constructs a DataSource for consumers that request it. The DataContentHandler  mechanism is extended to also allow conversion from Objects to InputStreams.","The following code is an example of a data base front end using the JAF, which provides query results in terms of objects.",{"@attributes":{"id":"p-0072","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/**"},{"entry":"* Get the viewer to view my query results:"},{"entry":"*\/"},{"entry":"Component getQueryViewer(QueryObject qo) throws Exception {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"String mime_type = qo.getType( );"]},{"entry":[{},"Object q_result = qo.getResultObject( );"]},{"entry":[{},"DataHandler my_dh = new DataHandler(q_result, mime_type);"]},{"entry":[{},"return (Component)my_dh.getCommand(\u201cview\u201d).getCommandObject(my_dh,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"null));"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"interface DataSource: The DataSource interface provides the JavaBeans\u2122 Activation Framework with an abstraction of some arbitrary collection of data. It provides a type for that data as well as access to it in the form of InputStreams and OutputStreams where appropriate.","class DataHandler: The DataHandler class provides a consistent interface to data available in many different sources and formats. It manages simple stream to string conversions and related operations using DataContentHandlers. It provides access to commands that can operate on the data. The commands are found using a CommandMap.","interface DataContentHandler: The DataContentHandler interface is implemented by objects that can be used to extend the capabilities of the DataHandler's implementation of the Transferable interface. Through DataContentHandlers the framework can be extended to convert streams in to objects, and to write objects to streams.","interface DataContentHandlerFactory: This interface defines a factory for DataContentHandlers. An implementation of this interface should map a MIME type into an instance of DataContentHandler. The design pattern for classes implementing this interface is the same as for the ContentHandler mechanism used in java.net.URL.","class CommandMap: The CommandMap class provides an interface to the registry of viewer, editor, print, etc. objects available in the system. Developers are expected to either use the CommandMap implementation included with this package (MailcapCommandMap) or develop their own. Note that some of the methods in this class are abstract.","interface CommandObject: Beans that are Activation Framework aware implement this interface to find out which command verb they're being asked to perform, and to obtain the DataHandler representing the data they should operate on. Beans that don't implement this interface may be used as well. Such commands may obtain the data using the Externalizable interface, or using an application-specific method.","class CommandInfo: The Commandlnfo class is used by CommandMap implementations to describe the results of command requests. It provides the requestor with both the verb requested, as well as an instance of the bean. There is also a method that will return the name of the class that implements the command but it is not guaranteed to return a valid value. The reason for this is to allow CommandMap implmentations that subclass CommandInfo to provide special behavior. For example a Framework Deliverables","JAF Framework Auxiliary Classes","class FileDataSource: The FileDataSource class implements a simple DataSource object that encapsulates a file. It provides data typing services via a FileTypeMap object.","class FileTypeMap: The FileTypeMap is an abstract class that provides a data typing interface for files. Implementations of this class will implement the getContentType methods which will derive a content type from a file name or a File object. FileTypeMaps could use any scheme to determine the data type, from examining the file extension of a file (like the MimetypesFileTypeMap) to opening the file and trying to derive its type from the contents of the file. The FileDataSource class uses the default FileTypeMap (a MimetypesFileTypeMap unless changed) to determine the content type of files.","class MimetypesFileTypeMap: This class extends FileTypeMap and provides data typing of files via their file extension. It uses the .mime.types format. class URLDataSource: The URLDataSource class provides an object that wraps a URL object in a DataSource interface. URLDataSource simplifies the handling of data described by URLs within the JavaBeans\u2122 Activation Framework because this class can be used to create new DataHandlers.","class MailcapCommandMap: MailcapCommandMap extends the CommandMap abstract class. It implements a CommandMap whose configuration is based on mailcap files (RFC 1524). The MailcapCommandMap can be configured both programmatically and via configuration files.","class ActivationDataFlavor: The ActivationDataFlavor is a special subclass of java.awt.datatransfer.DataFlavor. It allows the JAF to set all three values stored by the DataFlavor class via a new constructor as well as improved MIME parsing in the equals method. Except for the improved parsing, its semantics are identical to that of the JDK's DataFlavor class.","class UnsupportedDataTypeException: Signals that requested operation does not support the requested data type.","class MimeType: A Multipurpose Internet Extension (MIME) type, as defined in RFC 2045 and 2046.","Small Footprint Device Application\/Service Containment Framework","As described above, the bookmark service or another application\/service running on a small footprint device, such as a personal contact list service, may invoke a separate service module to perform an action selected by a user for a particular data source. Since the system may open-ended, allowing various actions to be defined for various types of data sources, it may be necessary or desirable for the small footprint device software applications\/services to be based on a modular, extendable, lightweight application\/service containment framework. Such a containment framework is described below.","FIG. \u2014Hardware Architecture Block Diagram",{"@attributes":{"id":"p-0088","num":"0092"},"figref":"FIG. 5"},"It is noted that the specific numbers given are exemplary only and are used for comparison purposes. For example, a personal data assistant having eight megabytes of memory or more may still be a small footprint device, although the device has more memory than the typical figure of two megabytes given above.","Small footprint devices may also have constraints on other resource types compared to typical desktop computing systems, besides the memory, processor, and display size resources described above. For example, a typical small footprint device may not have a hard disk, may not have a network connection, or may have an intermittent network connection, or may have a wireless network connection, etc.","Many small footprint devices are portable and\/or are small compared to desktop computers, but are not necessarily so. Also, many small footprint devices are primarily or exclusively battery-operated. Also, small footprint devices may typically have a more limited or narrow range of usage possibilities than a typical desktop computing system. Small footprint devices include, but are not limited to, the following examples: handheld computers, wearable devices (e.g., wristwatch computers), personal data assistants (PDAs), \u201csmart\u201d cellular telephones, set-top boxes, game consoles, global positioning system (GPS) units, electronic textbook devices, etc. Since new classes of consumer devices are rapidly emerging, it is not possible to provide an exhaustive list of small footprint devices. However, the term \u201csmall footprint device\u201d is intended to include such devices as may reasonably be included within the spirit and scope of the term as described above.",{"@attributes":{"id":"p-0092","num":"0096"},"figref":"FIG. 5"},"As shown in , the small footprint device contains a processor . The processor  may be any of various types, including an x86 processor, e.g., a Pentium class, a PowerPC processor, as well as other less powerful processors or processors developed specifically for small footprint devices. The processor  may have various clock speeds, including clock speeds similar to those found in desktop computer-class processors, as well as lower speeds such as 16 MHz.","Also shown in  the device includes a system memory . The system memory  may comprise memory of various types including RAM or ROM. A typical small footprint device may have a very small memory storage capacity compared to a typical desktop computer system.","A small footprint device may also comprise one or more input mechanisms. An input mechanism  is illustrated in . The input mechanism  may be any of various types, as appropriate to a particular device. For example, the input mechanism may be a keypad, mouse, trackball, touch pen, microphone, etc.","A small footprint device may also comprise one or more display mechanisms. A display  is illustrated in . However, a small footprint device may not comprise a display, or may comprise another type of output mechanism, such as an audio speaker. The display mechanism  may be any of various types, as appropriate to a particular device. The display mechanism for a typical small footprint device, such as a smart cellular phone, may be small compared to the display of a desktop computer system.","FIG. \u2014Hardware\/Software Hierarchy Diagram",{"@attributes":{"id":"p-0097","num":"0101"},"figref":"FIG. 6"},"The base layer shown in  is the device hardware layer , which comprises the hardware resources necessary to support a software system, such as a processor and system memory. In one embodiment, the hardware of a small footprint device, such as the small footprint device hardware example illustrated in , implements the hardware layer  illustrated in . However, in other embodiments, the hardware layer  may be implemented in other types of devices, such a device with even greater resource constraints than a typical small footprint device, such as a smart card.","As shown in , the next layer up from the hardware layer is the operating system layer . As is well known in the art, the operating system functions as an interface layer between the device hardware and software running on the device and serves as a manager for low-level tasks such as input\/output, memory management, etc. The operating system  illustrated in  may be any particular operating system which supports the higher layers shown in . The operating system  may be a small and efficient one that is suitable for or written particularly for use in a small footprint device. For example, the operating system  may be the JavaOS operating system available from Sun Microsystems, Inc.","In one embodiment, the containment framework is implemented in a Java\u2122 application environment as one or more Java\u2122 classes. As shown in , the Java\u2122 virtual machine layer  and Java\u2122 application programming interface (API) class libraries layer  are the next layers up from the operating system. These two layers together make up the Java\u2122 application environment, or Java\u2122 platform. Classes implementing the containment framework may be built using the Java\u2122 libraries  and compiled into bytecodes. The bytecodes are instructions which execute on the Java\u2122 virtual machine , which interacts with the operating system  and\/or the device hardware .","In one embodiment, the containment framework is implemented in the PersonalJava Java\u2122 application environment, which is a Java\u2122 platform designed to be highly scalable, modular, and configurable, while requiring minimal system resources. PersonalJava\u2122 comprises the Java\u2122 virtual machine and a subset of the Java\u2122 API, including core and optional APIs and class libraries. In addition, the PersonalJava\u2122 API includes specific features required by consumer applications in resource-limited environments, such as a specialized version of the Java\u2122 abstract window toolkit (AWT). The PersonalJava\u2122 AWT library is targeted and tuned for consumer product look and feel, providing graphics and windowing features while supporting low-resolution displays and alternate input devices (via an extended event model for mouse- and keyboard-less devices).","Referring again to , the containment framework  is shown as the next layer up from the Java\u2122 platform layer. As noted above, the containment framework  may also be based on other platforms. As described in detail below, the containment framework  manages program modules, e.g. by enabling module registration, lookup, instance tracking, etc. Modules may provide various services. The containment framework  enables modules to request other modules, in order to use their services. Applications may be implemented as modules that utilize the services of other modules. The containment framework  thus provides a lightweight, extendable service and application framework, enabling applications to coexist and share a modular code base.","This type of extendable architecture enabling multiple program modules to cooperate is an important development for small footprint devices. Small footprint devices have historically been limited to relatively narrow uses. For example, cellular phones were typically used for telephony and little else. However, as various technologies are developed allowing small footprint devices to become \u201csmarter\u201d, having general-purpose processors, larger display screens, etc., it has become desirable to expand the scope of applications used in small footprint devices.","The present containment framework may enable the types of applications and services generally associated with desktop computing environments to work together in a small footprint device, in a manner that desktop computer users are familiar with. As illustrated in  and described above, services and applications  running on a small footprint device may be implemented as modules built on the containment framework layer . For example, the Personal Applications suite available from Sun Microsystems, Inc. is built using one embodiment of the containment framework . The Personal Applications Suite comprises an integrated set of applications such as a browser, an email client, and a personal organizer.",{"@attributes":{"id":"p-0105","num":"0109"},"figref":["FIG. 6","FIG. 7"],"b":["128","132","130","128"]},{"@attributes":{"id":"p-0106","num":"0110"},"figref":"FIGS. 7\u201311"},{"@attributes":{"id":"p-0107","num":"0111"},"figref":"FIG. 7","b":["134","144","130","132","130","132","138","136","136"]},"The federation of devices and services may be implemented in various ways. For example, Jini\u2122 technology, available from Sun Microsystems, Inc., comprises components and a programming model which enables the type of distributed system illustrated in . In one embodiment, the local network shown in  may be a Jini\u2122 network, and the printer  and internet television  may be Jini\u2122-enabled devices. Each device is operable to find the Jini\u2122 network lookup service and register the services it offers with the lookup service. The lookup service maps interfaces indicating the functionality provided by a service to sets of objects that implement the service.","To add its services to a service federation, a device or other service provider may first locate an appropriate lookup service by using a \u201cdiscovery\u201d protocol.  illustrates the discovery process. As shown, the service provider , e.g. the printer  shown in , may broadcast a request on the local network for any lookup services to identify themselves.","Once the service provider  has located the lookup service , the service provider  may register its service with the lookup service  by using a \u201cjoin\u201d protocol.  illustrates the join process. The service provider  may create a service object which clients can use to invoke the service. As illustrated in , the service object for the provided services may then be loaded into the lookup service , along with service attributes or descriptors containing information about the types or names of services provided. For example, in a Jini\u2122 network, the printer  shown in  may create a service object which comprises a Java\u2122 programming interface for the print service . The printer  may then call a \u201cregister\u201d method of the lookup service , passing this service object, along with attributes which specify that the service  being registered is a print service, the printing resolution, the possible paper sizes, etc.","Once the service provider  has joined its services with the lookup service , other network clients may request and use the services. The process of requesting a service, called lookup, is illustrated in . After discovering the lookup service, a client  may request a service from the lookup service  using a description of the requested service. The lookup service  attempts to match the description given by the requestor to the services that have joined the lookup service. The lookup service  may use the service attributes sent by the service provider  during the join process to perform this matching. If a match is found, the lookup service  provides the appropriate service object to the client . For example, a Java\u2122 interface for the requested service may be provided to the client .","Once a client  has received a service object from the lookup service, the client may invoke the service.  illustrates the process of service invocation. When a service is invoked, the client  and the service provider  may communicate directly with each other. Any of various interaction protocols may be used for this communication. For example, the protocol used may be Java\u2122 Remote Method Invocation (RMI), CORBA, DCOM, etc. The service object that a client receives from the lookup service may call back to code located at the service provider, e.g. by calling an RMI method, or it may execute locally to provide the requested service, or it may use a combination of these approaches.","As shown in , the lookup service  for a local network may also act as a gateway to an outside network such as the Internet . The service-based distributed computing model may thus be extended to include clients and services located outside the local network. For example, the technology being developed for the Open Service Gateway Initiative (OSGI) may be leveraged to implement this type of distributed computing system.","This type of service sharing between and across different networks and the Internet may enable new types of applications to be developed. For example, merchants may use Internet services to record data about specific consumers, and advertising service providers may use this data to push context-specific ads onto consumer devices, depending on which local network the device is connected to, etc. For example, a customer may enter a shopping mall and connect a personal data assistant (PDA) into a local network for the shopping mall, via a wireless connection. An Internet-based consumer data service may be joined with the lookup service for the shopping mall network and may provide information about the specific consumer who has just plugged into the mall network. Services running in the shopping mall network may then use this data together with other factors such as the customer's current location within the mall, the time of day, etc., in order to generate personalized ads and push them onto the customer's PDA.","Many other examples of services based on the network of  are possible. For example: network-enabled consumer devices within a home may utilize a service provided by a power company, via the Internet, which manages power consumption within the home; security service providers may monitor a home or specific devices via network services and may notify the owner immediately when property is broken into; health service providers may remotely monitor a patient's state by communicating with medical instruments; etc.","In the examples listed above, an assumption is made that devices are able to transparently connect to a network, integrate network services with device-resident services, and export device-resident services for use by network clients. The containment framework described herein may provide the necessary interface to integrate services and applications of small footprint devices such as personal data assistants, handheld computers, smart cellular phones, etc. with a network service federation.","As shown in  and described in more detail below, the containment framework  has its own type of lookup service . The lookup service  within the containment framework  may operate similarly to the local network lookup service described above, utilizing discovery, join, lookup, and service invocation processes. For example, the personal organizer application  may utilize various services such as a calendar service, a contact list service, a bookmark service, etc. (not shown). The personal organizer application  may obtain a reference for communicating with these services via the containment framework lookup service .","The containment framework  may integrate its own lookup service  with an off-device lookup service such as the local network lookup service  shown in . In this way, off-device services such as the print service  and the web service  may become available to the applications\/services , , and  of the containment framework, and vice versa. For example, the personal organizer application  may request a print service from the containment framework lookup service . The containment framework lookup service  may first search for an on-device print service. If one is not found, the containment framework lookup service  may then request a print service from the network lookup service . The service object for the print service  may then be returned to the personal organizer . An interface  between the on-device services\/applications and the off-device services is illustrated in . Details follow on how the integration of on-device\/off-device services may be implemented.","As noted above, clients of services may themselves be services to other clients. For example, the email client \u201capplication\u201d  of the smart cellular phone shown in  may itself be a service to a client running in the containment framework  or to a network client. For example, in the case of malfunction, the printer  shown in  may request an email service so that it can send diagnostic information to a service technician. If the network lookup service  cannot find a network-based email service, it may request an email service from the smart cellular phone  via the interface . A service object for the email application\/service  running in the containment framework  may be passed to the requesting printer client . In this example, the printer client  may communicate directly with the email application\/service  to send an email containing diagnostic information to a printer service technician. The email application\/service  may send the email immediately if it is able to find an email server service, or it may send the email later when such a service becomes available when the cellular phone user connects to a different network.","Although the above description references specific protocols and programming models, such as Jini\u2122 technology, it is noted that these specific technologies are exemplary only. For example, the applications and services within the containment framework may be integrated with clients, services, devices, networks, etc. which employ any of various types of standards, protocols, and programming models, including, but not limited to: Jini\u2122, CORBA, COM\/DCOM, Bluetooth, CAL, CEBus, HAVi, Home API, HomePNA, HomePnP, HomeRF, VESA, etc.","FIG. \u2014Containment Framework Block Diagram",{"@attributes":{"id":"p-0121","num":"0125"},"figref":["FIG. 12","FIG. 12","FIG. 12","FIG. 12"],"b":["170","170"]},"As shown in , the central framework instance  comprises data  representing the modules currently loaded in the system. The containment framework architecture is non-hierarchical. Thus, the loaded modules may be represented as a flat list or array of modules. This non-hierarchical system helps to keep the core containment framework code and the modules running within the framework compact. Systems employing hierarchical components such as JavaBeans\u2122 components may provide associated benefits, but the benefits come at the expense of a more complex management system requiring more system resources. However, the containment framework does provide a mechanism for the non-hierarchical modules to gain many of the benefits of a hierarchical containment system. This mechanism is described below for .","As shown in , in one embodiment the central framework instance  comprises publicly accessible methods  which modules may call. These methods may be broken into abstract groups. For example, one group of methods  may comprise lookup methods. Lookup methods implement the lookup service functionality described above. Modules may pass a module descriptor to a lookup method of the central framework instance  to locate a particular service module. The containment framework lookup process is described below for . Another group of framework methods  may comprise methods for loading and unloading modules. After finding a service module, a client module may request the central framework instance  to load the service module and return a reference to the loaded module. The client module may then invoke the service. The client may call a framework method to release the service module when it is finished using it. Although described as distinct groups, the division of methods into lookup and load\/unload groups may be only a conceptual division. For example, in one embodiment a lookup method may also load a module that it matches and return a reference to the matched module.",{"@attributes":{"id":"p-0124","num":"0128"},"figref":"FIG. 12","b":["180","182","176","170","180","180","180"]},"After receiving a reference to the core system data , a system module may use or modify the data in any way desirable. Thus, the containment framework is highly extendable. The central framework instance  may itself remain small, and system modules may be added to implement any functionality not already enabled by the central framework instance . For example, a system module may enable the integration described above for  between applications\/services running within the containment framework and services based in an external network.","In this example, such a system module may be written as a secondary lookup service that conforms to the protocols and programming model of the external network. For example, for a Jini\u2122 network, a system module may be written which discovers the Jini\u2122 network lookup service and joins the network lookup service, registering itself as a secondary lookup service. When a network client requests a service, the network lookup service may invoke the lookup service implemented by the system module. This system module may attempt to find a service module within the containment framework which matches the description of the requested service. If a match is found, then the system module may perform any necessary steps to export the service module to the network client, since the system module has full access to the system module list and metadata. For example, the system module may load and register the matched service module into the system and return an interface, such as a Java\u2122 interface, to the newly loaded module to the requester.","FIGS.  and \u2014Simulating a Hierarchical Environment","It is often desirable to establish a hierarchical context for modules. For example, several service modules of the same type may be present in a system, but each may behave slightly differently. In a hierarchical containment system, a request by a module for a service may be filtered through a parent or containing module of the requesting module so that a reference to a specific service module may be passed back to the requestor. Hierarchical containment also has other inherent advantages, such as an ability to easily distribute and store data among a hierarchy of modules. However, as stated above, a full implementation of a hierarchical containment system may be very costly in terms of the system resources required, such as memory and processing power. The containment framework may provide a mechanism giving developers and applications many of the benefits of hierarchical containment, but without the high overhead costs usually associated with it.","For example, one embodiment of the containment framework allows modules to register themselves as module request listeners of other modules. For example, a module A may register itself as a request listener of a module B, e.g., by calling an AddRequestListener method of the central framework instance. When module B subsequently calls a method of the central framework instance to find a particular service, the central framework instance checks for any module request listeners for module B. In this case, it finds module A as a request listener, and asks module A to provide the requested service module to module B.",{"@attributes":{"id":"p-0129","num":"0133"},"figref":["FIGS. 13 and 14","FIG. 13"],"b":["192","194","190","192","194","190"]},"Although the containment framework utilizes a non-hierarchical containment model, the hierarchy illustrated in  may be realized by registering the print manager module  as a module request listener of client modules that may request a print service.  illustrates example modules  which may run in a system. As described earlier, these modules may themselves employ other modules as services. According to the non-hierarchical model of the containment framework, the modules are shown arranged in a flat layout, with no inherent module hierarchy.","In this example, the web browser module  may be operable to make a print request, e.g., for printing a web page. As shown in , the print manager module  may be registered as a module request listener for the web browser module . Upon receiving the print service request from the web browser , the containment framework lookup service may find the print manager module  registered as a request listener for the web browser module  and may ask the print manager module  to provide a print service module to the web browser requestor . The print manager module  may then return a reference to print service module A  or print service module B , or the print manager module  may present a dialog box to the user to decide which print service module to return, etc. Thus, the desired module hierarchy of  may be implemented for non-hierarchical modules of the containment framework.","FIG. \u2014Parcel Packaging Units","Modules may be packaged into units referred to as parcels. This packaging serves several purposes. For example, parcels provide a convenient mechanism to manage related code and data as a unit. If closely related modules have static dependencies, then they may be packaged together into a parcel. Parcels may be used to handle installation and upgrading within a system.",{"@attributes":{"id":"p-0133","num":"0137"},"figref":"FIG. 15","b":["200","202","204","208","206","200"]},"Parcels also provide an additional way to provide a run-time context for non-hierarchical modules. When a module is loaded into the system, the central framework instance may store metadata specifying which parcel, if any, the module belongs to. Service modules may later use this information to provide services differently for different client modules, depending on which parcel the client belongs to. For example, client modules may use a file access service module to obtain a root directory. The file access module may return different root directories for different clients, depending on which parcels the clients belong to.","FIG. \u2014Module Request Flowchart Diagram",{"@attributes":{"id":"p-0135","num":"0139"},"figref":["FIG. 16","FIG. 16"]},"In step  of , the central framework instance receives a module lookup request from a requester module. For example, the requestor module may call a RequestModule method of the central framework instance, passing a module descriptor for the service module being requested, as well as a reference to the requestor module itself. The reference to the requestor module may be added to the system data so to keep track of service module users. As described in more detail below, a module may be unloaded when no other modules are using it.","The module descriptor passed by the requestor module specifies various attributes about the requested module that the framework instance can use to attempt to find a matching module. This module descriptor may be an object which comprises information such as the requested module's service type, class name, and\/or service-specific attributes, etc. The requestor may also pass a text description to the central framework instance, which the central framework instance may use to create a module descriptor object.","In step , the central framework instance checks to see whether any request listener modules are registered for the requesting module. If a request listener is found, then in step  the framework instance notifies the request listener of the request and instructs the request listener to attempt to provide a module which matches the module request descriptor. If the request listener can provide a matching module, then execution proceeds to step . Otherwise, other registered request listeners may be asked to provide a module, until a match is found or there are no more request listeners.","If no request listeners are found, or if no request listeners can provide the requested module, execution proceeds to step . However, in one embodiment, if one or more request listeners are registered for the requesting module, and none of them are able to provide a matching module, then execution may stop after step . In step , the central framework instance checks the list of modules to determine whether one of the modules matches the module descriptor. If a match is found, then in step  the framework instance checks whether the matched module is multi-instantiable. If not, then execution proceeds to step .","If the matched module is found to be multi-instantiable in step , then the central framework instance may continue to search through the module list for a match. If there are no more modules to search, execution proceeds to step . In step , the framework instance searches for module-provider modules in the module list. Module-provider modules are modules capable of providing a requested module. For example, a network lookup service may be imported as a module-provider module for the containment framework.","If a module-provider module is found, then in step , the central framework instance notifies the module-provider module of the request and instructs it to attempt to provide a module which matches the module request descriptor. If a match is found then execution proceeds to step . If the module provider cannot provide the requested module, the central framework instance may search for other module-provider modules and repeat step . If no module providers are present in the module list or if none can provide the requested module, then the requestor is notified that the request cannot be fulfilled, and execution completes.","Step  may be reached from step , , or . In all cases, a module is found which matches the module request descriptor. In step  the requestor is registered as a user of the matched module, and in step  a reference to the matched module is returned to the requester. Any necessary initialization steps involved in loading and initializing the matched module are also performed in step . For example, modules may have an Initialize method that is called when a module is loaded.","As noted above, the flowchart of  is exemplary, and various embodiments may have different lookup\/load scenarios. For example, a module may call a central framework method to load a service module without returning a reference to the matched module, or request listeners may be ignored in some cases, etc.","FIG. \u2014Module Release Flowchart Diagram","When a client module is finished using a service module, the client may call a method of the central framework instance to release the module.  is a flowchart diagram illustrating the module release process. The flowchart of  is exemplary, and various steps may be combined, omitted, added, or modified as required or desired for different embodiments.","In step , the central framework instance receives a module-release notice from a user module. As described above for , when a user module requests a service module, the user module is added to a list of users of the service module. In step , the central framework instance removes the releasing user module from the list of users of the released module. In step , the framework instance determines whether any other user modules are using the released module, e.g., by checking whether other modules are present in the releases module's user module list. If so, then execution stops.","If no other modules are using the released module, the central framework instance may attempt to unload the released module. In step , the framework instance may call a CanFinalize method of the released module. The CanFinalize method returns true if the module can be unloaded, or false otherwise. If the CanFinalize method returns false in step , then execution stops. Otherwise, a Finalize method of the released module may be called. The Finalize method may perform any necessary steps for unloading the module, such as releasing resources. The module may then be unloaded, which may involve garbage-collection, etc., depending on the particular embodiment.","Although the present invention has been described in connection with specific embodiments, it is not intended to be limited to the specific forms set forth herein, but on the contrary, it is intended to cover such alternatives, modifications, and equivalents, as can be reasonably included within the spirit and scope of the invention as defined by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 13 and 14"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 17"}]},"DETDESC":[{},{}]}
