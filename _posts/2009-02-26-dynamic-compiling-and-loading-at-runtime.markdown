---
title: Dynamic compiling and loading at runtime
abstract: A compiler is loaded by a computing device using an evaluation function that is included in a program in a compiled form. The evaluation function causes the compiler to compile source code for the program, wherein the source code includes new instructions that are uncompiled, and wherein compiling the source code generates compiled code that includes the new instructions. The evaluation function loads the compiled code into memory, retrieves the new instructions, and executes the new instructions. The evaluation function may perform these operations during runtime of the program that includes the evaluation function.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09134973&OS=09134973&RS=09134973
owner: Red Hat, Inc.
number: 09134973
owner_city: Raleigh
owner_country: US
publication_date: 20090226
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","DETAILED DESCRIPTION"],"p":["Embodiments of the present invention relate to dynamic loading, and more specifically to dynamically compiling and loading source code at run time.","A programming language is an artificial language designed to express computations that can be performed by a machine such as a computer. All programming languages translate code from human readable form to a non-human readable form. There are loosely two common classes of programming languages: interpreted languages and compiled languages. In a compiled language, source code is translated directly into a machine readable code (code that contains instructions that can be executed by a particular physical or virtual machine) once. Examples of compiled languages include C, C++ and Java. In an interpreted language, source code is translated into an intermediate form that is later further translated to machine readable code each time the code is to be run. Examples of interpreted languages include Perl and command shells.","The distinction between compilers and interpreters is blurred by languages that translate human readable source code into machine readable form that's not actually machine code (e.g., Java). An important distinction between compiled languages such as Java and interpreted languages (e.g., Perl) is based on when translation occurs. If translation occurs once for a given piece of code (as in Java), then the language is a compiled language. If the translation occurs every time the code is run (e.g., every time a new process that executes the particular code starts), then the language is an interpreted language (e.g., as in Perl).","Some interpreted languages include a function called the evaluate (\u2018eval\u2019) function, which is a mechanism for executing instructions that have not yet been transformed into an intermediate form. However, conventional compiled languages do not have an ability to convert programming statements into an executable form at runtime.","Described herein is a method and apparatus for dynamically loading uncompiled code or files. In one embodiment, a compiler is loaded by a computing device using an evaluation function that is included in a program in a compiled form. The evaluation function causes the compiler to compile source code for the program, wherein the source code includes new instructions that are uncompiled, and wherein compiling the source code generates compiled code that includes the new instructions. The evaluation function loads the compiled code into memory, retrieves the new instructions, and executes the new instructions. The evaluation function may perform these operations during runtime of the program that includes the evaluation function. The compiled code may be machine code, byte code, p-code, or subroutine-threaded code.","In the following description, numerous details are set forth. It will be apparent, however, to one skilled in the art, that the present invention may be practiced without these specific details. In some instances, well-known structures and devices are shown in block diagram form, rather than in detail, in order to avoid obscuring the present invention.","Some portions of the detailed description which follows are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.","It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion, it is appreciated that throughout the description, discussions utilizing terms such as \u201ccalling\u201d, \u201cloading\u201d, \u201ccompiling\u201d, \u201cexecuting\u201d, \u201cgenerating\u201d, \u201cperforming\u201d, or the like, refer to the actions and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (e.g., electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.","The present invention also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes, or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium, such as, but not limited to, any type of disk including floppy disks, optical disks, CD-ROMs, and magnetic-optical disks, read-only memories (ROMs), random access memories (RAMs), EPROMs, EEPROMs, magnetic or optical cards, or any type of media suitable for storing electronic instructions.","The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein, or it may prove convenient to construct a more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear from the description below. In addition, the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.","A machine-readable medium includes any mechanism for storing or transmitting information in a form readable by a machine (e.g., a computer). For example, a machine-readable medium includes a machine readable storage medium (e.g., read only memory (\u201cROM\u201d), random access memory (\u201cRAM\u201d), magnetic disk storage media, optical storage media, flash memory devices, etc.), a machine readable transmission medium (electrical, optical, acoustical or other form of propagated signals (e.g., carrier waves, infrared signals, digital signals, etc.)), etc.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1","b":"100"},"The exemplary computer system  includes a processor , a main memory  (e.g., read-only memory (ROM), flash memory, dynamic random access memory (DRAM) such as synchronous DRAM (SDRAM) or Rambus DRAM (RDRAM), etc.), a static memory  (e.g., flash memory, static random access memory (SRAM), etc.), and a secondary memory  (e.g., a data storage device), which communicate with each other via a bus .","Processor  represents one or more general-purpose processing devices such as a microprocessor, central processing unit, or the like. More particularly, the processor  may be a complex instruction set computing (CISC) microprocessor, reduced instruction set computing (RISC) microprocessor, very long instruction word (VLIW) microprocessor, processor implementing other instruction sets, or processors implementing a combination of instruction sets. Processor  may also be one or more special-purpose processing devices such as an application specific integrated circuit (ASIC), a field programmable gate array (FPGA), a digital signal processor (DSP), network processor, or the like. Processor  is configured to execute the processing logic  for performing the operations and steps discussed herein.","The computer system  may further include a network interface device . The computer system  also may include a video display unit  (e.g., a liquid crystal display (LCD) or a cathode ray tube (CRT)), an alphanumeric input device  (e.g., a keyboard), a cursor control device  (e.g., a mouse), and a signal generation device  (e.g., a speaker).","The secondary memory  may include a machine-readable storage medium (or more specifically a computer-readable storage medium)  on which is stored one or more sets of instructions (e.g., software ) embodying any one or more of the methodologies or functions described herein. The software  may also reside, completely or at least partially, within the main memory  and\/or within the processing device  during execution thereof by the computer system , the main memory  and the processing device  also constituting machine-readable storage media. The software  may further be transmitted or received over a network  via the network interface device .","The machine-readable storage medium  may also be used to store a process , an uncompiled file (not shown) and\/or a compiler  and\/or a software library (not shown) containing methods that call, for example, the compiler . Embodiments of the process  and compiler  are described below with reference to .","Returning to , while the machine-readable storage medium  is shown in an exemplary embodiment to be a single medium, the term \u201cmachine-readable storage medium\u201d should be taken to include a single medium or multiple media (e.g., a centralized or distributed database, and\/or associated caches and servers) that store the one or more sets of instructions. The term \u201cmachine-readable storage medium\u201d shall also be taken to include any medium that is capable of storing or encoding a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention. The term \u201cmachine-readable storage medium\u201d shall accordingly be taken to include, but not be limited to, solid-state memories, and optical and magnetic media.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIGS. 2A-2B","FIG. 1","FIG. 2A"],"b":["100","210","215","220"]},"Source code  is instructions that, once compiled, can be executed by a machine. The source code  may be written in any compiled language such as C, C++, BASIC, Fortran, Pascal, Java and so on. In one embodiment, source code  is included in an uncompiled file.","The source code , once compiled, provides functions and\/or variables that may be accessed and used (e.g., dynamically loaded) by an application, service or other software such as process . In one embodiment, the source code  is an uncompiled plugin to process . A plugin is a computer program that interacts with a host application or other software to provide a specific function to the host application\/software. The plugin may rely on a host application's user interface (e.g., a user interface of process ). In another embodiment, the source code  is an uncompiled extension to process . An extension is a computer program designed to enhance the functionalities of a host application (e.g., of process ). Alternatively, the source code  may simply be one or a few strings of code that provide, for example, instructions for a single function or variable to process .","Compiler  is a computer program that transforms source code written in a particular computer language (e.g., source code ) into compiled or machine readable code (e.g., machine code, byte code, etc.). The machine readable code is then executable by a particular hardware platform's processor. Typical compilers perform one or more of lexical analysis, code parsing, code generation, code optimization, preprocessing and semantic analysis.","In one embodiment, compiler  is a compiler for a traditional compiled language (e.g., C or C++) that has been modified to include eval function support . Compiler  may also be a compiler for Java that has been modified to include the eval function support . Alternatively, no compiler support may be necessary to implement the eval function. In such an embodiment, compiler  may be a traditional compiler that has not been modified to include any eval function support .","Process  may be any computer program, application or service that includes instructions for an evaluate (eval) function  that enables the process  to evaluate a string (or multiple strings) as though it were one or more statements (an individual executable unit of code). For example, the string \u201creturn 0;\u201d in C is a statement that contains the \u201creturn\u201d keyword (which tells the compiler to generate code to execute the correct function) and the expression \u201c0.\u201d The eval function  can supply syntactic wrappings so that a piece of functionality itself can be compiled as an independent unit. For example, in C\/C++ a function definition structure may be wrapped around the code to be evaluated, and in Java a class definition structure may be wrapped around the code to be evaluated.","After the source code  is evaluated (e.g., compiled), the eval function  causes it to be dynamically loaded. Dynamic loading is a mechanism that enables a process (e.g., an application or program) to add executable code to its executable image and configure it to execute, at runtime (the time during which the process is running). Typically, dynamic loading includes loading a file into memory during runtime. In conventional dynamic loading, the file and\/or instructions that are loaded into memory must be executable (e.g., machine code, byte code, etc.). However, embodiments of the present invention enable process  to dynamically load uncompiled files and\/or source code  into memory during runtime via the eval function .","To dynamically load source code , eval function  calls compiler  at runtime of process , passes to compiler  source code , receives from compiler compiled code (e.g., machine code), and executes the compiled code. The precise mechanics of the eval function  would depend on how an implementer intended that it be used. At its simplest, it would just wrap and execute a simple string. For example, doing this in Java could look like this:",{"@attributes":{"id":"p-0034","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class EvalExample {"]},{"entry":[{},"\u2003\u2003public static void main(String [ ] args) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003eval(\u201cSystem.out.println(\\\u201cHello, World!\\\u201d);\u201d);"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"More specifically, in Java the eval function  (e.g., the eval( ) method coded above) would receive a string to evaluate. This string in one embodiment resides in source code . The eval function  can create a temporary class, with a single method (e.g., doEval) that performs the code that was passed as a string to evaluate. The eval( ) method may create a file that gets compiled, or may operate on InputStream and Output Stream objects, which can be tied to arrays in memory. In Java, the anonymous class would look something like this:",{"@attributes":{"id":"p-0036","num":"0035"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public class EvalTmpClassYuHkSieEUfgwdlFrAl3b1w {"},{"entry":"\u2003\u2002public static void doEval( ) { System.out.println(\u201cHello, World!\u201d); } }"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The eval function  would call compiler  (in this example a Java compiler) and pass to compiler  the created temporary class, along with an instruction to compile source code  and to return a compiled class. Upon receipt of the compiled class, the eval function  causes the compiled class to be loaded (most likely, by passing the class file data to a ClassLoader subclass defineClass( ) method). The eval function  would then call the doEval( ) method on the freshly loaded class. Any temporary files that were created during the compiling of the source code  could then be deleted.","In one embodiment, the eval function is implemented in process  without requiring any modification to a compiler (e.g., compiler ) that was used to compile process . However, in order for the eval function  to be more tightly integrated with process  (e.g., have the evaluated code execute in the same execution scope as the caller, which would let evaluated code access and modify the variables defined in the enclosing scope), some compiler eval function support  may be required, which is described in greater detail below.","The above example shows how the eval function  and eval function support  may operate for the Java programming language. The case for a C program would be analogous, as shown in the following example. Again, at its simplest the eval function would just wrap and execute a simple string, as follows:",{"@attributes":{"id":"p-0040","num":"0039"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int main(void) {"]},{"entry":[{},"\u2003\u2003eval(\u201cprintf(\\\u201cHello, World!\\\\n\\\u201d);\u201d); }"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The eval function  would create a subroutine around the passed-in string:","void evalfnYuHkSieEUfgwdlFrA13b1w( ) {printf(\u201cHello, World!\\n\u201d;}","The eval function  would call the compiler  and pass the generated source code to the compiler . This can be accomplished \u201coff the shelf\u201d, if it is acceptable for the instructions in the source code  to be only loosely integrated with process . The compiler  would generate a compiled version of source code , and pass it back to process . The eval function  would receive and call the function included in the compiled version of source code , after which any temporary files could be cleaned up.","In one embodiment, in order for instructions generated based on the eval function  to be tightly integrated with process , compiler  includes eval function support . Principally, the eval function support  records which variables are accessible from the calling scope, and provide some mechanism for the eval function  to use this information. This can be accomplished by an eval function support  included in the compiler , or by eval function support  that is included in a preprocessor .","A preprocessor  is program that runs before the compiler  to preprocess code. The amount of processing and type of processing performed by the preprocessor can vary. Some preprocessors can be used to extend the functionality of a programming language. In one embodiment, the preprocessor  includes eval function support  that records which variables are accessible from the calling scope of eval function , and provides some mechanism for the eval function  to use this information.","In a more detailed example of an eval function  implemented in the C programming language, the eval function  may appear as follows:",{"@attributes":{"id":"p-0047","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int main( )"]},{"entry":[{},"{"]},{"entry":[{},"\u2003int i = 42;"]},{"entry":[{},"\u2003eval(\u201cprintf(\\\u201c i == %d\\\\n\\\u201d,i++);\u201d);"]},{"entry":[{},"\u2003printf(\u201cnow, i == %d\\n\u201d, i);"]},{"entry":[{},"\u2003return 0;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In this example, the eval function would need access to information about where i is being stored (either on the stack, or in a particular register set). This information can be provided by eval function support  or , as described below.","Upon execution of the above coded eval function , the eval function  may create a function definition that looks like this:",{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void evalfnVYQHZMJklF3j_YdfJ0Jg1w(frame_descriptor *f) {"]},{"entry":[{},"\u2003int *iptr = (int *)lookup(f, \u201ci\u201d);"]},{"entry":[{},"\u2003printf(\u201ci == %d\u201d, (*iptr)++);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The frame_descriptor would be a structure that contains the information necessary to find a particular local variable in an enclosing scope by name. This frame descriptor structure could be created at the time that process  was compiled by the compiler . The compiler  would also need to record information on how to find static and global variables in the scope of the calling function. In one embodiment, the eval function support  or eval function support  provides these capabilities.","In phases, one embodiment of the operations would be:\n\n","In one embodiment, the eval runtime does the lookups before it generates the code. In such an embodiment, the generated code may resemble the following:",{"@attributes":{"id":"p-0054","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void evalfnVYQHZMJklF3j_YdfJ0Jg1w(int *iptr) {"]},{"entry":[{},"\u2003printf(\u201ci == %d\u201d, (*iptr)++);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"If the compiler  is a Java compiler, the eval function support  and  may differ from that described above. Specifically, Java does not directly support pointer or reference types, so the eval function support ,  would include more extensive functionality.","In an example, the eval function may appear as follows:",{"@attributes":{"id":"p-0057","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class Example {"]},{"entry":[{},"\u2003public static void main(String [ ] args) {"]},{"entry":[{},"\u2003\u2003int i = 42;"]},{"entry":[{},"\u2003\u2003eval(\u201cSystem.out.println(\\\u201ci==\\\u201d+i++);\u201d);"]},{"entry":[{},"\u2003\u2003System.out.println(\u201cnow, i == \u201d+i);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This could be translated by eval function support  to something like this:",{"@attributes":{"id":"p-0059","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class Example {"]},{"entry":[{},"\u2003public class Examplemainvariables {"]},{"entry":[{},"\u2003\u2003public String [ ] args;"]},{"entry":[{},"\u2003\u2003public int i;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003public static void main(String [ ] args)"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003int i = 42;"]},{"entry":[{},"\u2003\u2003Examplemainvariables e = new Examplemainvariables( );"]},{"entry":[{},"\u2003\u2003e.args = args;"]},{"entry":[{},"\u2003\u2003e.i = i;"]},{"entry":[{},"\u2003\u2003EvalRuntime.eval(e, \u201cSystem.out.println(\\\u201ci == \\\u201d+i++);\u201d);"]},{"entry":[{},"\u2003\u2003args = e.args;"]},{"entry":[{},"\u2003\u2003i = e.i;"]},{"entry":[{},"\u2003\u2003System.out.println(\u201cnow, i == \u201d+i);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The eval method of the EvalRuntime class would be able to use the information provided by the object to pass information back and forth to the evaluated code. Such an implementation is not as efficient as using pointers and references (since the entire scope of the method would need to be copied twice), but is both simple and robust.","EvalRuntime.eval would generate code that looks like this:",{"@attributes":{"id":"p-0062","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class EvalClassVYQHZMJklF3j_YdfJ0Jg1w implements"]},{"entry":[{},"EvalInterface {"]},{"entry":[{},"\u2003public evalfn(Object e) {"]},{"entry":[{},"\u2003\u2003int i = EvalRuntime.lookupInt(e, \u201ci\u201d);"]},{"entry":[{},"\u2003\u2003System.out.println(\u201ci==\u201d+i++);"]},{"entry":[{},"\u2003\u2003EvalRuntime.save(e, \u201ci\u201d, i);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0063","num":"0066"},"figref":["FIG. 2B","FIG. 2A","FIG. 2A","FIG. 2A"],"b":["220","210"]},"In , on the other hand, compiler  is included in a library . Library  is a collection of subroutines, classes, functions, variables and other data that can be used by multiple different programs. In one embodiment, the library  is a shared library. Components in a shared library can be shared (accessed and loaded into memory) by unrelated applications. In some shared libraries, the components can also be shared in memory (the components only need to be loaded into memory once, and each application can map a different address space to the same physical memory page).","In one embodiment, the library  is a dynamically linked library. In a dynamically linked library, subroutines included in the library can be loaded into an application at runtime. Therefore, the subroutines can remain as separate files in the secondary memory, and do not need to be linked to process  at compile time. This enables process  to load compiler  at runtime via dynamic linking. Therefore, process  can access compiler  only when necessary.","Providing compiler  as a component in a dynamically linked library provides a number of advantages. Since the compiler  is in the library , process  does not have to rely on having compiler development tools installed. The compiler's performance (e.g., speed, response time, etc.) can also be increased because process  communicates directly with compiler  through memory. Moreover, calls can be made to specific portions (e.g., bits of code) in the compiler  during different phases of compilation, rather than loading the entire compiler  into memory. By providing compiler  as a subroutine\/component in a dynamically linked library, compiler  can be implemented as an extension to applications that are configured to dynamically compile and load files.","In one embodiment, the eval function  is also a component of library . Therefore, process  can load the eval function  at runtime and pass it variables, such as an identification of source code . This enables process  to use the eval function without requiring programmers to program eval functionality into process . The loaded eval function  can then cause the compiler  to also be loaded at runtime, pass compiler  source code  (e.g., from an uncompiled file), receive compiled instructions, and execute the compiled instructions.",{"@attributes":{"id":"p-0068","num":"0071"},"figref":["FIG. 3","FIGS. 2A-2B"],"b":["300","300","300","310","300","310","300","320","300","310"]},{"@attributes":{"id":"p-0069","num":"0072"},"figref":["FIG. 4","FIG. 1"],"b":["400","400","400","100"]},"Referring to , at block  processing logic calls new instructions that may include a function and\/or variable included in source code. The processing logic may be a process that is in a runtime state (e.g., a process that is being executed by a processor). The source code may be a user readable string of high level language computer code (e.g., source code). In one embodiment, the source code is included in an uncompiled file. The uncompiled file may be, for example, a text file that includes instructions that can be read by a compiler such as a C\/C++ compiler, a Java compiler, etc.","At block , processing logic loads a compiler. The compiler may be an independent program (e.g., a separate executable file that is not part of a library) and\/or may be a component of a library such as a dynamically linked library and\/or a shared library. If the compiler is an independent program, it may be executed with a command line that is different from what it would have if it were being executed in the ordinary course of compiling a unit of code. For example in the GNU Compiler Collection (GCC), it may be passed \u201c-fpipe\u201d to tell it to read from its standard input instead of a file, or it may be passed \u201c-fpic\u201d or \u201c-fPIC\u201d to produce position independent code. For other compilers, other commands may be passed. If the compiler is a subroutine of a dynamically linked library, it may be loaded using standard application programming interfaces (APIs) provided by an operating system on which processing logic operates.","At block , processing logic compiles the source code using the compiler to generate compiled machine code. Alternatively, the processing logic may compile the source code into byte code (e.g., Java byte code). The processing logic may also compile the source code into some other appropriate machine readable form. For example, in the Pascal language, the source code may be compiled into a variable length coding called p-code. P-code (also known as pseudo-code) is a form of compiled code that is designed to execute on a virtual machine called a pseudo-code machine. In another example, in the Forth programming language, the source code may be compiled into subroutine-threaded code that includes a sequence of machine code call instructions and\/or address references.","At block , processing logic unloads the compiler.","At block , processing logic loads the compiled code into memory.","At block , processing logic retrieves the function and\/or variable from the compiled code.","At block , processing logic executes the function and\/or accesses the variable. Therefore, the functionality of the processing logic can be extended without a need to recompile, relink or change the code of the processing logic. New code can be repeatedly added on to the processing logic without a need for recompiling. This permits applications to be developed that call on functions that have not yet been completed when the applications are compiled, with the assumption that the functions will be created down the line.","At block , processing logic determines whether the function and\/or variable is still needed. If the function and\/or variable are still needed, the method may end. If the function and\/or variable are no longer needed, then it may be unloaded from memory. The method then ends.","It is to be understood that the above description is intended to be illustrative, and not restrictive. Many other embodiments will be apparent to those of skill in the art upon reading and understanding the above description. Although the present invention has been described with reference to specific exemplary embodiments, it will be recognized that the invention is not limited to the embodiments described, but can be practiced with modification and alteration within the spirit and scope of the appended claims. Accordingly, the specification and drawings are to be regarded in an illustrative sense rather than a restrictive sense. The scope of the invention should, therefore, be determined with reference to the appended claims, along with the full scope of equivalents to which such claims are entitled."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings and in which:",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIG. 2A","FIG. 1"]},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIG. 2B","FIG. 1"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
