---
title: Virtual machine demand estimation
abstract: A method for use in a system in which computational entities are distributed across physical computing resources to place the entities on the resources includes estimating actual resource demand for each entity on each resource based on application resource usage data collected from a data source external from the entity, computing a best allocation of the resources to the entities from the estimated actual resource demand for each entity and distributing the resources to the entities in accordance with the computed best allocation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09037717&OS=09037717&RS=09037717
owner: International Business Machines Corporation
number: 09037717
owner_city: Armonk
owner_country: US
publication_date: 20090921
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Aspects of the present invention are directed to a method and a system for virtual machine CPU demand estimation for autonomous resource and power management.","In a virtualized environment, the physical hardware is decoupled from the operating system and application software via a hypervisor layer. In such environments, resource consolidation is a commonly applied technology that is enabled by computing hardware virtualization. The hypervisor helps multiple virtual machines (VMs), which may run different operating systems on different virtual hardware, share the same physical resources.","Current virtualization technologies incorporate management schemes that present a unified resource view for multiple virtualized hosts and provide methods for dynamic resource balancing among these hosts by, e.g., migrating VMs between resources. Such resource balancing requires explicit knowledge of each VM's resource demand to commit resources efficiently. One key challenge in these processes is the determination of the actual desired resource demand of each VM. In a case where a host is undercommitted and has more resources than the total demand produced by its occupant VMs, each VM's resource usage tracks demand closely. However, in the case where a host is overcommitted and had less resources than the total demand produced by its occupant VMs, VM resource usage deviates from demand. This latter case is far more important in terms of resource balancing and may lead to VM performance degradation. In overcommitment, the existing solutions have drawbacks in that they either use resource usage, such as each VM's CPU usage percent, as an indicator of demand or they may rely on legacy implementations tightly coupled with the underlying virtualization technology for specific implementations.","Generally, it is seen that some of the existing techniques either explicitly rely on CPU usage or introduce disruptive hooks to the overlaying virtualized applications for resource management and capacity planning. Some of these proposed techniques argue for the necessity of application-level intervention to distinguish demand from usage. While other work also argues that demand does not necessarily follow usage in both native and virtualized systems and points out some of the indicators of resource contention, they do not provide an estimation technique. Other work that proposes virtual machine performance modeling and estimation techniques rely on tracking virtual machine resource usage\/demand and develop forecasting or application-level performance modeling techniques. These studies are not applicable for arbitrary black-box virtualization management (that is, virtualization management done without any monitoring hooks inside the VMs, where VMs are treated as black boxes) cases, and do not provide a general representation of actual VM resource demand. Some solutions aim to address the problem of identifying the resource requirements of a VM. These solutions rely on determining resource needs from within a virtual machine by inspecting application and operating system behavior within the VM to track certain indicative behavior such as detecting the occurrences of an idle loop within a virtual machine. In an approach for hypervisor load balancing, information about the VM CPU load is determined based on its interrupt response time. While this technique provides indirect measures on whether a VM is receiving its resource requirements, it is generally intrusive and does not provide a direct measure of a VM's actual resource demand.","In accordance with an aspect of the invention, a method for use in a system in which computational entities are distributed across physical computing resources to place the entities on the resources is provided. The method includes estimating actual resource demand for each entity on each resource based on application resource usage data collected from a data source external from the entity, computing a best allocation of the resources to the entities from the estimated actual resource demand for each entity and distributing the resources to the entities in accordance with the computed best allocation.","In accordance with another aspect of the invention, a method for estimating actual resource demand for running entities is provided and includes obtaining a map of the entities relative to resources, obtaining resource usage metrics for each entity and resource, obtaining resource capacities and computing the estimated actual resource demand based on the map of the entities relative to the resources, the resource usage metrics and the resource capacities.","In accordance with another aspect of the invention, a system, in which computational entities are distributed across physical computing resources to place the entities on the resources, is provided. The system includes a processor and a computer readable medium coupled to the processor having executable instructions stored thereon, which, when executed instruct the processor to estimate actual resource demand for each entity on each resource based on application resource usage data collected from a data source external from the entity, to compute a best allocation of the resources to the entities from the estimated actual resource demand for each entity and to distribute the resources to the entities in accordance with the computed best allocation.","With reference to , an exemplary system includes a virtualized cluster with 3 hosts, each with total CPU capacity of 100%, and 8 virtual machines (VMs). Dynamic placement aims to balance resources for use by the VMs such that each host's utilization does not, for example, exceed 85%. Dynamic placement also employs power management such that if the total resource demand by the VMs can be satisfied with fewer than 3 hosts, the remaining hosts are powered down. When the demand rises, the hosts are powered back on to satisfy the demand. In this example, the VMs are initially close to idle (each demanding 10% CPU) and, they fit within a single host (8\u00d710%=80%<85%), they all reside in a single host with the other two machines powered down. When each VM's demand increases to 25% a dynamic resource manager uses resource usage as a measure of demand to respond in the absence of the demand estimation of the invention and an iterative process including 5 separate decisions that converges to the placement of resources.","In the present disclosure embodiments, desired resource demand of the VMs is captured initially and guides dynamic resource balancing actions in a single operation. That is, the resource management actions performed in steps T-T of  are realized in a single operation with demand estimation. This is achieved using scheduling statistics commonly available to operating systems and hypervisors to derive reliable estimates for actual VM resource demand.","With reference to , a method for use in a system in which computational entities are distributed across physical computing resources to place the entities on the resources is provided as described above. This includes estimating actual resource demand for each entity on each resource based on application resource usage data collected from a data source external from the entity , such as a hypervisor, computing a best allocation of the resources to the entities from the estimated actual resource demand for each entity , and distributing the resources to the entities in accordance with the computed best allocation .","The estimating of operation  may include obtaining a map of the entities relative to the resources , obtaining resource usage metrics for each entity and resource , obtaining resource capacities  and computing the estimated actual resource demand based on the map of the entities relative to the resources, the resource usage metrics and the resource capacities . The resource capacities may be potentially time-varying due to employment of dynamic power\/performance management techniques (such as dynamic voltage and frequency scaling, dynamic memory sizing), resource reservations, dynamically-varying system resource requirements, and other contributors.","The computing of the estimated resource demand of operation  may further include computing estimated actual resource demand specific to CPU resources , computing estimated actual resource demand specific to memory resources , computing estimated actual resource demand specific to storage I\/O resources  and computing estimated actual resource demand specific to network I\/O resources .","In accordance with embodiments of the invention, the computing of the estimated actual resource demand specific to CPU resources  may include obtaining CPU resource usage metrics for each entity and resource, obtaining CPU resource capacities for each resource and computing actual resource demand specific to CPU resources for each entity from the CPU resource usage metrics and the CPU resource capacities. Here, The CPU resource usage metrics may include CPU cycles during which the entity was actually granted the use of the CPU resources, CPU cycles during which the entity was ready to use the CPU resources, CPU cycles during which the entity was waiting on a resource other than the CPU and CPU cycles during which the entity was idle. The CPU resource usage metrics may further include CPU cycles during which the resource performed system-related operations. The CPU resource capacities may include available CPU cycles aggregated over all available logical processing units enclosed by the resource.","In accordance with further embodiments of the invention, the computing of the estimated actual resource demand specific to memory resources  may include obtaining memory resource usage metrics for each entity and resource, obtaining memory resource capacities for each entity and resource and computing actual resource demand specific to memory resources for each entity from the memory resource usage metrics and the memory resource capacities. Here, the memory resource usage metrics may include an amount of memory that is active for each entity, an amount of memory that is mapped for each entity, an amount of memory that is swapped for each entity, an amount of memory that is shared with other entities and an amount of reserved memory. The memory resource capacities may include available and configured memory for each resource.","In accordance with further embodiments of the invention, the computing of the estimated actual resource demand specific to storage I\/O resources  may include obtaining storage resource usage metrics for each entity and resource, obtaining storage resource capacities for each entity and resource and computing actual resource demand specific to storage I\/O resources for each entity from the storage resource usage metrics and the storage resource capacities. Here, the storage resource usage metrics may include storage read and write rates for each entity, storage read and write requests for each entity, storage read and write latencies for each entity and resource and storage device read and write queue lengths for each resource. The storage resource capacities may include storage bandwidth for each resource.","In accordance with further embodiments of the invention, the computing of the estimated actual resource demand specific to network I\/O resources  may include obtaining network resource usage metrics for each entity and resource, obtaining network resource capacities for each entity and resource and computing actual resource demand specific to network I\/O resources for each entity from the network resource usage metrics and the network resource capacities. Here, the network resource usage metrics include network packet transfer and receive rates for each entity and resource, packet transfer and receive latencies for each entity and transmit and receive queue lengths and latencies for each resource. The network resource capacities may include available network bandwidth for each resource and configured network bandwidth for each entity.","The methods described above may be embodied in a system, in which computational entities are distributed across physical computing resources to place the entities on the resources. The system may include a processor and a computer readable medium coupled to the processor having executable instructions stored thereon. When executed, the executable instructions instruct the processor to estimate actual resource demand for each entity on each resource based on application resource usage data collected from a data source external from the entity, to compute a best allocation of the resources to the entities from the estimated actual resource demand for each entity and to distribute the resources to the entities in accordance with the computed best allocation.","Demand estimation of aspects of the present invention generally relies on basic scheduling metrics. As shown in Table 1 below, the scheduling metrics may include CPU Used, CPU Wait, CPU Ready and CPU System metrics. The CPU Used metric refers to a time spent while the CPU is in use. The CPU Wait metric refers to a time spent waiting for some resource other than the CPU. The CPU Ready metric refers to a time spent waiting for the CPU to be available. The CPU System metric refers to a time spent in the hypervisor\/kernel.",{"@attributes":{"id":"p-0027","num":"0026"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CPU scheduling statistics used in demand estimation:"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CPU Used","Time spent while using the CPU"]},{"entry":["CPU Wait","Time spent waiting for some resource other than the CPU"]},{"entry":["CPU Ready","Time spent waiting for the CPU to be available"]},{"entry":["CPU System","Time Spent in the hypervisor\/kernel"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The metrics can be defined for each VM, as well as each physical processor. The demand estimation method then uses the statistics gathered for each VM over a sampling period T that is smaller than the average decision making period used by a dynamic resource balancing mechanism. It is understood that while demand estimation relates to computing resource management as described herein, it may also be applied to memory, bandwidth and\/or other similar computing resources.","The CPU Used metric tracks an amount of time a VM was actually running on a physical processor. The amount of time reported in these metrics may be considered as a portion of the sampling period T. For example, for a case in which T=20 seconds, if the CPU Used metric is found to be 10 seconds, this translates to 50% CPU usage for the VM. The CPU Wait metric describes a time spent waiting on some other resource such as a disk or a network input\/output (I\/O) unit. During wait time, the VM cannot progress even if there is an available CPU resource since this resource is effectively blocked. The CPU Ready metric captures a time during which the VM was ready to run on the CPU, but had to relinquish the processor to some other VM or task computing for the same resource. During ready time, the VM could actually make useful progress had it been given more processing resources. The CPU System metric represents a time spent in lower-level operations such as hypervisor or kernel tasks and may be an important component in VM CPU accounting.","Insights relevant to demand estimation are drawn from these metrics. For example, for an idle VM, used and ready times are close to 0 seconds, while wait time is around 100%. For a completely CPU-bound VM, the sum of used and ready times is expected to by approximately 100%. In general, the sum of all the four metrics is expected to approximate total elapsed time for a VM. The CPU demand estimate for a VM follows from these insights. The VM is expected to be in one of the four states described by the metrics and the distribution of VM CPU time to these states depends on an amount of physical resources available to the VM and each VM's actual desired demand.","With reference to , a hypothetical example demonstrates how the VM time is distributed during the lifetime of a VM. System time is omitted in the description for clarity.  shows an example where 10 VMs are consolidated on a single host. The host has 2 physical CPUs aggregating to a total CPU capacity of 200%. Each VM has a CPU demand of 80%. In the example, t represents an arbitrary time quantum during which only a pair of the VMs can run on the two physical cores. For simplicity, we assume the VMs get their turns to run in a pairwise round-robin fashion. That is, at t=1, VM and VM run, while the remaining are eight VMs wait their turn; at t=2, VM and VM acquire the cores, while the others wait; and so on. In addition the VM load is constructed such that each VM wants to perform CPU operations worth 4t time, followed by a 1t idle period. This load pattern is repeated with this 5t period to achieve the 80% CPU demand over a sampling period T>>5t. The three different states are represented with U (CPU Used), W (CPU Wait) and R (CPU Ready). The columns of the figure represent the timeslices in t, and the whole chart from left to right shows the execution timeline of the 10 VMs.","At t=1, all VMs are ready to run. The first two VMs are scheduled on the physical processors and, therefore, they are in the U state. The other VMs stay in the R state, as they are ready to run, but there are no available CPUs. At t=2, VM and VM relinquish the CPUs, which are then allotted to VM and VM, which go into the U state. The same pattern continues until t=16. At this point, VM and VM run for the fourth t interval. After this, they have completed their CPU-bound operation worth 4t CPU time and they remain idle for 1t. This is indicated with the W state. That is, at this point VM and VM are not competing for the CPU resources. The following VMs enter the U state to perform their fourth t interval of CPU-bound execution and consecutively go into W state. The VMs go back into R state after the W state when they start competing for resources again after idling for the 1t interval. As the highlighted region shows, the whole 10VM execution pattern shows a fundamental period of 20t. Therefore, a sampling interval T>>20t shall capture a similar distribution of states as shown in the highlighted 20t region.","Focusing on the representative 20t region, each VM shows a state distribution of {U=4t, W=1t, R=15t}. While the amount spent in R is generally dependent on the amount of competition between VMs, W and U can be expected to be moderately consistent regardless of the level of overcommitment. As such, it is seen that the demand of the VMs is captured by a ratio of how much the VMs are in the U and W states and that a ratio of the CPU Used time (4t) to the sum of CPU Used and CPU Wait times (5t) represents the actual CPU demand of the VMs (80%). Thus, an estimated actual demand for a VM can be represented as:",{"@attributes":{"id":"p-0034","num":"0033"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"CPU_Demand","mo":"\u2242","mfrac":{"mrow":[{"mi":"Used","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mo":"+","mi":"System"}}},{"mi":"Used","mo":"+","mrow":{"mi":"Wait","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mo":"+","mi":"System"}}}}]}},"mo":"=","mfrac":{"mrow":[{"mi":"Used","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mo":"+","mi":"System"}}},{"mi":["Stats_Period","Ready"],"mo":"-"}]}}}}},"This equation shows an approach to VM CPU demand estimation, which relies on the use of scheduling parameters for a hypervisor. An additional \u201csystem\u201d component is also included in the above equation. This represents a small overhead component for the time spent in local hypervisor resource management processes that is not attributed to the U, R and W states. While the equation shows the conceptual derivation of VM CPU demand, an analytical representation can be derived as shown in .","As shown in , at operation , at each tick of a CPU clock a VM is assumed to be in a \u201cu\u201d state, where the VM gets to use the CPU for that tick, a \u201cw\u201d state, where the VM is waiting for an I\/O wakeup, as an example, or an \u201cr\u201d state where the VM is not given access to the CPU but could have used it had it been. Next, at operation , counts for each state over an interval of N ticks are defined as N(the number of \u201cu\u201d state seconds), N(the number of \u201cw\u201d state seconds) and N(the number of \u201cr\u201d state seconds). It is then assumed, at operation , that the VM's behavior is statistically stationary, such that for over a large number of ticks, where N>>1, the following quantities are well defined and measurable: U=N\/N=Fraction of \u201cu\u201d seconds, W=N\/N=Fraction of \u201cw\u201d seconds, and R=N\/N=Fraction of \u201cr\u201d seconds.","If, at operation , it is determined that there is no contention for the CPU, the VM gets access to the CPU resources whenever it needs such access and it is known that R=O. Here, baseline quantities of U=U, W=Wand R=R=0 are defined with the goal being to calculate Ugiven values of U, W and R measured when there is contention for the CPU. When there is contention for the CPU, at operation , the CPU scheduling algorithm is treated as a random process in which, at each tick of the clock, the CPU is given to something other than the VM with a fixed probability. In this way, it may be represented that, if the VM would have been in state \u201cu\u201d if there were no contention, and if the CPU were to be given to something else for that clock tick, then the VM is placed in the \u201cr\u201d state and its program counter would not advance. Alternatively, if the VM is in the \u201cw\u201d state when the CPU is given to something else, the VM is unaffected. This substitution leads to the desired equations:",{"@attributes":{"id":"p-0038","num":"0037"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":"U","mn":"0"},"mo":"=","mrow":{"mfrac":[{"mi":"U","mrow":{"mi":["U","W"],"mo":"+"}},{"mi":"U","mrow":{"mn":"1","mo":"-","mi":"R"}}],"mo":"="}}}}},"With reference to , demand estimation may be implemented and validated in an embodiment of a virtualized environment using, for example, one or more hypervisors , such as VMware hypervisors, and VMs A-C, such as Linux VMs, which are distributed across hosts , . A virtualization manager  collects host\/VM CPU usage stats in an aggregator  and stored in a virtual appliance . This exemplary validation prototype is implemented as a virtual appliance application programming interface (API) client that gathers the described VM CPU statistics from the hypervisors and as an integrated dynamic resource balancing engine that performs resource management and dynamic placement. In other embodiments, demand estimation can be carried out by agents in individual hypervisors or as part of a general virtualization management endpoint. Experiments similar to the case shown in  have been conducted in the prototype implementation of  and indicate that demand estimation relatively accurately captures VM resource demand and that demand estimation eliminates the iterative progress described in . Demand estimation therefore enables a dynamic placement engine to perform correct resource balancing actions in a single operation.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0041","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CPU demand configurations for a case in which five VMs"},{"entry":"are used in demand estimator validation:"},{"entry":"CPU Demand"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"VM1","100%"]},{"entry":[{},"VM2","80%"]},{"entry":[{},"VM3","60%"]},{"entry":[{},"VM4","40%"]},{"entry":[{},"VM5","20%"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"In , the top highlighted regions show the observed CPU usage and the demand estimation, which tracks actual VM CPU demand relatively closely. The lower area shows the impact of demand estimation in dynamic resource balancing. The placement engine identifies and performs three live migrations to satisfy the actual demand of all VMs in the cluster in a single operation.","The case shown in  corresponds to the same initial state of the scenario described in , where all VMs reside in the first host. In this case, the estimator identifies the actual demand of each VM with reasonable accuracy. As a result, dynamic placement performs all the necessary balancing actions immediately. In other words, all the intermediate steps of  are merged to a single correct action.","Table 3 shows the timeline of the actual placement decisions applied in this example with and without demand estimation. Without demand estimation, dynamic placement progresses in an iterative fashion, similar to . In contrast, with demand estimation, all of the necessary balancing actions are completed in a single iteration.",{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Timeline of dynamic placement actions, with and without"},{"entry":"demand estimation:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Timeline","Without Demand Estimation","With Demand Estimation"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Iteration 1","Migrate VM5 \u2192 Host2","Migrate VM5, VM4 &"]},{"entry":[{},{},"VM3 \u2192 Host2"]},{"entry":["Iteration 2","Migrate VM4 \u2192 Host2","ALL DEMANDS MET"]},{"entry":["Iteration 3","Migrate VM3 \u2192 Host2"]},{"entry":["Iteration 4","ALL DEMANDS MET"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"In accordance with further embodiments of the invention, relative priorities of VMs can be changed, resource caps on VMs can be introduced, resource guarantees for certain VMs can be provided. In each case, the demand estimate approach performs in a similar fashion as demonstrated above. The individual VM performances however show different characteristics as dictated by the applied resource constraints.","While the discussed prototype focuses on homogeneous resources, demand estimation can also relate to heterogeneous resources. In the case of heterogeneous host configurations, if the demand estimate for a VM is seen to be less than 100% (minus an empirically-determined threshold for resilience against measurement fluctuations) of host capacity, this demand can be translated into another host by carrying over absolute resource requirements. The case where the VM demand is seen to be close to 100% can be handled as a special case. In this case, the VM is known to desire at least as much as its current host's capacity. Therefore, for another host with lower capacity than the VM's current host, it is known that the VM demand exceeds 100% of that host's capacity. This can be represented as either a percentage greater than 100% or by using absolute resource demand measures. For another host with capacity higher than the VM's current host, the actual demand of the VM can be estimated within a range. It is known that, the demand can be at least as much as the original host's resource capacity. This capacity translates into a percentage that is lower than 100% in the other (bigger-capacity) host. This measure constitutes a lower bound on VM demand. As the new measured demand cannot exceed capacity of the other host, the VM demand can be only as high as 100% of the other host's capacity. Thus, a demand of 100% constitutes an upper bound for conservatively estimating such a VM's demand on another, bigger-capacity host. For performance-efficient placement, this conservative estimate relatively cautiously assumes the upper bound of the possible range of VM resource demand.","In addition to improving the power\/performance efficiency of virtualized environments, the improved demand estimates provided by the proposed invention can be employed for other purposes.","A first additional purpose for which the invention may be employed is to improve the effectiveness of forecasting approaches that predict future resource demand of VMs. Without demand estimation, a forecasting approach that aims to discern trends and patterns from past resource usage history is exposed to spurious and potentially sharp changes in these historical measurements. These spurious shifts in past resource usage history occur because the patterns for each VM are susceptible to both other VMs' dynamically-varying application characteristics and the dynamic placement decisions as they work to correct any resource overcommitment.","In contrast, a forecasting approach that takes into account the actual demand created by a VM is exposed to a representative view of the actual VM behavior that is only dependent on the same VM's own application characteristics. Such a forecasting approach is not misdirected by inter-VM influences on resource usage and ongoing dynamic placement decisions.","A second additional purpose for which the invention may be employed is to provide administrators directly with information about the evolution of demand over time, rather than feeding the demand estimate directly to an automated resource allocator. For example, the estimated actual demand of each VM (or application) over time could be plotted alongside the more traditional CPU utilization plot in the Graphical User Interface of a system administrator tool. If used in conjunction with forecasting (see, in , operation  of forecasting future demand based on the estimated actual resource demand), the GUI could also display a forecast of future demand, computed from the time series of estimated demands. As noted above, the future demand forecast would be more accurate and informative than a future CPU utilization forecast.","While the disclosure has been described with reference to exemplary embodiments, it will be understood by those skilled in the art that various changes may be made and equivalents may be substituted for elements thereof without departing from the scope of the disclosure. In particular, the disclosure can be applied to a more general set of computational entities than VMs, such as applications or processes. In addition, many modifications may be made to adapt a particular situation or material to the teachings of the disclosure without departing from the essential scope thereof. Therefore, it is intended that the disclosure not be limited to the particular exemplary embodiment disclosed as the best mode contemplated for carrying out this disclosure, but that the disclosure will include all embodiments falling within the scope of the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTIONS OF THE SEVERAL VIEWS OF THE DRAWINGS","p":["The subject matter regarded as the invention is particularly pointed out and distinctly claimed in the claims at the conclusion of the specification. The foregoing and other aspects, features, and advantages of the invention are apparent from the following detailed description taken in conjunction with the accompanying drawings in which:",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
