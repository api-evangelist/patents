---
title: Generating a format translator
abstract: Generating code is disclosed. A specification of one or more translation patterns is received. The one or more translation patterns are used to generate at least a portion of code associated with a translator. Using the one or more translation patterns to generate at least a portion of code associated with the translator results in the translator being configured to create a target object model. Creating the target object model includes populating one or more elements of the target object model in a processing order at least in part associated with an order of elements in the one or more translation patterns.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07774746&OS=07774746&RS=07774746
owner: Apple, Inc.
number: 07774746
owner_city: Cupertino
owner_country: US
publication_date: 20060419
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","DETAILED DESCRIPTION"],"p":["Often electronic content data do not consistently adhere to one standard on format, organization, and use in consistent software. For example, each individual content data creator may choose to save electronic content data in various formats including a variety of text formats, document formats, spread sheet formats, presentation formats, visual graphic formats (e.g. chart, graph, map, drawing, image formats), audio formats, multimedia (e.g. video formats) formats, and database formats. This heterogeneous nature of the electronic content data can pose challenges when the various content need to be converted to a different format. Existing translation solutions typically require that heterogeneous content be converted into a common format. Translation from format A to format B is done in two steps: an import from format A to the common format followed by an export from the common format to format B. This allows all possible mappings between N number of formats with 2N number of converters rather than N-N number of converters that would be needed without a common format. However, this common format method is inefficient, requiring two conversions steps rather than one. Many standard tools for conversion to the common format operate at inconsistent semantic levels, or encode an inappropriate semantic level, potentially causing information needed to perform desired content management and\/or electronic publishing functions, for example, to be lost. As new file formats are created, the current solutions are difficult to adapt to rapidly advancing software technology. Therefore, there exists a need for a better way to convert electronic content.","The invention can be implemented in numerous ways, including as a process, an apparatus, a system, a composition of matter, a computer readable medium such as a computer readable storage medium or a computer network wherein program instructions are sent over optical or electronic communication links. In this specification, these implementations, or any other form that the invention may take, may be referred to as techniques. A component such as a processor or a memory described as being configured to perform a task includes both a general component that is temporarily configured to perform the task at a given time or a specific component that is manufactured to perform the task. In general, the order of the steps of disclosed processes may be altered within the scope of the invention.","A detailed description of one or more embodiments of the invention is provided below along with accompanying figures that illustrate the principles of the invention. The invention is described in connection with such embodiments, but the invention is not limited to any embodiment. The scope of the invention is limited only by the claims and the invention encompasses numerous alternatives, modifications and equivalents. Numerous specific details are set forth in the following description in order to provide a thorough understanding of the invention. These details are provided for the purpose of example and the invention may be practiced according to the claims without some or all of these specific details. For the purpose of clarity, technical material that is known in the technical fields related to the invention has not been described in detail so that the invention is not unnecessarily obscured.","Specifying a format translation pattern and providing a mechanism for automatically generating translator code based at least in part on a collection of one or more such patterns is disclosed. In some embodiments, the format translation pattern includes a way to represent one or more sets of similar features from different source content formats. In some embodiments, the format translation pattern represents a common way of translating data structures without an assumption that those data structures represent similar features. The pattern includes a parameterization\/template for representation of the features as well as representation of the translations between corresponding features. In some embodiments, a meta-language such as XML (Extensible Markup Language) is used to represent the features and\/or the translation parameterization. In some embodiments, a code generator takes a parameterized description of a feature of one or more content formats as input and outputs code that translates\/implements that feature. In some embodiments, the pattern is one of a plurality of patterns.","As used herein, \u201cformat\u201d is defined as any information representation or schema. This may include schemas for streams, database tables, object models, trees, graphs and\/or other base data structures. A \u201ctranslator\u201d between formats is defined as any process that takes information in a source format as input and produces corresponding information in another target format as output. Parsers, mappers and serializers are regarded as instances of translators, and are defined as follows: A \u201cparser\u201d translates from a stream-based format into an object model, a \u201cmapper\u201d converts between object models, and a \u201cserializer\u201d translates from an object model to a stream-based format. In some embodiments, translators can be connected in sequence to make other translators. For example a stream to stream file format translator is created by connecting a parser with any number of successive mappers connected to a serializer.","In some embodiments, the steps to create content conversion software include (i) analysis of the source content format, (ii) creation of a parser, (iii) mapping analysis, (iv) creation of one or more mappers, and (v) implementation of a serializer to the target format. For example, in creating the parser, a suitable collection of translation patterns is selected, and their parameters are filled in using a language developed for the purpose of describing translator instances. The language includes constructs to specify how to query binary streams, applicable to binary source files, as well as other categories of source format such as text or XML. A parser-generator reads in this translator specification, and creates source code for a parser. That parser is compiled to object code. By applying the parser to a source content, an in-memory tree representation of the source content is created. This tree can be shown to a software developer with a tree view in an IDE (Integrated Development Environment) or serialized, for example, as XML for purposes of testing and further developing a parser. In some embodiments, a rapid file format analysis tool that allows a user to discover the source format schema is used in an iterative process: at each step a single modification to the translator specification is suggested by the user, a new parser is generated, a series of test files are parsed, and the results are shown in a tree view or dumped as XML for inspection. The source and target of a mapper are both object models that can be similarly represented as trees in an IDE or as XML, and it is possible to create a rapid mapping analysis tool that generates the mapper translator. Specifying a mapper also involves choosing a suitable collection of translation patterns and filling them in. The Queries used by a mapper are queries into an object model. If XML or another common meta-language is used to represent both source and target of the mapper, then mappers can be rapidly prototyped as translations of that meta-language. For example, XSLT (Extensible Stylesheet Language Transformations) can be used to prototype mappers when the source and target format are represented as XML.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1","b":"102"},"At , a format converter is generated. In some embodiments, generating the format converter includes generating and connecting together one or more of the following: a parser translator, a mapper translator, and a serializer translator. In some embodiments, serialization is not performed by a separate translator, but by serialization methods on the target objects of the mapper translator. In some embodiments, one or more of the translators are specified using a common language, such as an XML grammar designed to describe translator components and how they are connected together. For example, data is communicated between translators using queries on intermediate object models. These intermediate object models can be described using a common meta-language such as XML, and the queries can be described using a common language such as XPath. In some embodiments, one or more of the translators comprises a previously generated translator and\/or a component of another format converter. In some embodiments, an input of at least one of the translators is the source content. At , the format converter is used to perform the desired format conversion. In some embodiments, more than one format converter is used to perform the desired format conversion. In some embodiments, output of the desired format conversion is at least in part used in performing a desired processing. In some embodiments, the format of the output is associated with an open standard and can be used to style, view, search, augment, edit or otherwise process the output. For example, in some embodiments the output is in a SVG (Scalable Vector Graphics) format.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 2","FIG. 2","FIG. 1"],"b":["104","202"]},"At , one or more mapper translators are generated. In some embodiments, a mapper translator translates at least a portion of content in one object model to another object model. In some embodiments, by using a common API (Application Programming Interface) to access the object models and\/or using a common query language together with query compilers that turn this into to source code to accesses disparate APIs, translator re-use is maximized. In some embodiments, generating the mapper translator includes using a parameterization\/specification associated with how to interpret one or more translation patterns to generate code for compilation\/interpretation as the mapper translator. At , a serializer translator is generated. In some embodiments, the serializer translator translates an object model of content to a stream-based format, such as a format associated with a saved file. For example, in some embodiments an in-memory representation of converted content is translated to a format associated with a file on a storage media. In some embodiments, generating the serializer translator includes using a parameterization\/specification associated with how to interpret one or more translation patterns to generate code for compilation\/interpretation as the serializer translator. At , one or more of the generated translators are connected together. In some embodiments, connecting two translators together includes ensuring that they have been specified in such a way as to act on the same intermediate object models, and linking all the code fragments that were generated from their individual pattern instances. By connecting the translators together, a format converter is generated. In some embodiments, the connections between the translators are optimized to create an efficient converter.","In some embodiments, one or more translators are generated in parallel. For example, generation of a translator is dependent on data associated with another translator, and the dependent data is exchanged as the translators are generated. In some embodiments, generation of one or more of the parser translator, the mapper translator, and the serializer translator is optional. For example, when importing\/opening a file, the serializer translator is not generated, and when exporting\/saving content already in memory, a parser translator is not generated. In some embodiments, one or more pre-generated translators are used, e.g., if available and applicable.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 3","FIG. 3","FIG. 3","FIG. 2"],"b":["202","204","206","302","304","306","302","308","306","310","314","312","316","312","314","312","304","314","316","314"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 4","FIG. 4","FIG. 1","FIG. 2","FIG. 4"],"b":["104","202","204","206","304","402"]},"At , a function-query-constant tree is determined. Specifying an instance of a translator pattern requires a combination of three basic operations: placing data, obtaining data, and manipulating data. For example, an XML tag in a translation pattern for specifying each of these operations includes in some embodiments: \u201c<const>\u201d tag indicating constants for placing data, \u201c<query>\u201d tag indicating queries for obtaining data from the source content; and \u201c<func>\u201d identifying functions for manipulating data. Each individual parameter in the object model for a translation pattern can be filled in with a constant, a query, or a function. Within a function, arguments can be filled in with a constant, a query or another function. In some embodiments, by filling in the translation patterns, a function-query-constant tree is generated with interior nodes that are functions and leaf nodes that are queries or constants. In some embodiments, the translation pattern is associated with a translation schema. The following is an example of the translation schema. The \u201ctranslation.xsd\u201d XML schema below encodes a parameterized object model for translation patterns as well as the function-query-constant trees that are used to specify instances.",{"@attributes":{"id":"p-0024","num":"0023"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<?xml version=\u201c1.0\u201d encoding=\u201cUTF-8\u201d?>"},{"entry":"<schema targetNamespace=\u201chttp:\/\/www.schemasoft.com\/schema\/"},{"entry":"translation.xsd\u201d"},{"entry":"\u2002xmlns=\u201chttp:\/\/www.w3.org\/2001\/XMLSchema\u201d"},{"entry":"\u2002xmlns:trans=\u201chttp:\/\/www.schemasoft.com\/schema\/translation.xsd\u201d"},{"entry":"\u2002elementFormDefault=\u201cqualified\u201d attributeFormDefault=\u201cunqualified\u201d>"},{"entry":"\u2002<element name=\u201ctranslation\u201d>"},{"entry":"\u2003<annotation>"},{"entry":"\u2003\u2002<documentation>For translation patterns and instances"},{"entry":"\u2003\u2002<\/documentation>"},{"entry":"\u2003<\/annotation>"},{"entry":"\u2003<complexType>"},{"entry":"\u2003\u2002<sequence>"},{"entry":"\u2003\u2003<element name=\u201cobject\u201d type=\u201ctrans:objectType\u201d\/>"},{"entry":"\u2003\u2002<\/sequence>"},{"entry":"\u2003\u2002<attribute name=\u201curi\u201d type=\u201canyURI\u201d use=\u201crequired\u201d\/>"},{"entry":"\u2003\u2002<attribute name=\u201cversion\u201d type=\u201cdecimal\u201d\/>"},{"entry":"\u2003<\/complexType>"},{"entry":"\u2002<\/element>"},{"entry":"\u2002<complexType name=\u201cobjectType\u201d>"},{"entry":"\u2003<choice minOccurs=\u201c0\u201d maxOccurs=\u201cunbounded\u201d>"},{"entry":"\u2003\u2002<element name=\u201cobject\u201d type=\u201ctrans:objectType\u201d\/>"},{"entry":"\u2003\u2002<element name=\u201cparam\u201d type=\u201ctrans:paramType\u201d\/>"},{"entry":"\u2003<\/choice>"},{"entry":"\u2003<attribute name=\u201cname\u201d type=\u201cName\u201d\/>"},{"entry":"\u2003<attribute name=\u201cid\u201d type=\u201cID\u201d\/>"},{"entry":"\u2003<attribute name=\u201chref\u201d type=\u201canyURI\u201d\/>"},{"entry":"\u2002<\/complexType>"},{"entry":"\u2002<complexType name=\u201cparamType\u201d mixed=\u201ctrue\u201d>"},{"entry":"\u2003<choice minOccurs=\u201c0\u201d>"},{"entry":"\u2003\u2002<element name=\u201cfunc\u201d type=\u201ctrans:funcType\u201d\/>"},{"entry":"\u2003\u2002<element name=\u201cquery\u201d type=\u201ctrans:queryType\u201d\/>"},{"entry":"\u2003\u2002<element name=\u201cconst\u201d type=\u201ctrans:constType\u201d\/>"},{"entry":"\u2003<\/choice>"},{"entry":"\u2003<attribute name=\u201cname\u201d type=\u201cName\u201d\/>"},{"entry":"\u2003<attribute name=\u201ctype\u201d type=\u201cstring\u201d\/>"},{"entry":"\u2003<attribute name=\u201cdefault\u201d type=\u201cstring\u201d\/>"},{"entry":"\u2002<\/complexType>"},{"entry":"\u2002<complexType name=\u201cfuncType\u201d>"},{"entry":"\u2002<choice minOccurs=\u201c0\u201d maxOccurs=\u201cunbounded\u201d>"},{"entry":"\u2003<element name=\u201cfunc\u201d type=\u201ctrans:funcType\u201d\/>"},{"entry":"\u2003<element name=\u201cquery\u201d type=\u201ctrans:queryType\u201d\/>"},{"entry":"\u2003<element name=\u201cconst\u201d type=\u201ctrans:constType\u201d\/>"},{"entry":"\u2002<\/choice>"},{"entry":"\u2002<attribute name=\u201cns\u201d type=\u201canyURI\u201d\/>"},{"entry":"\u2002<attribute name=\u201cclass\u201d type=\u201cName\u201d\/>"},{"entry":"\u2002<attribute name=\u201cxpath\u201d type=\u201cstring\u201d\/>"},{"entry":"\u2002<attribute name=\u201cname\u201d type=\u201cName\u201d use=\u201crequired\u201d\/>"},{"entry":"\u2002<attribute name=\u201ctype\u201d type=\u201cstring\u201d\/>"},{"entry":"<\/complexType>"},{"entry":"<complexType name=\u201cqueryType\u201d>"},{"entry":"\u2002<annotation>"},{"entry":"\u2003<documentation>Subclassed for various query sources<\/documentation>"},{"entry":"\u2002<\/annotation>"},{"entry":"\u2002<simpleContent>"},{"entry":"\u2003<extension base=\u201cstring\u201d>"},{"entry":"\u2003\u2002<attribute name=\u201ctype\u201d type=\u201cstring\u201d\/>"},{"entry":"\u2003<\/extension>"},{"entry":"\u2002<\/simpleContent>"},{"entry":"<\/complexType>"},{"entry":"<complexType name=\u201cconstType\u201d>"},{"entry":"\u2002<attribute name=\u201ctype\u201d type=\u201cstring\u201d\/>"},{"entry":"\u2002<attribute name=\u201cvalue\u201d type=\u201cstring\u201d use=\u201crequired\u201d\/>"},{"entry":"<\/complexType>"},{"entry":"<complexType name=\u201cxpathQueryType\u201d>"},{"entry":"\u2002<simpleContent>"},{"entry":"\u2003<extension base=\u201ctrans:queryType\u201d>"},{"entry":"\u2003\u2002<attribute name=\u201cxpath\u201d type=\u201cstring\u201d use=\u201crequired\u201d\/>"},{"entry":"\u2003<\/extension>"},{"entry":"\u2002<\/simpleContent>"},{"entry":"<\/complexType>"},{"entry":"<complexType name=\u201csqlQueryType\u201d>"},{"entry":"\u2002<simpleContent>"},{"entry":"\u2003<extension base=\u201ctrans:queryType\u201d\/>"},{"entry":"\u2002<\/simpleContent>"},{"entry":"<\/complexType>"},{"entry":"<complexType name=\u201cregExpQueryType\u201d>"},{"entry":"\u2002<simpleContent>"},{"entry":"\u2003<extension base=\u201ctrans:queryType\u201d>"},{"entry":"\u2003\u2002<attribute name=\u201cregExp\u201d type=\u201cstring\u201d use=\u201crequired\u201d\/>"},{"entry":"\u2003\u2002<attribute name=\u201cencoding\u201d type=\u201cstring\u201d default=\u201cUTF-8\u201d\/>"},{"entry":"\u2003\u2002<attribute name=\u201cindex\u201d type=\u201cnonNegativeInteger\u201d default=\u201c1\u201d\/>"},{"entry":"\u2003\u2002<attribute name=\u201clength\u201d type=\u201ctrans:nonNegativeCountable\u201d"},{"entry":"\u2003\u2003default=\u201cunbounded\u201d\/>"},{"entry":"\u2003\u2002<attribute name=\u201coverlap\u201d type=\u201cboolean\u201d default=\u201ctrue\u201d\/>"},{"entry":"\u2003<\/extension>"},{"entry":"\u2002<\/simpleContent>"},{"entry":"<\/complexType>"},{"entry":"<complexType name=\u201cbinQueryType\u201d>"},{"entry":"\u2002<complexContent>"},{"entry":"\u2003<extension base=\u201ctrans:queryType\u201d>"},{"entry":"\u2003\u2002<sequence>"},{"entry":"\u2003\u2003<element name=\u201cfunc\u201d type=\u201ctrans:funcType\u201d minOccurs=\u201c0\u201d\/>"},{"entry":"\u2003\u2003<element name=\u201crange\u201d type=\u201ctrans:rangeType\u201d minOccurs=\u201c0\u201d"},{"entry":"\u2003\u2003\u2002maxOccurs=\u201cunbounded\u201d\/>"},{"entry":"\u2003\u2002<\/sequence>"},{"entry":"\u2003\u2002<attribute name=\u201cendian\u201d default=\u201clittle\u201d>"},{"entry":"\u2003\u2003<simpleType>"},{"entry":"\u2003\u2003\u2002<restriction base=\u201cNMTOKEN\u201d>"},{"entry":"\u2003\u2003\u2003<enumeration value=\u201clittle\u201d\/>"},{"entry":"\u2003\u2003\u2003<enumeration value=\u201cbig\u201d\/>"},{"entry":"\u2003\u2003\u2002<\/restriction>"},{"entry":"\u2003\u2003<\/simpleType>"},{"entry":"\u2003\u2002<\/attribute>"},{"entry":"\u2003<\/extension>"},{"entry":"\u2002<\/complexContent>"},{"entry":"<\/complexType>"},{"entry":"<complexType name=\u201crangeType\u201d>"},{"entry":"\u2002<sequence>"},{"entry":"\u2003\u2003<element name=\u201cskip\u201d type=\u201ctrans:delimiterType\u201d minOccurs=\u201c0\u201d"},{"entry":"\u2003\u2003\u2002maxOccurs=\u201cunbounded\u201d\/>"},{"entry":"\u2003\u2003<element name=\u201cstart\u201d type=\u201ctrans:delimiterType\u201d\/>"},{"entry":"\u2003\u2003<element name=\u201cskip\u201d type=\u201ctrans:delimiterType\u201d minOccurs=\u201c0\u201d"},{"entry":"\u2003\u2003\u2002maxOccurs=\u201cunbounded\u201d\/>"},{"entry":"\u2003\u2003<element name=\u201cend\u201d type=\u201ctrans:delimiterType\u201d\/>"},{"entry":"\u2003\u2003<element name=\u201crange\u201d type=\u201ctrans:rangeType\u201d minOccurs=\u201c0\u201d"},{"entry":"\u2003\u2003\u2002maxOccurs=\u201cunbounded\u201d\/>"},{"entry":"\u2003\u2003<element name=\u201ccount\u201d type=\u201ctrans:inputType\u201d minOccurs=\u201c0\u201d\/>"},{"entry":"\u2002<\/sequence>"},{"entry":"<\/complexType>"},{"entry":"<complexType name=\u201cdelimiterType\u201d>"},{"entry":"\u2002<sequence>"},{"entry":"\u2003<element name=\u201coffset\u201d type=\u201ctrans:inputType\u201d minOccurs=\u201c0\u201d\/>"},{"entry":"\u2003<element name=\u201crepeat\u201d type=\u201ctrans:inputType\u201d minOccurs=\u201c0\u201d\/>"},{"entry":"\u2002<\/sequence>"},{"entry":"\u2002<attribute name=\u201calign\u201d type=\u201cpositiveInteger\u201d default=\u201c1\u201d\/>"},{"entry":"\u2002<attribute name=\u201cbitsPerUnit\u201d type=\u201cpositiveInteger\u201d default=\u201c8\u201d\/>"},{"entry":"\u2002<attribute name=\u201cref\u201d default=\u201crelative\u201d>"},{"entry":"\u2003<simpleType>"},{"entry":"\u2003\u2002<restriction base=\u201cNMTOKEN\u201d>"},{"entry":"\u2003\u2003<enumeration value=\u201crelative\u201d\/>"},{"entry":"\u2003\u2003<enumeration value=\u201ccurrent\u201d\/>"},{"entry":"\u2003\u2003<enumeration value=\u201cabsolute\u201d\/>"},{"entry":"\u2003\u2002<\/restriction>"},{"entry":"\u2003<\/simpleType>"},{"entry":"\u2002<\/attribute>"},{"entry":"<\/complexType>"},{"entry":"<complexType name=\u201ccompareDelimiterType\u201d>"},{"entry":"\u2002<complexContent>"},{"entry":"\u2003<extension base=\u201ctrans:delimiterType\u201d>"},{"entry":"\u2003\u2002<sequence>"},{"entry":"\u2003\u2003<element name=\u201ccompareTo\u201d type=\u201ctrans:inputType\u201d\/>"},{"entry":"\u2003\u2002<\/sequence>"},{"entry":"\u2003\u2002<attribute name=\u201csize\u201d type=\u201cpositiveInteger\u201d default=\u201c1\u201d\/>"},{"entry":"\u2003\u2002<attribute name=\u201cinterval\u201d type=\u201cpositiveInteger\u201d\/>"},{"entry":"\u2003\u2002<attribute name=\u201crelation\u201d default=\u201cequal\u201d>"},{"entry":"\u2003\u2003<simpleType>"},{"entry":"\u2003\u2003\u2002<restriction base=\u201cNMTOKEN\u201d>"},{"entry":"\u2003\u2003\u2003<enumeration value=\u201cless\u201d\/>"},{"entry":"\u2003\u2003\u2003<enumeration value=\u201clessOrEqual\u201d\/>"},{"entry":"\u2003\u2003\u2003<enumeration value=\u201cequal\u201d\/>"},{"entry":"\u2003\u2003\u2003<enumeration value=\u201cgreaterOrEqual\u201d\/>"},{"entry":"\u2003\u2003\u2003<enumeration value=\u201cgreater\u201d\/>"},{"entry":"\u2003\u2003\u2003<enumeration value=\u201cnotEqual\u201d\/>"},{"entry":"\u2003\u2003\u2002<\/restriction>"},{"entry":"\u2003\u2003<\/simpleType>"},{"entry":"\u2003\u2002<\/attribute>"},{"entry":"\u2003<\/extension>"},{"entry":"\u2002<\/complexContent>"},{"entry":"<\/complexType>"},{"entry":"<complexType name=\u201cregExpDelimiterType\u201d>"},{"entry":"\u2002<complexContent>"},{"entry":"\u2003<extension base=\u201ctrans:delimiterType\u201d>"},{"entry":"\u2003\u2002<attribute name=\u201cregExp\u201d type=\u201cstring\u201d use=\u201crequired\u201d\/>"},{"entry":"\u2003\u2002<attribute name=\u201cencoding\u201d type=\u201cstring\u201d default=\u201cUTF-8\u201d\/>"},{"entry":"\u2003\u2002<attribute name=\u201cmatchedChar\u201d default=\u201cfirst\u201d>"},{"entry":"\u2003\u2003<simpleType>"},{"entry":"\u2003\u2003\u2002<restriction base=\u201cNMTOKEN\u201d>"},{"entry":"\u2003\u2003\u2003<enumeration value=\u201cfirst\u201d\/>"},{"entry":"\u2003\u2003\u2003<enumeration value=\u201clast\u201d\/>"},{"entry":"\u2003\u2003\u2002<\/restriction>"},{"entry":"\u2003\u2003<\/simpleType>"},{"entry":"\u2003\u2002<\/attribute>"},{"entry":"\u2003<\/extension>"},{"entry":"\u2002<\/complexContent>"},{"entry":"<\/complexType>"},{"entry":"<complexType name=\u201cinputType\u201d mixed=\u201ctrue\u201d>"},{"entry":"\u2003<choice minOccurs=\u201c0\u201d>"},{"entry":"\u2003\u2002<element name=\u201cfunc\u201d type=\u201ctrans:funcType\u201d\/>"},{"entry":"\u2003\u2002<element name=\u201cquery\u201d type=\u201ctrans:queryType\u201d\/>"},{"entry":"\u2003\u2002<element name=\u201cconst\u201d type=\u201ctrans:constType\u201d\/>"},{"entry":"\u2003<\/choice>"},{"entry":"\u2003<attribute name=\u201ctype\u201d type=\u201cstring\u201d\/>"},{"entry":"\u2002<\/complexType>"},{"entry":"\u2002<simpleType name=\u201cnonNegativeCountable\u201d>"},{"entry":"\u2003<union>"},{"entry":"\u2003\u2002<simpleType>"},{"entry":"\u2003\u2003<restriction base=\u201cnonNegativeInteger\u201d\/>"},{"entry":"\u2003\u2002<\/simpleType>"},{"entry":"\u2003\u2002<simpleType>"},{"entry":"\u2003\u2003<restriction base=\u201cstring\u201d>"},{"entry":"\u2003\u2003\u2002<enumeration value=\u201cunbounded\u201d\/>"},{"entry":"\u2003\u2003<\/restriction>"},{"entry":"\u2003\u2002<\/simpleType>"},{"entry":"\u2003<\/union>"},{"entry":"\u2002<\/simpleType>"},{"entry":"<\/schema>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0025","num":"0024"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["<translation>","The <translation> element is outermost, with a uri attribute to uniquely"]},{"entry":[{},"identify the pattern and a version attribute to keep track of ongoing"]},{"entry":[{},"updates to the pattern."]},{"entry":["<object>","The pattern's object model is written as a hierarchy of <object>"]},{"entry":[{},"elements, each can have a name attribute to identify its class, as well as"]},{"entry":[{},"an href attribute to point to an external definition of the object, or an id"]},{"entry":[{},"attribute to allow others to point to this object definition."]},{"entry":["<param>","The object model is parameterized with <param> elements with name"]},{"entry":[{},"attribute to identify the parameter, type attribute to indicate data type"]},{"entry":[{},"expected for the parameter, and default attribute giving the value used"]},{"entry":[{},"when the parameter is not filled in. Parameters are filled in by"]},{"entry":[{},"providing a <func>, <query> or <const> child element."]},{"entry":["<func>","Input data is manipulated with functions represented by <func>"]},{"entry":[{},"elements. These are identified by their name attribute, and the return"]},{"entry":[{},"type is as specified by their type attribute. Functions that are methods"]},{"entry":[{},"of objects in the translator's output object tree are indicated by"]},{"entry":[{},"providing an xpath attribute to point to the object, or a class attribute to"]},{"entry":[{},"identify the class of the object. In the latter case, the first argument of"]},{"entry":[{},"the function is the \u201cthis\u201d argument that determines which object of the"]},{"entry":[{},"given class is being referenced, unless the function is static, in which"]},{"entry":[{},"case no \u201cthis\u201d argument is needed. The ns attribute can be used to"]},{"entry":[{},"identify function libraries or packages with a namespace. When"]},{"entry":[{},"referring to member functions of objects generated by another"]},{"entry":[{},"translation pattern instance, this must match the uri attribute of the"]},{"entry":[{},"corresponding <translation> element."]},{"entry":[{},"Each of the child elements of a <func> element describes how to fill"]},{"entry":[{},"one of the function inputs. The allowed child elements are the same as"]},{"entry":[{},"those used to fill in parameters: <func>, <query> or <const>. Queries can"]},{"entry":[{},"return collections, such as the node sets returned by XPaths."]},{"entry":[{},"Collections are interpreted as arrays for purposes of function input."]},{"entry":[{},"When an array of objects is specified for an input not typed as an"]},{"entry":[{},"array, the function is to be applied to each element of the array"]},{"entry":[{},"individually, and an array of results is to be returned. This can lead to"]},{"entry":[{},"arrays of arrays being returned if more than one argument is specified"]},{"entry":[{},"in this manner. The interpretations described here are enforced by"]},{"entry":[{},"default in the code generators for translation patterns."]},{"entry":["<query>","Each <query> element specifies how to get a unit of information from"]},{"entry":[{},"the source file, and its type attribute indicates the data type of the"]},{"entry":[{},"information once gotten. This attribute is not to be confused with the"]},{"entry":[{},"xsi:type attribute for indicating the inherited type of <query> element"]},{"entry":[{},"used in instance documents. There are four inherited types of <query>"]},{"entry":[{},"element defined in translation.xsd, all by extension of the base queryType."]},{"entry":[{},"These are: xpathQueryType for XPath queries on XML document"]},{"entry":[{},"sources, sqlQueryType for SQL queries on database sources,"]},{"entry":[{},"regExpQueryType for regular expression queries on text file sources,"]},{"entry":[{},"and binQueryType for queries on binary source files."]},{"entry":["<const>","Constants are set with the <const> element by providing the data type in"]},{"entry":[{},"its type attribute and the data value in its value attribute."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"At , a translator is generated at least in part by using the function-query-constant tree. In some embodiments, the tree is used at least in part to generate code that can be compiled\/interpreted to generate a translator.","In some embodiments, a parser is generated in . For example, an instantiated parser is associated with a tree of target objects under class membership. The children of a given object are among its member objects. The object model is defined by associating together a collection of parsing patterns. In some embodiments, the association includes setting \u201chref\u201d attributes on \u201c<object>\u201d elements of files adhering to the \u201ctranslation.xsd\u201d schema. Each target object implements a parse interface, including a method to read itself. The code to do this is determined by the function-query-constant trees assigned to the pattern object model's parameters. A binary file format parser uses the \u201cbinQueryType\u201d of \u201c<query>\u201d element to specify file access. For example, the \u201cbinQueryType\u201d content model includes \u201c<range>\u201d elements used to specify byte ranges. \u201c<range>\u201d elements can contain other \u201c<range>\u201d elements, so that the final data query can be arrived at via a process of refinement in which ranges, sub-ranges, and sub-sub-ranges identified. The \u201cbinQueryType\u201d content model allows an optional \u201c<func>\u201d element. If present, this means that the query is to be performed on the stream output of the function identified by the \u201c<func>\u201d element rather than on the source file stream. That function can be a member function of a parser target object, and its inputs can be specified as file stream read operations and\/or further function calls. The implications for data flow are that parts of the file stream can be processed in stages, each intermediate stage being another stream. The formalism and code generator are capable of handling these intermediate streams in the same manner as the original file stream. This is useful when the source format has any of the following features: structured storage, such as OLE DocFile or RIFF (Resource Interchange File Format); compression, such as Huffman, Lempel-Ziv-Welch, arithmetic coding, run-length coding, discrete cosine transform, or fractal; encoding, such as Base64, UUencode, BinHex, Quoted-Printable or yEnc Encryption, such as RSA, Diffie-Hellman, DES, Blowfish, IDEA, or RC4; embedded formats; and\/or proprietary obfuscation algorithms.","In some embodiments, binary queries can access arrays of data just as XPath queries can. In particular, multiple sibling \u201c<range>\u201d elements are interpreted as an array of values. Furthermore, an optional \u201c<count>\u201d child of the \u201c<range>\u201d element can be used to access repetitive byte sequences as arrays. This \u201c<count>\u201d element specifies the maximum number of times to repeat the range specification; the end of the stream or sub-stream might be reached first. Often, the \u201c<count>\u201d data is something that must be read from file, rather than a constant. The same is true of other elements used to express binary queries; namely, \u201c<offset>\u201d, \u201c<repeat>\u201d and \u201c<compareTo>\u201d. For this reason, all four elements can have separate function-query-constant trees descending from them (they all have type \u201cinputType\u201d). \u201c<range>\u201d nodes can have \u201c<func>\u201d children. Thus \u201cbinQueryType\u201d \u201c<query>\u201d elements have the unique feature that further \u201c<query>\u201d elements can be descendants to any depth, and there are many ways in which this can occur.","In some embodiments, each \u201c<range>\u201d element has \u201c<start>\u201d and \u201c<end>\u201d children to delimit the start and end of a byte sequence or bit sequence that is to be read, and these delimiter elements can be interspersed with any number of \u201c<skip>\u201d elements to indicate ranges that are skipped over, not read. \u201c<start>\u201d, \u201c<end>\u201d and \u201c<skip>\u201d elements are all of type \u201cdelimiterType\u201d, and allows specification of a stream position by any of the following kinds of operations, in the following order:\n\n","In some embodiments, a mapper translator is generated in . In some embodiments, the source of the mapper translator is output of a parser translator, and the output is queried with the \u201cxpathQueryType\u201d of \u201c<query>\u201d element. In some embodiments, even though the queries of in-memory objects and not serialized XML, the \u201cxpathQueryType\u201d is used to specify the queries since it is convenient to describe object queries in terms of queries on the prescribed XML serialization of the objects, even the serialization is not performed. The \u201cxpathQueryType\u201d of \u201c<query>\u201d element has a required \u201cxpath\u201d attribute that encodes its data as a standard XPath. The XPath is interpreted as acting on the source object model, where objects are interpreted as nodes and member objects are interpreted as child nodes. The context for the XPath is set by the code generated from the mapper pattern, starting with a context node assignable to each mapper pattern object. XPath expressions that return node sets are normally turned into code that returns arrays as defined in the target language of the code generator.","In some embodiments, a serializer translator is generated in . In some embodiments, the serializer is implemented via an interface implemented by each of the objects in the mapper target format. This is optimized so that each mapper target object serializes itself as soon as all its information has been read in from the parser's target object tree. In some embodiments, serialization is used for test purposes during development. For example, the parser and mapper target objects implement the serialization interface in debug builds. Control flow usually begins at the root of the mapper target object tree. In the case of a translator that serializes its output, control begins with a call to the root object's \u201cwrite\u201d member function. As with other objects in the target object tree, this will trigger calls into the parser target object tree to access its member data, which will be written out, interspersed with calls to the \u201cwrite\u201d functions of child objects (which are created as needed). When parser target objects are queried, they will read their data in, create any other objects on which they depend (if not already created), and query any other objects on which they depend. Generally, dependence happens along lines of ancestry.","In some embodiments, generating the translator includes generating code that can be compiled to the translator. In some embodiments, the code is C++ code. The code generator uses XML written in the grammar of \u201ctranslation.xsd\u201d and performs a templating function derived by the input XML. In some embodiments, XSLT is used to produce the C++ code. In some embodiments, a translator consists of general code infrastructure into which specific, generated code components plug in. The general code takes the form of a set of libraries that are statically linked, and is needed to look after things like setting context variables, managing input and output streams, and managing information that permits streaming, progressive rendering and memory use optimizations. The specific code components plug in by inheriting from library base classes and implementing library interfaces. These interfaces include handlers for the various parsing, mapping and serializing tasks, and they provide access to runtime variables affecting the specific code. In some embodiments, there exists \u201cdefault\u201d code-generators associated with master XSLT files that are imported into each individual pattern's XSLT file, and whose individual code-generating templates can be overridden. The default code-generators generate C++ classes and member variables with naming and membership corresponding to the translation pattern's object model, and they will provide a generic treatment for function-query-constant trees. Pattern-specific overrides can, for example, create a target object model different from the pattern object model and can add member functions specific to each object. In some embodiments, parser pattern overrides tend to leave the default target object model code generation in place (but will change other things), whereas mapper pattern overrides tend to replace the default with code generation for target objects that is unique to each pattern. This reflects the assertion that a parser's job is to faithfully construct an in-memory object representation of the input information without fundamentally changing or re-interpreting that information, whereas a mapper's job is to apply whatever re-interpretation is necessary to optimally map to target format constructs.","At , the generated translator is verified. In some embodiments, verifying the translator includes translating a test file and examining the output. In some embodiments, examining the output includes presenting the output and\/or a representation thereof to a user and receiving feedback from the user. If the output is not (entirely) valid, one or more translations patterns and\/or parameters are modified (e.g., as specified or otherwise indicated by a user), and the translator is regenerated with the modifications. In some embodiments, regenerating the translator with modifications includes repeating -, as applicable. The verification and regeneration is performed until the translator is valid. In some embodiments, the verification and modification is at least in part performed using a graphical interface tool. In some embodiments, the verification is optional.","An object-oriented library is the implementation of a collection of classes. Classes have properties and methods. The properties may be primitive objects (such as integers or characters), instances of other objects in the collection, or collections of objects. Specific details vary, based on programming language constructs, support for reflection (which permits run-time inspection of arbitrary classes), and\/or supported dispatch mechanisms. In some embodiments, automated access to computer documents is often provided through an object-oriented software library whose classes and methods provide access to everything in the document. The interface exposed by this library is the \u201cApplication Programming Interface\u201d (API). In some embodiments, the API is \u201cfully-abstract\u201d, projecting all the information that is required by the consuming application but not providing any additional information. For example, for a format that links together blocks of characters, the API might simply provide access to the characters in order, without exposing the linking mechanism at all. Such abstraction mechanisms are pervasive because they are crucial to the management of complexity in the development of real-world software.","As used herein, an abstraction is a projection or function from one domain to another. An API implements a projection (of the binary data in a document to the data types it provides). In some embodiments, the projected view is associated with a tree structure. In some embodiments, document APIs are used for purposes, such as mapping one format to another, providing searching and indexing capabilities, and\/or rendering the elements visually. Real-world document API can be complex and developing software that uses them can be time-consuming and costly. A document query includes extracting specific kinds of data from a content (e.g., document) using the API. In some embodiments, the time it takes to develop software that uses the API can be reduced by using a language that specifies one or more queries for automatically generating program code.","For our purposes, we define an \u201celement\u201d to be an object with a name and a (possibly empty) set of attributes. An \u201cattribute\u201d is an object with a name and a value that is a primitive object, such as an integer, a real number, a character, or a string. A \u201ctree\u201d is a set of elements E together with a partial ordering <of E such that, for each e in E, {f in E|f<e} is well ordered. This set of elements is called the \u201cancestors\u201d of e. The ordinality of the ancestors is called the \u201cheight\u201d of e. The \u201cdescendants\u201d of an element e are {f in E|e<f}. If e is an element with height k, the \u201cchildren\u201d of e are the set of elements f whose height is k+1 and such that e<f. e is called the \u201cparent\u201d of each f in the set. If the set is empty, then e is called a \u201cleaf\u201d. The \u201csiblings\u201d of an element e are all the elements whose parent is the parent of e. An \u201cordered tree\u201d is a tree which has exactly one element of height , called the \u201croot\u201d of the tree, and which has an element ordering that is defined between the children of any element in the tree. A \u201ctree schema\u201d is a set of constraints over trees from which it is possible to define a predicate valid(t). All the elements of an ordered tree can be well-ordered in a sequence E, E, E, . . . , E, as follows:\n\n","In some embodiments, schemas are defined by providing a set of element names, a set of attributes for each element, and various constraints of the possible descendants of each element. Trees can support linked and cyclic structures through the use of reference attributes. In an object-oriented programming language such as C++, trees are commonly implemented using a Composite pattern. Each element type is defined by a class with a common base class. The base class provides a container for the children. The element's attributes are defined by properties of the class. This implementation allows trees to be constructed and traversed, from the root to a specific element. Implementations of trees do not always provide a means of traversing down the tree, or to a sibling node (these trees grow from the root downwards). A reference is an expression that uniquely identifies an element in a tree. There are various possible ways to express references. For example, a finite sequence of numbers (assuming directed trees) can be used, where an empty sequence designates the root of the tree, otherwise the first number designates the child of the root, the second number the index of its child. The number \u22121 designates a parent. Using this language, a reference to any node in a tree from a given node can be specified.","In some embodiments, a query takes a tree and returns data. A query can return one or more of the following: a primitive value, an element from the tree, and an ordered set of elements. A query is an expression that defines an attribute, element or set of elements for a given tree, given a specific element (the starting position of the query). References augmented by a period (.) and a name for attributes, and special operators such as \u201cdescendants\u201d and \u201cancestors\u201d can be used to define a query language. In the XML query language XPath, these operators are called axis specifiers. A filter may be added to a query, where a filter is a predicate that can determine whether or not to include a node or attribute in the query result. A \u201cstep\u201d is a triplet \u201c<a,n,F>\u201d where a is an axis specifier, n is a node-test, and F is a (possibly empty) set of filter tests. A \u201cquery\u201d is a pair \u201c<a,S>\u201d where a is either absolute or relative, and S is a sequence of steps. Intuitively, absolute queries start from the root of a tree, while relative queries start from some given position in the tree. The notation \u201cP.t\u201d is used to indicate a query made up of a sequence P of steps, and a single step t. P is called the \u201cprefix\u201d of the query. The example above is not dependant on any particular realization of a tree-based or xml-based query language. The XPath language is a widely used example of a query language, and all queries as defined here can be expressed using XPath syntax.","In some embodiments, the code generated by a given translation pattern executes in an order unique to that pattern. Normally, this means that the document order of the \u201c<param>\u201d elements in the pattern's parameterized object model is the order in which these parameters are read in, and each element of the target object model is created as soon as all the information needed to produce it has been read in. When information is available for creating multiple output objects simultaneously, the output objects are created in output object model document order. When serialization of the output object model is needed or desired, the elements are serialized in a separate thread, in document order up to the last element whose existence, name and attributes are known to be complete. This method ensures that information is streamed out as soon as possible, which permits the progressive display of information by an application during the translation process.","The following is an example of the order of execution of code associated with one \u201c<param>\u201d element's specification: Its function-query-constant tree is traversed in document order. When a \u201c<const>\u201d is encountered, the specified constant is just instantiated and assigned in memory. When a \u201c<func>\u201d is encountered, the corresponding function is called in a function library linked to the generated code. When a \u201c<query>\u201d is encountered, that query is executed according to the methods described later in this document.","Some objects in the parameterized object model for a given pattern have parameters, and others do not. The ones without parameters are represented by a reference to another pattern instance or the same pattern instance, as in the following example:",{"@attributes":{"id":"p-0042","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<?xml version=\u201c1.0\u201d encoding=\u201cUTF-8\u201d?>"},{"entry":"<translation xmlns=\u201chttp:\/\/www.schemasoft.com\/schema\/translation.xsd\u201d"},{"entry":"\u2002xmlns:xsi=\u201chttp:\/\/www.w3.org\/2001\/XMLSchema-instance\u201d"},{"entry":"\u2002xsi:schemaLocation=\u201chttp:\/\/www.schemasoft.com\/schema\/translation.xsd"},{"entry":"\u2002translation.xsd\u201d uri=\u201chttp:\/\/www.schemasoft.com\/translations\/headers\u201d>"},{"entry":"\u2002<object name=\u201clist\u201d id=\u201csections\u201d>"},{"entry":"\u2003<param name=\u201cfor\u201d>"},{"entry":"\u2003\u2002<query xsi:type=\u201cxpathQueryType\u201d xpath=\u201c.\/section\u201d"},{"entry":"\u2003\u2003type=\u201cnodeset\u201d\/>"},{"entry":"\u2003<\/param>"},{"entry":"\u2003<object name=\u201csection\u201d>"},{"entry":"\u2003\u2002<param name=\u201ctitle\u201d>"},{"entry":"\u2003\u2003<query xsi:type=\u201cxpathQueryType\u201d xpath=\u201c.\/title\/text( )\u201d"},{"entry":"\u2003\u2003\u2002type=\u201cstring\u201d\/>"},{"entry":"\u2003\u2002<\/param>"},{"entry":"\u2003\u2002<object name=\u201ccontent\u201d href=\u201c.\/content.xml\u201d\/>"},{"entry":"\u2003\u2002<object name=\u201clist\u201d href=\u201c#sections\u201d\/>"},{"entry":"\u2003<\/object>"},{"entry":"\u2002<\/object>"},{"entry":"<\/translation>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"In some embodiments, an efficient method is used to create and serialize target objects. The base class for each target object in the target object tree has a state variable that takes one of the following values; for example, as an enumeration in C++:\n\n","In some embodiments, target objects can be re-used. In some embodiments, functions given in function-query-constant trees can be methods on objects in the target object model. If data computed by one generated code fragment is needed by another generated code fragment, then the first code fragment can store it in the target object tree, and the second code fragment can access the data there. This avoids unnecessary re-computing of results. Even if the re-used data is just an intermediate result and is not to be serialized, it can be stored in the target object tree with serialization methods that do nothing. Another option is to create custom objects just for the purpose of storing intermediate results, and to access their methods in pattern instances. When accessing target objects in this manner, the writable state is used to determine whether the object's name and attributes can be accessed, and the completeness state is used to determine whether an object's children can be accessed. The generated code can do lazy querying of the source document, only actually implementing the queries that are used to fill out the target objects when the information is needed.","In some embodiments, output content is written as a stream. The states can be used to determine how much of the tree can be safely serialized without backtracking in the output stream, even though the tree could be built in memory in any order. The serializable portion can be efficiently updated just by checking the states of neighboring elements, rather than having to traverse the whole tree every time there is a change. When generated code determines that a \u201cnotWritable\u201d element's name and attributes are ready to be written out, it calls a \u201cwritable( )\u201d method that does the following: If the previous element in document order is \u201ccomplete\u201d or \u201cdisposable\u201d and \u201clastWritable\u201d, \u201cwritten\u201d or \u201clastWritten\u201d; or if there is no previous element (because the current element is the root), then the current element is changed to \u201clastWritable\u201d (and if the previous element was \u201clastWritable\u201d it is changed to \u201cwritable\u201d); otherwise the current element is changed to \u201cwritable.\u201d Furthermore, when generated code determines that an \u201cincomplete\u201d element is now \u201ccomplete,\u201d it calls a \u201ccomplete( )\u201d method that changes the state to \u201ccomplete\u201d and, if that element is also \u201clastWritable\u201d, \u201cwritten\u201d or \u201clastWritten\u201d then iterates forward in document order and calls \u201cwritable( )\u201d on each element until encountering the first element that is not \u201cwritable.\u201d This has the effect of moving the \u201clastWritable\u201d position forward as far as it can go. A separate thread can actually do the writing at any time from the \u201clastWritten\u201d element to the \u201clastWritable\u201d element (when one exists) or a \u201cwrite( )\u201d method can be called every time the state of an element changes to \u201clastWritable.\u201d The \u201cwrite( )\u201d method writes an element's start tag and attributes after closing any needed end tags, then changes the element's state to \u201cwritten\u201d, unless the element before it in document order is \u201clastWritten\u201d; in which case it changes the element's state to \u201clastWritten\u201d and the previous element's state to \u201cwritten.\u201d","In some embodiments, memory can be opportunistically purged. In some embodiments, target elements are marked as disposable when they have been written and they are no longer going to be accessed. In the case of a memory exception or internally-imposed limit, any subtrees that are entirely disposable can be deleted to free up memory.",{"@attributes":{"id":"p-0047","num":"0070"},"figref":"FIG. 5","b":["502","504","506","508","502","502","504","506","510","508","508","510"]},{"@attributes":{"id":"p-0048","num":"0071"},"figref":["FIG. 6","FIG. 5"],"b":["606","508","606","602","604","606","608"]},{"@attributes":{"id":"p-0049","num":"0072"},"figref":["FIG. 7","FIG. 5","FIG. 6"],"b":["510","608","702","704","706","706"]},"In some embodiments, standards for code included in the generated source codes includes one or more of the following standards:\n\n","In some embodiments, a special variable called currentNode is assumed to be a reference to a node in a tree. In some embodiments, a collection of variables called attributeValueT is set to the result of an attribute query, where T is the type of the attribute value. In some embodiments, given a query and the schema, the compiler can determine the kind of query, where the kind can be attribute, element or sequence of elements. If Q is a query, we write kind(Q) to indicate the kind of the query.","In some embodiments, a query is a sequence of steps, each step is a triplet, and the query's kind can be determined. For example, queries can be written as P.s where P is a (possibly empty) sequence of steps, and s is a step. In some embodiments, the generated code can be fully determined by the schema and the coding standards.","The generic query compiler has a class for every possible node-test. These classes all inherit from a base class that provides a standard \u201ccompileQuery\u201d method. The compiler starts by examining the step \u201c<a,n,F>\u201d. Using a factory, an instance of the class corresponding to n is created. Its compileQuery method is then called, passing the entire query. In some embodiments, this method allows the subclass method to by-pass the normal code generation pattern if necessary.","A standard way to implement the compiler is to provide a class with generic methods for each of the cases described below. For example, a method of this class is:",{"@attributes":{"id":"p-0055","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"GenericComplier::CompileStringAttribute(const char* name)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003char buffer[2000];"]},{"entry":[{},"\u2003\u2003sprintf(buffer,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201dattributeValueString = currentNode.get%s\\n\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003name);"]},{"entry":[{},"\u2003\u2003code->output(buffer);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0056","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class E"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"\u2003\u2003compileAttribute(const char* name)"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003genericCompiler-> CompileStringAttribute(name);"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The following is an example of compiling element node tests. When the node test is a simple element name, there are three code patterns, one for each kind of query. In the case where the kind is not sequence, the query specifies a single value accessed from a single element in the source tree. Prefix of the query must be of kind element. Whenever code is generated for an element, the variable \u201ccurrentNode\u201d will be set to the appropriate node. The following is an example of the three code patterns.","Kind attribute\u2014Assume: T=String, attribute name=Attr. kind(Prefix)=element.\n\n","Kind element\u2014Assume: Node test is Elt. kind(Prefix)=element.\n\n","Kind sequence\u2014In this case, instead of returning all the elements that satisfy the node test, the compiler creates an iterator. The kind of the prefix also determines the output code pattern. If kind(P)=element, then the generated code obtains an iterator for the node-test using\n\n",{"@attributes":{"id":"p-0061","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class Iterator"},{"entry":"{"},{"entry":"\u2003private:"},{"entry":"\u2003\u2003\u2003Iterator* elementIterator; \/\/ nill if kind(parent)=element"},{"entry":"\u2003\u2003\u2003Iterator* parentIterator;"},{"entry":"\u2003\u2003\u2003char* nodeTest;"},{"entry":"\u2003public:"},{"entry":"\u2003\u2003\u2003Iterator(Iterator* parent,const char* nodeTest,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Element* currentNode);"},{"entry":"\u2003\u2003\u2003Element* nextElement( );"},{"entry":"};"},{"entry":"Iterator::Iterator(Iterator* parentIterator,const char* nodeTest, Element*"},{"entry":"currentNode)"},{"entry":"{"},{"entry":"\u2003\u2003\u2003this->parentIterator = parentIterator;"},{"entry":"\u2003\u2003\u2003this->nodeTest = nodeTest;"},{"entry":"\u2003\u2003\u2003if(this->parentIterator)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Element* parentElement ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003this->parentIterator->nextObject( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003elementIterator ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003parentElement->elementIterator(nodeTest);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003elementIterator ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003currentNode->elementIterator(nodeTest);"},{"entry":"}"},{"entry":"Element* nextElement( )"},{"entry":"{"},{"entry":"\u2003\u2003\u2003Element* result = elementIterator->nextObject( );"},{"entry":"\u2003\u2003\u2003if(result) return result;"},{"entry":"\u2003\u2003\u2003Element* parentElement;"},{"entry":"\u2003\u2003\u2003if(parentIterator)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003parentElement ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003parentIterator->nextElement( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if(!parentElement) return nil;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003elementIterator ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003new parentElement->elementIterator(nodeTest);"},{"entry":"\u2003\u2003\u2003return elementIterator->nextObject( );"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The constructor and nextElement can be overwritten to take advantage of the existence of a specific iterator method in the parent object that provides an iterator for children with the given name. There are slightly different patterns for kind(P)=sequence and kind(P)=element. Thus the generated iterator for a node test whose element name is Elt will be:",{"@attributes":{"id":"p-0063","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Case 1: kind(P) = element, element name of parents node's last step: N"},{"entry":"\u2003\u2003class Elt: public Iterator"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003public:"},{"entry":"\u2003\u2003\u2003\u2003Elt (Iterator* parent)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003this->parentIterator = NULL;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003this->nodeTest = \u201cElt\u201d;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003elementIterator ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003currentNode->elementIteratorN( );"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003Element* nextElement( )"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Element* result = elementIterator->nextObject( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return result;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003};"},{"entry":"Case 2: kind(P) = sequence, element name of parents node's last step: N"},{"entry":"\u2003\u2003class Elt: public Iterator"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003public:"},{"entry":"\u2003\u2003\u2003\u2003Elt(Iterator* parent):super(parent,\u201dElt\u201d,NULL){ }"},{"entry":"\u2003\u2003\u2003\u2003Element* nextElement( )"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003Element* result = elementIterator->nextObject( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003if(result) return result;"},{"entry":"\u2003\u2003\u2003\u2003\u2003Element* parentElement;"},{"entry":"\u2003\u2003\u2003\u2003\u2003parentElement = parentIterator->nextElement( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003if(!parentElement) return nil;"},{"entry":"\u2003\u2003\u2003\u2003\u2003elementIterator = new parentElement->elementIteratorN( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003return elementIterator->nextObject( );"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The following is an example of compiling code for filters. A step that contains a sequence of filters is of kind sequence. An iterator is generated for each filter. There are two types of filters: a literal index (a positive integer) and an expression. The code generated for expressions is a copy of the filter, except that any embedded query is compiled first. In the special case of node( ).attr, the generated expression is currentNode->getAttr( ). The iterator for a filter F where EXPRESSION(F) indicates the expression corresponding to the filter is:",{"@attributes":{"id":"p-0065","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class Filter: public Iterator"]},{"entry":[{},"{"]},{"entry":[{},"\u2003public:"]},{"entry":[{},"\u2003\u2003\u2003Filter(Iterator* parent):super(parent,NULL,NULL){ }"]},{"entry":[{},"\u2003\u2003\u2003Element* nextElement( )"]},{"entry":[{},"\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003Element* result;"]},{"entry":[{},"\u2003\u2003\u2003\u2003while(result = elementIterator->nextObject( )"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003&&  EXPRESSION(F));"]},{"entry":[{},"\u2003\u2003\u2003\u2003return result;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0066","num":"0107"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class Filter: public Iterator"]},{"entry":[{},"{"]},{"entry":[{},"\u2003public:"]},{"entry":[{},"\u2003\u2003\u2003Filter(Iterator* parent):super(parent,NULL,NULL){ }"]},{"entry":[{},"\u2003\u2003\u2003Element* nextElement( )"]},{"entry":[{},"\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003count = 0;"]},{"entry":[{},"\u2003\u2003\u2003\u2003Element* result;"]},{"entry":[{},"\u2003\u2003\u2003\u2003while(result = elementIterator->nextObject( )"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003&&  count++<N);"]},{"entry":[{},"\u2003\u2003\u2003\u2003return result;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In some embodiments, there exists an object identified as \u201cdocument\u201d with a method named \u201croot\u201d that returns the root element of the document. For the example query:\n\n",{"@attributes":{"id":"p-0068","num":"0110"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"currentNode = document->root( ); \/\/ \/a"]},{"entry":[{},"Ib bs = new Ib(NULL,\u201db\u201d,currentNode);"]},{"entry":[{},"Ic cs = new Ic(bs,\u201dc\u201d,NULL);"]},{"entry":[{},"If fs = new If(cs,NULL,NULL);"]},{"entry":[{},"C* elt = NULL;"]},{"entry":[{},"int i = 0;"]},{"entry":[{},"while(i<1 &&  elt = cs->nextObject( ));"]},{"entry":[{},"if(i==1)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\u2003currentNode = elt;"]},{"entry":[{},"}"]},{"entry":[{},"\/\/ Precondition: currentNode is NULL or points to"]},{"entry":[{},"\/\/ correct node in tree"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Although it is always possible to compile code for arbitrary queries, the compiler may constrain the queries allowed to avoid generating inefficient code. For example, if the API does not provide a \u201cgetParent\u201d operator, then queries such as\n\n","In some embodiments, a real-world API has partial compliance to the coding standards implied by the assumption stated above. A general method for extending the code generator described above so that it can generate code that works for any document API is disclosed. The document schema is independent of any particular coding standard. The purpose of the schema is to provide developers with a uniform and consistent view of the data in documents. This can be thought of as a \u201cvirtual\u201d API for the document. The actual API may be designed with particular design criteria that are not directly compatible with the schema. Examples include attributes that can be inferred but are not provided directly (which we call synthetic attributes), mechanisms for navigating through the document which do not follow the straight-forward tree traversal methods implied by the schema, and performance requirements satisfied either by providing methods and classes that are not part of the schema, or by placing constraints on API calls. Traditionally it was up to developers to determine from the API documentation (and perhaps by trial-and-error) how to use the API to effect particular queries. The query compiler represents an encapsulation of this knowledge in a useful form.","In some embodiments, the generic code generator uses a distinct class for each node test, and the code generation methods for each node test are independent. The code generator is presented with the entire query before the query prefix is used to generate code. The code generator for a particular node test can control the overall code pattern. For example, the code generator for a particular element E could even use a pattern different from the prefix P that it is given. These two points allow the code generator to emit code patterns that vary widely from the generic patterns. The following are examples.","Access to text: Conceptually, a body of text can be considered to be the value of an attribute of an element. In practise, text is usually treated differently, mainly because the size of text objects may be large. The node-test in XPath for text is \u201ctext( )\u201d. The generic compiler generates elt->getText( ), but the document specific compiler will generate code which is consistent with the API's requirement for accessing text.","Synthetic Attributes: A synthetic attribute is defined in the API documentation as an attribute that is not present, but whose value can be computed. An example arises from a common pattern in the PowerPoint schema where the siblings of an element are grouped using a marker element. For example, all the text for a presentation is stored in a section of the document whose element is called \u201cslideListWithText\u201d. For each slide in the presentation, there is a sequence of elements in the children of slideListWithText such as\n\n","Streaming Access: Generally, there are two models for accessing documents, which we will call the DOM approach and the Streaming approach. In the DOM approach, the API provides a method (or small collection of methods) that effectively builds an entire tree structure for the document in internal memory. Once this call returns, the program need make no further access to an external memory device when accessing parts of the document. It is generally a property of this model that the time taken to access to any property of the document is only dependent on the properties height in the tree. (For example, it takes the same time to access the first and last child of the root of the tree.)","In the Streaming approach, the API provides methods for accessing the document one part at a time. In some instances, the order in which the parts are delivered corresponds to the order in which they appear in the documents external file. However, even if the order in which the parts are delivered is different from the file layout, a streaming interface can be prefereable to a DOM interface because it requires less memory than a DOM approach. This is especially important in processing large documents. Complex APIs may permit both streaming and DOM approaches, but overall design considerations might determine which approach is used. We will illustrate the generality of the query compiler with an another example from Microsoft's PowerPoint. Consider the XPATH expression\n\n",{"@attributes":{"id":"p-0076","num":"0130"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class text: public Iterator"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003private:"]},{"entry":[{},"\u2003\u2003\u2003\u2003PttTextObject* textObject;"]},{"entry":[{},"\u2003\u2003public:"]},{"entry":[{},"\u2003\u2003text::text( ):super(NULL,NULL,NULL)"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003textObject = PptFactory::factory(PPTTEXTATTOMID);"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003PptObject* nextObject( )"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003pptReader->read(&object);"]},{"entry":[{},"\u2003\u2003\u2003\u2003return *object;"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The iterator relies on a design pattern in the API: the so-called reader works by looking for the next object in the document (from its current location) that corresponds to the type of argument it is passed. The methods \u201cseek\u201d and \u201cread\u201d are similar\u2014the difference is that \u201cseek\u201d does not populate its argument, it simply positions the internal read position of the reader. (Node that the API uses polymorphism rather than introspection to implement the read methods. In other words, there is a family of read methods, one for every object type. This allows the API's implementation to optimize access on an element-by-element basis.)","In this example, because the factory method created a PptTextObject, each call to the reader's read method will return the next \u201ctext\u201d object. The compiler can make use of the knowledge that, although the \u201ctext\u201d elements are children of the second occurrence of slideListWithText, no descendants of the first instance have an element named text. In other words, the compiler methods can produce code that takes advantage of specific information that may not be part of the schema. Note further that the only use made of the Prefix in this case is to check that it is valid. No code is generated for the Prefix.","Aggregated Schemas: Many real-world document formats are an amalgamation of distinct schemas. Furthermore, it is even possible that the coding standards differ for distinct parts of the schema. The implication of this is that access to elements is not uniform, usually dealt with by developers using \u201cif\u201d tests in their code. However, our invention solves this problem by permitting the code of each iterator to overide the generic iterator code. For example, consider an XPath query like\n\n","As an example, consider \u201cEscher\u201d, a schema used for representing graphical objects that is used in the entire family of Microsoft Office products. The Schemas for the individual formats (Excel, Word, Powerpoint), differ substantially, but they all permit the embedding of Escher objects. The way that Escher is actually used differs in each case, so it is not possible to generate generic \u201cEscher\u201d code that works with all three formats. On the other hand, any library that provides a Microsoft Office API will provide a section that works with Escher that is likely to be common. The implication for developers is that access to children of an element in a document tree will differ for Escher elements and other elements. Our code generator accommodates these differences through the use of iterators as discussed above.","In some embodiments, XML can be used to describe various aspects of the methods described here. For example, schemas can be described using XML (XML-Schemas). Instances of documents can be expressed using XML. A document API can be used to create a tool that maps any document to its XML form, where the XML form is valid with respect to the schema. Developers can examine document structures as if they were XML documents, simplifying their task of deriving XPath expressions for query parameters. In some embodiments, one or more of the approaches described above offer at least two advantages. First, an approach described above is general, and can create target objects whose structure is significantly different than the source. Although this can be done with XSLT in some cases, the XSLT programs become very complex in these situations. Second, an approach described above is more efficient because translators are compiled rather than interpreted. The step of mapping to XML is not actually performed since the compiled queries use the API directly, and the code for extracting data from the source document is compiled. Since XSLT output is an XML file, there may be an additional step required to create a binary target file, whereas an approach described above permits such files to be created optimally.","Although the foregoing embodiments have been described in some detail for purposes of clarity of understanding, the invention is not limited to the details provided. There are many alternative ways of implementing the invention. The disclosed embodiments are illustrative and not restrictive."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Various embodiments of the invention are disclosed in the following detailed description and the accompanying drawings.",{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
