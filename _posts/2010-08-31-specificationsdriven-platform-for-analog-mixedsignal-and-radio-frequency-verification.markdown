---
title: Specifications-driven platform for analog, mixed-signal, and radio frequency verification
abstract: A design specifications-driven platform () for analog, mixed-signal and radio frequency verification with one embodiment comprising a client () and server () is presented. The server comprises an analog verification database (), a code and document generator (), a design to specifications consistency checker (), a symbol generator (), a coverage analyzer (), a server interface (), a web server (), and an analog verification server application (). The client comprises a web browser (), generated datasheets and reports (), generated models, regression tests, netlists, connect modules, and symbols (), generated simulation scripts (), a client interface (), design data (), simulators (), and a design data extractor ().
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08682631&OS=08682631&RS=08682631
owner: 
number: 08682631
owner_city: 
owner_country: 
publication_date: 20100831
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FEDERALLY SPONSORED RESEARCH","SEQUENCE LISTING OR PROGRAM","FIELD OF INVENTION","BACKGROUND","Advantages","SUMMARY","DRAWINGS\u2014REFERENCE NUMERALS","DETAILED DESCRIPTION","First Embodiment","Operation","Alternative Embodiments","Alternative Uses","Conclusion, Ramifications, and Scope"],"p":["This application claims the priority of U.S. Provisional Patent Application No. 61\/239,664 filed on Sep. 3, 2009 by the present inventors, which is incorporated by reference herein.","Not Applicable","Not Applicable","This invention relates to the creation of a design specifications-driven platform for analog, mixed-signal, and radio frequency verification in the field of analog, mixed-signal, and radio frequency (\u201cRF\u201d) integrated circuit (\u201cIC\u201d) and system design and verification. A mixed-signal design is a design that includes analog and digital design. The term analog includes purely analog, mixed-signal, radio frequency, and any combination of these types of designs. A design may be an entire IC, a subblock of an IC, or a component of an IC.","The design of a complex analog, mixed-signal, or RF IC is a large undertaking involving a design team which may include system designers, digital designers, analog designers, and a chip level implementation team. Distinct and separate from the design team may be a verification team, whose sole focus is to check the work of the design team. In general, when designing any large, complex system, a distinct and separate verification task may become necessary when the complexity of what is being designed increases to a point where the designer or designers may no longer be able to adequately check their own work. In digital IC design, this point occurred in the mid 1990's. The design of complex analog, mixed-signal, and RF ICs has now reached this point. Design bugs or errors now occur in the analog section, in the interface between the analog and digital section, and in the digital section that works closely with the analog. The root causes for these errors include miscommunication between the design teams, incorrect interpretation of the design specifications, incorrect or incomplete design specifications, and simple human error. It is these symptoms that suggest that a distinct and separate analog verification task may be necessary.","Analog, mixed-signal, and RF designs begin with the creation of at least one specification for the design. Typically, there is a plurality of specifications for a design. Depending on the design team, specifications may be formal and detailed, or these specifications may be as informal as a set of handwritten notes. Regardless, there are specifications that represent some level of understanding of what the analog design is to do as agreed to with the end user of the design. A typical flow is that from the specifications, the designers implement the design. When completed, the design is translated to layout. The layout is checked to match the design and to be design rule correct. If there is digital layout, the analog layout is then combined with the digital layout. Additional checks are conducted on the final layout. Once all of the checks pass, the design is released to manufacturing. After manufacturing, each chip is tested to validate that they are working.","Designs may be implemented hierarchically where there is a top or a chip level comprising blocks or components. The design may be implemented starting from the top, starting from the blocks, or both. The blocks, components, top-level, and chip-level have ports consisting of inputs, outputs, and bidirectional signals that facilitate communication from one part of the design to another.","The purpose of analog verification is to validate that the analog design meets its specifications, that the analog is properly connected to the rest of the design, and that in conjunction with the register transfer logic (\u201cRTL\u201d) that has been developed, that the IC behaves correctly. A key technology used when verifying designs is the use of computer simulators. Computer simulators allow the designer or verification engineer to predict what the design will do prior to manufacturing the design. A limitation of computer simulations is that simulations may be very time consuming. At present, simulating the analog section with all of the transistors with the rest of the IC is prohibitive, because the simulations times are too long. These simulation times may range from weeks to months. Even simulating the analog section alone may be prohibitive. To address this issue, analog verification relies on a model representation of the design and the design components. This is often referred to as a behavioral model. Behavioral models, when written properly, simulate much faster than the design. To use this model, however, it is critical that the model be proven to match the design implementation. If the model does not match the design, there is no certainty as to whether or not the design is truly being verified. To verify the consistency of the model and the design, a self checking regression test is applied independently to the model and the design. The regression tests apply stimulus to either the model or the design and checks the outputs of what is being tested. The expected outputs are determined by the specifications. If the actual outputs match the expected outputs, then to what the regression tests are applied and specifications are consistent. If both the model and design are consistent with the specifications, then the model and design are consistent, and therefore, the model, the design, and the specifications are consistent.","Analog verification is a new field in which there is little automation. Datasheets, reports, models, regression tests, netlists that combine blocks together, connect modules, symbols, and simulation scripts are usually written manually. Designers and verification engineers typically use templates or files written for a previous project as a starting point to gain efficiency. Of the automation that does exist in the field of analog verification, most fall under the categories of formal techniques, model generation, and testbench generation with most of the work in model generation.","In all fields of study, there is much literature on model generation, essentially the idea of building an abstract representation of something detailed. However, different techniques are required for different disciplines. For example, in the field of electronic design automation of which aiding in the design of analog, mixed-signal, and RF ICs is a part, there are techniques for the generation of digital models, digital system level models, and transistor device level models. U.S. Pat. No. 5,363,320 to Graeme Boyle, Susan Bergquist, Ernest McReynolds, and Matson Haug (1993) describes an approach to device or component level modeling. Devices include transistors, resistors, capacitors, and inductors. The creation of a behavioral model of an analog block which is a combination of devices requires different techniques in that abstraction or the removal of detailed behavior is required. One of the primary goals of having an analog model is that it simulate faster than a complete description of the design. The goal of device modeling is to have a very accurate representation of the devices where detailed behavior is included. U.S. Pat. No. 5,463,563 to Owen Bair, Patrick Yin, and Chih-Chung Chen (1995) describes an automatic modeling approach for logic, a subset of digital. The focus is on generating accurate timing information. Since analog signals fundamentally differ from digital signals, this work cannot be applied to creating analog behavioral models. Digital signals have a fixed number of values, usually two, on or off. Analog signals are continuous and may take on any value within a range. As a result, different modeling techniques are required. Also, simulating analog signals may require a different simulator, and therefore, different types of models. An event-driven simulator is typically used to simulate digital designs. Simulating analog signals often requires a simulator have an ordinary differential equation solver engine. This type of engine is known as a SPICE engine or an analog simulator. A SPICE engine requires solving a network of simultaneous equations. Simulators that have both an event-driven simulation engine and SPICE engine are generally known as AMS simulators or mixed-signal simulators. Modeling languages targeted for analog include Verilog-A, Verilog-AMS, and VHDL-AMS. Custom language extensions to Verilog and SystemVerilog have also been written to extend an event-driven engine to be able to accommodate some amount of analog modeling. Analog modeling may be accomplished using a digital language, but in many circumstances, an analog modeling language or a digital language with custom extensions is required. Model generation techniques in other fields, such as digital, do not use analog modeling languages nor do they use custom analog extensions to a digital language.","In the field of analog model generation, two basic approaches have been proposed. The first is based on an abstract description of the design such as a specification or equations representing the function that the design is to perform, and the second is based on the implementation of the design itself The latter requires that the design be completed before the model can be created. \u201cSimulation-based Automatic Generation of Signomial and Posynomial Performance Models for Analog Integrated Circuit Sizing\u201d by Walter Daems, Georges Gielen, and Willy Sansen presented at the IEEE\/ACM International Conference on Computer Aided Design in 2001 describes a technique to create signomial and posynomial performance models based on SPICE or circuit simulation of the implementation of the design to be modeled. \u201cFirst Steps Towards SAT-based Formal Analog Verification\u201d by Saurabh Tiwary, Anubhav Gupta, Joel Phillips, Claudio Pinello, Radu Zlatanovici presented at The IEEE\/ACM International Conference on Computer Aided Design in 2009 describes an alternative method for analog verification. In both cases the implementation of the design in the form of a netlist of all of the devices and how these devices interconnect is required.","For the model generation approaches that begin with an abstract description of the design, the prior art for this approach may be broken into two types of methods. The first is circuit type based, where specific knowledge of the type of analog, mixed-signal, or RF circuit being modeled needs to be pre-written into the tool generating the models. This knowledge may be in the form of equations or templates for the models where typically all that is required of the user is to enter parameters for the type of circuit. Often, model templates or equations specific to the circuit type are build into the tool. \u201cAutomatic Analog Model Generation for Behavioral Simulation\u201d by Brian Antao and Fatehy El-Turky presented at the IEEE Custom Integrated Circuits Conference in 1992 discusses the generation of behavioral models for s-domain and z-domain filters. The input to the model generator are the coefficients for the filters. In this case, specific domain knowledge about s-domain and z-domain filters, two types of circuits, are pre-programmed into the generator. \u201cA Formal Approach for Specification-Driven AMS Behavioral Model Generation\u201d by Subhankar Mukherjee, Antara Ain, S Panda, Rejdeep Mukhopadhyay, and Pallab Dasgupta presented at the Design, Automation, and Test in Europe Conference in April, 2009 describes a method in which the user enters specifications including the type of circuit being modeled to generate behavioral models. In this paper, the authors use as an example to describe their approach, a low drop out (LDO) regulator and explain how domain knowledge for LDOs is included in their tool. US Patent Application Publication 2008\/0048675 by Edouard Ngoya and Jean Rousset (published 2008) describes a method to accurately create a noise model in RF circuits. This is focused on analyzing a specific class of circuits, RF oscillators, RF mixers, and RF amplifiers, where built in knowledge of these types of circuits are required. This publication is also more of an analysis technique and not a method for generating a behavioral model of a design. The second type of the description based approaches to model generation is to enter a description of the design using a schematic capture tool or topology editor tool. U.S. Pat. No. 5,963,724 to H. Alan Mantooth, Christopher Wolff (1999) provides an example of this approach.","U.S. Pat. No. 5,369,604 to Naiknaware Ravindranath, G. N. Nandakumar, and Srinivasa Kasa (1994) describes an approach for automatic test plan generation. The invention described in U.S. Pat. No. 5,369,604 requires a circuit description, functional models, test models, and heuristic rules to generate the test plan.","The invention described in this patent application, part of which generates models and regression tests, uses the approach where one starts from an abstract description of the design in the form of specifications. This has the advantage that the implementation of the design does not have to exist before the model and regression test may be generated. There is also the advantage that the generation may be done in a significantly faster manner as circuit simulation is not involved. This invention also does not require circuit-type specific information. For example, common analog blocks include LDOs, analog-to-digital converters, digital-to-analog converters, amplifiers, mixers, oscillators, phased-locked loops. When using the method described in this invention to generate models and regression tests, the type of analog design being modeled does not have to be specified. The advantage is that a wider variety of analog blocks may be modeled. Often analog blocks comprise various types of analog blocks. It is infeasible for generators to anticipate all combinations. Since this invention does not require domain or circuit specific knowledge, analog blocks comprised of other analog blocks may be generated. This invention also does not require that the user enter a topology as a way of describing the design. The user need only enter the specifications for the design. The advantage is that the information entered may be more abstract and is closer to how the designer would naturally write specifications for their design. Finally, for the generation of models and regression tests, the invention described in this patent application requires only the specifications. Additional information is not required. This has the advantage over the prior art that requires more information, in that a reduced set of information is required, thus saving the user time when providing the input required for the generator.","In accordance with one embodiment, this invention is a design specifications-driven platform for analog, mixed-signal, and radio frequency verification for accelerating and improving the quality of the design and verification effort. This invention starts where the analog design starts, namely the design specifications. This invention provides a method for verifying an analog, mixed-signal, or radio frequency design where at least one specification is entered for the design, where the specification is stored, where a code and document generator is used to convert the specification to a behavioral model. The specification may contain a behavior of an analog port. Using the code and document generator and a model template, the behavior is converted into a portion of the behavioral model. Further, the code and document generator may convert the specification to a regression test, where simulations are then performed, where simulation results are stored, and where these results are used to generate a datasheet and report. Utilizing the regression test, an implementation of the design and the specification may be verified for consistency. The coverage including model coverage, regression test coverage, regression test run completeness, and assertion execution completeness may be measured. The code and document generator may also generate netlists, connect modules, simulation launch scripts, simulation launch script configuration files and schematic symbols. The quality of analog verification is improved as automated generation prevents manual errors from being introduced when a manual generation process is used. The quality of analog verification is also improved as the analysis capabilities ensure that the analog verification is more complete.",{"@attributes":{"id":"p-0034","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":[{"@attributes":{"id":"ul0001-0001","num":"0033"},"b":"100"},{"@attributes":{"id":"ul0001-0002","num":"0034"},"b":"101"},{"@attributes":{"id":"ul0001-0003","num":"0035"},"b":"102"},{"@attributes":{"id":"ul0001-0004","num":"0036"},"b":"103"},{"@attributes":{"id":"ul0001-0005","num":"0037"},"b":"104"},{"@attributes":{"id":"ul0001-0006","num":"0038"},"b":"105"},{"@attributes":{"id":"ul0001-0007","num":"0039"},"b":"106"},{"@attributes":{"id":"ul0001-0008","num":"0040"},"b":"110"},{"@attributes":{"id":"ul0001-0009","num":"0041"},"b":"111"},{"@attributes":{"id":"ul0001-0010","num":"0042"},"b":"120"},{"@attributes":{"id":"ul0001-0011","num":"0043"},"b":"121"},{"@attributes":{"id":"ul0001-0012","num":"0044"},"b":"122"},{"@attributes":{"id":"ul0001-0013","num":"0045"},"b":"123"},{"@attributes":{"id":"ul0001-0014","num":"0046"},"b":"124"},{"@attributes":{"id":"ul0001-0015","num":"0047"},"b":"130"},{"@attributes":{"id":"ul0001-0016","num":"0048"},"b":"131"},{"@attributes":{"id":"ul0001-0017","num":"0049"},"b":"132"},{"@attributes":{"id":"ul0001-0018","num":"0050"},"b":"150"},{"@attributes":{"id":"ul0001-0019","num":"0051"},"b":"160"},{"@attributes":{"id":"ul0001-0020","num":"0052"},"b":"210"},{"@attributes":{"id":"ul0001-0021","num":"0053"},"b":"211"},{"@attributes":{"id":"ul0001-0022","num":"0054"},"b":"212"},{"@attributes":{"id":"ul0001-0023","num":"0055"},"b":"213"},{"@attributes":{"id":"ul0001-0024","num":"0056"},"b":"214"},{"@attributes":{"id":"ul0001-0025","num":"0057"},"b":"215"},{"@attributes":{"id":"ul0001-0026","num":"0058"},"b":"216"},{"@attributes":{"id":"ul0001-0027","num":"0059"},"b":"217"},{"@attributes":{"id":"ul0001-0028","num":"0060"},"b":"218"},{"@attributes":{"id":"ul0001-0029","num":"0061"},"b":"310"},{"@attributes":{"id":"ul0001-0030","num":"0062"},"b":"311"},{"@attributes":{"id":"ul0001-0031","num":"0063"},"b":"312"},{"@attributes":{"id":"ul0001-0032","num":"0064"},"b":"313"},{"@attributes":{"id":"ul0001-0033","num":"0065"},"b":"314"},{"@attributes":{"id":"ul0001-0034","num":"0066"},"b":"315"},{"@attributes":{"id":"ul0001-0035","num":"0067"},"b":"316"},{"@attributes":{"id":"ul0001-0036","num":"0068"},"b":"320"},{"@attributes":{"id":"ul0001-0037","num":"0069"},"b":"321"},{"@attributes":{"id":"ul0001-0038","num":"0070"},"b":"322"},{"@attributes":{"id":"ul0001-0039","num":"0071"},"b":"323"},{"@attributes":{"id":"ul0001-0040","num":"0072"},"b":"410"},{"@attributes":{"id":"ul0001-0041","num":"0073"},"b":"411"},{"@attributes":{"id":"ul0001-0042","num":"0074"},"b":"412"},{"@attributes":{"id":"ul0001-0043","num":"0075"},"b":"413"},{"@attributes":{"id":"ul0001-0044","num":"0076"},"b":"414"},{"@attributes":{"id":"ul0001-0045","num":"0077"},"b":"415"},{"@attributes":{"id":"ul0001-0046","num":"0078"},"b":"416"},{"@attributes":{"id":"ul0001-0047","num":"0079"},"b":"510"},{"@attributes":{"id":"ul0001-0048","num":"0080"},"b":"511"},{"@attributes":{"id":"ul0001-0049","num":"0081"},"b":"512"},{"@attributes":{"id":"ul0001-0050","num":"0082"},"b":"513"},{"@attributes":{"id":"ul0001-0051","num":"0083"},"b":"520"},{"@attributes":{"id":"ul0001-0052","num":"0084"},"b":"521"},{"@attributes":{"id":"ul0001-0053","num":"0085"},"b":"522"},{"@attributes":{"id":"ul0001-0054","num":"0086"},"b":"523"},{"@attributes":{"id":"ul0001-0055","num":"0087"},"b":"530"},{"@attributes":{"id":"ul0001-0056","num":"0088"},"b":"531"},{"@attributes":{"id":"ul0001-0057","num":"0089"},"b":"540"},{"@attributes":{"id":"ul0001-0058","num":"0090"},"b":"541"},{"@attributes":{"id":"ul0001-0059","num":"0091"},"b":"542"},{"@attributes":{"id":"ul0001-0060","num":"0092"},"b":"543"},{"@attributes":{"id":"ul0001-0061","num":"0093"},"b":"544"},{"@attributes":{"id":"ul0001-0062","num":"0094"},"b":"545"},{"@attributes":{"id":"ul0001-0063","num":"0095"},"b":"546"},{"@attributes":{"id":"ul0001-0064","num":"0096"},"b":"547"},{"@attributes":{"id":"ul0001-0065","num":"0097"},"b":"548"},{"@attributes":{"id":"ul0001-0066","num":"0098"},"b":"610"},{"@attributes":{"id":"ul0001-0067","num":"0099"},"b":"611"},{"@attributes":{"id":"ul0001-0068","num":"0100"},"b":"612"},{"@attributes":{"id":"ul0001-0069","num":"0101"},"b":"613"},{"@attributes":{"id":"ul0001-0070","num":"0102"},"b":"710"},{"@attributes":{"id":"ul0001-0071","num":"0103"},"b":"711"},{"@attributes":{"id":"ul0001-0072","num":"0104"},"b":"712"},{"@attributes":{"id":"ul0001-0073","num":"0105"},"b":"713"},{"@attributes":{"id":"ul0001-0074","num":"0106"},"b":"714"},{"@attributes":{"id":"ul0001-0075","num":"0107"},"b":"715"},{"@attributes":{"id":"ul0001-0076","num":"0108"},"b":"716"},{"@attributes":{"id":"ul0001-0077","num":"0109"},"b":"717"},{"@attributes":{"id":"ul0001-0078","num":"0110"},"b":"718"},{"@attributes":{"id":"ul0001-0079","num":"0111"},"b":"719"},{"@attributes":{"id":"ul0001-0080","num":"0112"},"b":"720"},{"@attributes":{"id":"ul0001-0081","num":"0113"},"b":"1001"},{"@attributes":{"id":"ul0001-0082","num":"0114"},"b":"1002"},{"@attributes":{"id":"ul0001-0083","num":"0115"},"b":"1003"},{"@attributes":{"id":"ul0001-0084","num":"0116"},"b":"1004"},{"@attributes":{"id":"ul0001-0085","num":"0117"},"b":"1005"},{"@attributes":{"id":"ul0001-0086","num":"0118"},"b":"1006"},{"@attributes":{"id":"ul0001-0087","num":"0119"},"b":"1007"},{"@attributes":{"id":"ul0001-0088","num":"0120"},"b":"1008"},{"@attributes":{"id":"ul0001-0089","num":"0121"},"b":"1009"},{"@attributes":{"id":"ul0001-0090","num":"0122"},"b":"1011"},{"@attributes":{"id":"ul0001-0091","num":"0123"},"b":"1012"},{"@attributes":{"id":"ul0001-0092","num":"0124"},"b":"1013"},{"@attributes":{"id":"ul0001-0093","num":"0125"},"b":"1014"},{"@attributes":{"id":"ul0001-0094","num":"0126"},"b":"1015"},{"@attributes":{"id":"ul0001-0095","num":"0127"},"b":"1101"},{"@attributes":{"id":"ul0001-0096","num":"0128"},"b":"1102"},{"@attributes":{"id":"ul0001-0097","num":"0129"},"b":"1103"},{"@attributes":{"id":"ul0001-0098","num":"0130"},"b":"1104"},{"@attributes":{"id":"ul0001-0099","num":"0131"},"b":"1105"},{"@attributes":{"id":"ul0001-0100","num":"0132"},"b":"1106"},{"@attributes":{"id":"ul0001-0101","num":"0133"},"b":"1107"},{"@attributes":{"id":"ul0001-0102","num":"0134"},"b":"1108"},{"@attributes":{"id":"ul0001-0103","num":"0135"},"b":"1109"},{"@attributes":{"id":"ul0001-0104","num":"0136"},"b":"1110"},{"@attributes":{"id":"ul0001-0105","num":"0137"},"b":"1111"},{"@attributes":{"id":"ul0001-0106","num":"0138"},"b":"1112"},{"@attributes":{"id":"ul0001-0107","num":"0139"},"b":"1113"},{"@attributes":{"id":"ul0001-0108","num":"0140"},"b":"1114"},{"@attributes":{"id":"ul0001-0109","num":"0141"},"b":"1115"},{"@attributes":{"id":"ul0001-0110","num":"0142"},"b":"1116"},{"@attributes":{"id":"ul0001-0111","num":"0143"},"b":"1117"},{"@attributes":{"id":"ul0001-0112","num":"0144"},"b":"1118"},{"@attributes":{"id":"ul0001-0113","num":"0145"},"b":"1119"},{"@attributes":{"id":"ul0001-0114","num":"0146"},"b":"1120"},{"@attributes":{"id":"ul0001-0115","num":"0147"},"b":"1121"},{"@attributes":{"id":"ul0001-0116","num":"0148"},"b":"1122"},{"@attributes":{"id":"ul0001-0117","num":"0149"},"b":"1123"},{"@attributes":{"id":"ul0001-0118","num":"0150"},"b":"1124"},{"@attributes":{"id":"ul0001-0119","num":"0151"},"b":"1125"},{"@attributes":{"id":"ul0001-0120","num":"0152"},"b":"1126"},{"@attributes":{"id":"ul0001-0121","num":"0153"},"b":"1127"},{"@attributes":{"id":"ul0001-0122","num":"0154"},"b":"1128"},{"@attributes":{"id":"ul0001-0123","num":"0155"},"b":"1129"},{"@attributes":{"id":"ul0001-0124","num":"0156"},"b":"1130"},{"@attributes":{"id":"ul0001-0125","num":"0157"},"b":"1132"},{"@attributes":{"id":"ul0001-0126","num":"0158"},"b":"1133"},{"@attributes":{"id":"ul0001-0127","num":"0159"},"b":"1134"},{"@attributes":{"id":"ul0001-0128","num":"0160"},"b":"1135"},{"@attributes":{"id":"ul0001-0129","num":"0161"},"b":"1201"},{"@attributes":{"id":"ul0001-0130","num":"0162"},"b":"1202"},{"@attributes":{"id":"ul0001-0131","num":"0163"},"b":"1203"},{"@attributes":{"id":"ul0001-0132","num":"0164"},"b":"1204"},{"@attributes":{"id":"ul0001-0133","num":"0165"},"b":"1205"},{"@attributes":{"id":"ul0001-0134","num":"0166"},"b":"1206"},{"@attributes":{"id":"ul0001-0135","num":"0167"},"b":"1301"},{"@attributes":{"id":"ul0001-0136","num":"0168"},"b":"1302"},{"@attributes":{"id":"ul0001-0137","num":"0169"},"b":"1310"},{"@attributes":{"id":"ul0001-0138","num":"0170"},"b":"1311"},{"@attributes":{"id":"ul0001-0139","num":"0171"},"b":"1312"},{"@attributes":{"id":"ul0001-0140","num":"0172"},"b":"1313"},{"@attributes":{"id":"ul0001-0141","num":"0173"},"b":"1314"},{"@attributes":{"id":"ul0001-0142","num":"0174"},"b":"1315"},{"@attributes":{"id":"ul0001-0143","num":"0175"},"b":"1317"},{"@attributes":{"id":"ul0001-0144","num":"0176"},"b":"2000"},{"@attributes":{"id":"ul0001-0145","num":"0177"},"b":"2001"},{"@attributes":{"id":"ul0001-0146","num":"0178"},"b":"2002"},{"@attributes":{"id":"ul0001-0147","num":"0179"},"b":"2010"},{"@attributes":{"id":"ul0001-0148","num":"0180"},"b":"2011"},{"@attributes":{"id":"ul0001-0149","num":"0181"},"b":"2012"},{"@attributes":{"id":"ul0001-0150","num":"0182"},"b":"2013"},{"@attributes":{"id":"ul0001-0151","num":"0183"},"b":"2014"},{"@attributes":{"id":"ul0001-0152","num":"0184"},"b":"2015"},{"@attributes":{"id":"ul0001-0153","num":"0185"},"b":"2016"},{"@attributes":{"id":"ul0001-0154","num":"0186"},"b":"2017"},{"@attributes":{"id":"ul0001-0155","num":"0187"},"b":"2018"},{"@attributes":{"id":"ul0001-0156","num":"0188"},"b":"2019"},{"@attributes":{"id":"ul0001-0157","num":"0189"},"b":"2020"},{"@attributes":{"id":"ul0001-0158","num":"0190"},"b":"2021"},{"@attributes":{"id":"ul0001-0159","num":"0191"},"b":"2030"},{"@attributes":{"id":"ul0001-0160","num":"0192"},"b":"2031"},{"@attributes":{"id":"ul0001-0161","num":"0193"},"b":"2032"},{"@attributes":{"id":"ul0001-0162","num":"0194"},"b":"2033"},{"@attributes":{"id":"ul0001-0163","num":"0195"},"b":"2034"},{"@attributes":{"id":"ul0001-0164","num":"0196"},"b":"2035"},{"@attributes":{"id":"ul0001-0165","num":"0197"},"b":"2036"},{"@attributes":{"id":"ul0001-0166","num":"0198"},"b":"2037"},{"@attributes":{"id":"ul0001-0167","num":"0199"},"b":"2038"},{"@attributes":{"id":"ul0001-0168","num":"0200"},"b":"2039"},{"@attributes":{"id":"ul0001-0169","num":"0201"},"b":"2040"},{"@attributes":{"id":"ul0001-0170","num":"0202"},"b":"2041"},{"@attributes":{"id":"ul0001-0171","num":"0203"},"b":"2042"},{"@attributes":{"id":"ul0001-0172","num":"0204"},"b":"2043"},{"@attributes":{"id":"ul0001-0173","num":"0205"},"b":"2044"},{"@attributes":{"id":"ul0001-0174","num":"0206"},"b":"2045"},{"@attributes":{"id":"ul0001-0175","num":"0207"},"b":"2046"},{"@attributes":{"id":"ul0001-0176","num":"0208"},"b":"2047"},{"@attributes":{"id":"ul0001-0177","num":"0209"},"b":"2048"},{"@attributes":{"id":"ul0001-0178","num":"0210"},"b":"2049"},{"@attributes":{"id":"ul0001-0179","num":"0211"},"b":"2050"},{"@attributes":{"id":"ul0001-0180","num":"0212"},"b":"2051"},{"@attributes":{"id":"ul0001-0181","num":"0213"},"b":"2052"},{"@attributes":{"id":"ul0001-0182","num":"0214"},"b":"2053"},{"@attributes":{"id":"ul0001-0183","num":"0215"},"b":"2054"},{"@attributes":{"id":"ul0001-0184","num":"0216"},"b":"2055"},{"@attributes":{"id":"ul0001-0185","num":"0217"},"b":"2056"},{"@attributes":{"id":"ul0001-0186","num":"0218"},"b":"2057"},{"@attributes":{"id":"ul0001-0187","num":"0219"},"b":"2101"},{"@attributes":{"id":"ul0001-0188","num":"0220"},"b":"2102"},{"@attributes":{"id":"ul0001-0189","num":"0221"},"b":"2103"},{"@attributes":{"id":"ul0001-0190","num":"0222"},"b":"2104"},{"@attributes":{"id":"ul0001-0191","num":"0223"},"b":"2105"},{"@attributes":{"id":"ul0001-0192","num":"0224"},"b":"2106"},{"@attributes":{"id":"ul0001-0193","num":"0225"},"b":"2107"},{"@attributes":{"id":"ul0001-0194","num":"0226"},"b":"2108"},{"@attributes":{"id":"ul0001-0195","num":"0227"},"b":"2109"},{"@attributes":{"id":"ul0001-0196","num":"0228"},"b":"2110"},{"@attributes":{"id":"ul0001-0197","num":"0229"},"b":"2111"},{"@attributes":{"id":"ul0001-0198","num":"0230"},"b":"2201"},{"@attributes":{"id":"ul0001-0199","num":"0231"},"b":"2202"},{"@attributes":{"id":"ul0001-0200","num":"0232"},"b":"2203"},{"@attributes":{"id":"ul0001-0201","num":"0233"},"b":"2204"},{"@attributes":{"id":"ul0001-0202","num":"0234"},"b":"2205"},{"@attributes":{"id":"ul0001-0203","num":"0235"},"b":"2206"},{"@attributes":{"id":"ul0001-0204","num":"0236"},"b":"2207"},{"@attributes":{"id":"ul0001-0205","num":"0237"},"b":"2208"},{"@attributes":{"id":"ul0001-0206","num":"0238"},"b":"2209"},{"@attributes":{"id":"ul0001-0207","num":"0239"},"b":"2210"},{"@attributes":{"id":"ul0001-0208","num":"0240"},"b":"2301"},{"@attributes":{"id":"ul0001-0209","num":"0241"},"b":"2310"},{"@attributes":{"id":"ul0001-0210","num":"0242"},"b":"2301"},{"@attributes":{"id":"ul0001-0211","num":"0243"},"b":"2311"},{"@attributes":{"id":"ul0001-0212","num":"0244"},"b":"2312"}]}},"One embodiment of a design specifications-driven platform for analog, mixed-signal, and radio frequency verification  is shown in . The components for the platform  are divided into server side  components and client side  components. There is at least one server  and at least one client  in the preferred embodiment. If there is a plurality of users, there may be a plurality of clients. If the capabilities provided by a single server is insufficient, a plurality of servers may be used. The server  may be a computer such as a laptop, desktop, workstation, or computer server. The server  has at least one processor readable storage medium containing instructions that, upon execution, result in the implementation of operations. This processor readable storage medium may be random access memory, read-only memory, static memory, dynamic memory, non-volatile memory, floppy disk, or hard disk. For optimal performance, the server  has high compute power and high bandwidth to the internet, and is preferably a workstation or computer server. The client  may be a computer such as a netbook, mini notebook computer, sub notebook computer, notebook computer, laptop, desktop, workstation, server, tablet computer, or mobile phone. The client  also has at least one processor readable storage medium containing instructions that, upon execution, result in the implementation of operations. To access the web based functions that the platform  provides, it is sufficient that the client  be a device with web browsing capabilities such as a personal digital assistant, mobile phone, tablet computer, or electronic book reader. The server  runs an operating system such as Unix, Linux, Sun Solaris, Microsoft Windows, Apple MacOS, or Chrome. The client  runs an operation system such as Unix, Linux, Sun Solaris, Microsoft Windows, Apple MacOS, or Android. A user of this platform uses at least one of the client side computers . On the server side , our preferred embodiment is a Linux computer server. On the client side , our preferred embodiment is a Linux workstation.","On the server side  is a web server  which connects to the client side . An analog verification server application  connects to the web server , an analog verification database , and functional units including a code and document generator , a design to specifications consistency checker , a symbol generator , and a coverage analyzer . The generator , the consistency checker , the symbol generator , and the coverage analyzer  also connect to the database . The database  and the analog verification server application  connect to a server interface  which connects to at least one client . The web server  may be a commercial or an open source web server such as Apache. The database  may be an open source or a commercial structured query language (\u201cSQL\u201d) database such as MySQL. The analog verification server application  serves as a user interface capturing information from the user, storing data in the database , calling the functional units  to , and retuning that information to the user. The code and document generator  takes information from the database  and converts the information to at least one type of code or document. Code that is generated is meant to be interpreted by a simulator, by a computer operating system, a general purpose computer language interpreter, or an application. The application may be part of the platform  or may be another software application. A general purpose computer language interpreter includes scripting language interpreters. Scripting languages include bourne shell, bash shell, c-shell, python, ruby, tcl, and company proprietary extension languages such as Cadence's SKILL and Ocean. A document that is generated is meant to be interpreted by person. The design to specifications consistency checker  makes static checks between at least one design data repository  and what is in the analog verification database . Inconsistencies and warnings are provided to the analog verification server application  and returned to the user. The consistency checker  also checks for self consistency within the specifications. For example, information may be placed in the database  that specifies under what conditions certain design objects may be connected. If connections are made that violate these conditions, the consistency checker  issues an error and the user is notified. The symbol generator  takes information from the database  and produces at least one schematic symbol that the user may use in schematic drawings. The coverage analyzer  takes data from the database  and calculates at least one coverage metric. These metrics include the level to which the design has been verified. The server interface  provides an interface to the client  to allow data to be transferred to and from the database . The server interface  also provides an application programming interface (\u201cAPI\u201d) that allows a client to access functionality provided in the analog verification server application  and to access and change contents in the analog verification database  without going through the web server .","On the client side , a web browser  connects to the web server  on the server side , and to generated datasheets and reports , generated models, regression tests, netlists, connect modules, and symbols , and generated simulation scripts . The generated models, regression tests, netlists, connect modules, and symbols , simulation scripts , a design data extractor , and at least one simulator , are connected to the design data . The scripts , simulators , and extractor  connect to a client interface . The client interface  connects to the server interface  on the server side . The web browser  may be an open source or a commercial web browser such as Firefox or Microsoft's Internet Explorer. In the preferred embodiment, the client  uses Firefox as the web browser . The design data  may include at least one file stored on a computer or include at least one database for integrated circuit design. Common integrated circuit design databases are developed by companies in the field of electrical design automation (\u201cEDA\u201d). Examples of integrated circuit design databases include the Cadence Database (\u201cCDB\u201d) and OpenAccess. A combination of at least one file and at least one database may also be used. The design data  hold the design and implementation information for an integrated circuit or system being designed. The simulators  may be open source or commercial simulators developed by a company in the field of EDA. The simulators include circuit simulators, event-driven simulators, and mixed circuit and event-driven simulators. The simulators  may simulate at least one of many hardware description (\u201cHDL\u201d) languages. HDL languages include Verilog, Verilog-A, Verilog-AMS, SystemVerilog, VHDL, VHDL-AMS, SystemVerilog, and SystemC. In the preferred embodiment, the reports , models, regression tests, netlists, connect modules, and symbols , and simulation scripts  are outputs from the server . The design data extractor  converts the information from the design data  to enable the checker . The converted information is stored in the database . The client interface  communicates with the server interface  to enable the transfer of data to the server . The transfer of data includes storing and retrieving information from the database .","The client  and the server  communicate via the web server  and the database . The server application  provides the user interface to the user by receiving inputs and creating outputs in a language that the web browser  may interpret such as text, hypertext markup language (\u201cHTML\u201d), or Javascript.","The components of the code and document generator  are shown in . The code and document generator  includes a data management module , database input and output routines , access function parsers , user input parsers , code fragment generators , routines to run executable templates , executable templates , packaged code support , and a prepackaged library . The data management module  handles the internal data structures. The database input and output routines  serves as the interface to the analog verification database . The user input parsers  convert user input to data that the code and document generator  may interpret and provide feedback to the user in case there is an error in the input. The access function parsers  convert a special type of user input that gives the user the ability to access or set quantities such as voltage or current. Access functions also provide the ability to access or to set compound quantities such as the positive quantity of a differential signal, negative quantity of a differential signal, differential mode components of a differential signal, common mode quantity of a differential signal, and a single ended value of a differential signal. The user may also define the name of the access function. The code and document generator  may provide many types of outputs including models, regression tests, netlists, connect modules, simulation scripts, symbols, datasheets, and reports. These types are defined in the form of the executable templates . The routines to run executable templates  support the use of the templates . These routines  aid in the interpretation of data in the executable templates . Output from the code and document generator  include elements. The elements are defined in the prepackaged library . The prepackaged code support  is required to enable the use of the prepackaged library . In the preferred embodiment, the components in the executable templates  and in the prepackaged library  are described using an executable document description language. The routines to run executable templates  and prepackaged code support  assist in interpreting the executable document description language format.","The components of the prepackaged library  shown in  include prepackaged analog and RF assertions , prepackaged output drivers , prepackaged input receivers , prepackaged branches , prepackaged digital assertions , prepackaged transistor models , prepackaged passive component models , prepackaged assertion tests , prepackaged power tests , prepackaged common tests , and assertion coverage test code . The prepackaged analog and RF assertions  are typically put into models to check that analog and RF inputs meet a particular criteria such as being within a range of certain values. Analog and RF assertions may also be placed in regression tests and may also check outputs. The prepackaged digital assertions  are typically put into models to check that digital inputs meet a particular criteria such as being within a range of values. Digital assertions may also be placed in regression tests and may also check outputs. The prepackaged output drivers  are predefined behavior that describe an output port of a design block. Examples of output drivers include single ended outputs, differential outputs, class b outputs, outputs that may either source or sink current, and sine wave generators. The prepackaged input receivers  are predefined behavior that describe an input port on a design block. For example, an input receiver could be a current input with a value for its input impedance. Another example of an input receiver is one where the user may specify a pull up or pull down resistance value. The input receivers and output drivers contain information that allow for static checks. An example of a static check includes verifying that a particular input may be connected to a particular output. Another example of a static check is verifying that the limits on the number of connections between at least one output to at least one input is satisfied. The prepackaged branches  are predefined behavior that describe behavior between two terminals in the design that do not have to be ports. Examples branches are resistors, capacitors, inductors, switches, clamps, and diodes. The prepackaged transistor models  are predefined behavior that describe the behavior of a transistor. These models are not the foundry provided compact models for the transistors but simpler behavioral models that are more efficient but complex enough to still be sufficient for analog, mixed-signal, and RF verification. The prepackaged passive component models  are predefined behavior that describe passive components in a design. Example passive components are resistors, capacitors, and inductors. These models are not the foundry provided compact models for passive components but simpler behavioral models that are efficient but complex enough to still be sufficient for analog, mixed-signal, and RF verification. The prepackaged assertion tests  are predefined behavior that checks that the assertions are working properly. The prepackaged power tests  are predefined behavior that includes measuring current consumption of blocks. The prepackaged common tests  are predefined behavior for tests. Example common tests are tests for analog-to-digital converters, tests for serial-deserializer blocks, and phase-locked loops. The assertion coverage test code  measures the extent to which assertions have been placed in the generated models and regression tests and the extent to which they have been exercised. All of the behavior described in the prepackaged library  is parameterized and may be customized by the user. The user interface to using the prepackaged components  to  are designed to be as modeling language independent as possible so that the user may target multiple languages for models, regression tests, netlists, and connect modules.","The components in the executable templates  shown in  are model templates , regression test templates , netlist templates , connect module templates , simulation launch scripts , symbol templates , and datasheet and report templates . Model templates  are templates for the behavioral models that are created from user provided specifications . Behavioral models represent integrated circuits, systems, or components of integrated circuit or systems. Models may also be empty where a model only includes the port information. Regression test templates  are templates for the regression tests that are created from user provided specifications . Regression tests are connected to either behavioral models or the design implementation to verify that the user specifications  have been achieved. Regression tests are also used to verify that a behavioral model for a design block matches the implementation. Regression tests may either describe the behavior to be achieved using information from the specifications, by including the behavioral model to represent the desired behavior, or instantiating the behavioral model to represent the desired behavior. The regression tests may be used in design verification and post manufacturing test. The regression test templates  also include tests that run on the design to calibrate models. For example, tests may be added to measure the current consumption of the design. These results are stored in the database . Then the models may be generated or regenerated from the model templates  to include these results. Netlist templates  are templates for netlists that indicate how design blocks are interconnected. An example netlist is a chip top-level netlist. The chip top-level netlist describes how a plurality of blocks at the chip level are connected. The blocks at the chip level may comprise pads, the digital subsystem, the analog subsystem, and the RF subsystem. Another example of a netlist is one that connects the regression tests to the behavior model or design to be simulated. The connect module templates  are templates for connect modules. Connect modules are found in some behavioral modeling languages such as Verilog-AMS. Connect modules convert signals from one domain to another. Domains include discrete or logic, electrical, mechanical, discrete analog, and baseband equivalent analog and RF. An example of a connect module is one that converts from the digital domain to the analog electrical signal domain. Manually written connect modules exist to convert from some domains to others. The preferred embodiment adds the ability to automatically generate connect modules from one domain to another as needed. The preferred embodiment also gives capability to the user to customize connect modules. Less common connect modules which the code and document generator  may generate include converting between the discrete analog domain to and from the electrical domain, and the baseband equivalent signal domain to and from the electrical domain. There is at least one template in the templates  to . At least one behavioral language is targeted in each of the templates  to . These languages include Verilog, Verilog-A, Verilog-AMS, Verilog with extensions for passing analog information, VHDL, VHDL-AMS, and SystemVerilog. Also included are variations on these languages as a result of simulator dependent implementations. The templates  to  are designed in such a way to make them extensible to future languages. The simulation launch script templates  are used to create user specific simulation launch scripts to start regression tests , to configure what design data  or model data  is to be used, and which simulator  is to be used. The simulation launch scripts that are generated are in a computer language that may run on the client  or on another computer of the user's choosing. The scripts are written in a scripting language. The scripts may be in a compiled form, may call routines that are written in a compiled language, and may be written in a compiled language. The simulation launch script templates  include simulation specifics and may be customized to a particular simulator. The symbol templates  are used to create the schematic symbol or used to create the code that generates the schematic symbol based on user specifications . The schematic symbol may be in a proprietary database format such as Cadence's CDB or in an open format such as OpenAccess. In addition to templates including the code or symbol data, the templates include common shapes for schematic symbols for common analog, mixed-signal, digital, and RF blocks. The datasheet and report templates  generate documents readable by users. The contents of these documents are derived from the analog verification database . Reports may contain all or some of the data in the database . For example, a datasheet may contain the user specifications . Reports may include register lists found in the users specifications , global digital control signal tables found in the user specifications , coverage analysis results , simulation completion analysis found in the simulation data , and user specifications with simulation results  indicating whether or not the specifications  were met. The format of the datasheets and reports include document, spreadsheet, presentation, document interchange format, and standard formats. Example document programs are Microsoft's Word, Adobe's Framemaker, and OpenOffice Writer. Example spreadsheet programs are Microsoft's Excel and OpenOffice Calc. Example presentation format are Microsoft's PowerPoint and OpenOffice Draw. Example document interchange formats are rich text format (\u201cRTF\u201d), maker interchange format (\u201cMIF\u201d), extensible markup language (\u201cXML\u201d), and comma-separated values (\u201cCSV\u201d). Standard formats include the hypertext markup language (\u201cHTML\u201d). The datasheet and reports may be in electronic format or printed. The executable templates  are applicable to all design types and do not require that specific design type information or circuit type information be incorporated in the templates.","The components of the analog verification server application  are shown in . The components, web interface routines , user payment account management routines , user\/system administration routines, and a license manager  provide general web server functionality. More specific to the analog verification application are wiki components , general system utilities , database input and output routines , a portable document format (\u201cPDF\u201d) generator for printable output , download routines , and output results display support . Specific to the analog verification application are a specifications organizer , specifications editor module , import routines , a regression test run progress analyzer , a revision control system , a simple and advanced mode controller , a verification plan editor , a regression test run controller , and simulation results to specifications back annotation routines . The components  to  provide capabilities to the user. The web interface routines  provide the input and output capabilities from and to the web server . These include generating HTML and Javascript and include handling input from the user through the HTML forms using the post mechanism. The user payment account management routines  handle the accounting and payment from users for the use of the capabilities provided by the platform . The data for these routines  are stored in the database . The user and system administration routines  include handling the user accounts and maintaining personal user data , such as names, addresses, and phone numbers. The license manager  handles authentication of the use of the server  code. The wiki components  give extended editing capabilities to the user when editing user specifications . These extended editing capabilities include adding text extensions, tables, and graphics. The graphics include schematics, waveforms, and timing diagrams. The general system utilities  provide basic functionality to support the server application . An example of a general system utility is data formatting. The database input and output routines  provide the capability to access the data in the analog verification database . The PDF generator for printable output  formats data from the analog verification database  into PDF that may be viewed by a PDF viewer such as Adobe's Acrobat Reader. The output results display support  provides the routines to format the data from the analog verification database  into a format that may be viewed by a web browser. These formats include HTML and Javascript. The output results display support  also provides support to adequately display results from design to specifications consistency checker data , and coverage analysis results . The download routines  enable the user to download generated documents and code  and generated symbols . Utilizing the download routines , the user may initiate a download of at least one output. The specifications organizer  provides the capabilities that allows the user to organize user specifications . Example organizational capabilities include sorting, linking, copying, deleting organizing hierarchically, and utilizing example specifications . The specifications editor module  allows the user to modify the contents in the user specifications . Modifying includes creating, displaying, updating, deleting contents in the specifications, and including example specification fragments . Updating includes copy, paste, and undo operations. The specifications editor  is suitable for editing component or top-level specifications. The import routines  allow the user to import information into specifications. Import formats include models manually written and models generated from the platform . For example, a Verilog model may be imported and the specifications may be pre-populated with port information. Other formats include formats developed for the platform , comma separated valued text files, an open source or commercial word processing format, and an open source or commercial spreadsheet format. The imported data may be incomplete or complete specifications. Imported data may include text, equations, and figures which may be placed in the generated datasheets and reports . The regression test run progress analyzer  reads simulation data and results  and returns progress information on simulations to the user. This information may include the number of simulations that have been run, the number that remain, and an estimate of the time required for the remaining simulations. The revision control system  allows the user to manage different versions of the specifications. The simple and advanced mode controller  gives the user the ability to switch between a mode with a simple user interface to one that is more complicated but which contains more advanced features. The verification plan editor  allows the user to modify verification plans . Modifying includes creating, displaying, updating, and deleting contents in verification plans. The regression test run controller  uses the data from the verification plans  to provide capabilities to manage the running of regression tests. The simulation results to specifications back annotation routines  provide the capability to take results from the simulation data and results  and merge them with the user specifications  to show which specifications have been met and which have not.","The coverage analyzer  is shown in . The components of the coverage analyzer  include a model coverage analyzer , a regression test coverage analyzer , a regression test run completeness analyzer , and an assertion execution completeness analyzer . The model coverage analyzer  checks to see how complete the generated model is from user specifications . For example, if the user does not specify sufficient information in the user specifications , the model coverage analyzer  will warn the user. The regression test coverage analyzer  measures how complete the regression tests are. The regression test run completeness analyzer  measures to what extent the regression tests were run. This includes checking to see if the regression tests previously run are still valid. For example, if the design data  or the user specifications  change after a regression test affected by those changes have been run, previous runs of the regression test run are considered invalid and not counted as part of the completeness metric. The assertion execution completeness analyzer  is used to verify that all of the assertions were executed and that the signals they are supposed to check were checked.","The database contents  are shown in . The contents  include example specifications , example specification fragments , user specifications , generated documents and code , results from the design to specifications consistency checker , generated symbols , coverage analysis results , user account information , simulation data and results , verification plans , and other housekeeping information . The other housekeeping information  are data required by any of the components in the server  in additional to the other contents  to  mentioned in the database . An example piece of housekeeping information are web session data to manage active users. In this case the component utilizing the other housekeeping information  is the web interface routines .","In this invention, design specifications  serve as the starting point that drives the platform . The design specifications  may be the specifications for an entire design or a component in the design. The design may be the design of an integrated circuit or a system. The specifications  include the behavior of the design. The specifications  may also include the behavior of the tests to be performed on the design. It is intended that for a design that there is a top-level specifications along with many specifications making up the components, blocks, and subsystems for that design. The design specifications  shown in FIG.  includes many sections  to  which are intended to capture the specifications of an analog, mixed-signal, or RF integrated circuit or system design.","In the preferred embodiment, the specifications  include parameters for the specifications , port types used in the specifications , a list of ports of the design being specified , discrete variables used to describe the behavior , continuous variables used to described the behavior , user defined behavioral code , user comments , branches used to describe the behavior , instances in the design , register and global control signal maps of the design , states in the design , test sequences to be used on the design , and look-up tables to aid in describing the behavior of the design . Not all designs or design blocks need to include all of the sections listed in the specifications . Each section of the specifications  to  and  to  may have zero or more items. The section of the specifications  is required where at least one port needs to be described. This is because the specifications  are based on a description of the ports. The behavior of the overall block or design being described may be captured with only a description of the ports and how the ports interrelate to each other. The other sections  to  and  to  add to section  providing additional descriptions which ultimately connect to the ports in section . The sections  to  of the specifications  do not ask for information on the circuit type of the design. Information on the circuit type of the design is not required. Both analog ports and digital ports may be in the list of ports . An analog port is a port that connects to an analog signal. A digital port is a port that connects to a digital signal.","These items are described by attributes  to  which may or may not be applicable in each of the sections  to . A table  indicating which sections  to  include which attributes  to  is shown in . The specification sections  to  are shown in the top row of the table . Attributes for each of these sections are shown in the first column  to . A check mark at the intersection of a row and a column indicates that the particular attribute  to  may be specified in a particular section  to  of the specifications. An item is described by the attributes listed.","An example is shown in . This example shows the list of ports section . The attributes ,  to  associated with the list of ports section  are listed in the top row of the table. Each item of this section of the specifications is a row in the table. In this example, there are six items  to . The list of ports  section is specified in second to final row of the table. In this example, the user provides the contents in rows  to . Each box in each of the rows is a field in which the user may enter data.","Attributes  to  of each item are provided by the user. Examples to assist the user are provided in examples specifications  and example specification fragments . Name  is a name given to an item. It has a specific meaning depending on what the specifications section  to  is. Description  is given by the user and is not meant to be interpreted by the computer. Value  is the value associated with an item. Aliases  is an equivalent for the name  and is considered the same when used in the specifications . Differential  indicates whether or not an item is differential in nature. Access methods  define the methods by which the quantities in an item may be accessed. Pin types  refer to types defined in modeling languages. The supply domain  indicates to which supply domain an item belongs. This information facilitates static checks to validate that connections between input and outputs are in the same supply domain. Direction  indicates a direction for an item. A port types attribute  may take on a value of one of the port type contents . A range  indicates a valid range for the port . A behavior  describes the behavior of an item using an expression. A protected variable  may be used to filter the input port. The filtered result is what is given in the protected variable  entry. Affects analog  indicates whether or not an item affects the analog section of a model or regression test. A reference port  is used to indicate whether or not there is a reference port where rather than using ground as the default reference another port is used. For example, a signal may want to refer to a port which has a common mode voltage instead of ground. In this case, the port with the common mode voltage would be indicated in this field. Gmin  refers to the minimum conductance to ground or a reference on that node. Pin number  allows a user to enter a value associated with a port. An order  field allows a user to order a list of items. Attributes  allows the user to specify additional information about a port that may be used in both static and dynamic verification. For example, a bias current could have an attribute which indicates its tolerance. Another example would be a supply port could have an attribute indicating that it is regulated or unregulated. Symbol information  contains specific information to aid in the generation of the symbol. Included in the symbol information is the location of the pin on the symbol. Test metrics  provide information to assist in the automatic generation of the regression tests. A test metric could indicate that pin has to be tested exhaustively for all combinations or that only certain values need to be tested. For analog inputs, example test metrics  include defining an input such as a sine wave, an input ramp, and an input test range. A variable type  refers to the model variable type to be used. A trigger  refers to what ports or variables cause the behavior of an item to change. Wait  allows the user to specify a condition for a signal that must be met before behavior is to be executed. Initial  specifies the initial condition for the item. A measurement unit  specifies the measurement unit for an item. Example measurement units include ampere, volt, coulomb, joule, weber, meter, second, Ohm, and henry. Smooth  specifies a variable that contains a smoothed version of the item. Branch type  specifies the type of branch to be used. Connects  specifies the connections for the branch, units, instances, or register map. Item parameters  are additional information to be provided for an item. Instance reference  provides a link to a specifications that is to become an instance of the specifications in which the instance reference is found. The location  gives information as to where an item is to go. The default and state columns  may add one or more columns to a table where the user may specify values for items when in the default state or specific states. For example, for an item in the ports section  that is a digital port type  with a direction  of input, the default state could indicate that its value is to be zero. Another example is for a supply port type , the default state could indicate its current consumption when in the default state. The behavior for the particular state could also be entered in the field. A behavioral condition may also be placed in the field to verify that when in a particular state, that the condition placed in the field has been met. During verification, when in default mode, an assertion could be added to verify that condition.","Some of the input fields for the attributes and specifications sections have a preselected set of values. Example options  for input fields  are shown in . Example names  for items of the parameters section  are listed in table entry . Example values for pin types  are listed in table entry . Example port directions  are listed in table entry . Example port types  are listed in table entry . Example discrete variable types  are listed in table entry . Example branch types  are listed in table entry . The instance reference  refers to other spec sheets and masters in the design data  as listed in table entry .","This invention creates a design specifications-driven platform for accelerating and improving the quality of analog, mixed-signal, and RF verification. Starting from design specifications; models, regression tests, netlists, datasheets, symbols, connect modules, and simulation scripts may be automatically generated. In addition, reports may be generated that include coverage analysis, results from static checks of the design implementation to the specifications, and simulation results.","There are many flows that analog, mixed-signal, and RF designers use when designing and verifying an analog, mixed-signal, or RF integrated circuit or system. This invention fits into many design flows. These include top-down, bottom-up, and middle-out flows. An example flow  in which this invention may be used is shown in . A design flow  is on the left and a verification flow  is on the right. A user of the design flow  is likely a designer and is likely part of a design team all of whom may be using the design flow  for a particular integrated circuit or system design. Designers may include analog, mixed-signal, RF, system, digital engineers, and a combination. A user of the verification flow  is likely a verification engineer and is likely part of a verification team all of whom may be using the verification flow . Verification engineers may include analog, mixed-signal, RF, system, digital verification engineers, and a combination. The user of the verification flow  may also be a designer in the case where the design and verification effort is combined. Users of the platform  include analog verification engineers, analog designers, analog design leads, digital verification engineers, CAD engineers, and system engineers.","The flow  begins at the start of a design . The first step is the creation of the top-level datasheet . The user may accomplish this using the datasheet generator . Working on a client computer , the user uses a web browser , connects to the web server , and accesses the analog verification server application . The top-level design specifications may be entered using the specifications editor . In this way, this embodiment of the platform  accepts the input of the specifications  from the user. The designer utilizes the prepackaged library  to be more efficient when entering the specifications. A rich set of information may be entered using the wiki components . Examples  and  are also available to accelerate the effort. The specifications are stored in the database  in the user specifications  section. Once entered, the code and document generator  may be used to generate the data sheet utilizing the datasheet and report templates . The output of the code and document generator  is stored in the database  specifically in the generated documents and code  section. Then using the download routines , the data sheet goes through the web server  to the web browser  and finally stored  on the client . Once a version of the top-level datasheet has been agreed to by all of the interested parties to the design, the designers define an architecture for the integrated circuit or system and create the component datasheets . The interested parties may include the team developing the integrated circuit or system and the team who will ultimately use the manufactured integrated circuit or system. The component datasheets  may be generated in the same manner as the top-level datasheet described previously. At this point, an assessment is conducted to see if the design is feasible . Step  may include performing hand calculations, using a spreadsheet to predict performance, writing models, even implementing critical components, and running simulations. The datasheets  that were generated in steps  and  facilitate step  by providing documentation that the engineers may study. This platform  may be used to generate models for this feasibility study. From the specifications entered, the code and document generator  is once again used, this time utilizing the model templates . If the design is determined to be not feasible, the top-level datasheet, architecture, and component datasheets are adjusted until feasibility is reached.","At this point, analog verification begins  with the design flow  and the analog verification flow  running in parallel. Different engineers may be assigned to the different flows. The engineers on the design flow  begin to implement the components . For analog, mixed-signal, and RF circuits, implementing includes drawing schematics and performing at least one simulation to validate that the implementation meets the specifications.","For digital circuits, implementing includes writing RTL and drawing schematics to validate that the implementation meets specifications. The implementation results are stored in the design database . The first step in the analog verification flow  is to create datasheets for the components  if they were not previously created in step . Once again, this may be done using the code and document generator  using the datasheet and report templates . If models exist that define the components or if the specifications are written in one of the formats that may be imported, the models or the specifications may be imported using the import routines  and serve as the starting point for the specifications. To manage all of the specifications for the components being entered, the specification organizer  and the revision control system  may be utilized.","Models are then created for the components . Models are generated from the specifications  using the code and document generator  utilizing the model templates . A portion of the generated model would include converting the behavior  of analog ports described in the list of ports . The next step is to develop regression tests for the components . The specifications  utilizing the code and document generator  and the regression test templates  are converted to at least one regression test. To efficiently run the regression tests on the models and implementation, simulation scripts are developed . These simulation scripts are created using the code and document generator  utilizing the simulation launch script templates . The regression tests are then run on the models . The simulation scripts  along with the models and regression tests  that were generated run on the simulators  producing results that are stored in the analog verification database  specifically in the simulated data and results section . Next, connect modules are developed  to enable running the regression tests on the implementation . The connect modules are generated using the code and document generator  utilizing the connect module templates . The simulation scripts  launch the regression tests on the implementation  utilizing the regression test  on the implementation that is in the design database  using one of the simulators  verifying whether or not the implementation of the design is consistent with the specifications. The regression tests results are again stored in the analog verification database . To configure how the regression tests are launched, the regression test run controller  may be used. Configurations include scheduling and whether or not simulations are to run in parallel. Progress of the simulations may be monitored utilizing the regression test run progress analyzer . To configure the overall goals for the verification effort, the verification plan editor  may be used. Once entered, the verification plan is stored in the database  in the verification plans  section. Depending on how much the user wants to customize the details of the verification effort, the simple\/advanced mode controller  may be utilized. Finally, to view the regression test results in the context of the specifications, the simulation results to specifications back annotation routines  are utilized, and the code and document generator  utilizing the datasheet and report templates  are used this time generating a report  which details how the desired specifications compare to simulated results. A datasheet  may also be generated which includes the specifications and a summary of the simulated results. The results may be viewed by the user using the output results display support  or on paper using the PDF generator for printable output . Steps  to  are repeated until all of the components that require models have been generated.","A set of static checks is then performed on the components. To accomplish this, design data  is extracted  and stored on the server . The design data is then checked for consistency to the specifications  stored in the analog verification database . This is accomplished using the design to specifications consistency checker . The results are stored in the database  specifically in the results from design to specifications consistency checker section . Component level coverage is then analyzed . This is accomplished using the coverage analyzer . All aspects of coverage are measured including model coverage , regression test coverage , regression test run completeness , and assertion execution completeness . The coverage analysis results are stored in the database  specifically in the coverage analysis results section . After this, a user produces reports to document the component level work . These reports may be generated using the code and document generator  utilizing the datasheet and report templates . The user may produce the reports in multiple formats to be more suitable for the audience or post processing. For example, a report in document form is more suitable for reading by another user while a report in a spreadsheet format is more suitable for post processing. All reports are generated as part of step .","When the implement components step  in the design flow  completes, layout of the components  begins. At the same time, as long as some of the components are complete, the design may be assembled and chip-level simulations begun .","Developing schematic symbols for the components  is required for the top-level work  to  and  to . The symbols are generated using the symbol generator  utilizing the symbol templates . The results are stored in the database  specifically in the generated symbols section . The generated symbols  may be used in the design flow  by placing them in the design data  where they are instantiated as part of the assemble design and chip-level simulations step . As the design is begin assembled, top-level verification may begin. The top-level netlist if it is not available from the assemble design step  is created . The top-level netlist is generated by the code and document generator  specifically using the netlist template . The next step is to produce register maps and top-level connectivity descriptions . This may be done using the code and document generator  utilizing the datasheet and report templates .","The next set of steps  to  follow the same procedure as steps  to  at the component level. The platform  is used to generate the reports , code , and scripts  required to execute steps  to . These steps are: develop top-level regression tests , develop simulation scripts , run top-level regression tests on models , develop connect modules , run top-level regression tests on implementation , extract the design data , check design consistency , analyze top-level coverage , and produce reports for the top-level work . The code and document generator  utilizing the templates , the consistency checker , symbol generator , and coverage analyzer  are used to accelerate steps  to .","In the design flow , after the design has been assembled , the top-level layout is then completed  followed by final simulations . Physical verification  including layout versus schematics, and design rule checking procedures follow.","Either after or during steps  to , all of the regression tests are re-run  on the final version of the design. All coverage is re-analyzed  to confirm that verification is complete on the final version of the design. If there is no cause for concern from the analog verification team, the team signs off on the design . The analog verification flow is complete .","When the design team is satisfied that it has completed and implemented the design and the verification team has signed off on the design, the design team completes the final design steps . This includes creating the data required for manufacturing. At this point, the design flow ends .","A detailed flow for specifications entry and output generation is shown in . The start  denotes the starting point of the flow which is at the point when the user is prepared to enter the specifications for a design or a component. The user enters the specifications  using a web browser  that connects to a web server  that connects to an analog verification server application . The specifications  are accepted and stored in the analog verification database . Entry of specifications is accelerated by the prepackaged library  and the examples  and . The specifications are saved  to the database . The input is parsed  by the code and document generator  that utilizes the user input parsers  and the access function parsers  routines. If there is an error  or if at least one message needs to be communicated to the user, the errors or messages are stored in the database , and the errors or messages are presented to the user utilizing the specifications editor module . If there is no error, then at least one output is generated . This is accomplished using the code and document generator  and the symbol generator . These utilize the executable templates . By doing so, the outputs may be models, regression tests, netlists, connect modules, symbols, , simulation scripts , and datasheets and reports . Messages are then displayed to the user . These messages may include warnings or suggestions to the user on how to improve the output. The generated outputs are displayed to the user . If the generated outputs are satisfactory , the user is then given the option to download one or more of the outputs . This ends  the flow for generating outputs.","The flow for the preferred embodiment of the code and document generator  is shown in . After the start , the first step is to retrieve the specifications  from the database . Following retrieving the specifications using the database input\/output routines , the specifications are stored locally using the data management module . Based on the desired output, the corresponding template is loaded  from the executable templates . The template is then executed . Executing the template requires the user input parsers , the access function parsers , routines to run executable templates , code fragment generators , the prepackaged library , and prepackaged library support routines . The template is then checked to see if there are fields requiring expansion . Fields requiring expansion are either filled by the specifications input data or data derived from the input  or filled by another template . If the check  determines that another template is required, the load executable template step  is performed again. The loop continues until the template no longer has any fields to complete. Messages including errors and warnings are saved  to the database . The generated output is saved  to the database . This completes  the flow for the preferred embodiment of the code and document generator.","An example Verilog-AMS model A and B for a gain stage that has been generated is shown in . The list of ports section  of the specifications for this example is shown in . The module and input declarations  are based on the list of ports section  for ports  to . Analog assertions  that are generated are also based on the list of ports section  for ports  and . Finally, the analog behavior  is also specified in the list of ports section . The analog behavior is specified on ports  and  in this example.","There are alternative embodiments of this invention. A platform  need not contain all of the components shown in . A subset is sufficient to provide efficiency gains in analog verification. For example, generating only models does accelerate analog verification. In this case, the components required are a web browser , a web server , an analog verification server application , a code and document generator , an analog verification database , a client interface , and a server interface . For a subset of functionality, the components which are in a code and document generator , prepackaged library , executable templates , analog verification server application , coverage analyzer , and database contents  may also be a subset of the components described in the preferred embodiment. A platform  may also include additional components to provide more functionality. Further, the code and document generator  need not be one entity. The code and document generator  may be separated into a code generator and a separate and distinct document generator, and if only code is required, only the code generator need to be in the platform . If only documents are required, only the document generator need to be in the platform .","A platform  may also have at least one component implemented in a different manner. These different manners include at least one component being implemented differently, a plurality of components being combined, or at least one component being split into a plurality of components. Examples of how components may differ follows. Prepackaged library components  to  need not be described in an executable document description language. Alternative description approaches include using other formats and languages, a template where a search and replace mechanism is used, and a template which contains embedded code to generate the result. Instead of using an SQL database , the data may be stored in a set of files. Another example of a component being implemented in a different manner is to replace a symbol generator  with a symbol and schematic generator. In this way, netlists that are generated from a code and document generator  may also be represented by a schematic. Generated models, regression tests, netlists, connect modules, and symbols  would now also include schematics which would be stored as part of design data . An example schematic is a top-level schematic. Also, the code and document generator  may also generate a simulation launch script configuration file to be used by a simulation launch script itself as a way of separating the simulation launch script and configuration information specific to design.","Another embodiment of a platform  is that rather than be structured as a web based application, the platform  is structured as a stand alone application. Specifications would be edited in various means including using a custom editor, an open source or commercial word processor, and an open source or commercial spreadsheet program. An analog verification server application  would be part of the stand alone application providing a user interface directly on an operating system such as Microsoft Windows, MacOS, Solaris, Unix, or Linux. A client interface  and a server interface  may not be necessary.","Another embodiment of a platform  is where specifications are edited using various means including a custom editor, an open source or commercial word processor, and an open source or commercial spreadsheet program. An analog verification server application  would reside on a server  wherein the specifications editor would be enhanced to communicate with the server . An analog verification server application  and a server interface  would have an interface to the specifications editor.","The sections of the specifications  do not have to be separated in the same way as shown in . A least one of the sections  to  may be split up into multiple sections, or a plurality of sections  to  may be combined into an individual section. An example is that the register section  and states section  may be combined. Also, all of the sections need not be present. For example if a platform  is only to generate models, then the test sequences section  is not required. If only component models are to be generated, then the register and global control signals map , instances  are not necessary. Also, simple models may be generated from a small set of sections. For example, a simple model may be generated with only the sections\u2014parameters , port types  and list of ports . Finally, at least one additional section may be provided in the specifications  to add additional functionality.","To simplify the description of port  relationships, prepackaged units may be included in the prepackaged library . Prepackaged units offer a simplified way of describing analog basic building block functionality. For example, the prepackaged units may comprise drivers, receivers, branches, transistor models, and passive component models. These prepackaged units serve as a simplified method or short hand for describing the common analog behaviors at the port level within the design. A units section would be added to the specifications . Units may include one or more of the predefined behaviors. As with all of the other sections in the specifications , except for list of ports , the units section may have zero or more entries.","In the table shown in  that shows which attributes  to  are associated with which specifications section  to , different embodiments may have different attributes for the different specifications sections. Attributes may be removed. New attributes may also be added.","The table shown in  lists example options  for particular input fields . The listed options  to  may be different in different embodiments. Options may be removed and new options may be added.","The first embodiment described in this patent application uses the term datasheet  to describe a human readable output document. The term specifications  is used to describe an input to the code and document generator. In the field of analog, mixed-signal, and RF design, the term datasheet is often used synonymously with the term specifications. An alternative embodiment of the invention described in this patent application would be to use the term datasheet in addition to the term specifications to describe the specifications . The term specification, the singular form of specifications, is also often used to mean specifications. An alternative embodiment of the invention described in this patent would also be to use the term specification in addition to the term specifications to describe the specifications .","In the field of analog, mixed-signal, and RF design, the term testbench is used to refer to at least one test run on a model or a design implementation. The term testbench may be used in place of regression tests. Also, the testbench need not be self checking. The regression test templates  may contain a template for a testbench that is not self checking, where the comparison between the outputs of the model and the design implementation is done visually by the designer or the verification engineer.","An alternative to the server  containing at least one processor readable storage mechanism is that the server  is network connected to at least one processor readable storage mechanism. An alternative to the client  containing at least one processor readable storage mechanism is that the client  is network connected to at least one processor readable storage mechanism.",{"@attributes":{"id":"p-0078","num":"0288"},"figref":"FIG. 12","b":["1004","1102","1117","1004","1102","1117"]},"Many design and verification flows exist. The design and verification flow  shown in  is only one example. Examples of different flows are as follows. The design flow  may be combined with the verification flow  to form a single flow. The steps  to ,  to , and  to  do not have to be in the same order as shown in  to . The steps  to ,  to , and  to  in  to  may be executed sequentially or in parallel.","Not all of the steps  to  in the design and verification flow  need to be followed. Any amount of verification may lead to potential benefits in finding errors in the design. One example of a reduction is a flow that includes create datasheets if none available , develop models for components , create top-level netlists if not available , develop top-level regression tests , and run top-level regression tests on models . In this flow, models  are created for the components. These models are then combined and tests are run on the top-level. This has the potential of catching top-level issues and interaction issues between the components. This reduced flow is not as comprehensive as the verification flow  but still offers benefits. As the run top-level regression tests on the implementation step  may be expensive in time, the flow may be reduced by removing this step. Other alternatives include completing this step is a mixed-level fashion. Mixed-level means that some of the components are simulated using the models while others are simulated using the design implementation. Multiple simulations may be conducted so that each of the components may be simulated at least once at the design implementation level. Another reduced flow is not to run regression tests on the models skipping steps  and  and running only on the implementation. In this way, the focus is to check the specifications directly against in the implementation. This may be done if the simulations of the implementation may run fast enough.","There are two approaches to verifying the consistency between a model and a design implementation. The first as described in the Design and Verification Flow  is to run regression tests on the model  and then to run regression tests on the implementation . An alternative approach is to run the regression test on the model and implementation of the design simultaneously comparing the outputs from the model and the implementation to verify that the outputs are functionality consistent. To support this latter method, the regression test templates  would include a template that instantiates the model inside the regression test.","A user also need not work on all of the steps  to  at the same time. For example, a user may use a client  that has web browsing capabilities such as a mobile phone. Using a web browser  that is on the client , the user has access to many of the capabilities in the platform . For example, the user may access the regression test run progress analyzer .","The design and verification flow  may also be extended to add additional steps to obtain additional benefits. An example is where a netlist is required at the component level to connect the regression test and models . In this case a netlist generation step is required between steps  to . Another extension is that rather than having two levels of hierarchy, a component level and a top-level, in the design and verification flow , a verification flow may have a plurality of levels of hierarchy for the components. In this case, steps  to  are repeated for each intermediate level of hierarchy until the top-level is reached. Another extension is to add a model calibration step after step  where results from the regression tests  are put back into the model. In this case, the models are regenerated using the code and document generator  using information from the simulation results . Manual extensions may also be made to the reports , models, regression tests, netlists, connect modules, symbols , and simulation scripts  wherein said reports, models, regression tests, netlists, connect modules, symbols, and simulation scripts require additions to meet user needs. For example, a user of a platform  may not have entered a complete design specifications. In this case, after the code and document generator  is run, the user may manually insert additions into at least one output of the code and document generator. Another extension to the design and verification flow  is to utilize model templates  to generate a model that includes utilizing the prepackaged assertions  and  and that instantiates the design. In this way, assertions may be applied to the design.","Another use is that a platform  need not be applied to only analog, mixed-signal, RF integrated circuit and system design. For example, the platform  may also be applied to a digital-only design, and a system design where the output is not a final chip but an architecture.","Another use of a platform  is to use the platform  in a programmatic manner. Rather than utilizing a human user interface such as a web browser  to access functionality  and data  in the platform, utilize the API in a server interface . A user may write a computer program to operate the platform . In this way, the user may achieve more automation and possibly increase efficiency. Computer programs may be written in a compiled language or in a scripting language.","A platform  may also be used in a flow where there is no verification flow, but only a design flow. For example, designers commonly develop models while implementing components . Such as flow includes steps defining architecture and components , checking for design feasibility , implementing components , and assembling the design and chip level simulations . Another example of a design-only use of a platform  is as a specifications management system where the goal is to primarily use the datasheet and report templates  to generate datasheets.","A platform  may also be used primarily for model generation in both design and verification. In this case, specifications  are created for the design components . Models for each component are generated in multiple languages to aid in the design and verification effort. For example, Verilog may be generated for the digital verification team. Verilog-A may be generated for the analog design team. Verilog-AMS may be generated for the analog verification team. This leads to significant time savings as the specifications only need to be entered once and multiple models are generated.","A platform  may also be used as part of other flows where the platform  is treated as a tool in the context of a larger flow. For example, there are many digital verification platforms and methodologies. A platform  may be used as part of that.","A platform  may also be applied to design for test and post manufacturing testing. Models, regression tests generated  and coverage analyzer  may be used as part of the design for test effort. The models and regression tests generated  may be applied in post manufacturing testing.","Not all design components need to follow the analog verification flow . Pre-existing models may be used in place of generating ones from specifications. Instead of pre-existing models, the design implementation may also be used provided that the components simulated using the design implementation may simulate fast enough to complete the top-level regression tests .","There may be at least one user using a platform  at any given time. Users may be collaborating or be working on different designs.","Custom digital design is logic circuitry designed without the aid of automated or semi-automated synthesis. As a result, custom digital design is very similar to analog design in that no model abstraction is available as a result of the design process, and a separate process is required to generate a behavioral model and has the same requirement that a regression test is needed to validate that the behavioral model is consistent with the design implementation. The invention described in this patent application may be applied to custom digital design.","Thus the reader will see that at least one embodiment of this invention provides methods for generating models, regression tests, netlists, connect modules, simulation launch scripts, simulation launch script configuration files, and schematic symbols for a design based on the specifications for that design. While the above description contains many specificities, these should not be construed as limitations on the scope, but rather as an exemplification of one preferred and alternative embodiments thereof. Many other variations are possible. Accordingly, the scope should be determined not by the embodiments illustrated, but by the appended claims and their legal equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DRAWINGS\u2014FIGURES","p":["Embodiments of the invention will now be described in conjunction with the drawings, in which:",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 23A","b":"1"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 23B","b":"2"}]},"DETDESC":[{},{}]}
