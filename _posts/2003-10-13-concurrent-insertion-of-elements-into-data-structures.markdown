---
title: Concurrent insertion of elements into data structures
abstract: A method of adding an element to a data structure may include atomically associating the element with the data structure if the element is not associated with the data structure. The element may be prepared for insertion into a location in the data structure. The method may also include atomically inserting the element into the location in the data structure if another element has not been inserted into the location.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08549043&OS=08549043&RS=08549043
owner: Intel Corporation
number: 08549043
owner_city: Santa Clara
owner_country: US
publication_date: 20031013
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"p":["The claimed invention relates to concurrent data processing and, more particularly, to concurrent data processing involving a shared resource.","For some time, computing environments have been available that support multithreading, which enables programs whose parts may execute concurrently. Such parts of a program that may execute independently of other parts are typically referred to as \u201cthreads.\u201d Examples of computing environments that may support concurrent (e.g., parallel) execution of threads may include operating systems, compilers, virtual machines, run-time systems, and just-in-time (JIT) compilers.","In some situations, multiple threads may want to perform different operations on the same data element and\/or data structure (i.e., a shared resource). To handle such instances, multithreaded computing environments typically include one or more synchronization mechanisms for synchronizing parallel activities of threads. One example of such a synchronization mechanism that may be provided (e.g., via an application programming interface (API) or other interface) is a \u201clock\u201d that allows exclusive use of the shared resource for a certain time by a particular thread. In such a case, a thread may acquire a lock, perform one or more operations that need to be mutually exclusive, and release the lock after performing the operation(s). The computing environment may ensure that only one thread at a time can acquire a lock, regardless of other threads also trying to acquire a lock.","Such locking synchronization mechanisms, however, may require a substantial amount of overhead for associated system calls (e.g., for keeping track of which threads own which locks and\/or the states of locks). This overhead may be large enough to impact performance if the locks are used in performance-critical code. Also, these locking mechanisms may not be tolerant of faults. For example, if a thread that has acquired a lock dies (e.g., is killed or exits abnormally) before releasing its lock, other threads may be prevented from accessing the shared resources protected by that unreleased lock. Further, if a thread that owns a lock is suspended, a \u201cdeadlock\u201d may occur if the resumption of the suspended thread is dependent on the completion of another task whose progress, in turn, is dependent on the lock of the suspended thread.","The following detailed description refers to the accompanying drawings. The same reference numbers may be used in different drawings to identify the same or similar elements. Also, the following detailed description illustrates certain implementations and principles, but the scope of the claimed invention is defined by the appended claims and equivalents.","During the execution of a program, it may be desirable to collect a list of items that have certain properties. Typically, this is done using a global dynamic structure, such as a linked list or a stack. Upon observing an item that meets certain criteria (e.g., upon activation of a program function), a routine may be called to add the item (e.g., a pointer to the function information) to the list. If the program is multithreaded, multiple threads may try to add items to the list simultaneously.","Although the following description may primarily describe adding elements to a linked list, it should be noted that other types of data structures and operations may be implemented consistent with the principles of the invention. For example, data structures such as stacks, queues, sets, doubly-linked lists, database data structures, etc. may be implemented consistent with the principles of the invention as described herein. Nor is the claimed invention limited to the operation of adding an element to a data structure. Rather, the principles described and claimed herein are applicable to a range of scenarios where there may be competition for and\/or contention over a shared resource among threads.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1","b":["100","110","130","100","100","100","100","100","100"]},"Data elements - may include a data portion (denoted by letters A-C) and a pointer (denoted by next(A-C)). Although only three data elements - are illustrated for ease of explanation, many more elements may be present. The data portions may include data of possibly various types. The pointer, next(A) for example, may point to another element, if data element  is part of list .","When data elements - are initialized, their respective pointers next(A), next(B), and next(C) may be given a null value (or some other predetermined, known value) to indicate that elements - are not initially part of list . Thus initialized, any of elements - may be checked to decide whether that element belongs to list . If next(A) is null, for example, then element  is not part of list , otherwise, element  may be part of list . Thus, pointers next(A-C) of elements - may perform the dual functions of indicating whether a particular element has been added to list  and linking together elements once added to list .",{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 2","FIG. 2","FIG. 3","FIG. 3"],"b":["200","200","1","100"]},"Processing may begin with the thread determining whether the pointer next(E) of the element to be added E is null [act ]. This determination may conclude process  at act  if element E is already present in list  (i.e., next(E) is not null). Act  may enforce a condition that an element E may appear in list  only once, and may efficiently determine whether element  is already in list  before performing other acts in process . Because element  has a null pointer value in , the decision in act  is affirmative and not explicitly illustrated.","If the pointer next(E) of the element to be added E is null, process  may continue with the thread executing a first atomic operation [act ]. As used herein, an \u201catomic\u201d operation may be defined as an operation and\/or software primitive that is uninterruptible by another thread (e.g., this may be conceptualized as an apparently instantaneous or uninterruptible\/indivisible operation\u2014hence the \u201catomic\u201d label). Atomic act  may perform a \u201ccompare-and-exchange\u201d type operation to replace the pointer next(E) of element  with its address E if next(E) is initially null. Such operations will be described in greater detail below. Like act , act  may conclude process  at act  if next(E) is not null. As illustrated in , for the single Thread , atomic act  may result in element  pointing to itself, indicating that it is associated with list .","Process  may continue with the thread modifying the pointer next(E) of element E to point to the value of ListP [act ]. As illustrated in , act  causes the pointer next(E) of element  to point to the same location as ListP. In the example of  where list  initially includes no elements, the value of ListP and next(E) may be the head of list , but in other cases, next(E) would be modified by act  to point to the first element in list .","Process  may continue with the thread executing a second atomic, compare-and-exchange type operation [act ]. Atomic act  may replace the value of ListP with the address E of element  if the values of ListP and next(E) are initially equal. As illustrated in , for the single Thread  atomic act  may result in ListP pointing to element , because no other threads have changed the value of value of ListP before act .","As will be explained in a multiple-thread example below, the values of ListP and next(E) may not necessarily be equal in act , despite assigning ListP to next(E) in the previous act , due to interference from other threads. In such a case, where the values of ListP and next(E) are not equal in act , process  may repeat acts  and  until element E is added to list , as illustrated in .","Process  may conclude with act , a return from the adding routine. As illustrated in , act  may be reached from acts , , and . In acts  and , the thread may reach act  when it has been unable to add element E to list . Thus, addition process  may be considered \u201ccompleted\u201d even when element E has not been added to list . By contrast, the thread may reach act  from act  upon successful addition of element E to list .",{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 4","FIG. 4","FIG. 4","FIG. 3","FIG. 1"],"b":["200","2","5","100","2","310","3","4","110","5","120","100","310","110","120"]},"Further, in the example of , Threads - may execute process  nearly concurrently. That is, each of Threads - may execute act , for example, at approximately the same time. When one thread must execute before another (e.g., for atomic acts  and\/or ), Thread  may be assumed to execute slightly before Thread , which in turn executes slightly before Thread , which in turn executes slightly before Thread . Such an order has been chosen for the purposes of illustration only, and may differ in practice. Similarly, the numbers of threads and elements shown in  are purely exemplary, and may also vary from that shown.","Threads - may execute act . Threads - may continue beyond act , because the respective pointers next(A) and next(B) of elements  and  are null. Thread  may return\/exit from process , because it seeks to add element  that is already present in list \u2032 (e.g., having a non-null pointer next(E)). Such returning\/exiting from process  is illustrated in  by Thread 's arrow stopping at act .","Continuing in process , Thread  may execute atomic act , causing the pointer next(A) of element  to point to its address. Because Thread  cannot execute atomic act  concurrently with Thread  or otherwise interrupt Thread 's execution of atomic act , Thread  may execute act  slightly afterward. Thread  may find in act  that next(A) of element  is no longer null due to Thread . Accordingly, Thread  may return\/exit from process . Such returning\/exiting from process  is illustrated in  by Thread 's arrow stopping at act .","Thread  may successfully execute atomic act , causing the pointer next(B) of element  to point to its address. Thus, after act  list \u2032 may be unaltered, and elements  and  may point to themselves. This resulting state of list \u2032 and elements \/ is conceptually illustrated in  immediately below the dotted line of act .","Continuing process , both Thread  and Thread  may perform act . After act , the pointers next(A) and next(B) of elements  and  may both point to the same location (e.g., element ) as the list pointer ListP of list \u2032. The resulting state of list \u2032 and elements \/ after act  is conceptually illustrated in  immediately below the uppermost dotted line of act .","Thread  may execute atomic act . Finding List P of list \u2032 being equal to the pointer next(A) of element , Thread  may change ListP to the location of element . This successful execution of atomic act  is illustrated in  by Thread 's arrow stopping at act . The resulting state of new list \u2033 (including elements  and ) and element  after atomic act  is conceptually illustrated in  immediately below the uppermost dotted line of act .","Because Thread  cannot execute atomic act  concurrently with Thread  or otherwise interrupt Thread 's execution of atomic act , Thread  may execute act  slightly afterward. Thread  may find in act  that List P of list \u2032 is not equal to the pointer next(B) of element  due to the prior execution of atomic act  by Thread . Accordingly, Thread  may return to act  to try again to add element  to list \u2033. Such returning to act  is illustrated in  by Thread 's arrow continuing beyond the uppermost dotted line of act  to the lowermost line of act .","Thread  may perform act  again. After act , the pointer next(B) of element  may point to the same location (e.g., element ) as the list pointer ListP of list \u2033. The resulting state of list \u2033 and element  after act  is conceptually illustrated in  immediately below the lowermost dotted line of act .","Thread  may execute atomic act  again. Finding List P of list \u2033 being equal to the pointer next(B) of element , Thread  may change ListP to the location of element . This second time executing act , Thread  does not encounter a ListP that was changed by another thread. This successful execution of atomic act  is illustrated in  by Thread 's arrow stopping at the lowermost act . The resulting state of new list \u2032\u2033 (including elements , , and ) after atomic act  is conceptually illustrated in  immediately below the lowermost dotted line of act .","With regard to the example in , the following characteristics of process  may be noted. Act  may provide an efficient mechanism for checking whether an element is already in list . Atomic act  may resolve contention among two or more threads seeking to add the same element to list . Atomic act  may ensure that a concurrent update of list  by a number of threads is performed correctly.","Further, process  may be tolerant of faults and may not produce deadlocks regardless of whether threads are suspended or killed. Atomic acts  and , at least conceptually, reduce lock time to essentially zero, because atomic acts are assumed to be instantaneous\/uninterruptible. Also, act , when it repeats acts  and  for some thread that was unable to add its element, may modify the position in list  of another element that was just added by another concurrent thread.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 5","FIG. 5"],"b":["200","500","510","520","530","530","210","220","230","240","3","6","11","500","250"]},"The atomic operations of acts  and  may be performed by \u201ccompare and exchange\u201d type atomic instructions  and . Computing environments may provide an API, CompareAndExchange (or a similar atomic primitive) that has the following characteristics. The API may include three arguments CompareAndExchange (dst, new, cmp) and may perform the following operations atomically. It may compare a content of the destination (dst) with a value of the comparand (cmp). If dst and cmp are equal, then CompareAndExchange may store the third value, new, to the destination, dst. Otherwise, CompareAndExchange may not modify the destination, dst. In either event, CompareAndExchange may return the initial value of the destination, dst. In this manner, an atomic instruction similar to CompareAndExchange may be used to implement acts  and\/or .","Certain aspects of implementations of the claimed invention may be implemented using hardware, software, or a combination thereof and may be implemented in one or more computer systems or other processing systems. In fact, in one implementation, methods described herein may be implemented in programs executing on programmable machines such as mobile or stationary computers, personal digital assistants (PDAs), set top boxes, cellular telephones and pagers, and other electronic devices that each include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and one or more output devices. Program code may be applied to the data entered using the input device to perform the functions described and to generate output information. The output information may be applied to one or more output devices.","One of ordinary skill in the art may appreciate that implementations consistent with the principles of the invention may be practiced with various computer system configurations, including multiprocessor systems, minicomputers, mainframe computers, and the like. Implementations consistent with the principles of the invention may also be practiced in distributed computing environments where tasks may be performed by remote processing devices that are linked through a communications network.","Each program may be implemented in a high level procedural or object oriented programming language to communicate with a processing system. However, programs may be implemented in assembly or machine language, if desired. In any case, the language may be compiled and\/or interpreted.","Program instructions may be used to cause a general-purpose or special-purpose processing system that is programmed with the instructions to perform the methods described herein. Alternatively, the methods may be performed by specific hardware components that include hardwired logic for performing the methods, or by any combination of programmed computer components and custom hardware components. The methods described herein may be provided as a computer program product that may include a machine readable medium having stored thereon instructions that may be used to program a processing system or other electronic device to perform the methods.","The term \u201cmachine readable medium\u201d or \u201cmachine accessible medium\u201d used herein may include any medium that is capable of storing or encoding a sequence of instructions for execution by the machine and that causes the machine to perform any one of the methods described herein. The terms \u201cmachine readable medium\u201d and \u201cmachine accessible medium\u201d accordingly may include, but may not be limited to, solid-state memories, optical and magnetic disks, and a carrier wave that encodes a data signal. Furthermore, it is common in the art to speak of software, in one form or another (e.g., program, procedure, process, application, module, logic, and so on) as taking an action or causing a result. Such expressions are merely a shorthand way of stating that the execution of the software by a processing system may cause the processor to perform an action or produce a result.","The foregoing description of one or more implementations consistent with the principles of the invention provides illustration and description, but is not intended to be exhaustive or to limit the claimed invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practice of the invention.","For example, the principles of the invention described herein may be applied to data structures other than linked lists, and to operations other than adding an element to the data structure.","Moreover, the acts in  need not be implemented in the order shown; nor do all of the acts necessarily need to be performed. Also, those acts that are not dependent on other acts may be performed in parallel with the other acts. Further, the acts in this figure may be implemented as instructions, or groups of instructions, implemented in a computer-readable medium.","No element, act, or instruction used in the description of the present application should be construed as critical or essential to the invention unless explicitly described as such. Also, as used herein, the article \u201ca\u201d is intended to include one or more items. Where only one item is intended, the term \u201cone\u201d or similar language is used. The scope of the claimed invention is defined by the claims and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings, which are incorporated in and constitute a part of this specification, illustrate one or more implementations consistent with the principles of the invention and, together with the description, explain such implementations. In the drawings,",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 4","FIG. 2"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 5","FIG. 2"]}]},"DETDESC":[{},{}]}
