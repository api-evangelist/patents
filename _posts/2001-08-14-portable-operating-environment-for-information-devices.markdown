---
title: Portable operating environment for information devices
abstract: A client software program for use on an embedded computing device includes an operating system layer including an abstraction layer, a programming environment, and an application framework including a package manager. The client is configured to interface with a client support server including a package repository, for receiving package data for running a software package on the embedded computing device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07032227&OS=07032227&RS=07032227
owner: Twin Communications of America, Inc.
number: 07032227
owner_city: San Jose
owner_country: US
publication_date: 20010814
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["PRIORITY","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS","Client Support Services","Graphics Rendering Mechanism","Font Extensions","Clipping","Theming","Handwriting Recognition","Locking Mechanism","HTML Correction"],"p":["This application claims the benefit of priority to U.S. provisional patent application No. 60\/225,569, filed Aug. 14, 2000.","1. Field of the Invention","The invention relates to software architectures for networked computing devices, which are operated in heterogenous network environments and are able to adapt to varying content types.","2. Discussion of the Related Art","Today, most operating environments are still focused on general purpose desktop computers, and are tightly coupled to their underlying operating systems, a typical example being Microsoft Windows. For certain information device categories, there exist specializd environments like Epoch (cell phones) and Palm OS (Palm PDAs). Several technologies exist which can be utilized in different, cross-platform environments (e.g. Personal Java VMs). These systems so far do not provide the desire degree of:\n\n","Most existing drivers focus on expensive desktop-oriented windowing systems (Windows, X etc.), and accelerated display hardware. Consequently, these drivers have a high degree of runtime configurability (color depth, screen resolution), and use a design which assumes that most performance critical functions can be offloaded to special purpose hardware (bit block transfers, line drawing etc.). Inherently, such a design exhibits a considerable amount of indirection (functions called via pointers), which is acceptable if this overhead is compensated by fast graphics hardware. There are some adaptations of such drivers for generic framebuffer devices, but because of the display hardware oriented design, they do not make use of platform specific optimization mechanisms.","In general, applications use toolkit library functions, which in turn map to driver functions, either by means of direct calls or some inter-process communication mechanism. The driver then branches according to the display HW type (display processor), the user configured screen resolution (width, height) and color depth, invoking the functions which actually do the work (mostly by delegating it to the display processor).","Embedded computing devices mostly don't have accelerated display HW, and provide just a framebuffer memory area. They usually have a fixed resolution and color depth, i.e. don't have a high degree of runtime configurability. They mostly have RISC like processors which provide efficient mechanisms for memory block transfers (number of registers). It is desired to have a graphics rendering mechanism for use with an embedded device which is designed to compensate for a lack of expensive display hardware.","To be suitable for global deployment, it is desired to be able to use local font sets. To overcome the problem of various different, and partially conflicting character encoding schemes, the Unicode initiative has become a de-facto standard. It is based on multi-byte character encoding and as of today contains about 50,000 character symbols.","This constitutes a considerable problem for displaying unicode text with conventional font rendering systems. In general, a font object includes of a collection of per-font and per-character attribute values, the character attributes being index-accessed (with the character code) for efficiency reasons.","The per-character attribute (width, bearing, glyph etc.) implementations usually use arrays of the size of the required character set. While this involves just about 10 kB for a bitmapped 256-character font instance (e.g. ASCII), a full unicode font (50,000 characters) would use up to 2 MB for a single instance (face\/weight\/slant\/size). Typical applications (e.g. web-browsers) utilize about 4 different instances, adding up to 8\u201310 MB of required font space. This amount of memory is not generally available for embedded devices (16 MB RAM\/ROM). It is therefore desired to have a font extension mechanism which permits the implem entation of a reasonable number of font instances in less than, e.g., 2 MB of memory.","In order to provide a suitable basis for a broad range of applications for use with embedded devices, it is recognized herein that it would be advantageous to implement a full windowing system with z-order capabilities (i.e. windows can overlap, with foreground windows partially or fully obscuring background windows). In addition, the rendering mechanism should support explicitly set, non-z-order implied clipping rectangles. Devices having special display processors may implement this by means of HW-augmented region clipping. As mentioned above, embedded devices usually do not have special display processors. It is desired to provide an embedded device with a rendering mechanism that supports explicitly set, non-z-order implied clipping rectangles.","Handwriting recognition systems known in the art include the GRAFFITI system, developed by Xerox, which is used in the PalmPilot, and the JOT system, which is used in WinCE (and others). It is desired to have an improved handwriting recognition system, particularly for use with an embedded computing device.","A client software program for use on an embedded computing device configured for establishing a network connection with at least one other computing device, includes an operating system layer, a programming environment, and an application framework. The operating system layer includes an operating system and an operating system abstraction layer, wherein the operating system abstraction layer is configured to interface between platform independent code and platform dependent code used by the operating system.","A client software program for use on an embedded computing device is further provided including an operating system layer, a programming environment, and an application framework. The client software program is configured to interface with a client support server including a type converter module for translating complex content to simplified content. The client software program is further configured to receive the simplified content from the client support server for processing the simplified content.","A client software program is further provided for use on an embedded computing device including an operating system layer, a programming environment, and an application framework. The client software program is configured to interface with a client support server including a protocol converter module for mapping at least one complex protocol to a simplified protocol. The client software program is further configured to receive and use the simplified protocol.","A client software program is further provided for use with an embedded computing device including an operating system layer, a programming environment, and an application framework including a package manager. The client software program is configured to interface with a client support server including a package repository. The package manager is configured to communicate with the package repository for receiving package data for running a software package on the embedded computing device.","A method of transferring simplified data to a client running on an embedded device from complex data residing on a content server, using a converter service running on a client support server, is provided including communicating a transfer request of the complex data from the content server to the client running on the embedded device, communicating a conversion request to the client support server to convert the complex data to the simplified data, retrieving the complex data, converting the complex data to the simplified data, and transferring the simplified data to the client.","A method of transferring simplified data to a client running on an embedded device from complex data residing on a server, using a converter service software module, is further provided including communicating a transfer request of the complex data from the server to the client running on the embedded device, communicating a conversion request for the converter service software module to convert the complex data to the simplified data, retrieving the complex data, converting the complex data to the simplified data, and transferring the simplified data to the client.","A method of transferring package data needed to run a software package residing on a content server to a client running on an embedded device, using a package repository running on a client support server, is further provided including communicating a transfer request of the software package from the content server to the client running on the embedded device, communicating a conversion request to the package repository for package data needed to run the software package on the embedded device, transferring the package data from the package repository to the client, and transferring the software package from the content server to the client.","A method of transferring package data needed to run a software package to a client running on an embedded device, using a package repository software module, is also provided including communicating a transfer request of the software package from the server to the client running on the embedded device, communicating a conversion request to the package repository software module for package data needed to run the software package on the embedded device, transferring the package data to the client via the package repository software module, and transferring the software package from the server to the client.","A method of processing data on an embedded device having an operating system running platform dependent code thereon, the embedded device being configured for establishing a network connection with at least one other computing device, is also provided including receiving platform independent data from the at least one other computing device for processing in a programming environment using platform independent code, converting the platform independent code using an operating system abstraction interface, and processing the data using the operating system.","A server software program running on a server computer is further provided including at least one data conversion module for converting complex data to simplified data for sending to an embedded computing device for processing thereon, and a package repository module configured to communicate with a package manager of the embedded device for sending package data to the embedded computing device for running a software package on the embedded computing device.","A server software program running on a server computer is also provided including a package repository module configured to communicate with the package manager for sending package data to the embedded computing device for running a software package on the embedded computing device. The package repository module is further configured to communicate with the package manager for sending package metadata to the embedded computing device for running the software data.","A server software program running on a server computer is also provided including at least one data conversion module for converting complex data to simplified data for sending to the embedded computing device for processing thereon. The complex data includes complex content and the simplified data includes simplified content translated from the complex content by the at least one data conversion module.","A server software program running on a server computer is further provided including at least one data conversion module for converting complex data to simplified data for sending to the embedded computing device for processing thereon. The complex data includes a complex protocol and the simplified data includes a simplified protocol mapped from the complex protocol by the at least one data conversion module.","A preferred overall software architecture for use with an embedded device includes client software  and server software , and is schematically illustrated at . It may be subdivided into four different layers, including three layers (1\u20133 below) and a server layer (4 below):\n\n","The preferred architecture is based on a distributed computing model and uses a dedicated server component, or client support server  to offload computing tasks from the client , and to provide on-demand installable SW components. Each of the mentioned layers provides certain advantageous features, as described herein, in accordance with what is desired in the field of embedded device computing, e.g., as set forth above.","The operating system (OS) layer  includes an abstraction layer  which enables the use of a standard operating system  and usage of third party components like device drivers , and also provides the flexibility to exchange these operating systems  without affecting the rest of the system. This features relates particularly to features described below with respect to graphics rendering mechanisms on small embedded devices.","The programming environment layer  is preferably implemented as a Java virtual machine and corresponding libraries. This facilitates several features which permit enhanced performance (locking mechanism, see below), provides advantageous input methods (handwriting recognition, see below), and enables configurable user interfaces (theming , see below). The application layer has a query system module  which communicates with a unified data storage module . The unified data storage module , in turn, communicates with the programming environment  and participates in the theming .","The application framework  includes an advantageous application model, which provides an automated, on-demand triggered package management system via a package manager module which includes a package registry . This mechanism is preferred for enabling on-demand updates\/installation of new software components via the network, and is described in more detail below. An application  is also shown running within the application framework  of the client .","The client support server  provides the backend for this package management and in this sense includes a package repository module , as shown. In addition, the client support server  has functions to transform complex content and\/or protocols into simpler ones, having a type converter module  for translating content  received from a content server  and a protocol converter module  for mapping protocols from a repository  on a content server , thus offloading expensive functions from the client . The client  may have capability to directly receive some content  from a content server  or otherwise such as in a peer-to-peer networking environment, wherein it is understood that when \u201ccontent server\u201d is used herein, it is meant to include any device from which content may be obtained.","As mentioned above, embedded devices are typically memory constraint (i.e., have a limited amount of RAM\/ROM), and typically do not have secondary storage (disks). Embedded devices also differ significantly from desktop computers in terms of processing power, screen resolution, and visuals (color-model). As a consequence, it is more difficult to install all potentially interesting software components before shipment of the device and\/or to run all applications on all embedded device types, e.g., PDAs, cell phones, etc. A preferred embedded device does, however, include some network connection capability. Therefore, it is a feature of the preferred software architecture to provide reliable and efficient access to software and applications by the embedded device through network connection to the client support server  introduced above with reference to .","The application model  of the client software  makes it possible to offload certain tasks to, and to automatically install software components from, a dedicated server , providing so-called \u201cclient support services\u201d to the client . While the content server  would typically not be \u201cclient-aware\u201d (i.e., with respect to architecture, capabilities, installed software, etc.), the client support server  would preferably be client-aware. The client application model\/framework  is preferably designed in a way that it automatically reaches out to a well known (configured) client support server  in case it encounters some content from the content server  that the client  does not know about, or that the client  cannot handle locally.","Referring now to , the client  may retrieve certain types of content, e.g., content type A, directly from the content server  (or a generic proxy of it), using data path (A). In case this is not possible because of client constraints, either path (B) via the content type converter  or path (C) via protocol converter  are available through the client support services server . Path (D) is described in more detail below.","Referring now to , a communication may be, although not necessarily, initiated by encountering a URI or content data ( or , e.g.) which the client  is not configured to process, as illustrated by step (1). The client  then communicates a conversion request to the client support server  as illustrated by step (2). If the complex content data was supplied with the request, then the process would proceed to step (4). However, in case the complex content data was not supplied with the request, then the client support server  retrieves it from the content server as illustrated at step (3). In either case, the client support server converts the data, e.g., by translating complex content  to simplified content using the type converter module  or by mapping a complex protocol  to a simplified protocol using the protocol converter , each as illustrated at . Finally, the client support server  sends the converted content back to the client  in a format\/protocol that the client  can process as illustrated at step (4).","A typical format conversion example could be a complex word-processor document, wherein the embedded device, such as a handheld device, is configured such that it is only capable of displaying HTML or other markup language type content. In this example, the type converter  would convert the word processor document to markup language type. A protocol conversion example could be accessing a mail server via a simple message protocol, leaving the complexities to handle IMAP, POP3, etc., to the protocol converter service  running on the client support server .","The client update\/extension mechanism (D) (see ) will now be described with reference to . The client update\/extension mechanism (D) may typically start with a content reference (URI) from the content server  that the client  does not know about or is not configured with, as having only application  () installed, as illustrated by step (1) in . For example, the client  may have no registered protocol-handler to retrieve the content, or may have no registered viewer for its format. In this case, a feature request is sent to the package repository service  on the client support server  as illustrated by step (2). The feature is looked up in the repository  (containing client software packages), and sent back as a package description (metadata) as illustrated by step (3), containing dependencies and conflicts to\/with other packages. This is checked on the client against installed packages, potentially resulting in additional requests for missing dependency packages, i.e., repeating step (2).","Once all dependencies have been resolved, the required package data is retrieved from the client support server  as step (5) and finally processed as an install transaction (i.e., fully processed or reverted) of application 1 () at step (6). The user of the embedded device may be involved in the process by initiating a confirming request at step (4), although the system may be configured to automatically perform the process. In either case, the user doesn't not have to know about the feature with respect to package mapping, dependencies or constraints. Alternatively, step (3) may involve a user selection from a list of alternative packages.","Preferably, all client support services are utilized via an application model which is driven by portable documents written in a markup language (e.g., HTML or XML). Documents can be nested, which enables a local service to embed a new child document into its requester. New local services may be installed via the package manager , and may in turn use a remote converter service, as described below with reference to .","Referring to , an illustration of how the process is performed by the application , the application framework  and the client support services server  is described below. The application  performs the steps of retrieving the document , parsing the document  and resolving features . The application framework  then becomes involved for package management , and communicates with the package repository  of the client support server . The package manager  communicates with a local service registry  which utilizes a local service . The local service communicates with the converter service ,  of the client support server . The application  processes data via registered services  by communicating with the local service registry  and the local service . The document is cached , wherein the process may return to step . Resources are freed by the application at step .","A graphics rendering mechanism for use with an embedded device which is designed to compensate for a lack of expensive display hardware is described below. The preferred graphics rendering mechanism for use with an embedded computing device includes an application , e.g, paint , a graphics toolkit , e.g, including drawling and fill rectangle tools , and a graphics driver . The graphics driver  is divided into two parts: a framebuffer access macro layer  and a shape function layer . The framebuffer access macro layer  includes a target architecture (CPU) specific instruction set to set\/retrieve pixel values into\/from the framebuffer memory. The framebuffer access instructions are expanded or inlined into the shape function layer , to avoid or reduce call overhead. The shape function layer  itself can be inlined into the application, thus providing enhanced efficiency (at the cost of runtime configurability, which is less relevant for embedded systems as compared with, e.g., desktop systems).","One of the most performance critical tasks for a graphics driver is to map certain mathematically described shapes (lines, circles etc) to the display pixel raster, which involves finding the closest raster pixel for a given mathematical point. This is called rasterization.","The preferred rasterizer utilizes the mentioned characteristics of embedded devices, to compensate lack of expensive display hardware by means of\n\n","Display adapter acceleration can still be done at the shape function level  (e.g. drawLine), but the preferred mechanism introduces a whole new layer of processor specific acceleration, which is implemented as a set of macros, i.e., enables inlining up to a point where there is little or no indirect invocation of rendering functions.","Most shape algorithms are conceptually 2-dimensional, i.e., assume a logical framebuffer model which can be thought of as a matrix of pixels, each addressed by a x,y coordinate pair. However, the physical framebuffer is just a simple memory range, i.e., 1-dimensional, organized into so called scanlines (the matrix rows). The preferred rasterizer bridges this gap by means of the fact that most shape function algorithms make use of shape-specific scene cohesion properties, where new pixel positions are derived from previous pixel positions. The Bresenham line drawing algorithm can be considered as a typical example: depending on the slope of the line, the algorithm iterates in 1-increments through the major delta coordinate (e.g., x), and accumulates error terms for the dependent pixel coordinate (e.g., y). If the error term (which is usually inexpensive to evaluate) exceeds a certain threshold, the dependent pixel coordinate is incremented ( see ).","Such an algorithm can be re-formulated so that it uses an abstract set of scanline access instructions:\n\n","These instructions can be implemented as processor specific macros, which advantageously can have a significant performance gain for setting\/copying pixel ranges (i.e., block transfer operations used in filling rectangles, drawing horizontal\/vertical lines, copying bitmaps, etc.). Compared to a generic setPixel(x,y,color) function, this also eliminates a significant number of expensive multiplication instructions, replacing them by simple additions, or even increments. By means of these pseudo instructions, the 2-dimensional shape construction is separated from configurable 1-dimensional, processor specific scanline functions.","This separation is based on the concept of the SLC, the build-time configured scanline cell type, which is the smallest addressable scanline unit holding the color information, e.g., for at least one pixel (see ). This abstraction is used in order to deal with visuals which pack several pixels into one byte (e.g. black\/white, or VGA). These visuals can be dealt with by means of adding a column parameter (x) to the mentioned scanline access instruction set.","To overcome the problem set forth above with respect to the unicode set and the limited memory capacity available on embedded devices, as illustrated at , a preferred font handling mechanism is now described with reference to . The preferred font-handling mechanism is based on the assumption that for most localizations, only a single primary character subset is used from the whole unicode set. There might be characters from additional, secondary subsets interspersed, but these sets are usually smaller, and are just used for mixed in words\/names. As a example, a typical Japanese localization uses about 8000 characters from the Kanji\/Katakana\/Hiragana unicode subsets, with occasional western names rendered in latin characters. Such a font instance would typically add up to about 500 kB.","The preferred font handling mechanism therefore assumes that (especially per-character) font attributes are kept in disjunct, but linked memory objects, so called font-extensions. In case of a very expensive extension (e.g., Kanji), this extension could be shared between several font instances, especially for different per-font rendering attributes like italic, which mostly make sense for latin font sets anyway. In addition, font-extensions can be loaded on demand, which is particularly advantageous on systems not providing memory mapped font instances (i.e., filesystem data is duplicated into the process address space).","By splitting up the whole unicode font range into configured primary\/secondary font extensions (with possibly shared secondary extension data), it becomes feasible to implement a reasonable number of font instances in less than 2 MB of memory. The fact that most of the text is rendered in the primary character subset, and secondary subsets are used on a per-word basis (i.e. the number of extension switches is relatively low), can be used to compensate the efficiency penalties (caused by per-character font-extension checking) by means of keeping a reference to the most-recently-used extension.","A structure and algorithm is now described which compensates for the lack of embedded devices having a sophisticated display processor, and enables a straight-forward, inexpensive implementation of the rasterizer, which is preferably based on rectangular clipping at the driver level. As mentioned above, the preferred embedded device is configured to display drawings surfaces or windows overlapping one another on the display.",{"@attributes":{"id":"p-0077","num":"0092"},"figref":"FIG. 12"},"One of the rendering attributes of a \u2018GraphicsContext\u2019 object can be an explicitly set clipping region (\u2018clipRegion\u2019), i.e., the area to which graphics output is confined to (which is application specific). Graphics context objects can have explicitly set attributes like color, font, and clipping regions. When an output operation is performed, a visibility tag (see below) of the attached surface object is checked for changes. If the tag value has been modified, a set of rectangular clip segments are computed and stored in the graphics context object, by means of calculating the intersection of the drawing surface's visible segments with the graphics context's clipping region:\n\n{R}={R}intersected with {R}\n","Additional advantageous features of the preferred algorithm include \u201cvisible segments\u201d, \u201cclip segments\u201d, and \u201cvisibility tags\u201d. Visible segments (\u2018visSegments\u2019), are sets of rectangles describing the visible, not obscured region of a \u2018DrawingSurface\u2019. These visible segments are preferably changeable by modifying the z-order of the \u2018DrawingSurface\u2019 object (e.g., by calling a function \u2018changeZorder( )\u2019), which is assumed to happen orders of magnitudes less frequent than executing the drawing operations using these segments (e.g. \u2018drawShape( )\u2019), and are kept as attributes of the \u2018DrawigSurface\u2019. Every change of the visible segment set increments a visibility tag (\u2018visTag\u2019), which is also stored as a \u2018DrawingSurface\u2019 attribute.","Clip segments (\u2018clipSegments\u2019), describe the exposed region of a \u2018DrawingSurface\u2019 instance which falls within the clipping region of a \u2018GraphicsContext\u2019 instance. When an output operation (e.g. \u2018drawShape( )\u2019) is executed via a \u2018GraphicsContext\u2019 object, the visibility tag stored in the \u2018GraphicsContext\u2019 object is compared to the one stored in the corresponding \u2018DrawingSurface\u2019. If the tag value has been modified, a new set of rectangular clip segments is computed and stored in the \u2018GraphicsContext\u2019 object, by means of calculating the intersection of the visible segments of the \u2018DrawingSurface\u2019 with the clipping region of the \u2018GraphicsContext\u2019.","The output operation is then performed iterative for each clip segment rectangle, i.e., preferably does not use more than simple rectangular clipping from the underlying graphics driver\/rasterizer.\n\n","Referring to , the computation of visible segments and clip segments is done by means of an intersection algorithm which treats rectangles and sets of non-overlapping rectangles (aka regions) uniformly, the underlying data model being a linkable rectangle (i.e., sets represented as a linked list of rectangles). For each combination of two overlapping rectangles Rand R, the inverse logical product is either nil (Rfully obscured by R), a single rectangle (Rleft\/upper\/right\/lower half obscured by R), or a set of 2 to 4 rectangles, as illustrated at .","Calculating intersections of sets of rectangles {R} and {R} is performed by building the union of result sets obtained by computing the inverse logical product for each combination of elements of {R} and {R}. The preferred clipping mechanism is especially useful in the context of non-overlapping drawing surfaces (i.e., a small number of resulting clip segments, which are infrequently modified), since it includes only minimal overhead to handle set operations, and avoids expensive clip region re-calculations.","The following embodiment is particularly contemplated for use with embedded devices wherein a vendor and\/or user configured look and feel is desired (e.g., colors, fonts, decorations), which is referred to herein as theming. To achieve this goal, a preferred software scheme includes a design which makes it possible to generically separate the logic of a user interface component from data which can be used to factorize the way it is rendered.","Referring to , the design is based on an abstraction that each UI component can be divided into a border and a background area, the border having invariant extensions for a specific component class (e.g. Button) and theme. Information which is displayed in the UI component (e.g., a Button label text) is drawn on top of the background, is clipped against the border, and is rendered in a separate step.","Rendering of the border and background may be performed automatically by the system (i.e., does not involve user code), and uses a per-UI component decoration object which may be theme-, UI class-, and style- specific. The decoration objet can be shared between instances of the same UI class, and gets set during the initialization of the UI via a configured theme object, which is a decoration factory.","This process is described in , by means of a UML-like diagram, with boxes representing types\/classes (including name, data members and functions), round boxes representing snippets of the key functions, thin arrow lines representing references, thick arrow lines representing inheritance relationships (arrow pointing towards super-class), and dotted arrow lines representing object creation. Attributes which are used to render UI data (colors, font, clipping region), and to determine the UI component size (border widths), are queried from the decoration object. The preferred mechanism enables very flexible rendering schemes, e.g., partially transparent borders, backgrounds inherited by UI component-parents, and UI-state\/-style specific representation (e.g., \u2018focused\u2019 UI components). Theme and decoration classes can be completely hidden from user code, which makes the mechanism especially suitable for extending the functionality of existing application programming interfaces, i.e., to use theming in applications which are compatible to standard libraries (like Java). In addition to this generic design, the preferred configuration also includes a specialized ConcreteDecoration class as illustrated in , which is based on a tiled image model.","There are three major types of objects involved in the preferred embodiment: \u201cuser interface components\u201d (also called \u201cwidgets\u201d), \u201cdecoration\u201d objects, and \u201ctheme\u201d objects, each of them derived from abstract base types, with at least one concrete derived type (e.g. \u2018AbstractWidget\u2019\/\u2018ConcreteWidget\u2019). UI component objects are the objects used in the application (e.g., a button), to display data (e.g. text), and to collect user input. Decoration objects are system constructs to separate the UI component logic from rendering border and background of a UI component. Theme objects are used to create specific decoration objects so that their types do not have to be hardcoded into the UI components.","The common UI component type (\u2018AbstractWidget\u2019) references a \u2018AbstractDecoration\u2019 object, which is obtained from a global theme object (\u2018AbstractTheme\u2019) acting as a abstract factory pattern (creating specific \u2018ConcreteDecoration\u2019 instances and returning them as \u2018AbstractDecoration\u2019 references). Creating and storing decoration objects is usually done as part of the UI component initialization (e.g. in initialize( )). Once the \u2018decoration\u2019 object is known to the UI component, it uses it to obtain its own dimensions (e.g. by calling \u2018getBorderWidth( )\u2019), which is done by adding the decoration-specific border extensions to its data-dependent background extensions.","The rendering process itself is divided into two separate layers: (1) automatic decoration rendering and (2) component specific data rendering. It is wrapped into a function which is automatically called by the system (e.g. \u2018render( )\u2019), implemented in the common UI component type (e.g., \u2018AbstractWidget\u2019), which first uses the decoration object to render border and background areas (e.g. by calling \u2018drawBordero\u2019, \u2018drawBackground( )\u2019), and then calls a overloaded rendering function (e.g. \u2018paint( )\u2019), which is implemented in the concrete UI component class to render the component specific data on top of the background area.","Referring now to , there are preferably nine images (bitmaps) used per widget, one for each corner, one for each border, and one for the background. Border images are tiled left-to-right, top-to-bottom, and the background image is tiled across the whole interior of the widget.","This decoration scheme is especially advantageous for implementing artistic themes, i.e., providing customized look and feel without programming. The theme images can be kept in separate packages\/archives which can be installed separately.","According to this preferred embodiment, a rendering policy is encapsulated into a shared delegation object (the \u2018decoration\u2019), i.e., an API (not just data). A UI component area is logically split up into background and border. The border dimensions are queried and attributes rendered (e.g., font,color) from the decoration object, and the UI component size is calculated from it. The drawing is preferably split up into a non-overridable system part (e.g., \u201crender( )\u201d in the picture) and an overridable user part (e.g., \u201cpaint( )\u201d).","This following description relates to a preferred handwriting recognition system which is designed to provide the following advantages particularly for use with embedded devices:\n\n","The preferred algorithm presented here preferably includes the following features:\n\n","The following algorithm is preferably used wherein stroke characters are converted into integers:","Step A: Setup\n\n","Step B. Pen Down\n\n","Step C. Pen Move\n\n","Step D. Pen Up\n\n","The above algorithm can be extended to recognize multi-stroke characters. To do this, the event \u2018pen down\u2019 is defined which is added to the pattern in the usual way whenever the pen is pressed down. However, to avoid recognition when the pen is released, \u2018Step D\u2019 is triggered on another action rather than \u2018pen up\u2019 as defined for uni-stroke characters. This action can be one of the following:\n\n","Spatial\u2014an area may be defined as illustrated in . A character is written in each box from left to right (or right to left depending on the language). A character is considered complete and trigger \u2018step D\u2019 when the pen is put down in a different box from the last box. Note that this scheme does not allow the separate recognition of symbols, numbers, uppercase letters and lowercase letters. However, all of these may be encoded using multiple stokes making such a scheme unnecessary.","In order to provide a safe multi-threading environment for applications (concurrent execution of several tasks), the preferred embodiment includes an efficient inter-thread synchronization scheme, which is done by means of monitors (guarded sequences of instructions, allowing just a single thread at a time to execute the instructions), and using efficient object locks. Depending on the thread model in use, checking, and updating object locks can be very expensive, since these operations involve atomic instruction sequences which might be implemented as operating system-specific system functions. Advantageously, the locking mechanism according to the preferred embodiment provides testing and setting of the lock in an uninterrupted manner:\n\n","The scheduler (or thread switching mechanism) is not allowed to switch threads between the lock test and the lock set, which avoids inconsistencies (e.g., object lock held by two different threads). This is achieved at the scheduler level, i.e., is implemented efficiently with user thread systems (wherein the scheduler is part of the application), but can use expensive system calls in case kernel threads are used.","While the probability of colliding lock attempts depends on the nature of executed applications, statistical analysis has shown that in typical applications this probability is less than 0.1, i.e. more than 90% of all locking operations release the lock before another thread tries to get it. However, it is quite common that a lock is recursively obtained\/released from within the same thread, as in:\n\n","The well-separated nature of locking attempts is depicted at . The non-overlapping locks and recursive thread internal locks are deemed un-critical in that not more than one thread tries to obtain the lock at a given time. The lock collision area is the only case which involves a second requestor (thread B) which is blocked on the attempt to acquire the lock, to be re-scheduled once the lock is given up (by thread A).","The locking aspect of this preferred embodiment builds upon this observation to distinguish between heavy and light locks, handling the much more likely light locks (non-overlapping and recursive thread internal locks) in user space, i.e., without the use of expensive system functions, and reverting to system-based heavy locks (lock collision situations) when a potential collision is not recognized as just a thread-internal nested locking attempt.","Each object can have one of the lock states depicted in . The first locking attempt puts an unlocked object into the \u2018light locked\u2019 state. If there are subsequent locking attempts from within the same thread, the state doesn't not change. However, if another thread tries to lock a \u2018light locked\u2019 object, the state changes to \u2018heavy locked\u2019.","In order to implement this model, the preferred embodiment uses three advantageous constructs\n\n","Typically, nested intra-thread lock attempts are detected by means of obtaining an identifier of the currently running thread, and to compare it with the one stored in the lock structure. However, obtaining such a thread id can be expensive in itself (especially for kernel thread systems, where it again involves a system call, i.e., requires the measure that the preferred embodiment overcomes by means of the light locks). The preferred embodiment works around this by using addresses of stack variables to identify threads (stacks are per-thread data areas). If a locking attempt of a \u2018light locked\u2019 object detects that the difference D=S\u2212Sbetween its own lock slot and the address stored in the object lock reference is smaller than a certain threshold (deduced from a reserved area at the end of each stack), this is recognized as a nested intra-thread locking attempt and the object lock is not inflated (i.e., it is not turned into a heavy lock). The feature is illustrated at . While this conservative approach might inflate some locks without need (inside of deeply nested function calls), the vast majority of nested locking attempts is recognized and handled without overhead.","To provide atomic execution of the lock test & set, the preferred embodiment uses a generalized compareAndExchange macro, which is logically defined by\n\n","To achieve portability, the preferred embodiment does not assume that the target architecture (CPU) directly supports the compareAndExchange function, and provides implementations for several different atomic machine instructions:\n\n","While implementation with (1) is most straight forward, (2) and (3) involve the use of additional helper variables.","ATOMIC_EXCHANGE uses a stack variable to store the results of the atomic instruction in a thread-safe location\n\n","The temporary LOCKINPROGRESS value is used to detect concurrent executions of COMPARE_AND_EXCHANGE.","TEST_AND_SET can be used to efficiently implement a global lock\n\n","To distinguish between light and heavy locks, the invention makes use of word aligned lock slots and heavy lock objects, setting bit  when storing heavy lock addresses in the object lock field.\n\n","The IS_HEAVY test macro then simply has to check for this bit\n\n","With these functions, the lock and unlock operations can be implemented like\n\n","In summary, the preferred embodiment uses stack variables, memory alignment (of stack variables and heap objects), and an abstract COMPARE_AND_EXCHANGE instruction to achieve a portable, thread-system neutral, and efficient contention-based lightweight locking scheme.","The application model according to a preferred embodiment is based on markup language documents, the most common language being HTML. Unfortunately, this language has evolved over more than a decade, with the result that many documents today do not follow a strict grammar, or are simply malformed. Classical examples of malformed HTML are missing end-tags\n\n","Constructing meaningful documents from such input usually involves a separate parsing step, i.e., generating a memory representation, correcting it, and then writing it back so that it can be further processed\/displayed (which again involves a parsing step, with different semantic actions and node types).","The preferred embodiment works around this problem by means of utilizing a recursive descend parsing scheme with token lookahead (mapping grammar productions into recursively called functions), which enables to return from productions based on semantic actions. The following grammar fragment prints semantic actions in bold italics, and uses a EBNF like syntax definition (\u2018{. . . }\u2019 denoting repetitions, \u2018[. . . ]\u2019 denoting options, and \u2018|\u2019 separating choices).",{"@attributes":{"id":"p-0124","num":"0267"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"node ::= \u2018<\u2019 START_TAG \u2018>\u2019"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{","if (!validNextNode(START_TAG,"]},{"entry":[{},{},"lookAhead(1),lookAhead(2))) return; (1)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"node [TEXT]"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"| \u2018<\/\u2019 END_TAG \u2018>\u2019 if (equal(START_TAG,END_TAG)) return; (2)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The semantic action (1) is executed before the parser descends into the next \u2018node\u2019 construct, which would be treated as a child of START_TAG.","The preferred embodiment introduces a function validNextNode( ), which is responsible for determining if the following node is either (A) a valid child node or (B) an acceptable end node of START_TAG.","Test (A) can be efficiently implemented by means of a N\u00d7N matrix of all valid HTML tags, with \u20181\u2019 elements indicating a valid parent-child relationship. This test would fail for the <LI> . . . <LI> combination of the first example, bailing out of the first <LI>, then accepting the second <LI> as a valid child of the enclosing <UL>.","Test (B) requires the classification of tags as being \u2018structural\u2019 (like <UL>), or \u2018attribute\u2019 (like <FONT>). Mismatching structural end tags are preferably not accepted, and are returned to their corresponding START_TAG level. Mis-matching attribute tags preferably are usually accepted, since they are mainly used for semantic side effects (like setting attribute values for all enclosed \u201cchild\u201d nodes). A matching end tag of course returns after consuming all corresponding end tokens (2). With this mechanism, it becomes possible to parse and process HTML documents (showing the above deficiencies) in a single pass.","While exemplary drawings and specific embodiments of the present invention have been described and illustrated, it is to be understood that that the scope of the present invention is not to be limited to the particular embodiments discussed. Thus, the embodiments shall be regarded as illustrative rather than restrictive, and it should be understood that variations may be made in those embodiments by workers skilled in the arts without departing from the scope of the present invention as set forth in the claims that follow, and equivalents thereof.","In addition, in the method claims that follow, the operations have been ordered in selected typographical sequences. However, the sequences have been selected and so ordered for typographical convenience and are not intended to imply any particular order for performing the operations, except for those claims wherein a particular ordering of steps is expressly set forth or understood by one of ordinary skill in the art as being necessary."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0028","num":"0031"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0029","num":"0032"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0030","num":"0033"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0031","num":"0034"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0032","num":"0035"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0033","num":"0036"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0034","num":"0037"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0035","num":"0038"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0036","num":"0039"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0037","num":"0040"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0038","num":"0041"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0039","num":"0042"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0040","num":"0043"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0041","num":"0044"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0042","num":"0045"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0043","num":"0046"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0044","num":"0047"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0045","num":"0048"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0046","num":"0049"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0047","num":"0050"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0048","num":"0051"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0049","num":"0052"},"figref":"FIG. 22"}]},"DETDESC":[{},{}]}
