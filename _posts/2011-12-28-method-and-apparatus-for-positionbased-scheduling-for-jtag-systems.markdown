---
title: Method and apparatus for position-based scheduling for JTAG systems
abstract: A position-based scheduling capability supports interaction between one or more user applications and a scheduler for performing testing via a scan chain of a unit under test. The scheduler receives access requests from one or more user applications, where each access request is a request for access to a segment of the scan chain, respectively. The scheduler determines scheduling of the access requests using a circuit model configured to represent an ordering of the segments of the scan chain. The scheduler may provide the access responses to the user application(s) from which the access requests are received, thereby enabling the user application(s) to issue test operations toward a processor configured to generate test data to be applied to the scan chain. The scheduler may obtain the test operations and send the test operations toward a processor configured to generate test data to be applied to the scan chain.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08775884&OS=08775884&RS=08775884
owner: Alcatel Lucent
number: 08775884
owner_city: Paris
owner_country: FR
publication_date: 20111228
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application is a continuation-in-part of U.S. patent application Ser. No. 12\/495,237, entitled \u201cMETHOD AND APPARATUS FOR SYSTEM TESTING USING MULTIPLE INSTRUCTION TYPES\u201d, now U.S. Pat. No. 8,533,545 U.S. patent application Ser. No. 12\/495,295, entitled \u201cMETHOD AND APPARATUS FOR SYSTEM TESTING USING MULTIPLE PROCESSORS\u201d, and U.S. patent application Ser. No. 12\/495,336, entitled \u201cMETHOD AND APPARATUS FOR SYSTEM TESTING USING SCAN CHAIN DECOMPOSITION\u201d, each of which was filed on Jun. 30, 2009, and each of which claims the benefit of U.S. Provisional Patent Application Ser. No. 61\/157,412, filed on Mar. 4, 2009, entitled TEST INSTRUCTION SET ARCHITECTURE, which applications are hereby incorporated herein by reference in their entirety. This application is related to U.S. patent application Ser. No. 13\/338,581, entitled \u201cMETHOD AND APPARATUS FOR DEFERRED SCHEDULING FOR JTAG SYSTEMS\u201d, which is hereby incorporated herein by reference in its entirety.","The invention relates generally to JTAG systems and, more specifically but not exclusively, to scheduling of testing in JTAG systems.","In Joint Test Action Group (JTAG) applications, access to a System Under Test (SUT) is provided through application of vectors to a scan chain of the SUT. The vectors are serially applied to the standardized Test Access Port (TAP), which provides an interface to the scan chain of the SUT. The vectors represent the binary value of each bit in the scan chain. A typical test routine may include anywhere from a few vector bits to a large number of vector bits (e.g., hundreds, thousands, or even more). As a result, given that vector sets must be computed and serially applied to the TAP, the size of a vector set is an important consideration in testing for a SUT, especially in embedded applications. Furthermore, vectors are computed for a specific JTAG setup and, thus, need to be modified each time that the JTAG setup changes (an operation that is known as retargeting, which is quite onerous especially when the subsystem to retarget is complext). As a result, dynamic testing (e.g., situations where the vector inputs must be adapted \u201con the fly\u201d based on the actual outputs) is limited because it requires a continuous retargeting of the entire scan chain and, similarly, use of dynamic topologies (e.g., where the length of the scan chain varies depending on the value of some elements) is limited as concurrent use of instruments is quite difficult because of the computational intesity associated with the required retargeting. Thus, although theoretically possible, the above-described problems make dynamic and portable testing unfeasible.","Various deficiencies in the prior art are addressed by methods and apparatuses for scheduling of scan chain access for accessing a scan chain of a unit under test.","In one embodiment, an apparatus includes a processor and a memory, where the processor is configured to receive a plurality of access requests and determine scheduling of the access requests. The access requests are configured to request access to respective segments of a scan chain of a unit under test, where each segment models one or more elements of which the scan chain is composed. The scheduling of access requests is determined using a circuit model configured to represent an ordering of the segments of the scan chain.","In one embodiment, a method includes using a processor for receiving a plurality of access requests of at least one user application and determining scheduling of the access requests. The access requests are configured to request access to respective segments of a scan chain of a unit under test, where each segment models one or more elements of which the scan chain is composed. The scheduling of the access requests is determined using a circuit model configured to represent an ordering of the segments of the scan chain.","In one embodiment, an apparatus includes a processor and a memory, where the processor is configured to send an access request from a user application toward a scheduler and receive an associated access response from the scheduler. The access request is a request of the user application. The access request is configured to request access to a segment of a scan chain of a unit under test, where the segment models one or more elements of which the scan chain is composed. The access response is received at the user application. The access response is configured to indicate, to the user application, that the user application may access the segment of the scan chain for which access was requested.","In one embodiment, a method includes using a processor for sending an access request of a user application from the user application toward a scheduler, and receiving an access response associated with the access request at the user application. The access request is configured to request access to a segment of a scan chain of a unit under test, where the segment models one or more elements of which the scan chain is composed. The access response is configured to indicate, to the user application, that the user application may access the segment of the scan chain for which access was requested.","To facilitate understanding, identical reference numerals have been used, where possible, to designate identical elements that are common to the figures.","Various system testing capabilities are provided for use in performing testing of a system under test (SUT).","In one embodiment, a test instruction set architecture (TISA) is provided. The TISA is provided for use in performing system testing. The TISA combines computer science capabilities with system testing capabilities to provide improved system testing capabilities, including interactive testing capabilities, remote testing capabilities, and various other capabilities described herein. The TISA is formed by adapting a software-based instruction set architecture (ISA) using system testing capabilities. The software-based ISA may utilize any suitable software programming language (e.g., C++, Java, and the like, as well as various combinations thereof) and may be implemented using any suitable processor. The system testing capabilities may utilize any suitable TAP, such as IEEE 1149.1 (also known as JTAG) TAPs or any other suitable TAPs. In general, the TISA is formed by combining the atomic operations of a software process with atomic testing operations of a test procedure. In the TISA, the algorithmic portions of the test procedure are handled by the software flow, such that the algorithmic portions of the test procedure are translated into the atomic testing operations. The TISA is formed by combining the atomic operations of the software process with the atomic testing operations of the test procedure, such that the atomic testing operations are treated in the same manner as the atomic operations of the software process that is handling the algorithmic portions of the test procedure. This enables finer-grain control of embedded test execution, remote test execution, and various other improved system testing capabilities as depicted and described herein.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 1"},"As depicted in , system testing environment  includes a testing system (TS)  and a system under test (SUT) .","The TS  may be any system suitable for testing SUT . The TS  is configured for testing SUT . The TS  may perform any testing of SUT , e.g., testing one or more individual components of SUT , one or more combinations of components of SUT , one or more interconnections between components of SUT , one or more system level functions of SUT , and the like, as well as various combinations thereof. The TS  may perform any of the functions typically associated with testing a system under test, such as executing test procedures, providing input data to the system under test, receiving output data from the system under test, processing output data received from the system under test for determining system testing results, and like functions, as well as various combinations thereof. The design and use of TS  for testing a system under test is described in additional detail hereinbelow.","The SUT  may be any system which may be tested using TS . The SUT  may include any component(s), at least a portion of which may be tested, individually and\/or in combination, by TS . The SUT  may include one or more scan chains, having one or more sets of associated input and output access pins, providing access to the component(s) to be tested by TS . The manner in which a scan chain(s) may be utilized in SUT  for testing SUT  will be appreciated by one skilled in the art. For example, SUT  may include one or more boards, testing of which may be performed using one or more scan chains having associated input and output access pins which may be used for applying input testing signals to SUT  and collecting output testing signals from SUT .","As depicted in , TS  accesses SUT  via a test access interface (TAI) . The test access interface may be implemented using any suitable test access interface, which may depend on one or more of the TS , the SUT , the type of testing to be performed, and the like, as well as various combinations thereof.","For example, TAI  may include a Joint Test Action Group (JTAG) Test Access Port (TAP) as standardized in IEEE 1149.1 standard, which is incorporated by reference herein in its entirety. The IEEE 1149.1 standard defines a TAP that supports the following set of signals: Test Data In (TDI), Test Data Out (TDO), Test Mode Select (TMS), Test Clock (TCK), and, optionally, Test Reset Signal (TRST). The TDI and TDO pins of SUT  are interconnected in a boundary scan chain by which TS  may access SUT  for testing at least a portion of SUT .","The TAI  may include any other suitable test access interface.","It will be appreciated by one skilled in the art that TS , TAI , and SUT  may be implemented in any manner suitable for providing features of the embodiments covered herein.","As described herein, the TISA is able to leverage computer science capabilities in combination with system testing capabilities to provide a significant improvement in system testing. A general description of system testing capabilities and computer science capabilities follows, followed by a description of the manner in which computer science capabilities and system testing capabilities may be utilized together to provide the TISA.","The TISA improves upon system testing capabilities by leveraging computer science capabilities. The system testing capabilities may include the capabilities generally supported in all stages of the \u201cautomated test\u201d flow (which generally includes all of the steps and resources that may be needed to get from a definition of the test algorithm(s) to actual testing operations).","In order to help test automation, test resources often are embedded inside the boards and devices, and can be accessed using a standardised interface, usually called the Test Access Port (TAP). This has the effect of limiting the pin count and rationalising resource access and management. A number of languages are available for describing resources inside a system under test, and, thus, which may be used as inputs to Test Generation Tools (TGTs). TGTs can apply algorithms to generate testing sequences which may be used by a Test Control Unit (TCU) to command the TAP and execute the associated testing operations. The features and performances of the testing operations depend on these three elements: the access standard, the data format, and the TCU implementation.","The TISA is able to leverage computer science capabilities to provide improved system testing capabilities. This may include use of computer science capabilities that are available in all stages of the \u201csoftware development flow\u201d (which generally includes any or all of the steps and resources that may be needed to get from a software algorithm coded in a software language(s) of choice to the final debugging and execution on a target processor, such as compilation, an Instruction Set Architecture (ISA), interactive debugging, and the like, as well as various combinations thereof).","The use of compilation in computer science reduces an algorithm defined in a programmer-friendly high level abstraction to a series of machine-executable instructions. This process can vary greatly, depending on the input programming language and project complexity; however, most, if not all, of the approaches share the same basic assumption: any algorithm can be decomposed into basic instructions, regardless of its complexity. This applies to classic languages, as well as to more modern high-level and object oriented languages such as, for example, C++, Java, Python, and the like.","The Instruction Set Architecture (ISA) is the core of any processor, and the reason for which compilation is so effective. In general, each processor offers a set of instructions which define the manner in which the processor can be operated. The instructions form at least part of the ISA of the processor. It will be appreciated that the ISA may be considered to include various constructs associated with the instructions, such as registers, addressing modes, opcodes, memory structures, and the like, as well as various combinations thereof. The ISA enables the processor to execute simple instructions, such as reading\/writing values from\/to memory, perform logical or arithmetical operations on registers, handle interruption, and the like. This basic behaviour has remained essentially unchanged over time, and modern processors achieve exceptional performances because they can efficiently exploit great numbers of resources, and, thus, are able to complete a much larger number of such basic instructions in approximately the same amount of time. Furthermore, even higher performances may be reached from the use of co-processors (e.g., floating-point co-processors, graphical co-processors, and the like), which can help the main processor by hard-coding complex operations.","The use of debugging in computer science allows monitoring and verification of the software development and execution process. In general, software development is a long and difficult process, which is strictly monitored and verified to assure that the final product is free of defaults, or \u201cbugs\u201d are they are usually called. In order to help test software programs, the software development flow provides many powerful debug features. For example, common software development flow debug features include step-by-step execution; observability\/controllability of all registers and memory locations, use of breakpoints and watchpoints, and the like. These debug features, as well as various other debug features, are more often enabled by algorithms and structures embedded into the final code by the software compiler, but may also be assisted by hardware resources available inside of the processor. From this information the debugger can reconstruct the original code and correlate all the ISA-level operations to the programming abstraction layer.","The use of automated test execution capabilities and computer science software capabilities together to enable improved system testing capabilities may be better understood by way of reference to  and .",{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 2","FIG. 1"]},"As depicted in , the TS  includes a test generation tool (TGT)  and a software compiler (SC) .","The TGT  includes a TGT composer  and TGT algorithms .","The TGT composer  accepts system description files  as input. The system description files  include any suitable description files which may be used by a TGT to produce testing instructions\/vectors for testing a system under test. For example, system description files  may include circuit description files, board\/fixture netlist files, other description files, and the like, as well as various combinations thereof. The system description files  may be available on TGT  and\/or may be obtained from one or more remote components and\/or systems.","The system description files  may include one or more circuit description files, The circuit description files may be specified using any suitable description language(s), such as the Boundary Scan Description Language (BSDL, which was developed as part of the IEEE 1149.1 standard for board-level JTAG), the Hierarchical Scan Description Language (HSDL, which was developed as an extension of BSDL), New Scan Description Language (NSDL), and the like, as well as various combinations thereof.","The system description files  may include one or more board\/fixture netlist files, The board\/fixture netlist files may include files related to the physical description of the device(s), describing the netlist, connections, and like information. The board\/fixture netlist files may be specified in any suitable format, such as PCB, Gerber, and\/or any other format suitable for board\/fixture netlist files.","The system description files  may include one or more other description files. The other description files may include any other suitable description files which may be used as input for producing a circuit model. For example, other description files may include any suitable application-specific and\/or tool-specific description language files, such as Asset's Macro Language, Goepel's CASLAN Language, and\/or any other suitable description language files.","The TGT composer  processes the system description files  to produce a circuit model . The processing of system description files  by TGT composer  to produce circuit model  may be performed in any suitable manner. The circuit model  specifies a model of the system under test or portion of the system under test for which TGT  is being run. The TGT composer  provides circuit model  to TGT algorithms .","The TGT algorithms  accept circuit model . The TGT algorithms  process the circuit model  to produce TGT atomic test operations . The processing of circuit model  by TGT algorithms  to produce the TGT atomic test operations  may be performed in any suitable manner.","The SC  includes SC front-end algorithms  and SC back-end algorithms .","The SC front-end algorithms  accept computer science source files  as input. The computer science source files  include any suitable computer science source files which may be compiled by a compiler. For example, computer science source files  may include computer science source files for any suitable computer programming language(s), such as C++, Java, Python, and the like, as well as various combinations thereof. For example, computer science source files  may include one or more of one or more C files, one or more C++ files, and\/or any other suitable computer science source files.","The SC front-end algorithms  process the computer science source files  to produce a program model . The program model  specifies an intermediate representation of the computer science source files . The SC front-end algorithms  provide the program model  to the SC back-end algorithms .","The SC back-end algorithms  accept program model  as input. The SC back-end algorithms  process the program model  to produce one or more ISA Binary Files  including ISA atomic operations . The processing of program model  by the SC back-end algorithms  to form the ISA Binary Files  including the ISA atomic operations  may be performed in any suitable manner. The ISA atomic operations  are assembly-level instructions supported by the processor for which the TISA is implemented.","As depicted in , in addition to the respective processing flows of TGT  and SC , additional interaction between TGT  and SC  may be utilized for controlling generation of the TISA atomic operations . In one embodiment, SC back-end algorithms  may initiate one or more vector computation requests  to TGT algorithms . The SC back-end algorithms  may initiate a vector computation request  when the SC back-end algorithms  need to access the TAP. The TGT algorithms , upon receiving a vector computation request  from SC back-end algorithms , generate one or more TGT atomic test operations  for the TAP based on the received vector computation request . The one or more TGT atomic test operations  may then be applied to the TAP in a manner controlled by SC back-end algorithms , because the TGT atomic test operations  are combined with the ISA atomic operations  to enable algorithmic control over TGT atomic test operations  using ISA atomic operations . In this manner, the SC  provides algorithmic control of access to the TAP.","As depicted in , in addition to TGT  and SC , TS  further includes a TISA composer . The TISA composer  accepts the TGT atomic test operations  and the ISA atomic operations . The TISA composer  converts the TGT atomic test operations  into TISA instructions and inserts the TISA instructions into the ISA Binary File(s)  (i.e., combining the TISA instructions with the ISA atomic operations  to form thereby TISA Binary files  including TISA atomic operations ). The TISA composer  may be part of TGT , part of SC , split across TGT  and SC , implemented separate from TGT  and SC , and the like.","It will be appreciated that the various inputs and outputs depicted and described with respect to  may be stored, displayed, executed, propagated, and\/or handled in any other suitable manner, as well as various combinations thereof.",{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 3","FIG. 1"]},"As depicted in , TS  of  operates in a manner similar to TS  of , in that TISA Binary files including TISA atomic operations are generated using interaction between the test generation tool and the software compiler; however, interaction between the test generation tool and the software compiler in TS  of  is different than interaction between the test generation tool and the software compiler in TS  of .","As depicted in , the TS  includes a test generation tool (TGT)  and a software compiler (SC) .","The TGT  includes a TGT composer  and TGT algorithms .","The TGT composer  accepts system description files  as input. The system description files  include any suitable description files which may be used by a TGT to produce testing instructions\/vectors for testing a system under test. For example, system description files  may include circuit description files, board\/fixture netlist files, other description files, and the like, as well as various combinations thereof. The system description files  of  may include system description files similar to system description files  depicted and described with respect to  (e.g., one or more circuit description files, one or more board\/fixture netlist files, one or more other description files, and the like, as well as various combinations thereof). The system description files  may be available on TGT  and\/or obtained from one or more remote components and\/or systems.","The TGT composer  accepts one or more test operation description files -(collectively, test operation description files ) as input. The test operation description files  are generated by SC . The generation of test operation description files  by SC  is described in detail hereinbelow.","The TGT composer  processes the system description files  and the test operation description files  to produce a circuit model . The processing of system description files  by TGT composer  to produce circuit model  may be performed in any suitable manner. The circuit model  specifies a model of the system under test or portion of the system under test for which TGT  is being run. The processing of system description files  in conjunction with test operation description files  enables the TGT composer  to produce circuit model  in a manner for enabling TGT  to produce appropriate TAP atomic operations. The TGT composer  provides circuit model  to TGT algorithms .","The TGT algorithms  accept circuit model . The TGT algorithms  process the circuit model  to produce TGT atomic test operations . The processing of circuit model  by TGT algorithms  to produce the TGT atomic test operations  may be performed in any suitable manner.","As depicted in , in addition to TGT  and SC , TS  includes a TISA translator . The TISA translator  receives the TGT atomic test operations . The TISA translator  translates TGT atomic test operations  to form TISA atomic test operations . The TISA translator  provides TISA atomic test operations  to SC  for inclusion in the software compilation process. The use of TISA atomic test operations  by SC  is described in detail hereinbelow. The TISA translator  may be part of TGT , part of SC , split across TGT  and SC , implemented separate from TGT  and SC , and the like.","The SC  includes a SC pre-compiler , SC front-end algorithms , and SC back-end algorithms .","The SC pre-compiler  accepts computer science source files .","The computer science source files  include any suitable computer programming source files which may be compiled by a compiler. For example, computer science source files  may include computer programming source files for any suitable computer programming language(s), such as C++, Java, Python, and the like, as well as various combinations thereof. For example, computer science source files  may include one or more of one or more C files, one or more C++files, and\/or any other suitable computer science source files.","The SC pre-compiler  processes the computer science source files .","The SC pre-compiler  processes the computer science source files , producing therefrom pre-processed computer science source files . The computer science source files  may be pre-processed by SC pre-compiler  to form pre-processed computer science source files in any suitable manner. The SC pre-compiler  provides the pre-processed computer science source files to SC front-end algorithms .","The SC pre-compiler  detects test operations during processing of the computer science source files , and generates the test operation description files . The test operation description files  may be specified using any suitable test description language (e.g., using one or more standard test description languages, using a test description language specific to the TGT , and the like, as well as various combinations thereof). The SC pre-compiler  provides the test operation description files  to TGT  (illustratively, to the TGT composer  of TGT , which processes the test operation description files  in conjunction with the system description files  to produce circuit model ).","The SC front-end algorithms  accept pre-processed computer science source files . The SC front-end algorithms  also accept the TISA atomic test operations , which are produced by TISA translator  using TGT atomic test operations  produced by TGT  from the test operation description files . The SC front-end algorithms  compile the pre-processed computer science source files and TISA atomic test operations  to produce a program model . The program model  specifies an intermediate representation of the pre-processed computer science source files , which includes TISA atomic test operations  such that TISA atomic test operations  may be integrated within the ISA atomic operations to form TISA atomic operations. The SC front-end algorithms  provide the program model  to the SC back-end algorithms .","The SC back-end algorithms  accept program model . The SC back-end algorithms  process program model  to produce one or more TISA Binary Files  including TISA atomic operations . The processing of program model  by the SC back-end algorithms  to form the TISA Binary Files  including the TISA atomic operations  may be performed in any suitable manner.","The TISA atomic operations  include ISA atomic operations (i.e., assembly-level instructions supported by the processor for which the TISA is implemented) and TISA atomic test operations .","The TISA atomic operations  provide algorithmic control (using ISA atomic operations) over TGT atomic test operations  (i.e., in the form of the TISA atomic test operations ), thereby enabling improved system testing of the system under test to which the TISA atomic operations  are to be applied. Thus, the TGT atomic test operations  (i.e., in the form of the TISA atomic test operations ) may be applied to the TAP in a manner controlled by SC back-end algorithms , because the TGT atomic test operations  are combined with the ISA atomic operations to enable algorithmic control over TGT atomic test operations  using the ISA atomic operations. In this manner, the SC  provides algorithmic control of access to the TAP.","It will be appreciated that the various inputs and outputs depicted and described with respect to  may be stored, displayed, executed, propagated, and\/or handled in any other suitable manner, as well as various combinations thereof.","With respect to  and , although primarily depicted and described with respect to specific numbers of input fifes, intermediate files, models, output files, and the like, it will be appreciated that the embodiments of  and , as well as various associated teachings provided herein, may be implemented using any suitable numbers of input files, intermediate files, models, output files, and the like.",{"@attributes":{"id":"p-0098","num":"0097"},"figref":["FIG. 2","FIG. 3","FIG. 2","FIG. 3"]},"Referring to , it will be appreciated that the capabilities and features of the TISA are defined by its abstraction level, i.e., the finer the definition of the TISA atomic operations, the better performance the TISA will provide.","In one embodiment, in which TISA is implemented in a JTAG architecture, three abstraction levels may be supported for scan operations.","The first abstraction level is the Vector Level. The Vector Level is the coarsest grain of the three abstraction levels, where the atomic operations are inputs and outputs of scan vectors. The Vector Level is best represented in a vector format, such as Serial Vector format (SVF) or any other suitable vector format, and gives the highest-level control.","The second abstraction level is the TAP Level. In the TAP Level, the atomic operations are enhanced to allow full control over the TAP state machine. This enables more refined control over scan operations, support of non-standard sequences (e.g., like the ones required, for instance, in the Addressable Shadow Protocol or other similar protocols).","The third abstraction level is the Scan Segments Level. The Scan Segments Level is the finest grain of the three abstraction levels. The Vector Level and TAP Level abstraction levels use the scan vector as the atomic data format, which is sufficient for traditional continuity tests where the entire scan chain is involved, but is cumbersome for instrument-based testing where there is a need for fine-grain control over the tens or hundreds of instruments that compose the scan chain. The Scan Segments Level allows the definition of \u201cscan segments\u201d inside the overall scan path, which can be handled separately, thereby providing a flexible and powerful set of primitives that can be used to define scan operations directly in the problem space and resolve the scan operations at implementation time. This approach is advantageous in embedded applications, where the available computational resources may be quite limited. The use of Scan Segments Level is depicted and described in additional detail hereinbelow.","As depicted in  and , regardless of the abstraction level of the scan operations, the resulting TAP atomic operations (illustratively, TGT atomic test operations  and TGT atomic test operations ) computed by the TGT are converted into corresponding TISA atomic test operations and inserted into the binary executable (i.e., into the ISA atomic operations generated by the SC).","Referring to , TGT atomic test operations  and ISA atomic operations  can be processed to form the TISA atomic operations  in the TISA binary executables (illustratively, TISA binary files ). The TISA atomic operations  include TISA atomic test operations and ISA atomic operations.","Referring to , TISA atomic test operations  (generated by TISA translator  from TGT atomic test operations  produced by TGT ) can be input into the SC front-end algorithms  as pre-compiled assembly instructions, without any need to modify the SC front-end algorithms  of SC . It will be appreciated that almost all programming languages allow for such operations. In C, for example, this operation is obtained using the \u201casm\u201d command. In one embodiment, minor modifications to SC back-end algorithms  may be required (e.g., to handle binary conversion of the TISA assembler instructions). An example of such a process is depicted and described herein with respect to .","Although primarily depicted and described with respect to levels of granularity of TISA atomic operations in a JTAG architecture, it will be appreciated by one skilled in the art that the same levels of granularity of TISA atomic operations may be utilized in other architectures, that different levels of granularity of TISA atomic operations may be utilized in a JTAG architecture and\/or other architectures, and the like, as well as various combinations thereof.","As described hereinabove, the TISA may be implemented using any suitable instruction set architecture (ISA). For example, the TISA may be implemented using the SPARC V8 ISA, an INTEL ISA, and the like.","For purposes of clarity in describing implementation of the TISA, an exemplary implementation of the TISA using a SPARC V8 ISA is depicted and described herein with respect to . In this exemplary implementation, the TISA is implemented as a Vector Level TISA, which allows direct coding of the instructions that compose the SVF format; however, as described hereinabove, it will be appreciated that implementation of the TISA using the SPARC V8 ISA also may be performed where the TISA is implemented as a TAP Level TISA or a Scan Segment Level TISA.","The SPARC V8 ISA is implemented in many products, such as the open-source soft processor family Leon 2 and Leon 3.","A review of \u201cThe SPARC Architecture Manual Version 8,\u201d published by SPARC International, Inc, 1992 (hereinafter \u201cSPARC Architecture Manual\u201d), reveals that there are many code words not exploited by the SPARC V8 ISA. This is evident at least from a review of the \u201copcodes and condition codes\u201d of Appendix F.",{"@attributes":{"id":"p-0112","num":"0111"},"figref":["FIG. 4A","FIG. 4A"]},{"@attributes":{"id":"p-0113","num":"0112"},"figref":["FIG. 4B","FIG. 4B"],"b":["30","25","21","18","17","14"]},{"@attributes":{"id":"p-0114","num":"0113"},"figref":["FIG. 4C","FIG. 4B"],"b":["21","18"]},"The SVF instructions allow for multiple parameters, which need to be coded inside the final code. In order to represent the parameters, and in the interest of the usual architectural best practice of keeping instruction and data separated, register-based parameter passing is defined for this exemplary implementation of a Vector Level TISA. Thus, the Vector Level TISA presents six dedicated 32-bit registers: GENERIC1, GENERIC2, TDI, TDO, MASK and SMASK. The six dedicated 32-bit registers are depicted in . The usage of the six dedicated 32-bit registers is described in detail hereinbelow, but, as a general rule, these registers are used either to store a parameter or to point to the memory location in which a parameter is stored. Thus, at compilation time, normal ISA instructions can be used to load these registers before the TISA instruction is invoked. More specifically, in this SPARC V8 ISA implementation of the TISA, coprocessor registers may be used directly as parameters for the usual load\/store instructions.","The SVF instructions which may be utilized in this SPARC V8 ISA implementation of the TISA include ENDDR, ENDIR, STATE, FREQUENCY, PIO, PIOMAP, HDR, HIR, TDR, TIR, SDR, SIR, and RUNTEST. These SVF instructions may be better understood by way of reference to the \u201cSerial Vector Format Specification,\u201d by ASSET InterTech, Inc., 1997 (hereinafter referred to as the SVF Manual), which is herein incorporated by reference in its entirety. The use of these SVF instructions in this SPARC V8 ISA implementation of the TISA is described in more detail hereinbelow.","ENDDR, ENDIR, STATE","The ENDDR and ENDIR instructions indicate the TAP state at which the TAP interface ends its operation. The STATE instruction forces the TAP interface to a specified state. In this exemplary implementation of the TISA, the SVF codings for the ENDDR, ENDIR, and STATE instructions are \u201c000000\u201d, \u201c000001\u201d, and \u201c000010\u201d, respectively, as depicted in . The SVF coding of these SVF instructions may be performed using the \u201cTAP STATE\u201d file (i.e., the exemplary bit coding of the TAP states as depicted in ) as needed. It will be appreciated, at least from a review of the SVF Manual, that the STATE instruction can optionally take the explicit sequence of states as parameters. In this exemplary implementation of the TISA, taking the explicit sequence of states as parameters would be coded by a series of instructions, one for each state in the sequence.","FREQUENCY","The FREQUENCY instruction is used to specify the working frequency of the TAP interface. The FREQUENCY instruction is expressed as a 32-bit integer of Hz cycles. In this exemplary implementation of the TISA, the SVF coding for the FREQUENCY instruction is \u201c000011\u201d, as depicted in . The value for the FREQUENCY instruction is stored in the GENERIC1 register.","PIO, PIOMAP","The PIO instruction can be used to handle parallel vectors, in a format previously set by a call to PIOMAP. In this exemplary implementation of the RISA, PIOMAP is seen as a pre-processor directive that generates the appropriate commands to set up the TAP interface. Thus, the PIO instruction merely needs to express the parallel vector, which can be expressed by indicating (in the GENERIC1 register) the address in which the parallel vector is stored. The number of words \u201cn\u201d that compose the vector is specified in bits - of the instruction, and, thus, the vector has an upper size limit of 2=8K words=32 Kbytes. If the vector size is not an exact multiple of a word, padding and re-alignment may be provided in memory, as needed. In this exemplary implementation of the TISA, the SVF coding for the PIO instruction is \u201c000100\u201d.","HDR, HIR, TDR, TIR","The roles of the HDR, HIR, TDR, and TIR instructions are different. Here, these SVF instructions are considered together because (1) these SVF instructions are functionally similar (i.e., they all command shift operations, even if they are of a different nature), and (2) these SVF instructions accept the same parameters:","(1) length: a 32-bit number expressing the number of bits to shift;","(2) TDI (optional): the input shift vector;","(3) TDO (optional): the expected output shift vector;","(4) MASK (optional): a mask to be used when comparing actual values with TDO. A \u20181\u2019 indicated a care, a \u20180\u2019 a don't care; and","(5) SMASK (optional): a mask to mark which bits are to be considered in TDI. \u20181\u2019 indicates a care, \u20180\u2019 a don't care.","In this exemplary implementation of the TISA, the SVF codings for the HDR, HIR, TDR, and TIR instructions are \u201c000110\u201d, \u201c000111\u201d, \u201c001010\u201d, and \u201c001011\u201d, respectively, as depicted in .","In this exemplary implementation of the TISA, the following additional codings may be used:","(1) length is stored in the GENERIC1 register;","(2) O1 is \u20181\u2019 when TDI is present, \u20180\u2019 otherwise. If set, the TDI register contains the address at which the input vector is stored;","(3) O2 is \u20181\u2019 when TDO is present, \u20180\u2019 otherwise. If set, the TDO register contains the address at which the expected output is stored;","(4) O3 is \u20181\u2019 when MASK is present, \u20180\u2019 otherwise. If set, the MASK register contains the address at which the output mask is stored; and","(5) O4 is \u20181\u2019 when SMASK is present, \u20180\u2019 otherwise. If set, the SMASK register contains the address at which the output mask is stored.","SDR, SIR","The SDR and SIR instructions have the same syntax as the HDR, HIR, TDR, and TIR instructions, but have a functional difference: SDR and SIR trigger the actual scan operation on the TAP. In interactive testing the actual output vector read from the system is fundamental for the algorithm, so the TISA offers the possibility of storing the actual output vector in memory. When the \u201cTAP STATE\u201d field (bits -, as depicted in ) is different than zero, the GENERIC2 register indicates the storage location of the actual output vector. Thus, SDR and SIR can support a maximum of seven parameters. If TDO is specified and the actual output vector is different from the expected output vector, an overflow flag is set in the Processor State Register (PSR), as described in Section 4.2 of the SPARC Architecture Manual.","RUNTEST","The RUNTEST instruction forces the TAP interface to run a test at a specified state for a specified amount of time, and is used mainly to control RUNBIST operations (e.g., as defined in IEEE 1149.1). The RUNTEST instruction accepts one or more of the following parameters (all of which are optional):","(1) run_state: the state the interface must maintain during test execution;","(2) run_count: the number of clock cycles the test must take;","(3) run_clk: which clock run_count refers to (TCK: TAP clock, SCK: system clock);","(4) min_time: minimum run time in seconds, expressed as a real number;","(5) max_time: maximum run time in seconds, expressed as a real number; and","(6) endstate: the state the interface must reach at the end of the command.","In this exemplary implementation of the TISA, the SVF coding for the RUNTEST instruction may be \u201c000101\u201d or \u201c100101\u201d.","In this exemplary implementation of the TISA, the following additional codings may be used:","(1) TAP_STATE: it contains run_state of which it is defined;","(2) O1: \u20181\u2019 if TAP_STATE is defined, \u20180\u2019 otherwise;","(3) O2: \u20181\u2019 if min_count is specified, \u20180\u2019 otherwise. If set, the GENERIC1 register contains the 32-bit unsigned representation of min_count;","(4) O3: \u20181\u2019 if max time is set, \u20180\u2019 otherwise. If set, the GENERIC2 register contains the 32-bit unsigned representation of max count;","(5) O4: \u20181\u2019 if endstate is set, \u20180\u2019 otherwise. If set, Bits - contain the end state.","(6) Bits -: if run_count is specified, expressed as an unsigned integer (max run_count=2=1024). If this field is not \u201c0\u201d, then Bit  indicates run_clock (\u20181\u2019=TCK, \u20180\u2019=SCK).","Although primarily depicted and described herein with respect to use of specific SVF instructions in this SPARC V8 ISA implementation of the TISA (i.e., namely, ENDDR, ENDIR, STATE, FREQUENCY, PIO, PIOMAP, HDR, HIR, TDR, TIR, SDR, SIR, and RUNTEST), it will be appreciated that fewer or more SVF instructions may be used.","Although primarily depicted and described herein with respect to an implementation of the TISA using the SPARC V8 ISA, it will be appreciated that various other ISAs may be utilized to implement a TISA in accordance with the TISA teachings depicted and described herein.","In interactive testing approaches, the data handoff point is quite important. As described hereinabove, a test program is composed of two main portions: the algorithmic portion (as represented by the software compiler) and the test access portion (as represented by the test generation tool). During a test operation using a testing program, there will be moments when the test program is accessing the system under test, and moments when the test program is examining the testing results and deciding the next step(s) required. The hand-off between these two operations is important for obtaining efficient interactive testing.","In existing script-based approaches, such as SVF and STAPL, a script takes care of all TAP operations at the Vector Level. At this level, the interface (or \u201cplayer\u201d) is able to communicate with the TAP protocol, and send\/receive vectors to\/from the system under test. Furthermore, STAPL also allows some basic flow control (if-then-else) and algorithmic operations on the bit vectors. If there is need for more sophisticated processing (e.g., identifying a register inside a received vector, or computing the vector to access a specific device), the player hands control over to the algorithmic portion. In STAPL, this is done through the \u201cexport\u201d command. Disadvantageously, however, neither SVF nor STAPL has a standardized format for this (e.g., in the case of STAPL, the handoff process is usually proprietary to a given vendor).","In existing embedded approaches, like Master Test Controller (MTC) from Ericsson and the System BIST Processor, the same partitioning between the algorithmic portion and the test access portion is used. In such embedded approaches, the algorithmic portion and the test access portion are executed by different coprocessors that must be programmed separately. Furthermore, the memory spaces of the algorithmic portion and the test access portion are physically different, such that the resulting handoff mechanisms are similar to the handoff mechanisms of STAPL. The result is that the coprocessor for the test access portion is forced to store a lot of scan operations before handoff to the algorithmic portion, which, given the increasing size of scan chains, may require a huge amount of resources.","In contrast with existing approaches to integrated testing (e.g., script-based approaches such as SVF and STAPL, and embedded approaches such as MTC and System BIST Processor), the TISA integrates the test access portion (i.e. the test operations) inside the algorithmic portion (i.e., the classical ISA), such that the test access portion and the algorithmic portion share the same physical memory space, thereby making handoff (and, thus, data passing) between the test access portion and the algorithmic portion automatic. In TISA, handoff between the test access portion and the algorithmic portion is made at the instruction level, such that the processor can freely mix scan and algorithm (i.e., freely mix test operations and algorithmic operations) as required according to the associated scheduling strategy.","In this exemplary implementation of the TISA, using the SPARC V8 ISA, all operations handling vectors use absolute addressing (as described hereinabove with respect to the SVF instructions). As a result, testing vectors may be used like normal variables inside the ISA program, thereby making the interface between the test access portion and the algorithmic portion automatic. As an example, based on the exemplary implementation of the TISA using the SPARC V8 ISA as described hereinabove, the following steps exemplify an archetypical testing sequence:","(1) An SDR instruction is used to obtain testing output data from the system under test. The resulting output data is placed in a specific memory location (e.g., the \u201cactual\u201d parameter in the GENERIC2 register);","(2) A classical LOAD instruction can transfer this output data to be loaded into a register;","(3) Once the output data is loaded in the register, arithmetic operations and\/or logical operations may be used to process the output data (note that since the SPARC V8 ISA is a load\/store architecture, all data must be loaded into a register before being handled);","(4) A classical STORE instruction is used to transfer the result of the algorithm into memory; and","(5) An SDR instruction can send new testing input data to the TAP (e.g., using the \u201cTDI\u201d parameter in the TDI register).","Note that the classical algorithmic operations (2) through (4) are standard for any ISA algorithm implementation, and are not modified in any way by the TISA.","Thus, from this simple example, it is clear that TISA can be supported using any given algorithm or computer program, with a natural and efficient hand-off between the algorithmic portion and the test access portion.","In this exemplary implementation of the TISA, using the SPARC V8 ISA, absolute addressing is used (for purposes of clarity in describing the TISA); however, one skilled in the art and informed by the teachings herein would be able to modify this exemplary implementation of the TISA to support all legal SPARC V8 addressing modes described in the SPARC Architecture Manual.","Although primarily depicted and described herein with respect to an exemplary implementation of the TISA in which SVF is used, SVF was used in the exemplary implementation because it is a well-known format proven to provide a complete, even if basic, handling of 1149.1 TAPs. It will be appreciated, by one skilled in the art and informed by the teachings herein, that the TISA may be implemented using any other suitable control formats, many of which may allow finer grain control of the TAP state machine and support more sophisticated testing operations.","Although primarily depicted and described herein with respect to an exemplary implementation of the TISA in which the abstraction level is the Vector Level, it will be appreciated, by one skilled in the art and informed by the teachings herein, that the exemplary TISA implementation depicted and described herein may be modified such that the abstraction level of the TISA is the TAP Level or the Scan Segment Level.","For purposes of clarity in describing the TISA, an exemplary use of the TISA to perform testing on an exemplary system under test is depicted and described herein with respect to . In this exemplary use of the TISA, the TISA is implemented as a Vector Level TISA using a SPARC V8 ISA and SVF (i.e., in continuation of the exemplary implementation depicted and described with respect to ).",{"@attributes":{"id":"p-0173","num":"0172"},"figref":"FIGS. 5A and 5B"},{"@attributes":{"id":"p-0174","num":"0173"},"figref":"FIG. 5A","b":["500","510","520"]},"The JTAG TAP  provides test access to a system under test . The JTAG TAP  provides test access to the system under test , for sending input data to system under test  and receiving output data from system under test . The JTAG TAP  includes an instruction register (IR) , which is an 8-bit instruction register.","The JTAG TAP  is controlled by a testing system (e.g., such as testing system  depicted and described with respect to , which is omitted for purposes of clarity).","The system under test  includes a first board  (denoted as B) and a second board  (denoted as B). The first board  includes a transmitter  (denoted as T). The second board  includes a receiver  (denoted as R). The transmitter  sends data, on a connection , to receiver . In this example, the connection  is an 8-bit connection.","As depicted in , each board is accessible from JTAG TAP  via its own scan chain. Namely, first board  is accessible via a first scan chain  and second board  is accessible via a second scan chain . The first scan chain  and second scan chain  are selectable by the IR  of JTAG TAP  (e.g., IR=0 selects first board B, IR=1 selects second board B). The transmitter  and the receiver  are not alone on their boards; rather, they are part of wider scan chains (e.g., for purposes of this example, 24 bits and 16 bits, respectively).","In a test program, input data is sent to transmitter  via the first scan chain , and the resulting output data is collected from the receiver  by exploiting the second scan chain . In order to perform an exhaustive test, all possible values are sent through the connection , such that 2=256 vectors are sent through the connection . Using C, an exemplary program could be the following:",{"@attributes":{"id":"p-0180","num":"0179"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u20021","include <stdio.h>"]},{"entry":["\u20022","include <jtag.h>"]},{"entry":["\u20023",{}]},{"entry":["\u20024","char sent_value, received value;"]},{"entry":["\u20025",{}]},{"entry":["\u20026","define MAX_COUNT 256;"]},{"entry":["\u20027",{}]},{"entry":["\u20028","void main(void)"]},{"entry":["\u20029","{"]},{"entry":["10","\u2003for (sent_value=0;sent_value<MAX_COUNT;sent_value++)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["11","{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["12","apply_JTAG(sent_value,B1.T);"]},{"entry":["13","read_JTAG (received_value,B2.R);"]},{"entry":["14","\u2002if (sent_value != received value) exit (0);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["15","}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["16","\u2003exit(1);"]},{"entry":["17","}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In this program, line  includes the C module that is handling JTAG operations, where the functions \u201capply_JTAG\u201d and \u201cRead_JTAG\u201d, used in lines  and , respectively, are defined. The SC pre-compiler  of SC  recognizes these functions, and generates test operation description files  for TGT . The format of the test operation description files  may vary, depending on the actual implementation of first board  and second board . For example, if first board  and second board  both are IJTAG compliant, test operation description files  could be specified, for example, using New Scan Description Language (NSDL) code. The TGT , using test operation description files , generates TGT atomic test operations , which are translated, by TISA translator , into TISA atomic test operations . The TISA atomic test operations  are provided to SC front-end algorithms  of SC . The TGT atomic test operations , the associated TISA atomic test operations , and the resulting TISA binary code are depicted in .",{"@attributes":{"id":"p-0182","num":"0181"},"figref":["FIG. 5B","FIG. 5A"],"b":"500"},"As depicted in , the mapping from C commands to TISA coding is represented using a table  having four columns: a \u201cC command\u201d column , an \u201cSVF instructions\u201d column , a \u201cTISA assembler\u201d column , and a \u201cTISA coding\u201d column . The table , from left to right, illustrates the manner in which a C command can be translated into an SVF instruction, which can be translated into TISA assembler, which can be coded into TISA binary coding.","The Apply_JTAG(value,B1.T) command is translated into two SVF instructions: SIR 8 TDI(00) and SDR 24 TDI (value).","The SIR 8 TDI (00) SVF instruction is translated into TISA assembler as three operations:\n\n","The SDR 24 TDI (value) SVF instruction is translated into TISA assembler as three operations:\n\n","The Read_JTAG (value,B2.R) command is translated into two SVF instructions: SIR 8 TDI (01) and SDR 16 ACTUAL (value).","The SIR 8 TDI (01) SVF instruction is translated into TISA assembler as three operations:\n\n","The SDR 16 ACTUAL (value) SVF instruction is translated into TISA assembler as three operations:\n\n","The TISA coding of the SET operations is not specified because the SPARC V8 Manual identifies them as \u201cpseudo-instructions\u201d which can have a different coding following the implementation of the processor.","Using the determined TISA codings, the SC pre-compiler  may now substitute the high-level JTAG accesses with their associated TISA assembler instructions. The result is the following code, specified using C, in which the calls to the JTAG TAP have been replaced by the associated TISA assembler coding:",{"@attributes":{"id":"p-0192","num":"0203"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u20021","include <stdio.h>"]},{"entry":["\u20022","include <jtag.h>"]},{"entry":["\u20023",{}]},{"entry":["\u20024","char sent_value, received value;"]},{"entry":["\u20025",{}]},{"entry":["\u20026","define MAX_COUNT 256;"]},{"entry":["\u20027",{}]},{"entry":["\u20028","void main(void)"]},{"entry":["\u20029","{"]},{"entry":["10","\u2002for (sent_value=0;sent_value<MAX_COUNT;sent_value++)"]},{"entry":["11","\u2003{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["12","asm volatile (\u2033SET 8, %cGENERIC1;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["13","SET 00, %cTDI;"]},{"entry":["14","SIR TDI;"]},{"entry":["15","SET 24, %cGENERIC1;"]},{"entry":["16","SET &sent_value, %cTDI;"]},{"entry":["17","SDR TDI;\u201d);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["18","asm volatile (\u2033SET 8, %cGENERIC1;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["19","SET 01, %cTDI;"]},{"entry":["20","SIR TDI;"]},{"entry":["21","\u2002SET 16, %cGENERIC1;"]},{"entry":["22","\u2002SET &received_value, %cGENERIC2;"]},{"entry":["23","\u2002SDR ACTUAL\u201c);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["24","\u2002if (sent_value != received value) exit (0);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["25","\u2003}"]},{"entry":["26","\u2002exit(1);"]},{"entry":["27","}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"This code can be input into the front-end algorithms , which will generate the program model . The program model  can be input into the back-end algorithms , which will generate the executable TISA binary file(s)  including the TISA atomic operations .","The \u201cTISA coding\u201d column  of table  depicts the binary coding of the TISA assembler instructions (e.g., using the various rules defined with respect to the exemplary implementation of the TISA using a SPARC V8 ISA, as depicted and described with respect to ).","As described herein, the TISA provides complete freedom regarding test granularity in performing testing of a system under test (i.e., from TAP Level through Scan Segment Level). As depicted in  and , and further explained using the exemplary TISA implementation of  and , test patterns may be computed using explicit queries by the Software Compiler to the Test Generation Tool, such that the only limit for the software algorithm is the resolution of the queries themselves.","As an example, at a coarse level, queries from the SC to the TGT may involve the entire scan chain of the system under test (e.g., such as in classical BSDL-based Boundary Scan testing).","As an example, at a fine level, queries from the SC to the TGT may involve registers or even bits. For example, dedicated Scan Segment primitives could significantly accelerate instrument access and TAP reconfiguration, boost code reuse, and provide various other advantages.","As an example, at a middle level somewhere between the coarse and fine levels, queries from the SC to the TGT may be done functionally (e.g., using standards such as IJTAG and other suitable standards, and using description languages such as NSDL and other suitable object-oriented description languages).","In this manner, the TISA does not force device\/register access to be resolved at the model space (i.e., in the TGT), but, rather, allows developers to handle device\/register access at the problem space (i.e., in the SC), thereby enabling developers to adapt the analysis grain to their needs and to the available resources.","Furthermore, in embodiments in which the TISA processor has sufficient resources, e.g., such as in the case of Automated Test Equipment (ATE), at least a portion of the circuit model may be implemented within the program model, thereby enabling the TISA machine to directly compute the vector patterns.","Furthermore, the TISA enables support for various other system test capabilities not previously possible without TISA, such as interactive testing including interactive debugging (locally and\/or remotely), concurrency, portability, and the like, as well as various combinations thereof. These additional capabilities are now addressed in additional detail.",{"@attributes":{"id":"p-0202","num":"0213"},"figref":"FIG. 6"},"As depicted in , TISA-based testing environment  includes a host computer (HC) , a testing system (TS) , and a system under test (SUT) .","The HC  is configured to control TS  for controlling testing of SUT . The HC  includes a processor  coupled to a memory . The processor  and memory  may be any suitable processor and memory.","The memory  stores one or more debugger control programs . The debugger control program(s) enable HC  to trace and, where desired or necessary, alter, the execution of computer program(s) running on TS . For example, debugger control program(s)  may include one or more of the GNU Debugger (GDB), the dbx debugger, the Perl debugger, the Bash debugger, the Python debugger, and like suitable debugger programs, as well as various combinations thereof.","The memory  also may store one or more debugger display programs . The debugger display program(s) enable HC  to display information associated with the debugger control program(s) . The information associated with debugger control program(s)  may be displayed by debugger display program(s)  in any suitable manner (e.g., using one or more display devices). For example, debugger display program(s)  may include one or more of Insight (which is a graphical user interface to GDB), the Data Display Debugger (DDD, which provides a graphical user interface for various command-line debuggers, such as GDB and others), and like suitable debugger display programs, as well as various combinations thereof.","The TS  is controlled by HC  for purposes of testing SUT . The TS  is configured to function in a manner consistent with the TISA (e.g., such as depicted and described with respect to TS  of . ) and, further, is configured to support interactive testing (e.g., by enabling access by debuggers running on HC ).","The TS  includes a TISA processor  coupled to a memory . The TISA processor  may be implemented using any suitable processor, such as SPARC V8 (as depicted and described hereinabove with respect to  and ), INTEL, and the like. The memory  may be any suitable memory.","The memory  stores one or more debugger program stub(s) . The debugger program stub(s)  understand the debugger protocol of the corresponding debugger control program(s)  running on HC , thereby enabling HC  to communicate with TS . For example, debugger program stub(s)  may include one or more of GDB stub, a DBX stub, a Perl stub, a Bash stub, a Python stub, and like suitable debugger program stubs, as well as various combinations thereof.","The memory  stores TISA Binary Files . The TISA Binary Files  are generated by TS  in a manner as depicted and described herein with respect to  and . The TISA Binary Files  are executed by TISA processor  to perform testing on SUT .","The TS  also includes a Test Access Port (TAP)  coupled to TISA processor . The TAP  provides a test interface between TISA processor  and SUT  for enabling TISA processor  to perform testing of SUT  while being controlled by HC . The TAP  may be any suitable TAP (e.g., an 1149.1 TAP).","The TISA processor  interfaces with TAP  using an interface . The interface  may be any suitable interface between a TAP and a system under test (e.g., such as an interface that supports TCK, TMS, TDI, TDO, and, optionally, TRST, where TAP  is implemented as an 1149.1 TAP).","As depicted in , there is an interface  between HC  and TS . The interface  may support local communications and\/or remote communications between HC  and TS . Thus, HC  may control interactive testing of SUT  via TS  locally and\/or remotely.","For example, for local testing, interface  may be implemented as one or more of a Universal Asynchronous Receiver-Transmitter (UART) interface, serial interface, and the like, as well as various combinations thereof.","For example, for remote testing, interface  may be implemented using any suitable communications capabilities, such as Transmission Control Protocol (TCP)\/Internet Protocol (IP) or any other suitable communications protocols. This enables remote testing in which the HC  and TS  may be separated by large geographical distances, and HC  will still be able to control TS  for purposes of performing testing of SUT .","In the TISA-based testing environment , the HC  is able to control, step-by-step, test execution on SUT , by controlling operation of TS  via a standard connection (e.g., UART, TCP\/IP, and the like), thereby enabling interactive testing and debugging capabilities.","Although omitted for purposes of clarity, it will be appreciated that HC  and TS  may include various other components, such as additional processors, additional memories, internal communications buses, input\/output modules, additional support circuits (e.g., power supplies), and the like, as well as various combinations thereof.","Although omitted for purposes of clarity, it will be appreciated that SUT  may be any system under test which may be tested using the TISA.","Although primarily depicted and described with respect to specific types of debugger control programs, debugger display programs, interfaces, and the like, it will be appreciated that TISA-based testing environment  may be implemented in a manner enabling fully-interactive testing capabilities using various other debugger control programs, debugger display programs, interfaces, and the like, as well as various combinations thereof.",{"@attributes":{"id":"p-0220","num":"0231"},"figref":["FIG. 7","FIG. 6"]},"As depicted in , exemplary TISA-based testing environment  of  is an implementation of the TISA-based testing environment  of  in which the GNU Tool Suite is used to support interactive testing of the exemplary system testing environment  of .","As depicted in , exemplary TISA-based testing environment  includes a host computer (HC) , a testing system (TS) , and a system under test (SUT) .","The HC  includes a processor  and a memory . The HC  of  is an implementation of HC  of , in which debugger control program(s)  is implemented using GDB (GDB ) and debugger display program(s)  is implemented using DDD (DDD ).","The TS  includes a TISA processor  and a memory . The TS  of  is an implementation of TS  of , in which the TISA processor  is implemented using a SPARC V8 ISA (denoted as SPARC V8 TISA processor ), debugger program stub(s)  is implemented using a GDB stub (GOB stub ), and the TISA Binary Files  are generated based on the SPARC V8 ISA associated with SPARC V8 TISA processor  (TISA Binary Files ).","The TS  also includes a Test Access Port (TAP)  coupled to SPARC V8 TISA processor . The TS  of  is an implementation of TS  of , in which the TAP  is implemented using a 1149.1 TAP (1149.1 TAP ).","The SPARC V8 TISA processor  interfaces with 1149.1 TAP  using an interface . The interface  is a standard 1149.1 interface that supports TCK, TMS, TDI, TDO, and, optionally, TRST.","The SUT  is the SUT  of . The SUT  includes a transmitter and receiver on different boards, as in SUT  of .","The 1149.1 TAP  provides a test interface between SPARC V8 TISA processor  and SUT  for enabling SPARC V8 TISA processor  to perform testing of SUT  while being controlled by HC .","As depicted in , there is an interface  between HC  and TS . The interface  may support local communications and\/or remote communications (e.g., via a network) between HC  and TS . Thus, HC  may control interactive testing of SUT  via TS  locally and\/or remotely.","In the exemplary TISA-based testing environment , the HC  is able to control, step-by-step, test execution on SUT , by controlling the operation of TS  via interface , thereby enabling interactive testing and debugging capabilities.","It will be appreciated that most of the left-hand side of  reuses existing Computer Science elements: namely, the entire HC , as well as the GDB stub  on TS . It is the same for the central part of , where analogies between HC  and TS  (as well as their associated sub-elements) are evident. The TISA allows this entire infrastructure to be leveraged to provide system testing.","As an example, in reference to the system test environment  of  (including the associated exemplary C programs, SVF instructions, TISA assembler instructions, and TISA codings), there are many interactive test operations that the TISA can enable by leveraging on GDB (or any other suitable debuggers), such as: (a) step-by-step execution while monitoring the variables \u201csent_value\u201d and \u201creceived_value\u201d; (b) on-the-fly modification of the value to be sent to the tap (variable \u201csent_value\u201d); (c) modification of the looping end condition; (d) monitoring of all variables; and the like, as well as various combinations thereof. These interactive test operations are standard operations for GDB, and the TISA can directly use them, due to the ability of the TISA to automatically hand off control between the algorithmic and test access portions, as described hereinabove. In the absence of the TISA, special tooling would need to be developed and adapted to each hand-off implementation.","Although exemplary TISA-based testing environment  of  is primarily depicted and described herein with respect to using the GNU Tool Suite to support interactive testing of a specific system under test, it will be appreciated, by those skilled in the art and informed by the teachings herein, that interactive testing capabilities in a TISA-based test environment may be realized using any suitable tool suites for testing any type of system under test.","Although TISA-based testing environment  of  and exemplary TISA-based testing environment  of  are primarily depicted and described herein with respect to linear test procedures where testing is done step-by-step following a pre-determined algorithm (for purposes of clarity in describing the interactive testing capabilities that are enabled by TISA), it will be appreciated that other more complicated interactive testing scenarios are possible due to the leverage of Computer Science experience and techniques enabled by TISA. An example of a more complicated interactive testing scenario enabled by TISA is depicted and described herein with respect to . It will be appreciated that this is merely one example, and that one skilled in the art and informed by the teachings herein may use TISA in many other interactive testing scenarios and applications.","As described herein, in addition to supporting both granularity and interaction, the TISA also supports concurrency.","The TISA naturally and fully merges the system testing flow with the computer science software flow and, therefore, can leverage the best aspects of both flows. As an example, approaches such as STAPL have difficulty in handling concurrent control of instruments, because such approaches are, by definition, fully sequential. Furthermore, approaches such as the MTC and SystemBIST are intrinsically sequential and single-task and, thus, it would be difficult and awkward to program such approaches to support concurrency. By contrast, concurrent execution is a well-known problem in Computer Science and is now, for instance, at the base of all operating systems. A large number of libraries supporting concurrent execution are available (e.g., the POSIX suite, the BOOST suite, and the like), and most modern processors are designed to efficiently support multi-tasking and context-switching (e.g., the SPARC V8, for instance, implements a rotating register window). The natural interaction between the system testing flow and the computer science software flow that is enabled by the TISA allows the TISA to completely leverage such computer science approaches to concurrency.","The support of concurrency capabilities by the TISA may be better understood by way of an example. As an example, consider the problem of optimizing the data transfer rate of the T-R channel between the transmitter  and the receiver  of the system under test  of  and . This would involve transmitting a stream of data patterns from transmitter  on first board , receiving a corresponding stream of data patterns at receiver  on second board , and comparing the transmitted and received streams of data patterns to compute bit\/error rates and to tune parameters of transmitter  and\/or receiver  accordingly. This optimization may be performed efficiently using three programs operating concurrently.",{"@attributes":{"id":"p-0238","num":"0249"},"figref":["FIG. 8","FIG. 5A","FIG. 7"]},"As depicted in , exemplary program architecture includes a pattern generator , a pattern receiver , and a comparator . The pattern generator , pattern receiver , and comparator  cooperate to optimize the data transfer rate of the T-R channel between the transmitter  and the receiver  of the system under test  of  and .","The pattern generator  sends the appropriate input data patterns to the transmitter  (T) on first board . The pattern generator  can access the TAP (illustratively, TAP  in , TAP  in ) in order to provide the input data patterns to transmitter  via the scan chain  of first board  (B). The pattern generator  may provide the input data patterns to the transmitter  in any suitable manner (e.g., as specified in lines 12-13 of the code described herein with respect to ). The input data patterns may be any data patterns suitable for optimizing the T-R channel between transmitter  and receiver . For example, the input data patterns may be pre-computed patterns, random patterns, and the like, as well as various combinations thereof.","The pattern receiver  collects the appropriate output data patterns from the receiver  (R) on second board . The pattern receiver  can access the TAP (illustratively, TAP  in , TAP  in ) in order to collect the output data patterns from receiver  via the scan chain  of second board  (B). The pattern receiver  may collect the output data patterns from the receiver  in any suitable manner (e.g., as specified in lines 14-15 of the code described herein with respect to ).","The comparator  communicates with pattern generator  and pattern receiver . The comparator compares the input data patterns and the output data patterns. The comparator  evaluates the bit transmission rate and the bit error rate of the T-R channel and, based on the results of the comparison, can access the control registers of both the transmitter  and the receiver  (omitted from  and , for purposes of clarity) to optimize the parameters of the T-R channel.","In order to perform such an optimization testing procedure, pattern generator , pattern receiver , and comparator  need to work in parallel, and each must be able to access the TAP independently of the others. This type of control structure is very difficult to code in traditional environments, which are developed only to support one-point serial handoff control over the TAP. This type of control structure also is very difficult to code in environments employing MTC or other such approaches which also share the same serial TAP access paradigm. By contrast, the TISA is not designed with any such assumption regarding test access; rather, in the TISA, test access is handled in a manner similar to other processor resources, and test access instructions are mixed directly with classical ISA instructions. Using the TISA, the optimization testing procedure of  may be executed by any multitasking Operating System using standard constructs like processes, threads, inter-process communications (IPC), and the like, as well as various combinations thereof. In this manner, pattern generator , pattern receiver , and comparator  can share access to the TAP, and can resolve any eventual TAP sharing issues as is done for all processor resources, e.g., using well-known constructs and algorithms such as, for example, Dijkstra's semaphores. Thus, whereas existing system testing capabilities do not support concurrency, it is clear that the TISA easily and fully supports concurrency.","As described hereinabove, the TISA does not make any assumptions regarding the test access method or the associated test program partitioning; rather, test instructions are treated in the same manner, or substantially the same manner, as classical ISA instructions, without any a priori separation between the two. This enables the TISA to be completely compatible with all existing (and, most likely, future) computer science algorithms and constructs, something that no existing test processor approaches can support.","Thus, it will be appreciated that any existing software libraries can be ported into the TISA architecture. For example, it would be easy to obtain multitasking and concurrency (e.g., as depicted and described herein with respect to ) by exploiting the POSIX and BOOST suites. Further, it will be appreciated that where the TISA is obtained as a generalization of an existing ISA (e.g., as depicted and described with respect to the exemplary SPARC V8 TISA implementation depicted and described with respect to the  and ), porting may not even be necessary since the ISA that the TISA has been developed from will already include such software libraries.","Furthermore, it will be appreciated that various other computer science techniques may be utilized for providing improved system testing using the TISA. For example, some examples of such computer science techniques which may be leveraged for the TISA include: (a) use of platform-independent coding styles, (b) use of ISA-to-ISA converters; (c) use of a Virtual Machine approach, e.g., like for Java, to obtain platform-independent bytecode, or even extension of the Java Virtual Machine itself to become a TISA; and (d) use of an Application Programming Interface (API) to standardize some TISA software interfaces, which would then be translated into primitives by the appropriate drivers. It will be appreciated that these examples are merely a few examples of computer science techniques which may be leveraged for the TISA.",{"@attributes":{"id":"p-0247","num":"0258"},"figref":"FIG. 9"},"Although primarily depicted and described herein as being performed serially, at least a portion of the steps of method  may be performed contemporaneously, or in a different order than depicted and described with respect to .","At step , method  begins.","At step , a first set of instructions is generated. The first set of instructions includes ISA instructions supported by the processor (i.e., ISA instructions being leveraged to provide the TISA for the processor).","At step , a second set of instructions is generated. The second set of instructions includes test instructions associated with the system under test. The second set of instructions may be generated in any suitable manner, e.g., as depicted and described with respect to TGT  of , as depicted and described with respect to TGT  of , and\/or using any other suitable method of generating test instructions.","At step , the first set of instructions and the second set of instructions are integrated to form thereby TISA instructions. The TISA instructions provide the TISA for the processor.","At step , the TISA instructions are stored, displayed, propagated, and\/or executed, or any combination thereof. The TISA instructions may be handled in any other suitable manner.","At step , method  ends.","The TISA may be formed in any suitable manner, e.g., as depicted and described with respect to method  of , as depicted and described with respect to the test system of  and associated method  of , as depicted and described with respect to the test system of  and associated method  of , and\/or using any other suitable method of forming a TISA.",{"@attributes":{"id":"p-0256","num":"0267"},"figref":["FIG. 10","FIG. 10"],"b":["1000","1002","1000"]},"At step , a first set of instructions is generated. The first set of instructions includes instructions generated by compiling at least one computer science software file (e.g., ISA instructions of an ISA supported by a processor).","At step , a second set of instructions is generated. The second set of instructions includes test instructions generated by compiling at least one description file associated with the system under test.","At step , the first and second sets of instructions are combined to form a combined set of instructions. In the combined set of instructions, the instructions of the first set of instructions are adapted for use in controlling execution of the test instructions of the second set of instructions.","At step , the combined set of instructions is stored, displayed, propagated, and\/or executed, or any combination thereof. The combined set of instructions may be handled in any other suitable manner.","At step , method  ends.",{"@attributes":{"id":"p-0262","num":"0273"},"figref":["FIG. 11A","FIG. 11B","FIG. 9","FIG. 10"],"b":["900","1000"]},{"@attributes":{"id":"p-0263","num":"0274"},"figref":["FIG. 11A","FIG. 11A","FIG. 11A","FIG. 11A","FIG. 2","FIG. 2"],"b":"1110"},"At step , method  begins.","At step , a program model is generated. The program model is generated by compiling at least one computer science software file (e.g., ISA instructions of an ISA supported by a processor), where the at least one computer science software file includes at least one call.","At step , a first set of instructions is generated. The first set of instructions is generated using the program model. At least one computation request also is generated using the at least one call included in the at least one computer science software file.","At step , a circuit model is generated. The circuit model is generated by compiling at least one system description file associated with the system under test.","At step , a second set of instructions is generated. The second set of instruction is generated using the circuit model and the at least one computation request.","At step , the first and second sets of instructions are combined to form a combined set of instructions. In the combined set of instructions, the instructions of the first set of instructions are adapted for use in controlling execution of the test instructions of the second set of instructions.","At step , the combined set of instructions is stored, displayed, propagated, and\/or executed, or any combination thereof. The combined set of instructions may be handled in any other suitable manner.","At step , method  ends.  depicts one embodiment of a method for generating instructions adapted for use in testing at least a portion of a system under test. Although primarily depicted and described herein as being performed serially, at least a portion of the steps of method  of  may be performed contemporaneously, or in a different order than depicted and described with respect to .  may be better understood by viewing it in conjunction with  and the associated description of .","At step , method  begins.","At step , at least one pre-processed computer science software file and at least one test operation description file are generated by pre-processing at least one computer science software file.","At step , a circuit model is generated. The circuit model is generated by compiling at least one system description file associated with the system under test and the at least one test operation description file.","At step , a set of test operations is generated. The set of test operations is generated using the circuit model. The test operations from the set of test operations are described using a set of test primitives (e.g., test primitives defined by a test generation tool which generates the circuit model). The set of test primitives includes test operations adapted for use in testing the system under test.","At step , the set of test operations is translated into a set of test instructions by translating the test primitives of the set of test operations into test instructions adapted for use in combination with software instructions of an instruction set architecture.","At step , a program model is generated. The program model is generated by compiling the at least one pre-processed computer science software file and the set of test instructions.","At step , a combined set of instructions is generated. The combined set of instructions is generated using the program model. The combined set of instructions includes (a) software instructions determined from the at least one pre-processed computer science software file and (b) test instructions from the set of test instructions.","At step , the combined set of instructions is stored, displayed, propagated, and\/or executed, or any combination thereof. The combined set of instructions may be handled in any other suitable manner.","At step , method  ends.",{"@attributes":{"id":"p-0281","num":"0292"},"figref":"FIG. 12"},"As depicted in , TISA processor architecture  includes a TISA processor  and a memory .","The TISA processor  may be any processor that is suitable for performing system testing using a TISA, such as a SPARC V8 processor, an INTEL processor, or any other suitable processor.","The memory  may include any memory suitable for use by TISA processor  to support system testing using a TISA, including one or more of random access memory, persistent memory, and the like, as well as various combinations thereof. The memory  may store any information required for performing system testing using a TISA, such as test programs, TISA instructions, testing data, and the like, as well as various combinations thereof.","In one embodiment, for example, TISA processor architecture  of  may support the TISA flows depicted and described with respect to  and .","In one embodiment, for example, TISA processor architecture  of  may operate in a manner similar to TISA processor  and memory  of testing system  depicted and described with respect to . For example, TISA processor architecture  of  may be implemented using a SPARC V8 TISA processor and associated memory, such as in the testing system  depicted and described with respect to . In such an embodiment, the TISA processor  itself interprets and executes both the ISA and TISA instructions.","In one embodiment, an apparatus for use in testing at least a portion of a system under test via a Test Access Port (TAP) includes a memory for storing a set of instructions of a test instruction set architecture and a processor executing the set of instructions of the test instruction set architecture for testing at least a portion of the system under test via the TAP. The set of instructions of the test instruction set architecture includes a first set of instructions comprising a plurality of instructions of an Instruction Set Architecture (ISA) supported by the processor and a second set of instructions comprising a plurality of test instructions associated with the TAP, where the instructions of the first class of instructions and the instructions of the second class of instructions are integrated to form thereby the set of instructions of the test instruction set architecture.","In one embodiment, a TISA processor for use in testing at least a portion of a system under test via a Test Access Port (TAP) includes a first class of instructions including instructions of an Instruction Set Architecture (ISA) supported by the processor and a second class of instructions including test instructions associated with the TAP, wherein the ISA instructions of the first set of instructions and the test instructions of the second set of instructions are integrated to form a TISA adapted for testing at least a portion of the system under test.","In one embodiment, a computer processor, for testing a system under test (SUT) via a Test Access Port (TAP), includes circuitry configured to process instructions according to a test instruction set architecture (TISA) having semantics that enable interaction with the system under test via the TAP. The TISA includes a plurality of instructions of a first type and a plurality of instructions of a second type, where the first type of instructions include instructions of an instruction set architecture (ISA) supported by the computer processor and the second type of instructions include test instructions for testing the system under test via the TAP.","Although primarily depicted and described hereinabove with respect to embodiments in which the TISA processor is defined in a particular manner (e.g., using particular language to describe different classes and\/or types of instructions), it will be appreciated that a TISA may be defined in other ways that are fully supported by the depiction and description of various TISAs as provided herein.","Although primarily depicted and described herein with respect to embodiments in which the TISA processor architecture is implemented using a single processor to support the TISA, in other embodiments the TISA processor architecture may be implemented using multiple processors.",{"@attributes":{"id":"p-0292","num":"0303"},"figref":"FIG. 13"},"As depicted in , test processor architecture  includes a primary processor  and a secondary processor  in communication via a communication path .","The primary processor  may be any processor suitable for supporting system testing, such as a SPARC V8 processor, an INTEL processor, or any other suitable processor. The primary processor  executes instructions for testing a system under test. In one embodiment, for example, primary processor  may support testing functions similar to the functions supported by CPU  of TISA processor architecture  of  (e.g., where test processor architecture  utilizes a TISA). In one embodiment, for example, primary processor  may support testing functions supported by testing processors in test processor architectures that do not utilize a TISA. The primary processor  may support various other testing capabilities.","The secondary processor  may be any processor suitable for supporting system testing, such as a SPARC V8 processor, an INTEL processor, or any other suitable processor. The secondary processor  supports a Test Access Port (TAP) interface to the system under test (which is omitted for purposes of clarity). The TAP interface may interface with any suitable TAP. For example, the TAP interface may provide an interface to an IEEE 1149.1 TAP or any other suitable TAP which may be used for testing a system under test.","The primary processor  and secondary processor  cooperate to perform testing of at least a portion of a system under test.","The primary processor  executes test instructions for testing a system under test. The test instructions may be test instructions of a TISA (where test processor architecture  utilizes a TISA) or test instructions not associated with a TISA (where test processor architecture  does not utilize a TISA). The primary processor , during execution of the test instructions, detects instructions related to control of the TAP of the system under test (e.g., such as instructions for loading input data to a TAP controller of the system under test, instructions for reading output data from a TAP controller of the system under test, and like instructions, as well as various combinations thereof). The primary processor  provides the TAP-related instructions to secondary processor . The secondary processor  receives the TAP-related instructions from primary processor . The secondary processor  executes the TAP-related instructions. The primary processor  continues executing test instructions while secondary processor  executes the TAP-related instructions received from primary processor . In this manner, primary processor  may perform a context switch and continue operating while secondary processor  controls scan operations via the TAP of the system under test. This is difficult using a single-processor approach, because while the single processor is controlling the TAP, the single processor is prevented from performing other operations. Therefore, the use of multiple processors, as in the test processor architecture , provides a significant improvement in testing efficiency without a need to use high-end processors, especially considering that operations over the TAP typically take a long time compared to the time required for a processor to perform a single operation.","The cooperation between primary processor  and secondary processor  to perform testing of at least a portion of a system under test is facilitated by communication path . The communication path  may be implemented using any suitable means of communication between primary processor  and secondary processor , which may depend on the type of multi-processor architecture with which the test processor architecture  is implemented. For example, communication path  may include one or more of a main processor interface bus, an auxiliary processor interface, a communication interface (e.g., such as a serializer-deserializer (SERDES) interface or other suitable communication interface), and the like, as well as various combinations thereof.","Although omitted for purposes of clarity, it will be appreciated that the test processor architecture  will include memory (e.g., random access memory, persistent memory, cache memory, and the like, as well as various combinations thereof). The memory of test processor architecture  may include one or more of memory shared by primary processor  and secondary processor , memory dedicated to primary processor , memory dedicated to secondary processor , and the like, as well as various combinations thereof.","Although omitted for purposes of clarity, it will be appreciated that the test processor architecture  may include various other support circuits, such as buses, I\/O circuits, and the like, as well as various combinations thereof.","The test processor architecture  of  may be implemented in a number of ways.","In one embodiment, for example, the test processor architecture may use a test co-processor unit architecture in which a central processor unit (CPU) cooperates with a test co-processor unit (TCPU) in order to support system testing. An exemplary embodiment is depicted and described with respect to .","In one embodiment, for example, the test processor architecture may use a test adjunct processor unit architecture in which a central processor unit (CPU) cooperates with a test adjunct processor unit (TAPU) in order to support system testing. An exemplary embodiment is depicted and described with respect to .",{"@attributes":{"id":"p-0304","num":"0315"},"figref":"FIG. 14","b":["1400","1400"]},"The test co-processor architecture  includes a central processor unit (CPU) , a test co-processor unit (TCPU) , a main memory , and a flash memory .","The test co-processor architecture  includes a main processor interface bus . The CPU , TCPU , main memory , and flash memory  each are coupled to (or otherwise configured to be able to communicate with) the main processor interface bus .","The test co-processor architecture  also may include an auxiliary processor interface  which directly couples CPU  and TCPU , thereby enabling direct communications between CPU  and TCPU .","The CPU  may be any CPU suitable for performing system testing of a system under test. The CPU  supports testing capabilities supported by primary processor  depicted and described with respect to .","The TCPU  may be any CPU suitable for facilitating system testing of a system under test. The TCPU  supports a Test Access Port (TAP) interface , which may interface with any suitable TAP (e.g., such as an IEEE 1149.1 TAP or any other suitable TAP used for testing a system under test). The TCPU  supports testing capabilities supported by secondary processor  depicted and described with respect to .","The CPU  and TCPU  cooperate to perform testing of at least a portion of a system under test in a manner similar to primary processor  and secondary processor  depicted and described with respect to . The CPU  and TCPU  utilize instruction exception handling in order to enable CPU  to continue operating to process test instructions while TCPU  executes TAP-related instructions for controlling the TAP of the system under test during testing.","The CPU  executes test instructions for testing a system under test. The CPU , during execution of the test instructions, detects instruction exceptions (i.e., instructions related to control of the TAP of the system under test) and provides the instruction exceptions to TCPU . The TCPU  receives the instruction exceptions from CPU  and processes the instruction exceptions such that the TCPU  may handle the instruction exceptions while CPU  continues to operate to perform other tasks (e.g., executing other testing instructions). In other words, CPU  and TCPU  cooperate during system testing such that CPU  may switch context and continue to operate to perform other tasks while TCPU  handles instruction exceptions detected by CPU , thereby improving system testing efficiency.","In one embodiment, the CPU  includes a cache , e.g., for improving the performance of CPU .","In one embodiment, the TCPU  includes a direct memory access (DMA) unit , which may be any type of DMA unit suitable for use in support system testing. In one embodiment, for example, DMA unit  is a scatter\/gather (SIG) DMA unit. The TCPU  may utilize DMA unit  for purposes of handling instruction exceptions received from CPU , and for efficiently accessing sensible data stored in memory. In one embodiment, CPU  may configure SIG DMA tables prior to encountering an instruction exception.","In one embodiment, the TCPU  supports a set of specialized TCPU instructions. The set of specialized TCPU instructions may support TAP access and control. The set of specialized TCPU instructions may be used by TCPU  to perform specific TAP operations on the TAP State Machine.","The CPU  and TCPU  utilize main memory  and\/or flash memory  for performing various testing functions, such as execution of test instructions by CPU , instruction exception handling by TCPU , execution of TCPU instruction by TCPU , and the like, as well as various combinations thereof. The main memory  may be any suitable processor memory. The flash memory  may be any suitable flash memory or any other suitable form of persistent memory. The CPU  and TCPU  share the memory with arbitrated access. The CPU  and TCPU  also may share the memory for purposes of exchanging information. Although primarily depicted and described with respect to specific numbers and types of memory, it will be appreciated that various other memory schemes may be used for supporting the functions performed by CPU  and TCPU .","The CPU  and TCPU  perform testing of the system under test using communication between CPU  and TCPU  and communication between CPU  and\/or TCPU  and other components of test co-processor architecture  (e.g., main memory , flash memory , and other components), and the like, as well as various combinations thereof. The communications may be supported using one or both of the main processor interface bus  and the auxiliary processor interface . The communications between CPU  and TCPU  may include communications associated with instruction exception notification, interrupt access, DMA arbitration, and the like, as well as various combinations thereof. The communications between CPU  and TCPU  and other components of the test co-processor architecture  may include communications associated with reading from memory, writing to memory, and\/or any other tasks which may be performed in support of testing the system under test.",{"@attributes":{"id":"p-0317","num":"0328"},"figref":"FIG. 15","b":["1500","1500"]},"The test adjunct processor architecture  includes a central processor unit (CPU)  and a test adjunct processor unit (TAPU) . The CPU  and TAPU  may reside on the same board or may reside on different boards.","The CPU  may be any CPU suitable for performing system testing of a system under test. The CPU  supports testing capabilities supported by primary processor  depicted and described with respect to .","The CPU  has a main memory , a flash memory , and an input\/output module  associated therewith. The CPU  has a main processor interface bus  associated therewith. The CPU , main memory , flash memory , and input\/output module  each are coupled to (or otherwise configured to be able to communicate with) the main processor interface bus .","In one embodiment, the CPU  includes a cache , e.g., for improving the performance of CPU .","The TAPU  may be any CPU suitable for facilitating system testing of a system under test. The TAPU  includes an input\/output module . The TAPU  supports a Test Access Port (TAP) interface , which may interface with any suitable TAP (e.g., such as an IEEE 1149.1 TAP or any other suitable TAP used for testing a system under test). The TAPU  supports testing capabilities supported by secondary processor  depicted and described with respect to .","The TAPU  has a local test memory  associated therewith. The TAPU  has an internal interface bus  associated therewith. The TAPU  and local test memory  each are coupled to (or otherwise configured to be able to communicate with) the internal interface bus .","The input\/output module  associated with CPU  and the input\/output module  of TAPU  support a communication interface  enabling communications between CPU  and TAPU . The communication interface  supports streaming of TAP-related commands from CPU  to TAPU .","In one embodiment, the input\/output module  associated with CPU  and the input\/output module  of TAPU  support Serializer-Deserializer (SERDES) communications capabilities and, therefore, the communications interface  is a SERDES-based communications interface. In this embodiment, the SERDES-based communications interface  may be implemented using any suitable SERDES communications protocol (e.g., such as Gigabit Ethernet (GigE), Serial Rapid  (SRIO), Peripheral Component Interconnect Express (PCIe), and the like). Although primarily depicted and described herein with respect to using SERDES-based communications between the CPU  and the TAPU , other suitable communications capabilities may be used in order to support communications between CPU  and TAPU .","The CPU  and TAPU  cooperate to perform testing of at least a portion of a system under test in a manner similar to primary processor  and secondary processor  depicted and described with respect to . The CPU  and TAPU  utilize command streaming via the communication interface  in order to enable CPU  to continue operating to process test instructions while TAPU  executes TAP-related instructions for controlling the TAP of the system under test during testing.","The CPU  executes test instructions for testing a system under test. The CPU , during execution of the test instructions, detects instructions related to control of the TAP of the system under test. The CPU  propagates the TAP-related instructions to the TAPU  via the communication interface  (i.e., from CPU  to input\/output module  via the main processor interface bus , for propagation via communication interface ). The TAPU  receives the TAP-related instructions from CPU  and processes the TAP-related instructions such that the TAPU  may handle control of the TAP while CPU  continues to operate to perform other tasks (e.g., executing other testing instructions). In other words, CPU  and TAPU  cooperate during system testing such that CPU  may switch context and continue to operate to perform other tasks while TAPU  handles TAP-related instructions detected by CPU , thereby improving system testing efficiency.","In one embodiment, the TAP-related instructions detected by CPU  and processed by TAPU  are packetized by the CPU  for propagation to TAPU .","In one embodiment, the TAP-related instructions detected by CPU  and processed by TAPU  include opcodes supported by TAPU . In one such embodiment, the TAP-related instructions also may include one or more extension commands adapted for use in performing block memory copies between memory associated with the CPU  and memory associated with the TAPU  (e.g., between main memory and local test memory ).","The CPU  utilizes main memory and\/or flash memory for performing various testing functions, such as execution of test instructions, detection of TAP-related instructions, packetization of TAP-related instructions, and the like, as well as various combinations thereof. The main memory may be any suitable processor memory. The flash memory may be any suitable flash memory or any other suitable persistent memory.","The TAPU  utilizes local test memory  for performing various testing functions, such as storage of TAP-related instructions received from CPU , processing of TAP-related instructions received from CPU , and the like, as well as various combinations thereof. The local test memory  may be any suitable processor memory. In one embodiment, the local test memory  may be relatively small since it handles processing of scan chain segments of the scan chain of the system under test, rather than the entire scan chain (as may be required in an on-chip memory).","Although primarily depicted and described with respect to specific numbers and types of memory, it will be appreciated that various other memory schemes may be used for supporting the functions performed by CPU  and TCPU .","Although primarily depicted and described herein with respect to use of a co-processor architecture or an adjunct processor architecture to implement the TISA, it will be appreciated that the TISA may be implemented using any suitable processor architecture, which may include processor architectures other than the co-processor architecture or the adjunct processor architecture. Thus, the TISA processor architecture may be implemented using multiple processors in various other ways, at least some of which may include use of more than two processors for supporting the TISA.","Although primarily depicted and described herein with respect to use of the co-processor architecture or the adjunct processor architecture in order to implement the TISA architecture, it will be appreciated by one skilled in the art and informed by the teachings herein that the co-processor architecture and the adjunct processor architecture each may be used to implement other types of testing architectures (i.e., other testing architectures that do not employ TISA).","It will be appreciated that the test co-processor architecture and the test adjunct processor architecture are functionally similar in that each enables a TISA to be executed by two communicating processors. In a given application, the choice between the two architecture may be made by the designer on the basis of implementation-dependent parameters, such as available resources, costs, performances, physical constraints (integration in the same chip, in different chips and\/or boards or any combination thereof), as well as any other implementation parameter. Although primarily depicted and described herein with respect to test co-processor and test adjunct processor architectures, it will be appreciated by one skilled in the art and informed by the teachings herein that these implementation considerations will apply to any other types of testing architectures\/infrastructure.","The TISA processor architectures depicted and described herein may employ any suitable TISA for use in performing system testing.","A description of one exemplary embodiment of a TISA adapted for use with the TISA processor architectures follows. This exemplary embodiment of a TISA is an implementation of Scan Segment Level primitives depicted and described herein. In a Scan Segment Level abstraction level, the overall scan chain of the system-under-test is divided into segments, which are then used as the data atom of the algorithm. It will be appreciated that the system-under-test may be partitioned into the scan segments by the algorithm developer, which may be a human and\/or an automated tool. A more general description of the use of TISA to enable scan operations to be performed at the Scan Segment Level, i.e., a description that is independent of this exemplary TISA implementation, is provided detail hereinbelow.","The following embodiment of a TISA proposes a set of registers and instructions able to define and handle those scan segments. The following embodiment is based on a 32-bit sized TISA, but it could be adapted to any other word size (e.g., 16-bit, 64-bit, or any other suitable word size).",{"@attributes":{"id":"p-0339","num":"0350"},"figref":["FIG. 16","FIGS. 16A-16D"],"b":["1","4"]},"As depicted in , the first register set R includes the following User Accessible Data Registers:\n\n","As depicted in , the second register set R includes the following Internal Scratch Registers:\n\n","As depicted in , the third register set R includes the following Scatter\/Gather Segment Descriptions registers:\n\n","As depicted in , the fourth register set R includes the following MultiBlock Scatter\/Gather Segment Descriptions registers:\n\n","It will be appreciated that the exemplary TISA register sets may be modified in any suitable manner. For example, each of the exemplary register sets may be modified to include fewer, more, and\/or different registers. For example, the exemplary registers may be regrouped into fewer, more, and\/or different sets. For example, fewer, more, and\/or different register sets may be used. In other words, the exemplary TISA register sets may be replaced with any other TISA register set(s) suitable for use with TISA instructions sets to implement a TISA processor architecture.","The exemplary TISA may employ any suitable TISA instruction set (i.e., command dictionary) for use in performing system testing.","The exemplary TISA instruction set includes the following opcodes, which may be utilized to manipulate register sets R through R depicted and described with respect to , as well as the original ISA register sets depicted and described herein:\n\n","The exemplary TISA instruction set includes the following register modification instructions that use explicit values:\n\n","The exemplary TISA instruction set includes the following register modification instruction that use implicit values:\n\n","The exemplary TISA instruction set includes the following register preservation instructions:\n\n","The exemplary TISA instruction set includes the following logical operations on registers:\n\n","The exemplary TISA instruction set includes the following miscellaneous operation on registers:\n\n","The exemplary TISA instruction set includes the following instructions for extending support for streaming for an embodiment using the adjunct processor architecture:\n\n","The exemplary TISA instruction set includes the following values for scan state:\n\n","It will be appreciated, by one skilled in the art and informed by the teachings herein, that various other TISA implementations may be used with the TISA processor architectures depicted and described herein. For example, other TISA implementations may use fewer, more, and\/or different registers, may use fewer, more, and\/or different instruction sets, and the like, as well as various combinations thereof. In one embodiment, other TISA implementations may be utilized where different processor architectures are used, in order to provide TISA implementations better-suited to specific applications, and\/or for any other suitable reasons.","As described hereinabove, use of TISA in a JTAG architecture enables scan operations to be performed at the Scan Segments Level, which allows the definition of independently controllable \u201cscan segments\u201d inside the overall scan path, thereby providing a flexible and powerful set of primitives that can be used to define scan operations directly in the problem space and resolve the scan operations at implementation time.","In general, JTAG operations are based on the scan operation in which all bits are scanned in serially one-by-one while at the same time bits are being scanned out serially one-by-one. This means that, in order to be able to perform a scan operation, knowledge of which value is needed for each bit in the scan chain (i.e., the input and output vectors) is required. TGTs typically provide this capability for traditional structural testing by computing the required vectors from a system model obtained through description languages such as BSDL. Additionally, formats like SVF and STAPL mirror this, as they allow the user to manipulate those vectors. While testing in this manner is sufficient for structural (and other types) of testing, testing in this manner is highly inefficient for interactive setups in which there is no real need to access the whole scan chain. The inefficiency may be seen by considering an example.","For example, consider a scan chain composed of 100 instruments, each one having 16 bits. If the user needed to write 0x1234 in the registers of the 76instrument in the scan chain, the TGT would need to generate the vector for the whole scan chain (100*16=1600 bits) and send it to the TAP interface to be input into the scan chain. Similarly, if the user wanted to read the associated output, the TGT would need to receive the entire 1600 bit vector before being able to extract the desired output information. In this example, the fact that a majority of the scan bits are useless is not important, as scan efficiency is not one of the goals (rather, in this example, the goal is primarily to be able to efficiently access one particular entity of the scan chain).","This type of approach is a problem at least for the following reasons: (a) there is the computational need of handling long vectors (e.g., lots of memory transfers have a high impact on performances); (b) there is a need to store the entire vector(s) in memory (which may be a problem for long chains); (c) memory storage is not limited to data inputs and data outputs, but also includes expected data, input and output mask, and the like (thereby multiplying memory requirements which are already potentially strained just from the input and output data); and (d) the transformation from instrument-vector-instrument must be made each time (which demands computational power and time).","The Scan Segments Level abstraction level is a powerful tool for providing efficient access to individual entities, or groups of entities, of the scan chain of a system under test, without any special emphasis on scan efficiency (even if, of course, still enabling it if needed).","In one embodiment, Scan Segments Level abstraction is implemented by decomposing a scan chain into a succession of segments and defining one or more scan operations on each of the segments. The scan chain is composed of a plurality of elements, and each segment includes at least one of the elements of the scan chain. The elements may be defined at many levels of the system under test (e.g., elements may be devices, instruments, registers, segments of a register, and the like, as well as various combinations thereof), and, thus, that the segments into which the scan chain is decomposed may be defined at many levels of the system under test (e.g., segments may include one or more devices, a portion of a device(s), one or more instruments, a portion of an instrument(s), one or more registers, a portion of a register(s), one or more register segments, and the like, as well as various combinations thereof). In this manner, a segment may represent the smallest control unit of the scan chain.","In one embodiment, decomposition of a scan chain into segments may be hierarchical. For example, the scan chain may be decomposed into segments, at least some of which may be composed by sub-segments, at least some of which may be composed by sub-segments, and so forth. In this manner, the hierarchical decomposition of the scan chain may be viewed as having a tree-based structure in which a segment may be composed of other segments. In one such embodiment, the segments at the leaves of the tree may be referred to as segments (in that they represent the smallest control unit of the scan chain), which the segments located above the leaves of the tree may be referred to as super-segments. It will be appreciated that, in one embodiment, one or more of the segments of the scan chain may be composed of virtual sub-segments which are controllable, but only in a manner that is transparent to the user\/system. The hierarchical decomposition of a scan chain may be defined in any other suitable manner.","The use of segmentation enables definition of entities for types of segments and\/or types of segment combinations. An entity is a generic description of a type of target, which is valid for and may be reused for each physical instance of that type of target. For example, an entity may define a description of a device, a group of devices, a portion of a device, an instrument, a group of instruments, a portion of an instrument, and the like, as well as various combinations thereof. Thus, since a scan chain may be decomposed such that segments of the scan chain include specific elements or combinations of elements, entities may be defined for respective segments and\/or respective combinations of segments, of a scan chain. For example, where a scan chain is decomposed such that a segment includes an instrument, an entity may be defined for that type of segment (i.e., each segment including that type of instrument), such that the entity may be reused for each physical instance of that type of segment in the scan chain. Similarly, for example, where a scan chain is decomposed such that a segment includes multiple instruments, an entity may be defined for that type of segment (i.e., each segment including that type combination of instruments), such that the entity may be reused for each physical instance of that type of segment in the scan chain. This enables additional features and functions to be supported, as described below.","The use of segmentation allows an entity (i.e., a description of a type of segment under control) to be correlated with a physical protocol that is used to communicate with the entity. As a result, description languages (e.g., such as NSDL, P1687 IJTAG PDL, and the like) could be written specifically for the entity, and the connectivity description portion (e.g., the structure of the NSDL or the IJTAG HDL) would describe the ordering of the segmentation instructions.","TISA provides a reusable modularity that can be defined once for all occurrences of a particular entity type, as the TISA instructions are segment-based operations rather than model-based operations. Thus, since TISA is both modular and autonomous for the entity under test in a particular segment, TISA provides significant advantages over existing architectures.","TISA enables a direct mapping of the Test Data Register definition into a reusable and portable module that may be plugged into the execution flow at any point in the scan process, in any order that is necessary, without needing to define the entire connectivity as a static model up front as existing tools require. TISA enables integration of the port\/signal interfaces that are non-scan with the scan operations as a single solution space architecture based on a unified control flow and standard computer science techniques (providing significant advantages over solutions in which native language constructs are used to provide access to non-scan operations).","TISA enables reuse of instruction sequences for multiple instances of the same entity, thereby enabling a reduction in code storage requirements in the system. For example, a generalized function, which maps to description language functions which are called by a managing program, may be written. In this example, each of the functions are methods of native language objects that represent the entity, and there may be separate instances of these objects for each entity defined in the system, but there could be a single copy of code used to communicate with each of these instances. In this manner, the native language implementation models directly control the description language used to specify the connectivity and functionality of the circuit.","In reference to the example given above, use of Scan Segments Level abstraction would enable definition of three segments as follows: segment S including instruments  through , segment S including the instrument , and segment S including instruments  through . In this manner, access to instrument  is greatly simplified. For example, access to instrument  could be obtained by making a \u201cdummy shift\u201d (e.g., ScanBlockZero) for segment S, executing the instruction(s) for segment S (i.e., instrument ), making another dummy shift for segment S, and then terminating with an update. In such a sequence, access to segment S (i.e., to a specific instrument in the scan chain) is provided without a need of any knowledge of segment S or segment S apart from their length. It will be appreciated that this is merely one example, and, thus, that other decompositions of the 100 instrument-long chains are possible to enable access to other instruments or instrument groups.",{"@attributes":{"id":"p-0368","num":"0451"},"figref":"FIG. 17"},"The exemplary SUT  includes four devices -(collectively, devices ; and denoted in  as Device , Device , Device , and Device , respectively). The devices  are arranged serially within SUT  to form a scan chain . The scan chain  is as follows: the TDI of the TAP is connected to the input port of device , the output port of device is connected to the input port of device , the output port of device is connected to the input port of device , the output port of device is connected to the input port of device , and the output port of device is connected to the TDO of the TAP.","In the exemplary SUT , each of the devices  includes (1) an input de-multiplexer providing inputs to a test instruction register (TIR) and a test data register (TDR), and (2) an output multiplexer for collecting outputs from the TIR and the TDR. The TIR and TDR of each device  are parallel registers. The device includes one additional TDR, such that the input de-multiplexer provides inputs to one TIR and two TDRs and collects outputs from the one TIR and the two TDRs, where the one TIR and two TDRs are all in parallel. The TIRs and TDRs each are depicted as serial shift registers, each including nine associated elements (e.g., flip-flops). In this manner, (a) the TIRs form one scan chain (denoted as an test instruction scan chain) that includes thirty-six serial elements and (b) the TDRs form another scan chain (denoted as a test data scan chain) that includes forty-five total elements and thirty-six serial elements (i.e., because the two TDRs of device are in parallel).","In the exemplary SUT , the test instruction scan chain has been decomposed into four segments follows: a first segment  which includes the nine elements of the TIR of device , a second segment S which includes the nine elements of the TIR of device , a third segment S which includes the nine elements of the TIR of device , and a fourth segment SI which includes the nine elements of the TIR of device . In this manner, the testing system may access any of the TIRs of SUT , individually or in combination, with minimal knowledge of the other TIRs of SUT  (other than the number of elements of which they are composed).","In the exemplary SUT , the test data scan chain has been decomposed into six serial segments (seven total segments) as follows: a first segment SD that includes the nine elements of the TDR of device ; a second segment SD that includes the nine elements of the TDR of device ; a third segment SD that includes either the nine elements of the first TDR of device (denoted as sub-segment SD.) or the nine elements of the second TDR of device (denoted as sub-segment SD.), where these are counted as separate segments for purposes of counting the total number of segments; and a fourth segment which is further decomposed into three serial sub-segments as follows: a first sub-segment that includes the first three elements of the TDR of device (denoted as sub-segment SD .), a second sub-segment that includes the next four elements of the TDR of device (denoted as sub-segment SD .), and a third sub-segment that includes the last two elements of the TDR of device (denoted as sub-segment SD.). In this manner, the testing system may access any of the TDRs of SUT  (or even sub-portions of the TDR of device ), individually or in combination, with minimal knowledge of the other TDRs of SUT  (other than the number of elements of which they are composed).","It will be appreciated that SUT  of  is merely one example of the manner in which the scan chain(s) of a system under test may be decomposed for use in providing Scan Segments Level abstraction. Although depicted and described herein with respect to specific types, numbers, and arrangements of elements, components, and the like, it will be appreciated that a system under test for which a scan chain(s) is decomposed may be include various other types, numbers, and\/or arrangements of elements, components, and the like.","As described herein, decomposition of the scan chain of a system under test enables scan operations to be defined on the segments, thereby improving testing efficiency. A method, according to one embodiment, for generating a set of instructions including scan operations for segments of a decomposed scan chain is depicted and described herein with respect to .","A more detailed example of scan decomposition and generation of scan segment operations is provided follows.","As a general example, consider a scan chain that includes three boards where each board includes a segment (denoted as segments A, B, and C associated with a first board, a second board, and a third board, respectively). In this example, where the scan segments are hierarchical, the segment A on the first board may be composed of a plurality of sub-segments (e.g., sub-segments Athrough A), the segment B on the second board may be composed of a plurality of sub-segments (e.g., sub-segments Bthrough B), and\/or the segment C on the third board may be composed of a plurality of sub-segments (e.g., sub-segments Cthrough C).","As a more specific example, following the application and the SUT, a segment could be: one or more registers inside an instrument, an instrument, a cluster of registers, one or more boards, and the like, as well as various combinations thereof.","The overall scan operation is therefore decomposed in a series of segment scan operations. As a result, all that is required in order to obtain the final scan chain operation is a series of simple atomic operations. Thus, the embodiments of Scan Segments Level abstraction, while not exclusively limited to, are especially effective in implementations in which the atomic test operations are treated like processor operations (e.g., such as in the various TISA implementations depicted and described herein, or in any other similar implementations in which atomic test operations are treated like processor operations).","In such embodiments of Scan Segments Level abstraction, the actual implementation of the Scan Segments Level scan operations may require that one or more technological constraints linked to JTAG be addressed. For example, constraints such as the need to define the state of the TAP machine and the risk of using the Pause-DR state (not always implemented), among others, may need to be addressed.","In order to identify instrument\/segment outputs in the output bitstream received via the scan chain, based on the position of the instrument\/segment in the scan chain, the scan chain may be treated as a first-in-first-out (FIFO) system (given its serial nature) such that the first segment that is scanned in is also the first segment that is scanned out (as it is closest to the end of the scan chain).","In order to make the SUT \u201cexperience\u201d the sequence of scan segment operations like a single scan operation, the TCK may be frozen between segment operations. As all elements inside the scan chain are synchronous, the effect of freezing TCK in this manner is that the scan chain is frozen together with TCK.","The use of Scan Segments Level in a TISA-based testing system may be better understood by way of a few examples, In the examples that follow, assume that a system under test (SUT) is composed of three segments (denoted as A, B, and C, in that order), and that a user needs to write a value V inside of segment B.","As a first example, assume that the three segments of the system (A, B, and C) are implemented inside the same JTAG device. In this first example, once the three segments are defined in memory, the TISA operations would become:\n\n","With respect to the first example, keeping the TAP Finite State Machine (FSM) in the ShiftDR state ensures that there is no update on the scan chain. This may be seen from the first example, in which keeping the TAP FSM in the ShiftDR state from step (i) to step (ix) ensures that there is no update on the scan chain, given that the UpdateDR State will be reached only once leaving ShiftDR.","Further with respect to the first example, the scan clock TCK is active only during the scan operations (i.e., steps (iii), (vi), and (ix)), and is frozen in the remaining states. The effect is that the SUT, from the point of view of the SUT based on operations synchronous with TCK, will see steps (iii), (vi), and (ix) as a continuous bitstream.","Further with respect to the first example, the \u201cbypass sequence\u201d is a property of the scan segment, and can be, for instance, a given sequence (all zeros, all ones, or any other suitable sequence), or \u201cdon't care\u201d, where it is up to the TGT to decide such sequence.","As a second example, assume that the three segments of the system (A, B, and C) are implemented on different JTAG devices (in one or more cards). In this second example, once the three segments are defined in memory, the TISA operations would become:\n\n","In comparing the first example and the second example, it will be understood that the additional complexity associated with the second example comes from the need to use the Instruction Register (IR) of each JTAG device to select\/deselect the segments. In that case, unused segments are directly taken out of the chain by putting the related JTAG device in the BYPASS mode of the 1149.1 standard (as indicated in steps (iii) and (xvii) of the second example).","It will be appreciated that all compositions of the above two examples are possible, with any number of segments defined on one or more JTAG devices. It will be further appreciated that the above-two examples are merely examples provided for the purpose of illustrating use of the Scan Segments Level for testing a system under test, and, thus, that embodiments in which the Scan Segments Level is used for testing a system under test are not intended to be limited by these examples.","In such embodiments, the actual sequence of TISA instructions can have multiple origins, including one or more of the following: (1) the TISA instructions may be statically computed by the TGT, in which case, each time the user wants to access a segment, the entire chain must be scanned (it will be appreciated that, while this solution is not optimized for scan time, it can be useful for embedded systems with limited computational resources and little or no time constraints); (2) the TISA instructions may be issued by a software scheduler, which receives access requests and composes them into scan operations; and\/or (3) the TISA instructions may be issued by a hardware scheduler (e.g., such as, but not limited to, what is done for instruction reordering and bypass in some high-performance processors). It will be appreciated that TISA instructions associated with Scan Segments Level control may be issued in any other suitable way, which may include a combination of the methods described above and\/or one or more other suitable methods which may be used in place of or in addition to one or more of the methods described above.","The Scan Segments Level abstraction level is a powerful tool for handling dynamic topologies, such as the ones proposed by the IEEE P1687 standard and other dynamic topologies. If a section of the scan chain can be taken in and out the active scan path (e.g., using an SIB cell proposed by the IEEE P1687 standard or any other suitable hierarchy-enabling component(s)), that section can be marked as one (or more) segments. The testing scheduler then has knowledge, from the system state, as to whether or not this segment(s) is active, and, therefore, if the segment should be included in the TISA instruction scheduling. It will be appreciated by those skilled in the art and informed by the teachings herein that this principle also may be used for other dynamic elements, such as hot-swap boards (e.g., by detecting their presence from a status register) or any other suitable dynamic elements.",{"@attributes":{"id":"p-0392","num":"0502"},"figref":"FIG. 18"},"Although primarily depicted and described herein as being performed serially, at least a portion of the steps of method  may be performed contemporaneously, or in a different order than depicted and described with respect to .","At step , method  begins.","At step , the scan chain is decomposed into a plurality of segments. The scan chain is composed of a plurality of elements, and each segment includes at least one of the elements of the scan chain. The scan chain may be decomposed into segments in any suitable manner, as described hereinabove. As described herein, decomposition of the scan chain into segments may be applied anywhere in the development flow (e.g., by the test developer, by the test generation tool, by an embedded circuit model, and the like).","At step , a set of instructions is generated. The set of instructions includes processor instructions associated with an ISA and test instructions for testing the portion of the system under test. The test instructions include, for each of the segments of the scan chain, at least one scan operation to be performed on the segment. The test instructions may be any type of test instructions, such as conventional test instructions, test instructions of a TISA, and the like, and, thus, may be generated in any suitable manner. The set of instructions may be generated in any suitable manner (e.g., in a manner the same as or similar to as depicted and described hereinabove respect to","At step , the set of instructions is executed for testing the portion of the system under test. The set of instructions may be executed in any suitable manner, which may depend on the type of instructions of the set of instructions.","At step , method  ends.","Although primarily depicted and described herein with respect to embodiments in which embodiments of TISA are used to enable scan operations to be performed at the Scan Segments Level, it will be appreciated that one or more of the Scan Segments Level embodiments depicted and described herein also may be provided in environments using TISA-like instructions architectures, non-TISA instruction architectures and\/or non-TISA testing environment implementations, and the like.","Although references are made herein to \u201cthe TISA\u201d for purposes of describing the enhanced system testing capabilities enabled by exemplary embodiments of TISAs which may be formed and utilized as depicted and described herein, it will be appreciated that many different TISAs may be formed depending on various factors, such as one or more of the ISA of the processor for which the TISA is formed, characteristics of the SUT for which the TISA is formed, characteristics of the test algorithm the TISA is supposed to execute, and the like, as well as various combinations thereof. Thus, references made herein to \u201cthe TISA\u201d also may be read more generally as \u201ca TISA\u201d in that many different types of TISAs may be formed.","A position-based scheduling capability for supporting testing of Joint Test Action Group (JTAG) hardware is depicted and described herein.","In one embodiment, the position-based scheduling capability utilizes various features of TISA. In TISA, the scan chain is seen as a composition of sub-elements called segments, which results in the following advantages: (1) the operations on a segment are local (i.e. they are independent from the topology of which the segment is a part) and (2) an overall scan operation is composed by an ordered series of scan operations on the segments of which the scan chain is composed. It is noted that, in such an environment, the notion of \u201cvector\u201d is no longer needed; rather, only the position of the segment inside the scan chain is needed. As such, in one embodiment, the position-based scheduling capability is configured such that elements needing access to portions of the scan chain are configured to provide access requests to a scheduler which is configured to determine a schedule according to which the elements may access the requested portions of the scan chain, thereby obviating the need for each of the elements to compute the complete vector for the entire scan chain.",{"@attributes":{"id":"p-0403","num":"0513"},"figref":"FIG. 19"},"As depicted in , scheduler execution architecture  includes a system under test (SUT) , a TISA processor , a scheduler , and a user application .","The SUT  includes a JTAG scan chain  accessible via the TISA processor  and a TAP which is omitted for purposes of clarity. The JTAG scan chain  traverses four devices . The four devices  are denoted, in the direction from TDI to TDO, as Device , Device , Device , and Device , each of which includes a plurality of registers . The SUT  includes eight instruments  disposed on the devices  and accessible via the JTAG scan chain . The eight instruments  are denoted, in the direction from TDI to TDO, as Instruments . and . (which are disposed, in series, on Device ), Instruments . and . (which are disposed, in series, on Device ), Instrument  (which is disposed on Device ), and Instruments  ., ., and . (which are disposed, in series, on Device ). The eight instruments  are considered to be separate segments of the JTAG scan chain  (e.g., as depicted and described herein with respect to one or more of ). The segments may be controlled individually and, thus, result in scan segment composition  depicted in  (i.e., the JTAG scan chain  may be considered to be composed of a sequence of eight scan segments which correspond to the eight instruments , rather than being composed of each of the registers  of each of the devices  of the JTAG scan chain ).","The TISA processor  is configured to receive TISA operations from user application , based on a schedule determined by scheduler , for testing of SUT . The TISA operations may include TISA instructions (and, optionally, also may include other types of information). The TISA processor  is configured to process the TISA operations to generate the associated input test data to be applied to SUT  and, optionally, to receive output test data generated by SUT . It is noted that, for at least some embodiments, the operation of TISA processor  may be better understood by way of reference to . It is noted that, when the operations are executed by the TISA processor  and the input test data is updated, the TISA operations will be aligned within the correct positions within the JTAG scan chain  (i.e., the TISA operations will be associated with the scan segments for which the TISA operations are intended, respectively). An example is depicted and described with respect to . Namely,  depicts an exemplary TISA segment concatenation for an exemplary scan chain composition. As described hereinabove, a TISA processor (such as TISA processor  depicted and described with respect to ) is configured to execute operations on partial sections of the scan chain (the segments), and to freeze all signals, including the clock, between operations. In , lines TCK, TMS, TDI depict the JTAG outputs of a TISA processor, while TDI depict the input from a System Under Test. In , \u201cFSM\u201d depicts the state of the JTAG Finite State Machine belonging to the SUT, and it can be seen how its state transitions are independent from the pauses between segment operations. In , the last two lines show how the input\/output streams coming from TDI and TDO, respectively, are distributed between the different segments.","The scheduler  is configured to receive access requests from the user application , perform position-based scheduling of the access requests, and respond to the user application  with access responses indicative as to when the user application  may perform TISA operations (associated with the access requests\/responses, respectively) on portions of the JTAG scan chain  of SUT .","The scheduler  includes one or more scheduler core processes  and a Circuit Model .","The scheduler core processes  are processes configured to perform position-based scheduling of the access requests received at the scheduler  using the Circuit Model . An exemplary scheduler core process  is depicted and described with respect to . The scheduler core processes  may be better understood by first considering the Circuit Model .","The Circuit Model  is a simplified model of the SUT  that is specified in terms of the scan segments of which JTAG scan chain  of SUT  is composed.","The Circuit Model  is configured to specify the order of the scan segments of the SUT  (e.g., as depicted in scan segment composition ). The Circuit Model  also may include any other information suitable for use by scheduler  in determining scheduling of access requests\/responses for execution of the corresponding TISA operations by TISA processor .","In one embodiment, the Circuit Model  is implemented using a tree structure. In this embodiment, each segment of which the JTAG scan chain  is composed is represented as a leaf node in the tree, and the remainder of the tree includes super-segments (disposed over one or more hierarchical levels) which represent the hierarchical nature of the JTAG scan chain . The root node of the tree represents the SUT . It is noted that the Circuit Model  as represented by the tree has a number of properties, including: (1) each node of the tree can be uniquely identified according to its path in the tree, (2) the Circuit Model  is intrinsically hierarchal, such that systems may be composed by simply adding the entire sub-tree to the Circuit Model , and (3) a simple depth-first (also known as post-order) traversal of the tree provides the correct order of segment accesses on the JTAG scan chain  of SUT . An exemplary scan chain composition and its associated Circuit Model for use as Circuit Model  of SUT  are depicted in .",{"@attributes":{"id":"p-0413","num":"0523"},"figref":["FIG. 21","FIG. 19"]},"As depicted in , exemplary scan chain composition  is configured such that Device is composed of three segments corresponding to Instruments ., ., and ., Device is composed of one segment corresponding to Instrument , Device  is composed of two segments corresponding to Instruments . and ., and Device  is composed of two segments corresponding to Instruments . and ..","As further depicted in , exemplary Circuit Model  is a tree-based model of exemplary scan chain composition . The root of exemplary Circuit Model  (denoted as SUT) corresponds to SUT . The next level of exemplary Circuit Model  include four nodes (denoted as Device , Instrument , Device , and Device , where the nodes for Devices , , and  each have additional nodes subtending therefrom and the node for Instrument  is a leaf node. The bottom level of exemplary Circuit Model  includes seven leaf nodes corresponding to the seven segments of which some of the Instruments  are composed (namely, the Device  node is a parent to three leaf nodes which represent Instruments ., ., and . of which Device  is composed; the Device  node is a parent to two leaf nodes which represent Instruments . and . of which Device  is composed; the Device  node is a parent to two leaf nodes which represent Instruments . and . of which Device  is composed). In the Circuit Model , the scan segments are depicted as rectangular-shaped nodes and the remaining nodes are depicted as oval-shaped nodes.","In the Circuit Model , each scan segment can be uniquely identified by its path in the tree. For example, the segment that represents Instrument . is uniquely identified by the path SUT.Device.Instrument.., the segment that represents Instrument  is uniquely identified by the path SUT.Instrument, the segment that represents Instrument . is uniquely identified by the path SUT.Device.Instrument., and so forth. As such, the exemplary scan chain composition  may be obtained from exemplary Circuit Model  by performing a depth-first traversal of the exemplary Circuit Model . In one embodiment, in order to assist processing using such paths, the scheduler  may be configured to associated unique identifiers with the paths such that the unique identifiers may be used to represent the paths, respectively (e.g., using unique integer identifiers which may be easier to handle than character strings, although it will be appreciated that any suitable type of unique identifiers may be used to represent the paths).","The scheduler  receives unordered access requests from user application , determines scheduling of the unordered access requests based on the scan segment composition  as determined by scheduler  from Circuit Model  of SUT  which is available to scheduler , and provides access responses to user application  where the access responses are indicative as to when the user application  may provide associated TISA operations (associated with the access requests and access responses, respectively) to TISA processor  for execution. In this sense, scheduler  processes an unordered set of access requests received from user application  and generates an ordered set of access responses (e.g., ordered in accordance with scan segment composition  as determined by scheduler  from Circuit Model  of SUT ), such that scheduler  may then instruct user application  as to the order in which TISA operations associated with the access requests may be provided to TISA processor  for processing by TISA processor .","The scheduler  may be configured to perform position-based scheduling of access requests using the concept of critical section, which may be used to arbitrate mutual exclusive access in multi-tasking operating systems. An exemplary process by which scheduler  may perform position-based scheduling of access requests using the concept of critical section is depicted and described with respect to .","The user application  is configured to issue access requests associated with testing of SUT . The user application  may issue access requests for any of the instruments . The user application  does not have knowledge of the scan segment composition  of SUT ; rather, the user application  merely issues access requests without accounting for the order in which the TISA operations associated with the access requests may be or should be applied to the SUT . The access requests issued by user application  are received by scheduler  for scheduling based on the scan segment composition  as determined by the scheduler  from the circuit model of the SUT . The user application  is further configured to receive access responses from the scheduler  in response to the access requests, and to provide TISA operations to the TISA processor  in response to the access responses. An exemplary process by which the user application  may request and receive access to portions of JTAG scan chain  using the concept of critical section is depicted and described with respect to .","As depicted in , user application  includes a plurality of user application elements -(collectively, user application elements ), which may operate in a concurrent fashion. The access request sent by the user application  may be sent by ones of the user application elements  and, similarly, the access responses received and processed by the user application  may be received by processed by ones of the user application elements  from which the associated access requests are sent. The user application elements  may be application threads or any other hardware and\/or software based elements configured for use in sending access requests and receiving and processing access responses.","As depicted in , user application  sends unordered access requests requesting access to segments of JTAG scan chain . The scheduler  receives the access requests from user application . The set of unordered access requests includes access requests for the following segments in the following initial order: Instrument ., Instrument ., Instrument ., Instrument , Instrument ., Instrument ., Instrument ., and Instrument .. The scheduler  determines scheduling of the access requests using Circuit Model . The scheduler  determines the ordering of the scan segments of JTAG scan chain  (i.e., scan segment composition ) using the Circuit Model . The scheduler  determines the ordering of the access requests based on the scan segment composition  determined using Circuit Model . The scheduler  responds to the access requests with respective access responses provided to the user application. The set of ordered access responses includes access responses for the following segments in the following order: Instrument ., Instrument ,, Instrument ., Instrument , Instrument ., Instrument ., Instrument ., and Instrument .. The user application  receives the set of ordered access responses from scheduler . The user application  then performs TISA operations on the JTAG scan chain  of SUT  based on the ordering of the segments as specified by the set of ordered access responses (namely, in the following order: Instrument ., Instrument ,, Instrument ., Instrument , Instrument ., Instrument ., Instrument ., and Instrument .).",{"@attributes":{"id":"p-0422","num":"0532"},"figref":"FIG. 22"},"At step , the user application  sends an access request (depicted as REQUEST) to the scheduler .","The user application  may initiate the access request whenever the user application needs to access a resource of the SUT .","The access request is configured to request access by the user application  to a resource of the SUT . The resource of the access request may be any suitable type of resource (e.g., a scan segment of the SUT  and\/or any other suitable type of resource).","The access request may identify the resource of SUT  in any suitable manner. In one embodiment, for example, the access request may include a unique identifier (which may be denoted herein as a Unique Identifier (UID)) specifying the resource of the SUT  to which the user application  is requesting access.","It is noted that the access request does not need to include the associated test data to be scanned for the resource to which access is requested, at least because the scheduler  is configured to return an associated access response to the user application  (at which time user application  may then use the relevant test data, available at and\/or to the user application , when providing the associated TISA operation(s) to TISA processor ).","The user application  then waits for an access response from the scheduler , during which time the user application  may operate in any suitable manner (e.g., entering a sleep state or other suitable waiting state, initiating one or more additional access requests to scheduler , performing one or more other processing functions, and the like).","At step , the scheduler  determines authorization of the access request.","The scheduler  is configured to receive multiple unordered access requests for access to resources of SUT  (including the REQUEST depicted in  and one or more other access requests omitted from FIG.  for purposes of clarity) and process the multiple unordered access requests for determining scheduling of the unordered access requests based on the scan segment composition  as determined by scheduler  from Circuit Model  of SUT . In this sense, for the specific access request of , the scheduler  is configured to determine the time at which the user application  is granted access to the resource of the SUT  that was specified in the access request of  (within the context of authorizing other access requests for resources of SUT  that are received from user application  which, again, are omitted from  for purposes of clarity).","The scheduler  processes the Circuit Model  to determine scheduling of the access request. It is noted that scheduler  may explore the Circuit Model  in any suitable manner. For example, exploration of the Circuit Model  may be launched following a precise strategy (e.g., all leaves are marked as pending, time-triggered, explicit requests, and the like). For example, upon receipt of the access request for the scan segment, the scheduler  marks the associated leaf node of Circuit Model  (which corresponds to the requested scan segment) as pending. For example, if during exploration a segment is encountered that is not pending, a default sequence is shifted instead (e.g., the sequence can be fixed, can be included inside of the leaf (e.g., defined by the instrument provider), and the like). It is noted that, in the case when an instrument operation might be perturbed by scan operations, the leaf node may ask the scheduler  to inhibit accesses for a certain length of time.","At step , the scheduler  sends an access response to the user application  (depicted as RESPONSE), responsive to the access request (REQUEST) received from the user application .","The access response includes the unique identifier provided in the access request (again, which may be denoted herein as a UID), which specifies the resource(s) of the SUT  to which the user application  has been granted access by scheduler .","The access response indicates to the user application  that it is the only entity with access rights to the resource of SUT  that is identified by the UID (i.e., the resource of SUT  that is identified by the UID is locked for use by the user application  to which access was granted by the scheduler ). Accordingly, in conjunction with sending the access response, the scheduler  locks the resource of SUT  that is identified by the UID. The scheduler  may lock the resource of SUT  that is identified by the UID in any suitable manner (e.g., via changing of one or more values associated with the node of the Circuit Model  that is associated with the resource of SUT  that is identified by the UID, or in any other suitable manner).","At step , after receiving the access response, the user application  has access rights to the resource of SUT  that is identified by the UID (with a guarantee that it is the only entity that currently has access rights to the resource of SUT  that is identified by the UID) and performs one or more TISA operations on the resource of SUT  that is identified by the UID. The operations may include sending one or more TISA operations, related to the resource of SUT  that is identified by the UID, from user application  to TISA processor  for execution by TISA processor . The operation(s) performed by user application  may include any suitable number of TISA accesses via TISA processor  to the SUT . The user application  may continue to use the resource of SUT  that is identified by the UID until it no longer needs access to the resource of SUT  that is identified by the UID, at which time the user application  may initiate release of the resource of SUT  that is identified by the UID.","At step , the user application  sends a resource release message (depicted as RELEASE) to scheduler . The user application  sends the resource release message when the user application no longer needs access to the resource of SUT  for which access was originally requested. The resource release message includes the unique identifier provided in the access request (again, which may be denoted herein as a UID), which specifies the resource of the SUT  to which the user application  has been granted access by scheduler . The scheduler , upon receiving the resource release message, releases the resource of SUT  that is identified by the UID. The scheduler  may release the resource of SUT  that is identified by the UID in any suitable manner (e.g., via changing of one or more values associated with the node of the Circuit Model  that is associated with the resource of SUT  that is identified by the UID).","It is noted that, although primarily depicted and described with respect to an embodiment in which an access request is configured to request access to a single resource, access to multiple resources may be requested via one or more associated access requests.","It is noted that process  is repeated for each access request that is initiated by user application , thereby enabling the scheduler  to authorize multiple access requests in a manner that is coherent with JTAG scan chain  and, similarly, enabling user application  to access portions of JTAG scan chain  in an order that is based on scan segment composition  of JTAG scan chain  without requiring user application to computer the complete vector for the entire JTAG scan chain . In this sense, it is noted that from the perspective of user application , process  can be performed concurrently by various one of the user application elements  as various ones of the user application elements  issue access requests and receive and process associated access responses. It is noted that process  may be implemented in any suitable manner. In one embodiment, for example, process  may be implemented using semaphores and mutexes. For example, in reference to common use of computer science techniques and, more specifically, to Dijkstra's semaphore formulation, a REQUEST  is equivalent to a \u201cP\u201d operation while a RELEASE  is equivalent to a \u201cV\u201d operation.","It is noted that various embodiments of the position-based scheduling capability enable simplification of the user application . In the absence of the position-based scheduling capability, the user application  would need to maintain an associated Circuit Model that models the entire SUT . For example, the user application  would need to maintain a Circuit Model which provides a description of SUT  that includes (1) for each device in the SUT , a structure description of the device (e.g., the register(s) in the device, the instruction(s) used to access the register(s), the length(s) of the register(s), and the like) and (2) a linked list which describes the connections between the devices of SUT . Similarly, in the absence of the position-based scheduling capability, when the user application  wants to write something to a particular register in SUT  the user application  would need to find the device, find the register in that device, and update the register, and then, for each associated scan operation, also would need to proceed through the linked list of devices in order to gather all of the vector information for the current register that is active, write out a super-vector representing all of the devices in the scan chain of SUT , read the output data, process the output data in order to put the output data back into the Circuit Model of SUT  in order to analyze the output data. The position-based scheduling capability obviates the need for user application  to maintain such a Circuit Model that describes the entire SUT ; rather, the user application  would merely need to be aware of portions of SUT  in which it is interested (e.g., as denoted by its UID). The position-based scheduling capability also obviates the need for user application  to deal with the entire scan chain of the SUT  when performing operations on SUT  (e.g., obviates the need for the user application  to construct a super input vector for the entire scan chain of SUT  and process a super output vector for the entire scan chain of SUT  when performing operations on SUT , including when performing operations on only a portion of SUT ). Rather, in TISA, the use of segments (and the associated representation of the scan segments in a Circuit Model that is a tree-based representation in which a depth-first traversal of the tree yields the composition of the scan segments of which the scan chain of SUT  is composed), enables delegation of operations from user application  in the TISA model (e.g., where an operation intended for a particular device or register represented by a particular scan segment can be handled by sending the operation) to the node of the Circuit Model which represents that scan segment such that the node can perform a scan operation with TISA that is specific only to that device or register. In other words, it is not necessary to construct the entire vector for the entire scan chain of SUT  in order to perform the intended operation. It is noted that this is a huge boost to portability for the user application , which does not need to be adapted to the actual scan chain. For example, if the user application  is only interested in interacting with Device  of SUT  (e.g., user application  is an emulation application and Device  is a microprocessor chip), user application  is (1) not required to be aware of Device , Device , or Device  of SUT  and, thus, is not required to maintain a Circuit Model including information for Device , Device , or Device  of SUT  and (2) not required to construct a super input vector for the entire scan chain of SUT  and process a super output vector for the entire scan chain of SUT  when performing operations on SUT . Rather, the user application  merely needs to send an access request to scheduler  where the access request indicates the operation that the user application  would like to perform on Device  (e.g., update a particular register in Device , or any other suitable operation). In this manner, handling of requested operations is transformed from a modelling problem (including the associated processing and efficiency problems that are associated therewith when trying to construct a super input vector from structure description and linked list information and process an associated super output vector in order to analyze the desired results) into a scheduling problem (which may be handled by scheduler  using various computer science functions). Therefore, various embodiments of the position-based scheduling capability are more efficient than existing testing capabilities.","Although omitted for purposes of clarity, it is noted that the various elements of scheduler execution architecture  may be implemented using one or more devices and, similarly, that communication between the various elements of scheduler execution architecture  may be performed in any suitable manner (e.g., depending on the number of devices used, the locations of the device, and the like). It is further noted that various elements of scheduler execution architecture may be implemented using hardware and\/or software. For example, scheduler  and user application  each may be implemented in hardware or as a software-based module stored in one or more memories and configured for execution by one or more processors (e.g., TISA processor  and\/or any other suitable processor(s), which may depend on the locations of TISA processor , scheduler , and user application ).","In one embodiment, for example, TISA processor , scheduler , and user application  may be implemented in separate devices which may communicate with each other via one or more communication networks (e.g., via an Ethernet network, the Internet, and the like, as well as various combinations thereof).","In one embodiment, for example, TISA processor  and scheduler  may be co-located in a single device and user application  may be implemented in a separate device. For example, scheduler  may be a software-based module stored in one or more memories accessible to one or more processors (e.g., TISA processor  and\/or one or more other processors which may cooperate with TISA processor ) configured to execute the scheduler  in order to provide the various functions depicted and described herein. For example, user application  may be implemented in hardware or as a software-based module stored in one or more memories and configured for execution by one or more processors to provide the various functions depicted and described herein. For example, communication between scheduler  and user application  may be via one or more communication networks (e.g., via an Ethernet network, the Internet, and the like, as well as various combinations thereof).","In one embodiment, for example, TISA processor  and user application  may be co-located in a single device and scheduler  may be implemented in a separate device. For example, user application  may be a software-based module stored in one or more memories accessible to one or more processors (e.g., TISA processor  and\/or one or more other processors which may cooperate with TISA processor ) configured to execute the user application  in order to provide the various functions depicted and described herein. For example, scheduler  may be implemented in hardware or as a software-based module stored in one or more memories and configured for being executed by one or more processors to provide the various functions depicted and described herein. For example, communication between user application  and scheduler  may be via one or more communication networks (e.g., via an Ethernet network, the Internet, and the like, as well as various combinations thereof).","In one embodiment, for example, scheduler  and user application  may be co-located in a single device and TISA processor  may be implemented as a separate device. For example, scheduler  and user application  each may be implemented in hardware or as a software-based module stored in one or more memories and configured to be executed by one or more processors to provide the various functions depicted and described herein. For example, communication between user application  and TISA processor  may be via one or more communication networks (e.g., via an Ethernet network, the Internet, and the like, as well as various combinations thereof).","In one embodiment, for example, TISA processor , scheduler , and user application  may be co-located in a single device. For example, scheduler , and user application  may be software-based modules stored in one or more memories accessible to one or more processors (e.g., TISA processor  and\/or one or more other processors which may cooperate with TISA processor ) configured to execute the scheduler  and user application  to provide the various functions depicted and described herein. An exemplary embodiment is depicted and described with respect to .",{"@attributes":{"id":"p-0446","num":"0556"},"figref":"FIG. 23"},"As depicted in , scheduler execution architecture , which is similar to the scheduler execution architecture  of , includes a system under test (SUT) , a main CPU , a scheduler , and a user application . For purposes of clarity, it is noted that SUT  is equivalent to SUT , main CPU  is equivalent to TISA processor , scheduler  is equivalent to scheduler , and user application  is equivalent to user application  (where segment threads to are equivalent to user application elements to , respectively).","The SUT  includes a JTAG scan chain  accessible via the main CPU  and a TAP (which is omitted for purposes of clarity). The","JTAG scan chain  has an associated scan chain composition  composed of a plurality of scan segments -(collectively, scan segments ).","The main CPU  supports a TISA , such that the main CPU  is configured to function as a TISA processor (e.g., in a manner similar to TISA processor  depicted and described with respect to ).","The main CPU  has access to a memory , which stores scheduler  and user application .","The scheduler  is configured to receive access requests from the user application , perform position-based scheduling of the access requests, and respond to the user application  with access responses indicative as to when the user application  may perform TISA operations on portions of the JTAG scan chain  of SUT  that are associated with the access requests\/responses, respectively. For example, the TISA operations may include providing TISA operations to the TISA processor  for processing.","The scheduler  includes one or more scheduler core processes  and a Circuit Model .","The scheduler core processes  are processes configured to perform position-based scheduling of the access requests received at the scheduler  using the Circuit Model . The scheduler  also includes an access Application Programming Interface (API)  which provides an API via which user application  accesses scheduler core processes . The access API  is configured for enabling the user application  to communicate with the scheduler  using an access scheduling protocol (e.g., access scheduling protocol  depicted and described with respect to ). The scheduler core processes  may be configured to execute portions of the access scheduling protocol depicted and described as being performed by scheduler .","The Circuit Model  is a simplified model of the SUT  that is specified in terms of the scan segments  of which the JTAG scan chain  of SUT  is composed. The scheduler  also includes a circuit model Application Programming Interface (API)  which provides an API via which user application  accesses Circuit Model . The circuit model API  is configured for enabling the user application  to build and modify the Circuit Model . It is noted that the Circuit Model  may be built\/modified via circuit model API  as depicted and described with respect to exemplary circuit model  of .","The user application  is configured to issue access requests associated with testing of SUT . The user application  may issue access requests for any of the scan segments  of SUT . The user application  does not have knowledge of the scan segment composition  of SUT ; rather, the user application  merely issues access requests without accounting for the order in which the access requests may be or should be applied to SUT . The access requests issued by user application  are received by scheduler  for scheduling based on the scan segment composition  as determined by the scheduler  from the circuit model of the SUT .","The user application  includes a plurality of scan segment threads -(collectively, scan segment threads ) and a main thread . The scan segment threads  are supported by main thread .","The scan segment threads  of user application  each are configured to communicate with scheduler core processes  via access API  using respective instances of the access scheduling protocol (e.g., the access scheduling protocol  depicted and described with respect to ). In this sense, the scan segment threads  support multi-tasking, as one or more of the scan segment threads  may be involved in access arbitration with scheduler  via access API  at any given time.","The main thread  of user application  is configured to build and modify Circuit Model  of scheduler  via circuit model API  of scheduler .","It is noted that the operation of user application  and scheduler  in testing the SUT  via main CPU  may be better understood when the scheduler execution architecture  of  is reviewed in conjunction with the scheduler execution architecture  of .","As noted herein, main CPU  has access to memory , which stores scheduler  and user application . In this sense, scheduler core processes  of scheduler  may be accessed and executed by main CPU  for providing various functions of scheduler  depicted and described herein. Similarly, segment threads  of user application  may communicate with main CPU  for purposes of performing TISA accesses to JTAG scan chain  of SUT  via TISA . Although primarily depicted and described with respect to use of a single memory , it is noted that scheduler  and\/or user application  may be provided using any suitable number of memories.","It is noted that, in at least some embodiments, scheduler execution architecture  is compatible with various multi-tasking operating systems (OSs) and\/or other types of frameworks. In one embodiment, for example, implementation of scheduler execution architecture  using POSIX allows scheduler execution architecture  to be run as a standalone application that incorporates a reduced thread scheduler. Although primarily depicted and described herein with respect to use of position-based scheduling capability for scheduling of static paths, it is noted that various embodiments of the position-based scheduling capability may support scheduling of dynamic paths. In general, dynamic paths are one of the major limitations of traditional retargeting, primarily due to the fact that dynamic paths force heavy vector regeneration and\/or modification.","In one embodiment of the position-based scheduling capability, a dynamic scan path of a SUT may be supported by enabling one or more dynamic segments to be inserted into and removed from the scan chain of the SUT as needed or desired. In one embodiment, a dynamic segment may be configured to be dynamically inserted into the scan chain or removed from the scan chain via a control entity defined for an SUT, wherein the dynamic segment is represented in the tree as a leaf node having an associated parent node representing the control entity. The control entity may, but is not required to, reside directly adjacent to the dynamic segment in the hierarchy. For example, the dynamic segment could be controlled by some other data register that is multiple segments away. For example, the dynamic segment could be controlled by a separate data register that is accessed via its own instruction in the 1149.1 TAP Controller that is no longer accessible in the scan chain of the SUT, but its state is preserved as defined by the 1149.1 standard. In other words, many different types of representations for control are possible and, thus, the control entity may be implemented in a number of different ways. It is noted that control entity is defined for the SUT in the sense that there exists a predefined description of control aspects of the control entity that can be modelled and controlled by the tool.","In one embodiment of the position-based scheduling capability, scheduling for a dynamic scan path may be supported by representing the dynamic path as a super-segment. This embodiment may be better understood by considering .",{"@attributes":{"id":"p-0465","num":"0575"},"figref":"FIG. 24"},"As depicted in , an exemplary SUT  supports a dynamic scan path in which an element can be inserted into and removed from a JTAG scan chain  of the SUT  dynamically. The SUT  supports two different configurations depending on the value of a cell (illustratively, cell X) that is included in the JTAG scan chain  of SUT . In a first configuration of SUT  (depicted as SUT ), the value of cell X is set such that only the cell X and a static section (denoted as static) are active within the JTAG scan chain . In a second configuration of SUT  (depicted as SUT ), the value of cell X is set such that a dynamic section (denoted as dynamic) is added to the JTAG scan chain  between the cell X and the active section, i.e., the cell X, the dynamic section, and the static section (denoted as static) are active within the JTAG scan chain . The insertion of the dynamic section to JTAG scan chain  and removal of the dynamic section from JTAG scan chain  may be controlled by changing the value of cell X. It is noted that cell X may be implemented using any suitable element (e.g., using the Segment Insertion Bit (SIB) of the IEEE 1687 draft standard, or using any other suitable element(s)).","As further depicted in , exemplary SUT , which supports a dynamic JTAG scan path , may be represented using a Circuit Model . In the Circuit Model , cell X is represented as a super-segment  (represented as the trapezium in ). The cell X has a status associated therewith, such that super-segment  has a status associated therewith. When a depth-first traversal of Circuit Model  is performed, recursion through cell X is dependent on the status of cell X (e.g., recursion through cell X is allowed when the status of cell X is \u201copen\u201d; otherwise, cell X is treated as a leaf segment when the status of cell X is \u201cclosed\u201d).","In one embodiment, the associated scheduler (e.g., scheduler  or scheduler ) is able to adapt on-the-fly based on the current status of Circuit Model , without any need of retargeting.","In one embodiment, the associated scheduler is configured to detect a REQUEST to the \u201cdynamic\u201d node of the Circuit Model  when the \u201cdynamic\u201d node of the Circuit Model  is not active (when the status of cell X is \u201cclosed\u201d such that super-segment  of cell X is closed) and, in response, to generate one or more scan segment operations to open the super-segment  of cell X with which the non-active \u201cdynamic\u201d leaf node is associated (thereby causing the \u201cdynamic\u201d node of the Circuit Model  to become active). More generally, in one embodiment, the scheduler is configured to detect a REQUEST to a non-active leaf node and, in response, to generate one or more scan segment operations to change the status of the associated super-segment (i.e., the super-segment with which the non-active leaf node is associated) from \u201cclosed\u201d to \u201copen\u201d such that the non-active leaf node becomes active. It is noted that the operation of changing of state of a super-segment can be as simple or complex as needed, and in an object-oriented paradigm can be easily delegated by the scheduler  to an implementation method (e.g., using the visitor design pattern, or any other suitable mechanism).","It is noted that, in such embodiments, any suitable set of status values may be used to control depth-first traversal of Circuit Model . In one embodiment, for example, status values of \u201copen\u201d (indicative that traversal of the node is allowed), \u201cclosed\u201d (indicative that recursion ends at this node and the state remains the same), and \u201cpending\u201d (indicative that recursion ends at this node and the state of the node is changed to \u201copen\u201d for the next iteration) may be supported. It is noted that different sets of status values also may be used.","It is noted that, in such embodiments, status of nodes within Circuit Model  may be managed in any suitable manner. In one embodiment, for example, graph coloring may be used to manage the status of nodes of Circuit Model , whereby each node of the Circuit Model  is assigned a color which may be used by the depth-first traversal process to determine the action(s) to take with respect to the node.","Although primarily depicted and described with respect to use of the super-segment  to regulate access to a single dynamic segment, the super-segment  may be used to regulate access to multiple dynamic segments. In this case, the state of the super-segment (i.e., the value of cell X) may determine which one or more dynamic segments are active and the order in which they are to be traversed.",{"@attributes":{"id":"p-0473","num":"0583"},"figref":"FIG. 25"},"As depicted in , steps are performed by the user application, scheduler, and TISA processor used for testing a system under test (e.g., user application , scheduler , and TISA processor  depicted and described with respect to ). Although primarily depicted and described as being performed serially in a particular order, at least a portion of the steps of method  may be performed contemporaneously and\/or in a different order than depicted in .","At step , method  begins. At step , the user application  generates unordered access requests requesting access to respective portions of the system under test. At step , the user application  sends unordered access requests to scheduler . At step , the scheduler  receives the unordered access requests from user application . At step , scheduler  determines scheduling of the unordered access requests using an associated circuit model. At step , scheduler  generates ordered access responses associated with the unordered access requests. At step , the scheduler  sends the ordered access responses to the user application . At step , the user application  receives the ordered access responses from the scheduler . At step , the user application  generates TISA operations associated with the ordered access responses. At step , the user application  sends the TISA operations to the TISA processor . At step , the TISA processor  receives the TISA operations. At step , the TISA processor  processes the TISA operations. At step , method  ends. It is noted that the various steps of method  may be better understood when considered in conjunction with the description of .","Although  are primarily depicted and described herein with respect to supporting position-based scheduling in the testing input direction from the user application  toward the SUT  (e.g., for initiating tests on SUT ), it will be appreciated that the various functions of position-based scheduling may be performed in the opposite order to support position-based scheduling in the testing output direction from the SUT  toward the user application  (e.g., for receiving and analyzing the results of tests initiated for SUT ). In one embodiment, for example, processing may proceed as follows: (1) TISA processor  receives testing output data from SUT  via TDO, processes the testing output data to produce testing output results associated with TISA operations processed by TISA processor  to produce the testing input data provided to SUT , and propagates the testing output results toward user application , and (2) user application  receives the testing output results from TISA processor  and processes the testing output results (e.g., for analyzing the results of tests initiated for SUT ). Although primarily depicted and described within the context of embodiments in which the user application is responsible for providing TISA operations to the TISA processor, it is noted that in one embodiment the scheduler may be responsible for providing TISA operations to the TISA processor. An exemplary embodiment is depicted and described with respect to .",{"@attributes":{"id":"p-0477","num":"0587"},"figref":"FIG. 26"},"As depicted in , the scheduler execution architecture  of  is similar to the scheduler execution architecture  of  with the exception that the scheduler , rather than the user application , is configured to provide the TISA operations to the TISA processor .","The user application  sends unordered access requests to the scheduler . Additionally, user application  also provides associated test data for the access requests to scheduler . The test data may be provided with the access requests and\/or separate from the access requests. The access requests and associated test data may be provided from user application  to scheduler  in any suitable format (e.g., as packets, messages, and the like, as well as various combinations thereof).","The scheduler  receives the unordered access requests and the associated test data of the access requests from user application . The scheduler , rather than providing ordered access responses to the user application  (as depicted and described with respect to ), determines scheduling of the access requests and issues appropriate TISA operations to TISA processor  based on the determined scheduling of the access requests. The scheduler  is configured to use the test data of the access requests in order to generate the TISA operations for the access requests, respectively. The scheduler  issues the TISA operations to TISA processor  based on the scheduling of the access requests\/TISA operations as determined by scheduler .","The TISA processor  receives the TISA operations from scheduler , and processing proceeds as depicted and described with respect to scheduler execution architecture  of ).",{"@attributes":{"id":"p-0482","num":"0592"},"figref":["FIG. 27","FIG. 27","FIG. 19","FIG. 27"],"b":["1940","1930","1920","2700"]},"At step , method  begins. At step , the user application  generates unordered access requests requesting access to respective portions of the system under test. At step , the user application  sends unordered access requests and associated input test data for the access requests to scheduler . At step , the scheduler  receives the unordered access requests from user application . At step , scheduler  determines scheduling of the unordered access requests using an associated circuit model. At step , scheduler  generates TISA operations associated with the scheduled access requests. At step , the scheduler  sends the TISA operations to the TISA processor . At step , the TISA processor  receives the TISA operations. At step , the TISA processor  processes the TISA operations. At step , method  ends. It is noted that the various steps of method  may be better understood when considered in conjunction with the description of .","Although  are primarily depicted and described herein with respect to embodiments in which input testing data is provided from the user application  to scheduler  and scheduler  generates the associated TISA operations to be provided to TISA processor , it is noted that in at least some embodiments (1) the user application  is configured to generate the TISA operations and to provide the TISA operations to the scheduler  for scheduling of the TISA operations and (2) scheduler  is configured to schedule the TISA operations received from user application  and to provide the TISA operations to TISA processor  based on the determined scheduling of the TISA operations. As with the embodiments depicted and described in , the user application  may be configured to send access requests to scheduler  where, rather than just providing the input testing data for the access requests, the user application  provides the TISA operations (and associated input testing data) for the access requests (e.g., as part of the access requests and\/or separate from the access requests, similar to the embodiments depicted and described with respect to ). It is noted that such embodiments obviate the need for the scheduler  to generate the TISA operations, but at the expense of requiring a larger quantity of information to be sent from the user application  to scheduler .","Although  are primarily depicted and described herein with respect to supporting position-based scheduling in the testing input direction from the user application  toward the SUT  (e.g., for initiating tests on SUT ), it will be appreciated that the various functions of position-based scheduling may be performed in the opposite order to support position-based scheduling in the testing output direction from the SUT  toward the user application  (e.g., for receiving and analyzing the results of tests initiated for SUT ). In one embodiment, for example, processing may proceed as follows: (1) TISA processor  receives testing output data from SUT  via TDO, processes the testing output data to produce testing output results associated with TISA operations processed by TISA processor  to produce the testing input data provided to SUT , and propagates the testing output results toward scheduler , (2) scheduler  receives the testing output results from TISA processor  and propagates the testing output results toward user application , and (3) user application  receives the testing output results from scheduler  and processes the testing output results (e.g., for analyzing the results of tests initiated for SUT ).","Although omitted for purposes of clarity, it is noted that communication between the various elements of scheduler execution architecture  may be performed in any suitable manner. Many such embodiments are depicted and described with respect to . It is noted that, in the case of the scheduler execution architecture , where the TISA processor  and the scheduler  are implemented as separate devices communication between the TISA processor  and the scheduler  may be via one or more communication networks (e.g., via an Ethernet network, the Internet, and the like, as well as various combinations thereof).","Although primarily depicted and described herein with respect to embodiments in which the scheduler  is implemented separate from the TISA processor  and the TISA processor  is implemented separate from the SUT , it is noted that the scheduler execution architecture may be implemented in various other ways. In one embodiment, for example, the scheduler  may be embedded on the TISA processor . In one embodiment, for example, the TISA processor  and the scheduler  may be embedded within the SUT . Various other arrangements are contemplated.","Although primarily depicted and described herein with respect to embodiments in which test operations are issued when the scheduler allows the test operations to be issued, in one embodiment issuance of test operations may be deferred using a deferred scheduling capability.",{"@attributes":{"id":"p-0489","num":"0599"},"figref":"FIG. 28"},"As depicted in , deferred scheduler execution architecture  is a modified version of the scheduler execution architecture  depicted and described with respect to .","The deferred scheduler execution architecture  includes SUT , scheduler , and user application , each of which may be configured to function as depicted and described with respect to the embodiments the scheduler execution architecture  of . The deferred scheduler execution architecture  also includes a deferred scheduling module . The deferred scheduling module  includes a TISA module , a reordering buffer module , a vector transformation module , and a JTAG TAP . The TISA module  is disposed between user application  and reordering buffer module . The reordering buffer module  is disposed between TISA module  and vector transformation module . The vector transformation module  is disposed between the reordering buffer module  and the JTAG TAP . The JTAG TAP  is disposed between vector transformation module  and SUT  (or, optionally, one or more additional modules which may be configured to perform other types of operations).","It is noted that deferred scheduling module  and, more specifically, the TISA module , the reordering buffer module , and the vector transformation module , may be implemented using hardware and\/or software.","In one embodiment, for example, TISA module , reordering buffer module , and vector transformation module  may be implemented in hardware (e.g., using one or more hardware components).","In one embodiment, for example, TISA module  and reordering buffer module  are implemented in software (e.g., as one or more software modules configured to run on one or more processors or other suitable hardware) and vector transformation module  is implemented in hardware (e.g., using one or more hardware components).","In one embodiment, for example, TISA module  is implemented in software (e.g., as one or more software modules configured to run on one or more processors or other suitable hardware), and reordering buffer module  and vector transformation module  are implemented in hardware (e.g., using one or more hardware components).","In one embodiment, for example, TISA module , reordering buffer module , and vector transformation module  are all implemented in software (e.g., as one or more software modules configured to run on one or more processors or other suitable hardware).","In at least some implementations, as indicated above, TISA module  may be implemented as a purely software TISA. In one such embodiment, the TISA module  is implemented as a purely software TISA that is configured to access SUT  via a traditional vector JTAG interface. It is noted that use of the deferred scheduler execution architecture  enables such an embodiment, at least because implementation of a purely software TISA with a traditional vector JTAG interface uses a reconstruction of the entire vector from the TISA operations such that it is possible to send the input vector and receive the output vector via the traditional JTAG interface. In this manner, TISA scheduling as depicted and described herein with respect to  may be used even where the JTAG TAP is a traditional JTAG TAP (rather than a TAP designed for TISA, which may includes a gated TCK application or a gated TCK TAP controller supporting gating of the TAP TCK signal).","It is noted that the TISA module , the reordering buffer module , and the vector transformation module  may be implemented using hardware and\/or software in any other suitable manner.","In a direction toward SUT , TISA module , reordering buffer module , and vector transformation module  are configured to perform functions for enabling the TISA operations received at TISA module  to be applied to SUT as a complete input test vector for the scan chain of SUT . The TISA module  is configured to execute TISA operations in order to determine input test data (e.g., input test data bits) for SUT  and to provide the input test data to reordering buffer module . The reordering buffer module  is configured to receive the input test data from TISA module , buffer the input data in a manner enabling reordering of the input test data to form a complete input test vector for the scan chain of SUT , and provide the input test data of the complete input test vector to vector transformation module . The vector transformation module  is configured to receive the input test data of the complete input test vector from reordering buffer module , transform the input test data of the complete input test vector for use by JTAG TAP , and provide the input test data (e.g., input test data bits) of the transformed input test vector to the JTAG TAP .","In a direction from SUT , vector transformation module , reordering buffer module , and TISA module  are configured to perform functions for enabling an output test vector received from the scan chain of SUT  to be mapped back to the TISA operations of the associated input test vector applied to the scan chain of SUT . The vector transformation module  is configured to receive an output test vector including output test data (e.g., output test data bits) from JTAG TAP , apply a vector transformation to the output test vector to provide a transformed output test vector including transformed output test data, and provide the transformed output test data of the transformed output test vector to reordering buffer module . The reordering buffer module  is configured to receive the transformed output test data of the transformed output test vector from vector transformation module , preserve the transformed output test data in a buffer representing the transformed output test data to form a complete output vector for the scan chain of SUT , partition the transformed output test data into buffered segments corresponding to positions and lengths of the corresponding segments, and provide the transformed output test data to TISA module . It is noted that each of the test data segments represented in the reordering buffer module  represents scan segments requested by a user application (in this exemplary embodiment, user application ). The TISA module  is configured to receive the transformed output test data from reordering buffer module , map the transformed output test data to the TISA operations for which the associated output test data was requested, determine the associated user application(s) performing the respective TISA operations (again, in this exemplary embodiment, user application ), and provide test result data to be provided to the user application(s) (e.g., directly where the TISA module  interacts with the user application  directly, or via the scheduler where the TISA module  interacts with the scheduler  and the scheduler interacts with the user application ). In the case in which access requests are issued by multiple user applications and, thus, result in issuance of TISA operations of multiple user applications, the test result data is mapped to the TISA operations of the user applications such that the user applications receive portions of the test result data relevant to the TISA operations that they initiated, respectively.","It is noted that, although omitted for purposes of clarity, the Circuit Model  associated with the SUT  is modified to include the vector transformation module as its root. As depicted in , the exemplary Circuit Model  would include a parent node above the \u201cSUT\u201d node, where the parent node represents the vector transformation module .","It is noted that the use of deferred scheduling, such as via deferred scheduler execution architecture , enables reconstruction of the entire scan chain from its associated scan segments, thereby enabling various types of operations to be performed on the entire scan chain of SUT  (e.g., scrambling, overscan vector operations, and the like, as well as various combinations thereof). For example, in overscan vectors one or more additional bits are added to the scan vector input and, thus, also are being received as part of the scan vector output and must be removed from the scan vector output (i.e., it's not a direct 1:1 relationship in this case), and use of the deferred scheduler execution architecture  enables realignment of the bits of the scan vectors being shifted to account for this type of bit padding.","It is noted that use of deferred scheduling, such as via deferred scheduler execution architecture , enables use of TISA or a TISA-like test instruction set architecture even where gating of TCK is not supported or available.","Although primarily depicted and described herein with respect to an embodiment of a deferred scheduler execution architecture that is a modified version of the scheduler execution architecture  depicted and described with respect to , it is noted that deferred scheduler execution also may be used with the scheduler execution architecture  of . In this embodiment, deferred scheduling module  would be disposed between scheduler  and JTAG TAP  rather than between user application  and JTAG TAP .","Although omitted for purposes of clarity, it is noted that the various elements of deferred scheduler execution architecture  may be implemented using one or more devices and, similarly, that communication between the various elements of deferred scheduler execution architecture  may be performed in any suitable manner (e.g., depending on the number of devices used, the locations of the device, and the like).","It is noted that various elements of deferred scheduler execution architecture  may be implemented using hardware and\/or software. For example, the scheduler  and the user application  each may be implemented in hardware or as a software-based module stored in one or more memories and configured for execution by one or more processors (e.g., TISA module  and\/or any other suitable processor(s), which may depend on the locations of TISA module , scheduler , and user application ). Many such embodiments related to scheduler , user application , and TISA module  (e.g., TISA processor  in ) are depicted and described with respect to . Similarly, for example, as described hereinabove, deferred scheduling module  may be implemented in hardware and\/or software (which may include implementation of each of the elements of the deferred scheduling module  in hardware and\/or software).","It is noted that the deferred scheduling module  may be co-located with JTAG TAP  and separate from user application , may be co-located with user application  and separate from JTAG TAP , may be co-located with JTAG TAP  and user application  (co-located with or separate from scheduler ), or may be separate from both JTAG TAP  and user application . It is noted that such arrangements are in addition to the various arrangements of TISA module  (e.g., TISA processor ), scheduler , and user application  as depicted and described with respect to ). In such embodiments, communication between deferred scheduling module  and JTAG TAP , between deferred scheduling module  and user application  (e.g., in the case of deferred scheduler execution architecture  being implemented as a modified version of scheduler execution architecture  in which user application  is configured to provide the TISA operations for the JTAG TAP ), and between deferred scheduling module  and scheduler  (e.g., in the case of deferred scheduler execution architecture  being implemented as a modified version of scheduler execution architecture  in which scheduler  is configured to provide the TISA operations for the JTAG TAP ) may be provided in any suitable manner (e.g., using direct communication, using communication via one or more communication networks, and the like).","In one embodiment, for example, deferred scheduling module , scheduler , and user application  may be implemented in separate devices which may communicate with each other via one or more communication networks (e.g., via an Ethernet network, the Internet, and the like, as well as various combinations thereof).","In one embodiment, for example, deferred scheduling module  and scheduler  may be co-located in a single device and user application  may be implemented in a separate device. For example, scheduler  may be a software-based module stored in one or more memories accessible to one or more processors (e.g., TISA module  and\/or one or more other processors) configured to execute the scheduler  in order to provide the various functions depicted and described herein. For example, user application  may be implemented in hardware or as a software-based module stored in one or more memories and configured for execution by one or more processors to provide the various functions depicted and described herein. For example, communication between scheduler  and user application  may be via one or more communication networks (e.g., via an Ethernet network, the Internet, and the like, as well as various combinations thereof).","In one embodiment, for example, deferred scheduling module  and user application  may be co-located in a single device and scheduler  may be implemented in a separate device. For example, user application  may be a software-based module stored in one or more memories accessible to one or more processors (e.g., TISA module  and\/or one or more other processors) configured to execute the user application  in order to provide the various functions depicted and described herein. For example, scheduler  may be implemented in hardware or as a software-based module stored in one or more memories and configured for being executed by one or more processors to provide the various functions depicted and described herein. For example, communication between user application  and scheduler  may be via one or more communication networks (e.g., via an Ethernet network, the Internet, and the like, as well as various combinations thereof).","In one embodiment, for example, scheduler  and user application  may be co-located in a single device and deferred scheduling module  may be implemented as a separate device. For example, scheduler  and user application  each may be implemented in hardware or as a software-based module stored in one or more memories and configured to be executed by one or more processors to provide the various functions depicted and described herein. For example, communication between user application  and TISA module  may be via one or more communication networks (e.g., via an Ethernet network, the Internet, and the like, as well as various combinations thereof).","In one embodiment, for example, deferred scheduling module , scheduler , and user application  may be co-located in a single device. For example, TISA processor , scheduler , and user application  may be software-based modules stored in one or more memories executing on one or more processors. For example, scheduler  and user application  may be software-based modules stored in one or more memories accessible to one or more processors which may access and execute the scheduler  and user application  to provide the various functions depicted and described herein. For example, TISA module  may be an application running a library of ISA instructions that emulate the operation of a TISA processor (e.g., the TISA processor ) whereby actual writes and reads to the SUT are deferred by placing the vector data into the reordering buffer module  to later be applied as a unified vector to the SUT. An exemplary embodiment is depicted and described with respect to .",{"@attributes":{"id":"p-0513","num":"0623"},"figref":"FIG. 29"},"As depicted in , deferred scheduler execution architecture  is similar to deferred scheduler execution architecture  of  (and also is a modified version of scheduler execution architecture  of  which depicts an exemplary embodiment of scheduler execution architecture  of ).","The deferred scheduler execution architecture  includes SUT , Main CPU , and memory  of scheduler execution architecture  of , including modifications to the Main CPU  and memory  to support an embodiment of deferred scheduler execution architecture  of  (illustratively, an exemplary embodiment in which deferred scheduler execution architecture  is implemented in software).","The memory , in addition to including scheduler  and user application  of scheduler execution architecture  of , also includes a deferred scheduling module . The deferred scheduling module  includes a TISA module , a reordering buffer module , and a vector transformation module  which are software-based implementations of the TISA module , reordering buffer module , and vector transformation module  of deferred scheduler execution architecture  of , respectively.","The Main CPU , rather than including TISA  of the scheduler execution architecture  of  (since TISA processing is provided by TISA module  of deferred scheduling module  of memory ), includes a JTAG TAP  corresponding to JTAG TAP  of deferred scheduler execution architecture  of .","Although  is primarily depicted and described herein with respect to an embodiment in which the deferred scheduling capability is implemented within software, it will be appreciated (as depicted and described with respect to deferred scheduler execution architecture  of ), that the deferred scheduling capability may be implemented using hardware and\/or software. In one embodiment, for example, vector transformation module  may be implemented as a hardware module outside of memory , while reordering buffer  and TISA module  may still be implemented using software and, thus, may still be stored within memory . In one embodiment, for example, vector transformation module  and reordering buffer  may be implemented as one or more hardware modules outside of memory , while TISA module  may still be implemented using software and, thus, may still be stored within memory . Various other arrangements are contemplated.","Although primarily depicted and described herein with respect to embodiments in which the deferred scheduler execution architecture is implemented based on the scheduler execution architecture  of  (in which the user application  interacts with the TISA processor ), it is noted that the deferred scheduler execution architecture also may be implemented based on the scheduler execution architecture  of  (in which the scheduler  interacts with the TISA processor \/TISA module ). This latter solution has the advantage of presenting a single point of origin for TISA operations (namely, scheduler ), making interfacing and synchronisation with TISA module  or TISA module  much easier.","Although primarily depicted and described herein with respect to embodiments in which the deferred scheduling capability is provided in conjunction with scheduler execution architectures and environments that are depicted and described herein, it is noted that the deferred scheduling capability may be provided in conjunction with any other suitable type of scheduling-based testing architectures and environments.","In many of the embodiments of position-based scheduling that are depicted and described herein, an assumption is made that each of the scan segments of the scan chain of the SUT has an application assigned thereto, such that the applications(s) provide test data sufficient to populate the global scan chain. In many cases, however, one or more of the segments of which the scan chain is composed may not have any application assigned thereto when tests are executed using position-based scheduling. In these cases, data still needs to be provided for these unused segments of the scan chain. In other words, if no application is specifically asking to update the segment and the segment is in series with the allocated segments of applications, the global scan chain scan still needs to have data associated with those gaps in the scan chain. This may be handled in a number of ways.","In one embodiment, for example, the scheduler includes (or at least has access to) default data about each segment of the scan chain (e.g., TISA operations) such that it can provide data to fill any unused segments.","In one embodiment, for example, an application that is configured to deal with unallocated scan segments of the scan chain coordinates with the scheduler to provide data for the unallocated segments such that a complete scan vector can be generated. It is noted that supporting such a capability for providing data for each segment of the scan chain (including for unallocated segments) is particularly relevant in the case of a TISA-based implementation, because even though TISA allows any given application to focus only on a subset of the scan chain rather than the entire scan chain (e.g., on one or more target segments of which the scan chain is composed), the 1149.1 JTAG standard still requires that all segments of the scan chain be scanned in order to complete the entire scan sequence. In one embodiment, it may be included as part of an acknowledgement from the scheduler since the scheduler knows the topology of the entire scan chain.","Although primarily depicted and described herein within the context of providing position-based scheduling in a testing architecture using TISA (and associated TISA operations), it is noted that various embodiments of position-based scheduling may be provided in testing architectures using other types of test instruction sets (and other types of associated test operations). Similarly, although primarily depicted and described herein within the context of providing deferred scheduling in a testing architecture using TISA (and associated TISA operations), it is noted that various embodiments of deferred scheduling may be provided in testing architectures using other types of test instruction sets (and other types of associated test operations).",{"@attributes":{"id":"p-0525","num":"0635"},"figref":["FIG. 30","FIG. 30"],"b":["3000","3002","3004","3005","3006"]},"It should be noted that system testing functions depicted and described herein may be implemented in software and\/or in a combination of software and hardware, e.g., using a general purpose computer, one or more application specific integrated circuits (ASIC), and\/or any other hardware equivalents. In one embodiment, system testing process  can be loaded into memory  and executed by processor  to implement and\/or support implementation of at least a portion of the system testing functions described hereinabove. Thus, system testing process  (including associated data structures) can be stored on a computer readable storage medium or carrier, e.g., RAM memory, magnetic or optical drive or diskette, and the like.","It is contemplated that some of the steps discussed herein as software methods may be implemented within hardware, for example, as circuitry that cooperates with the processor to perform various method steps. Portions of the functions\/elements described herein may be implemented as a computer program product wherein computer instructions, when processed by a computer, adapt the operation of the computer such that the methods and\/or techniques described herein are invoked or otherwise provided. Instructions for invoking the inventive methods may be stored in fixed or removable media, transmitted via a data stream in a broadcast or other signal bearing medium, and\/or stored within a memory within a computing device operating according to the instructions.","Although various embodiments which incorporate the teachings of the present invention have been shown and described in detail herein, those skilled in the art can readily devise many other varied embodiments that still incorporate these teachings."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The teachings presented herein can be readily understood by considering the following detailed description in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIGS. 4A-4E"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 5A and 5B"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 8","FIG. 5A"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 11A"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 11B"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 21","FIG. 19"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 30"}]},"DETDESC":[{},{}]}
