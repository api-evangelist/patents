---
title: Systems and methods for providing an enhanced graphics pipeline
abstract: An enhanced graphics pipeline is provided that enables common core hardware to perform as different components of the graphics pipeline, programmability of primitives including lines and triangles by a component in the pipeline, and a stream output before or simultaneously with the rendering a graphical display with the data in the pipeline. The programmer does not have to optimize the code, as the common core will balance the load of functions necessary and dynamically allocate those instructions on the common core hardware. The programmer may program primitives using algorithms to simplify all vertex calculations by substituting with topology made with lines and triangles. The programmer takes the calculated output data and can read it before or while it is being rendered. Thus, a programmer has greater flexibility in programming. By using the enhanced graphics pipeline, the programmer can optimize the usage of the hardware in the pipeline, program vertex, line or triangle topologies altogether rather than each vertex alone, and read any calculated data from memory where the pipeline can output the calculated information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09064334&OS=09064334&RS=09064334
owner: MICROSOFT TECHNOLOGY LICENSING, LLC
number: 09064334
owner_city: Redmond
owner_country: US
publication_date: 20110603
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","COPYRIGHT NOTICE AND PERMISSION","FIELD OF THE INVENTION","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE ILLUSTRATIVE EMBODIMENT","Overview"],"p":["This application is a continuation of U.S. patent application Ser. No. 10\/933,850, filed Sep. 3, 2004, which is now U.S. Pat. No. 7,978,205, issued Jul. 12, 2011, which claims the benefit of U.S. Provisional Application No. 60\/567,490 filed May 3, 2004; the contents of both are incorporated by reference herein in their entirety.","This application is related by subject matter to U.S. Pat. No. 7,570,267 issued Aug. 4, 2009, and U.S. Pat. No. 7,671,862 issued Mar. 2, 2010. The contents of each of the above-referenced patents are incorporated by reference herein in their entirety.","A portion of the disclosure of this patent document may contain material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent files or records, but otherwise reserves all copyright rights whatsoever. The following notice shall apply to this document: Copyright\u00a92003-2004, Microsoft Corp.","The present invention is directed to a graphics processing unit (GPU) that enables an enhanced graphics pipeline using software developed for hardware to add new and improved functionality in the graphics pipeline.","Computer systems are commonly used for displaying graphical objects on a display screen. The purpose of three dimensional (3-D) computer graphics is generally to create two-dimensional (2-D) images on a computer screen that realistically represent an object or objects in three dimensions. In the real world, objects occupy three dimensions having a real height, a real width and a real depth. A photograph is an example of a 2-D representation of a 3-D space. 3-D computer graphics are generally like a photograph in that they represent a 3-D world on the 2-D space of a computer screen, except the underlying image is generally modeled with 3-D geometry and surface textures.","Images created with 3-D computer graphics are used in a wide range of applications, from video entertainment games to aircraft flight simulators, to portray in a realistic manner an individual's view of a scene at a given point in time. Well-known examples of 3-D computer graphics include special effects in Hollywood films such as Terminator II, Jurassic Park, Toy Story and the like.","One industry that has seen a particularly tremendous amount of growth in the last few years is the computer game industry and the current generation of computer games apply 3-D graphics techniques in an ever increasing fashion. At the same time, the speed of play is driven faster and faster. This combination has fueled a genuine need for rapid and flexible rendering of 3-D graphics in relatively inexpensive systems.","To create a 3-D computer graphical representation, typically, the objects to be depicted are represented as mathematical models within the computer. For instance, 3-D models can be made up of geometric points within a coordinate system consisting of an x, y and z axis, for example, corresponding to width, height, and depth, respectively. Objects are defined by a series of points, called vertices. The location of a point, or vertex, is defined by its x, y and z coordinates (or other coordinate system). In graphics terminology, one vertex is a point, two vertices define a line, or a line segment, and three vertices define a triangle where all three are \u201cprimitives.\u201d When three or more of these points are connected, a polygon is formed, with the triangle being the simplest polygon.","Rendering and displaying three dimensional (3-D) graphics on screen typically involves many calculations and computations. In a simple graphics system, such computations occur according to some level of cooperative or shared processing by the central processing unit (CPU) and the graphics processing unit (GPU). In an exemplary scenario, after instructions are processed and some initial computations occur in the CPU, a set of coordinate points or vertices that define the object to be rendered are stored in video memory for further processing by the GPU in the graphics pipeline. A tessellator may break the graphics data down into simple polygons according to predetermined algorithms designed to efficiently cover the surface of the object being represented\u2014this is known as tessellation. Currently, in most graphics pipelines, the data may then be operated upon by one or more procedural shaders, depending upon the instructions that are delivered to the GPU.","Procedural shaders are specialized processing subunits of the GPU for performing specialized operations on graphics data. An example of a procedural shader is a vertex shader, which generally operates on vertices. For instance, a vertex shader can apply computations of positions, colors and texturing coordinates to individual vertices. Vertex shaders perform either fixed or programmable function computations on streams of vertices specified in video memory of the graphics pipeline. Vertex shaders cannot generate additional geometry (vertices), but rather operate on the vertices that are specified for algorithmic transformation via the program downloaded to the vertex shader from the host.","Generally staged after the vertex shader, another example of a procedural shader is a pixel shader. For instance, the outputs of the vertex shader can be passed through a non-programmable unit, called the setup engine, which is a non-procedural shader unit that defines the gamut of pixels on which the pixel shader operates. The gamut of pixels can then be operated on by a pixel shader, which in turn operates on each individual pixel. From the pixel shader, the output values are sent to the frame buffer where they wait to be displayed to the screen, or await retrieval by the host system. While 3-D geometry is generally meshed together with triangles (sets of 3 vertices), currently, there are no procedural shaders that operate directly upon triangles as such (sets of three related vertices), or line segments, or lines, either (sets of two related vertices).","Where programmable, it is noted that the term \u201cshader\u201d is subject to misleading use because a \u201cshader\u201d can refer to the hardware subunit of the GPU that performs the shading and a \u201cshader\u201d can refer to the set of instructions or tokens downloaded to the GPU that are subsequently loaded into memory, e.g., register storage, used by the shader (hardware) to perform the shading. The term can also refer to both working together. Thus, while sometimes the word is used herein generically to refer to either, and accordingly, should be taken to encompass both meanings, where the term \u201csubunit\u201d is also used in connection with the term shader, the terms should be construed to refer to the subunit of the GPU that performs the processing associated with the shading.","It is also noted that the term \u201cframe buffer\u201d in today's graphics architectures does not generally refer to a pre-partitioned, pre-allocated and pre-defined portion of video memory reserved solely for the output of the setup engine or pixel processing unit of the graphics processing unit, but rather the frame buffer generally refers to any memory (generally video memory included for interoperation with the GPU) used in connection with rasterization and\/or digital to analog converter (DAC)-out processes. In this regard, though the term rasterization is sometimes used more generally, the processing performed in connection with pixel processing or setup engine processing in the graphics pipeline is generally referred to as rasterization. Scan-out or DAC-out, on the other hand, is the process of transmitting signals to a monitor or LCD based on the contents of the frame buffer.","Today, the values in the frame buffer may be used for purposes other than for display to a screen, but such use is limited. For instance, it may be desired to return the values to an application on the host after they have been operated on by a pixel shader or vertex shader for saving, printing, further transformation, etc. In these instances, the values \u201ctechnically\u201d may be read; however, retrieving the values in video memory, other than the limited portions devoted to buffering images for display, is an extremely arduous task that requires cooperation with host memory, the CPU and advanced knowledge about how video memory is arranged for use in connection with the particular graphics hardware. This is especially true if any portion of the video memory is to be read other than the frame buffer. While not impossible, in practice, it is far from straightforward to read the intermediate storage of video memory used for output by the tessellator, vertex shaders and pixel shaders. In some cases, the outputs of tessellators, vertex shaders and pixel shaders may never reach video memory, but instead may be limited to a specialized data path for use between GPU graphics processing stages (e.g., the output from a vertex shader is generally transmitted to a pixel shader via a pre-defined path without reaching video memory). GPU operations occur so fast and in accordance with specialized architecture that reading intermediate video memory storage in current graphics pipelines is not feasible until the output reaches the frame buffer for rasterization or other operation.","While the frame buffer memory, which receives the output of the pixel shader in a conventional system, may be accessed in a known fashion by the host CPU to save (or otherwise operate on) graphics data, such as images, processed by the GPU, the data must still be accessed and retrieved back to the host CPU for such further operations.  illustrates what must be done to the output of data from a frame buffer memory to achieve further operation upon the data by the graphics pipeline. After operation of a cycle of pipeline processing as represented by the GPU operations and after retrieving the values from the frame buffer back to the host CPU, the CPU then cooperates to send the values back through the graphics pipeline for any further processing. Thus, what is desired in the state of the art is two main things: (1) the ability to re-use, i.e., re-process, data that is output from sub-components, such as a vertex shader or a pixel shader, inside the graphics pipeline prior to reaching frame buffer memory and (2) the ability to do so recursively without implicating host resources and memory.","As illustrated in , computing systems are divided between the host CPU and the graphics hardware. The CPU facilitates the making of calls to graphics APIs by applications and services requesting their use. Conventionally, the application and drivers are located on the CPU side and information from those sources is sent to be displayed on a monitor. First, the information is sent from the CPU to the GPU, as packaged by the CPU according to APIs. Then, the information from the application waits in memory until it is accessed by the vertex shader. After the vertex shader concludes its operations, the information, as output from the vertex shader, is output through a special data path to the pixel shader (placing the output in video memory is generally too slow) until it is accessed by the pixel shader, and the vertex shader sits idle or continues processing more data. After the pixel shader has performed its operations, the information is placed in a frame buffer to be scanned out to a display, or sent back to the host for further operation.","Specialized 3-D graphics APIs have been developed that expose the specialized functionality of today's vertex and pixel shaders. In this regard, a developer is able to download instructions, or small programs, to a vertex shader unit that effectively program the vertex shader to perform specialized behavior. For instance, APIs expose functionality associated with increased numbers of registers in vertex shaders, e.g., specialized vertex shading functionality with respect to floating point numbers at a register level. In addition, it is possible to implement an instruction set that causes the extremely fast vertex shader to return only the fractional portion of floating point numbers. A variety of functionality can be achieved through downloading these instructions, assuming the instruction count limit of the vertex shader and associated the register storage is not exceeded.","Most notably, the functionality of a vertex shader stage is for transformation, lighting and occasionally texture transformation. Basically, transformation is taking position data, the data as to where vertices should be when displayed, and transforming it to data for the monitor, a two dimensional screen space. Traditionally, vertex transformation processes either pass position data without modification or modify the data using matrices. The vertex shader stage is usually limited to performing transformation functions, lighting functions, and some texture functions.","As games increase the level of graphics detail, polygon density increases and lighting and other vertex shading techniques become more important as a vertex processing step. Static lighting, a popular form of lighting due to its high quality, is usually calculated in the vertex shader and stored as a texture. Because it places all the lighting information into textures, it is difficult to modify the information during runtime making dynamic lighting possible only if instructions per vertex are given beforehand. Occasionally, the vertex shader applies a matrix transform to vertex coordinates to texture coordinates. This usually occurs for spherical and cubical reflection mapping and texture animation.","The typical types of lighting carried out by a vertex shader include: positional, directional or spotlight. To add such lighting, the mathematical computations, mostly matrix manipulation, change the vertices to reflect a type of lighting defined in an application. There are different lights, typically mimicking reality where light sources like sunlight and a street light have different properties. These lights can be positional, directional or spotlights creating a multitude of combinations for the vertex shader stage to compute.","Thus, the geometry processing performed using a vertex shader includes some type of transformation to apply to the data, lighting environment for vertices, and material for the texture transformation. Both fixed function and programmable vertex shaders usually function in those ways during that stage in the pipeline. If an application has more information to be processed in these areas, there will be a bottleneck in the vertex shader and other components of the graphics pipeline will sit idle.","With respect to pixel shaders, specialized pixel shading functionality can be achieved by downloading instructions to the pixel shader. For instance, functionality is exposed that provides a linear interpolation mechanism in the pixel shader. Furthermore, the functionality of many different operation modifiers are exposed to developers in connection with instruction sets tailored to pixel shaders. For example, negating, remapping, biasing, and other functionality are extremely useful for many graphics applications for which efficient pixel shading is desirable, yet as they are executed as part of a single instruction they are best expressed as modifiers to that instruction. In short, the above functionality is advantageous for graphics operations, and their functional incorporation into already specialized pixel and vertex shader sets of instructions adds tremendous value from the perspective of ease of development and improved performance. A variety of functionality can thus be achieved through downloading these instructions, assuming the instruction count limit and other hardware limitations of the pixel shader are not exceeded.","Although the pixel shader does perform some matrix operations (e.g., vector transformations for lighting), it may be useful to think of the functionality of a pixel shader as having more or less straightforward mathematical computational capabilities, as opposed to the more complex matrix calculations performed by the vertex shader to transform vertices, wherein each vertex may be represented by many values that require processing. The math involved with a pixel shader is likely floating point calculations and these calculations shade pixels to create reflectivity, glossiness, and bumpiness. There are limitations to the number of calculations that can be performed as information is passed through the pixel shader. Because of these limitations, some information requires multi-pass operations to create multiple textures on each pixel. And each pass encompasses several clock cycles in the pipeline.","The vertex shader computes matrices on a given vertex while the pixel shader can compute most floating point operations. There are instances when a programmer may want to see the mathematical transformations of the vertex and not the values as a screen display. At this point a programmer would have to read memory from the frame buffer which, as discussed, is prohibitive.","Pixel shaders and vertex shaders are able to operate on pixels and vertices. In graphics programming, primitives are the basic shapes out of which any given three dimensional graphic is created. Regularly used and defined primitives include a vertex, a line, and a triangle. Today, pixel shaders and vertex shaders are able to operate with given instructions on a vertex. Even if the shaders are programmable, the shaders are only able to operate on vertices, or points, as primitives.","When these specific shaders, either the pixel or vertex shaders, operate in a graphics pipeline, there are regular bottlenecks due to the operations that occur in each stage. These bottlenecks can be solved if a programmer tries to limit and balance the instructions sent to each shader for every vertex. However, when designing graphics for an intricate 3-D display, like a game, balancing the number of instructions becomes an overwhelming task. Most programmers do not implement any sort of optimization until the graphics are noticeably slower in a given program. Even in the best optimization schemes that a programmer may use, hardware will be found sitting idle and unused waiting for information to pass through, simply because of the variance associated with different kinds of tasks requested of a graphics subsystem. Furthermore, in order to optimize any graphics program, a programmer first must identify the source of the bottleneck which can be a tedious task. Thus, it would be desirable to be able to dynamically reconfigure the cores of a graphics subsystem so that the core processing of the data is automatically tailored to the task being requested to be performed.","Thus, the rendering of graphics data in a computer system is a collection of resource intensive processes. The process of shading, i.e., the process of performing complex algorithms upon set(s) of specialized graphics data structures, used to determine values for certain primitives, such as color, etc. associated with the graphics data structures, exemplifies such a computation intensive and complex process. Generally the process of shading has been normalized to some degree. By passing source code designed to work with a shader into an application, a shader becomes an object that the application may create\/utilize in order to facilitate the efficient drawing of complex video graphics. Vertex shaders and pixel shaders are examples of such shaders.","Thus, the introduction of programmable operations on a per vertex and per pixel basis has become more wide spread in modern graphics hardware. This general programmability enables the potential for limited creative algorithms at increased performance levels. However, in addition to those noted above, there are some limitations to what can be achieved today. Typically, with present day rendering pipelines at the vertex and pixel shaders, a stream of geometry data is input to the vertex shader to perform some operation of the vertices, as a result of which the geometry data is transformed to pixel data, outputting a stream of pixel data. The vertex shader may receive instructions which program the vertex shader to perform specialized functionality, but there are limits to the size and complexity of the vertex shader instructions. Similarly, a pixel shader can optionally perform one or more transformations to the data outputting a stream of pixel data. The pixel shader may also receive instructions which program the pixel shader to perform specialized functionality, but there are limits to the size and complexity to the pixel shader instructions.","Today, programmers regularly use vertex shaders and pixel shaders. The current programmable hardware has somewhat limited programmable mechanisms, however, that do not allow a programmer to specify the re-use of values prior to reaching the end of the pipeline before the values are rasterized. Programmers may try to balance their use of different components in the graphics pipeline to avoid bottlenecks in one or more of the shaders, however, the graphics hardware is fixed. While some specialized hardware is built for specialized tasks having specialized combinations and arrangements of procedural shaders for those specialized tasks, the hardware cannot be rearranged for other tasks. Thus, when performing tasks other than those specialized tasks, and information needs to be modified specifically by instructions for only one of the shaders, the modification may have to wait, perhaps unacceptably so depending upon the application. Furthermore, while vertices can be operated upon by shaders, however, the programmer is unable to specify via graphics APIs operations that work directly on other primitives as such. In other words, with the exception of vertices, a programmer is unable to arbitrarily package primitives for processing in the graphics pipeline as primitives.","Tesselation is a process that typically takes place at the beginning of a graphics pipeline which involves covering of a bounded geometric region without gaps or overlaps by congruent plane figures of one type or a few types. While existing tesselators implement a few basic algorithms for creating a grid of new vertices based on a handful of control-point vertices, the process is based on pre-fixed algorithms and is limited to the front end of the pipeline, and is therefore not programmable to create additional arbitrary geometry in the middle of the pipeline after processing by a procedural shader. Moreover, once vertices are generated by the tesselator, there is nowhere else in the pipeline where vertices can be generated. In other words, today's vertex shaders may be able to receive, process and output vertices, but they are unable to generate new vertices.","It would thus be desirable to implement systems and methods that overcome the shortcomings of present programmability in connection with present graphics pipelines architectures, APIs and hardware due to limitations in instruction count, limitations in form of output and the lack of sharing of data in the pipeline.","In consideration of the above-identified shortcomings of the art, the present invention provides systems and methods for optimizing the use of hardware in the graphics pipeline by having a common core which may function as either a pixel shader, a vertex shader or a geometry shader, where the geometry shader is a programmable shader which can operate on any primitives including triangles, as input and output so that graphics data can be operated upon more directly without transforming the data to vertices, or other intermediate format. Additionally, with the invention, new vertices can be generated inside the pipeline, either at the tessellation stage or by a geometry shader. In one embodiment, a tesselator may be used to generate geometry inside the pipeline programmatically after a procedural shader has operated on graphics data and a geometry shader may be used to supplement existing geometry in a programmable way to achieve on-the-fly alteration of the graphics shapes and effects applied inside the pipeline.","Advantageously, the common core is programmable or dynamically configurable as a pixel shader, a vertex shader, or a geometry shader, so a graphics pipeline can employ all pixel shaders, all vertex shaders, or all geometry shaders, or a combination of shaders based upon optimization of the computational needs for a specific application. The common cores can be dynamically configured (and reconfigured) depending upon the demands on the graphics pipeline made by the host.","With respect to a geometry shader, via a stream output, the graphics APIs and associated hardware of the invention enable application developers to programmably re-circulate data once inside the graphics pipeline without implicating the CPU's help in reading video memory and repackaging the data for re-use by the pipeline. In one embodiment, the invention includes a unique index for every primitive that enters the graphics pipeline which aids in the scheduling of work items that reach the GPU, and accuracy in floating point and integer computations conform to IEEE standards. The geometry shader can also process information about adjacent primitives or pixels of a stream of graphics data being processed by the GPU.","Other advantages and features of the invention are described below.","As mentioned, the present invention enhances a graphics pipeline by adding greater functionality to present hardware by using a dynamically configurable common shader core for pixel shaders, vertex shaders, and geometry shaders. The common shader core allows simplified optimization as identical hardware units for the different shaders provide load balancing by reconfiguring, or disabling a shader as part of the pipeline when it is not needed, thus freeing up resources for stages that remain active. The invention introduces a geometry shader which can operate on primitives including points, lines, and triangles, and advantageously, new geometry can be generated inside the pipeline by a tesselator operating in one of a limited number of pre-set modes, or relatively arbitrarily by a programmable geometry shader. Another embodiment of the invention includes a stream output where primitive data can be streamed out to a buffer for re-use elsewhere in the pipeline, enabling the application of recursive programmatic algorithms inside the pipeline. Additional features include a unique index for every primitive passing through the graphics pipeline, and performing accurate integer and floating point calculations within the graphics pipeline.","Exemplary Networked and Distributed Environments","One of ordinary skill in the art can appreciate that the invention can be implemented in connection with any computer or other client or server device, which can be deployed as part of a computer network, or in a distributed computing environment. In this regard, the present invention pertains to any computer system or environment having any number of memory or storage units, and any number of applications and processes occurring across any number of storage units or volumes, which may be used in connection with processes for a non-limiting implementation of an enhanced graphics pipeline, in accordance with the present invention. The present invention may apply to an environment with server computers and client computers deployed in a network environment or distributed computing environment, having remote or local storage. The present invention may also be applied to standalone computing devices, having programming language functionality, interpretation and execution capabilities for generating, receiving and transmitting information in connection with remote or local services. In a gaming environment, a graphics pipeline is particularly relevant to those computing devices operating in a network or distributed computing environment, and thus enhanced graphic pipeline techniques in accordance with the present invention can be applied with great efficacy in those environments.","Distributed computing provides sharing of computer resources and services by exchange between computing devices and systems. These resources and services include the exchange of information, cache storage and disk storage for files. Distributed computing takes advantage of network connectivity, allowing clients to leverage their collective power to benefit the entire enterprise. In this regard, a variety of devices may have applications, objects or resources that may implicate the graphics pipeline processes of the invention.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 2A","FIG. 2A"],"b":["10","10","110","110","110","14","10","10","110","110","110"],"i":["a","b","a","b","c","a","b","a","b","c"]},"It can also be appreciated that an object, such as , may be hosted on another computing device , , etc. or , , etc. Thus, although the physical environment depicted may show the connected devices as computers, such illustration is merely exemplary and the physical environment may alternatively be depicted or described comprising various digital devices such as PDAs, televisions, MP3 players, etc., software objects such as interfaces, COM objects and the like.","There are a variety of systems, components, and network configurations that support distributed computing environments. For example, computing systems may be connected together by wired or wireless systems, by local networks or widely distributed networks. Currently, many of the networks are coupled to the Internet, which provides an infrastructure for widely distributed computing and encompasses many different networks. Any of the infrastructures may be used for exemplary communications made incident to an enhanced graphics pipeline according to the present invention.","In home networking environments, there are at least four disparate network transport media that may each support a unique protocol, such as Power line, data (both wireless and wired), voice (e.g., telephone) and entertainment media. Most home control devices such as light switches and appliances may use power lines for connectivity. Data Services may enter the home as broadband (e.g., either DSL or Cable modem) and are accessible within the home using either wireless (e.g., HomeRF or 802.11B) or wired (e.g., Home PNA, Cat 5, Ethernet, even power line) connectivity. Voice traffic may enter the home either as wired (e.g., Cat 3) or wireless (e.g., cell phones) and may be distributed within the home using Cat 3 wiring. Entertainment media, or other graphical data, may enter the home either through satellite or cable and is typically distributed in the home using coaxial cable. IEEE 1394 and DVI are also digital interconnects for clusters of media devices. All of these network environments and others that may emerge as protocol standards may be interconnected to form a network, such as an intranet, that may be connected to the outside world by way of the Internet. In short, a variety of disparate sources exist for the storage and transmission of data, and consequently, moving forward, computing devices will require ways of sharing data, such as data accessed or utilized incident to program objects, which make use of the enhanced graphics pipeline in accordance with the present invention.","The Internet commonly refers to the collection of networks and gateways that utilize the TCP\/IP suite of protocols, which are well-known in the art of computer networking. TCP\/IP is an acronym for \u201cTransmission Control Protocol\/Internet Protocol.\u201d The Internet can be described as a system of geographically distributed remote computer networks interconnected by computers executing networking protocols that allow users to interact and share information over the network(s). Because of such wide-spread information sharing, remote networks such as the Internet have thus far generally evolved into an open system for which developers can design software applications for performing specialized operations or services, essentially without restriction.","Thus, the network infrastructure enables a host of network topologies such as client\/server, peer-to-peer, or hybrid architectures. The \u201cclient\u201d is a member of a class or group that uses the services of another class or group to which it is not related. Thus, in computing, a client is a process, i.e., roughly a set of instructions or tasks, that requests a service provided by another program. The client process utilizes the requested service without having to \u201cknow\u201d any working details about the other program or the service itself. In a client\/server architecture, particularly a networked system, a client is usually a computer that accesses shared network resources provided by another computer, e.g., a server. In the example of , computers , , etc. can be thought of as clients and computers , , etc. can be thought of as the server where server , , etc. maintains the data that is then replicated in the client computers , , etc., although any computer can be considered a client, a server, or both, depending on the circumstances. Any of these computing devices may be processing data or requesting services or tasks that may implicate the graphics programming techniques specific to an implementation of the enhanced graphics pipeline in the invention.","A server is typically a remote computer system accessible over a remote or local network, such as the Internet. The client process may be active in a first computer system, and the server process may be active in a second computer system, communicating with one another over a communications medium, thus providing distributed functionality and allowing multiple clients to take advantage of the information-gathering capabilities of the server. Any software objects utilized pursuant to the graphics programming techniques of the enhanced graphics pipeline may be distributed across multiple computing devices or objects.","Client(s) and server(s) communicate with one another utilizing the functionality provided by protocol layer(s). For example, HyperText Transfer Protocol (HTTP) is a common protocol that is used in conjunction with the World Wide Web (WWW), or \u201cthe Web.\u201d Typically, a computer network address such as an Internet Protocol (IP) address or other reference such as a Universal Resource Locator (URL) can be used to identify the server or client computers to each other. The network address can be referred to as a URL address. Communication can be provided over a communications medium, e.g., client(s) and server(s) may be coupled to one another via TCP\/IP connection(s) for high-capacity communication.","Thus,  illustrates an exemplary networked or distributed environment, with a server in communication with client computers via a network\/bus, in which the present invention may be employed. In more detail, a number of servers , , etc., are interconnected via a communications network\/bus , which may be a LAN, WAN, intranet, the Internet, etc., with a number of client or remote computing devices , , , , , etc., such as a portable computer, handheld computer, thin client, networked appliance, or other device, such as a VCR, TV, oven, light, heater and the like in accordance with the present invention. It is thus contemplated that the present invention may apply to any computing device in connection with which it is desirable to implement a graphics interface employing an enhanced graphics pipeline of the invention.","In a network environment in which the communications network\/bus  is the Internet, for example, the servers , , etc. can be Web servers with which the clients , , , , , etc. communicate via any of a number of known protocols such as HTTP. Servers , , etc. may also serve as clients , , , , , etc., as may be characteristic of a distributed computing environment. Communications may be wired or wireless, where appropriate. Client devices , , , , , etc. may or may not communicate via communications network\/bus , and may have independent communications associated therewith. For example, in the case of a TV or VCR, there may or may not be a networked aspect to the control thereof. Each client computer , , , , , etc. and server computer , , etc. may be equipped with various application program modules or objects  and with connections or access to various types of storage elements or objects, across which files or data streams may be stored or to which portion(s) of files or data streams may be downloaded, transmitted or migrated. Any one or more of computers , , , , etc. may be responsible for the maintenance and updating of a database  or other storage element, such as a database or memory  for storing data processed according to the invention. Thus, the present invention can be utilized in a computer network environment having client computers , , etc. that can access and interact with a computer network\/bus  and server computers , , etc. that may interact with client computers , , etc. and other like devices, and databases .","Exemplary Computing Device",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 2B"},"Although not required, the invention can be implemented via an operating system, for use by a developer of services for a device or object, and\/or included within application software that operates in connection with the graphics programming techniques for a graphics pipeline in the invention. Software may be described in the general context of computer-executable instructions, such as program modules, being executed by one or more computers, such as client workstations, servers or other devices. Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations and protocols. Other well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers (PCs), automated teller machines, server computers, hand-held or laptop devices, multi-processor systems, microprocessor-based systems, programmable consumer electronics, network PCs, appliances, lights, environmental control elements, minicomputers, mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network\/bus or other data transmission medium. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices, and client nodes may in turn behave as server nodes.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 2B","b":["100","100","100","100"]},"With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus).","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CDROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD-ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules  and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules  and program data . Operating system , application programs , other program modules  and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A graphics interface , such as Northbridge, may also be connected to the system bus . Northbridge is a chipset that communicates with the CPU, or host processing unit , and assumes responsibility for accelerated graphics port (AGP) communications. One or more graphics processing units (GPUs)  may communicate with graphics interface . In this regard, GPUs  generally include on-chip memory storage, such as register storage and GPUs  communicate with a video memory , wherein the application variables of the invention may have impact. GPUs , however, are but one example of a coprocessor and thus a variety of coprocessing devices may be included in computer , and may include a variety of procedural shaders, such as pixel and vertex shaders. A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface , which may in turn communicate with video memory . In addition to monitor , computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked or distributed environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks\/buses. Such networking environments are commonplace in homes, offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Exemplary Distributed Computing Frameworks or Architectures","Various distributed computing frameworks have been and are being developed in light of the convergence of personal computing and the Internet. Individuals and business users alike are provided with a seamlessly interoperable and Web-enabled interface for applications and computing devices, making computing activities increasingly Web browser or network-oriented.","For example, MICROSOFT\u00ae's managed code platform, i.e., .NET, includes servers, building-block services, such as Web-based data storage and downloadable device software. Generally speaking, the .NET platform provides (1) the ability to make the entire range of computing devices work together and to have user information automatically updated and synchronized on all of them, (2) increased interactive capability for Web pages, enabled by greater use of XML rather than HTML, (3) online services that feature customized access and delivery of products and services to the user from a central starting point for the management of various applications, such as e-mail, for example, or software, such as Office .NET, (4) centralized data storage, which increases efficiency and ease of access to information, as well as synchronization of information among users and devices, (5) the ability to integrate various communications media, such as e-mail, faxes, and telephones, (6) for developers, the ability to create reusable modules, thereby increasing productivity and reducing the number of programming errors and (7) many other cross-platform and language integration features as well.","While some exemplary embodiments herein are described in connection with software residing on a computing device, one or more portions of the invention may also be implemented via an operating system, application programming interface (API) or a \u201cmiddle man\u201d object, a control object, hardware, firmware, intermediate language instructions or objects, etc., such that the methods may be included in, supported in or accessed via all of the languages and services enabled by managed code, such as .NET code, and in other distributed computing frameworks as well.","Systems and Methods for Providing an Enhanced Graphics Pipeline","As described in the background and overview of the invention, the present invention improves upon the state of the graphics processing arts by introducing systems and methods for a graphics pipeline that optimize the use of resources, balance the workload in the graphics pipeline, allow access to calculated information with IEEE compliant integer or floating point values, and provide additional programmability. The invention is directed to geometry processing and programmable shaders. The enhanced graphics pipeline includes the introduction of a common core for all shaders, a stream output for computations that take place in the pipeline and a geometry shader which allows for programming primitives as well as the generation of new geometry.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 3A","FIG. 3A"],"b":["184","184","1","184","1","184","1","184","1","184","1","184","1","184","2","184","1","184","184","1","184","1","184","1","184","4","1","184","2","184","1","184","1"],"i":["a","a","a","a","a","a","b","b","a","c","a"],"sub":["1 ","2","3 ","4","1","3","4"]},"Further embodiments of the invention as reflected by the common core, the geometry shader, the stream output and ability to generate new geometry inside the pipeline of the invention are described in more detail below.","Common Shader Core for Shaders in the Pipeline","As mentioned in the background, a resource contention issue sometimes occurs due to the demands of different components of the graphics pipeline where specific components are required for a specific task, which can lead to a bottleneck in that area of the pipeline. Current graphics pipelines require optimization by the programmer in order to use the resources most effectively in the pipeline. Even with the best optimization schemes, however, prior art hardware itself is fixed, and thus there are times when the pixel shader or vertex shader remain idle, for instance, when the computations involve heavy matrix manipulation and the vertex shader is unable to compute such values fast enough. Thus, the pipeline may have bottlenecks due to excessive processing by the vertex shaders while the pixel shaders sits idle, or vice versa. In accordance with the invention, since shaders are able to function as one another, where a pixel shader can be reconfigured to function as a vertex shader, the underlying resources of the graphics chip can be optimized for the tasks being asked of the graphics chip. Moreover, as mentioned, the invention introduces a new class of shader referred to herein as a geometry shader, that provides another specialized set of processing capabilities. The common core provided by the invention can thus be configured as any of a vertex shader, a pixel shader and a geometry shader.","In an exemplary non limiting embodiment, the GPU contains a farm of units \u2032-, which can thus be scheduled to different stages on demand. This load balancing means programmers do not have to worry about utilizing every stage. Any stage may be dynamically enabled or disabled, and configured or reconfigured, thereby freeing and respecializing resources for stages that are active. The common core is able to perform the vertex shader stage, the geometry shader stage and the pixel shader stage, depending on its configuration.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 4A","b":["184","1","500","510"],"i":"a"},"The shader code receives information from the samplers , the textures  and the constant buffers . The samplers  define how to sample textures. However, memory can also be read without filtering and the sampler is not necessary in every embodiment. Because sampler objects are statically created, it enables the hardware to maintain references of multiple samplers in the flight of the pipeline without having to track changes or flush the pipeline (because the sampler objects maintain their definitions and are not modified). The textures  work with the shader code to provide texture sampling. In this particular embodiment, the only permitted resources are those containing a single element format per texel. The shader code receives constants from the constant buffers . In this embodiment, the constant buffers would function like one dimensional (1D) textures which are optimized for lower latency access and more frequent update. The shader code  also has two way communication with the temporary registers  and the subroutine return address stack . The temporary registers  serve as temporary storage. In an exemplary, non limiting embodiment, the registers can hold any non-indexable or indexable arrays of any size and quantity that are needed up to the limit of the temporary storage. The subroutine return address stack , in this particular, non limiting exemplary embodiment, is a fixed height. Furthermore, the stack is hidden from direct shader access and transparently stores return addresses only. It also permits the definition of recursive algorithms.","After the code has passed through the shader code , the data goes to output registers . The output registers , in this exemplary non limiting embodiment, are made of a dynamically indexable array of four vector outputs. Furthermore, some stages may have additional specialized outputs. The data is then output to the next shader stage, as a stream output or to a rendering stage depending on the pipeline.","The data structures listed can be changed from a 1D array to a 2D array or a list. All data structures may change depending on the size and storing capabilities of the GPU. Within the GPU, changes to the storage limits and fixed heights may occur due to dynamic allocation, and application of compression algorithms to information to conserve space. The samplers and constant buffers may behave like the textures, however as resources change, the definitions of these components may be modified. If textures are redefined, both samplers and constant buffers can change and are not limited to just the texture functions. Furthermore, all the data structures can implement new optimization algorithms for speed and utility purposes. The various embodiments described herein are mere examples of graphics pipeline using common cores, which can be dynamically configured to provide functionality of a vertex shader, a pixel shader and a geometry shader.","Geometry Shader to Operate on Primitives","Today, as graphics programmers develop graphics applications via a set of available graphics APIs, the programmer generally indicates a set of vertices to be operated upon by a set of algorithmic elements. Having specified the information, the data is sent into the graphics pipeline, and each vertex is streamed through a vertex shader and a pixel shader, as illustrated in . Although any data that fits the input structure for the vertex and pixel shaders may be specified, vertex shaders are generally suited and used for operation upon vertices and pixel shaders are generally suited and used for operation upon pixels.","In this regard, a geometry shader in accordance with the invention is a new type of shader for a GPU in a graphics subsystem that is capable of taking different types of \u201cprimitive\u201d input including any of a vertex, a line or a triangle, whereas prior art shaders (namely vertex shaders) are limited to being able to input, operate on and output vertices. In distinction, in addition to operation on a stream of vertices, the geometry shader of the invention can operate on primitives that define lines (sets of two vertices) and triangles (sets of three triangles), receiving such primitives as input inside the pipeline and outputting primitives inside the pipeline for further operation in accordance with the graphics architecture of the invention.","One further aspect of the primitive processing in accordance with the invention is that the geometry shader enables operations on the entire primitive not just by itself, but also in the context of some additional nearby vertices. One line segment in a polyline, for example, may be processed with the ability to read the vertices before and after that segment. Although the mechanism is general (graphics data need not be \u201cgraphics\u201d data, it can be any data defined for processing by the GPU), a frequent use for this capability to process adjacent vertices of a primitive is that the geometry shader is capable of taking information about neighboring points in 3-D geometric space into account in current calculations.","In , there is an embodiment of the functionality of the geometry shader where TV, TV, TV, LV, and LV are input data. The output data may include additional points which are indicated with the prefix AV. A geometry shader may thus take in one primitive, and output multiple primitives, optionally processing adjacent primitives, such as adjacent vertices. Some examples of the output include topologies like a triangle strip, a line strip or a point list. In this exemplary non-limiting embodiment, the output from a geometry shader goes to either a rasterizer for rendering and\/or to the buffer for stream output.","The concept is further illustrated in . In accordance with the invention, optionally, the data of the graphics data to be processed by the graphics pipeline may also be assigned an index. Previously, to index data, separate memory would have to have been pre-populated with index information for use with data being passed through the pipeline. In addition to synchronization issues with this prior art approach (synchronizing the indexes and the graphics data being processed), there are clear speed implications too. While generating the index information is fast, writing the index information to video memory, and reading from video memory to be used with the streaming graphics data is expensive in terms of time.","Thus, with the invention, the input assembler IA outputs the graphics data to be operated by the common core(s), along with any optional adjacency information (information about neighbors in the stream of primitives or data) and a corresponding stream of indexes can be generated for each element (primitive, data point, pixel value, etc.) represented by the graphics data. In one embodiment, indexes start at zero and increase by one with each new element of data, though any index value can be used as a start index value. Moreover, for some application, it may not even be useful to generate ordered indexes, and accordingly, in the generic sense, the invention generates unique identification (ID) values per graphics data element, which may or need not be ordered.","The ability to index has broad implications, and the range of uses are numerous. For instance, for geometry instancing, one might have a first area of memory with graphics data that defines a tree and another table that describes position for trees. Based on a count or index processed by the pipeline, the GPU can fetch portions of video memory to place variations of the tree at the positions defined by the table. The invention enables the use of an index value as part of a video memory addressing scheme while processing data, i.e., the index may signify where and when to retrieve (and\/or write to) portions of video memory for processing. As another example, it may be useful to apply a different algorithm to every fourth triangle of a stream of triangles and to perform the algorithm twice on every eighth triangle of the stream. The ability to index the primitives enables precisely this capability. The programs downloaded to the shader can thus programmatically use the index values associated with the graphics data while retrieving or writing to video memory, and also while processing graphics data.","Stream Output of Memory Before Frame Buffer Rasterization","As discussed in the background, with today's graphics pipelines, reading from the video memory used by a GPU to see the outcome of computation being performed in the pipeline is next to impossible. Having the knowledge of how to locate and extract data on the fly as it is being processed by a GPU's procedural shaders, and then actually extracting the data from video memory is too difficult a task in today's architectures.  shows how a programmer could go about retrieving the data from the output of the graphics pipeline, namely the frame buffer, and implicate host resources in order to send the data back into the pipeline for further processing. As explained, this task requires the programmer to either get the data from the frame buffer or the display. Generally, if further processing on data is necessary after passing through the pipeline, the programmer waits for the information to be received by the frame buffer and invokes the resources of the CPU to achieve the further processing.","In consideration of the shortcomings of today's graphics pipelines with respect to the recirculation of graphics data inside the pipeline, the invention allows programmers to \u201ctap\u201d into the pipeline while the data is inside the pipeline, wherein a tap can be turned on and off. When turned on, the pipeline includes an output stream of data that can either be read from memory for retrieval by the host or other operation, or recirculated into the pipeline to perform recursive or looping functionality. Furthermore, if necessary, the information can be streamed out while the same data goes to the rasterizer, thus not slowing down the rendering of data, or enabling the display of the image as it undergoes a transformation based on recursive algorithmic elements operating on the data.",{"@attributes":{"id":"p-0093","num":"0092"},"figref":"FIG. 3B","b":["184","1","184","2"],"i":"a","sub":"3"},"Lastly, memory is limited in space and therefore the stream output tracks the amount of data dependent upon the buffer size. When the memory storage space is full, in one exemplary embodiment, the shader continues its calculations for all data, while tallying the number of bytes needed to store all of the output data. This can be useful when it is unpredictable how much data will be produced by the calculations. The stream output may be used for graphics, but is not limited to only graphics. Although this is an enhancement of the graphics pipeline, the GPU can be used for mathematical calculations and can use the processing power of both the GPU and CPU. The uses of the stream output cover a wide range, as the stream output does not stop the rasterization functions of the graphics pipeline, and merely amplifies the power of the pipeline by providing more programmatic power to the developer in terms of the flexibility of specialized programs downloaded to the GPU. As mentioned, a very useful result of being able to tap into the output of a common core in accordance with the invention is that the data may be recirculated to other parts of the pipeline programmatically, i.e., the programmer can download a program to the GPU which performs recursive operations on the data (recircling data through the same algorithms recursively) or otherwise loop through the data a pre-fixed number of times.","Generation of Geometry Inside the Pipeline","As mentioned, today, as graphics programmers develop graphics applications via a set of available graphics APIs, the programmer generally indicates a set of vertices to be operated upon by a set of algorithmic elements. Having specified the information, the data is sent into the graphics pipeline, and each vertex is streamed through a fixed set of GPU subunits, such as a tesselator, vertex shader(s) and pixel shader(s), as illustrated in . Although any data that fits the input structure for the vertex and pixel shaders may be specified, vertex shaders are generally suited and used for operation upon vertices and pixel shaders are generally suited and used for operation upon pixels. However, other than the fixed stage tessellation which can generate geometry based on pre-defined control points prior to procedural shading according to pre-determined algorithms, there is nowhere in the pipeline today that can be used to generate new vertices, or geometry, for further processing.","Moreover, the tesselator of the invention may be used after the use of one or more procedural shading stages to receive a set of control points generated inside the pipeline, and operate programmatically, depending on the programs that configure the pipeline downloaded by the graphics APIs, to generate an arbitrary new number of geometry points. This is helpful, for instance, where it is desirable to perform coarse operations on a coarse mesh, but then to refine the mesh for additional operations requiring a more realistic model of the shapes. Previously, tesselator generation of geometry was limited to the beginning stage of a pipeline, and limited to pre-fixed operations on the pre-specified control point inputs. In consideration of such limitations, the invention enables common core(s) at the beginning of the pipeline to arbitrarily generate control points inside the pipeline (upstream from the tesselator), to output those control points to a tesselator, which generate additional geometry to be operated downstream as output from the tesselator.","As mentioned, the geometry shader of the invention may also be used to generate new geometry in a more general and programmable manner, as differentiated from a tesselator\u2014which is fixed function (not programmable) but generates arbitrary amounts of data (n\u00d7n mesh, no limit on n) versus the geometry shader, which is programmable, but is constrained in how much new geometry it can create.","For some exemplary non-limiting scenarios, the geometry shader of the invention assists a programmer by creating output vertices using a topology rather than a single vertex. Some examples of algorithms include point sprite tessellation, wide line tessellation, fin generation, shadow volume generation, and single pass rendering to multiple texture cube faces. To perform point sprite tessellation, the shader would take a single vertex and generate four vertices, or two output triangles representing four corners of a quadrilateral., while performing wide line tessellation, the shader receives two line vertices, like LV and LV in , and generates four vertices for a quadrilateral representing a widened line. Additionally, the geometry shader may utilize adjacent line vertices, AV and AV, to perform mitering on the line end points.","The geometry shader can also be used to generate fur or fins, this is not limited to fur or fin generation, but encompasses any additional vertices added in a third direction of a single topology. Examples include hair, scales, grass, etc., where primitives describing a geometry are fed to the geometry shader, and the geometry shader grows the geometry arbitrarily to supplement the shape. Thus, with hair, for instance, based on triangles input to a geometry shader, the geometry shader can add a few vertices that represent hair at each vertice. Advantageously, because a stream of triangles to the geometry shader includes information about the neighbors of a vertex, the proximity and properties (color, depth, etc.) of the geometry of the vertex's neighbors can be taken into account during processing.","While currently, geometry shaders of the invention are limited to being able to generate a maximum number of new arbitrary geometry, as specified by the program downloaded to the geometry shader by the graphics APIs, when combined with the recursive capabilities of the invention enabled by the stream output defined in more detail below, the invention enables arbitrary generation of unlimited geometry. For instance, in the case where a geometry shader may only create","Another exemplary non limiting use of the geometry shader includes shadow volume generation where the adjacency information is used to decide whether to extrude. Furthermore, an application may want to generate some geometry, like a fin or fur and extrude shadow volumes out of that. In such cases, multi-pass functionality of the geometry shader would be employed using the ability output a data stream and circulate it back through the use of the stream output.",{"@attributes":{"id":"p-0102","num":"0101"},"figref":["FIG. 5","FIG. 3A"],"b":["550","560","570","550","560","560","550","580"]},"In essence, one can quickly see the benefits of highly specialized and fast hardware that can be dynamically customized for the job it is requested to perform. This includes being able to specify recursive programs via stream output, being able to dynamically reconfigure the cores, being able to quickly operate on vertices while simultaneously taking input relating to the neighbors of the vertices, being able to generate new geometry arbitrarily anywhere in the pipeline (pre-tesselation generation of geometry, tesselator generation of geometry and post-tesselation generation of geometry). Accordingly, the advantages of the present invention are almost unlimited from the standpoint of the developer, who becomes closer to being limited only by imagination by what may be accomplished on graphics data in accordance with the invention.","The enhanced graphics pipeline of the invention thus includes a common core that is dynamically configurable to allocate pixel shaders, geometry shaders and vertex shaders in a manner that is best suited for the tasks being requested of the pipeline. The invention also includes a new procedural shader termed a geometry shader capable of operating on streams of any of points, lines and triangles. Moreover, the invention includes the ability to generate new geometry inside the pipeline, by the tesselator or by a geometry shader. The invention also includes a stream output, which may be tapped into inside the pipeline, prior to the data reaching the frame buffer for rasterization, enabling programmatic recursive and looping algorithms on graphics data. Also, the invention includes the ability to index every primitive that enters or is created in the graphics pipeline. The graphics pipeline can also perform all integer and floating point calculations according to IEEE standards.","There are multiple ways of implementing the present invention, e.g., an appropriate API, tool kit, driver code, operating system, control, standalone or downloadable software object, etc. which enables applications and services to use the systems and methods of the enhanced graphics pipeline invention. The invention contemplates the use of the invention from the standpoint of an API (or other software object), as well as from a software or hardware object that receives any of the aforementioned techniques, including techniques of the common core, the geometry shader or the stream output in accordance with the invention. Thus, various implementations of the invention described herein may have aspects that are wholly in hardware, partly in hardware and partly in software, as well as in software.","As mentioned above, while exemplary embodiments of the present invention have been described in connection with various computing devices and network architectures, the underlying concepts may be applied to any computing device or system in which it is desirable to employ a GPU with an enhanced graphics pipeline. For instance, the algorithm(s) and hardware implementations of the invention may be applied to the operating system of a computing device, provided as a separate object on the device, as part of another object, as a reusable control, as a downloadable object from a server, as a \u201cmiddle man\u201d between a device or object and the network, as a distributed object, as hardware, in memory, a combination of any of the foregoing, etc. While exemplary programming languages, names and examples are chosen herein as representative of various choices, these languages, names and examples are not intended to be limiting. One of ordinary skill in the art will appreciate that there are numerous ways of providing object code and nomenclature that achieves the same, similar or equivalent functionality achieved by the various embodiments of the invention.","As mentioned, the various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the present invention, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers, the computing device generally includes a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may implement or utilize the enhanced graphics pipeline techniques of the present invention, e.g., through the use of a data processing API, reusable controls, or the like, are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","The methods and apparatus of the present invention may also be practiced via communications embodied in the form of program code that is transmitted over some transmission medium, such as over electrical wiring or cabling, through fiber optics, or via any other form of transmission, wherein, when the program code is received and loaded into and executed by a machine, such as an EPROM, a gate array, a programmable logic device (PLD), a client computer, etc., the machine becomes an apparatus for practicing the invention. When implemented on a general-purpose processor, the program code combines with the processor to provide a unique apparatus that operates to invoke the functionality of the present invention. Additionally, any storage techniques used in connection with the present invention may invariably be a combination of hardware and software.","While the present invention has been described in connection with the preferred embodiments of the various figures, it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating therefrom. For example, while exemplary network environments of the invention are described in the context of a networked environment, such as a peer to peer networked environment, one skilled in the art will recognize that the present invention is not limited thereto, and that the methods, as described in the present application may apply to any computing device or environment, such as a gaming console, handheld computer, portable computer, etc., whether wired or wireless, and may be applied to any number of such computing devices connected via a communications network, and interacting across the network. Furthermore, it should be emphasized that a variety of computer platforms, including handheld device operating systems and other application specific operating systems are contemplated, especially as the number of wireless networked devices continues to proliferate.","While exemplary embodiments refer to utilizing the present invention in the context of a graphics pipeline, the invention is not so limited, but rather may be implemented to provide a second processing unit. For instance, if the programmer wants to render a display to the screen and process the computational mathematics while performing another function using the CPU, the processing units may need to be utilized to their fullest, whether or not the graphical display is included in the final output. Still further, the present invention may be implemented in or across a plurality of processing chips or devices, and storage may similarly be effected across a plurality of devices. Therefore, the present invention should not be limited to any single embodiment, but rather should be construed in breadth and scope in accordance with the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The systems and methods for an enhanced graphics pipeline, in accordance with the present invention, are further described with reference to the accompanying drawings in which:",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 2C"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 4C"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
