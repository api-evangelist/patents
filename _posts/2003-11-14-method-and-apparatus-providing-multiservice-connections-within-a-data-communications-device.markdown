---
title: Method and apparatus providing multi-service connections within a data communications device
abstract: A method and apparatus provide a data communication device that can process a number of streams of data according to a plurality of services. A host device such as a network access server which may include a router and a number of carrier cards hosts a number of modules. The host and modules are equipped with a messaging application programming interface (API). The API allows the host to discover what services are offered by the modules, and allows the host and modules to form an optimal interface configuration that most effectively handles data connections of different service types, such as voice, data, facsimile, video and so forth. In operation, each module is presented with a stream of data containing multiplexed calls. Each call contains data that is best operated on by one of the particular services. The messaging API allows the host to setup and control the module and sessions of the services offered by the modules depending upon the data types of the connections. Since the modules each offer a variety of services, a stream containing data one or more connections such as voice data, video data, modem data, facsimile data and so forth can be processed by a single module under control of the host.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07310338&OS=07310338&RS=07310338
owner: Cisco Technology, Inc.
number: 07310338
owner_city: San Jose
owner_country: US
publication_date: 20031114
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application is a continuation of U.S. application Ser. No. 09\/227,699, filed Jan. 8, 1999 now U.S. Pat. No. 6,667,972. The entire teachings of the above application are incorporated herein by reference.","Computer networking uses various data communications techniques to transmit information from one computer to another over a network. A typical network includes a series of interconnected data communications devices that can each store and forward or exchange data from one device to another, enabling the exchange of information. In a typical computer networking application, source and destination computers are personal computers, workstations, or the like which each include a modem or other transmitter that is used to transmit the data from the computer. The modem accepts data from an application executing on the computer and encodes the data according to one or more of a number of standardized data communication protocols. The modem can also decode data that is received. The specific protocol selected may be based on the function of the application in use and may create data having a specific associated type.","Depending upon which applications are in use, there may be many different types of data transmitted and received across a network. For example, voice data, video data, facsimile data and traditional application data (referred to as modem data) can all be digitized and encoded according to respective encoding protocols, with each protocol designed to optimally handle data of its specific type. Voice data for instance, must be sampled frequently and in real-time, and thus the mechanisms (i.e. protocols) used to send and receive voice data typically use small packet sizes that must be transmitted and received in a predetermined order over data links offering a more or less guaranteed quality of service (QoS). Conversely, regular application (modem) data can be transmitted using large packets that need not arrive in real-time nor in any particular order and delays in transmission are generally allowable.","Quite often, a network connection originates at a source computer host when data is transmitted from the modem to a central telephone switching office over a telephone line, for example. The central office may host connections from several source or destination computers each coupled via modem to the central office over dial-up or dedicated connections. Each connection is tantamount to a phone call and is frequently referred to simply as a \u201ccall\u201d or a \u201cDS0.\u201d There may be a number of central offices linked together which form a connection-based wide area network or WAN. To send the data on each call in each central office to a large packet-based computer network such as the Internet, the calls are multiplexed onto transmission links, such as T1, T3, E1, TDM or OC3 links, each of which offers a high bandwidth and high data rate. These high speed multiplexed links are coupled to a network access server (NAS).","Access servers are typically located at the facilities of an Internet Service Provider. An access server accepts the high bandwidth multiplexed links and routes the call connections containing the modulated data to a packet network. The access server also accepts data packets traveling in the reverse direction from the packet network to remote hosts located on the WAN.","Within an access server, the high bandwidth T1, T3, E1, TDM and\/or OC3 links containing calls from the WAN are received by a framer. The framer accepts the high bandwidth connections and outputs a number of Time Division Multiplexed (TDM) streams, each of which can include many multiplexed calls in associated timeslots. Each portion of data or DS0 in timeslots associated with each call has an associated data type, such as voice data, video data, facsimile data, modem data, or another type of data.","Each TDM stream is directed to a module to handle data within calls carried in that stream. A module is generally a circuit card that can accept and process the call data in one or more TDM streams according to a single service associated with that module. The module processes the calls in that TDM stream according to a service for which the module was designed. In other words, the specific module selected is dependant upon the type of data in the TDM stream. For instance, a module designed for voice data may be able to accept and process a TDM stream containing up to 32 simultaneous voice calls. Another module may be designed to accept calls containing video data, and another for modem data. The modules accept the TDM streams and convert the data for each call into a packet format for eventual transmission to a packet network.","In some prior art systems, a module that is designed to handle a specific type of data, such as commonly transmitted modem data, can use its modem data configuration to handle others types of data. As an example, a module configured for modem data can typically be configured to service voice data as well. The module configuration refers to such things as the length and number of data and message queues provided in the module, the protocol error checking used, and the data handling protocols that are used by the module. A module configured for modem data may, for example, use longer queues and create large packets full of data, while a module configured for voice may use short queues and create many packets with smaller amounts of data due to the real-time requirements of voice.","Modules configured to service one data type may use that configuration to service data of other types. In such cases, the underlying configuration of these modules does not change. Rather, the modules merely piggyback or shoehorn other data types into the constructs used for the original configuration. As an example, voice data can be transmitted through a module designed with queue lengths and protocols which are optimized for handling packets of modem data.","In the access server, a number of modules are typically coupled to another circuit card called a carrier card. A typical carrier card can host up to six modules. Like the modules, carrier cards are designed to most effectively handle data streams associated with the modules which they host. By way of example, a carrier card that hosts six voice modules is specifically designed to work with voice data, while a carrier card that hosts modem data modules is designed to most effectively handle streams of modem data. In a typical access server, there can be multiple carrier cards of different types, each hosting multiple modules.","In other access server systems, the modules can couple directly to a router backplane without a carrier card. The router backplane includes a router processor. The router processor is configured to specifically communicate with the modules. In either the case of a module\/carrier card configuration, or the module\/backplane configuration, an access server can service many various types of data connections by routing the different call types to modules designed to best serve the data in the call connections.","The backplane links connections from modules to one or more computer networks such as the Internet. The backplane may include knowledge of what type of data is being provided from a specific carrier card and\/or module. Thus, if the backplane processor detects a carrier card hosting voice modules, preference may be given to data passing to and from this carrier card due to the real-time nature of voice data. Generally however, the backplane accepts the packetized data connections from each carrier card\/module configuration and routes them to an appropriate computer network segment. In the reverse direction, the backplane accepts packets from the computer network segments and routes them to an appropriate module where the service converts the packet data to TDM stream data.","Prior art data communication devices such as the access server noted above suffer from a variety of inefficiencies in design and implementation. In particular, modules within an access server are more or less dedicated to servicing connections of a specific type, such as modem data, voice, video, facsimile, or another data type. The configuration of queue lengths, error correction schemes, protocols and so forth is generally fixed in prior art modules. If a protocol changes, the fixed configuration of the module may not support the new features of the protocol. As such, new modules may be required to support new protocols and carrier card design may be effected as well.","Another problem with prior art access server systems is that modules are designed to offer one basic type of service, such as voice or data. The protocols provided by the modules do not optimally adapt to servicing other types of data. This results in lower throughput rates when a module services connections which it is not optimally designed to service.","Carrier cards are also designed to support particular module types. Thus, a carrier card designed to support modem modules may not work efficiently or even at all when used to support modules designed to service voice call connections. As a result, different carrier card and module combinations must be installed in an access server to effectively service connections of different data types. This increases manufacturing costs since both specific carrier cards and modules are produced to handle different types of data.","The invention overcomes these problems. The invention provides a module that is generic in nature and that can provide protocol support for a number of different services. The module is called a multi-service module. A multi-service carrier card is also provided which is designed to support the multi-service modules. A messaging interface system is provided for a data communications device that is hosting the modules to determine the services available from the modules and to configure a module most appropriately for data processing according to those services. Preferably, this system allows a host to provide a module with information concerning its capabilities. In turn, the module can indicate to the host what services are offered by the module. The interface system uses a shared memory to hold the queues and allow the exchange of messages in one embodiment.","According to another aspect of the invention, a module provides data communications services. The module includes an interface for transferring a plurality of streams of data into and out of the module. The interface includes at least one port capable of transferring incoming and outgoing streams of multiplexed data. A shared memory is also coupled to the interface and includes a plurality of data queues. Each data queue buffers incoming and outgoing streams of packet data. A plurality of service processing units are provided in the module and are coupled to the shared memory. The service processing units support a plurality of services which operate on the streams of data being accepted through the interface.","The service processing units accept and process incoming streams of multiplexed data according to one of the services. The units convert the incoming streams of multiplexed data to outgoing streams of packet data and accept and processes incoming streams of packet data according to one of the services and convert the incoming streams of packet data to outgoing streams of multiplexed data. Also contained on the module is a processor which is coupled to the shared memory, the interface, and the service processing units. Generally, the processor controls the operation of the module to subject the streams of data to the plurality of services.","The services offered by the service processing units can be fax services, voice services, modem services, data services, and so forth. The invention is not limited to these services, but rather, can provide all types of protocols processing and data services, including encryption, compression, encoding, decoding, and the like. For each type of service, such as voice, data and video, a specific set of messages called a message catalog is provided. Thus, there may be a voice message catalog, a video message catalog, a data message catalog, and so forth. Each message catalog comprises messages that may be sent from the host to the module to configure the service associated with that catalog on the module. For example, if a module offers voice, video and digital data services (e.g., ISDN), the host can use specific messages from a voice message catalog, a video message catalog, and a data message catalog to configure each of those services for use within the module as those types of data are required to be processed. The messages from the message catalogs can perform such tasks as selecting a specific data rate for the service, adjusting flow control, parity, and so forth.","In operation of the interface system of this invention, an identity table is created within the shared memory upon start-up of the module. The identity table contains information identifying each of the plurality of services supported by the module. A host configuration table is also created upon start-up of the module in the shared memory. The host configuration table identifies the configuration of a host that is hosting the module. A downloaded module image runs on the module processor and reads the host configuration table to determine the configuration of the host that is hosting the module and creates the information identifying each of the services supported by the module and places the information in the identity table allowing the host that is hosting the module to read the identity table to determine the plurality of services are offered by the module. In this manner, the invention supports a mechanism between host and a module to identify the module and its services and to configure the host and module to support those services.","Also included on the module is a session manager process executing on the processor. The session manager process accepts session commands on the interface to control the service processing units supporting the services. A module manager process is provided that executes on the processor of the module as well. The module manager process accepts module commands on the interface to control the operation of the module. The shared memory includes a control queue and a status queue which are separate from the data queues. These queues receive the session commands and module commands over the interface from a host hosting the module so that the host can control operation of the module and its services.","To control each service within the modules, the host and modules are equipped with a plurality of service message catalogs, one per service offered by the module. Each service message catalog contains messages related to particular services offered by a module. A host processing unit selects and sends particular messages selected from a service message catalog associated with a service to the module to establish, control and configure the service within the module. The service can thus process the a data communications session according to the service. Message catalogs that are provided are a digital data message catalog, an in-band signaling message catalog, a data\/fax\/voice message catalog, and a packet gateway services message catalog.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 1","b":["200","101","102","109","110","111","112","101","102","103","108","101","102","200","150","151","151","151","103","108"]},"The access server  also couples to Local Area Network (LAN) network . In this example, LAN network  is a connectionless packet-based computer network which interconnects remote computers  through . Computers  through  execute applications which, for example, use the TCP\/IP protocol suite to communicate. Other access servers ,  and  are also coupled to LAN computer network  and provide access to and from other remote networks which are not shown in this example.","Within the access server  there are one or more trunk cards , also called framers, which provide interfaces for connections to and from the high bandwidth links , . Streams of data to and from remote systems  through  are provided on WANs ,  as individual connections called \u201ccalls\u201d or \u201cDS0s\u201d. Links  and  support these DS0 call connections in a time division multiplexed (TDM) format so that many simultaneous calls can exist on links  and  at one time. The framers  accept the call connections on links  and  and create streams of Time Division Multiplexed DS0's. Each TDM stream includes frames of individual DS0's, with each DS0 occupying one timeslot in a frame. Each call connection may, for example, be associated with one or more of the DS0's occupying a timeslot in the frame of a TDM stream. In high-bandwidth applications such as video connections, it may be the case that the video connection is actually associated with more than one DS0 timeslot in a frame of a TDM stream. In such cases, the DS0s associated with the video connection are referred to collectively as a channel. The framer  channels each TDM stream to a port (not shown) on one of the multi-service modules .","A module  configured according to this invention is able to service the individual call connections (DSOs, or groups of DS0's in the case of a channel) in a TDM stream, with each call (or channel) carrying data for one or more of a variety of services such as voice, video data, modem data, and so forth. The modules are mounted on the carrier cards  which, in this example, couple to the trunk cards  and the controller cards  and the router . The purpose of the modules  is to convert data from WANs  and  to data on LAN (i.e., computer network) , and to convert packet data from LAN  to call connection data for WANs  and\/or . In other words, the modules  support services which handle data conversion between the two networks.","A single service is a protocol executing on the module that processes connection data between the WAN and LAN networks ,  and . Generally, receive data arrives on a TDM channel from framer\/trunk cards  and is processed by the service in the module . After processing, the data is placed in a data queue for the router  which transmits the data in packet form to LAN . In the other direction, data from packets on the LAN  is placed in a data queue (not shown) by the router  and is processed by the service in the module  and is then placed in an appropriate timeslot of a TDM stream for transfer to one of WANs , .","The modules  provide protocol support between the access server  and WANs  and . Such support includes, but is not limited to G.711, G. 728, G.729 and other voice protocols including any appropriate voice activity detection and echo cancellation; modem protocols V.90, V.34, V.32 and their derivatives as well as other legacy modem protocols; Facsimile protocols such as T.30, T.4 and T.6 for FAX receive, FAX transmit and FAX relay; HDLC, ISDN and PPP protocols, SLIP, V.42, MNP, DSL\/ADSL and its variations, ITU V.110 and V.120, and any other protocols that require support for services between networks such as WAN  and  and computer network .","Within the access server , the modules  are physically mounted on carrier cards . Each carrier card  can support up to six modules , each of which can support connections of various service types such as data, voice, facsimile, video, and so forth. Depending upon how many connections are to be supported by the access server , there may be many carrier cards  supporting up to six modules  each.","In alternative embodiments, the modules  can directly interface with a backplane (not shown) of the router , and the carrier cards  are not required. In this instance, the modules  are said to be \u201chosted\u201d by the router , since the router  contains the processing capabilities that interact with the modules . In , a host  is illustrated within dotted lines that include the external processing components (either carrier card  and\/or router ) that form the host  that communicates with the modules  using the interface of this invention. That is, a host  with which a module  interfaces to exchange data and\/or commands may be a carrier card , a router  or another data processing device providing the functionality of the host  and module  interface as described herein. It is to be understood however that the architecture of access server  in  is provided by way of example only and is not limiting of this invention.","One aspect of the invention relates to the techniques and mechanisms that allow the multi-service modules , carrier cards  and router  to support connections of different services without dedicating modules  or other resources to supporting only specific services. Specifically, this aspect of the invention defines an interface between a module  and a host  (i.e., either carrier card  or router ) that hosts one or more modules . A module  can be queried by a processor located in the host  to determine which services are provided by that module . An application programming interface is provided by the invention between the host  and the modules  which allows each to determine the services and capabilities of the other. As a result, the host  can most efficiently configure itself and the module  for data transfer based upon the types of services supported within the module .","Aspects of the invention are described in the context of an access server by way of example only, to aid in the description of the invention. The invention is not limited to use in an access server, but rather, is generally applicable to other types of data communications equipment that process data according to one or more services, such as routers, switches, hubs, bridges, repeaters, or other data trafficking devices.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 2","FIG. 1","FIG. 1"],"b":["200","200","201","202","203","204","205","204","101","102","205","120","204","205","200"]},"The dial shelf  includes a number of circuit board components which mount in slots -A within card cage . In this configuration, framer cards  (also referred to previously as trunk cards) are positioned in the two left-most slots -A, and include WAN connections -A to which T1\/E1\/OC3 or other links ,  () can interconnect. The framer cards  remove framing and embedded signaling bits (or insert them depending upon direction of data flow) in the data and an onboard framer CPU (not shown) sends the data stream to an onboard time division multiplexing (TDM) resource which breaks out and passes each TDM stream over the backplane (not shown) to an appropriate module  () hosted on one of the carrier cards  (CC-CC).","In this example, there are ten carrier cards  individually labeled CC through CC, and two controller cards  which are inserted into respective slots -A of the dial shelf . A backplane (not shown in this figure) inside the dial shelf  provides electrical interfaces for each card ,  and  that is inserted into the card cage .","The router  includes network connectors -A which can couple to network segments on LAN , such as the data link  (). The router  includes a processor (not shown in this figure) that executes a routing process (i.e. protocol) that can route and send and receive packets to and from LAN . The router  also includes an dial shelf interconnect port  which allows the router  to exchange data with the dial shelf  via one or more dial shelf interconnect cables  (only one shown in this example). Dial shelf interconnect cable  serves as a data transfer mechanism between the packet-based connections (e.g.,  in ) coupled to network connectors -A in the router  and the circuit switched connections (e.g., , ) coupled to WAN connections -A in the dial shelf . Alternative configurations of a system according to this invention, such as an access server, may provide the router , carrier cards , and other cards (i.e. framer cards ) as individual circuit boards which slide into a common backplane within a single shared chassis (as compared to a separate router and dial shelf as shown in ).",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 3","FIG. 3"],"b":["200","301","101","102","303","308","250","1","250","268","250","1","250","268","250","268","250","259","304","261","205","120"]},"A typical service (not shown) in a module  converts TDM DS0 data (i.e. call data) to packet data (and as explained below, can also convert packet data to TDM DS0 data). The data conversion process used (i.e., the service used) depends upon the data type (i.e., modem data, facsimile data, video data, voice data, etc.).","In the reverse direction of data flow, data (i.e. packets) destined for a remote system on WANs  and\/or  are received at the router  from the LAN . The packets are routed through the backplane  to the carrier card  and then to one of the modules - through -N that provides the appropriate service connection for the packets. The module  receives the data and uses one of its services to convert the packet data into TDM stream data. The resulting data is then multiplexed onto an appropriate TDM stream on TDM bus  and is passed off the module  through TDM switch  to the TDM highway  that couples to the WAN , through WAN interface .","The invention particularly relates to how a host platform (i.e. either a carrier card  or router  or other data communications device) that hosts the modules  can communicate with, query, configure, and control the modules , their services, and data connections serviced through the modules . A unique interface between the module(s)  and the hosting platform is provided for this purpose.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIG. 4","FIG. 3","FIG. 2","FIG. 2"],"b":["259","200","259","250","250","1","250","268","250","250","268","309","303","304","250","1","250","205","307","307","261","206","208","307","259","250","205"]},"As indicated in this example, the router  includes host processor  and shared memory . As such, the router  is said to be the host with which modules - through -N communicate. In alternative embodiments, the host processor  and shared memory  may be located on the carrier card , in which case the carrier card  would be referred to as the \u201chost\u201d. In another embodiment, the shared memory  can be maintained on the modules  themselves, while the host processor  is either on the carrier card  or is within the router . The term \u201chost\u201d generally refers to the processing device(s) with which the modules  communicate as explained with respect to this invention. The point is that the invention is not limited to a specific location for a host processor  or memory  with which the modules  communicate (as will be explained). The various embodiments will be described later in various levels of detail. Those skilled in the art should understand that the particular design is not limited to these descriptions.","The shared memory  (within the router  in this example) supports the dynamic configuration of queues and buffers (not shown in this figure) which allows the transfer of data through the modules . This queue and buffer configuration is provided by one aspect of the invention. Since each module  can support a variety of connection services such as voice, data, fax, digital data (i.e. ISDN), video, and other services, the shared memory  can be configured using the invention to optimally define the queues, buffers and other data structures required on a service by service and port by port basis. Generally, each service is defined by one or more standardized protocols which may be best implemented in use by configuring queues, buffers, and other processing resources to settings designed to best carry out those services. This invention allows a host  to determine the services offered by a module , and then allows a configuration to be established that can best be used by those services.","The multi-service capability provided by each module  and the host  (preferably either the carrier card  or router ) and the manner in which these services are configured and controlled allows a single module  to supply any service to any call connection at a prescribed density. The system of the invention covers the design of the interaction (i.e., the interface) between the router , the carrier cards , and the modules  along with the messaging application programming interface (API) used to control this interaction. The interaction, as will be explained, includes an initial configuration process during which the host  and module  exchange information to determine the features (i.e., service and processing resources) offered by each, as well as the processes through which the host and modules can establish active data communications sessions whereby the data is subjected to the services of the modules . As will be explained, this system provides the ability to vary the configuration of a host  such as a carrier card  or router  and a module  to best accommodate each type of data service.","The entire design and operation of the system of the invention, including module  design, the interface between the modules  and a host , and the messaging techniques and message catalogs (to be explained) that exist and that are used for specific services represent preferred embodiments of this invention. It should be understood, however, that the invention is not limited to the exact designs expressed herein. Rather, the scope of the invention is meant to cover these embodiments, processes, aspects and features, as well as the general system concepts explained and as claimed.","Continuing on, most communications applications that execute on remote systems - and - () require varying amounts of access server data communications resources, such as memory, processor bandwidth (to handle service requirements), and data throughput bandwidth. These resources are dependent upon the specific service(s) (i.e., fax, voice, video, data) required by the applications. The messaging API of the invention allows a host  (i.e. router  and\/or carrier cards ) to communicate with the modules  to determine communications capabilities and\/or services supported by the modules . As such, as the access server  (or other data communications device equipped with the invention) processes streams of data between networks (i.e., LAN  and WANS , , ), module resources (i.e, memory, services, processor bandwidth) can be configured and controlled via the host  by scheduling modules  to service data connections according to the services offered by those modules . Before data stream processing occurs, the host  and module(s)  perform an initial configuration communication process. This initial configuration communication preferably takes place upon power-up or \u201cboot-up\u201d of the data communications device, which is the access server  and specifically the router  in this example.","For example, based upon the messaging that takes place (to be explained), a host  (e.g., router  or carrier card ) can inquire as to the connection support services offered by a module , and the module  can respond to the host  with the services offered. The messaging system also allows connections to be established for services (i.e., voice, video, data, facsimile) offered within the modules , and allows setup and tear-down processes for sessions of the services to be carried out. The messaging API of the invention allows the module  and\/or the carrier card  to be configured with varying degrees of flexibility to most efficiently allocate module  and host  resources. By providing this handshaking system, modules  and hosts  can obtain information about the facilities of each other and future changes in one component or the other can be understood and taken into account during communications processing. Thus, if a new module  is provided with an updated or completely new data communications service, the host  can discover this feature and will be able to handle streams of data associated with the updated or new service.",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 5","b":["250","260","250","260","320","260","259","205","260","250","120"]},"In this embodiment, the main components within the module  are shared memory , a module controller  and a number of service processing elements - through -N. These components are coupled via module busses . A serial EEPROM  is provided to permit the host  to automatically identify the module  via module identification signal  during or just prior to initial configuration. The reader should note that this figure illustrates the alternative embodiments in which shared memory  can either exist on the host  or within the module . The shared memory  is responsible for maintaining various message and data queues and buffers (not shown in ) which are used to store and forward data as it is processed and passed through the module . As will be explained in more detail further, Identity Table (IDT)  and Host Configuration Table (HCT)  are setup and maintained in shared memory  during configuration and operation and are used to configure and manage the module .","Module controller  is the central processing unit for the module  and executes a module manager process  and a session manager process . The module manager process  is responsible for communicating with the host  to establish the initial module configuration which includes the setup and sizing of queues and other structures in shared memory  during startup of the access server . Generally, the host  and module  relationship is a master\/slave relationship where the host  is the controlling master. That is, the host  governs and controls the overall actions of the module , and the module  reports back to the host  the status of requests and commands sent by the host . Instances where the module  initiates communication which is not generally in response to a command from the host  are limited to mostly error conditions.","Also illustrated in  are service message catalogs - through -N. Service message catalogs  are used by the host  to control aspects of individual services  within the module(s) . A more detailed discussion of the services message catalogs  will be presented later.","Preferably, a module  has a physical 3.5 by 5 inch form factor, and uses a 140 pin board-to-board connection which provides stacking support for stacking multiple modules  on top of one another. The system uses industry standard interfaces wherever possible and provides full hardware support for legacy software applications and services. The interface  also provides JTAG support for testing, programmable logic support and processor emulation support. Performance in a preferred embodiment of a module  supports four full duplex 8 Mbps TDM streams of 128 DS0s. The onboard bus  is capable of providing support for the above noted data rates. Module controller  provides enough computing power to support the intended application services .","During the operation of module , connections ,  and ,  are established and supported via the various service processing elements . TDM DS0 stream data ( in ) is illustrated both as TDM Tx (transmit) data  and TDM Rx (receive) data  in , while datagram or packet data  is illustrated as transmit data  and receive data . While illustrated as separate interfaces for illustrative purposes, all interfaces between a module  and host  can be incorporated into one physical connection interface such as the 140 pin interface noted above.","All references to transmit and receive data (both TDM and packet data) are in relation to the TDM highway  (). Thus, TDM Rx (receive) data  arrives at the module  on TDM highway  (), is processed by a service  in the module , and is then transmitted as Rx (receive) packet data . Rx packet data  is referred to as \u201creceive packet data\u201d, even through it is actually transmitted from the module  through the host  out to the LAN . This is because the all data in this description is called either receive or transmit data in relation to its direction of flow from the module  onto or off-of the TDM highway . Accordingly, in the reverse direction, packet data arriving at the host  (i.e. router  in ) from LAN  is referred to as Tx (transmit) packet data , even though it is \u201creceived\u201d from LAN . Again, this is because with respect to the TDM highway , the Tx packet data  is transmitted and not received.","Each incoming DS0 connection within the TDM Rx receive data  is switched to one of the service processing elements , depending upon the type of data in the connection. The session manager process  handles miscellaneous tasks associated with each individual DS0 connection , such as assigning an incoming DS0 connection on TDM Rx line  to a particular service processing unit  where a service  handles processing the data. As will be explained, commands from the host  are used to interact with the session manager process  on the module .","Preferably, each service processing element  is a digital signal processing (DSP) engine that provides data processing for one of more of the services  offered by module . As illustrated in this example, service processing unit - offers services - including voice, data and fax protocols. Other services - through -N are provided by the other service processing elements - through -N. The service processing elements  handle the packetization and de-packetization of data in streams ,  according to the configuration of the service processing unit  providing the service  for that stream , .","As an example, if a TDM stream  is carrying modem data, upon connection setup (to be explained), the session manager  associates that DS0 stream with a service processing unit  that is configured to most efficiently handle modem data, such as service processing unit -. The service processing unit - accepts the received stream on  and demodulates the data according to the service selected for that stream, such as V.32bis. The data is then forwarded on to a queue (not shown in this figure) in shared memory  where it awaits retrieval by the host . The host  then obtains the data  from the shared memory  and forwards it towards its eventual destination.","As an example of data flow in the reverse direction, as packets or datagram data  is received over the interface  from the host , they are buffered in data queues (not shown) in the shared memory . The session manager  associates each packet with a service processing unit - through -N depending upon the addressing or routing information provided from either the packet of data itself or from out-of-band signaling received from the host . The service processing unit  obtains and processes the data from shared memory  according to the service for the data type of the received data. The service may be, for example, a voice, fax, video, or modem protocol. After the data is serviced, the session manager  forwards the data on to the appropriate TDM transmit stream .","Before the module  can be used to service data as explained in the above examples, a start-up handshaking procedure is performed between the host  and each module . In a preferred embodiment, IDT and HCT tables ,  are configured in shared memory  during this start-up process. These tables ,  contain information required to describe all aspects of the interface between the host  and the module .","Table  is known as an Identity Table or IDT . The address of the identity table  is the only item that the host  must know in order to establish communications with the module . The exact location of the Identity Table  is located in the header of a downloaded software image that is sent to the module during the start-up procedure. Once the address of the identity table (IDT ) is determined by the host , software executing on the host  or a platform coupled to the host  can process the identity table to determine the characteristics of the port card module . An example of software which embodies the messaging and API host capabilities of this invention is the Cisco Internetworking Operating System (IOS) software produced by Cisco Systems of San Jose, Calif.","The IDT  contains the information that describes where certain message and data queues are located in shared memory . This queue information allows the host  to then query the module  to identify the service capabilities, applications, and protocols that the module  supports. Other information such as if the module  can operate in an initiator or target configuration for messaging, and if interrupts are used, can also be discovered. Using this mechanism, the host  can optimize both the location of data in shared memory  as well as the queue sizes and data buffer memory allocated to optimize the interface between the host  and module . Another significant benefit of this approach is that the host  can re-use the same code and mechanisms to communicate with any module  which supports these discovery and configuration mechanisms. Aside from IDT and HCT tables , , a sophisticated service message catalog set is provided and a queuing interface is established to enable communication and data transfer between the host  and the module .",{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 6","b":["260","250","250","340","250","260","250","260","600","250","1","250","250","601","333","260","250","602","260","250","260","334","264","250","603","604","250","605","250","334","250","260","250","606","250","333","264","333","260","340","250","260","607","260"]},"As outlined above, a primary aspect of the invention is to provide a universal module card application programming interface (API) solution that does not limit or pre-define the format and sizes of data objects (queues, buffers, etc.) used between the modules  and the host . As such, this aspect of this invention is open-ended with respect to the definition of the interface structure and queue mechanisms used and allows protocol advancements to drive configuration requirements. Once the queues are established, the bulk of host-module communications, such as session management, can be carried out via messages sent using the queuing structures in shared memory . Before a more complete description of host-module operations is provided, a discussion of the queue structures is in order.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 7","b":["400","259","250","400","340","200","400","250","400","260","340"]},"The interface  provides the ability to communicate with the module  using both in-band and out-of-band message queues  through . In-Band queues  through -N are used to exchange data between the host  and the services - through -N executing on one of the service processing elements - through -N () within the module . As such, in-band queues  are also called data queues.","Out-of-band queues  through  are used to exchange data between the host  and the module 's management facilities which include the module manager , session manager  and GDB debugger . Out-of-band queues  through  support out-of-band messages (i.e., control and command messages sent between the host  and the module ) using the message dispatcher . Specifically, the out-of-band queues  through  are the control queue , the Error-Status-Trace (EST) queue , and the GDB Debug queue . The control and EST queues ,  together provide the mechanism for transmission of module and session management commands, responses and messages from the host  to the module , and vice versa. The GDB Debug queue  is handled by the GDB Debug process  and is used to debug module processing if needed.","Preferably, queues  and  are required on modules  that meet the interface described herein as the invention. The GDB debug queue  is used for debugging module . The control queue  supports command messages from the host  to the module  and also supports response notification messages sent from the module  to the host . The EST queue  supports query messages from the host  to the module  and error, status, and trace messages from the module  to the host .","All queues  through  in the interface  (shown as  for the overall interface design) use a common handshake mechanism and queue format to exchange data. As example queue format and handshaking mechanism uses buffer descriptors and ring buffers (known in the art) to exchange data between the host  and the module . All queues  through  within the interface are preferably bi-directional and use the same transport process regardless of the direction of the data flow.","It is to be understood that while the queue structure illustrated in  is a preferred embodiment, the invention is not limited to using queue such a queue design. For instance, the messaging and configuration that takes place between a module  and a host  could be performed with using as few as one queue, or as many queues or other types of data structures (linked lists, stacks, heaps, etc.) as may be required or desired in a memory such as shared memory . Alternatively, instead of queues, direct electrical connections in the form of signaling lines could be used to transmit the configuration and messaging information between host processor  and module processor . Those skilled in the art will readily understand that there may be many equivalent communication strategies that can be employed to effectuate such communications.","The shared memory  serves as the medium in which queues  through  are established. The exact queue configuration depends upon the services  offered by the module  and is established at system start-up. Preferably, each module  can support up to thirty-two (32) queues  through . These include the control queue , the EST queue , the GDB queue , and up to 29 data queues - through -N. Each queue  through  is assigned a unique ID value and is provided with a set of bit field flags (not shown) to support referencing the queues, handling interrupt processing, controlling messages, and so forth. Each queue  through  is established during the module startup procedure which will be described in detail next.","During the start-up process, in order for a host  to determine what services are offered by a module , the host  and module  create tables  and  in shared memory  as previously noted. Initially, the host  maintains the module  in a reset state while the host  creates the HCT table  in shared memory .","The contents of the Host Configuration Table  is provided below:",{"@attributes":{"id":"p-0087","num":"0086"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Host Configuration Table 334"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FIELD NAME","DESCRIPTION"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","Magic_Value","A unique value that is used"]},{"entry":[{},{},"to identify the start of"]},{"entry":[{},{},"the table."]},{"entry":["2","Host_Version","Software version number in"]},{"entry":[{},{},"use by the host."]},{"entry":["3","Host_Memory_Base","Indicates the host PCI base"]},{"entry":[{},{},"address used for module-to-"]},{"entry":[{},{},"host address translations."]},{"entry":["4","Host_Memory_Limit","Indicates how much"]},{"entry":[{},{},"memory is available to be"]},{"entry":[{},{},"mapped into a module"]},{"entry":[{},{},"address map."]},{"entry":["5","Control_TX_Queue_Address_Offset","Byte address offset of the"]},{"entry":[{},{},"base of the control receive"]},{"entry":[{},{},"message queue 403."]},{"entry":["6","Control_RX_Queue_address_Offset","Byte address offset of the"]},{"entry":[{},{},"base of the control transmit"]},{"entry":[{},{},"message queue 403."]},{"entry":["7","EST_TX_Queue_Address_Offset","Byte address offset of the"]},{"entry":[{},{},"base of the EST receive"]},{"entry":[{},{},"message queue 404."]},{"entry":["8","EST_RX_Queue_Address_Offset","Byte address offset of the"]},{"entry":[{},{},"base of the EST receive"]},{"entry":[{},{},"message queue 404."]},{"entry":["9","Max_Streams_Supported","Indicates maximum number"]},{"entry":[{},{},"of TDM streams supported"]},{"entry":[{},{},"for this module."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"The Host Configuration Table (HCT)  (Table 1 above) contains specific configuration information that the host system  passes to the module  during the startup procedure. That is, the HCT  is located in the shared memory  on the module  and is populated with the values for each field listed in the HCT  shown above. Preferably, there are nine fields (numbered  through  in this example) and each field is a 32 bit word. In practice, the module  is configured to have read-only access to the HCT , while the host  has read-write access.","The Magic_Value (field ) and Version_Number (field ) fields are used to identify to the module  the start of the HCT  and what software version number is being used to communicate with the module. The Host_Memory_Base (field ) field is an address field used to compute memory addresses between the host  and the module . In a preferred embodiment, address translations are performed using offsets from this base value given in field . Host_Memory_Limit (field ) indicates the amount of shared memory  space that the module  must map into its local address space in order to support memory accesses as a PCI initiator. The Control_TX_Queue_Address_Offset and Control_RX_Queue_Address_Offset (fields  and ) fields indicate the start of the control queue  transmit and receive areas, while EST_TX_Queue_Address_Offset and EST_TX_Queue_Address_Offset (fields  and ) specify the offsets in memory  to the EST queue  transmit and receive areas. Finally, Max_Streams_Supported (field ) specifies the number of TDM streams that the host  can physically support or provide to the module . The module  reads the value of field  in the HCT  and adjusts its capabilities accordingly during the start-up process, as will be explained.","The contents of the Module Identity IDT Table  is provided below:",{"@attributes":{"id":"p-0091","num":"0090"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Module Identity Table 333"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FIELD NAME","DESCRIPTION"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","Magic_Value","A unique value that is used to"]},{"entry":[{},{},"identify the start of the"]},{"entry":[{},{},"IDT table."]},{"entry":["2","Module_Version","Software version number in"]},{"entry":[{},{},"use by the module."]},{"entry":["3","Module_Memory_Base","Indicates the host PCI base"]},{"entry":[{},{},"address used for host-to-"]},{"entry":[{},{},"module address translations."]},{"entry":["4","Module_Memory_Limit","Indicates how much memory"]},{"entry":[{},{},"is available to be mapped into"]},{"entry":[{},{},"a host address map."]},{"entry":["5","Queue_Memory_Address_Offset","Indicates the address offset of"]},{"entry":[{},{},"on-module memory 264 that"]},{"entry":[{},{},"is available to the host 260 for"]},{"entry":[{},{},"queues 402 through 402-N"]},{"entry":[{},{},"and buffers."]},{"entry":["6","Queue_Memory_Size","Indicates the size of the"]},{"entry":[{},{},"on-module queue memory"]},{"entry":[{},{},"as a count of words."]},{"entry":["7","GDB_TX_Queue_Address_Offset","Byte address offset of the base"]},{"entry":[{},{},"of the GDB debug transmit"]},{"entry":[{},{},"queue 404."]},{"entry":["8","GDB_RX_Queue_Address_Offset","Byte address offset of the"]},{"entry":[{},{},"base of the GDB receive"]},{"entry":[{},{},"message queue 404."]},{"entry":["9","Max_Streams_Supported","Indicates maximum number"]},{"entry":[{},{},"of streams supported by"]},{"entry":[{},{},"this module."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"The EDT  (contents shown in Table 2) identifies specific information about the features of the module  and is accessible by the host . The descriptions of each field are provided in the table. Essentially, the IDT  reports to the host  the features and services  that the module  supports and also conveys any information needed to configure and control the module  during its support for services . The module  fills the IDT  once during the initialization process. Preferably, the contents of the IDT  remains constant from that point on. Alternatively, periodic updates to the IDT  can be subsequently detected by the host  in order to signal, for example, a new version of a protocol that has been downloaded into the module  from a source, such as the router .","In this embodiment, the information in both the IDT  and HCT  is presented in a fixed format. If additional fields are required in either table at a later date, the new fields can be added at the end of the table thus maintaining compatibility with existing mechanisms which use table fields that existed before any new fields are added. As an example, as new fields are added to the IDT , older legacy hosts  may not immediately recognize the new fields. However, adding to the end of the IDT  table allows the legacy hosts  to ignore the new fields that define new services or updated or advanced features and allows the legacy hosts  to only process the original fields in the IDT . This allows new features to be added to the modules  while maintaining backward compatibility with older carrier card hosts  that support the overall interface design of this invention but that do not support the new features or services. Once added, however a field in the IDT  or HCT  cannot be removed or redefined for a different purpose, so as to maintain compatibility standards. If a field in either table  or  becomes obsolete or is no longer needed for a service that is unused, it merely becomes a placeholder. Alternatively, a mechanism could be used to indicate to the host  or module  how many fields exist in the IDT and HCT tables ,  and which ones are related to which services, thus providing an un-fixed format.",{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIG. 8","b":["250","260","260","320","250","250","260","262","322","250","264","264","260","250","262","322"]},"The start-up operation begins at the top of the figure and progresses steadily downward, with each step being executed in turn. The arrows associated with certain steps indicate the direction of information flow. At step , the host  and module  are powered-up. The host CPU  then reads a \u201ccookie\u201d (not shown) from the module's serial EEPROM  in step . A \u201ccookie\u201d is a unique identification, such as a serial number, that allows the host  to determine the authenticity of the module . The host  then sets up a PCI memory map which determines the location and addresses of the shared memory . The module  is released from a reset mode in step  and initialization of the module  then begins in step .","The host  tests shared memory  in step  and writes or downloads a software image to the shared memory . The software image is the image executed by the module which allows the module to function properly. In step , the host  reads the download header of the image downloaded in step . The download header indicates where in shared memory  that the HCT  exists. The host  then populates the HCT  with values in steps  through , and releases the module controller  to begin executing the image downloaded in step . At this point in processing, the host  has established the HCT  in shared memory  and has provided the required information in the HCT  which the module  will need to determine how to configure itself.","In step , the module  begins to execute its image on module controller (CPU)  and tests the shared memory . Afterwards, the module  processes the HCT  by reading the field values  through  from the HCT . based on these values from the HCT , the modules writes configuration information into the IDT  in steps  and . That is, fields  through  are placed into IDT  at this point. Host  then reads the information from IDT  in step  to determine the services offered and the queues lengths required. The host  then establishes the queues  and  in step . Meanwhile, the module  runs power-up diagnostics in step .","Once the control queue  and EST queue  are established by the host , the module  polls for the existence of the control queue  in step  until an ok status is received. In step , the host  writes the Control_TX_Queue_Address_Offset, EST_TX_Queue_Address_Offset, Control_RX_Queue_Address_Offset and EST_RX_Queue_Address_Offset values (fields  through ) into the HCT  for the newly established control queue  and EST queue . The size and location of the control queue  and EST queue  are under control of the host  and are specified through the HCT  via step . The module  then reads these fields in step . At this point, the module  and host  are able to communicate control and error and status messages between each other via queues  and . In step  and , the module  returns the status of the power-up diagnostics commenced in step . After steps  through  are complete, the IDT and HCT tables ,  are initialized and service queue establishment is ready to be commenced.","Note that the GDB Debug queue  is optionally established and supported by the module . This queue may be setup and established in a similar manner as queues  and . If a module  supports the GDB debug queue , it will write a valid address offset into the IDT  at startup, which will be detected by the host  at which point this queue  will be established.","It should be understood that the actual exchange of data via queues may use a variety of known queue management techniques. For example, queue exchanges between an originator (i.e., host or module) and a receiver (the other of the host or module) can use a buffer descriptor list, free ring, and ready ring configuration, or a signaling mechanism of another sort.",{"@attributes":{"id":"p-0101","num":"0100"},"figref":["FIG. 9","FIG. 9","FIG. 9","FIG. 9","FIG. 7"],"b":["403","404","405","250","250","403","405","260","250","550","556","403","405","250","322","407"]},"The servicing of the out-of-band queues  through  begins once the processing of  is complete. In Step , queue processing commences and step  first checks to see if the control queue  is empty. If it is not empty, step  is executed to process the control message in the control queue  and then processing returns to the start . If in step , the control queue  is empty, queue service processing then checks to see if the EST queue  is empty in step . If the EST queue is not empty, step  processes any EST message in the EST queue  and returns processing to the start step . Finally and optionally, if the GDB Debug queue  is used, step  is processed if both the control queue  and the EST queue  were empty in steps  and . If the GDB Debug queue  is empty in step , processing returns to the start and repeats. If the GDB Debug queue  is not empty, step  processes the GDB message and returns to the start step  to repeat queue service processing.","In this manner, a queue service processing priority is established that first checks the control queue  for control messages, which are most important, and then checks the EST queue , and finally the GDB debug queue .","Once the control queue  and EST queue  are established and are being serviced via the processing of , the host  and module  are in communication. At this point, no data queues  have necessarily been established as initially, there are no active or setup data communications sessions. The mechanism by which the host  and module  interact to allow the servicing of connections uses an application programming interface (API) via the out-of-band control and EST queues  and  to pass messages back and forth.","An important aspect of the invention is the way in which a module  and host  interact with one another to determine an appropriate configuration that is dependant upon the services  offered by the module . The API provided by the invention includes a comprehensive set of message catalogs - through -N () which include specific message formats to determine or control or configure, for example, specific services  within a module . There can be, for example, a message catalog  for each of the different service types, such as a packet gateway message catalog - for data services, a voice message catalog for voice services, a data\/facsimile modem message catalog for data and facsimile protocols, an in-band signaling message catalog to control signaling events such as call setup, and so forth. Each message catalog  describes a set of host command messages and module responses that can be used to allow the host  to determine the services  offered by the modules . The service message catalogs can also be used to establish sessions of data communication using those services, where the services  of a particular type are controlled via the message catalog associated with that service . More specific details concerning each message catalog  will provided later, after a description of the general operation of the interface of this invention.","Through the use of the API, the carrier cards  and the modules  and the router  can appropriately configure themselves to most efficiently handle the data streams ,  and ,  for the different data services  that can be channeled through the modules  within the access server . A specific configuration may depend upon a service , for example, by allowing the alteration of queue depths, buffer sizes, error control used, flow control selected, and other aspects of communication. These parameters can be controlled via messages specific to the message catalog associated with the particular service. That is, the API allows the modules, carrier cards and router (,  and ) in the access server  to dynamically adjust their internal configurations to most effectively channel data communications. As such, the bandwidth for a particular type of service, such as data, video, fax or voice may be maximized while using only the hardware and processing resources necessary for that service.","All modules  support one or more services  which execute on the module . Generally, a service  is an algorithm that processes in-band data (versus out of band command and message communication between host and modules) between the TDM stream (,  in ) and the host platform . Services  are typically bi-directional and process both transmit and receive TDM stream data ,  (). To standardize the services  supported by the interface mechanisms of this invention, each service  is assigned a unique service ID code. The service ID code is a 32-bit value which is made up of the service type and the service mode. Together, the service type and mode uniquely identify one processing algorithm which is supported by the module . There may be many service types offered on a single module  according to this invention. Service types define a general family of the service (i.e. Modem, Voice, Fax, Video, etc.) and the service mode defines the particular algorithm for that type (i.e., G.711, G.729, etc.).","Example service types offered by modules  configured according to this invention are universal data services, data and fax modem services, voice services, digital data services, in-band signaling services, fax relay services, modem relay services, video services, and so forth. Future services which have not yet been introduced into the field of networking are contemplated as being supported by modules  on this invention as well.","Modules  use \u201cservice groups\u201d to report the number of sessions that can be supported by the module  for each service. Preferably, up to 16 service groups are supported by a module  in this invention. The actual number supported is determined by each modules  implementation. All modules support at least one service group. Services are assigned to groups based on their relative \u201ccost\u201d to support. Services are considered cheap if they require less processing and are thus assigned lower service group numbers than more expensive services which require high processing costs. An example of a cheap service is the voice G.711 protocol, while a video protocol may be an expensive service due to high bandwidth requirements. Thus, voice services such as G.711 may be assigned to service group 0, while Video services to be defined may be assigned a service group number such as 15. Table 3 below illustrates the relationship between services groups, services, and the maximum number of sessions supported by an example module .",{"@attributes":{"id":"p-0110","num":"0109"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Group\/Service\/Session Relationship"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"MAXIMUM NUMBER"]},{"entry":["GROUP NUMBER","SERVICES","OF SESSIONS"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","G.711, V.110","50"]},{"entry":["1","G.723, Data Modem, Fax","20"]},{"entry":[{},"Modem"]},{"entry":["2","G.728","10"]},{"entry":["3","Video","6"]},{"entry":["4-15","Other\/expensive","0"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Using a message query technique, a host  can query a module  via a special message to determine what services  are offered by the module . The information in Table 3 can be communicated to the host . During operation of the module  (i.e., while processing data), the module  can use messaging to report to the host platform  the number of remaining sessions that can be started for a service group number using a special message.","To facilitate the establishment of data queues  and to create active sessions that process data, various messages are communicated via the queues  through  between the host  and module . Generally, the three types of messages are 1) module messages, 2) session messages and 3) service messages.","Module messages are used to control operations at the module level on module . These messages support such things as self-test and diagnostics, module configuration control (discussed previously), software module resets, and data queue setup. Typically, module messages are used to control operations that effect the module  as a whole.","Session messages are used to control operations associated with session management. These operations include session setup and tear-down of a session, session start and stop, and session statistics and diagnostics. Any operation that affects a communications session independent of the services operating on data within that session falls into the category of being controlled via a session message.","Service messages are used to control generic operations associated with services . These includes set\/get messages for access to service configuration parameters, and alternatively can include notification messages indicating that the service is initialized.","Additionally, as previously alluded to, the messaging protocol aspect of the invention includes service message catalogs. Service message catalogs define specific messages used to control each service type. That is, these catalogs define custom command, response, and notification messages required to control a specific service. The messages are typically specific to each service and are grouped accordingly. All messages include an ID that is unique so that the host  or module  will be able to identify any message and act accordingly.","Message exchanges between the host  and module  are categorized further as either \u201ccommand messages\u201d, \u201cresponse messages\u201d, or \u201cnotification messages.\u201d","Command messages are sent from the host  to the module . Command messages sent to the module  are destined for one of three locations: the module manager , the session manager , or a service . These three module entities ,  and  provide varying levels of control that the host  can use to configure, manage and test the module , the sessions (e.g., communication connections channeling data through streams , , , ), and the services , respectively. All command messages are sent to the module  through the control and EST queues , . Response messages are generated by the module  and received by the host  in response to a command. They are generated as a solicited response from a command message. Notification messages are unsolicited messages that are preferably asynchronously sent from the module  to the host .","Management of the modules  is accomplished via module command messages. Table 4 below illustrates module command messages available for use in a preferred embodiment:",{"@attributes":{"id":"p-0120","num":"0119"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Module Command Messages Sent To Module 250 From Host 260"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["MODULE COMMAND",{}]},{"entry":["MESSAGE","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["MODULE_SET_PARAM","Sets a module configuration parameter."]},{"entry":["CMD","Host 260 can use this to pass down all"]},{"entry":[{},"necessary operating information to the"]},{"entry":[{},"module. Typically this is used"]},{"entry":[{},"immediately after power-up."]},{"entry":["MODULE_GET_PARAM","Queries a module configuration"]},{"entry":["CMD","parameter"]},{"entry":["MODULE_RUN_DIAG","Starts a diagnostic self-test. The tests"]},{"entry":["CMD","commanded can vary in their intrusive-"]},{"entry":[{},"ness and when they can be executed."]},{"entry":[{},"Some tests require that the module 250"]},{"entry":[{},"be idle with no active sessions. Other"]},{"entry":[{},"tests may require the software on the"]},{"entry":[{},"module to be re-downloaded."]},{"entry":["MODULE_TEARDOWN","Performs a systematic tear-down of all"]},{"entry":["CMD","sessions on the module. At the com-"]},{"entry":[{},"pletion of this command, the module"]},{"entry":[{},"250 will be idle with no active sessions"]},{"entry":[{},"and all data queues 402 and TDM"]},{"entry":[{},"streams 331, 332 will be unassigned."]},{"entry":["MODULE_SETUP_DATA","Initializes the data queue information"]},{"entry":["QUEUE_CMD","to exchange in-band data buffers. The"]},{"entry":[{},"host 260 uses this command to instruct"]},{"entry":[{},"the module 250 about the location of the"]},{"entry":[{},"data queues 402."]},{"entry":["MODULE_SETUP","Configures the module for interrupt use"]},{"entry":["INTERRUPT_CMD","with message and data queues 402"]},{"entry":[{},"through 405, if interrupt processing is"]},{"entry":[{},"supported."]},{"entry":["MODULE_NOP_CMD","Pings the module to determine if an idle"]},{"entry":[{},"module 250 is still alive and available."]},{"entry":["MODULE_GET","Queries a module for capabilities. Used"]},{"entry":["CAPABILITY_CMD","during initialization of module\/host."]},{"entry":["MODULE_GET","Queries a module for currently sup-"]},{"entry":["SERVICES_CMD","ported services. Host 260 queries each"]},{"entry":[{},"service group separately until no"]},{"entry":[{},"services response is returned."]},{"entry":["MODULE_SPU_CMD","Control or send a command to a service"]},{"entry":[{},"processing element. This message can"]},{"entry":[{},"enable and disable a service"]},{"entry":[{},"processing element."]},{"entry":["MODULE_GET","Queries a module for interrupt infor-"]},{"entry":["INTERUPT_INFO_CMD","mation regarding the"]},{"entry":[{},"interrupts supported."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Table 5 below lists response messages that are sent to a host  from the module  in response to commands or events which occur at the module level, such as the commands from Table 4 above.",{"@attributes":{"id":"p-0122","num":"0121"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 5"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Response Messages Sent from Module 250 to Host 260"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["MODULE RESPONSE",{}]},{"entry":["MESSAGES","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["MODULE_ACK_RSP","Sent to host to indicate that a command"]},{"entry":[{},"message was received and successfully"]},{"entry":[{},"processed by the module."]},{"entry":["MODULE_NAK_RSP","Sent to host to indicate that an erred"]},{"entry":[{},"command message was received by the"]},{"entry":[{},"module. The error indicated may be"]},{"entry":[{},"the result of either invalid message"]},{"entry":[{},"content or incorrect message timing."]},{"entry":["MODULE_RUNTIME","Sent to host to indicate failure was"]},{"entry":["ERR_NTF","detected within the module."]},{"entry":["MODULE_DIAG_RSP","Sent to host after the module has"]},{"entry":[{},"completed executing one of the"]},{"entry":[{},"diagnostic self tests. Fields in"]},{"entry":[{},"message indicate tests that failed."]},{"entry":["MODULE_DATA","Sent to host to indicate the result"]},{"entry":["QUEUE_CREATED_RSP","of a module data queue setup"]},{"entry":[{},"command message."]},{"entry":["MODULE_PARAM_RSP","Returns the value of a module"]},{"entry":[{},"configuration parameter."]},{"entry":["MODULE_TEARDOWN","Indicates to host that tear down of"]},{"entry":["COMPLETE_RSP","module is complete."]},{"entry":["MODULE_CAPABILITIES","Used by module to indicate to host"]},{"entry":["RSP","the features of the interface 400"]},{"entry":[{},"which are supported by the module."]},{"entry":["MODULE_SERVICES","Returned to host from module to in-"]},{"entry":["RSP","dicate the services 340 supported,"]},{"entry":[{},"the service group of each service, and"]},{"entry":[{},"the maximum number of sessions per"]},{"entry":[{},"service group."]},{"entry":["MODULE_NOP_RSP","Contains an echo word from the NOP"]},{"entry":[{},"command messages."]},{"entry":["MODULE_SPU_NTF","Indicates the results of the module SPU"]},{"entry":[{},"command."]},{"entry":["MODULE_INTERRUPT","Returns interrupt information including"]},{"entry":["INFO_RSP","on-module locations for doorbell and"]},{"entry":[{},"handshake memory locations."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Besides module command messages which control the general operation of the module as a whole, another aspect of the invention is session management using session command messaging. A session essentially is a service  that is processing data in some manner via a service processing unit . Sessions are managed between the host platform  and the module  using messages exchange between the host  and the session manager . All sessions transition through the same states during start-up, execution and tear-down.","An IDLE session state indicates that a session of the desired service  has been instantiated and its internal initiation is complete. At this point however, no TDM stream ,  processing is occurring. In the IDLE state, a data queue  is active for in-band configuration and control queue  is available for sending out-of-band configuration messages to the session.","An ACTIVE session state indicates that a session has begun to process TDM stream data on channels , . Out-of-band service catalog messages can be sent to the service  session while in the ACTIVE state. That is, messages from the catalog associated with a service of the session can be used to control the service .","Another session state is RX_XOFF, which indicates that a service session  has ben flow controlled and no TDM receive stream data  will be processed. Transmit flow control occurs by the host  not posting any transmit data to the Transmit Data Queue of data queue -N that is associated with this session. Out-of-band service message catalog messages can be sent to the session while in this state.","Finally, a data communications session can be in the FLUSHING state. This state indicates that a session has been stopped or changed and that the service  is in the process of flushing any RECEIVE data from its associated data queue -N. A session will remain in this state until the host  (or module , depending on data flow direction) returns all outstanding data buffers thus acknowledging and indicating that the data has been removed from the data queue . Out-of-band service messages can be sent to a session in the FLUSHING state.","Table 6 below lists the session command messages that are sent from the host  to the session manager  to manage data queues  and services . The commands handles by the session manage can be service independent. They provide a standard method for control of the services  that the module  supports.",{"@attributes":{"id":"p-0129","num":"0128"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 6"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Session Command Messages from Host 260 to Module 250"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SESSION COMMAND MESSAGE","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["SESSION_SETUP_CMD","Instruct module to launch a"]},{"entry":[{},"service and assign a data"]},{"entry":[{},"queue to that service."]},{"entry":["SESSION_TEARDOWN_CMD","Detaches a service from the"]},{"entry":[{},"TDM channel 331, 332 and"]},{"entry":[{},"the data queue 402."]},{"entry":["SESSION_START_CMD","Start processing data using"]},{"entry":[{},"the service 340."]},{"entry":["SESSION_STOP_CMD","Used to stop the exchange"]},{"entry":[{},"of in-band data between a"]},{"entry":[{},"TDM Transmit or Receive"]},{"entry":[{},"stream 331, 332 and the"]},{"entry":[{},"host 260. After the service"]},{"entry":[{},"340 stops, it transitions to"]},{"entry":[{},"the FLUSHING state and"]},{"entry":[{},"no further data processing"]},{"entry":[{},"occurs."]},{"entry":["SESSION_CHANGE_SERVICE_CMD","Used to change the service"]},{"entry":[{},"that is executing on the"]},{"entry":[{},"TDM channel 331, 332."]},{"entry":["SESSION_QUERY_CMD","Query a service 340 for"]},{"entry":[{},"statistical information."]},{"entry":["SESSION_SET_MAX_INFLIGHT_RX","This command supports"]},{"entry":["BUFS_CMD","flow control of in-band"]},{"entry":[{},"receive data for a"]},{"entry":[{},"session of a service 340."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"As indicated in Table 6, the SESSION_SETUP_CMD is used to bind the service  to a data queue . To start a service, the host  must specify in the SESSION_SETUP_CMD command a session ID, a data queue ID, a service type\/mode and if the session is a universal port. The session ID is assigned by the host  and is used in subsequent session management command messages to identify the instance of the service  that data is being sent to. The data queue ID indicates the source and destination data queue  of in-band data. The service type and mode specify the processing protocol (i.e., what specific service protocol) that will be executed, and thus also determines which service message catalog is to be used to control the service. The universal port indication in the SESSION_SETUP_CMD command is provided to indicate if the module  should reserve resources to support changing the session from one service  to another. Thus, the SESSION_SETUP_CMD allows the module  to prepare itself for the capability of changing services  in mid-session. In other words, a module  configured according to this aspect of the invention allows multiple services  to be offered to a single data communications session and allows the session to switch between the services  during the same call.","The second command used to control sessions of services  is the SESSION_TEARDOWN_CMD command. After this command executes, the TDM channels ,  and data queue  associated with the packet data are no longer associated with the service  to which the command is directed and are available to be re-assigned. The service  will no longer respond to any service messages sent to it. Preferably, in operation it is recommended that the session be disabled prior to being torn down with this command. Disabling the session (via the SESSION_STOP_CMD) will stop the data exchange between the host  and the service  executing on the module  in a controlled manner. Any data buffers within the queues  through  will be flushed and any new queue data will be ignored. If the service  is not disabled prior to the tear-down command, the service  will drop any data buffers in progress and will immediately terminate.","One feature of this aspect of the invention is that if a host  posts messages to a service  on the module  that has been torn-down and the session ID has not be reassigned, the messages are dropped. However, if the session ID is reassigned, the messages to the session ID will be sent to the new service . In other words, a single data communications session (i.e., an instantiation of data transfer that is operated upon via a particular service ) can be re-assigned to different services  during the life of the session. The session can maintain the same session ID. As such, messages sent to the session ID can be used to control the session no matter which service  is currently operating on data transferred within the session.","By using the SESSION_START_CMD, a service  can begin to process data. More specifically, the SESSION_START_CMD command is used to start the exchange of in-band data between a TDM channel ,  and the host . After the service  has been setup (Using SESSION_SETUP_CMD), it is in the IDLE state and no TDM channel data processing is occurring. In order to have the service start processing TDM channel data, the host  sends the SESSION_START_CMD message to the module . Upon receipt of the SESSION_START_CMD, the service  for which the command was sent begins processing receive and transmit data bytes over the data queues  and the TDM. Receive and Transmit ports , .","The SESSION_CHANGE_SERVICE_CMD command is used to change the service  that is being used to process data for the session (i.e., data passing over the TDM Transmit and Receive streams , ). The host  is permitted to modify both the service  and the data queue  that is being used. When the new service  is started, it will be initialized with a set of default service parameter values and will be left in the IDLE state. The host  can then modify the local configuration of the service  if desired via other messages. When the desired configuration has been set, the host issues the SESSION_START_CMD command to instruct the new service  to begin processing data. The SESSION_QUERY_CMD can be used to query a session of a service  to determine its status. The host  can also use the SESSION_START_CMD command when a service  is being re-started on the same TDM channels , .","The session manager  and services  on the module  can respond to the session commands listed in Table 6 via a number of session response and notification messages as listed in Table 7 below. The session response and notification messages are sent from the session manager  executing on the module  to the host  and the commands indicate the disposition of the session command messages (Table 6) received from the host  and processed on the module .",{"@attributes":{"id":"p-0136","num":"0135"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 7"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Session Response and Notification Messages"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SESSION RESPONSE\/",{}]},{"entry":["NOTIFICATION MESSAGES","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["SESSION_SETUP_COMPLETE_RSP","Contains results of the"]},{"entry":[{},"session setup command."]},{"entry":["SESSION_TEARDOWN_COMPLETE","Contains results of the tear-"]},{"entry":["RSP","down command."]},{"entry":["SESSION_START_RSP","Contains results of the start"]},{"entry":[{},"command."]},{"entry":["SESSION_STOP_RSP","Contains results of the stop"]},{"entry":[{},"command."]},{"entry":["SESSION_STATUS_RSP","Contains results of a"]},{"entry":[{},"session query command in-"]},{"entry":[{},"dicating the session status."]},{"entry":["SESSION_STATE_REACHED_NTF","Notifies the host 260 that"]},{"entry":[{},"the module service 340 has"]},{"entry":[{},"reached a particular session"]},{"entry":[{},"state."]},{"entry":["SESION_REMOTE_FLOW_CONTROL","Notifies host 260 of far end"]},{"entry":["NTF","flow control."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"As indicated in Table 7, the SESSION_SETUP_COMPLETE_RSP message indicates the results of the session setup or session change command messages. A failure to setup the session of a service  means that no resources (i.e., shared memory  or data queue  space) have been allocated and that TDM timeslots of the time multiplexed TDM streams , , data queues , and session ID are in the same state that they were in prior to the setup command. The timing of this response message is an indication that the session manager  on the module  has reserved TDM timeslots in the TDM channels ,  and has allocated any required resources for this session of a service . A TDM timeslot map (not shown) is maintained and used to indicate the location the module  has chosen to start the service  for the session. The host  can thus direct in-band TDM data to the timeslot\/stream for processing. The other response and notification messages are generally self-explanatory as indicated by their descriptions in Table 7.",{"@attributes":{"id":"p-0138","num":"0137"},"figref":"FIG. 10","b":["340","560","661","562","563","323","250","260","564","565","566","567","564","564","567","570","571","562","562","564","567","568","569","340","260","250"]},"Another aspect of the messaging interface between the host platform  and the module  is management of services  on the module . The interface being described herein provides a few generic messages that are used to communicate with the service  executing on the module . These messages are intended to standardize the method all services  use to access their configuration parameters , .","Service configuration parameters ,  () are provided for each service  as a means for the host  to configure and control the operation of a service  on a module . For each service type that the module  supports, a unique set of configuration parameters (Default set  and specific or local set ) exists that controls the operation of that service . Within each configuration parameters set , , the actual parameters can be divided into two groups: static and dynamic.","Static parameters are those that are established while the service  is disabled (i.e., before any data processing occurs). Static parameters do not change while the service  is enabled. Dynamic parameters are those which can be altered while the service  is enabled and processing data. Dynamic parameters take effect immediately. Each service  determines which of its own parameters are static or dynamic. The messaging interface treats both static an dynamic parameters the same, and it is up to the host  and service  to define how each parameter is expected to be controlled.","Within the module , a default configuration set  is maintained for each service type . The default configuration  represents the values used to start the service  when the SESSION_SETUP_CMD command is received. Since each service  on a module  requires a context to initialize itself, the default configuration set  is used for this purpose. The default configuration values for each service type can be retrieved or modified using \u201cservice set\u201d and \u201cservice get\u201d commands, as will be explained. To reference the default configuration parameters , the service type must be specified.","Once a service  has been set up using the SESSION_SETUP_CMD command, that service  has it's own local configuration parameter set . That is, once a service  is setup, it maintains a distinct set of parameters  which are local to that service. Any changes made to the default configuration  for the general service  at that point do not immediately affect a service  that has been setup and that has \u201ccopied\u201d the general default configuration  into a local set of parameters  for use by that instantiation of the service . That is, each set up service  maintains its own set of local parameters  that are initially based upon the default set . Changes to the static parameters of either the default set  or the services  local set  made after a particular service  is setup do not effect the set up service . However, changes made to dynamic parameters within the local configuration  associated with the set up service  take effect immediately. Changes made to the static parameters within the local configuration  associated with an instantiated service  do not take effect unless the service is stopped and restarted.","This aspect of the invention thus provides two mechanisms for a host  to configure a service . In the first method, the host  writes all configuration parameter values into the default configuration set  for a type of service . Next, the host  issues the session setup command to start the service . Finally, the host  issues the session start command to begin processing data by the service . In this case, the service  will use the default set  as its own local set .","Alternatively, the second method begins with the host  issuing the session setup command to start the service  with the default configuration parameters . The host  then writes the new configuration parameter values into the service's local configuration , which allows the host  to immediately modify a service  by changing parameters in set . Next, the host can issue the session start command to start the service with the new configuration values of dynamic or static parameters in set , and begin processing data by the service .","Either method will work and it is up to the host  to decide which method is used. In this manner, this aspect of the invention provides a way to alter services dynamically. Moreover, as services change over time, a module configured with a default set  for each service type can be updated using the messages to alter the default set  or the local set .","Table 8 below lists the various service command messages that are sent from the host  to the module  to manage default and local service configuration parameters associated with the services .",{"@attributes":{"id":"p-0148","num":"0147"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 8"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Service Command Messages Sent from Host 260 to Module 250."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SERVICE COMMAND MESSAGE","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["SERVICE_SET_DEFAULT_PARAM","Set the default configuration"]},{"entry":["CMD","values associated with a"]},{"entry":[{},"service type 340."]},{"entry":["SERVICE_SET_LOCAL_PARAM","Set the local configuration"]},{"entry":["CMD","values for a local"]},{"entry":[{},"instantiation of a service"]},{"entry":[{},"340 set up on a module 250."]},{"entry":["SERVICE_GET_DEFAULT_PARAM","Obtain the default con-"]},{"entry":["CMD","figuration values associated"]},{"entry":[{},"with a service 340 type."]},{"entry":["SERVICE_GET_LOCACL_PARAM","Obtain the local con-"]},{"entry":["CMD","figuration values for a local"]},{"entry":[{},"instantiation of a service 340"]},{"entry":[{},"setup on a module 250."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"As noted previously, the SERVICE_SET_DEFAULT_PARAM_CMD command passes down to the a service  from the host  all necessary operating information to a default configuration area  associated with a service  prior to the session start command message. Any changes made to the service default configuration  will have no affect on a service  that is already setup, however any subsequent session setup commands messages will pick up the new configuration values in the configuration .","The SERVICE_SET_LOCAL_PARAM_CMD command is used to set the configuration parameters contained with the services local configuration . The host  can use this command to pass down all necessary operating information to a service  that has been set up. Any changes made to the dynamic parameters will take effect immediately on the service , while changes made to static parameters will only take effect if the session is stopped and restarted.","In response to the messages and commands of Table 8, service response messages are sent to the host  for the services  in response to configuration queries. Table 9 below lists the service configuration response messages sent from the service  on module  to the host .",{"@attributes":{"id":"p-0152","num":"0151"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 9"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Service Response Messages Sent From Module 250 to Host 260"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SERVICE RESPONSE MESSAGE","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["SERVICE_DEFAULT_PARAM_RSP","Passes back results of the get"]},{"entry":[{},"default parameter query for a"]},{"entry":[{},"service type 340."]},{"entry":["SERVICE_LOCAL_PARAM_RSP","Passes back results of a get local"]},{"entry":[{},"parameter query from a set up"]},{"entry":[{},"service 340."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Each of the service response messages in Table 9 can return result code which indicate various information about the configuration of a service . Information such as Session ID, Data Queue ID, Receive Memory Block, Transmit Memory Block, and resources in use (i.e., data queues being used, service ID in use, timeslots in use, and so forth) can be included in the response messages. This allows the host  to determine the current configuration of services .","One objective of the system provided by this invention is to standardize the communication and control mechanisms used between modules , carrier cards  and router  in devices such as an access server . The prior art paradigm is to create a new carrier card for each platform (i.e., access server, router, bridge, switch, as so forth) each time a new port card module is developed to offer a new service (i.e., fax, data, voice, and so forth). The reasoning behind this prior art approach is caused in part by differences in physical connectors as well as variances in port card module architectures to support the differing services. Thus, prior art modules varied due to service requirement variations, and the carrier cards varied in prior art systems as well since they provided the glue layer between the modules and the host system or platform.","Benefits provided by the design of the module  and carrier card  include Universal Port Control which provides consistent port control independent of the port application or service  offered. The system also provides backward compatibility with existing interface specifications (such as the Portware API and Symphony DSP Host Interface specifications manufactured by Cisco Systems of San Jose, Calif.), which are implemented in the router internetwork operating system (IOS) and are downloaded into the firmware of the module  at boot time.","Scalabilty is also provided which can support extremely high density port card modules  that can take advantage of future developments and miniaturization of components to allow higher connection densities per module . This systems also provides extensibility for future support for additional port applications and services not yet on the market. In operation, the system of this invention maximizes the data throughput rate and minimizes latency, the time spent processing each datagram or packet in shared memory . The system also supports both polled and interrupt notification methods and is generally based on a \u201cblack box\u201d design of module  allowing the module  to act as a plug-and-play component for a multi-service carrier card  or router backplane.","Using the interface mechanisms described herein including the software messaging system and API, only one carrier card  per platform (i.e., dial shelf ) is required. The carrier card  can be populated with a variety of modules  which support differing applications and services such as modem, voice, ISDN, and so forth. This approach eliminates redundant software development and increases the re-use achieved on a carrier card . It also permits modules  that conform to the NextPort API and form-factor to be swapped among platforms.","It should be understood by those skilled in the art that the architecture and operation of module  supports a methodology which hides the TDM stream and timeslot selection from the host . That is, when a service  is started by detection of incoming data , the module  makes the decision which stream and timeslot should be used for this service . In this way, the module  is responsible for management of TDM streams  and resources (i.e., services ) on the module , not the host . This allows a module  to support many different services  and also provides support for private streams to a module which can be mapped from various TDM streams  () arriving from the framer trunk cards over a TDM backplane within the dial shelf . Call management, however, is not handled by the module . Rather, call management is handled by another circuit, such as the framer trunk cards  or the host .","By providing multiple services within one module , TDM stream management is placed within the module , rather than being controlled by the host  or another circuit, as in prior art systems. This avoids the prior art problems of requiring a host  or other component from having to understand what stream ,  can be used to start a particular service on which module, and then having to command the module to start the service on that stream.","Since the system de-couples the host  from the intimate details of any specific module or service, future modules can be integrated with a minimal impact on the host . The interface  also allows services  to provide support for connections of varying types, such as digital modems, fax modems, ISDN technologies, voice and video services, and so forth.","By allowing the module  to determine service support and operational characteristics, ever increasing port densities are supported by a module  configured according to the invention. Moreover, a universal session solution is provided herein that can accommodate any service on any connection and can allow a connection to change service without having to re-establish a connection. Scalabilty and expandability problems encountered with previous generations of prior art modules are also solved.","The system of the invention allows the ability to adapt to the requirements of future services. The messaging API system of this invention utilizes the shared memory interface via shared memory  to encapsulate the capabilities of a particular module  into the tables  and  that processing within the IOS executing on the router shelf  or carrier card  can interpret. Since the tables  and  can be used to define the eventual methods and configuration parameters selected to communicate with any module  which supports the API, flexibility is provided for future capabilities of modules  and carrier cards (hosts) , and router shelf . The Tables  and  also allow the control and status messaging, data queues, and application and service types supported by modules  on hosts  to be announced to the router systems in the router shelf  via the API system. This allows the router to dynamically identify module cards  that have been inserted into the carrier card\/host backplane  and allows determination of services  and function supported overall by the dial shelf .","Also, as service standards change, future modules  that are developed to support any new services  will be supported by carrier cards  that can inquire as to the new requirements of the new service. For example, a voice service standard may specify a specific packet length which could change in future versions of the standard. When a host  using the system of the invention requests the packet length for the configuration ,  for the service  on a new module , the most up-to-date information will be provided and the host  can correctly implement the new version of the service .","Likewise, if a service changes, an older module  that uses an out-of-date packet length but that is equipped with this invention can be updated by changing, for example, the configuration ,  for a service  that is initially configured for the old packet length. As the voice standard is changed, a module  supporting this change is detected via the system described herein. As such, queue lengths and buffer sizes can be adjusted to most accurately support the new voice standard. Further still, instead of having to provide a new module  encoded with the change, the API can be used to inform the programmable module card  to adjust it's existing voice standard protocol configuration ,  to reflect the changes made in the new standard.","As discussed previously, services  within the modules  can be controlled in this invention using messages. The particular messages used are preferably selected by the host  from service message catalogs  () which are maintained in the host . Each service message catalog  includes one or more messages each having a unique identification number (ID) which falls within a range of message numbers assigned to that message catalog . During the startup procedure (), when a module  returns a one or more service ID numbers in the IDT table  indicating to the host  which services  are supported by that module , the host  can select message numbers from the range of messages associated with the services offered.","For example, if a module  supports data and fax modem services, service IDs in the IDT  will exist for a data service, a fax service, and a data\/fax service. Using the service ID numbers, the host  can uses the messages from the data\/fax message catalog - to control these services , by selecting messages having message numbers in the range associated with each of these services . In other words, the API of this invention reserves ranges of message ID values for each message for each service  in a service message catalog . Examples of the types of message catalogs  that exist are a digital data message catalog, a data\/fax modem message catalog, a packet gateway service message catalog and an in-band signaling catalog. These are merely examples and the invention is not limited as such. Other service message catalogs can be created and used for other services, such as video, for example.","The digital data service message catalog - contains messages that are exchanged between the host  to the module  to establish and control sessions of services  that support digital data communication via the Integrated Services Digital Network (ISDN) protocols. Messages within this catalog can be used to control and establish digital data configuration parameters such as the mode of digital data communications (i.e., Clear Channel, V120, V110), line speed (i.e., 600 bps up to 64 Kbps), flow control, data and parity and stop bit selection, and PPP\/SLIP enablement. Also, ISDN dial-out numbers may be passed between the host  and the module  using messages in this message catalog.","The data\/fax modem message catalog - defines the message formats for use with data and fax modem services  within a module . Modem command messages within the data\/fax message catalog - control operations of data and fax modem services  include messages for performing operations such as initiating modem rate negotiations, modem testing, selecting framing modes, setting escape map sequences for PPP modes, retrieving modem states and link status and configuration and rate of service information. Response messages from the module  to the host  include modem and fax state responses, link responses, configuration responses, break detection, and dialstring return messages to the host .","An in-band signaling message catalog - is provided which includes messages used to provide control and notification of signaling events. Signaling messages in message catalog - are exchanged between the host  and the module  to manage such tasks as generating dial digits, starting and stopping dial digit generation, and starting and stopping the generation of call progress tones. Corresponding response message sent from the module  to the host  are also provided. The in-band signaling messages can encode standardized DTMF\/MF\/R1 and R2 digit encoding, as used by modems and other devices when providing call services. These messages can be used, for example, to allow signaling to a modem service  to generate digits to place a call onto WAN  or  ().","A packet gateway service message catalog - is also provided as an aspect of this invention. Packet gateway services  are those that perform the conversion of traditional telephony service (e.g., data, fax, modem) for transport through a packet network, such as LAN  (). This gateway connection can provide a bypass connection between two telephony (i.e., circuit switched) networks, or may be used between a telephony gateway and a native packet network such as LAN , or the Internet. Configuration parameters established and controlled through the use of packet gateway messages from message catalog - include such parameters as input and output gain; in-band signal detection enablement for fax, modem and voice; echo, noise and gain cancellation and control, playout de-jitter modes and delays, loop-back enablement, SSRC and VPXCC parameters, framing support, sequence numbering and other related parameters involved with call handling as understood by those skilled in the art.","Voice service command messages can also be provided within the packet gateway message catalog - to control aspects of voice services  such as starting and stopping in-band tone generation, generation of dial digits, and queries for information from the voice service . Response messages sent form the module  to the host  related to packet gateway services for voice, fax and data includes messages related to dial digit detection, playout control statistics, voice levels, and other statistics.","Command and response messages are also provided in packet gateway message catalog - for facsimile and modem data services such as fax relay (transmit, receive, playout, control and data pump statistics) and modem relay control.",{"@attributes":{"id":"p-0173","num":"0172"},"figref":["FIGS. 11A and 11B","FIG. 11A"],"b":["500","502","503","501","502","503","120","500","504","505","500","501"]},"Alternatively, as shown in , a packet gateway  equipped with this invention can serve as a gateway between an end-user  and a personal computer  coupled to packet network  that is equipped with application software such as NetMeeting which provides voice-over-IP service to a user of the personal computer .","While this invention has been particularly shown and described with references to preferred embodiments thereof, it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the spirit and scope of the invention as defined by the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing and other objects, features and advantages of the invention will be apparent from the following more particular description of preferred embodiments of the invention, as illustrated in the accompanying drawings in which like reference characters refer to the same parts throughout the different views. The drawings are not necessarily to scale, emphasis instead being placed upon illustrating the principles of the invention.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 11A"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 11B"}]},"DETDESC":[{},{}]}
