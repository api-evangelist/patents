---
title: Coordinate wrapping for anisotropic filtering of non-power of two textures
abstract: An apparatus and method for using non-power of two texture maps with anisotropic filtering is described. An anisotropic perturbation is applied to a texture map coordinate to produce a perturbed texture coordinate. A wrapped texture map index for various wrap modes is computed using the perturbed texture coordinate and an LOD width. In addition to the anisotropic perturbation, the perturbed texture coordinate may also include a tap perturbation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07091983&OS=07091983&RS=07091983
owner: NVIDIA Corporation
number: 07091983
owner_city: Santa Clara
owner_country: US
publication_date: 20040526
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DISCLOSURE OF THE INVENTION"],"p":["One or more aspects of the invention generally relate to computer graphics, and more particularly to anisotropic filtering of texture map data.","Conventional graphics processors are exemplified by systems and methods developed to read and filter texture map samples. To simplify the texture map filtering performed within a graphics processor, a texture is prefiltered and various resolutions of the prefiltered texture are stored as mip mapped texture maps.  is a conceptual diagram of prior art showing a mip mapped texture including a highest resolution texture map, Texture Map . A Texture Map , a Texture Map , and a Texture Map  are successively lower resolution texture maps, mip maps, each storing prefiltered texture samples.","Classic mip maps are isotropically filtered, i.e. filtered symmetrically in the horizontal and vertical directions using a square filter pattern. Isotropically filtered mip maps result in high quality images for surfaces with major and minor texture axis that are similar in length. However, when an isotropically filtered texture is applied to a receding surface viewed \u201con edge\u201d, aliasing artifacts (blurring) become apparent to a viewer as the texture is effectively \u201cstretched\u201d in one dimension, the receding direction, as the texture is applied to the surface. A Footprint  is a pixel footprint in texture space, with a Position  being the pixel center.  illustrates a prior art application of Texture Map  applied to pixels of a Surface  that is receding in image space. When viewed in image space, Footprint  (an ellipse) appears as Footprint  (a circle). While isotropic filtering of texture samples within a pixel footprint that forms a circle in texture space results in a high-quality image, isotropic filtering of texture samples within a pixel footprint that forms an ellipse, such as Footprint , results in an image with aliasing artifacts. In contrast to isotropic filtering, anisotropic filtering uses a rectangular shaped filter pattern, resulting in fewer aliasing artifacts for footprints with major and minor axes that are not similar in length in texture space.",{"@attributes":{"id":"p-0005","num":"0004"},"figref":["FIG. 1C","FIG. 1D","FIG. 1A","FIGS. 2A and 2B"],"b":["115","125","130","150","130","150","115","101","101","115"]},"Traditionally texture map dimensions are powers of two in order to simplify computations used to convert from texture parameters represented in surface space to texture coordinates represented in texture space. Specifically, a texture map dimension, n, that is a power of two may be expressed as n=2, where i is an integer. The texture coordinates are used to read texture map samples from memory. Power of two texture maps are also used to simplify computations used to support the wrap modes shown in .  illustrates a texture map applied to a square surface using a \u201crepeat\u201d wrap mode.  illustrates a texture map applied using a \u201cmirror\u201d wrap mode. When non power of two texture maps, such as a video image that has not been resampled, are used, computing wrapped texture coordinates is more difficult, i.e., requiring division by an arbitrary value.","Accordingly, there is a need to use non-power of two texture maps, such as a video image. Furthermore, there is a need to apply non-power of two texture map to a surface using a wrap mode, such as repeat or mirror wrap mode; there is also a need to use such techniques in combination with anisotropic filtering.","The current invention involves new systems and methods for using non-power of two texture maps. A non-power of two dimension image may be used as texture map without resampling to produce a power of two dimension texture map. Furthermore, the non-power of two texture map may be anisotropically filtered and applied to a surface using various wrap modes.","Various embodiments of a method of the invention include receiving a texture map coordinate corresponding to a non-power of two texture map, receiving an LOD width corresponding to the non-power of two texture map, applying an anisotropic perturbation to the texture map coordinate to produce a perturbed texture map coordinate, computing a texture map index based on the perturbed texture map coordinate, determining whether the texture map index is positioned outside of the non-power of two texture map, and computing a wrapped texture map index based on the texture map index and the LOD width when the texture map index is outside of the non-power of two texture map.","Various embodiments of the invention include an anisotropic unit for determining texture map indices for non-power of two texture maps. The anisotropic unit includes a perturbation unit, an index computation unit, and an anisotropic wrap unit. The perturbation unit is configured to apply a perturbation to a texture coordinate corresponding to a non-power of two texture map and produce a perturbed texture coordinate. The index computation unit is configured to receive the perturbed texture coordinates and produce a texture map index. The anisotropic wrap unit is configured to receive the texture map index and produce a wrapped texture map index for the non-power of two texture map responsive to a wrap mode.","Various embodiments of the invention include a programmable graphics processor for using non-power of two texture maps.","In the following description, numerous specific details are set forth to provide a more thorough understanding of the present invention. However, it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details. In other instances, well-known features have not been described in order to avoid obscuring the present invention.","In conventional graphics processing, an image with a non-power of two dimension, such as a video frame, is resampled to produce a power of two texture map that is designated as the highest resolution level of detail (LOD) texture map, LOD. More recently, a non-power of two texture map designated as LOD may be an image that has not been resampled, such as a video frame. Mip map texture maps that are filtered versions of the image may be generated such that each dimension of a mip map texture map is an arbitrary value, in particular, not a power of two.","For example, in a first embodiment a LOD texture map is 223\u00d7223 texels, a LOD texture map is 112\u00d7112 texels, a LOD texture map is 56\u00d756 texels, a LOD texture map is 28\u00d728 texels, and so forth. In a second embodiment, a LOD texture map is 223\u00d7223 texels, a LOD texture map is 157\u00d7157 texels, a LOD texture map is 111\u00d7111 texels, a LOD texture map is 78\u00d778 texels, and so forth. Therefore, a dimension of a mip map texture map may be greater than half of the corresponding dimension in the adjacent higher resolution map. In a third embodiment, a LOD texture map is 223\u00d7223 texels, a LOD texture map is 111\u00d7111 texels, a LOD texture map is 55\u00d755 texels, a LOD texture map is 27\u00d727 texels, and so forth. Therefore, a dimension of a mip map texture map may be less than half of the corresponding dimension in the adjacent higher resolution map. In an alternate embodiment, an LOD texture map and mip map texture maps are rectangular non-power of two texture maps. In a further alternate embodiment, LOD texture map and mip map texture maps are more than two dimensions.","Each texel within a texture map corresponds to unnormalized texture coordinates, such as u, v, and p, that are dependent on the texture map size. Unnormalized texture coordinates, e.g., u, v, and p, for a 223\u00d7223 texture map range from 0 to 222 and are typically represented in a fixed point format. Unnormalized texture coordinates associated with a surface are determined, using techniques known to those skilled in the art, based on normalized texture coordinates, such as s t, and r, corresponding to each pixel within the surface. The normalized texture coordinates are typically represented in a floating point format, where a value ranging from 0.0 to 1.0 covers each LOD of the texture map. Normalized texture coordinates may take on a value outside of the range (0.0 to 1.0), and the wrap mode determines how a value outside of the range will be changed to a value within the range. The unnormalized coordinates for an LOD of the texture map are computed using the normalized coordinates:\n\n*LOD width,\n\nwhere LOD width is the number of texels across a dimension, e.g., width, height, depth, or the like, of the LOD of the texture map. Likewise, v is computed using t and p is computed using r.\n","Texture indices computed based on the unnormalized texture coordinates are used to specify a particular texel and compute an address that is used to read the texel from memory. Texel indices are integers represented in index coordinate space, such as i, j, and k. For example, the texel indices for bilinearly filtered texels are computed using the unnormalized coordinates:\n\n=floor (0.5) and\n\n=floor (0.5)+1,\n\nwhere iand iare indices within one LOD of the texture map. Likewise, j indices are computed using v and k indices are computed using p. When the indices lie outside of the texture map, they are wrapped dependent on a wrap mode to lie inside the texture map, as described further herein.\n","When anisotropic filtering is used, the unnormalized texture coordinates are perturbed to generate perturbed texture coordinates for two or more texels within a footprint.  illustrates perturbed texture coordinates in accordance with one or more aspects of the present invention. A Position  is located along a Major Axis  at the unnormalized texture coordinates. A Position  corresponds to a first pair of perturbed texture coordinates and a Position  corresponds to a second pair of perturbed texture coordinates. An anisotropic perturbation may range in value from zero to half of a maximum anisotropic ratio (major axis\/minor axis) that is used. For example, when 16 to 1 is the maximum anisotropic ratio, the maximum anisotropic perturbation is 8.","A first anisotropic perturbation, \u0394u is subtracted from the u coordinate for Position  to generate the u coordinate for Position . Likewise, a second anisotropic perturbation, \u0394v is subtracted from the v coordinate for Position  to generate the v coordinate for Position . The first anisotropic perturbation, \u0394u is added to the u coordinate for Position  to generate the u coordinate for Position . Likewise, the second anisotropic perturbation, \u0394v is added to the v coordinate for Position  to generate the v coordinate for Position . Additional positions may be generated by adding the first and second anisotropic perturbations to Positions  and  or subtracting the first and second anisotropic perturbations from Positions  and . In some embodiments, a pair of perturbed texture coordinates, such as those corresponding to Position  or Position  may lie outside of the texture map. When perturbed texture coordinates are outside of the texture map, the perturbed texture coordinates must be wrapped to lie within the texture map. Likewise, texture indices produced using a perturbed coordinate may lie outside of the texture map and any index outside of the texture map must be wrapped to lie within the texture map. Rather than performing two wrapping operations, texture indices may be computed using the (unwrapped) perturbed texture coordinates and wrap operations may be performed on the texture indices to produce wrapped texture indices, as described further herein.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 3B","b":["305","305","0","223"]},"In step  an anisotropic perturbation is applied to the normalized texture coordinate to generate a perturbed texture coordinate. In one embodiment, the anisotropic perturbation is added to the unnormalized texture coordinate. For example, a perturbed texture coordinate, u\u2032, may be computed as:\n\n\n\nAlternatively, the anisotropic perturbation is subtracted from the unnormalized texture coordinate. For example, another perturbed texture coordinate, u\u2032, may be computed as:\n\n\n","In step  one or more texture indices are computed using each perturbed texture coordinate. For example, when point sampling, i.e., a single tap, is used to filter a texel, one index, i, may be computed as the integer portion of the perturbed texture coordinate: i=floor (u\u2032\u22120.5). Four indices (two indices for each dimension) may be computed for each perturbed texture coordinate when texels are bilinearly filtered, i.e., filtered using a four tap filter, as described further herein in conjunction with .","In step  the method determines if a texture index computed in step  lies outside of the texture map corresponding to the LOD, and, if not, the texture index is the wrapped texture index and the method proceeds to step . Otherwise, the method proceeds to step . When a repeat or \u201cclamp to edge\u201d wrap mode is used, the texture index lies outside of the texture map when the texture index is less than zero, greater than the LOD width, or equal to the LOD width. When a mirror wrap mode is used, the texture index lies outside of the texture map when the texture index is less than zero, greater than twice the LOD width, or equal to twice the LOD width. When a \u201cclamp to border\u201d wrap mode is used, the texture index lies outside of the texture map when the texture index is less than \u2212border size, greater than (border size+LOD width), or equal to (border size+LOD width).","In step  the texture index is wrapped, dependent on a wrap mode, to produce a wrapped texture index that lies within the texture map. The wrap mode may be selected by a user, specified for a particular texture map, or determined by an application program. A method for determining the wrapped texture index is described in conjunction with .","In step  the method determines if there is another texture index that lies outside of the texture map, and, if so, then the method returns to step . Otherwise, the method proceeds to step  and the wrapped texture coordinate is output.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 3C","FIG. 3B","FIG. 3F"],"b":["317","321","323","322","322","322","368"]},"In step  the method determines if the wrap mode is mirror, and, if not, the method proceeds to step . Otherwise the method proceeds to step . In step  the wrapped texture index is produced based on the mirror wrap mode, as described in conjunction with . After completing step , the method proceeds to step .","In step  the method determines if the wrap mode is \u201cclamp to border\u201d, and, if not, the method proceeds to step . Otherwise, in step , the wrapped texture index is produced based on the \u201cclamp to border\u201d wrap mode, as described in conjunction with . In step  the wrapped texture index is produced based on the \u201cclamp to edge\u201d wrap mode. After completing step  or step , the method proceeds to step . In an alternate embodiment, other wrap modes, such as mirror one, and the like, are used to produce the wrapped texture index.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 3D","FIG. 3C"],"b":["326","328","329","328","315","330","329","330","368"]},"In another embodiment a function may be used to compute the \u201cclamp to border\u201d wrapped texture index. The code shown in Table 1 represents such a function, where w is the LOD width, wm1 is (LOD width\u22121), and border_size_clamp is the border size. When use_border_color is asserted, a border color specified by the graphics application programming interface (API) is used instead of the texture data. By way of illustration, the code is defined using C. However, any other language may be used to define the function.",{"@attributes":{"id":"p-0047","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"if (is_border_textured)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"int i_clamped = MAX(\u2212border_size_clamp, MIN(w +"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"border_size_clamp \u2212 1, i) + border_size_clamp);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"i = i_clamped;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ the only place where i can exceed w"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["}",{}]},{"entry":["else","\/\/ there is no border texture"]},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"use_border_color = (i < 0) | (i > wm1);"]},{"entry":[{},"i = MAX(0, MIN(wm1, i));"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In another embodiment a function may be used to compute a \u201cmirror once clamp to border\u201d wrapped texture index or a \u201cmirror once clamp to edge\u201d wrapped texture index. The code shown in Table 2 represents such a function. By way of illustration, the code is defined using C. However, any other language may be used to define the function.",{"@attributes":{"id":"p-0049","num":"0048"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ if this is border textured, offset by the size of the border"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if (is_border_textured)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if (i < 0) i = ~i;"]},{"entry":[{},"\/\/ use the bitwise not of i if i is negative, e.g., \u22121 maps to 0"]},{"entry":[{},"\/\/ at this point i >= 0"]},{"entry":[{},"i = MIN (w + border_size_clamp \u2212 1, i) + border_size"]},{"entry":[{},"clamp;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}",{}]},{"entry":[{},"else","\/\/ there is no border texture"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if (i < 0) i = ~i;"]},{"entry":[{},"\/\/ at this point, i >= 0"]},{"entry":[{},"use_border_color = i > wm1;"]},{"entry":[{},"i = MIN(wm1, i);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 3E","FIG. 3C"],"b":["327","331","331","332","331","333","332","333","368"]},"In an alternative embodiment, step  of  is implemented by performing steps , , and  of , using a border size of 0. In another alternative embodiment, using a clamp Open GL\u2122 wrap mode, the wrapped texture index is set to the LOD width in step . In some embodiments a \u201cclamp mirror once\u201d option is supported when the clamp wrap modes (clamp to edge, clamp to border, and the like) are used and in step  the index is set to the absolute value of the texture index, i.e., any negative texture index is changed to a positive texture index. When the \u201cclamp mirror once\u201d option is steps  and  are not completed.","In another embodiment a function may be used to compute the \u201cclamp to edge\u201d wrapped texture index. The code shown in Table 3 represents such a function, where w is the LOD width and wm1 is (LOD width\u22121). By way of illustration, the code is defined using C. However, any other language may be used to define the function.",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"i = MAX(0, MIN(wm1, i));"]},{"entry":[{},"assert (0 <= i && i < w);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 3F","FIG. 3C"],"b":"325"},"In step , the method determines if the texture index is less than 0, and, if so, then the method proceeds to step . If, in step  the method determines that the texture index is not less than 0, then the method proceeds to step . In step  the method determines if the texture index is less than \u2212pattern width, where the pattern width is equal to the LOD width when repeat wrap mode is used. The pattern width is equal to twice the LOD width when a mirror wrap mode is used, as described in conjunction with . If, in step  the method determines that the texture index is less than \u2212pattern width, then in step  the wrapped texture index, e.g., i\u2032, is computed using the following equation:\n\nmod (pattern width),\n\nwhere i is the texture index computed in step  and mod is the modulus operator. Using the mod operator extracts only the remainder when i is divided by the pattern width.\n","When the pattern width is a power of two and i is represented as a binary number, the mod operation may be performed without a divide. However, when the pattern width is an arbitrary positive integer value, a divide is needed. Because the number of pattern width values that are less than the anisotropic perturbation is limited, the divide may be efficiently implemented using a table lookup. In one embodiment, the table stores the wrapped texture indices and is indexed using the pattern width and the texture index.","In one embodiment of a table used to compute the wrapped texture index when the repeat wrap mode is selected and the anisotropic perturbation is not greater than 9 is shown in Table 4. When the repeat mode is used, the pattern width is equal to the LOD width. Table 4 does not include entries for an LOD width of 1 because the only valid integer value for the wrapped texture index is 0. Table 4 does not include entries for LOD widths which are powers of two, such as 2, 4, and 8. Table 4 includes an entry for each LOD width that is less than the anisotropic perturbation. Table 4 also includes an entry for each texture index that is greater than the LOD width.",{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"center"}}],"thead":{"row":{"entry":[{},"TABLE 4"]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"texture","LOD width"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"42pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"index","3","5","6","7","9"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"6","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"42pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u22129","0","1","3","5","0"]},{"entry":[{},"\u22128","1","2","4","6","1"]},{"entry":[{},"\u22127","2","3","5","0","2"]},{"entry":[{},"\u22126","0","4","0","1","3"]},{"entry":[{},"\u22125","1","0","1","2","4"]},{"entry":[{},"\u22124","2","1","2","3","5"]},{"entry":[{},"\u22123","0","2","3","4","6"]},{"entry":[{},"\u22122","1","3","4","5","7"]},{"entry":[{},"\u22121","2","4","5","6","8"]},{"entry":[{},"0","0","0","0","0","0"]},{"entry":[{},"1","1","1","1","1","1"]},{"entry":[{},"2","2","2","2","2","2"]},{"entry":[{},"3","0","3","3","3","3"]},{"entry":[{},"4","1","4","4","4","4"]},{"entry":[{},"5","2","0","5","5","5"]},{"entry":[{},"6","0","1","0","6","6"]},{"entry":[{},"7","1","2","1","0","7"]},{"entry":[{},"8","2","3","2","1","8"]},{"entry":[{},"9","0","4","3","2","0"]},{"entry":[{},"10","1","0","4","3","1"]},{"entry":[{},"11","2","1","5","4","2"]},{"entry":[{},"12","0","2","0","5","3"]},{"entry":[{},"13",{},"3","1","6","4"]},{"entry":[{},"14",{},"4","2","0","5"]},{"entry":[{},"15",{},{},"3","1","6"]},{"entry":[{},"16",{},{},{},"2","7"]},{"entry":[{},"17",{},{},{},{},"8"]},{"entry":[{},"18",{},{},{},{},"0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"6","align":"center","rowsep":"1"}}]}]}}]}}},"In an alternate embodiment, multiple tables are used, each table corresponding to a particular LOD width and wrap mode (repeat or mirror). Each table is indexed using the texture index to read the wrapped texture indices for the particular LOD width.","In another embodiment a function may be used to compute the repeat wrapped texture index. Alternatively, the function may be used to generate wrapped texture indices stored in a repeat wrap lookup table. The code shown in Table 5 represents such a function, where w is the LOD width. ANISODEL is defined as 9 to compensate for any accumulated error that could cause the actual perturbation to be slightly larger than 8. By way of illustration, the code is defined using C. However, any other language may be used to define the function.",{"@attributes":{"id":"p-0061","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["#define ANISODEL","9"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ max aniso perturbation (8 would probably work)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["#define POSDEL","(ANISODEL+1)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ max expected positive delta (add the 1 for the +1 for tap)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["#define NEGDEL","(\u2212ANISODEL) \u2003\/\/ max expected negative delta"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ i coming in for wrap prior to aniso\/+1 delta was in range 0. . .w\u22121."},{"entry":"\/\/ the new range is [0,w\u22121]+[NEGDEL,POSDEL] = \u22129 . . . w+9"},{"entry":"\/\/ therefore, for wrap, we need to use the table only if the new u' value"},{"entry":"\/\/ cannot be brought into proper range by adding or subtracting w once."},{"entry":"\/\/ this means that either i' >= 2w or i' < \u2212w"},{"entry":"\/\/ thus either w+9>=2w or \u22129 < \u2212w -- the first implies w <= 9 and the"},{"entry":"second"},{"entry":"\/\/ implies w < 9 therefore we need to use the table only for w <= 9"},{"entry":"static"},{"entry":"int wrap_table (int i, int w)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"assert (i >= NEGDEL && i <= w\u22121 + POSDEL);"]},{"entry":[{},"i = i % w;"]},{"entry":[{},"if (i < 0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"i += w;","\/\/ work around C language misfeature"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return i;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"After producing the wrapped texture index in step , the method proceeds to step  in . If, in step  the method determines that the texture index is not less than \u2212pattern width, then in step  the wrapped texture index, e.g., i\u2032, is computed by adding the pattern width to the texture index:\n\n+pattern width,\n\nwhere i is the texture index computed in step .\n","If, in step , the method determines that the texture index is greater than or equal to zero then the texture index must be greater than or equal to the LOD width, because, in step  the method determined that the texture index lies outside of the texture map. In step  the method determines if the texture index is greater than or equal to twice the pattern width, and, if so, proceeds to complete previously described step . Otherwise, In step  the wrapped texture index, e.g., i\u2032, is computed by subtracting the pattern width (LOD width for the repeat wrap mode) from the texture index:\n\n\u2212pattern width,\n\nwhere i is the texture index computed in step . Following step , step , or step , the method proceeds to step  of .\n","In another embodiment a function may be used to compute the wrapped texture index when the repeat wrap mode is used. The code shown in Table 4 represents such a function, where w is LOD width, wm1 is (LOD width\u22121), WRAP_TABLE_LIMIT is the maximum anisotropic perturbation, and the wrap_table function is used to access Table 4, the repeat wrap lookup table, or the like. By way of illustration, the code is defined using C. However, any other language may be used to define the function.",{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#define POW2(x) (((x)&((x)\u22121))==0)"},{"entry":"if (POW2(w))"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"i &= wm1;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else if (w <= WRAP_TABLE_LIMIT)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"i = wrap_table(i, w);","\/\/ compute i mod w; output is 0. . .w\u22121"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else if (i < 0)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"i += w;","\/\/ should only have to do once"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else if (i >= w)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"i \u2212= w;","\/\/ should only have to do once"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 3G","FIG. 3C","FIG. 3F","FIG. 3F","FIG. 3F"],"b":["324","334","335","337","340","336","342","339","341","313"],"br":[{},{}],"in-line-formulae":[{},{}]},"In one embodiment of a table used to compute the wrapped texture index when the mirror wrap mode is selected and the anisotropic perturbation is not greater than 9 is shown in Table 7. Table 7 does not include entries for an LOD width of  because the only valid integer value for the wrapped texture index is 0. Table 7 does not include entries for LOD widths which are powers of two, such as 2, 4, and 8. Table 7 includes an entry for each pattern width (2*LOD width for the mirror wrap mode) that is less than the anisotropic perturbation. Table 7 also includes an entry for each texture index that is greater than the pattern width.",{"@attributes":{"id":"p-0068","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"center"}}],"thead":{"row":{"entry":[{},"TABLE 7"]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"texture","LOD width"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"42pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"index","3","5","6","7","9"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"6","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"42pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u22129","2","1","3","5","8"]},{"entry":[{},"\u22128","1","2","4","6","7"]},{"entry":[{},"\u22127","0","3","5","6","6"]},{"entry":[{},"\u22126","0","4","5","5","5"]},{"entry":[{},"\u22125","1","4","4","4","4"]},{"entry":[{},"\u22124","2","3","3","3","3"]},{"entry":[{},"\u22123","2","2","2","2","2"]},{"entry":[{},"\u22122","1","1","1","1","1"]},{"entry":[{},"\u22121","0","0","0","0","0"]},{"entry":[{},"0","0","0","0","0","0"]},{"entry":[{},"1","1","1","1","1","1"]},{"entry":[{},"2","2","2","2","2","2"]},{"entry":[{},"3","2","3","3","3","3"]},{"entry":[{},"4","1","4","4","4","4"]},{"entry":[{},"5","0","4","5","5","5"]},{"entry":[{},"6","0","3","5","6","6"]},{"entry":[{},"7","1","2","4","6","7"]},{"entry":[{},"8","2","1","3","5","8"]},{"entry":[{},"9","2","0","2","4","8"]},{"entry":[{},"10","1","0","1","3","7"]},{"entry":[{},"11","0","1","0","2","6"]},{"entry":[{},"12","0","2","0","1","5"]},{"entry":[{},"13",{},"3","1","0","4"]},{"entry":[{},"14",{},"4","2","0","3"]},{"entry":[{},"15",{},{},"3","1","2"]},{"entry":[{},"16",{},{},{},"2","1"]},{"entry":[{},"17",{},{},{},{},"0"]},{"entry":[{},"18",{},{},{},{},"0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"6","align":"center","rowsep":"1"}}]}]}}]}}},"In another embodiment a function may be used to compute the wrapped texture index. Alternatively, the function may be used to generate wrapped texture indices stored in a lookup table. The code in Table 8 represents such a function, where w is the LOD width. By way of illustration, the code is defined using C. However, any other language may be used to define the function.",{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["#define ANISODEL","9"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ max aniso perturbation (8 would probably work)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["#define POSDEL","(ANISODEL + 1)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ max expected positive delta (add the 1 for the +1 for tap)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["#define NEGDEL","(\u2212ANISODEL) \u2003\/\/ max expected negative delta"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ i coming in for mirror prior was in range 0. . .2w\u22121"},{"entry":"\/\/ the new range is [0, 2w\u22121]+[NEGDEL,POSDEL] = \u22129 . . . 2w+9"},{"entry":"\/\/ however, since the function we are implementing is"},{"entry":"\/\/ if (i < 0) u = \u2212i\u22121; i %= 2 * w; if (i >= w) i = 2w \u2212 1 \u2212 i"},{"entry":"\/\/ thus after the first if, i' is [0, MAX(9, 2w+9)]"},{"entry":"\/\/ we have a problem only if i' cannot be brought into range by subtracting"},{"entry":"\/\/ 2w once this occurs only if i' >= 4w. thus, we have"},{"entry":"\/\/ MAX(9, 2w+9) >= 4w. Solving for w gives w <= 9\/2 or w <= 4."},{"entry":"\/\/"},{"entry":"\/\/ we can reduce the number of concatenated operations for mirror though"},{"entry":"\/\/ if we restrict the maximum range of i' to be such that"},{"entry":"\/\/ i'\u22122w <= w\u22121 -- that is, once you subtract 2w you are done."},{"entry":"\/\/ so we have MAX(9, 2w+9) >= 3w"},{"entry":"#define MIRROR_TABLE_LIMIT MAX(\u2212NEGDEL\/3, (POSDEL\u22121))"},{"entry":"static"},{"entry":"int mirror_table(int i, int w)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"assert (i >= NEGDEL && i <= 2*w\u22121 + POSDEL);"]},{"entry":[{},"if (i < 0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"i = ~i;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"i = i % (2 * w);",{}]},{"entry":[{},"assert (i >= 0);","\/\/ no C language misfeature"]},{"entry":[{},"if (i >= w)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"i = 2 * w \u2212 1 \u2212 i;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return i;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Following step , step , or step , the method proceeds to step . In step , the method determines if the wrapped texture index is greater than or equal to the LOD width, and, if so, then the method proceeds to step . In step  the wrapped texture index is computed as the difference between the pattern width\u22121 and the wrapped texture index. Otherwise, in step  the wrapped texture index is not modified. After producing the wrapped texture index in step  or step , the method proceeds to step  in .","In another embodiment a function may be used to compute the wrapped texture index when the mirror wrap mode is used. The code shown in Table 9 represents such a function, where w is LOD width, wm1 is (LOD width\u22121), MIRROR_TABLE_LIMIT is the maximum anisotropic perturbation, twow is 2*LOD width, and the mirror_table function is used to access Table 7, the mirror wrap lookup table, or the like. By way of illustration, the code is defined using C. However, any other language may be used to define the function.",{"@attributes":{"id":"p-0073","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"if (POW2(w))"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"i = ((i & w) ? ~i : i) & wm1;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else if (w <= MIRROR_TABLE_LIMIT)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"i = mirror_table(i, w); \/\/ compute mirror(i, width); output is"]},{"entry":[{},"0. . .w\u22121"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"else"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (i < 0)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"i = ~i;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if (i >= twow)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"i \u2212= twow;",{}]},{"entry":[{},"assert (i <= w\u22121);","\/\/ having done this we know that i <="]},{"entry":[{},{},"w\u22121"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"else if (i >= w)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"i = twow \u2212 1 \u2212 i;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Persons skilled in the art will appreciate that any system configured to perform the method steps of , C, D, E, F, and G, or their equivalents, is within the scope of the present invention. Furthermore, persons skilled in the art will appreciate that the method steps of , C, D, E, F, and G may be extended to support non-square texture maps. For example, LOD width may be replaced with an LOD height, or in the case of three-dimensional textures an LOD depth may also be used. Additionally, each dimension may have a separate wrap mode specified for it.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 4","sub":["0","1","0","1","0","1","0","0 ","1"],"br":[{},{},{},{},{},{}],"in-line-formulae":[{},{},{},{},{},{},{},{}],"i":["u","=u\u2032\u2212","u","=u+","u","=u\u2032\u2212","u","=u"]},"The tap computation may be combined with the anisotropic perturbation, such that each texture coordinate is perturbed to produce two perturbed texture coordinates. Specifically, the sum of a tap perturbation, \u0394uis summed with the anisotropic perturbation, \u0394u, and subtracted from the u texture coordinate corresponding to Position  to produce the perturbed u texture coordinate corresponding to Position . Likewise, the sum of a tap perturbation, \u0394uis summed with the anisotropic perturbation, \u0394u, and summed with the u texture coordinate corresponding to Position  to produce the perturbed u texture coordinate corresponding to Position . Similarly, the perturbed v texture coordinates corresponding to Positions  and  may be computed based on the v texture coordinate corresponding to Position .",{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 4B","b":["405","410"],"sub":["0 ","1"]},"In step  a texture index is produced for each perturbed texture coordinate, e.g., i=floor (\u22120.5) and i=i+1. In step  the method determines if a texture index produced in step  lies outside of the texture map corresponding to the LOD, and, if not, the texture index is the wrapped texture index and the method proceeds to step . Otherwise, the method proceeds to step .","Step  is completed as previously described in conjunction with step  of . Persons skilled in the art will appreciate that any system configured to perform the method steps of  their equivalents, may be configured to use a perturbed texture coordinate that includes a tap perturbation, such as u\u2032 or u\u2032 to compute a wrapped texture index. In step  the wrapped texture indices are output.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIG. 5A","FIG. 6"],"b":["500","500"]},"Texture Unit  includes an LOD Unit  which receives texture parameters and determines LOD values using a technique known to those skilled in the art. In some embodiments LOD Unit  outputs a LOD width and a LOD height corresponding to each LOD value that is output. Texture Unit  includes a Texture Coordinate Computation Unit . A Control Unit  within Texture Coordinate Computation Unit  processes the program instructions, such as instructions to set the wrap mode.","Parameters produced by the rasterizer are output by LOD Unit  and received by a Parameter Conversion Unit  within Texture Coordinate Computation Unit . Parameter Conversion Unit  computes unnormalized texture coordinates, e.g., u and v, and the like, using techniques known to those skilled in the art. In some embodiments Parameter Conversion Unit  computes a LOD width and a LOD height corresponding to each LOD value. The unnormalized texture coordinates are output by Parameter Conversion Unit  to an Anisotropic Unit .","Anisotropic Unit  may include storage elements, e.g., registers, to store one or more tables used to compute wrapped texture indices. Anisotropic Unit  may also store LOD width and LOD heights for texture maps. In an alternate embodiment, Anisotropic Unit  receives LOD width and LOD height values from Control Unit . Anisotropic Unit  receives unnormalized texture coordinates and produces wrapped texture indices based on the wrap mode, as described in conjunction with .","Anisotropic Unit  outputs wrapped texture indices and anisotropic weights to an Address Computation Unit . Address Computation Unit  uses wrapped texture indices such as, i\u2032 and j\u2032 and other texture information, such as a texture ID received by Texture Unit , to determine addresses for reading texels from memory. In some embodiments Texture Coordinate Computation Unit  determines and outputs tap weights for use in filtering the texels read from memory. In other embodiments, another unit (not shown) in Texture Unit  determines the tap weights, using techniques known to those skilled in the art.","Address Computation Unit  outputs the addresses to a Read Interface . Read Interface  outputs the addresses and a read request to a memory, e.g., cache, RAM, ROM, or the like. Texels read from memory are received from the memory by a Texture Filter Unit . Texture Filter Unit  receives the tap weights and the anisotropic weights from Address Computation Unit  and filters the texels read from memory using bilinear interpolation, trilinear interpolation, anisotropic filtering, or the like, to produce filtered texels. The filtered texels are output to a shader unit, described further herein, to compute a color for each fragment.",{"@attributes":{"id":"p-0086","num":"0085"},"figref":["FIG. 5B","FIG. 5A"],"b":["505","530","525","510","532","520","520"]},"The perturbed texture coordinate is output to an Index Computation Unit  which computes one or more texture indices for each perturbed texture coordinate. Index Computation Unit  outputs the texture indices to an Add\/Subtract Unit  and a Wrap Lookup Table  within Anisotropic Wrap Unit . Add\/Subtract Unit  and Wrap Lookup Table  receive the LOD width (or pattern width) and wrap mode from Index Computation Unit  or Control Unit . Add\/Subtract Unit  subtracts a pattern width from a texture index when the texture index is a positive value to produce an adjusted texture index. Add\/Subtract Unit  adds a pattern width to the texture index when the texture index is a negative value to produce the adjusted texture index. Wrap Lookup Table  is indexed using the wrap mode, the texture index, and the pattern width. Wrap Lookup Table  outputs a remainder texture index. Wrap Lookup Table  includes storage elements that are written by Control Unit . In an alternate embodiment, Wrap Lookup Table  is a ROM.","A Select Unit  receives the texture index, wrap mode, adjusted texture index, and remainder texture index, and produces the wrapped texture index. Select Unit  computes the wrapped texture index when the wrap mode is \u201cclamp to edge\u201d or \u201cclamp to border.\u201d When mirror or repeat wrap mode is selected, Select Unit  determines if the adjusted texture index is negative, equal to the pattern width, or greater than the pattern width, and if so, the remainder texture index is output as the wrapped texture coordinate. Otherwise, when mirror or repeat wrap modes are selected, Select Unit  outputs the adjusted texture index as the wrapped texture index. Persons skilled in the art will appreciate that any system configured to perform the functions of , or its equivalent, is within the scope of the present invention.",{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 6","b":["600","610","607","500","600","610","614","612","612","615","615","612","615","615","612","640","607"]},"Host computer  communicates with Graphics Subsystem  via System Interface  and an Interface . Graphics Subsystem  includes Local Memory  and a Programmable Graphics Processor . Programmable Graphics Processor  uses memory to store graphics data, including texture maps, and program instructions, where graphics data is any data that is input to or output from computation units within Programmable Graphics Processor . Texture maps stored in graphics memory may include non-power of two texture maps. Graphics memory is any memory used to store graphics data or program instructions to be executed by Programmable Graphics Processor . Graphics memory can include portions of Host Memory , Local Memory  directly coupled to Programmable Graphics Processor , storage resources coupled to the computation units within Programmable Graphics Processor , and the like. Storage resources can include register files, caches, FIFOs (first in first out memories), and the like.","In addition to Interface , Programmable Graphics Processor  includes a Graphics Processing Pipeline , a Memory Controller  and an Output Controller . Data and program instructions received at Interface  can be passed to a Geometry Processor  within Graphics Processing Pipeline  or written to Local Memory  through Memory Controller . In addition to communicating with Local Memory , and Interface , Memory Controller  also communicates with Graphics Processing Pipeline  and Output Controller  through read and write interfaces in Graphics Processing Pipeline  and a read interface in Output Controller .","Within Graphics Processing Pipeline , Geometry Processor  and a programmable graphics fragment processing pipeline, Fragment Processing Pipeline , perform a variety of computational functions. Some of these functions are table lookup, scalar and vector addition, multiplication, division, coordinate-system mapping, calculation of vector normals, tessellation, calculation of derivatives, interpolation, and the like. Geometry Processor  and Fragment Processing Pipeline  are optionally configured such that data processing operations are performed in multiple passes through Graphics Processing Pipeline  or in multiple passes through Fragment Processing Pipeline . Each pass through Programmable Graphics Processor , Graphics Processing Pipeline  or Fragment Processing Pipeline  concludes with optional processing by a Raster Operations Unit .","Vertex programs are sequences of vertex program instructions compiled by Host Processor  for execution within Geometry Processor  and Rasterizer . Shader programs are sequences of shader program instructions compiled by Host Processor  for execution within Fragment Processing Pipeline . Geometry Processor  receives a stream of program instructions (vertex program instructions and shader program instructions) and data from Interface  or Memory Controller , and performs vector floating-point operations or other processing operations using the data. The program instructions configure subunits within Geometry Processor , Rasterizer  and Fragment Processing Pipeline . The program instructions and data are stored in graphics memory, e.g., portions of Host Memory , Local Memory , or storage resources within Programmable Graphics Processor . When a portion of Host Memory  is used to store program instructions and data the portion of Host Memory  can be uncached so as to increase performance of access by Programmable Graphics Processor . Alternatively, configuration information, including wrap mode information, is written to registers within Geometry Processor , Rasterizer  and Fragment Processing Pipeline  using program instructions, encoded with the data, or the like.","Data processed by Geometry Processor  and program instructions are passed from Geometry Processor  to a Rasterizer . Rasterizer  is a sampling unit that processes primitives and generates sub-primitive data, such as fragment data, including parameters associated with fragments (texture IDs, texture parameters, and the like). Rasterizer  converts the primitives into sub-primitive data by performing scan conversion on the data processed by Geometry Processor . Rasterizer  outputs fragment data and shader program instructions to Fragment Processing Pipeline .","The shader programs configure the Fragment Processing Pipeline  to process fragment data by specifying computations and computation precision. Fragment Shader  is optionally configured by shader program instructions such that fragment data processing operations are performed in multiple passes within Fragment Shader . Fragment Shader  includes an embodiment of previously described Texture Unit . In one embodiment Texture Unit  is configured to read shader program instructions stored in Local Memory  or Host Memory  via Memory Controller .","Fragment Shader  outputs processed fragment data, e.g., color and depth, and codewords generated from shader program instructions to Raster Operations Unit . Raster Operations Unit  includes a read interface and a write interface to Memory Controller  through which Raster Operations Unit  accesses data stored in Local Memory  or Host Memory . Raster Operations Unit  optionally performs near and far plane clipping and raster operations, such as stencil, z test, blending, and the like, using the fragment data and pixel data stored in Local Memory  or Host Memory  at a pixel position (image location specified by x,y coordinates) associated with the processed fragment data. The output data from Raster Operations Unit  is written back to Local Memory  or Host Memory  at the pixel position associated with the output data and the results, e.g., image data are saved in graphics memory.","When processing is completed, an Output  of Graphics Subsystem  is provided using Output Controller . Alternatively, Host Processor  reads the image stored in Local Memory  through Memory Controller , Interface  and System Interface . Output Controller  is optionally configured by opcodes to deliver data to a display device, network, electronic control system, another computing system, such as Computing System , another graphics subsystem, such as Graphics Subsystem , or the like.","The invention has been described above with reference to specific embodiments. Persons skilled in the art will recognize, however, that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. For example, in alternative embodiments, the method set forth herein may be implemented either partially or entirely in a software program or a fragment program executed by Fragment Shader . The foregoing description and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense. The listing of steps in method claims do not imply performing the steps in any particular order, unless explicitly stated in the claim."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE VARIOUS VIEWS OF THE DRAWINGS","p":["Accompanying drawing(s) show exemplary embodiment(s) in accordance with one or more aspects of the present invention; however, the accompanying drawing(s) should not be taken to limit the present invention to the embodiment(s) shown, but are for explanation and understanding only.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIGS. 1B","b":["1","1"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3C"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3D"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3E"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3F"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3G"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 5B","FIG. 5A"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
