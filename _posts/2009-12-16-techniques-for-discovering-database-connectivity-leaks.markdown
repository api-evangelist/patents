---
title: Techniques for discovering database connectivity leaks
abstract: Techniques for discovering database connectivity leaks are presented. Each connection made by an application to a database is monitored. When the application is shut down, if information regarding a particular connection remains in memory, then that connection is reported as a potential database connectivity leak.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08949421&OS=08949421&RS=08949421
owner: Teradata US, Inc.
number: 08949421
owner_city: Dayton
owner_country: US
publication_date: 20091216
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application is with and includes the same inventor as Provisional Application No. 61\/229,393 filed on Jul. 29, 2009 and entitled: \u201cTechniques for Discovering Database Connectivity Leaks;\u201d and the present application is a non-provisional of that Provisional Application and claims priority thereto and incorporates by reference the entirety of that Provisional Application herein.","One of the most common and most serious problems in software application development is a failure to properly close connections to an underlying relational database. This is most commonly called \u2018leaking connections\u2019 or a \u2018connection leak\u2019. This problem is serious, and can degrade or even render unusable an application over time. Detecting the specific piece of application code that failed to close a connection is often extremely difficult, especially in high volume multi-threaded applications. The usual approach is a laborious manual inspection of suspect code or, if the problem can be recreated, debugging through the application source until the problem cause is determined.","Thus, improved mechanisms for discovering database connectivity leaks are needed.","In various embodiments, techniques for discovering database connectivity leaks are provided. Specifically, a method to discover database connectivity leaks is presented. Connections made to a database from an application are detected. A unique connection record is maintained for each separate connection when that connection is established to the database. Any remaining connection records that remain when the application is shut down are reported as potential database connectivity leaks.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1","b":["100","100"]},"At , the leak discovery service detects connections made to a database from an application. For instance, consider a web server that processes Internet requests to a backend enterprise database. In this example, the web server is the application making connections to the database; the leak discovery service detects these connections. This can be done in a variety of manners and without modifying the underlying code or processing associated with the application.","For example, at , the leak discovery service identifies connections that are being made from within a database interface. This can be a standard database interface routine, such as JAVA\u00ae's DataSource or it can be any other database interface that the application utilizes to make connections to the database.","Continuing with the embodiment of  and at , the leak discovery service configures the application to execute a modified database interface in place of the existing database interface. The modified interface communicates with the leak discovery service to identify the connections and to gather additional connection information, as discussed in greater detail below.","At , the leak discovery service maintains a unique connection record for each separate connection when that connection is established to the database. So, a record of metadata information is maintained for each connection thread established by the application to the database. A variety of information can be retained in each record.","For example, at , the leak discovery service acquires for each connection and its corresponding connection record: a thread identifier for a particular connection thread to the database, an application identifier to unique identify the application, a routine identifier to unique identify a routine within the application that makes a request for a particular connection, and\/or a source code location identifier (such as a line number) to identify a particular source code statement within the routine where the particular connection was initially requested.","According to an embodiment, at , the leak discovery service maps each connection record to a call stack for a particular thread of the application associated with the connection. So, each record maps to a connection thread to the database.","In another case, at , the leak discovery service indexes a record key for each connection record with a connection identifier for the particular connection of that connection record. The record key and the connection identifier include the connection record and a link to an in-memory call stack associated with the particular connection. So, the reserved memory for a particular connection is indexed with the record so that it can be located when the application is closed.","At , the leak discovery service reports any remaining connection records that remain when the application is shut down. So, the application can be normally terminated or abnormally terminated and when an event is detected by the leak discovery service indicating that the application is shut down and inspection is made to see if any remaining connection records exist. That is, the leak discovery service removes connections records when connections are closed properly by the application (by detecting close connection calls). So, remaining connection records indicate that there are database connectivity leaks in the application if the records still exist when the application is terminated. These remaining records are reported out, such as to an administrator or to a log file when the application is terminated. This permits a subsequent analysis to be done and the source code of the application revised to correct lingering connection issues in the application source code.","In an embodiment, at , the leak discovery service frees in-memory storage reserved for those connections that were associated with the remaining connection records and the leak discovery service also removes the remaining connection records. Here, the leak discovery service cleans up the lingering in memory call stacks for database connectivity leaks by freeing the reserved memory when it is detected that the application has terminated and these call stacks remain.","An example illustration and further discussion is now presented for purposes of comprehension. It is noted that these language specific examples are just illustrations and are not to limit the techniques presented herein to any specific implementation, as others are permissible without departing from the teachings presented herein.","For applications written in the Java programming language, there is a fairly straightforward and efficient means of identifying the exact source of connection leaks during the runtime of an application. Every connection leak is detected and its cause identified and the results provided in a summary log. The approach is documented in the following steps:","(1) Create a Software Wrapper that Implements the Java DataSource Interface.",{"@attributes":{"id":"p-0021","num":"0020"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"DataSource : See http:\/\/java.sun.com\/javase\/6\/docs\/api\/javax\/sql\/DataSource.html"},{"entry":"Driver : see http:\/\/java.sun.com\/javase\/6\/docs\/api\/java\/sql\/Driver.html"},{"entry":"Connection : see http:\/\/java.sun.com\/javase\/6\/docs\/api\/java\/sql\/Connection.html"},{"entry":"JDBC : see http:\/\/java.sun.com\/javase\/6\/docs\/technotes\/guides\/jdbc\/"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The most common strategy for connection management in Java containers (Enterprise JavaBeans (EJB), Spring, etc.) is the deployment of a Data Source, which is responsible for acquiring and handing out connections. The approach used herein is to detect connection leaks by creating, in one example embodiment, a Java class that implements the Data Source interface so as to deploy it in the application to be tested. So, the first order of business is to create a \u201cDataSource\u201d class that serves as a software wrapper around the existing DataSource used by the test applications. The software wrapper may contain a reference to an existing JDBC DataSource implementation or the wrapper may contain plumbing to acquire Connections through the JDBC Driver. (These JDBC objects are the standard relational database access methods for Java applications.) The software wrapper also adds instrumentation to the methods of the DataSource interface that return Connection objects. Depending on the deployment environment, it may be necessary to modify container (EJB, Spring, etc.) configuration to point to the DataSource wrapper rather than the DataSource reference it contains.","(2) Add Instrumentation to the DataSource Software Wrapper.","The software wrapper created in Step  is modified to keep a (temporary) record of each call stack that acquires a Connection from the DataSource. When the Connection is closed, the temporary record is cleared. Any record that remains when application is shut down indicates a call to the DataSource that opened a connection but did not close it. This is a connection leak. The call stack identifies the caller (client code) that leaked the connection.","It is noted that the DataSource wrapper hands back a connection to a caller, it gets the current call stack. A call stack is a sequential list of class method calls on the current thread of execution. A call stack is saved when the connection is acquired by creating a new Throwable( ) instance, calling its filllnStackTrace( ) and then its getStackTrace( ) method. The results of the getStackTrace( ) can be formatted and stored as a String for later reporting. Formatting is generally a good idea, as the call stacks can take up a lot of space and the calling code that we are interested in is usually the code unique to the application under test. In some cases, the techniques presented are used to filter the call stacks to refer to just the packages in a deployed version of the application.","So, now there is a DataSource wrapper and a handle on the call stacks. These are leveraged as follows. There are a couple of ways to do implementations. One approach would be to have the DataSource wrapper keep an internal Map (http:\/\/java.sun.com\/javase\/6\/docs\/api\/java\/util\/Map.html) that maintains the stack traces, by Connection, of each requested connection. Whenever a connection is handed out to a piece of client code from the wrapper, a new entry is stored in the map. The entry is created using the returned Connection object as a key, and the value stored under the key is a string representation of the Java stack trace taken at the time of the call to get the connection. Whenever the Connection is closed, its record is removed from the map. This provides a constantly updated snapshot of all the Connections currently in use by the client code. When the application shuts down, look in the map for any entries that were not removed (they were leaked because close was never called) and use the stack trace information in the map to create a formatted report to a trace log or the system console identifying the call stacks of the client code that leaked a connection.","An alternative implementation for keeping track of the leaking clients is done without using a map in the DataSource wrapper. Instead, each Connection (which is really a wrapper\u2014see discussion in step  example above) contains a member string representing the call stack of the client code that acquired the Connection from the DataSource wrapper. It is the responsibility of the DataSource wrapper to set the value of the stack information each time it is handed out the Connection to a caller. This implementation is a little different: it establishes a direct link between an active Connection and the call stack of the client that acquired (opened) it. This is the key point. As long as one has this information at application shutdown, one can provide a complete list of all client calls that ended up leaking a connection.","(3) Implement a Connection Wrapper and Override the Close Method.","The DataSource wrapper that was created in step 1 has to wrap the Connections that it hands out to the clients. Java provides some infrastructure Application Programming Interfaces) (APIs to assist with this. See for example:",{"@attributes":{"id":"p-0028","num":"0027"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"http:\/\/java.sun.com\/javase\/6\/docs\/api\/javax\/sql\/ConnectionPoolDataSource."]},{"entry":[{},"html and"]},{"entry":[{},"http:\/\/java.sun.com\/javase\/6\/docs\/api\/javax\/sql\/PooledConnection.html)."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{}]},"At this point, a Connection has been opened but is has not yet been closed. But one needs to be able to write the information in a useful way so that the developers can fix the leaking code by adding a close to the Connection. What one needs to do is to tell the Java Virtual Machine (JVM) that one wants to be notified on shutdown so one can look at leaked connections and do some reporting. To get called at VM shutdown, a report class is provided that implements the Java runable interface (http:\/\/java.sun.com\/javase\/6\/docs\/api\/java\/lang\/Runnable.html). For the purposes of our explanation here, let's assume one calls a class LeakReporter. All that is really required in this class is that in its run( ) method, it implements code that iterates over the current entries in the DataSource wrapper map of open connections (or alternatively, over the set of open connections in the pool) and gets the saved stack traces. Each stack trace is written to a log file, or routed to the system console. In any case, once your reporter is provided, one needs to register it when the application starts up. An example line of code for achieving this is as follows:",{"@attributes":{"id":"p-0030","num":"0029"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Runtime.getRuntime( ).addShutdownHook(new Thread(new"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LeakReport( )));"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Now when the Virtual Machine (VM) shuts down, each piece of code that opened a connection but failed to close it, is obvious in the reported stack traces.","The one of many advantages of this solution is that it provides a means to easily find a common and usually difficult to diagnose software problem. Prior to this solution, the typical approach to this problem was to manually pore over hundreds or thousands of lines of source code looking for unpaired open\/close on Connections. This manual process was very time consuming, and not very effective at all in high concurrency environments. The approach outlined in this new solution negates the need for developers to debug connection leaks manually, and instead keeps them advised on each new application run whether or not the current application code has introduced a connection leak.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2","b":["200","200"]},"The leak monitoring service provides another and in some cases enhanced perspective of the leak discovery service represented by the method  of the .","At , the leak monitoring service gathers a set of connection information for each connection made to a database by an application. Again, the application is a front-end application to the database that is capable of handling requests from a plurality of clients that access the database over a network, such as the Internet.","In an embodiment, at , the leak monitoring service maintains each set of connection information as an in-memory connection record that is unique to the connection that the record is associated with. So, each unique connection to the database includes its own maintained set of connection information. This information can include a variety of details, such as but not limited to: an application identifier, a routine identifier (for a routine that requested the connection within the source code of the application), a source code statement identifier for the source statement where the connection request was made inside the source code of the application, data and time connection was established, user that established the application, and the like.","Continuing with the embodiment of  and at , the leak monitoring service maps each in-memory connection record to a particular in-memory call stack assigned to the unique connection that is associated with that record. The call stack for each connection is mapped and linked to the connection record being maintained by the leak monitoring service.","In a particular situation, at , the leak monitoring service acquires each set of connection information when the application makes a particular connection request via a database interface to connect to the database. Again, the processing of the leak monitoring service is interjected into the database interface that establishes connections to the database as described above with reference to the method  of the .","In yet another case, at , the leak monitoring service records within each set of connection information a source code location within the application where a particular connection request to make a particular connection was made. This can provide invaluable information to a developer or analyst by pinpointing where in the source code of the application a connection request was made that was never properly closed when the application terminated.","At , the leak monitoring service removes each set of connection information for each connection that is properly closed. In other words, when a connection is closed an event is detected and the set of connection information associated with the closed connection is removed and no longer tracked by the leak monitoring service.","At , the leak monitoring service reports each remaining set of connection information for each connection that remains open when the application terminates. So, any set of connection information that remains when the application is detected as having terminated, the leak monitoring service knows this is a database connectivity leakage situation. This set of connection information is then reported. The report can be made electronically and automatically to an administrator or logged to a file or database location for subsequent analysis.","According to an embodiment, at , the leak monitoring service removes reach remaining set of connection information and removes reserved in-memory storage to close out each connection that remained opened when the application terminated. So, not only does the leak monitoring service report database connectivity leakages but the leak monitoring service can correct and clean such leakages.","Continuing with the embodiment of  and of , and at , the leak monitoring service provides each source code location along with a particular connection identifier in a report that is then electronically sent to an administrator for subsequent analysis. So, the administrator can modify the source code of the application by inspecting the report in the proper location to resolve the database connectivity issues going forward with the application.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 3","b":["300","300"]},"In an embodiment, the database connectivity leak discovery system  implements, inter alia, the methods  and  of the , respectively.","The database connectivity leak discovery system  includes a database  and a database interface . Each of these and their interactions with one another will now be discussed in turn.","The database  is implemented in a computer-readable storage medium and executes on one or more processors of a network. Example aspects of the database  related to connectivity were discussed above with reference to the methods  and  of the , respectively.","The database interface  is implemented in a computer-readable storage medium and executes on the one or more processors of the network. Processing features associated with the database interface  were discussed in detail above with reference to the methods  and  of the , respectively.","The database interface  is configured to maintain a unique connection record for each connection made by an application to the database . The database interface  is also configured to remove each particular connection record when a particular connection is closed properly from within the application. The database interface  further configured to report each remaining record when a remaining connection remains open when the application shuts down.","According to an embodiment, the database interface  is configured as a wrapper that acts as a preprocessor and post processor to an existing database interface used by the application to access the database . In other words, input to the existing database interface and output from the existing database interface passes through the database interface  that is configured as a wrapper around the existing database interface.","In another situation, the database interface  is configured to be processed by the application in place of an existing database interface for the application. This is done by altering a configuration file associated with the application to point to the database interface  and not the application's existing database interface.","Also, the database interface  is configured to remove an in-memory call stack reserved for the remaining connection when the application is shut down.","Still further, the database interface  is configured to identify a specific source code line number for specific source statement within a source code version of the application. The specific source code statement corresponding to a particular application call used to establish the remaining connection that was not closed when the application shut down.","In yet another case, the database interface  is configured to generate a report that is: logged to a particular network location, emailed to a particular pre-defined recipient, texted to the recipient, and\/or instant messaged to the recipient.","The above description is illustrative, and not restrictive. Many other embodiments will be apparent to those of skill in the art upon reviewing the above description. The scope of embodiments should therefore be determined with reference to the appended claims, along with the full scope of equivalents to which such claims are entitled."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
