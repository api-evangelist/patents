---
title: Layering concept for a repository of a user interface framework for web applications
abstract: Various embodiments of systems and methods for a layering concept for a repository of a user interface framework for Web applications are described herein. The content of a repository provided by different parties (e.g., vendor, partner, customer, user, etc.) is separated. The separation is achieved by assigning solutions to the parties that store content in the repository. Simplified access to the repository is achieved by layering the solutions in a stack and implementing a layer strategy for the layers and their order of access.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08694544&OS=08694544&RS=08694544
owner: SAP AG
number: 08694544
owner_city: Walldorf
owner_country: DE
publication_date: 20101227
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The field generally relates to the software arts, and more specifically, to methods and systems for a layering concept for a repository of a user interface framework for Web applications.","In the world of computing, Web applications such as Rich Internet Applications (RIAs) have many of the characteristics of desktop applications. The RIAs are typically delivered either by a site-specific browser, a browser plug-in, or independently via a virtual machine. The most commonly used frameworks that support such Web applications are Adobe Flash\u00ae, Java, and Microsoft Silverlight\u00ae. Generally, the framework has to be installed using the computer's operating system prior to launching the RIA. The Web application framework typically downloads, updates, verifies, and executes the RIA. Microsoft Silverlight\u00ae is a programmable Web browser plug-in that enables features such as animation, vector graphics and audio-video playback that characterize RIAs. Microsoft Silverlight\u00ae brings additional interactivity features and support for .NET\u00ae languages and development tools. It is compatible with multiple Web browser products. Microsoft Silverlight\u00ae, which was developed under the codename Windows\u00ae Presentation Foundation\/Everywhere (WPF\/E), is a web-based subset of WPF.","Many Web application frameworks follow the Model View Controller (MVC) architectural pattern to separate the data model with the business logic from the user interface. The MVC pattern modularizes code, promotes code reuse (use of existing software code, or software knowledge, to build new software code), and allows multiple interfaces to be applied. The MVC architecture consists of a model, a view, and a controller. The model part of the MVC pattern is a domain-specific representation of the data upon which the application operates. Domain logic adds meaning to raw data (for example, calculating the totals, taxes, and shipping charges for shopping cart items). When a model changes its state, it notifies its associated views so they can refresh. The view of the MVC pattern renders the model into a form suitable for interaction, typically a user interface element. Multiple views can exist for a single model for different purposes. The controller of the MVC pattern receives input and initiates a response by making calls on model objects. When a Web application user interface framework is built on the MVC architectural pattern approach, high speed development of uniform user interfaces (UIs) is possible.","Various embodiments of systems and methods for a layering concept for a repository of a user interface framework for Web applications are described herein. In an embodiment, the method includes receiving a request to obtain a data object from a repository, wherein the repository is organized in a set of layers, each layer implemented as a file system that stores content for a solution. The method further includes providing access to the repository based on a layer strategy, wherein the layer strategy includes a definition of at least one layer from the set of layers and a definition of a sequence access to the set of layers. Finally, the set of layers of the repository is searched for the data object based on the sequence access to the set of layers defined in the layer strategy.","In an embodiment, the system includes a processor and a memory in communication with the processor. The memory includes a repository organized in a set of layers, each layer implemented as a file system that manages content for a solution. The repository includes a personalization file system that stores personalization settings, a development file system that stores temporary content, which in response to activation is moved to a writable layer, and a list file system that includes the set of layers, wherein the set of layers are defined in a layer strategy.","These and other benefits and features of embodiments of the invention will be apparent upon consideration of the following detailed description of preferred embodiments thereof, presented in connection with the following drawings.","Embodiments of techniques for a layering concept for a repository of a user interface framework for Web applications are described herein. In the following description, numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize, however, that the invention can be practiced without one or more of the specific details, or with other methods, components, materials, etc. In other instances, well-known structures, materials, or operations are not shown or described in detail to avoid obscuring aspects of the invention.","Reference throughout this specification to \u201cone embodiment\u201d, \u201cthis embodiment\u201d and similar phrases, means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus, the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be combined in any suitable manner in one or more embodiment.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["110","120","115","125"]},"In one embodiment, the UI Framework Client Runtime  may be implemented in a programming language such as \u201cC#\u201d using a RIA based framework such as Microsoft Silverlight\u00ae technology. The UI Framework Client Runtime  is responsible for rendering user interfaces and accessing business data from backend . Every user request is triggered on the UI Framework Client Runtime . The very first request is a navigation request that results in a request to the backend  to read a UI component. The UI component is read from the Repository  in the backend  and transported to the frontend . A component manager instantiates the UI component and a corresponding component controller  for the UI component on the frontend  and triggers the initialization of the UI component on the backend . The component manager builds up a control tree for the UI component out of a set of UI controls . These UI controls  ensure conformable look and feel and the ability to change UI themes consistently. The controls in the \u201cthemed UI controls\u201d package are all enabled in a consistent way for test automation and accessibility, and are provided in a manner so that native implemented custom UI panes can make use of those controls. Usually, more than one UI component is needed to render a UI, as UI components typically embed other UI components (e.g., a Work Center component embeds a set of Work Center View Components and they again embed other components). The top-level UI component that is rendered is the root UI component which ensures the rendering of a common frame for all UI components, e.g., by rendering the top level navigation and the ability for personalization from personalization unit .","In an embodiment, the UI Framework Client Runtime  also comprises the following built-in units: analytics , mashups , diagnostics , shell , and frontend scripting engine . Analytics  are components that represent data in a grouped, aggregated, and hierarchical way. These components serve to answer business questions about, for example, how many products were sold in a particular country and provide drill down capabilities to different levels of abstraction. Diagnostics  allows the collection of, for example, the context of the current framework and all other running entities of the overall system at a specific point in time (e.g., in case of an exception or error). The collected information can help to track down the cause of the exception. Shell unit  provides the shell for running the UI Framework Client Runtime. It includes all units for the user interface ranging from defining the overall appearance of windows (including standard elements such as menus, toolbars, navigation areas, windows management) as well as the mediator layer that maps logical component definitions from the configuration model to physical controls. In addition, there are possibilities to use a Silverlight\u00ae feature to run the client in \u201cout of browser\u201d mode. Also, a prototype exists to run the client as a standard WPF desktop client in contrast to the Silverlight\u00ae browser plug-in. This requires some replacement of connectivity and authorization code, which is provided by the browser stack itself. Frontend scripting engine  enables data from the client side data model to be read, evaluated, and modified\u2014which eventually causes configured events again in the runtime execution of the model. With these capabilities, UI-only logic can be expressed and modeled via some script; it is not required to implement or model the logic in the backend. Optionally, the script can be executed on the client or backend.","The frontend  communicates with the backend  via browser  on a regular HTTP\/HTTPs connection  using JavaScript Object Notation (JSON) (also, other serialization formats such as XML can be used in parallel to JSON) as a lightweight data interchange format. The requests from the frontend  are received at Internet Communication Framework (ICF) . The ICF  forwards the requests to the UI Framework Server Runtime  and Repository . The Repository  stores all UI entities with their metadata. The UI Framework Server Runtime  reads and interprets the UI model of the application, manages the access to the backend and ensures an optimized communication with the UI Framework Client Runtime . After the UI Framework Client Runtime  triggers the initialization of a UI component in the backend  for a first time in a session, the UI Framework Server Runtime  first creates a master controller  for the complete session and then creates a component controller for each component that is requested from the UI Framework Client Runtime . Each component controller builds a UI data container out of the information of the UI model for a component. At runtime, the composition of the dependent components is combined within the master controller , which holds one event queue and performs data updates for all included components as one component. In an embodiment, logically separated declared components can be configured to run as one virtual controller at runtime.","After the master controller  has processed all component controllers, it collects all the data that has changed in the UI data container and makes sure that all changed data and only the changed data is transported to the client . The access from the UI Framework Server Runtime  to business data  is performed via connector . Connector  is able to connect to different technologies.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2","b":["175","175","210","220","210","215","225","230","230","210","175","175","175","175","235"]},"The service provider  is managed by the repository . For UI components, the service provider  is aware of the internal buildup of the entity. The structure of UI components may be described in an XML Schema Definition (XSD) format. A UI component consists of a model part, a controller part, and a view part. The model part contains the binding to the business objects and represents the data sources available in the UI. The controller part describes (special) UI logic and can contain\/reference script coding (e.g., Ruby Script). The view part contains the UI elements and their layout. UI texts are language dependent and need to be mixed in according to the logon language of the user.","The service provider registry and all other metadata that belongs to the repository  are also exposed by the APIs , which are accessed through different clients. The repository  provides an option to expose text from the different content types into tables and other units of the framework to access the tables and handle the exposed text. For example, a translation unit can translate the text and when the translation is performed, the repository  handles the merging back of the text into the different content types via service calls. For example, some text can be defined in a user interface such as a title of a floor plan, the header of a section, etc., and this text is stored in a UI component, which is stored in the repository . A service provider implements the interfaces from the core repository layer. Using the implemented interface, the framework is notified that there is some text for translation available. The framework extracts the text in a separate table (or tables) and the translation process is performed. Once the translation is finished, the translated text is filled back in the table. Later, when the runtime requests that specific user interface, for which the text has been translated, to run, then the repository  has the feature to merge text in the appropriate language into the content and thus the content provides the translated UI back to the user.","The administration user interfaces  allow the users to manage and configure the repository  by actions such as registering service provider , creating solutions, creating projects, handling transport issues, and so on. The design time UIs  and the runtime UIs  communicate with the repository  via HTTP\/HTTPs connections. The HTTP calls (get\/post) are routed directly via JSON connector  to the repository APIs . The core part of repository  includes repository engine  and core toolbox . Core toolbox  is used by repository engine  to provide core functionalities such as: addressing\/naming, layering, versioning, locking, transport handling, caching, etc. The core part of repository  is not aware of the semantics of its content, if the content is an image, a document, coding, a .dll file, and so on. The commonly needed core functionalities guarantee a fast and easy integration of different content types into the repository . Specific functionalities concerning the semantics of the content are handled by specialized service providers. A service provider (such as service provider ) can be written and registered in the repository core to perform the handling of dedicated content types. The registered service provider can use the core toolbox  to implement their functionalities.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3","b":["175","305","310","305","315","320","325","330","315","335","340","320","345","350","360","310","355","315","315","320","325","335"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 4","b":["175","175","410","420","175","420","430","440","410","450","460","175"]},"In an embodiment, internal file systems may be implemented in the repository core to execute base operations such as put, get, and list of files. In repository , a file system that can be delivered or imported into a system is unique in the repository as identified with a globally unique identifier (GUID) and has type of \u201csolution\u201d. The file systems include, but are not limited to, a default file system, a customer file system, a development file system, a personalization file system, list file system, layer strategy file system, all file system, and so on.","The default file system accesses the core header table of the repository ; it is user and client independent. The default file system also provides the transport connection and lock mechanism. The customer file system is a special implementation of default file system. This file system accesses the client dependent header table. In the customer file system, all changes that belong to one customer are stored. The customer file system does not provide a transport mechanism, but a lock mechanism is available so that nobody from the same client is able to edit the same file concurrently. This type of a file system is used in a customer system. Customers are not allowed to modify any entities that belong to solutions of other partners. Modifying or extending entities is performed by using the relative URL of the entity for an own replacement of the entity.","The development file system is a default file system that is not created based on the user settings. This file system is always added by the core of the repository. The development file system accesses the client and the user dependent header table and acts as a work list during development. All content in this file system is temporarily stored and after activation will be moved into the next writable layer. This type of a file system does not provide a transport and a lock mechanism. Partners can deliver their own solutions, which can refer to other solutions. Partners are not allowed to modify any entities that belong to solutions of other partners. Modifying or extending entities is performed by using the relative URL of the entity for replacement of the entity.","Personalization file system is also user and client dependent; it stores the user specific changes. The personalization file system does not provide transport and locking mechanism too. The personalization file system does not store the content temporarily; the content is kept until it is removed explicitly. Users can personalize their UI (or the UI of special user groups) by creating their views or their texts in the appropriate file system. The list file system is a collection of all layers defined in the layer strategy table. This file system creates corresponding default or customer file systems based on the defined layer sequences. All operation calls that are delegated to the corresponding file system depend on the defined sequences and whether the layer is writable or not.","The layer strategy itself is also implemented as a file system internally. Layer strategy contains a list file system and two user-dependent file systems on top for development and personalization. Layer strategy just delegates all operations to the personalization, development, or list file system. Layer strategy file system can have two modes. One mode has personalization on top, then development file system and then list file system. Another mode has only development file system on top and then list file system. The mode with personalization is for the normal customer runtime environment, where the main change operations are for personalization. The mode without personalization is for the development design time environment, where a work list and corresponding states transition such as edit, create, save, and activation are required.","All file system is a special file system which only implements the read-only access. This file system represents the internal view of repository  without taking layer strategy settings into account. Solutions, branches and projects are displayed in the all file system.","The repository content may be stored by the repository core, repository engine  and core toolbox , and by the service provider . While the repository core stores administrative data, the service provider stores the actual content. User personalization data is stored into separate files to better support switch upgrades. In various embodiments, the repository content is arranged in branches as each branch may contain the complete set of a solution, such as a product, (a full branch) or only subsequently changed content (delta branches). Delta branches refer to a preceding branch. A layer in the repository is a view of one branch (including all preceding branches) of one solution. A layer strategy defines an ordered list of layers. Repository  uses the layer strategy as a search path from top to bottom when servicing content retrieval requests. The top-most entry of a layer strategy can be marked as writable. Repository  chooses the corresponding solution when serving change requests. Depending on the logon client different layer strategies can be used. In an embodiment, user-specific layer strategies may exist.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 5","b":["175","175","175"]},"In various embodiments, the layers and their order must be configured manually in a layer strategy or by some management layer, e.g., that handles to switch on and off partner solutions to be used by the customer. User layers are added by the repository by default without the need for manual configuration. The top-most layer (the user-specific layer) of a strategy is marked as writable, while all layers below are read-only. In an embodiment, there can be only one layer in a strategy that is writable.  shows the layering concept for access to the repository  based on solutions by parties. The horizontal axis represents the branches  of a product (e.g., releases of a product, service patches, etc.), while the vertical axis represents the solutions . The solution  at the bottom layer  represents the solution provided by the vendor (e.g., SAP Business ByDesign\u00ae by SAP). Solution  represents the solution provided by the partner at layer . Solution  represents the solution provided by the customer at layer . Solution  represents the solution provided by the user at layer . Layer  is marked as writable, which means that the users have rights to change the content of solution  in the repository.","\u201cCopy on write\u201d (COW) operation on the content takes place whenever a change request comes in the repository (e.g., an XML file) that is assigned to a read-only layer. The COW operation exists as one optional mode\u2014in this case the content \u201covershadows\u201d the content from the lower layer. There is also the mode when a change is stored in the upper layer and also as delta information to the lower content (implicit merge logic provided by the framework). There is also a third mode, where the delta information (so called \u201cchange transaction\u201d) is stored separately and linked to the original content and merged semantically by the repository framework (explicit merge logic).","The content is copied to the writable layer (e.g., layer ), while keeping a reference to the original content. Accordingly, \u201cwhiteout on delete\u201d (WOD) operation marks content as deleted in the writable layer. Repository  offers explicit API methods for personalization changes, because it treats personalization changes different from development changes\u2014especially with regard to software logistics and automatic \u201cdiff & merge\u201d functionality (redoes changes performed to a file when a new version of that file comes in; this is done automatically without human interaction). Repository  adds user-specific layers automatically to the configured layer strategy. One layer is added for design time requests. When a developer activates the changes, the content of this layer is moved back to the layer below. For runtime requests, two layers are added: one for user-specific development and another one for personalization.","In various embodiments, layers and corresponding layer strategies can be defined. The layer strategy includes a stack of layers and a sequence with a precedence of the different layers. For example, layer  includes the solution provided by the vendor and one or more layers  that include solutions for different partners on top of layer , which refer to layer . Also, there is one or more layers for the customers (e.g., ) and a plurality of layers for users including a layer for each user (e.g., layer ). For a specific party (user, customer, partner, etc.), there is a layer strategy defined, which starts with the corresponding user layer for the party and points to the vendor layer. The vendor layer points to any sequence of partner layers, if there are any, and finally the vendor layer is referenced as the lowest layer. This stack of layers and the layer strategy, which can be different for different users and different clients or companies, can aggregate a view to the different content. This means that if a specific object is accessed by one user through the aggregation mechanisms of the repository , it may result in a different view of the entities than for another user or for another company, or partner, etc.","Semantic changes can be defined to an existing entity and that entity may be stored to any layer in the repository. For example, there may be an object instance in the solution provided by the vendor (e.g., solution ) and a partner may want to bring additional fields to this object instance. The changes that the partner will perform are not stored within the vendor solution but are stored in a semantic description of this change in a small entity called change transaction, which describes the actual change (e.g., the additional fields to the object instance) in an abstract way. The change transaction is stored in the partner layer. Then, the repository has the feature that once this object instance is accessed, it knows that there are change transactions in the partner layer and if the partner layer is present in the current layer strategy of the request, then the change transaction will be merged into the object instance and a resulting view, as result of the merge, will be passed back as a response to the request. For atomization reasons, once the merge has happened, the result is stored in the partner layer of the repository and will be reapplied only if something is changed in the change transaction or in the underlying object (that is changed by the change transaction).","The layers stack and the layering strategy guarantee lifecycle stability. For example, there are different layers and a set of entities stored in the repository by a given solution. When an update of the solution is provided, the customer changes or the personalization settings to the layers are not lost but just they have been reapplied and remerged together with the newly content.","In some embodiments, the different releases of a solution are stored separately so that a switch between the releases is possible in case some data from an old release is needed. If the content in the repository  is shipped to customers and there is a new release, the new release is stored in parallel to the old release and the content of the old release is present to the customer, so that the customer is able to run the former release using the UIs of the new release.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 6"},"At block , a request is received that requires a data object to be read from the repository during runtime. At block , the request is forwarded to the layer strategy file system. The layer strategy is implemented as an internal file system\u2014the layer strategy file system. The layer strategy includes definitions of a set of layers and a definition of a sequence access to the layers with a precedence of the different layers. The sequence access represents a number that defines which layer has precedence to be accessed when searching the layers or when delegating an operation. The layer strategy file system contains a list file system and on top of it two user-dependent file systems: development file system and personalization file system.","At block , the request is forwarded to personalization file system to search and retrieve information for the data object. At decision block , it is checked if the data object is found in the personalization file system. If the result is \u201cyes\u201d, then the method continues at block , otherwise at block . At block , the request is forwarded to development file system to search and retrieve information for the data object. At decision block , it is checked if the data object is found in the development file system. If the result is \u201cyes\u201d, then the method continues at block , otherwise at block . At block , the request is forwarded to list file system to search and retrieve information for the data object. The list file system is a collection of all layers defined in the layer strategy. At block , the defined layers are searched in sequence according to the sequence access defined in the layer strategy. At block , the data object is located in a layer of the repository. At block , data object attribute value is returned in response to the initial request.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 7","b":["705","710","715","720","725","730","735","740","745"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 8","b":["810","820","830","840","850","860"]},"Some embodiments of the invention may include the above-described methods being written as one or more software components. These components, and the functionality associated with each, may be used by client, server, distributed, or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as, functional, declarative, procedural, object-oriented, lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively, the components maybe implemented in server and client applications. Further, these components may be linked together via various distributed programming protocols. Some example embodiments of the invention may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example, a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level (e.g., a graphical user interface). These first and second computer systems can be configured in a server-client, peer-to-peer, or some other configuration. The clients can vary in complexity from mobile and handheld devices, to thin clients and on to thick clients or even other servers.","The above-illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term \u201ccomputer readable storage medium\u201d should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term \u201ccomputer readable storage medium\u201d should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store, encode, or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described, represented, or illustrated herein. A computer readable storage medium may be a non-transitory computer readable storage medium. Examples of a non-transitory computer readable storage media include, but are not limited to: magnetic media, such as hard disks, floppy disks, and magnetic tape; optical media such as CD-ROMs, DVDs and holographic devices; magneto-optical media; and hardware devices that are specially configured to store and execute, such as application-specific integrated circuits (\u201cASICs\u201d), programmable logic devices (\u201cPLDs\u201d) and ROM and RAM devices. Examples of computer readable instructions include machine code, such as produced by a compiler, and files containing higher-level code that are executed by a computer using an interpreter. For example, an embodiment of the invention may be implemented using Java, C++, or other object-oriented programming language and development tools. Another embodiment of the invention may be implemented in hard-wired circuitry in place of, or in combination with machine readable software instructions.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 9","b":["900","900","905","955","900","940","955","910","915","910","915","905","915","900","925","930","900","925","930","900","935","900","950","950","900","945","900","920","960","960","960","950","960"]},"A data source  is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases, such as, relational, transactional, hierarchical, multi-dimensional (e.g., OLAP), object oriented databases, and the like. Further data sources include tabular data (e.g., spreadsheets, delimited text files), data tagged with a markup language (e.g., XML data), transactional data, unstructured data (e.g., text files, screen scrapings), hierarchical data (e.g., data in a file system, XML data), files, a plurality of reports, and any other data source accessible through an established protocol, such as, Open DataBase Connectivity (ODBC), produced by an underlying software system (e.g., ERP system), and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams, broadcast data, and the like. These data sources can include associated data foundations, semantic layers, management systems, security systems and so on.","In the above description, numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize, however that the invention can be practiced without one or more of the specific details or with other methods, components, techniques, etc. In other instances, well-known operations or structures are not shown or described in details to avoid obscuring aspects of the invention.","Although the processes illustrated and described herein include series of steps, it will be appreciated that the different embodiments of the present invention are not limited by the illustrated ordering of steps, as some steps may occur in different orders, some concurrently with other steps apart from that shown and described herein. In addition, not all illustrated steps may be required to implement a methodology in accordance with the present invention. Moreover, it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.","The above descriptions and illustrations of embodiments of the invention, including what is described in the Abstract, is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of, and examples for, the invention are described herein for illustrative purposes, various equivalent modifications are possible within the scope of the invention, as those skilled in the relevant art will recognize. These modifications can be made to the invention in light of the above detailed description. Rather, the scope of the invention is to be determined by the following claims, which are to be interpreted in accordance with established doctrines of claim construction."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The claims set forth the embodiments of the invention with particularity. The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. The embodiments of the invention, together with its advantages, may be best understood from the following detailed description taken in conjunction with the accompanying drawings.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2","b":"175"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4","b":"175"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5","b":"175"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
