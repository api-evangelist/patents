---
title: Method and system for distributing applications
abstract: Methods and systems for distributing applications are described herein. In one aspect of the invention, an exemplary method includes receiving an original request for accessing a distributed resource management system (DRMS) through an application distributor application programming interface (API), the application distributor API being independent of the DRMS, selecting the DRMS as requested, translating the original request to be compatible with the selected DRMS, and transmitting translated request to the selected DRMS. Other methods and systems are also described.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07096249&OS=07096249&RS=07096249
owner: Intel Corporation
number: 07096249
owner_city: Santa Clara
owner_country: US
publication_date: 20020329
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD","BACKGROUND","DETAILED DESCRIPTION"],"p":["Embodiments of the invention relate to the field of distributed application; and more specifically, to distributed resource management system environments.","As the computer networks are getting more popular and the development of software applications getting more complex, the software applications are more often executed in parallel in a distributed environment. These applications that run on a master host could use distributed resource manager system (DRMS) to have the jobs executed on available compute servers.","However, in order to use a DRMS, the application developers have to redesign their applications for distributed execution. Normally, the redesigned distributed application submits jobs for execution, stages input and output files for the jobs, monitors and controls the remote jobs by making calls to an application programming interface (API) provided by a DRMS vendor. Typically, commercially available DRMSs have very different APIs that support different remote execution paradigms. As a result, this situation effectively precludes development of distributed applications by independent application vendors who cannot afford to support multiple DRMSs that might be installed on their end user sites.","In addition, one of the obstacles that the distributed application developers are facing is that the DRMS interfaces are designed on how to interact with the DRMS, rather than on how to accomplish common tasks that come up during developing distributed applications. Each DRMS API is distinctly different from each vendor. A developer is not only facing with the task of handling the program logic and mapping it to a variety of DRMS APIs, but also providing ways for an end user of the application to interact with the computing environment.","When a distributed application is an application that spawns child processes, there are situations where the application interchanges data with its child processes via a communication channel. When the child application is sent to a remote site for execution, the communication channel is broken. Therefore, a workable solution is needed.","A single portable application programming interface (API) is provided to support varieties of distributed resource management system (DRMS). The API provides single point of access for developers of distributed applications to interact with a DRMS without specific knowledge of the targeted DRMS. A mechanism is provided to further simplify and automate distributed application execution for the end users. In addition, a set of proxies for inter-machine communication is described that supports a communication between the parent application and its spawned child or helper applications when the parent application spawned helper applications are submitted for execution in a distributed environment. In the following description, numerous specific details are set forth. However, it is understood that embodiments of the invention may be practiced without these specific details. In other instances, well-known circuits, structures and techniques have not been shown in detail in order not to obscure the understanding of this description.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 1","FIG. 1"],"b":["101","108","108","101","107","107","107","104","106"]},"The DRMS  could be one of the varieties of the DRMS commercially available in the market. In one embodiment, the DRMS  may be LSF from Platform Computing. Alternatively, the DRMS  may be PBS or PBS Pro from Veridian, LoadLeveler from IBM, or enFuzion from TurboLinux. Other DRMS may be utilized. As discussed above, each DRMS has different architecture and different interface. Conventionally, a distributed application developer has to redesign or customize its application to be compatible with the targeted DRMS, in order to communicate with the targeted DRMS. Since there are varieties of DRMS out in the market, it would be a burden for the developer to develop different application for different DRMS vendors.","PAD API library encapsulates all of the specific information of most DRMS on the market. The API also provides a higher level abstraction than those provided by the DRMS vendors. The higher level abstraction makes the API much easier to use. For example, using an embodiment of the API, controlling or waiting for completion of all remote tasks could be accomplished with just a one call, without having full knowledge of the targeted DRMS. The specific DRMS internals are hidden from the developers such that they can spend more time on developing new functionality.","Referring to , a distributed application uses PAD API to place requests to the selected DRMS. The request may further include parameters passed to the DRMS by a person who is running the distributed application. A PAD library that implements the PAD API is initialized before being used by providing all the information that a DRMS might need. For example, a DRMS may be selected via an environmental variable that is either set directly via an environmental variable or within a script that is used to run the distributed application Other methods may be utilized. The rest of the DRMS specific variables needed for initialization are specified similarly. After the PAD library API use or at the end of the distributed application execution, the PAD library is disengaged.","Once the PAD library  receives a request for DRMS it selects a proper specific code based on the DRMS with which was initialized. The PAD library specific code  then translates the request to specific DRMS calls  compatible with the specific DRMS requested. The DRMS  then schedules the distributed application jobs to a proper compute server, such as compute server  over a network . Thereafter, the remote application is launched on the compute server.","As a result, a distributed application developer does not need to know specific API of each DRMS being accessed. Instead, the developer calls the PAD API  specifying a DRMS. The PAD library  properly translates the request to appropriate DRMS API and requests the execution of the job in a proper DRMS. The end user can specify different DRMS, only one per application, without actual knowledge of the specific DRMS being accessed.","As the distributed application  getting more complex, an application driver script  may be used to control the distributed application . The application driver script  may be written in any scripting language. In one embodiment, the script may be in Perl scripting language. The application driver script  may be used to prepare the distributing application execution environment. In some cases, the application driver script  may be acting as a driver shell that insulates an end user from the tedium of choosing the appropriate environment in which the distributed application is run.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2","b":["201","201","202","201","202","203","203","203"]},"The PAD library  translates the request from the distributed application  to another request compatible with the intended DRMS. For example, if a user desires to use DRMS LSF , the user may choose LSF at the distributed application execution time. The PAD library  then translates the request to a format compatible to a specific API of LSF , such that the request can be handled correctly by LSF DRMS subsequently. As a result, the end user or the developer does not need to know the specific API of LSF . All they need to do is to specify the intended DRMS and call PAD API, and the PAD library  will properly take care of how to submit request to LSF . Similarly, the end user may choose to access other DRMS systems, such as PBS , by simply selecting PBS before the distributed application execution.","In addition to having very different interfaces, DRMSs have different approaches to handle remote computations. Typically, there are two modes in execution of distributed applications: data centric mode and job centric mode.  shows a typical data centric mode and  shows a typical job centric mode. Referring to , under the data centric mode, the distributing application master host created files (e.g., input files  and output files ), are stationary and are not moved to the remote compute server . Under the data centric mode, the computations are performed in a shared disk storage space. Under the job centric mode, as illustrated in , private copies of files, such as input files  and output files , are used for a remote job  at the remote compute server . Under the job centric mode, the remote jobs are executed in the compute server's local directories, which requires proper file staging to and from the compute servers.","An embodiment of the PAD library implements a neutral model supporting both modes. The developers do not need to know how to handle the specifics of these modes, such as file staging under job centric mode. All they need to do is to specify the input and output files in both of these modes and the PAD library will handle them properly. While the developer may restrict the distributed application implementation to either one of these modes, it may be more appropriate for the end user to decide. The PAD API hides all of these complexities from the developers and end users.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 4"},"Referring to , when a distributed application is executed, at block , the distributed application initializes the PAD library by specifying all necessary information for a DRMS system. The initialization may be conducted through a scripting file, a set of global environmental variables or by direct calls to the PAD API. DRMS is selected via an environmental variable by either of the former two ways above. At block , a requested DRMS is initialized. After the initialization, at block , the distributed application calls the PAD API and submits a request to DRMS through the PAD library API . Based on the initialization, the PAD library selects the targeted DRMS. At block , the PAD library translates the request to be compatible with the targeted DRMS, such that the request can be recognized and executed by the appropriate DRMS. At block , the translated request is then transmitted to the targeted DRMS. In one embodiment, the request is transformed to a script, such as remote script  of . Such script is created on the fly by the PAD library. While the jobs are being executed at a compute server, at block , the PAD could wait for the remote job executions to finish. Once the jobs have finished executing, at block , the distributed application disengages PAD library PAD library disengages from the DRMS, and distributed application exits.","The routines may be grouped in four categories: init and exit, job submission, job monitoring and control, and auxiliary routines. The job submission routines allow a developer to specify a remote execution command, mode of job execution, mode of disk utilization, files to be staged, manipulation of standard input, output, and error streams, native DRMS options to be passed, and job name to be used for the job submission. The job monitoring and control routines contain job stopping, resuming, and killing, waiting for the remote job until the end of its execution, checking the exit code of the finished remote job, checking the remote job status, and waiting for all the jobs to finish execution. The auxiliary routines serve for tracing and error monitoring. The tracing is useful when there are multiple processes spawned.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 5","FIG. 5"]},"Referring to , when a distributed application  is started the distributed application spawns a local proxy instead of its helper or child application. The local proxy, with execution environment set up in Proxy Driver Script , submits or queues a remote proxy job with DRMS , using a PAD API, such as PAD library API  of . The PAD library identifies the proper DRMS and translates the remote proxy job request to comply with the API of the specific DRMS requested. Before the local proxy submits a remote proxy job it starts a communication server  at the local host. In one embodiment, the communication server may be a socket server. The local proxy  provides the basic functionality and a customizable part where developers may add customized functionality to extend its basic features. The command line parameters that were intended for the helper or child application are part of the remote proxy command line parameters.","The local proxy may perform other tasks such as encoding signals and transmitting data. The signals are transmitted from the distributed application and are intended for the helper or child application. The data could be transmitted in both directions, helper or child application sends data to the distributed application. Likewise, the distributed application could be sending data to the helper or child application.","At the remote site, once the remote proxy starts running, the remote proxy spawns a remote or helper application  with the same command line parameters that were set by the distributed application. The remote proxy  then starts a communication client at the remote site. In one embodiment, the communication client may be a socket client. The remote proxy  uses the communication client to connect with the communication server  running at the local proxy, to form a communication channel  between the local proxy  and the remote proxy . The communication channel  effectively connects the remote helper or child application (formerly child process on the local machine) with its distributed application . It is useful to note that the local and the remote proxies are implemented to functionally replicate the original communication channel between the distributed application and the helper or child application, when they are communicating to the distributed and helper or child application respectively. The helper or child application is replaced with a system of local proxy, remote proxy, and now remote helper or child application. From the distributed application view (e.g., the parent distributed application), there is no difference when it communicates with its child application. The parent distributed application communicates the same way to the local proxy, as to its original child application.","The communication server, for example a socket server, of the local proxy listens for the remote proxy socket connection and handles the incoming socket data including the transfer of the remote proxy child application process ID. The outgoing socket data connection is used to encode the signal and to transfer data from the distributed application . Typically, the remote application  uses standard input and output (e.g., stdin, stdout, or stderr) to transfer data back and forth with its parent distributed application. The data are intercepted and retransmitted by the local and remote proxies.","The local proxy could be a standalone process or it could be embedded in the distributed application. The remote proxy is a standalone process. Application developers or end users may individually customize the local and remote proxies, such that the communication between the child process and its parent distributed application contains more functionality and flexibility. Similar to the PAD library API of , the distributed application may be invoked by a proxy driver script . The proxy driver script  may be written in any scripting language, such as Perl, or it could be a graphic user interface (GUI) to control or interact with the distributed application . The end user may use the proxy driver script to set up the environment for the local proxy execution.","The local and remote proxies may be customized by the developer. The developer may add extra parameters to the original helper or child application command line parameter list. The extra parameters are obtained from the end user configured customized files. The developer has to properly stage input and output files from the original command line parameters to and from the remote host. The remote proxy uses its communication client program to propagate the data and decoded signals from the local proxy to the remote child application on its remote node. The remote proxy has to decode the signals received from the local proxy to resend them to the remote helper application. It also transfers data from the remote helper application back to the master host. The local proxy and remote proxy may be implemented in multithreaded or in multiplexed form.","In addition, according to one embodiment, a proxy daemon  may be employed to monitor the remote proxy  and the remote application . The purpose of the proxy daemon  is to ensure that the remote application is terminated if it is still running after the termination of the remote proxy. For example, when the remote proxy is terminated by the local proxy  or by the DRMS , leaving the remote application  running by accident, the proxy daemon  terminates the remote application  since it is no longer needed. One proxy daemon monitors all the remote proxy\/remote application pairs on one machine. When there are no remote proxy\/remote application pairs for a predetermined amount of time the proxy daemon  terminates itself since it is no longer needed. The proxy daemon is transparent to the end user and developer.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 6","b":["601","605","602","604","603","604","602","604","602","605","607","604","608","602","603","602","609","601"]},"Once the communication channel has been established between the local and remote proxies, the parent distributed application can exchange data with its remote child application. The parent distributed application exchanges data with its remote child application in the same way as usual, even though the remote child application has been relocated to a remote site. In a conventional method, once the remote child application has been relocated to a remote site, the communication channel between the parent and the child (e.g., pipe) is broken. With the use of the local and remote proxies, the communication channel is maintained by the proxies.","When the parent distributed application  desires to communicate with its remote child application , it could send a signal and\/or a message  to the local proxy . The local proxy  encodes the signal and sends the encoded signal and\/or message  to the remote proxy  through the communication channel (e.g., socket channel), over the network . The remote proxy  then decodes the signal and transmits the decoded signal and\/or a message  properly to the remote child application . The remote child application may reply by transmitting the reply  back to the remote proxy  which in turn redirects the data  through the communication channel over the network, to the local proxy . The local proxy  then completes the transfer  back to the parent distributed application .","With the help of the local and remote proxies, the distributed application, we could call it a parent application,  does not need to know where the remote child application  is being executed. The remote proxy  has spawned the remote child application , while the distributed application  has spawned the local proxy. As long as the communication channel is maintain between the local and remote proxies, the data exchanged between the distributed application and the remote child processes is properly handled. All the local proxy and remote proxy need to do is to correctly communicate with the distributed and remote child applications respectively.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 7","b":["509","507","508"]},"Referring to , at block , when the proxy daemon is launched, it records its own communication server port. At block , the proxy daemon listens and waits for the registration from the remote proxy. Once the remote proxy registers itself and the remote application to the proxy daemon, the proxy daemon monitors the activities of both remote proxy and the remote application, at block . At block , the proxy daemon may detect whether the remote proxy has been terminated. If the remote proxy has been terminated, at block , the proxy daemon terminates the remote application if the remote application is still running. At block , the monitoring process continues until there are no remote proxy\/application activities for a pre-specified amount of time. In which case, the proxy daemon closes the communication server, at block , and terminates itself since it is no longer needed.","After the proxy daemon is launched and initialized, the proxy daemon monitors any abnormal activities of the remote proxy and remote application. For example, at block , if the proxy daemon detects that the remote proxy has been terminated by either the DRMS or the local proxy at the local node, while the remote application is still running, the proxy daemon terminates the remote application at block . Thereafter, if no more remote proxy\/application activities for a period of time are detected at block , the proxy daemon closes the communication server and terminates itself, at block .",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIGS. 8 and 9"},"Referring to , when a distributed application is started, at block , the local proxy is spawned by the distributed application. It is configured upon start by the execution environment set up by a user via proxy driver script . At block , the local proxy then starts a socket server so that a remote proxy can establish a communication channel from the remote node. At block , the local proxy queues the remote proxy job to the DRMS which in turn schedules the remote proxy job to a remote node for execution. If the local proxy receives a signal from the distributed application (e.g., user requests to interact with the distributed application), the local proxy transmits the encoded signal to the remote proxy through the socket channel set up previously, at block .","The local proxy also listens to the remote proxy for any remote activity. At block , if the local proxy receives remote data from the remote proxy through the socket channel, the local proxy redirects the data to the distributed application at block . At block , if the local proxy detects that the remote proxy\/remote application has been terminated, the local proxy closes the socket server at block  and exits execution with the exit code of the remote helper application or an error code of any failure that prevented execution of the remote helper application.","Referring to , at block , when the remote proxy spawns the remote helper application the remote proxy launches the proxy daemon if one has not been already running. Once the proxy daemon is running, the remote proxy registers with the proxy daemon. After establishing a connection with the local proxy, block , the remote proxy also listens for any data coming from the local proxy or the remote application. At the block , if the remote proxy receives an encoded signal from the local proxy, it decodes the signal and retransmits it to the remote application at block . On the other hand, at block , if the remote proxy receives data from the remote application, it redirects the data to the local proxy through the socket connection at block . These data activities continue until the remote application exits at block , upon which time, the remote proxy closes the socket connection at block  and exits with the exit code of the remote helper application or an error code of any failure that prevented execution of the remote helper application.","In the foregoing specification, the invention has been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the invention as set forth in the following claims. The specification and drawings are, accordingly, to be regarded in an illustrative sense rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention may best be understood by referring to the following description and accompanying drawings that are used to illustrate embodiments of the invention. In the drawings:",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
