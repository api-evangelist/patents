---
title: Graphics compute process scheduling
abstract: A method, system, and computer program product are disclosed for providing improved access to accelerated processing device compute resources to user mode applications. The functionality disclosed allows user mode applications to provide commands to an accelerated processing device without the need for kernel mode transitions in order to access a unified ring buffer. Instead, applications are each provided with their own buffers, which the accelerated processing device hardware can access to process commands. With full operating system support, user mode applications are able to utilize the accelerated processing device in much the same way as a CPU.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09176794&OS=09176794&RS=09176794
owner: ATI Technologies ULC
number: 09176794
owner_city: Markham, Ontario
owner_country: CA
publication_date: 20111104
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY OF EMBODIMENTS","DETAILED DESCRIPTION OF EMBODIMENTS","CONCLUSION"],"p":["This application claims the benefit of U.S. Provisional Patent Application Ser. No. 61\/422,460, filed Dec. 13, 2010, entitled \u201cGraphics Compute Process Scheduling,\u201d which is incorporated herein by reference in its entirety.","1. Field of the Invention","The present invention is generally directed to computing systems. More particularly, the present invention is directed to unifying the computational components within a computing system.","2. Background","The desire to use a graphics processing unit (GPU) for general computation has become much more pronounced recently due to the GPU's exemplary performance per unit power and\/or cost. The computational capabilities for GPUs, generally, have grown at a rate exceeding that of the corresponding central processing unit (CPU) platforms. This growth, coupled with the explosion of the mobile computing market (e.g., notebooks, mobile smart phones, tablets, etc.) and its necessary supporting server\/enterprise systems, has been used to provide a specified quality of desired user experience. Consequently, the combined use of CPUs and GPUs for executing workloads with data parallel content is becoming a volume technology.","However, GPUs have traditionally operated in a constrained programming environment, available primarily for the acceleration of graphics. These constraints arose from the fact that GPUs did not have as rich a programming ecosystem as CPUs. Their use, therefore, has been mostly limited to two dimensional (2D) and three dimensional (3D) graphics and a few leading edge multimedia applications, which are already accustomed to dealing with graphics and video application programming interfaces (APIs).","With the advent of multi-vendor supported OpenCL\u00ae and DirectCompute\u00ae, standard APIs and supporting tools, the limitations of the GPUs in traditional applications has been extended beyond traditional graphics. Although OpenCL and DirectCompute are a promising start, there are many hurdles remaining to creating an environment and ecosystem that allows the combination of a CPU and a GPU to be used as fluidly as the CPU for most programming tasks.","Existing computing systems often include multiple processing devices. For example, some computing systems include both a CPU and a GPU on separate chips (e.g., the CPU might be located on a motherboard and the GPU might be located on a graphics card) or in a single chip package. Both of these arrangements, however, still include significant challenges associated with (i) separate memory systems, (ii) efficient scheduling, (iii) providing quality of service (QoS) guarantees between processes, (iv) programming model, and (v) compiling to multiple target instruction set architectures (ISAs)\u2014all while minimizing power consumption.","For example, the discrete chip arrangement forces system and software architects to utilize chip to chip interfaces for each processor to access memory. While these external interfaces (e.g., chip to chip) negatively affect memory latency and power consumption for cooperating heterogeneous processors, the separate memory systems (i.e., separate address spaces) and driver managed shared memory create overhead that becomes unacceptable for fine grain offload.","Both the discrete and single chip arrangements can limit the types of commands that can be sent to the GPU for execution. By way of example, computational commands (e.g., physics or artificial intelligence commands) often cannot be sent to the GPU for execution. This limitation exists because the CPU may relatively quickly require the results of the operations performed by these computational commands. However, because of the high overhead of dispatching work to the GPU in current systems and the fact that these commands may have to wait in line for other previously-issued commands to be executed first, the latency incurred by sending computational commands to the GPU is often unacceptable.","An additional difficulty faced in using GPUs for computational offloading lies in the software tools available to developers to interface with the GPU and provide work. Many of the existing software tools are designed with the GPU's graphics capabilities in mind, and therefore lack the capability to easily provide non-graphics work to a GPU.","What is needed, therefore, is improved support for accessibility of GPU compute resources.","Although GPUs, accelerated processing units (APUs), and general purpose use of the graphics processing unit (GPGPU) are commonly used terms in this field, the expression \u201caccelerated processing device (APD)\u201d is considered to be a broader expression. For example, APD refers to any cooperating collection of hardware and\/or software that performs those functions and computations associated with accelerating graphics processing tasks, data parallel task's, or nested data parallel tasks in an accelerated manner compared to conventional CPUs, conventional GPUs, software and\/or combinations thereof.","Various embodiments of the present invention include a method and apparatus for allocating an APD work queue for an application via a kernel mode driver, allocating a compute process control block for the application. The compute process control block includes a reference to the work queue. The method and apparatus also include selecting, by a scheduler, the compute process control block for execution, and dispatching commands from the work queue referenced by the compute process control block to the APD.","Additional features and advantages of the invention, as well as the structure and operation of various embodiments of the invention, are described in detail below with reference to the accompanying drawings. It is noted that the invention is not limited to the specific embodiments described herein. Such embodiments are presented herein for illustrative purposes only. Additional embodiments will be apparent to persons skilled in the relevant art(s) based on the teachings contained herein.","Further features and advantages of the invention, as well as the structure and operation of various embodiments of the invention, are described in detail below with reference to the accompanying drawings. It is noted that the invention is not limited to the specific embodiments described herein. Such embodiments are presented herein for illustrative purposes only. Additional embodiments will be apparent to persons skilled in the relevant art based on the teachings contained herein.","In the detailed description that follows, references to \u201cone embodiment,\u201d \u201can embodiment,\u201d \u201can example embodiment,\u201d etc., indicate that the embodiment described may include a particular feature, structure, or characteristic, but every embodiment may not necessarily include the particular feature, structure, or characteristic. Moreover, such phrases are not necessarily referring to the same embodiment. Further, when a particular feature, structure, or characteristic is described in connection with an embodiment, it is submitted that it is within the knowledge of one skilled in the art to affect such feature, structure, or characteristic in connection with other embodiments whether or not explicitly described.","The term \u201cembodiments of the invention\u201d does not require that all embodiments of the invention include the discussed feature, advantage or mode of operation. Alternate embodiments may be devised without departing from the scope of the invention, and well-known elements of the invention may not be described in detail or may be omitted so as not to obscure the relevant details of the invention. In addition, the terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. For example, as used herein, the singular forms \u201ca\u201d, \u201can\u201d and \u201cthe\u201d are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms \u201ccomprises,\u201d \u201ccomprising,\u201d \u201cincludes\u201d and\/or \u201cincluding,\u201d when used herein, specify the presence of stated features, integers, steps, operations, elements, and\/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and\/or groups thereof.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 1A","b":["100","102","104","102","100","102","104","104","102","102","104"]},"In one example, system  also includes a memory , an operating system , and a communication infrastructure . The operating system  and the communication infrastructure  are discussed in greater detail below.","The system  also includes a kernel mode driver (KMD) , a software scheduler (SWS) , and a memory management unit , such as input\/output memory management unit (IOMMU). Components of system  can be implemented as hardware, firmware, software, or any combination thereof. A person of ordinary skill in the art will appreciate that system  may include one or more software, hardware, and firmware components in addition to, or different from, that shown in the embodiment shown in .","In one example, a driver, such as KMD , typically communicates with a device through a computer bus or communications subsystem to which the hardware connects. When a calling program invokes a routine in the driver, the driver issues commands to the device. Once the device sends data back to the driver, the driver may invoke routines in the original calling program. In one example, drivers are hardware-dependent and operating-system-specific. They usually provide the interrupt handling required for any necessary asynchronous time-dependent hardware interface.","Device drivers, particularly on modern Microsoft Windows\u00ae platforms, can run in kernel-mode (Ring 0) or in user-mode (Ring 3). The primary benefit of running a driver in user mode is improved stability, since a poorly written user mode device driver cannot crash the system by overwriting kernel memory. On the other hand, user\/kernel-mode transitions usually impose a considerable performance overhead, thereby prohibiting user mode-drivers for low latency and high throughput requirements. Kernel space can be accessed by user module only through the use of system calls. End user programs like the UNIX shell or other GUI based applications are part of the user space. These applications interact with hardware through kernel supported functions.","CPU  can include (not shown) one or more of a control processor, field programmable gate array (FPGA), application specific integrated circuit (ASIC), or digital signal processor (DSP). CPU , for example, executes the control logic, including the operating system , KMD , SWS , and applications , that control the operation of computing system . In this illustrative embodiment, CPU , according to one embodiment, initiates and controls the execution of applications  by, for example, distributing the processing associated with that application across the CPU  and other processing resources, such as the APD .","APD , among other things, executes commands and programs for selected functions, such as graphics operations and other operations that may be, for example, particularly suited for parallel processing. In general, APD  can be frequently used for executing graphics pipeline operations, such as pixel operations, geometric computations, and rendering an image to a display. In various embodiments of the present invention, APD  can also execute compute processing operations (e.g., those operations unrelated to graphics such as, for example, video operations, physics simulations, computational fluid dynamics, etc.), based on commands or instructions received from CPU .","For example, commands can be considered as special instructions that are not typically defined in the instruction set architecture (ISA). A command may be executed by a special processor such a dispatch processor, command processor, or network controller. On the other hand, instructions can be considered, for example, a single operation of a processor within a computer architecture. In one example, when using two sets of ISAs, some instructions are used to execute x86 programs and some instructions are used to execute kernels on an APD compute unit.","In an illustrative embodiment, CPU  transmits selected commands to APD . These selected commands can include graphics commands and other commands amenable to parallel execution. These selected commands, that can also include compute processing commands, can be executed substantially independently from CPU .","APD  can include its own compute units (not shown), such as, but not limited to, one or more SIMD processing cores. As referred to herein, a SIMD is a pipeline, or programming model, where a kernel is executed concurrently on multiple processing elements each with its own data and a shared program counter. All processing elements execute an identical set of instructions. The use of predication enables work-items to participate or not for each issued command.","In one example, each APD  compute unit can include one or more scalar and\/or vector floating-point units and\/or arithmetic and logic units (ALUs). The APD compute unit can also include special purpose processing units (not shown), such as inverse-square root units and sine\/cosine units. In one example, the APD compute units are referred to herein collectively as shader core .","Having one or more SIMDs, in general, makes APD  ideally suited for execution of data-parallel tasks such as those that are common in graphics processing.","Some graphics pipeline operations, such as pixel processing, and other parallel computation operations, can require that the same command stream or compute kernel be performed on streams or collections of input data elements. Respective instantiations of the same compute kernel can be executed concurrently on multiple compute units in shader core  in order to process such data elements in parallel. As referred to herein, for example, a compute kernel is a function containing instructions declared in a program and executed on an APD compute unit. This function is also referred to as a kernel, a shader, a shader program, or a program.","In one illustrative embodiment, each compute unit (e.g., SIMD processing core) can execute a respective instantiation of a particular work-item to process incoming data. A work-item is one of a collection is of parallel executions of a kernel invoked on a device by a command. A work-item can be executed by one or more processing elements as part of a work-group executing on a compute unit.","A work-item is distinguished from other executions within the collection by its global ID and local ID. In one example, a subset of work-items in a workgroup that execute simultaneously together on a SIMD can be referred to as a wavefront . The width of a wavefront is a characteristic of the hardware of the compute unit (e.g., SIMD processing core). As referred to herein, a workgroup is a collection of related work-items that execute on a single compute unit. The work-items in the group execute the same kernel and share local memory and work-group barriers.","In the exemplary embodiment, all wavefronts from a workgroup are processed on the same SIMD processing core. Instructions across a wavefront are issued one at a time, and when all work-items follow the same control flow, each work-item executes the same program. Wavefronts can also be referred to as warps, vectors, or threads.","An execution mask and work-item predication are used to enable divergent control flow within a wavefront, where each individual work-item can actually take a unique code path through the kernel. Partially populated wavefronts can be processed when a full set of work-items is not available at wavefront start time. For example, shader core  can simultaneously execute a predetermined number of wavefronts , each wavefront  comprising a multiple work-items.","Within the system , APD  includes its own memory, such as graphics memory  (although memory  is not limited to graphics only use). Graphics memory  provides a local memory for use during computations in APD . Individual compute units (not shown) within shader core  can have their own local data store (not shown). In one embodiment, APD  includes access to local graphics memory , as well as access to the memory . In another embodiment, APD  can include access to dynamic random access memory (DRAM) or other such memories (not shown) attached directly to the APD  and separately from memory .","In the example shown, APD  also includes one or \u201cn\u201d number of command processors (CPs) . CP  controls the processing within APD . CP  also retrieves commands to be executed from command buffers  in memory  and coordinates the execution of those commands on APD .","In one example, CPU  inputs commands based on applications  into appropriate command buffers . As referred to herein, an application is the combination of the program parts that will execute on the compute units within the CPU and APD.","A plurality of command buffers  can be maintained with each process scheduled for execution on the APD .","CP  can be implemented in hardware, firmware, or software, or a combination thereof. In one embodiment, CP  is implemented as a reduced instruction set computer (RISC) engine with microcode for implementing logic including scheduling logic.","APD  also includes one or \u201cn\u201d number of dispatch controllers (DCs) . In the present application, the term dispatch refers to a command executed by a dispatch controller that uses the context state to initiate the start of the execution of a kernel for a set of work groups on a set of compute units. DC  includes logic to initiate workgroups in the shader core . In some embodiments, DC  can be implemented as part of CP .","System  also includes a hardware scheduler (HWS)  for selecting a process from a run list  for execution on APD . HWS  can select processes from run list  using round robin methodology, priority level, or based on other scheduling policies. The priority level, for example, can be dynamically determined. HWS  can also include functionality to manage the run list , for example, by adding new processes and by deleting existing processes from run-list . The run list management logic of HWS  is sometimes referred to as a run list controller (RLC).","In various embodiments of the present invention, when HWS  initiates the execution of a process from run list , CP  begins retrieving and executing commands from the corresponding command buffer . In some instances, CP  can generate one or more commands to be executed within APD , which correspond with commands received from CPU . In one embodiment, CP , together with other components, implements a prioritizing and scheduling of commands on APD  in a manner that improves or maximizes the utilization of the resources of APD  resources and\/or system .","APD  can have access to, or may include, an interrupt generator . Interrupt generator  can be configured by APD  to interrupt the operating system  when interrupt events, such as page faults, are encountered by APD . For example, APD  can rely on interrupt generation logic within IOMMU  to create the page fault interrupts noted above.","APD  can also include preemption and context switch logic  for preempting a process currently running within shader core . Context switch logic , for example, includes functionality to stop the process and save its current state (e.g., shader core  state, and CP  state).","As referred to herein, the term state can include an initial state, an intermediate state, and\/or a final state. An initial state is a starting point for a machine to process an input data set according to a programming order to create an output set of data. There is an intermediate state, for example, that needs to be stored at several points to enable the processing to make forward progress. This intermediate state is sometimes stored to allow a continuation of execution at a later time when interrupted by some other process. There is also final state that can be recorded as part of the output data set","Preemption and context switch logic  can also include logic to context switch another process into the APD . The functionality to context switch another process into running on the APD  may include instantiating the process, for example, through the CP  and DC  to run on APD , restoring any previously saved state for that process, and starting its execution.","Memory  can include non-persistent memory such as DRAM (not shown). Memory  can store, e.g., processing logic instructions, constant values, and variable values during execution of portions of applications or other processing logic. For example, in one embodiment, parts of control logic to perform one or more operations on CPU  can reside within memory  during execution of the respective portions of the operation by CPU .","During execution, respective applications, operating system functions, processing logic commands, and system software can reside in memory . Control logic commands fundamental to operating system  will generally reside in memory  during execution. Other software commands, including, for example, kernel mode driver  and software scheduler  can also reside in memory  during execution of system .","In this example, memory  includes command buffers  that are used by CPU  to send commands to APD . Memory  also contains process lists and process information (e.g., active list  and process control blocks ). These lists, as well as the information, are used by scheduling software executing on CPU  to communicate scheduling information to APD  and\/or related scheduling hardware. Access to memory  can be managed by a memory controller , which is coupled to memory . For example, requests from CPU , or from other devices, for reading from or for writing to memory  are managed by the memory controller .","Referring back to other aspects of system , IOMMU  is a multi-context memory management unit.","As used herein, context can be considered the environment within which the kernels execute and the domain in which synchronization and memory management is defined. The context includes a set of devices, the memory accessible to those devices, the corresponding memory properties and one or more command-queues used to schedule execution of a kernel(s) or operations on memory objects.","Referring back to the example shown in , IOMMU  includes logic to perform virtual to physical address translation for memory page access for devices including APD . IOMMU  may also include logic to generate interrupts, for example, when a page access by a device such as APD  results in a page fault. IOMMU  may also include, or have access to, a translation lookaside buffer (TLB) . TLB , as an example, can be implemented in a content addressable memory (CAM) to accelerate translation of logical (i.e., virtual) memory addresses to physical memory addresses for requests made by APD  for data in memory .","In the example shown, communication infrastructure  interconnects the components of system  as needed. Communication infrastructure  can include (not shown) one or more of a peripheral component interconnect (PCI) bus, extended PCI (PCI-E) bus, advanced microcontroller bus architecture (AMBA) bus, advanced graphics port (AGP), or other such communication infrastructure. Communications infrastructure  can also include an Ethernet, or similar network, or any suitable physical communications infrastructure that satisfies an application's data transfer rate requirements. Communication infrastructure  includes the functionality to interconnect components including components of computing system .","In this example, operating system  includes functionality to manage the hardware components of system  and to provide common services. In various embodiments, operating system  can execute on CPU  and provide common services. These common services can include, for example, scheduling applications for execution within CPU , fault management, interrupt service, as well as processing the input and output of other applications.","In some embodiments, based on interrupts generated by an interrupt controller, such as interrupt controller , operating system  invokes an appropriate interrupt handling routine. For example, upon detecting a page fault interrupt, operating system  may invoke an interrupt handler to initiate loading of the relevant page into memory  and to update corresponding page tables.","Operating system  may also include functionality to protect system  by ensuring that access to hardware components is mediated through operating system managed kernel functionality. In effect, operating system  ensures that applications, such as applications , run on CPU  in user space. Operating system  also ensures that applications  invoke kernel functionality provided by the operating system to access hardware and\/or input\/output functionality.","By way of example, applications  include various programs or commands to perform user computations that are also executed on CPU . CPU  can seamlessly send selected commands for processing on the APD . In one example, KMD  implements an application program interface (API) through which CPU , or applications executing on CPU  or other logic, can invoke APD  functionality. For example, KMD  can enqueue commands from CPU  to command buffers  from which APD  will subsequently retrieve the commands. Additionally, KMD  can, together with SWS , perform scheduling of processes to be executed on APD . SWS , for example, can include logic to maintain a prioritized list of processes to be executed on the APD.","In other embodiments of the present invention, applications executing on CPU  can entirely bypass KMD  when enqueuing commands.","In some embodiments, SWS  maintains an active list  in memory  of processes to be executed on APD . SWS  also selects a subset of the processes in active list  to be managed by HWS  in the hardware. Information relevant for running each process on APD  is communicated from CPU  to APD  through process control blocks (PCB) .","Processing logic for applications, operating system, and system software can include commands specified in a programming language such as C and\/or in a hardware description language such as Verilog, RTL, or netlists, to enable ultimately configuring a manufacturing process through the generation of maskworks\/photomasks to generate a hardware device embodying aspects of the invention described herein.","A person of skill in the art will understand, upon reading this description, that computing system  can include more or fewer components than shown in . For example, computing system  can include one or more input interfaces, non-volatile storage, one or more output interfaces, network interfaces, and one or more displays or display interfaces.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 1B","FIG. 1A","FIG. 1B","FIG. 1A","FIG. 1B"],"b":["104","124","124","124","124","124","125","0","124","162","1","2","124","124","160","166","128"],"i":["a","b","c","a","b ","c"]},"In , graphics pipeline  can include a set of blocks, referred to herein as ordered pipeline . As an example, ordered pipeline  includes a vertex group translator (VGT) , a primitive assembler (PA) , a scan converter (SC) , and a shader-export, render-back unit (SX\/RB) . Each block within ordered pipeline  may represent a different stage of graphics processing within graphics pipeline . Ordered pipeline  can be a fixed function hardware pipeline. Other implementations can be used that would also be within the spirit and scope of the present invention.","Although only a small amount of data may be provided as an input to graphics pipeline , this data will be amplified by the time it is provided as an output from graphics pipeline . Graphics pipeline  also includes DC  for counting through ranges within work-item groups received from CP pipeline . Compute work submitted through DC  is semi-synchronous with graphics pipeline .","Compute pipeline  includes shader DCs  and . Each of the DCs  and  is configured to count through compute ranges within work groups received from CP pipelines and ","The DCs , , and , illustrated in , receive the input ranges, break the ranges down into workgroups, and then forward the workgroups to shader core .","Since graphics pipeline  is generally a fixed function pipeline, it is difficult to save and restore its state, and as a result, the graphics pipeline  is difficult to context switch. Therefore, in most cases context switching, as discussed herein, does not pertain to context switching among graphics processes. An exception is for graphics work in shader core , which can be context switched.","After the processing of work within graphics pipeline  has been completed, the completed work is processed through a render back unit , which does depth and color calculations, and then writes its final results to memory .","Shader core  can be shared by graphics pipeline  and compute pipeline . Shader core  can be a general processor configured to run wavefronts. In one example, all work within compute pipeline  is processed within shader core . Shader core  runs programmable software code and includes various forms of data, such as state data.","A disruption in the QoS occurs when all work-items are unable to access APD resources. Embodiments of the present invention facilitate efficiently and simultaneously launching two or more tasks to resources within APD , enabling all work-items to access various APD resources. In one embodiment, an APD input scheme enables all work-items to have access to the APD's resources in parallel by managing the APD's workload. When the APD's workload approaches maximum levels, (e.g., during attainment of maximum I\/O rates), this APD input scheme assists in that otherwise unused processing resources can be simultaneously utilized in many scenarios. A serial input stream, for example, can be abstracted to appear as parallel simultaneous inputs to the APD.","By way of example, each of the CPs  can have one or more tasks to submit as inputs to other resources within APD , where each task can represent multiple wavefronts. After a first task is submitted as an input, this task may be allowed to ramp up, over a period of time, to utilize all the APD resources necessary for completion of the task. By itself, this first task may or may not reach a maximum APD utilization threshold. However, as other tasks are enqueued and are waiting to be processed within the APD , allocation of the APD resources can be managed to ensure that all of the tasks can simultaneously use the APD , each achieving a percentage of the APD's maximum utilization. This simultaneous use of the APD  by multiple tasks, and their combined utilization percentages, ensures that a predetermined maximum APD utilization threshold is achieved.",{"@attributes":{"id":"p-0088","num":"0087"},"figref":["FIG. 2","FIG. 1B","FIG. 2","FIG. 2"],"b":["104","104","204","122","204","122","204","122","204","162","204","160","162","122"]},"Shader resource arbiter  can be implemented using hardware; software, firmware, or any combination thereof. For example, shader resource arbiter  can be implemented as programmable hardware.","As discussed above, compute pipeline  includes DCs  and , as illustrated in , which receive the input thread groups. The thread groups are broken down into wavefronts including a predetermined number of threads. Each wavefront thread may comprise a shader program, such as a vertex shader. The shader program is typically associated with a set of context state data. The shader program is forwarded to shader core  for shader core program execution.","During operation, each shader core program has access to a number of general purpose registers (GPRs) (not shown), which are dynamically allocated in shader core  before running the program. When a wavefront is ready to be processed, shader resource arbiter  allocates the GPRs and thread space. Shader core  is notified that a new wavefront is ready for execution and runs the shader core program on the wavefront.","As referenced in , APD  includes compute units, such as one or more SIMDs. In , for example, shader core  includes SIMDs A-N for executing a respective instantiation of a particular work group or to process incoming data. SIMDs A-N are respectively coupled to local data stores (LDSs) A-N. LDSs A-N provide a private memory region accessible only by their respective SIMDs and is private to a work group. LDSs A-N store the shader program context state data.","It would be apparent to one of skill in the art that aspects of the present invention, as described below, can be implemented in many different embodiments of software, hardware, firmware, and\/or the entities illustrated in the figures. Any actual software code with the specialized control of hardware to implement the present invention is not limiting of the present invention. Thus, the operational behavior of the present invention will be described with the understanding that modifications and variations of the embodiments are possible, given the level of detail presented herein.","Additionally, and as will be apparent to one of skill in the art, the simulation, synthesis and\/or manufacture of the various embodiments of this invention may be accomplished, in part, through the use of computer readable code (as noted above), including general programming languages (such as C or C++), hardware description languages (HDL) including Verilog HDL, VHDL, Altera HDL (AHDL) and so on, or other available programming and\/or schematic capture tools (such as circuit capture tools). This computer readable code can be disposed in any known computer usable medium including semiconductor, magnetic disk, optical disk (such as CD-ROM, DVD-ROM) and as a computer data signal embodied in a computer usable (e.g., readable) transmission medium (such as a carrier wave or any other medium including digital, optical, or analog-based medium).","As such, the code can be transmitted over communication networks including the Internet and intranets. It is understood that the functions accomplished and\/or structure provided by the systems and techniques described above can be represented in a core (such as APD core and\/or a CPU core or other processing cores) that is embodied in program code and may be transformed to hardware as part of the production of integrated circuits.",{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIG. 3","b":["300","302","304","302","302","302","306","308","306","304","308"]},"The approach of data flow model  transitions between user mode and kernel mode with every submission of commands to the ring buffer .  illustrates an additional data flow model  applying the concepts of data flow model  of  to an exemplary Windows environment, although one skilled in the relevant arts will recognize the applicability of data flow model  to other operating environments.","As is shown in data flow model , an APD context for an application, such as user mode application , is created at step  and memory allocated at step  using kernel mode driver functionality (including, for example, allocation of command buffer ). User mode application  fills command buffer  with instructions at step , which is then forwarded to a Windows Display Driver Model (\u201cWDDM\u201d, in an exemplary Windows environment) component at step . At step , a kernel mode driver can add a context for application  to a context queue, indicating that command buffer  is ready for processing. Kernel mode software is then able to submit commands from command buffer  to the APD engine ring buffer  at step .","This approach funnels an application's APD instructions through the kernel mode driver (e.g., DXGKRNL in a Windows environment). There are a number of disadvantages to this approach, primarily stemming from the original design focus of the APD. In this approach, the APD is not intended to handle general processing instructions from an application outside of a graphics context. Everything must be packaged through the standard graphics interfaces. The necessary transitions between user mode and kernel mode when submitting commands are expensive, requiring hardware privilege level transitions. Additionally, writing to the single APD engine ring buffer  requires a lock, which may block other APD-bound applications.","An additional challenge faced by this legacy approach is that operations being added to the APD ring buffer must be tested for references to virtual memory space. Specifically, the APD is only permitted to operate on APD memory and pinned system memory. Otherwise, data referenced by an operation must be brought in to either APD memory or pinned system memory, such as by copying the referenced data to main memory and pinning it.","Prior to submission of the commands to the APD engine ring buffer , steps  are performed to ensure that the APD can access memory referenced by the commands being written to the APD engine ring buffer . This includes traversing the command buffer for all references to virtual memory and patching these references with physical memory address references. If no physical memory reference currently exists, the data referenced by virtual memory must be paged in to pinned system memory of APD memory so that it can be used by the APD.","The need to assure availability of referenced memory for all operations prior to posting the operation to the APD ring buffer can become expensive. The patching check must be performed on all operations whether or not referenced data is already present in pinned system memory or APD memory. As a result, submitting commands to the APD ring buffer entails significant overhead.","In order to overcome or reduce the performance issues associated with the data flow models illustrated in , it is beneficial to embed functionality that allows the APD to be treated as a first-class citizen. In other words, to be treated as a computing resource on a par (or closer to par) with the CPU. The concept of allowing the APD and APD-accessible memory space to be treated in a similar manner to the CPU can be achieved in a number of different ways. However, in various embodiments (e.g., with full support from the operating system and native hardware support), it is possible to avoid kernel mode transitions beyond initialization of an application.",{"@attributes":{"id":"p-0104","num":"0103"},"figref":"FIG. 5","b":["500","502","504","500","506"]},"System stack  further includes APD scheduler and CPU scheduler . While CPU scheduler is analogous to traditional schedulers present in existing systems for scheduling CPU-bound work, APD scheduler handles scheduling of APD-bound work. The operation of APD scheduler is described in further detail below.","System stack  additionally includes APD memory management component and CPU memory management component . While CPU memory management component is analogous to traditional memory managers present in existing operating systems for allocating memory to CPU-bound applications, APD memory management component handles allocation of memory objects for applications with APD-bound commands.","While  illustrates an exemplary embodiment where cooperation is obtained from the operating system and underlying hardware, one skilled in the relevant arts will appreciate that other mechanisms may be employed to avoid the performance issues associated with the data flow models of .",{"@attributes":{"id":"p-0108","num":"0107"},"figref":"FIG. 6","b":["600","600","600"]},"By way of the IOMMUv2 driver  of  (or other kernel mode driver or kernel mode software component), a user mode application can create its own user mode accessible work queue (e.g., a ring buffer) at step . During initialization, and by way of non-limiting example, the user mode application calls a function in runtime  to allocate a work queue. This work queue may be, by way of non-limiting example, a ring buffer or other FIFO queue, although one skilled in the relevant arts will appreciate that other techniques for command buffering may be used. The application further calls a kernel mode function in the kernel mode driver, which registers the ring buffer at step  for access by the APD.","This same kernel mode driver also accepts a resource allocation request at step  from the application and allocates resources, such as APD memory or pinned system memory at step , in accordance with a further embodiment of the present invention. Memory may be allocated using virtual memory addresses, which may correspond to data not presently in the physical memory space (as is the case prior to initialization).","After initialization, data flow model  illustrates the behavior of the user mode application during runtime. During application runtime, the application can fill a command buffer at step . The command buffer's contents can then be forwarded to the application's ring buffer at step , from which instructions are dispatched to the APD at step .","One skilled in the relevant arts will appreciate that the use of a command buffer, such as the command buffer at step , is optional, and commands may instead be forwarded directly to the ring buffer used at step . A command buffer may be employed, by way of non-limiting examples, in situations where writes to the ring buffer would be expensive operations (such as when the write operation blocks a unified ring buffer in the examples of ). However, in instances where each application has its own ring buffer allocated by the kernel mode driver, this operation may not have the same costs traditionally associated with it, and therefore performance cost savings can be realized by forgoing the command buffer. References herein to the command buffer therefore contemplate scenarios where commands being placed in the command buffer are instead forwarded directly to the application's ring buffer.","At runtime, an illustrative embodiment relies on several components in order to handle instruction processing by the APD.  illustrates a system overview  of an exemplary architecture at runtime, in accordance with an embodiment of the present invention. As previously noted, each application  is allocated its own ring buffer . This ring buffer  may be written to by commands stored in one or more command buffers . However, as previously discussed, the use of command buffers  is optional, and commands may instead be written directly to the ring buffer .","Additionally, the kernel mode driver allocates and maintains several kernel space memory objects. These kernel space memory objects include compute process control blocks and run list entries , each allocated to a corresponding application . A master compute process list , referencing outstanding instances of the compute process control blocks , is used to track the list of registered applications. One skilled in the relevant arts will appreciate that other methods of maintaining information regarding individual applications  may be used, and this particular methodology is provided by way of example, and not limitation. The kernel space memory objects also include context switch blocks . These blocks of memory are used to save the current state (i.e., context) of the APD whenever the corresponding application is switched out in a multitasking environment. Application context switching is further discussed below with regard to operation of the scheduler.","As previously noted, one of the benefits of the architecture described in system overview  is the ability to avoid kernel mode transitions when sending work to the APD from a user mode application. When an application  registers with the kernel mode driver, it is assigned a corresponding compute process control block . The APD accesses the compute process control blocks  to obtain privilege state information related to an associated process context, which includes the location of ring buffer  of application . As a result, the APD can access commands from ring buffer  without the need for a costly kernel mode transition.","Compute process control blocks  may contain additional information useful to process scheduling. For example, a priority level (e.g., low, medium, high, realtime) for the corresponding application  may be kept in a compute process control block , which can be utilized by the scheduler to allocate APD processing time to the application , as will be described in further detail below. Priority information may also include a timer reset value, indicating an amount of APD processing time (such as a number of clock cycles or individual instructions) to process during a next scheduling window. Compute process control blocks  also contain a reference to the corresponding context switch block  that the APD can utilize when switching application contexts. The APD therefore utilizes compute process control blocks  as a representation of the individual applications  which it services.","In accordance with an embodiment of the present invention, ring buffer  is guaranteed to be resident in memory when accessed by the APD and cannot be paged out. Kernel mode driver compute interfaces are used to allocate user space resident command buffers, which are accessible directly by APD hardware, allowing the compute work load dispatch and completion process to bypass any kernel mode transitions. With the support of the IOMMUv2 and APD hardware, page faulting is supported for the user space command (and data) buffers , which allows these buffers to avoid the overhead of memory pinning, in accordance with an additional embodiment of the present invention.","In contrast to the data flow models of , where kernel mode software must traverse commands submitted by a user mode application to patch virtual memory references, thereby ensuring all references are to resident pinned system or APD memory, the APD is able to access ring buffer  directly prior to any patching taking place. Therefore, the APD must be able to identify and handle page faults by one of various mechanisms.","For example, when an instruction referencing virtual memory is handled by the APD, a determination is made as to whether the virtual memory address corresponds to a physical memory address (e.g., using a page table). If not, the APD can trigger a page fault to the system's CPU, allowing the CPU to retrieve data from the corresponding virtual memory address into pinned system or APD memory. If the APD's capabilities permit, the APD can switch to another application context while blocking on the page fault, or can instead stall while waiting for the page fault to be serviced.","In accordance with a further embodiment of the present invention, the APD can probe an instruction prior to servicing to determine whether a page fault is necessary, and if so, will trigger the page fault mechanism interrupt of the CPU.","From the perspective of a user mode application , the aforementioned functionality allows direct interaction with the APD in a similar manner to the system's CPU. This characteristic of certain embodiments of the present invention is said to establish the APD as a \u201cfirst-class citizen\u201d, relative to the CPU.",{"@attributes":{"id":"p-0122","num":"0121"},"figref":["FIG. 8","FIG. 7"],"b":["702","802","804","804"]},"By way of non-limiting example, initialization of the application at step  includes the creation of a compute process control block, such as compute process control block  of . One skilled in the relevant arts will appreciate that other mechanisms may be used by which a representation of the application, accessible to the APD, can be maintained and updated.","Steps  and  illustrate initialization processes to applications exploiting aspects of the present invention. At step , a ring buffer (such as ring buffer  of , or other form of command buffer (e.g., FIFO queue)) is allocated to the application, and memory resources are allocated at step . The method then ends at step .","As previously noted, allocation of the ring buffer  and memory resources at steps  and , respectively, is handled through interaction with a kernel mode driver or other kernel mode software (e.g., an application allocates ring buffer  and registers it with the kernel mode software as in step  of ). The ring buffer  and memory resources are accessible to the application and the APD, without the need to block other applications or transition to kernel mode to utilize the resources.",{"@attributes":{"id":"p-0126","num":"0125"},"figref":["FIG. 9","FIG. 7","FIG. 7"],"b":["900","902","904","706","704","704","906"]},"At step , the commands in ring buffer  are ready for dispatch. The method ends at step . As previously noted, the APD hardware has direct access to the commands stored in ring buffer , and can begin processing commands from an appropriate application's ring buffer  as required, such as when instructed to do so by a scheduling algorithm.","By allocating a ring buffer to each application, such as by step  of , it is possible to handle scheduling in a variety of different ways. In particular, scheduling in the data flow models illustrated in  is accomplished by pushing data into a unified ring buffer for an APD, from which the APD hardware would pull operations in whatever order they were presented. In order to signal completion of a particular packet of data placed in the ring, a technique is used whereby the last operation in an operation packet in the unified ring buffer increments a timestamp. However, this operation adds latency and requires inefficiencies introduced by execution of a hardware interrupt. This approach also lacks resolution when determining precisely how many operations have been processed in a particular timeframe, as completion is determined for the packet of operations as a whole.","In contrast, exemplary embodiments of the present invention allow a scheduler or other mechanism to select a particular application context to execute next (such as an application identified by a compute process control block  of ), providing instructions from the selected application's  ring buffer  to the APD for execution. Additionally, a work packet in the application's ring buffer  can itself signal completion entirely within user mode, providing a lower cost and resolution configurable solution to completion signaling.","One skilled in the relevant arts will appreciate that a number of approaches to scheduling can be applied to the embodiments disclosed herein, and the approaches described herein are provided by way of example, and not limitation.  is a flowchart  illustrating steps by which a scheduler, such as APD scheduler of , schedules processing of APD commands, in accordance with an embodiment of the present invention. The method begins at step  and proceeds to step  where a compute process control block  is allocated to an application  (such as during application initialization). At step , a ring buffer  or other data structure for queuing commands from application  is allocated to the application .","At step , the scheduler determines the next application to be scheduled. This can be accomplished, by way of non-limiting example, through selection of a compute process control block or runlist  corresponding to a next application to be scheduled. Selection of the next compute process control block  may be handled by a number of scheduling algorithms, such as round-robin scheduling. Use of other scheduling algorithms will be apparent to those skilled in the relevant ails.","In accordance with an additional embodiment of the present invention, an application  is able to notify the APD that it is eligible to be selected for execution. This is handled, by way of non-limiting example, through the use of a \u201cdoorbell\u201d signal by the application whenever commands are added to the ring buffer . If the APD has not been informed of waiting commands through the use of the \u201cdoorbell\u201d signal, it can skip to the next compute process control block  at step  which has signaled that commands are present in its ring buffer , or that the APD otherwise knows to have ready APD commands.","Once the scheduler has identified the next application  to be executed by its corresponding compute process control block , the APD obtains the location of the application's ring buffer  from the compute process control block . The APD can then service commands at step  directly from the ring buffer .","Application  is able to place only APD-bound commands in ring buffer , while remaining free to separately execute CPU-bound commands. This means that the CPU and APD can operate on instructions at different speeds and frequencies, without having to wait for completion by the other (except in the event of dependencies). While the APD is servicing commands at step , the CPU can continue operation on its own commands.","The APD continues to service a number of commands at step , and then proceeds to step  where the scheduler may schedule a different application for APD time, in which case the method proceeds again to step . If no further applications remain to be scheduled, the method ends at step  and the APD remains idle.","The number of commands serviced by the APD at step  prior to scheduling of a subsequent application may be controlled by a number of factors. One skilled in the relevant arts will appreciate that these factors are exemplary, and other techniques may be employed instead to control the amount of APD time allocated to an application. For example, if the application  terminates, or if the ring buffer  is emptied by the APD (i.e., no further APD-bound commands queued for execution), then the scheduler can immediately schedule the next application for execution.","Additionally, the scheduler can switch context to another application (steps  followed by ) prior to servicing all commands in the ring buffer  to allow APD multitasking. This can be handled through the use of a timer, which triggers the context switch when it expires (e.g., after a number of clock cycles, or after a certain amount of \u201cwall-time\u201d has elapsed). This timer may optionally be set through a value assigned to an application  and stored in its compute process control block . Additionally, a priority value in compute process control block  may assist the scheduler in determining how many commands to service from the ring buffer  at step  prior to a context switch.","When a context switch occurs, the state of execution of the current application's APD-bound commands from ring buffer  should be saved. This allows the APD to continue processing the commands from ring buffer  using the same execution state, including any register values the commands may rely on.  is a flowchart  illustrating steps by which the state of execution is preserved in a context switch, in accordance with an embodiment of the present invention.","The method begins at step  and proceeds to step , where the APD state (e.g., register values, next instruction, etc.) of an application  to be context-switched-out in favor of another is stored in the application's  corresponding context switch block . At step , the scheduler identifies the next application  to be scheduled (via its compute process control block ), along with its corresponding ring buffer  and context switch block  referenced by the compute process control block . Then at step , the APD restores its state using the state saved in context switch block  for the next application . The method then ends at . This allows the application  that has been context-switched-in to continue APD execution where it left off.","While the foregoing application describes hardware-bound scheduling, it is also possible to combine hardware- and software-bound scheduling in accordance with a further embodiment of the present invention. This technique allows a software-based scheduler to predict (through the use of heuristics by way of non-limiting example) which application should be permitted APD time next, and register the application to be scheduled next by the APD.",{"@attributes":{"id":"p-0141","num":"0140"},"figref":"FIG. 12","b":["1200","1202","1204","702","1206","710","702","702","1210"]},"In accordance with an additional embodiment of the present invention, when such changes are made to the set of runlist entries  known by the APD, the entire set of runlist entries  is resubmitted to allow the hardware scheduler to reevaluate the scheduling order. The changes that trigger this behavior include adding another runlist entry, deleting a runlist entry, or editing one or more of the runlist entries (e.g., in order to change the priority of an application context).","Various aspects of the present invention can be implemented by software, firmware, hardware, or a combination thereof. For example, the methods illustrated by flowcharts  of ,  of ,  of ,  of ,  of , and  of  can be implemented in unified computing system  of . Various embodiments of the invention are described in terms of this example unified computing system . It would be apparent to a person skilled in the relevant art how to implement the invention using other computer systems and\/or computer architectures.","In this document, the terms \u201ccomputer program medium\u201d and \u201ccomputer-usable medium\u201d are used to generally refer to media such as a removable storage unit or a hard disk drive. Computer program medium and computer-usable medium can also refer to memories, such as system memory  and graphics memory , which can be semiconductor memories (e.g., DRAMs, etc.). These computer program products are means for providing software to unified computing system .","The invention is also directed to computer program products comprising software stored on any computer-usable medium. Such software, when executed in one or more data processing devices, causes a data processing device(s) to operate as described herein or, as noted above, allows for the synthesis and\/or manufacture of computing devices (e.g., ASICs, or processors) to perform embodiments of the present invention described herein. Embodiments of the invention employ any computer-usable or -readable medium, known now or in the future. Examples of computer-usable mediums include, but are not limited to, primary storage devices (e.g., any type of random access memory), secondary storage devices (e.g., hard drives, floppy disks, CD ROMS, ZIP disks, tapes, magnetic storage devices, optical storage devices, MEMS, nanotechnological storage devices, etc.), and communication mediums (e.g., wired and wireless communications networks, local area networks, wide area networks, intranets, etc.).","While various embodiments of the present invention have been described above, it should be understood that they have been presented by way of example only, and not limitation. It will be understood by those skilled in the relevant art that various changes in form and details can be made therein without departing from the spirit and scope of the invention as defined in the appended claims. It should be understood that the invention is not limited to these examples. The invention is applicable to any elements operating as described herein. Accordingly, the breadth and scope of the present invention should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings, which are incorporated herein and form a part of the specification, illustrate embodiments of the present invention and, together with the description, further serve to explain the principles of the invention and to enable a person skilled in the relevant art to make and use the invention.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 1B","FIG. 1A"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 2","FIG. 1B"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
