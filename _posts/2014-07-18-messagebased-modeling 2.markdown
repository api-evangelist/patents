---
title: Message-based modeling
abstract: A system and method may generate executable models having message sending objects and message receiving objects. A message may include a fixed data payload, and the message may persist for only a determined time interval of a total execution or simulation time of model. Message queues may be established for the messages, and the queues may have attributes. The model may include a state-based portion having states and transitions. States may be configured to generate and send messages, and to receive and process messages. In addition, transitions may be guarded by particular messages. The system and method also may generate standalone code, such as source code, for the model. The standalone code may include code that establishes a message passing service to support the sending and receiving of messages.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09594608&OS=09594608&RS=09594608
owner: The MathWorks, Inc.
number: 09594608
owner_city: Natick
owner_country: US
publication_date: 20140718
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BRIEF DESCRIPTION OF THE DRAWINGS","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS"],"p":["This application is a continuation-in-part (CIP) application of application Ser. No. 14\/163,147 filed Jan. 24, 2014 for MESSAGE-BASED MODELING, now U.S. Pat. No. 9,304,840, which is a continuation of application Ser. No. 13\/117,531 filed May 27, 2011 for MESSAGE-BASED MODELING, now U.S. Pat. No. 8,689,236, which application claims the benefit of U.S. Provisional Patent Application Ser. No. 61\/349,401, which was filed on May 28, 2010, by Alan Moore et al., for a MESSAGE BASED TRACES AND VERIFICATION, which applications are hereby incorporated by reference in their entireties.","The disclosure below refers to the accompanying drawings, of which:",{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIGS. 6A-6C"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIGS. 7A and 7B"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIGS. 9A"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 21"},"Overview","Exemplary embodiments of the disclosure generate executable models having objects configured to run in accordance with message-based execution semantics. A message may include a payload comprising one or more data elements that may not change during the execution of the model. In addition, a message may be generated at a particular point in the execution or simulation time of the model by a message sender object, and the message may persist for a determined time interval of the total model execution or simulation time.","A message-based modeling entity, which may be included within a modeling system, may support message-based functionality in the model. The system may include a library of pre-defined object types, such as graphical block types, configured to generate and send messages, and to receive and process messages. The library of message-based blocks may be organized as a class hierarchy. The modeling environment may include a graphical editor that provides a model canvas in which a user may construct and\/or edit a model. Message-based objects may be configured to have one or more message ports for sending and receiving messages. In response to the message ports of selected objects being interconnected, such as through message-based connections extending from source ports to destination ports, the system may establish message-based relationships among the interconnected objects.","The system may establish one or more message queues for storing messages. The message queues may have attributes, such as a length, a processing order, an overflow policy, and a priority. Message generated during execution of the model may be logged and may be routed to other message queues and\/or message-based receiver objects.","The system may also include a message-based execution engine that controls the execution of the model's message-based objects. More specifically, during execution, a message sender object may generate a message at a particular point in the execution time of the model. The message-based execution engine may maintain the message for a determined portion or time interval of the total execution time of the model. In addition, the execution engine may send the message to one or more message-based receiver objects, which may or may not trigger their execution, and the execution engine may control the processing of the message by the one or more message-based receiver blocks.","In an embodiment, the modeling system may include entities or modules that support other execution domains, such as a time-based and state-based execution domains. In addition, the message-based modeling entity may cooperate with such a time-based and\/or state-based execution entities or modules to implement hybrid execution models.","The time-based entity or module may include a library of time-based objects or blocks, and selected time-based objects or blocks may be added to the model. A time-based block describes a dynamic system of equations that defines time-based relationships between signals and state variables. Signals represent quantities that change over time, and may have values at all points in time. The relationships between signals and state variables may be defined by the set of equations represented by the time-based blocks. Time-based blocks may include signal ports that may be interconnected with signal-based connections. The source of a signal corresponds to the block that writes to the signal during the evaluation of the block's equations, and the destination of the signal is the block that reads the signal during the evaluation of the destination block's equations.","The state-based entity or module may include a library of state-based objects, such as states, sub-states, transitions, junctions, etc. The state-based objects may be configured to generate and\/or receive messages. For example, programming syntaxes, such as a textual programming syntax, may be defined for generating and\/or evaluating messages by state-based objects. In addition, state transitions may be guarded by messages. For example, the programming syntaxes may support the specification of particular messages to guard transitions or other state-based objects.","The time-based execution engine executes the time-based blocks in the diagram by evaluating the relationships between signals and state variables over time beginning at a start time and continuing to a stop time. Each evaluation of the relationships may be referred to as a time step.","As mentioned, the message-based system and the time-based and\/or state-based execution engines may cooperate to implement a hybrid environment. In particular, the time-based execution engine may organize time-based and\/or state-based blocks or objects into a scheduled or sorted order, which refers to the order in which the blocks' operations or methods (e.g., execution methods), are invoked. The time-based and\/or state-based blocks or objects may then be executed according to the scheduled order.","The message-based system may also include a verification engine. The verification engine may support a library containing one or more verification blocks. Instances of the verification blocks may be added to the model to evaluate the operation of message-based blocks. The types of verification blocks may include an observer type, a message sink type, a generator type, and a scenario type. The observer block may be used to visualize a set of messages, referred to as a trace, generated by one or more selected message-based objects of the model. The set of messages of the trace may be ordered in time between a start time and an end time by the observer block. The observer block may be a floating block within the model, and it may be associated with a message-based connection. The message sink block may be directly connected to a message-based block, and may be used to visualize a trace generated by that message-based block. The generator block may be used to represent an external source of messages to the model. The generator block may be connected to one or more message-based blocks as a source, and configured to generate one or more messages or traces that may then be received and processed by the one or more message-based blocks to which the generator block is connected. The scenario block may be used to define valid and invalid traces. It may also or alternatively be used to define one or more constraints on one or more messages or traces. For example, temporal constraints may be defined on one or more messages, or between two or more messages. The scenario block may be associated with one or more message-based connections in the model whose messages may form a runtime trace to be evaluated. The scenario block may compare the defined valid and invalid traces, and the one or more constraints, to the runtime trace produced during execution of the model. The scenario block may be further configured to take one or more actions if one or more of the runtime traces is not equivalent to the defined valid traces, or the runtime traces are equivalent to the defined invalid traces. The scenario block may also take a specified action if the one or more constraints are not satisfied.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 1","b":["100","100","102","104","106","108","110","112","100","114","106","116","118","120","104","122","122","200"]},"The removable medium drive  may accept and read a computer readable medium , such as a CD, DVD, floppy disk, solid state drive, tape, flash memory or other medium. The removable medium drive  may also write to the computer readable medium .","Suitable computer systems include personal computers (PCs), workstations, laptops, tablets, palm computers and other portable computing devices, etc. Furthermore, exemplary processing elements include single or multi-core Central Processing Units (CPUs), Graphics Processing Units (GPUs), Field Programmable Gate Arrays (FPGAs), Application Specific Integrated Circuits (ASICs), etc. Nonetheless, those skilled in the art will understand that the system  of  is intended for illustrative purposes only, and that the present disclosure may be used with other computer systems, data processing systems or computational devices. The present disclosure may also be used in a networked, e.g., client-server, computer architecture, or a public and\/or private cloud computing arrangement.","Suitable operating systems  include the Windows series of operating systems from Microsoft Corp. of Redmond, Wash., the Linux operating system, the MAC OS\u00ae series of operating systems from Apple Inc. of Cupertino, Calif., and the UNIX\u00ae series of operating system, among others.","A user or developer, such as an engineer, scientist, programmer, etc., may utilize the keyboard , the mouse , and the display  to operate the high-level modeling environment , and construct or open one or more models of a system that is being designed. The model, which may have executable semantics, may represent a real-world dynamic system that is being modeled, simulated, and\/or analyzed by the user.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 2","b":["200","200","202","204","206","200","208","210","212","202","214","216","218","220","222","202","224","226","228"]},"In an implementation, high-level modeling environment  may receive inputs by a user as the user creates, edits, revises, and\/or opens one or more models, as indicated by arrow . The model execution engine  in cooperation with the modeling systems ,  and  may execute the model generating one or more results that may be presented to the user, as indicated by arrow . A model may include a plurality of portions each operating according to a different execution domains. For example, a first portion may operate according to message-based semantics, a second portion may operate according to time-based semantics, and a third portion may operate according to state-based semantics.","In an embodiment, a graphical model may be executable such that the model receives one or more inputs, processes those inputs, and produces one or more outputs.","In an embodiment, a suitable high-level modeling environment includes the MATLAB\u00ae technical computing environment from The MathWorks, Inc. of Natick, Mass. The high-level modeling environment may thus operate at a level that is even higher than other well-known programming languages, such as the C, C++, and C# programming languages. A suitable time-based graphical modeling system includes the SIMULINK\u00ae environment from The MathWorks, Inc. A suitable state-based modeling system includes the Stateflow charting tool from The MathWorks, Inc.","It should be understood that other modeling tools in addition to or in place of the time-based modeling system  and\/or the state-based modeling system  may be used in the environment . Other such modeling tools include dataflow systems, such as the LabVIEW programming system from National Instruments Corp. of Austin, Tex., and the Visual Engineering Environment (VEE) from Agilent Technologies, Inc. of Santa Clara, Calif., physical modeling systems, such as The Simscape product from The MathWorks, Inc., Unified Modeling Language (UML) systems, and Systems Modeling Language (SysML) systems, among others. In addition, a lower level programming language, such as the C, C++, and C# programming languages, among others, may also be used to create one or more models or model portions.","The propagation engine , message-based execution engine , verification engine , report generator , interface engine , message-based object constructor , and class packages ,  may each comprise registers and combinational logic configured and arranged to produce sequential logic circuits. In an embodiment, the propagation engine , message-based execution engine , verification engine , report generator , interface engine , message-based object constructor , and class packages ,  may be implemented through one or more software modules or libraries containing program instructions pertaining to the techniques described herein. The software modules may be stored on main memory  and\/or computer readable media, such as computer readable medium , and executable by one or more processing elements, such as processing element . Other computer readable media may also be used to store and execute these program instructions. In alternative embodiments, various combinations of software and hardware, including firmware, may be utilized to implement the present disclosure.","In an embodiment, the message-based components of a graphical model as well as the messages generated during execution of the model may be objects, and these objects may be defined by creating \u201cclasses\u201d which are not objects themselves, but which act as templates that instruct the constructor  how to construct an actual component and message object. A class may, for example, specify the number and type of data variables and the steps involved in the functions which manipulate the data. The object constructor  may use the corresponding class definition and additional information, such as arguments provided during object creation, to construct the object. Likewise, objects may be destroyed by a special function called a \u201cdestructor\u201d. Objects may be used by manipulating their data and invoking their functions.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 3","b":["300","300","300","302","304","306","308","302","310","312","314","316","306","318","320","308","322","324"]},"It should be understood that other, possibly more complex, class hierarchies may be provided. For example, additional base classes may be provided, and one or more of the subclasses may include subclasses of its own, and so on.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 4","b":["400","400","402","402","402","404","406","408","404","406","408","404","410","412","414","416","414","416","408","418"]},"While the message types are referred to as classes, in an embodiment, they do not have any methods. Instead, the specialization of the message classes may add new properties, i.e., data members, only.","In an embodiment, an instance of a message object may include one or more data elements.  is a schematic illustration of a data structure  representing the data elements of an instance of a message object. The data structure  may be organized into a plurality of fields and sub-fields each storing particular information. For example, the data structure  may include a message type field , a message identifier (ID) field , a valid flag , a time to live (TTL) field , and a payload field . The message type field  may store information that indicates the particular type of message, the message ID field  may store an identifier that uniquely identifies the message, the valid flag  may indicate whether the message is valid or invalid, the TTL field  may store information indicating how long the message should be maintained, and the payload field may store information associated with the message that was generated by the message source and that may be used by one or more message destinations.","It should be understood that the data structure may include additional or fewer fields. In addition, the payload field  may be organized into a plurality of sub-fields.","In another embodiment, message-based components and\/or messages may be instances generated from types, instead of being objects generated from classes. Those skilled in the art will understand that other implementations of message-based components and\/or messages may be utilized.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIGS. 6A-C","b":["200","602","200","200","106","116","118","120","200","202","204","206","120","202","204","206"]},"The environment  may also support the creation of a model programmatically.","In an embodiment, a user may select one or more types of message-based components from the library browser. In response, the constructor  may access the component class package , and create an object instance of the selected type, as indicated at block . The object instance may be stored in memory, such as main memory , and an icon, such as a block, may be added to the canvas, as indicated at block .","The user may configure one or more of the components of the model to generate and\/or receive a message, as indicated at block . For example, a user may open a properties or other page associated with a selected message-based component that has been added to the canvas. The property page may include fields or other data entry elements for receiving information, for example, from the user, specifying a message type that the component is to receive. In response, the object constructor , or another module, such as the model builder , may add an input port to the block as presented on the canvas. Similarly, the property page, or another property page, may include fields and data entry elements for receiving information that specifies a message type that a selected component is to send. In response, an output port may be added to the block as presented on the canvas. In this way, a user may add a plurality of blocks representing message-based components to the canvas, and provide these blocks with input and output ports for receiving and sending messages.","The user may define message-based relationships among the message-based components of the model as well as the other components, as indicated at block . For example, the user may define a message-based relationship graphically by drawing a message-based connection between the input and output ports of message-based blocks. More specifically, the user may configure a given message-based component to receive a particular message by drawing a connection from the source of the message, such as the output port of another message-based component, to the respective input port of the given message-based component. Likewise, the user may configure a selected message-based component to send a message by drawing a connection from the respective output port of the selected message-based component to the destination of the message. In response to the definition of message-based relationships, e.g., by the user, the message-based execution engine  may add the destination component to a list of listeners for the respective message, as indicated at block . Specifically, the execution engine  may create a list of listeners for each message for which a message-based relationship has been defined in the model. If a message-based relationship is removed, for example, by the user deleting a message-based connection between two message-based blocks, the execution engine  may remove the destination component from the list of listeners for that message.","In an embodiment, model components operating in domains other than the message-based execution domain, may be configured to send or receive messages. For example, a user may draw a message-based connection between a message-based block and a block operating in another domain, such as the time-based domain, the state-based domain, the dataflow domain, etc. Likewise, a user may draw a message-based connection from a block operating in another domain to a message-based block.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIGS. 7A and 7B","b":["700","700","700","702","704","706","708","702","710","712","704","714","716","718","720","722","724","706","726","728","708","730","732","734","736"]},"The Message Generator block  may be configured to have two input ports , , each associated with a respective type of message that the Message Generator block  is interested in receiving. The Message Generator block  also may be configured to have one output port  that is associated with a message type that the Message Generator block may send. The Message Buffer block  may be configured with an input port  and an output port , each associated with a respective message type. The Message Receive block  may be configured with an input port  and two output ports , , each associated with a respective message type. In addition, the state-based portion  may be configured with a first input port that is associated with a type of message, and a second input port that is associated with a signal. The state-based portion  may be further configured with a first output port that is associated with a type of message, and a second output port that is associated with a signal.","In an embodiment, the data type of a message payload may specify the type of message.","Message-based relationships may be established among the time-based portions , , the state-based portion , and the message-based portion . For example, a user may connect various input and output blocks of the model  with message-based connections. In response, constructor  may create message object instances, and the execution engine  may establish message-based relationships among the respective portions or components of the model .","In an embodiment, before execution of the model , the propagation engine  may analyze the construction and configuration of the model  to determine whether, during execution of the model , those blocks that are configured to receive messages will receive the intended messages, as indicated at block . In particular, the message-based execution engine  and the model execution engine  may build an in-memory representation of the model , such as an intermediate representation (IR). The IR may include a plurality of nodes, that may represent the blocks of the model , and edges that represent connections within the model. The IR may also be annotated with additional information, such as the types of messages that destination blocks are configured to receive, the types of messages that source blocks are configured to send, etc. The IR may be created as part of a compilation stage that marks the start of model execution. This compilation stage may include preparing data structures and evaluating parameters, configuring and propagating block characteristics, determining block connectivity, and performing block reduction and insertion. In addition, one or more optimization techniques may be applied to the IR. After the application of an optimization technique, an additional IR may be generated. The propagation engine  may analyze one or more of these IRs.","The propagation engine  may evaluate this IR examining, for example, those elements of the IR that represent the input ports of message-based and other blocks. The propagation engine  may determine the type of message that the given message-block expects to receive on a subject input port. The propagation engine  also may identify the upstream block that is connected to the subject input port of the given message-based block. The propagation engine  may determine the type of message issued by this upstream block. In addition, the engine  may determine whether the type of message defined for the output port of the source component complies with the type of message defined for the input port of the destination component. If a mismatch is identified by engine , it may be reported. For example, an error message or error report may be generated and presented, for example on the display  for review by the user.","The model  may be simulated, e.g., executed or run. For example, the model editor window may include a Run command button that may be selected by the user, e.g., with the mouse . Alternatively, the user may enter a text-based run command, for example, in a Command Line Interface (CLI), or the model may be run programmatically.","In an embodiment, the model execution engine  interfaces with the time-based system , the state-based system , and the message-based system  to execute the entire model , as indicated at block .","In an embodiment, the time-based modeling system  may create a sorted order of the time-based components of the model , as indicated at block . The sorted order may refer to the order in which to invoke block methods, during execution of the model . Exemplary block methods for time-based components may include an output method that computes the output signals of the block based on its input signals and its state, an update method that computes the block's states, and a derivatives method that computes the derivatives of the block's continuous states. Time-based components that are configured to execute together may be identified as a group in the sorted order. For example, a time-based subsystem may include a plurality of time-based blocks, and the subsystem may be configured to run as an atomic subsystem. In this case, all of the time-based blocks of the atomic subsystem execute atomically as a group. The time-based modeling system  may also define a simulation start time, a simulation end time, and a plurality of time steps between the start and end times. The size of the time steps may depend on the particular solver being used to execute the model.","Input and output signals may be represented graphically in the model or block diagram by arrow elements extending between time-based blocks. Input and output signals represent quantities, for example, input and output data that change over time during the execution of the model, and the quantities represented by the signals may be defined, and thus have values, for all points in time between a model's start time and its stop time. Execution of a model may also be referred to as simulation of the model.","In an embodiment, one or more initialization steps may be performed before execution of the model begins. For example, one or more state-based portions of the model may execute one or more default transitions, as indicated at block . Initialization steps for message-based portions of the model may involve typical operations, such as dequeuing a waiting message.","For each time step of the simulation, which may begin with the simulation start time, execution of model may proceed as follows. The time-based modeling system  in cooperation with the model execution engine  may begin executing the time-based components of the model according to the sorted order, as indicated at block . If an event that is a triggering event for a state-based portion of the model occurs, the execution of the time-based components may be suspended, as indicated at block . The triggered state-based portion may be executed as an atomic unit, for example, by the state-based modeling system  in cooperation with the model execution engine , as indicated at block . Upon completing the execution of the state-based portion, the execution of the time-based components may resume from the point in the sorted-order at which execution had been suspended, as indicated at block . For example, the model execution engine  may record where in the sorted order the execution was suspended to execute the state-based portion.","In an embodiment, an input triggering event may occur outside of a state-based portion, for example, by a time-based or other component, but may be visible within the state-based portion. Exemplary input trigger events may include an edge-triggered input event and a function call, for example, from a time-based component. An edge-triggered input event may be configured to operate on a rising edge, a falling edge, or either a rising or falling edge. To operate as an input edge-triggered input event, a signal from a time-based component may need to cross zero, such as a changing from \u22121 to 1. In contrast, a function-call input event may consist of an instantaneous flow of control from a caller subsystem to a callee subsystem. A triggering event for a state-based portion, whether it is an edge, function call or other trigger, may not provide any input data to the state-based portion, which the state-based portion might otherwise use for processing, for example to generate output data. Instead, the triggering event may operate as a control signal that triggers execution of the state-portion, and the state-based portion may operate upon input data that is internal to the state-based portion, or that is received in other ways besides a triggering event.","If the triggering event for the state-based portion occurs during the execution of a group of time-based components that are configured to execute atomically, then the execution of the entire group of time-based components may be completed. Further execution of time-based components may then be suspended, and the execution of the triggered state-based system performed.","If a message is generated and sent, for example, during the execution of time-based components according to the sorted order, then the execution of time-based components may be suspended, as indicated at block . The message-based execution engine  may examine the list of listeners for the respective message. The execution engine  may send the message to the components on the list of listeners, as indicated at block . If the destination component is triggered by the receipt of the message, the execution engine  may execute the destination component, as indicated at block . The message-based execution engine  may also start a timer associated with the generation of a message, and may track the age of the message, as indicated at block . For example, the engine  may use the clock  to operate one or more timers. When the age of the message reaches its maximum age, which may be indicated in message's TTL field , the message may be destroyed by the message-based execution engine , as indicated at block . Each message may thus persist for only a defined time period during the execution of a model.","Upon completing the execution of the components triggered by the message, the execution of the time-based components may resume from the point in the sorted-order at which execution had been suspended, as indicated at block .","It should be understood that the model execution flow described in connection with one or more of steps  to  may be nested. For example, the execution of a state-based portion may generate a message triggering the execution of a message-based portion, which may trigger the execution of a state-based portion, and so on.","It should be understood that a message may be sent to a message-based component, a state-based component, a time-based component, or some other component. In addition, the message-based component, the state-based component, and the time-based component may execute in response to the received message.","The life-time of a message may depend on the semantics of the message processing environment. A message implemented using function-call semantics may get created and consumed in the same time-step, thus resulting in a lifetime of a single time-step. In the presence of queuing semantics, messages can be produced in one time-step but wait in a message queue for a number of time-steps before they are consumed. In addition, the consumer can choose to process a message without consuming the message, thus resulting in messages with potentially infinite lifetime.","In an embodiment, instead of sending a message to a destination component, the message-based execution engine  may notify a destination component that a message has been created. In response, the destination component may retrieve the message. If the destination component fails to retrieve the message before its maximum age is reached, the message may be destroyed before ever being retrieved.","In an embodiment, a message-based component may be configured, upon sending a message, to expect a reply to its message. Such a component may be configured to execute in a synchronous or asynchronous manner. For example, the component may be configured to execute synchronously in which case the component, after sending its message, waits to receive the reply before continuing with its execution. Alternatively, the component may be configured to execute asynchronously in which case the component, after sending its message, proceeds with its execution without waiting for the reply.","In an embodiment, a state-based portion of the model may be configured to execute during a time step even though no triggering event for that state-based portion occurred during the time step. More specifically, a state-based portion may register for time-based triggering. If the model includes a state-based portion that is registered for time-based triggering, and the state-based portion has not already executed during the current time step, then the model execution engine  may execute the state-based portion, as indicated at block .","At this point, execution during the current time step may be complete. If the current time step does not equal the simulation end time, the current time step may be incremented and the execution process may be repeated. This process, for example steps  to , may be repeated for each time step between the simulation start time and the simulation end time.","Referring to model  (), execution at each time step may proceed as follows. Time-based Constant and Gain blocks  and  may execute first as they may be the first blocks in the sorted order. The signal output of Gain block  may be a trigger event for the state-based portion . Accordingly, after Gain block  executes, execution of other time-based components may be suspended, and the state-based portion  may be executed. The Message Receiver block  is configured to listen for a message from the state-based portion  on input port . If the execution of the state-based portion  results in the generation and sending of this message, the message is received by Message Receiver block  causing it to be executed. Next, the blocks of the second time-based portion  execute following the completion of execution of the Message Receiver block , assuming it executes. Execution of the second time-based portion  results in the generating and sending of a message that is received by the Message Generator block . If the second time-based portion  is configured as an atomic subsystem, then all of its blocks, including Gain block  and Outport block  will execute before the Message Generator block  executes. On the other hand, if the second time-based portion  is not configured as an atomic subsystem, then the Message Generator block  may execute before execution of the Gain block  and Outport block .","If the execution of the Message Generator block  results in the generation and sending of a message, then the Message Buffer block  may execute, as it is triggered by such a message. If the execution of the Message Buffer block  results in the generation and sending of a message, then the state-based portion  may execute again.","At this point, execution of the current time step may be complete. The model execution engine  may increment the time step and execute the model  again, unless the simulation end time has been reached.",{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 10","b":["1000","1000","1000","1002","1004","1006","1008","1010","1012","1014","1016","1006","1018","1020","1022","1024","1002","1004","1006","1024"],"i":["a","c","a","c","Simulink ","User's Guide "]},"The library  of model objects may include a plurality of predefined object types or classes, including time-based object types, state-based objects, and message-based object types, among others. Exemplary state-based objects or components include state charts, bubble charts, junctions, transitions, conditions, and flow graphs, among others. To create a model, a user may, among other operations, select a plurality of object types from the library . In response, the modeling system  may add instantiations of the selected objects to the model being constructed or edited.","The clock  may be configured to generate one or more clock or time signals that may be used during execution of a model.","The message-based modeling entity  may include a propagation engine , a message-based execution engine , a verification engine , a report generator , an interface engine , a logging engine , a message routing engine , an object constructor  that may access one or more class packages, such as message-based component class package  and a message-type class package . The message-based modeling entity  also may include or have access to message queues as indicated at .","The HMI engine , model editor , simulation engine , message-based modeling entity , state-based modeling entity , and code generator  may each comprise registers and combinational logic configured and arranged to produce sequential logic circuits. In an embodiment, the HMI engine , model editor , simulation engine , message-based modeling entity , state-based modeling entity , and code generator  are or include software modules or libraries containing program instructions pertaining to the methods described herein, that may be stored on computer readable media, and executable by one or more processors and\/or processing elements. Other computer readable media may also be used to store and execute these program instructions. In alternative embodiments, various combinations of software and hardware, including firmware, may be utilized to implement embodiments of the disclosure.","The modeling system  may receive inputs by a user as the user creates, edits, revises, and\/or opens one or more models, such as computer models that, when executed, simulate the operation of systems, such as physical systems. A model may be specified graphically, textually, or a combination of graphically and textually, and may include a plurality of portions each operating according to a different execution domains. For example, a first portion may operate according to message-based semantics, a second portion may operate according to time-based semantics, and a third portion may operate according to state-based semantics. Other domains may include dataflow, control flow, and combined data and control flow domains. The time-based and\/or the state-based portions may further operate in accordance with message-based semantics. The simulation engine  in cooperation with the message-based execution engine  may execute the model generating one or more results that may be presented to the user.","In an embodiment, the modeling system , including the message-based modeling entity , may be configured to implement a message-based modeling architecture in which producer\/sender objects of a model generate messages that are received consumer\/receiver objects during execution of the model. The model objects may be specified graphically, textually or a combination of graphically and textually. In an embodiment, messages may be instances of message types, and may include payloads comprising one or more data elements that may be fixed during execution of the model, for example a message's data does not change over the model's execution time. In an embodiment, a message payload value may be modified, e.g., during the message's time interval. Messages also may include one or more commands, such as operation codes (opcodes).","In an embodiment, a model or at least a portion thereof may represent a dynamic system that defines relationships between signals and state variables that change over time. Determining the behavior of a dynamic system may involve evaluating these relationships at a plurality of intervals, which may be called time steps, beginning at a start time and ending at a stop time. The process of solving a model at successive time steps may be referred to as simulating the system that the model represents.","In addition, sample times and sample rates may be determined, e.g., at model compilation stage, for at least some components of a model, such as one or more objects or blocks of the model. A block's sample time may be set explicitly by a user or programmatically, e.g., by setting a SampleTime parameter of the block, or it may be determined in an implicit manner based on the block's type and\/or its context within the model. A block's SampleTime parameter may be a vector [T, T] where Tis the sampling period and Tis the initial time offset. One or more of the solvers  used to \u2018solve\u2019 the model may determine the size of the simulation time steps in order to execute the model, and these simulation time steps may be selected to correspond with the sample times of the blocks of the model. When a simulation time step matches the sample time for a block, a sample time hit occurs, and the block may be scheduled for execution during that simulation step.","The solver  may generate an execution schedule for components, including objects or blocks, of the model over the course of the model's simulation time. In addition, one or more message-based components may be configured to execute at particular sample times. That is, the message-based components may be scheduled for execution at one or more time steps that correspond to sample time hits for the message-based components.","As noted, messages may persist for determined time intervals of an execution time of a model where the time interval is less than the full or entire execution time of the model. For example, a model may be or may include a time-based portion, and may execute over a simulation time that begins at a simulation start time and ends at a simulation end time. One or more of the solvers  chosen to \u201csolve\u201d the model may determine the execution time steps for the model. The time-based portion of the model may produce signals that have a value throughout the execution time of the model, and the value may change dynamically during the model's execution. Messages, on the other hand, may persist for a discrete, limited portion of a model's simulation time. Messages may be configured to be triggering in which case, when a message is generated, a consumer\/receiver object is activated, e.g., woken up, and run in order to process the message. The consumer\/receiver object may process the message according to the object's normal execution schedule, e.g., as determined by the solver . Alternatively, messages may be configured to be non-triggering in which case, while a consumer\/receiver object may be woken up upon generation of a message, the consumer\/receiver object is not required to process the message immediately. Instead, the consumer\/receiver object, when activated, may examine a message queue to determine whether there is a message present in the queue, and if so may process, e.g., consume, the message. Activation of the consumer\/receiver object may occur at some time after the message was generated and placed in the message queue. Messages also may be blocking or non-blocking. With a non-blocking message, a producer\/sender may post a message, and then run to completion before a consumer\/receiver of the message is activated, e.g., woken up. With a blocking message, the producer\/sender object may be configured to enter a wait state upon posting a message, and execution may switch to the consumer\/receiver object. Once execution of the consumer\/receiver object completes, execution of the producer\/sender may resume. In an embodiment, the message-based modeling entity  may be configured such that messages are non-triggering and non-blocking. In this embodiment, if a producer\/sender object wishes to receive an acknowledgement to a message, the producer\/sender object may enter a wait state explicitly.","Message Queuing","As noted, the message-based modeling entity  may establish one or more message queues  configured to store messages generated by producer\/sender objects of a model during execution of the model. The message queues  may be accessed by consumer\/receiver objects to retrieve messages stored therein. In particular, as part of a model initialization or set-up phase, the message-based modeling entity  may request allocation of one or more data structures, e.g., in main memory  (), to establish the message queues . Exemplary data structures include linked lists, circular queues, etc. Messages, or alternatively message payloads, generated by producer\/sender objects of a model may be placed and stored in the message queues .","In an embodiment, a producer\/sender object may be configured to specify a particular one of the queues  to store messages generated by the producer\/sender object. One or more message queues, such as message queues  may be global queues for storing messages generated by any message producer\/sender object and intended for any consumer\/receiver object. One or more other message queues, such as message queues , may be local to one or more message-based objects, such as a producer\/sender or consumer\/receiver object. In addition, one or more message queues, such as message queues , may be shared by a group of objects. For example, a group of consumer\/receiver objects that are configured to receive certain messages during execution of the model, such as messages from the same producer\/sender object, may share one of the shared message queues .","Message queues  may have a plurality of attributes or properties, such a length, a processing order, and an overflow policy, which may be specified through corresponding properties. The attributes or properties may be fixed or they may be settable, e.g., by a user, on a queue by queue basis. Exemplary lengths include 1, 2, 3, etc., such that the message queue may store one, two, three, etc. messages. Exemplary processing orders include First In First Out (FIFO), Last In Last Out (LIFO), and priority-based queuing, among others. An exemplary overflow policy is delete\/replace oldest message if message queue is full when a new message is received\/posted. With an overflow policy a producer\/sender object may continue to send messages to the message queue. That is, the producer\/sender object may not be blocked from sending further messages when a message queue is full.","In a further embodiment, at least some of the message queues  may be configured with a priority attribute or property, and may thus be assigned priorities, such as a high priority message queue, a moderate priority queue, and a low priority message queue. A producer\/sender object may designate one of the message queues  to hold a given message. For example, for a message having high importance, the producer\/sender object may designate the high priority message queue. For a message having moderate or low importance, the producer\/sender object may designate the moderate or low priority message queues. A message receiver\/consumer may be configured to process messages from a higher priority queue before processing messages from a lower priority queue irrespective of the chronological order, e.g., in terms of model execution time, of the messages in the two queues.","In an embodiment, the interface engine  of the message-based modeling entity  may be configured to provide, within an executable graphical model, one or more graphical objects, such as icons, blocks, etc., that represent a message queue. The message-based modeling entity  may be configured to add one or more message queue objects to a graphical model automatically or in response to user action, such as selection and drag and drop operations.",{"@attributes":{"id":"p-0104","num":"0103"},"figref":"FIG. 19","b":["1900","1900","1900","1902","1904","1906","1900","1908","1904","1910","1902","1912","1914","1916","1906","1914","1900","1906","1900","1918","1920","1922","1922","1900"]},"The model  may include a first double line arrow  that connects the subsystem's output port  to the Message Receive block  to indicate that the Message Receive block  is to receive the messages generated by the Message Send block  of the subsystem . A second single line arrow  may connect the Message Receive block  to the Scope block . As noted, a first graphical affordance, e.g., a double line arrow, may be used to represent message connections among message send and receive blocks, while a second graphical affordance, e.g., a single line arrow, may be used to represent signals of the model . In an embodiment, the message-based modeling entity  may be configured to establish at least one message queue automatically in response to the Message Receive  being added to the model  and configured to receive messages from the subsystem . During execution of the model , messages generated and sent by the subsystem  may be stored in this message queue for receipt and possibly consumption by the Message Receive block .",{"@attributes":{"id":"p-0106","num":"0105"},"figref":"FIG. 20","b":["2000","2000","2000","2002","2004","2002","2004","2000","2006","2008","2002","2004","2010","2012","2000","2014","2016","2018","2002","2004","2000","2014","2020","2000","2020","2002","2004","2014","2020","2002","2004","2006","2008","2020","2000","2020"]},"In an embodiment, a properties page may be associated with the message queue block . The properties page may include a plurality of settable entries through which a user may specify attributes or properties of the message queue represented by the message queue block , such as length, processing order, overflow policy, and priority, among others. The properties page may be opened in response to selection of the message queue block .","Furthermore, instead of, or in addition to, having priority queues, one or more messages may be assigned a priority, e.g., by the producer\/sender object of the message. The message-based execution engine  may be configured to sort messages within a message queue  based on the priority of the messages. For example, messages assigned a high priority may be moved to the head of the queue, and may be removed and consumed before other messages in the queue that have a low or a lower priority.",{"@attributes":{"id":"p-0109","num":"0108"},"figref":"FIG. 11","b":["1100","1100","1100","1102","1104","1106","1108","1110","1112","1114","1102","1104","1106","1108","1110","1112","1114"]},"Exemplary message opcodes may include WARNING, ERROR, DIAGNOSTIC, ALARM, and ALERT. Nonetheless, additional or other opcodes may be provided.","Synchronous\/Asynchronous Execution","During execution of a model, a producer\/sender object may generate and send a message to a consumer\/receiver object of the model. The generation and\/or sending of a message may occur at a sample time hit for the producer\/sender object, or the generation and\/or sending of a message may occur independently of the model's execution time steps. The message may be stored at a message queue . As noted, a consumer\/receiver object may be being triggered to execute upon the receipt of a message. That is, upon notification of a message being added to the queue, the consumer\/receiver object may be activated and may retrieve and consume the message. The consumer\/receiver object may thus operate synchronously relative to the receipt of a message. Alternatively, a consumer\/receiver object may be configured to execute during one or more sample times, instead of being triggered by the receipt of a message. For example, at a sample time hit, the consumer\/receiver object may examine its message queue to see whether there is a message in the queue. If there is a message in the queue, the consumer\/receiver object may retrieve and consume the message as part of its execution during the sample time hit. At the next sample time hit, the consumer\/receiver object may again access the message queue and, if one or more messages are found, may retrieve and consume the messages. The consumer\/receiver object may thus execute asynchronously with respect to the reception of a message. During initialization of a model, the message-based execution engine  may be configured to schedule message-based components or objects for synchronous or asynchronous execution. A message-based component or object may be configured to include a property or parameter whose setting specifies whether the component or object executes synchronously or asynchronously.","Using Messages within State-Based Modeling Components","In an embodiment, the library  of model objects may include time-based and state-based objects or components that may be further configured to send and\/or receive messages during execution of a model having instances of those objects or components. In particular, the simulation engine  in cooperation with the message-based execution engine  may be configured to execute state-based components or objects that send and\/or receive messages during execution of a model or a portion thereof including those state-based components or objects.","A user may interact with a Graphical User Interface (GUI) to open, create, and\/or revise a model, including a state-based model. Specifically, the HMI engine  may be configured to provide a model editor window in the form of a GUI having a plurality of window gadgets (widgets) or graphical elements, which may be arranged as a desktop environment. The GUI's graphical elements may include a model canvas and one or more floating palettes that present graphical object types, such as component types, from the library  that may be selected, e.g., by a user, and used to construct a desired model on the model canvas.",{"@attributes":{"id":"p-0116","num":"0115"},"figref":"FIG. 12","b":["1200","1202","1204","1206","1208","1202","1206","1202","1204","1210","1210","1000","1200","1206","1212","1212","1212","1214","1208","1216","1212","1206"]},"In an embodiment, the modeling system  may be configured to execute state-based components or objects in response to events or messages occurring during model execution. Furthermore, the modeling system  may be configured to utilize a plurality of execution stages for state-based components or objects. For example, a state-based component may have an inactive execution stage in which the component has no active states, an active execution stage in which the component has one or more active states, and a sleeping execution stage in which the component has one or more active states but no events or messages to process.","Input\/Output Messages","In an embodiment, the message-based modeling entity  may be configured to add one or more message ports to a state-based component of a model, such as the chart  of the model . The message ports may be represented graphically, and may be added in response to user inputs or programmatically. The modeling system  may be configured to open the chart , e.g., for editing, in response to a selection of the chart , e.g., by a user.  is a schematic illustration of the model editor window  in which the chart  is opened. With the chart component  opened, a user may construct or revise the chart component , for example, by adding program elements or components to the canvas . A menu bar  for the chart  may be presented on the model editor window  in place of the menu bar  (). A popup dialog  may be presented in response to a selection of a Chart command  of the menu bar . The popup dialog  may include an Add Inputs & Outputs command  that, in turn, may present a plurality of commands, such as an Add Message Input command  and an Add Message Output command . The message-based modeling entity  may be configured to add message ports to state-based objects, such as the chart component , for example, in response to the selection of the Add Message Input command  and\/or the Add Message Output command , e.g., by a user. In an embodiment, a properties page (not shown) may be presented in response to the selection of the Add Message Input command  and\/or the Add Message Output command  through which a user may specify property values for the respective message ports. A message input port may have the following properties:","1. data type of message payload;","2. Queue size; and","3. Consume message on peek (yes\/no).","A message output port may have the following properties:","1. data type of message payload; and","2. block on send (yes\/no).","Nonetheless, additional or other properties may be provided.","The message-based modeling entity  may be configured to assign default values to one or more of the properties of the message ports. The message-based modeling entity  may be configured to implement message ports as objects instantiated from a message port class or type.","Once desired values have been selected for the properties of the message ports, the user may return to the model view.  is a schematic illustration of the model editor window . The chart component  now includes a message input port, named \u2018Message\u2019, , and a message output port, named \u2018Message1\u2019, . In an embodiment, particular messages may be assigned to the message input and output ports  and  graphically, e.g., by drawing a line or other graphical object from another component or object of the model to the message input and output ports  and . Alternatively, messages may be assigned to the message input and output ports  and  through textually specified commands or through a combination of textual and graphical inputs.","In an embodiment, the message-based modeling entity  may be configured to assign respective message queues  to the message ports, such as the message input and output ports  and . The message queues  assigned to the input and output ports  and  may have a length, a processing order, an overflow policy, and a priority.","It should be understood that the message-based modeling entity  may be configured to utilize other objects to implement message ports and\/or message queues. For example, a separate graphical object, such as a Message Queue block, may be defined, and instances of the Message Queue block may be added to a model. A Message Queue block may be associated with a message port of a state-based component. For example, a Message Queue block may be graphically or visually connected to the message port.","Logging and Message Tracing","In an embodiment, the logging engine  may be configured to log messages generated during execution of a model. For example, the logging engine  may be configured to utilize one or more blocks or objects for logging message. The blocks or objects may be included in the model, and may be configured to detect messages as they are added to a message, and to store copies of the messages for subsequent analysis. In addition to storing copies of the message, the blocks or objects may be configured to store additional data, such as metadata, associated with the messages. The metadata may include such things as the execution time at which messages are created and added to the queue, the execution time at which messages are de-queued, the producer\/sender of a message, the receiver\/consumer of a message, etc. Exemplary blocks or objects that may be used by the logging engine  include the \u2018To Workspace\u2019 block of the Simulink model-based design system from The MathWorks, Inc. The \u2018To Workspace\u2019 block may, for example, be connected to a message port and\/or a Message Queue block. During execution, the \u2018To Workspace\u2019 block may store information concerning messages in a workspace associated with the model. Following the execution of the model, a user may access the workspace, and examine the messages and their metadata.","Message Routing and Forwarding","In an embodiment, the message routing engine  may be configured to route messages within a model. For example, the message routing engine  may be configured to forward messages received at a first message queue to a second message queue. The message routing engine  may call a forward method or operation on the queue. The forward method or operation may specify the second message queue to which messages are to be forwarded. In an embodiment, the forward method or operation may not cause messages to be consumed, e.g., deleted from the first queue. To the extent the first message queue is associated with a state-based component or object of a model, the message routing engine  may be configured to forward messages from the first message queue when the component or object goes to sleep. In an alternative embodiment, the forwarding of messages from the first queue may result in the messages being consumed.","In an embodiment, one or more graphical object types may be specified, and instances of these graphical object types may be included in a graphical model to specify message routing functions or operations. The graphical objects may be represented in a graphical model by preselected graphical affordances, such as particular blocks, icons, etc.",{"@attributes":{"id":"p-0136","num":"0135"},"figref":"FIG. 21","b":["2100","2100","2100","2102","2104","2100","2106","2108","2102","2104","2102","2104","2100","2100","2110","2112","2100","2110","2102","2104","2114","2114","2100","2110","2102","2104","2116","2118","2114","2120","2122","2102","2104","2124","2114","2110"]},"It should be understood that other or different message routing blocks may be provided, such as a message splitter block configured to distribute messages from one message source block to multiple message receiver blocks.","Message Queue Primitives","Message queues may be configured by the message-based modeling entity  to implement a plurality of methods or operations, such as primitive operations or primitives, during execution of a model. For example, message queues may support a \u2018peek\u2019 method or operation. In response to calling the \u2018peek\u2019 method, a message queue may reply by informing the caller or sender of the \u2018peek\u2019 method whether or not a message is currently in the queue. The reply may simply indicate whether one or more messages are in the message queue, e.g., Yes or No. Alternatively, the reply may include the number of messages in the queue. In addition, the caller of the \u2018peek\u2019 method may obtain the message's payload. In an embodiment, the \u2018peek\u2019 method or operation may not result in the message being removed from the message queue. Accordingly, the number of messages currently stored in a message queue is not changed by the \u2018peek\u2019 method. A message queue may also support a \u2018pop\u2019 method or operation. A message queue may respond to a \u2018pop\u2019 method or operation by removing a message from the message queue, and providing the message to the caller of the \u2018pop\u2019 method or operation. The particular message that is removed may depend on the queue's processing order, e.g., FIFO, LIFO, etc. A message queue also may support a \u2018consume\u2019 method or operation. In response to a \u2018consume\u2019 method or operation, the message queue may destroy the respective message. In an embodiment, multiple methods or operations may be tied together. For example, the \u2018consume\u2019 method may be tied to the \u2018pop\u2019 method so that, when a message is removed from a message queue it is also destroyed.","Posting Messages from State-Based Components","The modeling system , including the state-based modeling entity , may be configured to execute actions defined or specified for state-based components or objects during model execution. More specifically, a user may define or specify, one or more action statements for state objects of a model. For example, an entry type of action, which may be identified by using a label, such as \u2018entry\u2019 or \u2018en\u2019, may be executed when a state becomes active, e.g., is entered. A during type of action, which may be identified by using a label, such as \u2018during\u2019 or \u2018du\u2019, may be executed while a state is active. In an embodiment, the modeling system  may be configured to support the specification of during actions to be performed or executed when a specified event occurs, or when a specified message and\/or message payload is received. An exit type of action, which may be identified by using a label, such as \u2018exit\u2019 or \u2018ex\u2019, may be executed when a state becomes inactive, e.g., is exited. An on event type of action, which may be identified by using a label, such as \u2018on\u2019, followed by an event name, may be executed when the state is active and the event occurs. In an embodiment, the modeling system  may be configured to support the specification of actions to be performed when a state is active and a particular message is received by the state. That is, the modeling system  may also support an on message type of action, which may also be identified by the \u2018on\u2019 label.","The modeling system , including the message-based modeling entity , may be configured to implement a programming syntax that may be used when defining or creating a model in order to configure a state-based component or object of the model to post a message during execution of the model. An exemplary textual syntax is:",{"@attributes":{"id":"p-0143","num":"0142"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"post(Message_Name, payload)"},{"entry":"where"},{"entry":"\u2018post\u2019 is the name of the operation or command for posting a message,"},{"entry":"\u2018Message_Name\u2019 is the name of the message to be posted, and"},{"entry":"\u2018payload\u2019 is the value of the payload of the message to be posed."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Using the defined syntax, a user may configure a state-based component or object of a model to post one or more messages during execution of the model including that state-based component or object. The posting of the message may be specified as an entry type of action, a during type of action, a on type of action, or an exit type of action. The one or more messages may be posted by the component or object to a particular message queue.",{"@attributes":{"id":"p-0145","num":"0144"},"figref":"FIG. 15","b":["1214","1502","1504","1502","1506","1504","1508","1214","1502","1028","1204","1504","1028","1404"]},"It should be understood that other programming syntaxes may be defined and used to post messages. For example, other exemplary programming syntaxes include:",{"@attributes":{"id":"p-0147","num":"0146"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"M.data = 3; post(M), and"]},{"entry":[{},"M = 3; post(M)."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Using Messages to Control Transitions Among States","In an embodiment, the modeling system  may be configured to support transitions among state components or objects of a model based on messages generated during execution of the model. That is, the transitions may occur (or may not occur) as a function of one or more messages. In other words, a state transition may be \u201cguarded\u201d by a message. In particular, the message-based modeling entity  may be configured to implement transitions between states:","1. when any message is received;","2. when a particular message is received;","3. when any message that satisfies some condition is received; and","4. when a particular message that satisfies some condition is received.","The message-based modeling entity  may be configured to recognize a programming syntax, and this programming syntax may be used to associate a message or a message and condition to a transition. An exemplary textual syntax is:",{"@attributes":{"id":"p-0155","num":"0154"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2018Message_Name\u2019(\u2018payload_name\u2019) [\u2018payload_name\u2019 = = \u2018value\u2019]"},{"entry":"where"},{"entry":"\u2018Message_Name\u2019 identifies the message,"},{"entry":"\u2018payload name\u2019, if present, identifies an element of the message's payload,"},{"entry":"and \u2018value\u2019 specifies a value for the identified payload element."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0156","num":"0155"},"figref":"FIG. 16","b":["1600","1602","1604","1606","1602","1604","1606","1606","1608","1600","1012","1608","1608","1012","1600","1012","1600","1602","1604"]},"A state-based component or object may be configured to transition between states on receipt of a message, regardless of the message's payload. For example, to configure the state-based component  to transition from state A  to state B  on receipt of a message, regardless of the message's payload, a user may associate the transition  with the textual string \u2018M\u2019. The message-based modeling entity  may be configured to evaluate this textual string to mean: determine whether any message \u2018M\u2019 is received, without considering the message's payload.","In an embodiment, a textual command string may be associated with a transition by selecting the transition, and entering the textual command string in a dialog that opens for the transition.","It should be understood that other programming syntaxes may be used to determine if a desired message exists to cause a transition among states. Alternative syntaxes that may be used include:",{"@attributes":{"id":"p-0160","num":"0159"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2018Message_name\u2019[\u2018Message_name\u2019 = = \u2018payload_value\u2019]"]},{"entry":[{},"rcv(\u2018Message_name\u2019)[\u2018Message_name\u2019 = = \u2018payload_value\u2019]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"State-based components or objects may also be configured to receive messages, and process the payloads of messages as during and exit types of actions.",{"@attributes":{"id":"p-0162","num":"0161"},"figref":"FIG. 17","b":["1700","1702","1704","1702","1706","1708","1702","1704","1708","1710","1706","1702","1702","1704"]},"State transitions may also be guarded by attributes of message queues, such as the length of a given message queue.","Determining when Messages are Posted","The simulation engine  may be configured to execute a model over a simulation time that has a plurality of time steps, including a model having components or objects that send and receive messages. The modeling system  may be configured to support a programming syntax for determining whether a message is received at a given point in time during the simulation time, such as a particular time step and\/or a particular simulation time. For example, the modeling system  may support the following programming syntax, which may be used in a model:",{"@attributes":{"id":"p-0166","num":"0165"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Message_name [t = = model_execution_time_point]"]},{"entry":[{},"where"]},{"entry":[{},"\u2018Message_name\u2019 is the name of the message,"]},{"entry":[{},"\u2018t\u2019 refers to the model's simulation time, and"]},{"entry":[{},"\u2018model_execution_time_point\u2019 is the time value to be evaluated"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"with respect to the specified message."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"This programming syntax may be used to guard transitions among states or to determine whether other operations should be performed, e.g., by a state-based or other component or object of a model.","Message Consumption","In an embodiment, the message-based modeling entity  may be configured to designate messages as consumed upon the messages being read. Once a message is designated as consumed, it may be marked stale and\/or destroyed. Suppose, for example, that a transition between two states is defined to occur on the existence of a message having an attribute that satisfies some condition, such as a payload equaling some value, a payload being greater or less than some value, the message is received at a particular point in the model execution time, etc. If the message-based modeling entity  examines the message queue and finds a message in the queue, then the message-based modeling entity  may read the message and mark it as consumed whether or not the message's attribute satisfies the condition. Thus, even though a message does not result in a transition between the two states because the message's attribute does not meet the condition, the message may be consumed, and thus destroyed.","With regard to state-based components or objects, the message-based modeling entity  may be configured to mark a message as read after the state-based component reaches a stable state. Suppose, for example, that a state-based component is defined so that the component transitions from a first state to a second state upon receipt of a message, regardless of the message's payload, and transitions from the second to a third state if an attribute of a received message satisfies some condition. In this case, upon receipt of a first message, the component transitions from the first state to the second state. The first message is also tested to see whether its attribute satisfies the condition. If so, the component transitions from the second to the third state. If the third state is a stable state of the component, then the message-based component marks the message as consumed, and the message is destroyed. Nonetheless, the same message may be used to effect two transitions within the state-based component.","A state diagram or state chart may be considered to be in a stable state after all possible transitions among states or sub-states are completed. Alternatively, the message-based modeling entity  may be configured to treat a message as consumed after the first access to the message, e.g., after accessing the message in response to a first transition of a state-based component or object.","In an embodiment, before a message-based component goes to sleep, messages that were peeked at may be popped and thus consumed.","In an embodiment, the state-based modeling entity , e.g., as default semantics, may be configured to execute the state-based components of a model once for every active input event or input message to the state-based components. If there are no input events or input messages for a given state-based component, it may be executed once each time step, if the model is a time-based model that executes over a plurality of time steps between a start time and an end time. In addition, a given state-based component or object of a model may be configured to execute multiple times for every active input event or input message, or for every time step when the state-based component has no input events or input messages. In this case, which may be referred to as \u2018super step\u2019 semantics, the given state-based component may take valid transitions until no more valid transitions exist for the given state-based component, or the number of transitions that have been taken exceeds a threshold, which may be user specified. For a state-based component configured with \u2018super step\u2019 semantics, the message-based modeling entity  may be configured to mark a message as read (and thus consumed) at the end of each single step, or alternatively at the end of a \u2018super step\u2019.","In an embodiment, the state-based modeling entity  may support the creation of state-based components that include parallel (AND) states or sub-states in which all the states or sub-states of the state-based component are active. The ordering of parallel states or sub-states may be explicit, e.g., user-specified priority numbers, or implicit, e.g., based on internal rules of the state-based modeling entity .","Suppose, for example, a state-based component has a single message input port and two parallel states that are both interested in messages posted to the component's message input port. In an embodiment, when a message is received at the message input port, the message-based modeling entity  may be configured to wait until each parallel state or sub-state has had an opportunity to read the message before marking the message as consumed. If a first parallel state is ready for a message, the message is read and acted upon by the first parallel state. If a second parallel state is not ready for a message, then it does not read the message, and the message may be considered consumed.","In an alternative embodiment, the message-based modeling entity  may be configured to establish a message queue for each parallel state or sub-state, and to place a copy of the message in each of these message queues. In this embodiment, if a first parallel state is ready for a message, it reads the message from its message queue and the message from that message queue is consumed. If a second parallel state is not ready for a message, the message waits in the second parallel state's message queue until the second parallel state is ready to read a message.","In yet another embodiment, the message-based modeling entity  may be configured to keep executing the parallel states until a fixed point is reach at which a message may be consumed by both of the parallel states, e.g., in the same time step.","Verification of a Message-Based Portion of a Model","In a further aspect of the disclosure, verification or other testing may be performed on one or more message-based portions of a model. In an embodiment, one or more verification components may be provided to verify a message-based portion of a model.","Message Observer","In an embodiment, the verification engine  may create a first verification component, which may be referred to as an observer, for verifying one or more messages in a model. The observer may be associated with a particular message-based connection in a model, and may present information concerning one or more of the messages that travel across that connection during execution of the model. In an embodiment, the observer component operates, at least in part, as a viewer to present information concerning all of the messages that travel across the selected connection during execution of the model. The observer component may provide a message-based view that includes the set of message participants, such as the sources and destinations, the types of messages generated and sent, and the payloads of those message. This collection of information may be referred to as an interaction.",{"@attributes":{"id":"p-0182","num":"0181"},"figref":"FIG. 8","b":["800","800","800","802","804","806","808","810","812","814","802","804","814","806","808","810","812","808","810","816","808","810","800","808","810","810","808"]},"Suppose a user is interested in examining and verifying the actual messages exchanged between the Bus component  and the Controller component  across the message-based connection  during execution of the model . In this case, the user may access an Observer component, such as Observer component or block .",{"@attributes":{"id":"p-0184","num":"0183"},"figref":"FIGS. 9A"},"The verification engine  may receive a request for an Observer block, as indicated at block . The verification engine  may also receive a designation of one or more message-based connections to which the requested Observer block is to be associated, as indicated at block . In response to the request, the verification engine  may cooperate with the constructor  to create an Observer component, such as an object instance. In addition, the model builder  may present a corresponding Observer block, such as block , in the graphical model , as indicated at block . A user may issue a request for an Observer block either textually, e.g., by entering a command in a Command Line Interface (CLI), or graphically, e.g., by selecting an Observer block from a library browser. In an embodiment, a user may select a message-based connection of interest, for example, connection , such as with the mouse . In response, the verification engine  may present one or more selectable commands in a drop-down list, including an \u2018Insert Observer Block\u2019 command. The user may select the \u2018Insert Observer Block\u2019 command, thereby causing an Observer component to be created that is associated with the selected message-based connection.","In an embodiment, the Observer block  may include a plurality of Graphical User Interface (GUI) elements. Specifically, the Observer block  may include corresponding icons for the two or more message-based participants, e.g., the components connected by the message-based connection to which the Observer block is associated. Here, the Observer block  may include a first box element  representing the Bus component , and a second box element  representing the Controller component . The Observer block  may also include a line element, such as line elements ,  extending from each box element , . Information concerning messages exchanged between the Bus component  and the Controller component  across message-based connector  may be presented between the line elements ,  of the Observer block .","After issuing a request for an Observer block and associating it with a message-based connection of interest, the model may be executed, as indicated at block . As part of the execution of the model , the Bus component  may generate and send one or more messages to the Controller component , and the Controller component  may respond with one or more reply messages. Information concerning this exchange of messages may be presented by the Observer block .","Specifically, the verification engine  may monitor the sending and receiving of messages across the selected message-based connector , as indicated at block . For example, the verification engine  may interface with the message-based execution engine . In addition, as each such message is generated and sent, the verification engine  may add an entry to the Observer block for that message, as indicated at block . The verification engine  may also include within each entry one or more information elements concerning the respective message, as indicated at block . For example, the verification engine  may add an arrow element to the Observer block  for each actual message. An arrow pointing from line element , which extends from box element , to line element , which extends from box element , may represent a message sent from the Bus component  to the Controller component . An arrow pointing from line element  to line element  may represent a reply message sent from the Controller component  to the Bus component . The verification engine  may also include a data element at each entry that indicates the type of message sent, and that includes information from the message's payload. The entire payload or a portion thereof may be included in the entry's data element.","In addition, the verification engine  may include one or more time elements in the entry for a given message. The one or more time elements may contain information relating to the timing characteristics of the message. In particular, a message may be sent by a source component at a particular time, which may be denoted as the TimeSent, T, and may be received by a destination component at a particular time, which may be denoted as TimeReceived, T. One or more of these timing characteristics, such as Tand\/or T, may be included in the entry of the Observer block  by the verification engine .","The timing characteristics of a message may be determined by the verification engine  in cooperation with the message-based execution engine . For example, system  may receive a clock signal from system clock , and the message-based execution engine  may use this clock signal to identify one or more timing characteristics of messages.","As illustrated in the Observer block , four messages were generated and sent across the message-based connection  during execution of the model , as indicated by arrow elements -. All four messages were sent by the Bus component  to the Controller component  as indicated by the arrow elements -. Furthermore, each of the four messages may be \u2018Altitude\u2019 type messages, and may carry the following payloads: \u201810,000\u2019, \u201820,000\u2019, \u201830,000, and \u201840,000\u2019. In addition, the four messages were received by the Controller component  at the following times: 12 s, 18 s, 20 s, and 21.4 s, as indicated by timing elements - of the Observer block .","The verification engine  may also receive a request for a report of the messaging information presented by the Observer block , as indicated at block  (). For example, a user may request such a report. The verification engine  may provide the information to the report generator , as indicated at block , and the report generator  may create a report, as indicated at block . The report generator  may provide the report to an output device, such as the display , a printer, etc., as indicated at block . The report generator  may also or alternatively save the report in memory, as indicated at block .","The Observer block  may be docked, that is fixed, to the model . The Observer block  also may be visually associated with the message-based connection  through a line element (not shown) connecting the Observer block  to the connection . Alternatively, the Observer block  may be a floating block. A floating block is not locked to any particular location in the model , but may be moved around the canvas, for example, by the user. In this case, an icon, such as a glasses element , may be placed near the connection  to indicate that an Observer block is associated with this message-based connection.","In an embodiment, the high-level modeling environment  may include one or more code generation modules for generating code from a model, such as C code, C++ code, Hardware Description Language (HDL) code, etc. The code generation module may generate code for one or more verification blocks, such as the Scenario blocks. If the code for the Scenario block detects an invalid trace, for example, it may generate an error message that could be read by another code module, which in turn may take some predetermined action, such as resetting the deployed systems, or sending a signal to a processing unit.","The generated code, moreover, may be used in a deployed system, that may be a real-world system that is physically separate from the data processing system  on which the high-level modeling environment  operates. Exemplary deployed systems include controllers, such as Engine Control Units (ECUs) used in cars and trucks, Anti-lock Braking Systems (ABS), aircraft flight control systems, etc.","Suitable code generation models include the Real Time Workshop code generator and the Simulink HDL Coder products from The MathWorks, Inc.","Referring to , the modeling system  may further include a code generator . The code generator  may be configured to generate code, such as computer programming code, for a model or portion thereof. The generated code may be standalone code that is independently executable, e.g., executable outside of the modeling system , and may be compatible with a specified target platform. Exemplary target platforms include a server or other data processing machine running a Microsoft Windows operating system, a server or data processing machine running a UNIX or Linux operating system, and an embedded system having a microprocessor, a Digital Signal Processor (DSP), a Field Programmable Gate Array (FPGA), and\/or an Application Specific Integrated Circuit (ASIC), among others. The generated code may be deployed to and run by the target platform, which may not include a modeling system . During the code generation process, a user may specify the target platform, and may specify other options for the code generation process, such as the use of one more optimizations. The generated code may be source code, object code, an executable, a binary, a hardware description language (HDL) description, etc., and may conform to a programming language, such as C, C++, VHDL, Verilog, etc. In an embodiment, the code generator  may be configured to generate code that, when compiled or interpreted on the target platform, creates a message-passing architecture or service. This message-passing architecture or service may be used by other modules of the generated code representing message-based components or objects of a model.","In another embodiment, the code generator  may generate code that takes advantage of an existing message-passing architecture or service of a target platform. For example, in addition to specifying a particular target platform, a user may indicate a message-passing service already present and available on the target platform. For example, the VxWorks real time operating system (RTOS) from Wind River Systems, Inc. of Alameda, Calif. creates message channels to support fast communication between applications, tasks, and processes. These message channels provide a connection-oriented, bidirectional messaging mechanism based on the Transparent Interprocess Communication (TIPC) open source protocol. The Run-time Environment (RTE) of the Automotive Open System Architecture (AUTOSAR), an open and standardized automotive software architecture jointly developed by various automobile manufacturers, suppliers, and tool developers, also defines an information exchange service. The Portable Operating System Interface for UNIX (POSIX) is a set of IEEE and ISO standards defining an interface between application programs and UNIX type operating systems. PROFINET is an industrial networking standard designed for automation. The code generator  may be configured to generate code that interfaces to the message channels of the VxWorks RTOS, the RTE from AUTOSAR, the POSIX standard, or the PROFINET standard, instead of creating a separate message passing service. For example, an interface specification, such as an Application Programming Interface (API), may provide details for interfacing to a particular message-passing service, such as VxWorks' message channels. The code generator  may be configured to generate code that includes calls to the message-passing service, based on the interface specification.","The code generator  may include or have access to code replacement tables containing message-passing service implementations for one or more existing message-passing services. When the code generate  reaches a point in the generated code regarding the passing of a message, the code generator  may access the one or more code replacement tables for the selected message-passing service, and utilize within the generated code the message-passing service implementations contained in the one or more tables. It should be understood that other techniques may be used to specify an implementation of an existing message-passing service.",{"@attributes":{"id":"p-0200","num":"0199"},"figref":"FIG. 18","b":["1006","1802","1006","1804","1006","1012","1806","1012","1042","1808","1012","1810","1016","1812","1812"]},"An executable graphical model may include portions, such as sub-models, subsystems, blocks, etc., that are configured to execute at different rates relative to each other. The different model rates may be a function of a fundamental rate or a fundamental model sample time.","The foregoing description of embodiments is intended to provide illustration and description, but is not intended to be exhaustive or to limit the disclosure to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from a practice of the disclosure. For example, while a series of acts has been described above with respect to the flow diagrams, the order of the acts may be modified in other implementations. In addition, the acts, operations, and steps may be performed by additional or other modules or entities, which may be combined or separated to form other modules or entities. Further, non-dependent acts may be performed in parallel. Also, the term \u201cuser\u201d, as used herein, is intended to be broadly interpreted to include, for example, a computer or data processing system (e.g., system ) or a user of a computer or data processing system, unless otherwise stated.","Further, certain embodiments of the disclosure may be implemented as logic that performs one or more functions. This logic may be hardware-based, software-based, or a combination of hardware-based and software-based. Some or all of the logic may be stored in one or more tangible non-transitory computer-readable storage media and may include computer-executable instructions that may be executed by a computer or data processing system, such as system . The computer-executable instructions may include instructions that implement one or more embodiments of the disclosure. The tangible non-transitory computer-readable storage media may be volatile or non-volatile and may include, for example, flash memories, dynamic memories, removable disks, and non-removable disks.","No element, act, or instruction used herein should be construed as critical or essential to the disclosure unless explicitly described as such. Also, as used herein, the article \u201ca\u201d is intended to include one or more items. Where only one item is intended, the term \u201cone\u201d or similar language is used. Further, the phrase \u201cbased on\u201d is intended to mean \u201cbased, at least in part, on\u201d unless explicitly stated otherwise.","The foregoing description has been directed to specific embodiments of the present disclosure. It will be apparent, however, that other variations and modifications may be made to the described embodiments, with the attainment of some or all of their advantages. For example, one or more message-based blocks, such as a verification block, may be configured through a command line Application Programming Interface (API) that may be provided by the message-based object constructor or the verification engine. Therefore, it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the disclosure."],"BRFSUM":[{},{}],"DETDESC":[{},{}]}
