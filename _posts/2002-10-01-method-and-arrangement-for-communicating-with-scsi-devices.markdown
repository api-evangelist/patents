---
title: Method and arrangement for communicating with SCSI devices
abstract: A method and arrangement, for use in a system having a host and one or more small computer system interface (SCSI) devices, are described for enabling a user application accessing the system to communicate with one or more of the SCSI devices. The method and arrangement serve to overcome a device node limitation observed in standard Linux, which limits the number of devices a user application may communicate with to 128 SCSI disk (sd) devices or 256 SCSI generic (sg) devices. The method and arrangement provide a pass through capability by allowing the user application to directly talk to any SCSI device by using virtual handles, thereby overcoming the device node limitation observed in standard Linux.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06934711&OS=06934711&RS=06934711
owner: Hewlett-Packard Development Company, L.P.
number: 06934711
owner_city: Houston
owner_country: US
publication_date: 20021001
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["In a Linux or UNIX operating system (OS) everything that accepts or sends data to or from the operating system is considered to be a \u201cdevice\u201d. Common devices include terminals, hard disks, printers, CD drives, and modems. A rule of thumb is that anything used for input, storage, or handling of data in an OS is considered a device and needs a device entry so that it may be detected by the OS.","All devices communicate in one of two ways; either one character at a time, or as a complete set of data in a predefined block. Therefore, devices can be classified as being either \u201ccharacter mode\u201d or \u201cblock mode\u201d. Terminals, printers, and modems are character devices since they handle data one character at a time. Hard drives and tape drives use blocks to transmit data as large chunks of information so they are block mode devices. Some devices function in either mode using two different device drivers.","Each of these devices may also be SCSI devices. SCSI (small computer system interface) is a family of standards that connects components via a parallel bus for system-level interfacing between a computer and intelligent devices such as hard disks, floppy disks, CD ROMs, printers, scanners and other types of media devices or storage devices. SCSI can connect multiple devices to a single adaptor (e.g., a host bus adapter (HBA) or port) on a SCSI bus. SCSI devices transfer bits in parallel and can operate in either asynchronous or synchronous modes.","A device driver is a software module that is part of the kernel and that supports access to a peripheral device. A device driver is a collection of subroutines and data within a kernel (a kernel is the core software of an OS) that constitutes the software interface to an I\/O device. In Linux, when a device needs to be accessed the Linux kernel passes an I\/O request to the device driver, which handles the communication with the device. Special device files (hereafter \u201cdevice files\u201d) are used to access devices which are connected to a Linux system, devices such as printers, tape drives, terminals and disk drives used for file system storage. Device files are kept in what is called a \/dev directory and are given device file names representative of their function, such as \u201c\/dev\/fd0\u201d for a floppy drive, for example. A device file may be type c (for \u201ccharacter\u201d devices, devices that do not use a buffer cache) or type b (for \u201cblock\u201d devices, which go through a buffer cache). In Linux, all disks are represented as block devices only.","Device numbers allow the operating system to differentiate between the devices. In a standard Linux implementation, each device is assigned a major number and a minor number. The major number identifies the driver, while the minor number identifies the instance of the device. For example, the device file name \u201c\/dev\/fd0\u201d identifies the first floppy drive on a system, with \u201cfd\u201d representing the major number, and \u201c0\u201d representing the minor number of the device file name. Before discussing major and minor numbers in greater detail, however, the Linux SCSI I\/O Subsystem driver architecture and SCSI addressing in Linux is briefly explained.","Driver Architecture Overview.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1","b":["100","110","150","100","1"]},"The ULDs in upper level layer  maintain the kernel side of the Linux OS's user-kernel interface for the logical class of devices they represent (e.g. disks). They are also responsible for managing certain kernel and SCSI subsystem resources such as kernel memory and SCSI command structures. Applications in the user space (e.g., user daemons) access these ULDs by opening a device file (block or char) typically found in the \/dev directory tree.","Accordingly, the upper level layer  supports the kernel\/user interface. For example, in the case of sd (disk) drivers and sr (CD-ROM) drivers, the kernel\/user interface is a block device interface, while for st (tape) drivers and sg (generic) drivers, the kernel\/user interface is a character device interface. Devices can be classified as being either \u201ccharacter mode\u201d or \u201cblock mode\u201d. Terminals, printers, and modems are character devices since they handle data one character at a time. Hard drives and tape drives use blocks to transmit data as large chunks of information so they are block mode devices. Some devices function in either mode using two different device drivers.","The mid-level SCSI layer  is common to all operations. The mid-level SCSI layer  defines internal interfaces and provides common services to the upper and lower level drivers. IOCTLs (input\/output control commands) provided by the mid-level SCSI  layer are available to file descriptors belonging to any of the four ULDs (sd, sr, st, sg device drivers). Any operation using the SCSI subsystem (e.g. reading a sector from a disk) involves one driver at each of the three levels, e.g. sd drivers at upper level , SCSI mid-level driver at SCSI mid level layer  and an HBA driver of lower level layer .","SCSI Subsystem Addressing.","Linux has a four level hierarchical addressing scheme for SCSI devices: (a) SCSI adapter number [host]; (b) channel number [bus]; (c) ID number [target]; and (d) LUN [lun]. The term \u201cLUN\u201d is a common SCSI abbreviation of Logical Unit Number. The LUN identifies the logical unit within a SCSI target device. A SCSI target device is a SCSI device containing logical units (LUs) that service commands from a SCSI initiator device in order to carry out a specified task for example. As is known, a logical unit may be defined as addressable blocks of storage created from one or more disks (also called spindles) contained within a SCSI device. A logical unit may provide a unique connection to an application program or another SCSI device. \u201cBus\u201d is used herein in preference to \u201cchannel\u201d in the description below.","The SCSI adapter number is typically an arbitrary numbering of adapter cards on internal I\/O SCSI buses (e.g. PCI, ISA, etc.) of a computer (Linux host) running the Linux OS. Such adapters are commonly referred to as host bus adapters (HBAs). HBA numbers are issued by the Linux kernel in ascending order, starting with 0 and proceeding for N HBAs. Each HBA may control one of more SCSI buses.","Each SCSI bus can have multiple SCSI devices connected to it. In SCSI parlance, the HBA may be called the \u201cinitiator\u201d (e.g., it may be an HBA of a SCSI initiator device) and takes up one SCSI ID number (typically the number \u201c7\u201d). The initiator talks to targets, commonly also known as SCSI target devices (e.g. disks), as briefly discussed above.","On SCSI parallel buses, the number of SCSI IDs are related to the width of the bus. For example, 8-bit buses (sometimes called \u201cnarrow\u201d SCSI buses) may have 8 SCSI IDs, of which one ID is taken by the HBA, leaving 7 IDs for SCSI devices. Wide SCSI buses are 16 bits wide and can have a maximum of 15 SCSI devices (e.g., targets) attached. The SCSI-3 draft standard allows a large number of IDs to be present on a SCSI bus, (0-255) with each SCSI device adapted to contain multiple (LUNs). These multiple LUNs are typically used by sophisticated tape and CD-ROM units that support multiple media. Accordingly, Linux's flavor of SCSI addressing is a four level hierarchy: <scsi(_adapter_number), channel, id, lun>, which is most commonly known and denoted with <host, bus, target, lun> encoding, i.e., (h0b0t0l0). Thus, a path from a SCSI host to a SCSI device, or to a logical unit represented by a LUN on a SCSI device, can be determined from the (h, b, t, l) address of a logical unit.","Storage area networking is predicated on the replacement of parallel SCSI transport with networked storage SCSI devices and tape SCSI devices behind the server or Linux Host. The vast majority of storage area networks (SANs) use a Fibre Channel (FC) medium for the underlying network transport and, at the upper layer, move data to and from disks with serial SCSI protocol, as described in the current draft SCSI Primary Commands-3 (SPC-3) document. The latest version of the SPC-3 document, found at ftp:\/\/ftp.t10.org\/t10\/drafts\/spc3\/spc3r09.pdf, provides SCSI primary command standards that are designed to be used industry wide. The combination of a high-speed transport (FC) with native SCSI protocol results in an efficient means to deploy servers, disk arrays, and tape subsystems and frees all components from the constraints of parallel SCSI architecture.","The SCSI-3 device driver supplied by the HBA vendor is responsible for mapping FC storage resources to the bus, target, lun conventions required by Linux. Since FC addresses are self-configuring, the mapping between port addresses, (which may change) and the upper level SCSI device driver designations are maintained by the HBA and the HBA's device driver interface to Linux.","The driver architecture and addressing within the SCSI Subsystem having been introduced, device names and their structure are now explained. A device name can be thought of as gateway to a Linux kernel driver (e.g., ULD sd, sr, st, sg) that controls a device rather than a gateway directly to the device itself. Hence there can be multiple device names, some of which may offer slightly different characteristics, all mapping to the same actual device.","The device names of the various SCSI devices may be found within the \/dev directory. Traditionally in Linux, SCSI devices have been identified by their major and minor device number, rather than by their SCSI bus addresses (e.g. SCSI target ID and LUN). Eight block major numbers are reserved for SCSI disks: , , , , , ,  and . Each major number can accommodate 256 minor numbers which, in the case of SCSI disks, are subdivided as follows in the following Table 1:",{"@attributes":{"id":"p-0019","num":"0018"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Device Names for SCSI Disk Devices (sd) - Major No. 8"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[b,8,0]","\/dev\/sda"]},{"entry":[{},"[b,8,1]","\/dev\/sda1"]},{"entry":[{},". . ."]},{"entry":[{},"[b,8,15]","\/dev\/sda15"]},{"entry":[{},"[b,8,16]","\/dev\/sdb"]},{"entry":[{},"[b,8,17]","\/dev\/sdb1"]},{"entry":[{},". . ."]},{"entry":[{},"[b,8,255]","\/dev\/sdp15"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"In Table 1, the disk device names without a trailing digit refer to the whole disk (e.g. \/dev\/sda) while those with a trailing digit refer to one of the 15 allowable partitions within that disk. Linux supports up to 15 partitions per virtual whole disk, so the minor number serves to distinguish partitions form each other. Further, the disk device names without a trailing digit refer to the whole disk (e.g. \/dev\/sda) while those with a trailing digit refer to one of the 15 allowable partitions within the disk.","Table 2 illustrates naming conventions for the remaining seven SCSI disk block major numbers. The remaining 7 SCSI disk block major numbers (e.g., , , , , ,  and  follow a similar pattern:",{"@attributes":{"id":"p-0022","num":"0021"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SCSI Disk Devices (sd) Names - Remaining Major Nos."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[b,65,0]","\/dev\/sdq"]},{"entry":[{},"[b,65,1]","\/dev\/sdq1"]},{"entry":[{},". . ."]},{"entry":[{},"[b,65,159]","\/dev\/sdz15"]},{"entry":[{},"[b,65,160]","\/dev\/sdaa"]},{"entry":[{},"[b,65,161]","\/dev\/sdaa1"]},{"entry":[{},". . ."]},{"entry":[{},"[b,65,255]","\/dev\/sdaf15"]},{"entry":[{},"[b,66,0]","\/dev\/sdag"]},{"entry":[{},"[b,66,1]","\/dev\/sdag1"]},{"entry":[{},". . ."]},{"entry":[{},"[b,66,255]","\/dev\/sdav15"]},{"entry":[{},". . ."]},{"entry":[{},"[b,71,255]","\/dev\/sddx15"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"SCSI CD-ROM devices are allocated the block major number of 11. Traditionally \u201csr\u201d has been the device name, but \u201cscd\u201d probably is more recognizable and is favored by several recent distributions. As shown in Table 3, in Linux, 256 SCSI CD-ROM devices are allowed.",{"@attributes":{"id":"p-0024","num":"0023"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Device Names for SCSI CDROM Devices (scd\/sr)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[b,11,0]","\/dev\/scd0","[or\/dev\/sr0]"]},{"entry":[{},"[b,11,255]","\/dev\/scd255","[or\/dev\/sr255]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"SCSI tape devices (st) are allocated the char major number of 9. Up to 32 tape devices are supported in Linux, each of which can be accessed in one of four modes (, ,  and ), with or without rewind. Device names for the st devices may be allocated as described in Table 4.",{"@attributes":{"id":"p-0026","num":"0025"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Device Names for SCSI Tape Devices (st)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[c,9,0]","\/dev\/st0","[tape 0, mode 0, rewind]"]},{"entry":[{},"[c,9,1]","\/dev\/st1","[tape 1, mode 0, rewind]"]},{"entry":[{},". . ."]},{"entry":[{},"[c,9,31]","\/dev\/st31","[tape 31, mode 0, rewind]"]},{"entry":[{},"[c,9,32]","\/dev\/st01","[tape 0, mode 1, rewind]"]},{"entry":[{},". . ."]},{"entry":[{},"[c,9,63]","\/dev\/st311","[tape 31, mode 1, rewind]"]},{"entry":[{},"[c,9,64]","\/dev\/st0m","[tape 0, mode 2, rewind]"]},{"entry":[{},". . ."]},{"entry":[{},"[c,9,96]","\/dev\/st0a","[tape 0, mode 3, rewind]"]},{"entry":[{},". . ."]},{"entry":[{},"[c,9,127]","\/dev\/st31a","[tape 31, mode 3, rewind]"]},{"entry":[{},"[c,9,128]","\/dev\/nst0","[tape 0, mode 0, no rewind]"]},{"entry":[{},". . ."]},{"entry":[{},"[c,9,160]","\/dev\/nst01","[tape 0, mode 1, no rewind]"]},{"entry":[{},". . ."]},{"entry":[{},"[c,9,192]","\/dev\/nst0m","[tape 0, mode 2, no rewind]"]},{"entry":[{},". . ."]},{"entry":[{},"[c,9,224]","\/dev\/nst0a","[tape 0, mode 3, no rewind]"]},{"entry":[{},". . ."]},{"entry":[{},"[c,9,255]","\/dev\/nst31a","[tape 31, mode 3, no rewind]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"The SCSI generic (sg) devices are allocated the char major number of . As shown in Table 5, there are 256 possible SCSI generic (sg) devices:",{"@attributes":{"id":"p-0028","num":"0027"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Device Names for SCSI Generic Devices (sg)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[c,21,0]","\/dev\/sg0"]},{"entry":[{},"[c,21,1]","\/dev\/sg1"]},{"entry":[{},". . ."]},{"entry":[{},"[c,21,255]","\/dev\/sg255"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"Device names, as embodied by their major and minor numbers, traditional device nodes and the current Linux implementation, have several limitations. Existing major and minor numbers are limited to 8 bits each. This is a limiting factor for some drivers, particularly the SCSI disk device driver, which originally consumed a single major number. Since 4 bits were assigned to the partition index (supporting 15 partitions per disk), this left 4 bits for the disk index. Thus, only 16 disks were supported.","A subsequent change in Linux reserved another seven major numbers for SCSI disks (sd), which has increased the number of supported disks to 128. but large storage arrays, such as RAID arrays, can currently present thousands of logical volumes. However, the current device node implementation stored on normal disk-based-systems in Linux limits the number of devices that can be accessed from user space. For targets (SCSI target devices) that support greater than 128 LUNs we cannot associate all the LUNs greater than 128 with a device node, and hence a physical device file because the Linux SCSI I\/O subsystem cannot support more than 128 device nodes at any point in time.","In other words, the number of SCSI devices which may be detected from the user space is restricted to 128 (in the case of disk devices) and to 256 in the case of generic devices because of the current Linux device node implementation. What is needed is a method and arrangement that enables an application, such as a user application, to detect greater than 128 disk devices (sd), or greater than 256 generic devices (sg), so that the application may communicate with disk devices or generic devices in excess of the current limitation, without modifying the existing device drivers or the underlying Linux SCSI subsystem.","A method and arrangement, for use in a system having a host and one or more small computer system interface (SCSI) devices, are described for enabling a user application accessing the system to communicate with one or more of the SCSI devices. The user application, via an interface, queries a kernel component in the system for all SCSI devices in the system that are known to the kernel component. In response to the query, the kernel component prepares a buffer of virtual handles, where each virtual handle represents a known SCSI device, and forwards the buffer to the user application.","The user application then issues issuing a command which contains the virtual handles and command information to the kernel component. The kernel component compares the virtual handles to a list of SCSI device data structures of known SCSI devices, and transports the command to SCSI devices where there is a match between a virtual handle and a corresponding device data structure of the SCSI device. Thus, a communication path between the user application and one or more SCSI devices is established.","Traditionally in Linux, SCSI devices have been identified by their major and minor device number rather than their SCSI bus addresses (e.g. SCSI target id and LUN). Thus, the current Linux device node implementation limits the number of identifiable (detectable) SCSI devices to 128 SCSI disk (sd) devices or 256 SCSI generic (sg) devices. The method and arrangement of the invention serve to overcome the device node limitation in Linux. The method and arrangement provide a pass through capability by allowing a user application to directly talk to any SCSI device using virtual handles, thereby overcoming the device node limitation observed in standard Linux. Hence, a user mode application can talk to a very large number of SCSI devices.","The method and arrangement of the present invention provide a user library in user space that contains Application Programming Interfaces (APIs) that allow a user application (e.g., application in the user space) to transport any SCSI command to any SCSI device using virtual handles, irrespective of whether the device has a device file representation or not. In this way, a user application may access beyond 128 disk devices or 256 generic devices.","In order to allow the user application to talk to more than 128 disk devices or 256 generic devices without modifying the device drivers or the underlying SCSI subsystem, a filter driver is inserted into the SCSI subsystem between the ULD's and the mid-level SCSI The filter driver provides an application with a set of virtual handles in the form c<host_no>b<channel>t<scsi_id>l<lun>. Using these virtual handles, any SCSI command can be directed to the corresponding SCSI device at a specific (h, b, t, l). Since these handles do not have a device node association, and hence no physical device file limitation, the 128 device file limitation for disk devices or the 256 device file limitation for generic devices is rendered irrelevant.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 2","b":["250","450","255","260","255","260","250"]},"Storage device  may contain a number of disk spindles  (or some type of storage medium such as flash RAM, tape, etc.) that the storage device  uses to persistently store data for consumers of the storage device (e.g., storage consumer ). Storage device  publishes internal storage to consumers by creating logical units  of storage using various methods that match with the storage consumer 's needs. For example, logical units  may be stripped across multiple spindles  to improve throughput, logical units  may be mirrored across multiple spindles  for data resiliency.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 2","FIG. 2"],"b":["270","265","255","275","260","275","260"]},"The dotted lines in  represent the various SCSI paths  from the host consumer  through SAN  to LU B. Internally, the consumer 's operating system (OS) will create named objects to represent the blocks of storage the OS discovered (represented as \u201cDisk B:# T:# LUN:#\u201d, analogous to the h,b,t,l path). In , the \u201chost\u201d (consumer ) has six paths to LU B and has created six different OS objects that ultimately point to the same logical unit of storage. Block  denotes the fact that the contained named objects are all related to the exact same logical unit, in this example LU B.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 3","FIG. 3"],"b":["270","260","250"]},"Sequence  in  depicts the various interactions between user space components and kernel space components within a SCSI subsystem. The user space includes a user application  and a RUID library , as well as a user library  that provides interfaces to the kernel space. The kernel space includes device drivers  (e.g., ULDs sd, st, sr, sg), a kernel component called a filter driver , a unique logical unit identifier database (UID DB ), a mid-level SCSI driver , an HBA driver , and a device (e.g., SCSI device)  on a storage system such as a SAN. Device  may represent one or a plurality of SCSI devices, more particularly one or more logical units (represented by their LUNs) on a SCSI target device (target).","In a preferred embodiment, a kernel component, called a filter driver  is inserted into the SCSI subsystem in kernel space between the device drivers  and mid-level SCSI driver . The filter driver  will \u201cintercept\u201d commands from the user space that normally are directed to the device drivers  (e.g., ULDs sd, sr, st, sg). In Linux, each device driver type (sd, sr, st, sg) of the device drivers  that is known to the OS kernel (not shown) has its scsi_device_template loaded by the kernel. The SCSI subsystem uses the scsi_device_template (s) to call various SCSI type driver routines (e.g., detect(), init(), finish(), attach(), detach() routines, etc.) for each type of SCSI device . However, the inserted filter driver  swaps its own driver routine entry points with the device drivers'  routines, i.e., swapping detect(), attach(), detach(), finish() entry points of the disk, tape, generic device drivers with its own. Thus, the filter driver  may be called by the user application , which also has a copy of the device structures, called scsi_device data structures, which pertain to all LUNs of a discovered device . In a standard Linux implementation, these scsi_device structures to all LUNs of a discovered device  would have been under the exclusive control of the device drivers .","Specifically, the filter driver  looks where these entry points are stored in device drivers , saves a copy for itself, and then overwrites them with its own entry points. That way, the filter driver 's routines would be called instead of the standard ULDs routines. The filter driver  may still call the routines of the other upper layer drivers (device drivers ) if one or more of them are to control a particular LUN (device ). Accordingly, any call for a driver routine will be intercepted by filter driver .","The filter driver , which is an upper level driver (ULD), will create what is called a \/proc entry point for itself, so that it may receive IOCTLs from user application , via user library , which supports interfaces to the kernel space. In other words, the filter driver  creates a point of communication between the user mode space and the kernel mode space for the user application  to send commands across to the kernel space.","Referring to , user application  calls () a function getAllHBTL() in user library , which issues an IOCTL call (), called IOCTL_GET_ALL_HBTL, that is directed towards the \/proc entry of the filter driver . The getAllHBTL() function is one of two API's used by user application . The IOCTL_GET_ALL_HBTL is used to get all h, b, t, l info of all SCSI devices  that the filter driver  knows of in the SCSI subsystem.","The filter driver  has built, in advance, its own unique logical unit identifier database (UID DB) . The UID DB  may consist of a table of in-memory mappings of the scsi_device_pointer (SDP) of each LUN (e.g., device ) that is known to the filter driver , to a unique logical unit identifier (UID). A SDP is a pointer to a scsi_device data structure, which is a data structure that includes host#, bus#, target# (SCSI ID), and LUN fields, (e.g., the h, b, t, l address) to a LUN (logical unit). The UID is a unique identifier, created by the filter driver  and maintained in LID DB , that is independent of the h, b, t, l path mapping to the LUN (logical unit) of a known device . In other words, it is another mechanism by which to identify or detect a device  in the SCSI subsystem. The in-memory mappings of SDPs-to-UIDs are stored in a \u201chash map\u201d In response to the IOCTL call , the filter driver  attempts to \u201cwalk through\u201d the SDPs (at ) for each UID in the hash map of the UID DB , so as to construct a buffer (return ) of <host, bus, target, lun> values for each SDP, essentially parsing out the (h, b, t, l) fields from each known SDP in the hash map.","The IOCTL call  is actually invoked twice in succession: the first time to get the buffer size required (from filter driver ) to hold the (h, b, t, l) addresses parsed out of the UID DB  by the filter driver , and the second time to get the h, b, t, l addresses themselves. Each entry in the buffer is a 32 bit-word consisting of four 8-bit fields (which is converted to a string in user library ) that may be in a format cXbYtZlN where the \u201cc\u201d represents that host information is in the first 8-bit field (portion) of the word, with X being host number, the \u201cb\u201d representing that bus (channel) information is in the next 8-bit field and Y the bus (channel) number, \u201ct\u201d representing that target (SCSI ID) information is in the next 8-bit field with Z being the target number (SCSI ID), and \u201cl\u201d representing that lun information is in the final 8-bit field with N being the logical unit number (e.g., LUN \u201c5\u201d).","The cXbYtZlN is what is called a \u201cvirtual handle\u201d. Virtual handles enable the user application  to access and communicate with a number of SCSI devices in excess of the 128 disk or 256 generic device limitations in standard Linux. In essence, the virtual handles represent a replacement for (or alternative to) a standard device file name, but are not subject to the limitations of device files (e.g., where the number of accessible devices is limited by the device's minor number). The reason for this is that a virtual handle refers to the target (SCSI id) and lun of a SCSI device , rather than to the minor number, of a SCSI device.","Accordingly, any SCSI command can be directed to a corresponding SCSI device at a specific (h, b, t, l) using the cXbYtZlN virtual handle. Since these virtual handles do not have a device node association, there is no device file limitation, so the 128 device file limitation for disk devices or the 256 device file limitation for generic devices are not applicable.","The filter driver  returns () the buffer of virtual handles (in word form) to the user library , and the user library returns () the buffer of virtual handles (after converting the virtual handles to string form) to user application . Now that the user application  has all the cXbYtZlN virtual handles that represent each known SDP, which point to known devices , the user application  may send any SCSI command to any of these devices , even though the actual number of devices  may exceed the standard Linux limitations.","Referring to , user application  builds an inquiry command and calls () a function \u201csendScsiCommandToHBTL\u201d in user library . This function is utilized in order to transport SCSI commands to devices  and get back data and status from the devices . When the function is called to the user library , it issues an IOCTL call  (called IOCTL_SEND_SCSI_COMMAND) that is directed towards the \/proc entry of the filter driver . The IOCTL_SEND_SCSI_COMMAND is the second API used by user application . The IOCTL call  includes a parameter which is a pointer to a transport structure which contains the (h, b, t, l) address at which the SCSI command is to be sent. The transport structure may be configured as shown below.",{"@attributes":{"id":"p-0057","num":"0056"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"unsigned int host;\/\/ the host info of the lun in question . . ."]},{"entry":[{},"unsigned int channel; \/\/ the bus info of the lun in question . . ."]},{"entry":[{},"unsigned int id;\u2003\u2003\/\/ the tgt info of the lun in question . . ."]},{"entry":[{},"unsigned int lun;\u2003\u2003\/\/ the lun info of the lun in question . . ."]},{"entry":[{},"unsigned char * scsi_cmd;"]},{"entry":[{},"int cmd_len; \/\/ the argument as passed to the sg ioctl call . . ."]},{"entry":[{},"unsigned char * scsi_result;"]},{"entry":[{},"int result_len;"]},{"entry":[{},"unsigned char * sense_buffer;"]},{"entry":[{},"int timeout;"]},{"entry":[{},"int result_status;"]},{"entry":[{},"int data_direction;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} transport_info;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The (h, b, t, l) information is obtained by parsing the virtual handles returned from the IOCTL_GET_ALL_HBTL call . The structure being passed as a parameter to the IOCTL call  may include, in addition to the (h, b, t, l) information, the SCSI command structure for the actual SCSI command (as described in the SCSI-2 command standard) that is to be sent, data direction parameters to indicate whether data is to be sent to or received from devices , a pre-allocated result buffer that is to contain device  data returned from the SCSI command, a pre-allocated sense buffer that is to contain information relating to why a SCSI command did not reach an intended device , a timeout value that indicates when the SCSI command times out in the event data is not returned from a device , and other values.","Accordingly, the filter driver  must be configured so as to be able to transport the SCSI command through the mid-level SCSI driver; this entails creating a SCSI request pointer (SRP) (at ). The filter driver  parses the cXbYtZlN from the IOCTL call  and searches () through SDPs in UID DB  to find an SDP which has an (h, b, t, l) address that matches the virtual handle. If there is a match, the SDP is returned () to the filter driver . It is to be understood that the SDP could already have a device file name (e.g., \/dev\/sdaa, \/dev\/sg3, etc) association in the file system space. If so, that device file may also be opened to talk to the device. In such a case, an IOCTL called SCSI_IOCTL_SEND_COMMAND may be directed towards any one of the device drivers  (ULDs), with the SCSI command to be sent as a parameter Even if there is no associated device file name, the user application  is able to send the SCSI command to (and communicate with) a device .","The returned SDP is used to create an SRP. Creation of a SRP is necessary in order to transport the user supplied SCSI command to the SCSI device  using the mid-level SCSI driver . The SRP is created by calling a exported mid-level SCSI function called scsi_allocate_request(), with the SDP as a parameter. This function dynamically creates a structure scsi_request data structure. The SRP is a pointer to that scsi_request data structure. The mid-level SCSI driver  stores a reference to the SDP in the scsi_request structure.","The filter driver  also creates a scsi_cmnd data structure, and a SCSI command pointer (SCP) points to the scsi_cmnd structure. The scsi_cmnd structure is an exported data structure that is contained in kernel memory and is part of the underlying SCSI Subsystem. Thus, it is always available to the filter driver . The scsi_cmnd data structure is added to a device queue of scsi_device structure of a device  using the SDP. A command length of the SRP is set to a user-supplied command length cmd_len from the transport_info structure value described above with respect to IOCTL (). A data direction field in the SRP is also set to the data_direction field in the transport_info structure.","Additionally, the scsi command structure for the actual SCSI command, result buffer, timeout value, etc., are passed as parameters to a mid-level scsi function scsi_wait_req. This function is used to transport the user supplied SCSI command to the scsi_wait_req function. The scsi_wait_req function uses the following arguments to send all SCSI commands out to low level drivers (HBA driver ): SRpnt (request descriptor, e.g., this is the SRP); cmnd (the actual SCSI command to be performed); buffer (the result buffer that is to contain the data return from the SCI command); bufflen (size of the result buffer); done (a completion function to be run); timeout (how long to let SCSI command \u201crun\u201d before timeout); and retries (number of allowable retries to device ). In turn, HBA driver  transports () the SCSI command, initiated from user application , to a SCSI device , since the HBA driver provides the hardware interface to a SCSI device.","The filter driver  waits for a command to complete (e.g., done), which is called by the mid-level SCSI driver , and receives a return () from device , via mid-level SCSI driver . The return could be a result buffer full of data requested by user application , or a sense buffer containing data indicating why the SCSI command was not completed by device . The filter driver  copies the result\/sense buffer () from the SRP to a sense_buffer supplied by the user application  that is contained within a field of the transport_info structure. A command status is copied back to a result_status field of the transport _info structure. The transport info structure is passed back to the user library , since the user library  provides the interface between a component in the kernel space and one in the user space. In turn, the user library  forwards the results to the user application .","As an exemplary application, the user library  may return inquiry data, if the scsi_cmnd data structure sent via function \u201csendScsiCommandToHBTL\u201d from user application  was in the form of a SCSI INQUIRY command. The user application  may parse the inquiry data, which may be payload from one or more of a Device Identification Vital Product Data Page (VPD 83h), Unit Serial Number Vital product Data page (VPD 80h), and a standard inquiry data page returned from device , to see if there is any identifying data of device  that is considered unique. To do so, it may invoke an RUID library  in user space, which is a set of compiled programs or procedures that dynamically (in real time) generates and returns a UID, in user space, to user application .","The RUID library  receives () the inquiry data in order to compute or generate a unique identifier (UID) in the user space. The creation of a UID may be accomplished as described in co-pending U.S. patent application Ser. No. 10\/260415 (to Erickson et al., entitled METHOD AND ARRANGEMENT FOR GENERATING UNIQUE IDENTIFIERS FOR SCSI LOGICAL UNITS, filed on Oct. 1 2002, the contents of which are hereby incorporated by reference in their entirety. For example, the UID library  may concatenate a product serial number field and one or more of the vendor identification, product identification, product revision level, and peripheral device type fields from received standard inquiry page data to identifier data found and cached in the VPD 83h page and\/or VPD 80h page payload. The resultant identifier for the logical unit (LUN) is a globally unique identifier (UID) that is independent of vendor, product, path and logical unit type (e.g. random access magnetic disk, sequential access magnetic tape, etc.). The UID library  utilizes the generated UID in order to create a UID-based file name. The UID-based file name is independent of the (h, b, t, l) path, and provides a persistent identifier for a device  (such as a LUN (logical unit)).","The invention having been thus described the invention may be varied in many ways. For example, the functional blocks in  may be implemented in hardware and\/or software. The hardware\/software implementation may include a combination of processors, application service providers, application specific integrated circuits (ASICs) and\/or articles of manufacture. The articles of manufacture may further include storage media and executable computer program. The executable computer program may include the instructions to perform the described operations. For example, the computer program may be a product that includes a computer-readable medium having computer program logic stored thereon for enabling a processor of the product to communicate with SCSI devices. The computer executable programs may also be provided as part of externally supplied propagated signals. Such variations are not to be regarded as a departure from the spirit and scope of the invention, and all such modifications as would be obvious to one skilled in the art are intended to be included within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention will become more fully understood from the detailed description given here and below and the accompanying drawings which are given by way of illustration only, and thus are not limitative of the present invention, and wherein:",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
