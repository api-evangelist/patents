---
title: Network device drivers using a communication transport
abstract: Network device drivers that interface with a communication transport are described. In one aspect, a networked computing system includes the network device driver and the communication transport. The network device driver converts abstract network device calls to network hardware device specific calls. The network hardware device specific calls are transported from the network device driver via the communication transport to a network hardware device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07735095&OS=07735095&RS=07735095
owner: Microsoft Corporation
number: 07735095
owner_city: Redmond
owner_country: US
publication_date: 20030502
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Appendix I: IDriverDevice.cs","Appendix I: IDriverDevice.cs (cont'd.)","Appendix II: IDriverSwitch.cs","Appendix II: IDriverSwitch.cs (cont'd.)","Appendix II: IDriverSwitch.cs (cont'd.)","APPENDIX III: ITransport.cs","APPENDIX III: ITransport.cs (cont'd.)","APPENDIX III: ITransport.cs (cont'd.)"],"p":["The invention relates to computer systems and networking. More particularly, this invention relates to drivers used for computer systems and networking.","The use of corporate intranets, the Internet, and other complex networks has exploded over the past several years and continues to grow. People have become very comfortable with many services offered on the World Wide Web (or simply \u201cWeb\u201d), such as electronic mail, online shopping, gathering news and information, listening to music, viewing video clips, looking for jobs, and so forth. One useful tool in networking involves the use of network device drivers that allow computers to interface with network hardware devices. Network device drivers often work by converting abstract calls (such as abstract Application Programming Interface [API] calls that are produced by a client) into hardware specific calls (e.g., hardware specific API calls) that can be understood by a network hardware device.","Relatively straight-forward network device drivers are most applicable to simple network configurations with relatively few servers, routers, links, and other such networking components. Unfortunately, as network configurations become more complex, the ability of network device drivers to effectively manage network configurations, and the ability of network device drivers to effectively perform their functions, is diminished. Much human interaction is often used to properly configure the network device drivers to ensure proper operation of the network. Accordingly, there is a need for improved techniques for designing and deploying network device drivers, especially in more complex networked systems.","This disclosure relates to network device drivers that interface using a communication transport. In one embodiment, a networked computing system includes the network device driver and the communication transport. The network device driver converts abstract network device calls to network hardware device specific calls. The network hardware device specific calls are transported from the network device driver via the communication transport to a network hardware device.","The following disclosure describes multiple embodiments of network device drivers for networked software applications using physical computing resources. In one embodiment, the network device driver is a software component that abstracts the functionality of a physical network hardware device to permit a software application to interact with the physical network hardware device without hardware specific knowledge.","One embodiment of a networked computer environment  is shown in . The networked computer environment  includes a networked client computer , a network hardware device , and a network . Certain embodiments of the networked client computer  include a network device solution  and a communication transport . One embodiment of the network device solution  includes a configuration file  and the network device driver .","The configuration file  contains information describing associations between the networked client computer  and each network hardware device . The information contained in the configuration file  is specific to each network hardware device  that it represents, information of the communication transport  (as shown in ), and the software that is related to network management software  as described relative to . In one embodiment, the configuration file  provides information about the communication transport  to be used by the network device driver . As such, the relationship between the network device driver  and the network hardware device  is largely determined based on the information stored within the configuration file . The configuration file  is stored as an eXtensible Markup Language (XML) file that includes information relating to the network device driver  and the network hardware devices.","One illustrative example of the configuration file  that is provided for a specific network hardware device (e.g., an HP ProCurve530 which is produced and distributed by the Hewlett-Packard Company) is provided in Table 1. Other network hardware devices have similar configuration files that are modified appropriately.",{"@attributes":{"id":"p-0019","num":"0018"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Illustrative Configuration File for Network Hardware Device in"},{"entry":"eXtensible Markup Language (XML)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<?xml version=\u201c1.0\u201d encoding=\u201cutf-8\u201d ?>"},{"entry":"- <!-- Configuration file for the HP's ProCurve 5304XL Layer-2"},{"entry":"switch - Oid 1.3.6.1.4.1.11.2.3.7.11.20-"},{"entry":"->"},{"entry":{"u":"-"}},{"entry":"version=\u201c1\u201d>"},{"entry":"\u2003<description oem=\u201cHP\u201d product=\u201cProCurve\u201d model=\u201c5304XL\u201d \/>"},{"entry":"<driverpath=\u201cMicrosoft.Big.Resource.Network.Driver.HP."},{"entry":"ProCurve5304XL.dll\u201d class=\u201cProCurve5304XL\u201d \/>"},{"entry":{"u":"-"}},{"entry":"\u2003<serial baud=\u201c9600\u201d handshake=\u201cnone\u201d readdelay=\u201c100\u201d writedelay="},{"entry":"\u2003\u201c50\u201d \/>"},{"entry":"\u2003<telnet ipv6=\u201cfalse\u201d \/>"},{"entry":"\u2003<\/transports>"},{"entry":"- <!-- Define device specific settings. -->"},{"entry":"\u2003<settings \/>"},{"entry":"\u2003<\/device>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The component of a network device driver  that provides for communication with the physical network hardware device can be the same over multiple network device driver implementations. The network device driver  is scalable to large and\/or diverse networked computer systems such as exist on the corporate intranets, Internet, and other complex networked configurations. Certain embodiments of distributed networks include a plurality of server computers that each handle a portion of the processing tasks or memory tasks for a user or a Website provider. Distributed computing systems are considered as relatively complex due to the associated processing tasks, security aspects, memory tasks, and other networked considerations are divided between multiple server computers.","To perform the abstraction of the network device driver, the network device driver  is a software component which is written to convert between abstract network device Application Programming Interface (API) calls and network hardware device specific API calls. The abstract network device API calls can interface with applications using the networked client computer . The network hardware device specific API calls can interface directly with the network hardware device  using the communication transport  as the media for communicating with the network hardware. The network  can be configured to include (but is not limited to), e.g., a corporate intranet, the Internet, a variety of Local Area Networks (LANs), a variety of Wide Area Networks (WANs), and non networking medias such as RS-232 serial cabling. The network hardware device  may include one or more Network Hardware Device Control Operating Systems  as shown in .","One embodiment of network management software portion  that provides for the association of the network device driver  to a network hardware device  is shown in . In different embodiments, the network management software  shown in  is contained within the network , within the networked client computer  of , or divided there between. In certain embodiments, the network management software  is a runtime environment that includes a \u201ccalls to driver device\u201d portion  and a communication transport . In different embodiments, the communication transport  establishes a communication with the network hardware device and includes a telnet session, an HTTP session, or a session relating to another transport layer protocol. As such, the communication transport may be considered as a transport component that provides session communications with the network hardware device.","The network device driver  utilizes the communication transport  to make specific commands to the network hardware device. The use of the communication transport  that interfaces with (but is operationally distinct from) the network device driver  makes the network device driver more flexible to different network configurations. For example, assume that during operation of the computer environment  as shown in , the transport session between the communication transport  and the network hardware device  changes from a telnet session to an HTTP session. During this change, the configuration and operation of the network device driver  does not have to change. In many configurations, the communication transport  selects the actual media that is established between the network device driver  and the network hardware device.","In one embodiment, the \u201ccalls to driver device\u201d portion  contains some software that can make API driver calls to the network device driver . The call to driver device by the calls to driver device portion  is envisioned to be one of many calls that an API driver can support. As shown in , the API driver calls  generated by the \u201ccalls to driver device\u201d portion  that are transmitted to the network device driver  therefore are abstract calls. The network device driver  converts the abstract calls  that it receives from the calls to driver device  into specific API calls  that are directed to (and are able to interface directly with the hardware of) particular network hardware device(s) . The specific API calls  that are generated from the network device driver  to the communication transport are independent of the type of transport layer between the communication transport  and the network hardware device .","Based on the abstract API call  made to the network device driver  from the calls to driver device portion , the communication transport  sets up the aspects of the transport layer (including, e.g., ports of the network hardware device ). The network device driver  uses the communication transport  to create a specific command (via the specific API call ) that is directed via the communication transport  to the network hardware device .","One embodiment of the communication transport  acts as a proxy, in that it provides a set of methods that are translated into a specific protocol stream, and the specific protocol stream is forwarded as a specific API call  that is carried to the network hardware device over a communication path . The communication path may be, for example, can be based on telnet, HTTP, or some other transport level protocol. Prior to using the communication transport  (one embodiment of which is described relative to ) to communicate API calls as described in this disclosure, the communication transport  can be created.","In one embodiment, the network hardware device  is a standalone device running a foreign operating system (OS), and therefore is not possible to execute code on the network device. The network hardware device  supports a native configuration protocol that the network device driver  (executing on Network Client Computer ) uses the communication transport to interface with the network hardware device . The network device driver  can also be considered as a component that translates \u201cCalls To Driver Device\u201d  to the native configuration protocol supported by the network hardware device  using the communication transport as the media for exchanging the network hardware device native configuration protocol.","For each particular network hardware device , it is therefore important to determine the correct network device driver . As such, in one embodiment, the driver binding process  uses the configuration file  to determine (in many instances automatically, i.e., without any human input) the network device driver  applies to each particular network hardware device .","Once a network device driver  is selected, it is important to be able to interface with the network hardware device . In one embodiment, the actual mechanism to set up the communications between the network device driver  and the network hardware device  is not the network device driver itself. Instead, communications between the network device driver  and the network hardware device  involve the communication transport . In this manner, many embodiments of the network device driver  does not have to interface directly with the hardware of the network hardware device , but instead interfaces using they communication transport .","The driver binding process  includes , which is a request to bind the network device driver  to the network hardware device  as shown in . The remainder of the driver binding process  may be considered as binding the network device driver  to the network hardware device  (and opening the network device driver) that is in response to the request to bind the network device driver  to the network hardware device  as shown in .","One embodiment of the creation of the communication transport  is now described relative to a driver binding process  as described herein relative to . One embodiment of the driver binding process  includes a request to bind the network device driver  (with a communication transport ) to a particular network hardware device . Within different embodiments, the request to bind can be performed using a variety of different mechanisms such as \u201con demand\u201d (e.g., when an application desires to communicate with network hardware device), automatically, within a prescribed time duration, automatically after a certain amount of traffic traverses the network, or using some other triggering mechanism.","The driver binding process  continues to  in which the network device configuration file  (one embodiment shown in ) is loaded. Each network device solution  has a distinct Object Identifier (OID) associated therewith by which such networks as intranets and the Internet can positively identify that network device solution. It is envisioned that there are a variety of mechanisms that can be used to link network hardware devices including configuration files using the OIDs. However, any known mechanism that links the network hardware devices are intended to be within the intended scope of the present disclosure. In addition, each network hardware device  is also provided with a unique identifier. The OID is used in certain embodiments of the present disclosure to bind the network device driver  to the network hardware device . In one embodiment, the appropriate network hardware device  value is determined based on the OID of the network hardware device.","The configuration file  contains information describing how to build and\/or generate the communication transport . The driver binding process  continues to  in which the network management software portion  as shown in  creates the communication transport  for a particular network hardware device  based on the information contained in the configuration file . In one embodiment, the communication transport  is created within the network management software  as shown in . In one embodiment, the communication is created by the network management software and provided to the network device driver. One embodiment of a communication transport would provide asynchronous Input\/Output and diagnostic tracing support. The communication transport  is created for one network hardware device . Therefore, one communication transport  is envisioned to be \u201ccreated\u201d for each network hardware device in one embodiment.","The driver binding process  continues to  in which the network driver device  that is associated with the communication transport  is opened (using an OPEN call in one embodiment), thereby providing the communication transport to be used for communications. The OPEN call is a high level API call that is used to pass a pointer to the communication transport  (or an indicator of the communication transport, or the communication transport itself) to the network device driver . Once the OPEN command is applied in which the network device driver is opened in , the binding process requested in  is completed. Following the OPEN command, the network device driver  has a link to the communication transport  that it can use to communicate with the network hardware device .  shows an established network configuration that uses the network hardware device  as established using the embodiment of driver binding process  shown in .","Following the driver binding process as described relative to , the network device driver  is bound to at least one network hardware device  via the communication transport , and the normal operation of the network management software  can then provide network communications as described relative to .","Such binding of the network device driver  to the network hardware device  can in certain embodiments of the present disclosure occur automatically within a computer environment as described relative to . Alternatively, network management techniques can allow a network manager (i.e., human) to configure the network device driver  and the communication transport  as desired. The level that the binding process that is automated can be determined by the user in certain embodiments.","Along with greater acceptance of such networks  as intranets and the Internet (that all require a very large number of networked client computers) comes an associated interference with the increased number of network hardware devices (such as server computers, routers, hubs, switches, etc.) that are used to provide services to users. As such, the network device driver  can be configured to adapt to a greater variety of networked configurations. Increasing the configuration of the network device driver (and the topology of the network itself) acts to reduce the amount of network manager and other human involvement in configuring the network. As networked systems become larger and faster, more complex network configurations (such as enterprise networks) become inevitable, and the importance for an automated system to provide network device drivers  becomes more pronounced.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIGS. 4 and 5","FIG. 4","FIGS. 2 and 4","FIG. 1","FIG. 6"],"b":["250","606","608","610","612","614","250","62","102","250"]},"The embodiment of network management software  as shown in  assumes knowledge of all network hardware and the wiring topology between network hardware devices and the network hardware of the client computer. The network management software  uses this knowledge to load the appropriate network hardware device providers and to perform multi-device updates that depend on the wiring topology of the managed network domain. The collection of network hardware and topology within the managed network domain can be obtained by direct operator input, active discovery or passive discovery.","The collection of network hardware and topology within the managed network domain is obtained by direct operator input from the direct operator input portion , active discovery from the active discovery portion , or passive discovery from the passive discovery portion . The network management software API is called to register a network hardware device or computer and specify topology information.","In one embodiment, the direct operator input portion  provides direct operator input for network management of network hardware devices  as shown in . By using the direct operator input, the operator can directly specify the network hardware device and topology via a network management tool that will call the appropriate network management software APIs  to register the network hardware device or computer and specify topology information. This section relates to the high level management component of the network management software. The network management software APIs  are external public APIs that define the network topology to the network management software. In one embodiment, a development tool is provided to import and export the managed network domain configuration in XML format.","The active discovery portion  can provide active discovery for network management of network hardware devices by, in certain embodiments, including the process of \u201cpinging\u201d a known range of IP addresses. Pinging provides for the discovery of the existence of associated network hardware devices, and then a Simple Network Management Protocol (SNMP) query is used to obtain specifics on the device.","The passive discovery portion  can, in certain embodiments, provide passive discovery for network management of network hardware devices. Passive discovery includes the process of listening to network traffic to identify new network and\/or computer devices. When a new device is detected, a Simple Network Management Protocol (SNMP) query is performed to obtain specifics on the device.","One embodiment of the present disclosure provides a mechanism for positively identifying network hardware devices using SNMP devices and techniques (e.g., involving Management Information Bases (MIBs)). In one embodiment, all network and computer resources within the network management domain support the SNMP MIB-II (RFC 1213\u2014incorporated by reference in its entirety) standard. The \u201csystem\u201d group within the MIB-II (RFC 1213) standard specifies a \u201csysObjectID\u201d which uniquely identifies the device (network or computer). The complete description of the \u201csysObjectID\u201d is also provided within the RFC-1213.","\u201cThe vendor's authoritative identification of the network management subsystem is contained in the entity. This value is allocated within the SMI enterprises subtree (e.g., 1.3.6.1.4.1) and provides an easy and unambiguous means for determining \u2018what kind of box\u2019 is the network hardware device that is being managed. For example, if an exemplary vendor \u2018Flintstones, Inc.\u2019 was assigned the subtree using the network hardware device's Object Identifier (OID), e.g., 1.3.6.1.4.1.4242, it could assign the OID of an included node, such as 1.3.6.1.4.1.4242.1.1, to one of its network hardware devices, e.g., \u2018Fred Router\u2019.","Since the network hardware device's Object Identifier (OID)  is unique to each network hardware device  as shown in , this value is used to locate the matching network hardware device provider (also referred to as driver solution). As such, each network hardware device  is referenced by a unique OID . Table 2 shows examples of a plurality of exemplary OIDs.",{"@attributes":{"id":"p-0047","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Object Identifiers for Network Hardware Devices"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Network Hardware Device Object Identifiers"]},{"entry":["Device","(OID)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Cisco Catalyst 2900XL","1.3.6.1.4.1.9.1.220"]},{"entry":["Cisco Catalyst 3550","1.3.6.1.4.1.1991.1.3.24.4"]},{"entry":["Foundry BigIron 8000","1.3.6.1.4.1.1991.1.3.7.2"]},{"entry":["Foundry FastIron 1500","1.3.6.1.4.1.1991.1.3.24.1"]},{"entry":"Switch"},{"entry":["HP ProCurve 5304XL","1.3.6.1.4.1.11.2.3.7.11.20"]},{"entry":"Switch"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"These appendices are provided in this disclosure to provide embodiments of Application Programming Interfaces (APIs) that can be used by the computer environment  as shown in . APPENDIX I represents exemplary code (in the form of APIs) for one embodiment of the network device driver that defines an IDriverDevice interface for abstracting all network hardware devices as shown in Appendix I. This API shown in APPENDIX I can be exposed by network device driver  when running a computer. The network device driver  is therefore an instance of an object as set forth by the IDriverDevice.cs class.","APPENDIX II represents exemplary code in the form of APIs that are associated with one embodiment of the driver switch that defines the interface for communicating with network layer-2 switch device drivers. Therefore, in one embodiment, the driver switch is an instance of an object as set forth by the IDriverSwitch.cs class. While the APPENDIX II code is directed to an interface for a network switch as one embodiment of network hardware device , it is envisioned that different embodiments of network hardware devices such as routers, load balancers, etc. will have a similar interface (and therefore similar APIs) as that illustrated in APPENDIX II.","APPENDIX III represents exemplary code (in the form of APIs) for one embodiment of the communication transport  as described in this disclosure relative to . These APIs represent one embodiment of the base interface used for communications with the network hardware devices. Therefore, in one embodiment, the communication transport  described relative to  is an instance of an object as set forth by the ITransport.cs class, one embodiment as set forth in APPENDIX III.","The creation of different custom network topologies for varied applications hosted on the same computing system can benefit from the automatically generated network device drivers  as disclosed herein. Such automatically generated network device drivers  and automatically generated network topologies are particularly helpful for large datacenters, which are complex and often called upon to host multiple applications. Distributed applications, such as installed at prior-art datacenters, often have complex networking requirements, and building physical network topologies to conform to these requirements can be a cumbersome, time consuming process that is prone to human error. Enabling automatic generation of network device drivers  and virtual network topologies that do not require physical re-configuration of the computing system for each deployed application (e.g., rerouting wiring, physically connecting computers to various switches, etc.) reduces the dependence on human-centric operations, thereby reducing costs and the likelihood of human error.","One embodiment of a network  includes an Internet data center (IDC)  as shown in . The IDC  is a specifically designed complex that houses many server computers  for hosting Internet-based services. IDCs  (that also go by such names as \u201cWebfarms\u201d and \u201cserver farms\u201d) typically house hundreds to thousands of server computers  in climate-controlled, physically secure buildings. These server computers  are interconnected and networked to run one or more programs supporting one or more intranet or Internet services or websites. Automating the set up of the communications between the computer device as provided by certain embodiments of the present disclosure has become especially important for such complex computer systems as IDCs. IDCs  provide reliable intranet\/Internet access, reliable power supplies, and a secure operating environment. Another type of networked computer system is an enterprise data centers (EDC). EDCs are similar to IDCs, but are targeted to enterprise networks.","The embodiment of IDC  shown in  has many server computers  (that may be, for example, arranged in a specially constructed room). The server computers  are general-purpose computers, and are typically configured as servers although other types of computers such as PCs, mainframes, etc. can be substituted. One embodiment of the IDC  may be constructed to house a single site for a single entity (e.g., a data center for Yahoo! or MSN), or to accommodate multiple sites for multiple entities (e.g., an Exodus center that host sites for multiple companies). The IDC  is illustrated with a plurality of entities-entity A, entity B, and entity C. Each entity shares the computer resources. In one aspect, these entities represent various companies that want a presence on the Web.","The present disclosure provides a mechanism to generate network device drivers that can interact with, and be bound to, a network hardware device. Such configuration of network hardware devices can be performed automatically to arbitrarily generate a variety of network configurations based on the network device driver configuration. Arbitrary network topologies in which physical network hardware devices such as those in IDCs  as shown in",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 7","FIGS. 1 and 3","FIG. 7"],"b":["300","200","308","300","302","200","304","200"]},"A network management layer  sits atop the automated deployment services layer . The network management layer  allows for network management and virtual topology generation. In part, the network management layer supports a driver model for network computers that facilitates the connection of individual computers to one or more VLANs via a single physical network interface connected to an associated port of the network hardware devices such as network switches. According to the driver model, a VLAN driver is installed at the server and used to create virtual network interfaces (VNICs) above the single physical network interface. The VLAN driver creates one virtual network interface (VNIC) for each VLAN. The VNICs reside just above the network interface (NIC) in the IP stack at the server so that the server can handle packets passed over more than one VLAN, even though all packets physically travel through the same physical NIC.","The driver model enables configuration of VLAN tagging on switch ports to allow data packets that are passed over the networked computing system to be tagged with identities of the VLAN to which they belong. The network hardware devicees  enforce the tagging and only accept packets with tags identifying the VLANs to which the switches belong. In one implementation, the network hardware devicees  have both tagged ports and non-tagged ports. Tagged ports of a switch are tagged with VLANs identifiers and used for connection to tagged ports of other switches. This allows rapid transfer of packets through the network of switches. Untagged ports of a switch are used for connection to the servers or computers. When packets reach their destination server's switch port, VLAN tags are stripped from the packets prior to communicating the packets upstream to the servers so that the servers need not know anything about the tagging.","A physical resource management layer  resides atop the network management layer . The physical resource management layer  maintains a physical model of the networked computing system, tracking ownership and coordinating allocation of all physical computing resources. In one embodiment, the network management software portion  as described relative to  in this disclosure falls within the physical resource management layer  as described relative to . The physical management layer  further supports driver binding, and batched resource allocation, thereby enabling dynamic configuration and management of physical computing resources.","A logical resource management layer  sits atop the physical resource management layer . The logical resource management layer  facilitates allocation of logical resources requested by the networked application. For instance, the application might call for such resources as databases, load balancing services, firewall, web services, and so forth. The logical resource management layer  exposes such logical resources.","The next layer is the service definition model and runtime layer , which allows description of the networked application and tracking of its operation. The service definition model (SDM) provides a namespace and context for describing operations processes and an API for application introspection and control of application resources. It further enables operators and developers to share common application views.","The sixth layer atop the computing resources layer  is the components layer . This layer permits definition of reusable building blocks of a networked application, which use the SDM APIs for context, naming, and binding. These building blocks are referred to as \u201ccomponents\u201d.","The top layer is the operations logic layer , which accommodates the operational aspects of the networked application. The operations logic is responsible for starting a service, growing and shrinking the service, upgrades and downgrades, fault detection and recovery, and state partitioning. The operations logic enables reuse of proven operational practices across deployments and applications. Through use of the SDM layer, the operations logic has context to better understand issues that may arise. For instance, when a failure occurs, the operations logic can determine that the failure occurred at the front-end of an email service, rather than just at some server in the middle of the room.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 8","FIGS. 1 and 3"],"b":"500"},"The computer environment  illustrated in  is a general computer environment, which can be used to implement the techniques described herein. The computer environment  is only one example of a computer environment and is not intended to suggest any limitation as to the scope of use or functionality of the computer and network architectures. The embodiment of the computer environment  as described herein represents one embodiment of computer environment  as described relative to . The computer environment  should not be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary computer environment .","The computer environment  includes a general-purpose computing device in the form of a computer . The computer  can be, for example, one or more of a stand alone computer, a networked computer, a mainframe computer, a PDA, a telephone, a microcomputer or microprocessor, or any other computer device that uses a processor in combination with a memory. The components of the computer  can include, but are not limited to, one or more processors or processing units  (optionally: including a cryptographic processor or co-processor), a system memory , and a system bus  that couples various system components including the processor  and the system memory .","The system bus  represents one or more of any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. By way of example, such architectures can include an Industry Standard Architecture (ISA) bus, a Micro Channel Architecture (MCA) bus, an Enhanced ISA (EISA) bus, a Video Electronics Standards Association (VESA) local bus, and a Peripheral Component Interconnects (PCI) bus also known as a Mezzanine bus.","The computer  typically includes a variety of computer readable media. Such media can be any available media that is accessible by the computer  and includes both volatile and non-volatile media, and removable and non-removable media.","The system memory  includes the computer readable media in the form of non-volatile memory such as read only memory (ROM) , and\/or volatile memory such as random access memory (RAM) . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within the computer , such as during start-up, is stored in the ROM . The RAM  typically contains data and\/or program modules that are immediately accessible to, and\/or presently operated on, by the processing unit .","The computer  may also include other removable\/non-removable, volatile\/non-volatile computer storage media. By way of example,  illustrates a hard disk drive  for reading from and writing to a non-removable, non-volatile magnetic media (not shown), a magnetic disk drive  for reading from and writing to a removable, non-volatile magnetic disk  (e.g., a \u201cfloppy disk\u201d), and an optical disk drive  for reading from and\/or writing to a removable, non-volatile optical disk  such as a CD-ROM, DVD-ROM, or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are each connected to the system bus  by one or more data media interfaces . Alternatively, the hard disk drive , magnetic disk drive , and optical disk drive  can be connected to the system bus  by one or more interfaces (not shown).","The disk drives and their associated computer-readable media provide non-volatile storage of computer readable instructions, control node data structures, program modules, and other data for the computer . Although the example illustrates a hard disk within the hard disk drive , a removable magnetic disk , and a non-volatile optical disk , it is to be appreciated that other types of the computer readable media which can store data that is accessible by a computer, such as magnetic cassettes or other magnetic storage devices, flash memory cards, CD-ROM, digital versatile disks (DVD) or other optical storage, random access memories (RAM), read only memories (ROM), electrically erasable programmable read-only memory (EEPROM), and the like, can also be utilized to implement the exemplary computer environment .","Any number of program modules can be stored on the hard disk contained in the hard disk drive , magnetic disk , non-volatile optical disk , ROM , and\/or RAM , including by way of example, the OS , one or more application programs , other program modules , and program data . Each OS , one or more application programs , other program modules , and program data  (or some combination thereof) may implement all or part of the resident components that support the distributed file system.","A user can enter commands and information into the computer  via input devices such as a keyboard  and a pointing device  (e.g., a \u201cmouse\u201d). Other input devices  (not shown specifically) may include a microphone, joystick, game pad, satellite dish, serial port, scanner, and\/or the like. These and other input devices are connected to the processing unit  via input\/output interfaces  that are coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port, or a universal serial bus (USB).","A monitor, flat panel display, or other type of computer display  can also be connected to the system bus  via an interface, such as a video adapter . In addition to the computer display , other output peripheral devices can include components such as speakers (not shown) and a printer  which can be connected to the computer  via the input\/output interfaces .","Computer  can operate in a networked environment using logical connections to one or more remote computers, such as a remote computer device . By way of example, the remote computer device  can be a personal computer, portable computer, a server, a router, a network computer, a peer device or other common network node, game console, and the like. The remote computer device  is illustrated as a portable computer that can include many or all of the elements and features described herein relative to the computer .","Logical connections between the computer  and the remote computer device  are depicted as a local area network (LAN)  and a general wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet.","When implemented in a LAN networking environment, the computer  is connected to a local network  via a network interface or adapter . When implemented in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the wide network . The modem , which can be internal or external to the computer , can be connected to the system bus  via the input\/output interfaces  or other appropriate mechanisms. It is to be appreciated that the illustrated network connections are exemplary and that other means of establishing communication link(s) between the computers  and  can be employed.","In a networked environment, such as that illustrated with the computer environment , program modules depicted relative to the computer , or portions thereof, may be stored in a remote memory storage device. By way of example, remote application programs  reside on a memory device of the remote computer . For purposes of illustration, application programs and other executable program components such as the operating system are illustrated herein as discrete blocks, although it is recognized that such programs and components reside at various times in different storage components of the computer , and are executed by the data processor(s) of the computer . It will be appreciated that the network connections shown and described are exemplary and other means of establishing a communications link between the computers may be used.","Various modules and techniques may be described herein in the general context of the computer-executable instructions, such as program modules, executed by one or more computers or other devices. Generally, program modules include routines, programs, control objects, components, control node data structures, etc. that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments.","An implementation of these modules and techniques may be stored on or transmitted across some form of the computer readable media. Computer readable media can be any available media that can be accessed by a computer. By way of example, and not limitation, computer readable media may comprise \u201ccomputer storage media\u201d and \u201ccommunications media.\u201d","\u201cComputer storage media\u201d includes volatile and non-volatile, removable and non-removable media implemented in any process or technology for storage of information such as computer readable instructions, control node data structures, program modules, or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by a computer.","\u201cCommunication media\u201d typically embodies computer readable instructions, control node data structures, program modules, or other data in a modulated data signal, such as carrier wave or other transport mechanism. Communication media also includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared, and other wireless media. Combinations of any of the above are also included within the scope of computer readable media.","Although the systems and processes have been described in language specific to structural features and\/or process, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or steps described. Rather, the specific features and steps are disclosed as preferred forms of implementing the claimed invention.","public interface IDriverDevice","The IDriverDevice interface abstracts network hardware device configuration.","The IDriverDevice interface provides an interrelation between the IDriverDevice, the IDriverSwitch, the IDriverRouter, the IDriverFirewall, and the IDriverLoadBalancer.","bool MustReset {get;}","The MustReset process is used to determine if a reset of the device is required to apply settings. For example, some devices require a reset after changing the IP address. MustReset returns True if the Reset method is called to apply the change.","The MustReset property can only be set true while pre-setup initialization of a network hardware device.","bool MustSave {get;}","The MustSave process is used to determine if the current configuration has been changed. If MustSave is true, the ConfigurationSave( ) method should be used to persist settings over a reboot. MustSave returns True if configuration changes were made since the last save.","DriverState State {get;}","The DriverState.State process gets and sets the driver state.","void Close( )","The Close process logs off from the network hardware device.","void Open(XmlNode settings, ITransport transport, IDriverCredential credential)","The Open process opens the device driver with the specific settings from the device's XML configuration file as the XmlNode instance.","void Reset( )","The Reset process resets the network hardware device, and will cause the network hardware device to reboot and reload configuration settings from the default location.","void SaveConfiguration( )","The SaveConfiguration process saves the current configuration to the default non-volatile memory location. This is the configuration location used on a powerup reboot or reset. The dirty property \u2018MustSave\u2019 is set to false.","void Set Configuration(DriverDeviceConfiguration configuration)","The SetConfiguration process sets the configuration of the network hardware device.","The SetConfiguration API has one parameter, \u201cconfiguration.\u201d With <param name=\u201cconfiguration\u201d>the device configuration is set.","public interface IDriverSwitch:IDriverDevice","The IDriverSwitch interface abstracts layer-2 switch configuration which involves software for devices such as the IDriverDevice, the IDriverSwitch, and the IDriverRouter.","Int DefaultVlanId {get;}","The DefaultVlanId process returns the VLAN identifier that represents the default VLAN. In one embodiment, the returned value is in the range of 1.4095.","DriverAddress ManagementIPAddress {get; set;}","The DriverAddress ManagementIPAddress process gets or sets the management IP address and subnet mask of a device.","IPAddress ManagementIPGateway {get; set;}","The IPAddress ManagementIPGateway process gets or sets the management IP default gateway of a device.","int MaxVlans {get;}","The int MaxVlans {get;} process gets the maximum number of VLANs supported by this device.","int UpperVlan {get;}","The UpperVlan process gets the upper VLAN id range supported by the device.","void AttachPortToVlan(string portName, int vlanId, bool tagged)","The AttackPortToVlan process attaches a specific switch port to a VLAN as tagged or untagged.","The AttackPortToVlan process includes three parameters: portName, vlanId, and tagged.",{"@attributes":{"id":"p-0104","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<param name=\u201cportName\u201d>Port on the switch to attach."},{"entry":"<param name=\u201cvlanId\u201d>VLAN to attach port to."},{"entry":"<param name=\u201ctagged\u201d>Indicates if the port is in tagged or untagged"},{"entry":"mode."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The CreateLayer2Vlan process creates a 802.1q VLAN on the layer-2 switch.","The CreateLayer2Vlan process includes two parameters: vlanId and vlanName.",{"@attributes":{"id":"p-0107","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<param name=\u201cvlanId\u201d>VLAN tagged identifier to create."]},{"entry":[{},"<param name=\u201cvlanName\u201d>Optional name of the VLAN to create."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"void DeleteLayer2Vlan(int vlanId)","The DeleteLayer2Vlan process deletes an existing 802.1q VLAN from the layer-2 switch. Any attached ports are automatically released. The DeleteLayer2Vlan process includes one parameter vlanId wherein <param name=\u201cvlanId\u201d>VLAN identifier to delete.<\/param>","void DetachPortFromVlan(string portName, int vlanId, bool tagged)","The DetachPortFromVlan process detaches a device port from a VLAN. The DetachPortFromVlan process includes three parameters: portName, vlanId, and tagged.",{"@attributes":{"id":"p-0110","num":"0109"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<param name=\u201cportName\u201d> acts to detach port."},{"entry":"<param name=\u201cvlanId\u201d>acts to detach port from VLAN"},{"entry":"<param name=\u201ctagged\u201d>Indicates if the port is in tagged or untagged"},{"entry":"mode."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The EnablePortTaggedMode process sets the tagged mode on a port.","The EnablePortTaggedMode process includes two parameters: portName and tagged.",{"@attributes":{"id":"p-0113","num":"0112"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<param name=\u201cportName\u201d>Port to enable\/disable tagged mode."]},{"entry":[{},"<param name=\u201ctagged\u201d>Indicates the new tagged mode to set."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The GetPort process returns an IDriverPort instance that represents a snapshot (copy) of the port specified by interface name.","The GetPort process includes one parameter: portName.","<param name=\u201cportName\u201d>Port to retrieve status of IDriverPort","GetVlan(int vlanId)","The GetVlan process returns a collection of all ports by its interface name \u201cDriverPortNameCollection GetPortNames( )\u201d","The GetVlan process returns an IDriverVlan interfaces that represents a snapshot (copy) of the specified VLAN state on the device.","The GetVlan process includes one parameter: vlanId.","<param name=\u201cvlanId\u201d>VLAN to retrieve status of IDriverVlan","DriverVlanIdCollection GetVlanIds( )","The GetVlanIds process returns a collection of all VLANs by identifier (1 to 4095).","int Ping(IPAddress ip)","The Ping process issues a remote ping from the switch to the target IP address.","The Ping process includes one parameter: ip.","<param name=\u201cip\u201d>IP address to ping from the switch.","The Ping process returns the time (in milliseconds) of the returned echo.","bool QueryLayer2VlanExist(int vlanId)","The QueryLayer2VlanExist process queries for the existances of a 802.1q VLAN on the layer-2 switch.","The QueryLayer2VlanExist process includes one parameter: vlanId.","<param name=\u201cvlanId\u201d>VLAN identifier to query for.","The QueryLayer2VlanExist process returnsTrue if found, or else returns false.","void SetPortEnabled(string portName, bool enable)","The SetPortEnabled process enables or disables a port on the device.","The SetPortEnabled process includes two parameters: portNasme and enable.",{"@attributes":{"id":"p-0132","num":"0131"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<param name=\u201cportName\u201d>Port to enable or disable."]},{"entry":[{},"<param name=\u201cenable\u201d>New enable\/disable state of the port."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"public interface ITransport:IDisposable","ITransport is the base interface for a number of transport related interfaces used to define the physical communication path from PC running the device driver code to the network hardware device.","int Available {get;}","The Available process gets the amount of data that has been received from the transport and is available to be read.","bool Logging {get; set;}","The Logging process gets or sets a value indicating whether this transport writes debugging logging information to any installed trace listeners. Logging is general raw data dumps of communications to\/from the network hardware device.","int ReceiveTimeout {get; set;}","The ReceiveTimeout process gets or sets the amount of time a transport will wait to receive data once a read operation is initiated.","The ReceiveTimeout value is the time-out value of the connection in milliseconds","The default value is 0.","The ReceiveTimeout property determines the amount of time that the Read method will block until it is able to receive data. This time is measured in milliseconds. If the time-out expires before Read successfully completes, the transport will throw a TransportTimeoutException. There is no time-out by default.","int SendTimeout {get; set;}","The SendTimeout process gets or sets the amount of time a transport will wait for a send operation to complete successfully.","The value of the SendTimeout is the send time-out value, in milliseconds. The default is 0.","The SendTimeout property determines the amount of time that the Send method will block until it is able to return successfully. This time is measured in milliseconds.","IAsyncResult BeginRead(byte[ ] buffer, int offset, int size, AsyncCallback callback, object state)","The BeginRead process begins to asynchronously receive data from a connected transport. The BeginRead process includes five parameters: buffer, offset, size, callback, and state.<\/summary>",{"@attributes":{"id":"p-0144","num":"0143"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<param name=\u201cbuffer\u201d>The storage location for the received data."},{"entry":"<param name=\u201coffset\u201d>The zero-based position in the buffer parameter at"},{"entry":"which to store the received data."},{"entry":"<param name=\u201csize\u201d>The number of bytes to read."},{"entry":"<param \/\/\/name=\u201ccallback\u201d>The delegate to call when the async call is"},{"entry":"complete."},{"entry":"<param name=\u201cstate\u201d>An object containing information supplied by the"},{"entry":"client."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The BeginRead process returns An IAsyncResult representing the asynchronous call.","IAsyncResult BeginWrite(byte[ ] buffer, int offset, int size, \/\/\/AsyncCallback callback, object state)","The BeginWrite process writes data asynchronously to a connected transport.","The BeginWrite process includes five parameters: buffer, offset, size, callback, and state.",{"@attributes":{"id":"p-0148","num":"0147"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<param name=\u201cbuffer\u201d>The location in memory that holds the data to"},{"entry":"send."},{"entry":"<param name=\u201coffset\u201d>The location in buffer to begin sending the data."},{"entry":"<param name=\u201csize\u201d>The size of buffer."},{"entry":"<param name=\u201ccallback\u201d>The delegate to call when the async call is"},{"entry":"complete."},{"entry":"<param name=\u201cstate\u201d>An object containing information supplied by the"},{"entry":"client."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The BeginWrite process returns An IAsyncResult representing the asynchronous call.","void EndRead(IAsyncResult asyncResult)","The EndRead process handles the end of an asynchronous read.","The EndRead process includes one parameter: asyncResult.","<param name=\u201casyncResult\u201d>An IAsyncResult representing an asynchronous call.","The EndRead process returns the number of bytes read from the transport.","void EndWrite(IAsyncResult asyncResult)","The EndWrite process handles the end of an asynchronous write. The EndWrite process includes one parameter \u201casynchResult.",{"@attributes":{"id":"p-0155","num":"0154"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<param name=\u201casyncResult\u201d>The IAsyncResult representing the"]},{"entry":[{},"asynchronous call."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"int Read(byte[ ] buffer, int offset, int count)","The Read process reads data from the communication transport. The Read process includes three parameters: buffer, offset, and count.",{"@attributes":{"id":"p-0157","num":"0156"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<param name=\u201cbuffer\u201d>The location in memory to store data read from"},{"entry":"the stream."},{"entry":"<param name=\u201coffset\u201d>The location in the buffer to begin storing the"},{"entry":"data."},{"entry":"<param name=\u201ccount\u201d>The number of bytes to read. The Read process"},{"entry":"returns the number of bytes read from the stream."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The Write process writes data to the stream.","The Write process includes three parameters: buffer, offset, anhd size.",{"@attributes":{"id":"p-0160","num":"0159"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<param name=\u201cbuffer\u201d>The data to write to the stream."},{"entry":"<param name=\u201coffset\u201d>The location in the buffer to start writing data"},{"entry":"from."},{"entry":"<param name=\u201csize\u201d>The number of bytes to write."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The same numbers are used throughout the specification to reference like features and components.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
