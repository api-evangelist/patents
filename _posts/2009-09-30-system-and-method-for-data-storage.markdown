---
title: System and method for data storage
abstract: One embodiment operates a computer system for storing and retrieving data from a data store. The computer system has a data manager device operable to manage patterns in the stored data along with pointers relating to the patterns in a manner which enables reconstruction of the stored data in original form.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08386436&OS=08386436&RS=08386436
owner: RainStor Limited
number: 08386436
owner_city: Gloucester
owner_country: GB
publication_date: 20090930
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This application is a national-stage entry of International Patent Application No. PCT\/GB2009\/002331, filed Sep. 30, 2009, entitled \u201cSystem and Method for Data Storage\u201d, which claims priority to United States Provisional Patent Application No. 61\/101,553, filed Sep. 30, 2008, entitled \u201cCommunication Systems\u201d.","The present invention relates generally to data storage. More specifically, the embodiments of the invention relate to the various systems and methods for archiving and database management which, in particular, allow use of legacy data without substantial or any data modification.","Many businesses and other organizations employ some form of large scale data storage as part of their information infrastructure. Many organizations store hundreds of terabytes, and even multiple petabytes (each of which is 1,000 terabytes), of data to facilitate routine business and record keeping. Data is added to these archives in a periodic fashion. Every week\/month\/year, or at whatever period the administrators (also referred to herein as \u201cusers\u201d) of the application deem appropriate, data is removed from a production system and put into the archive. However, this new data may not be in the same format as the data already in the archive. In this context, a production system is any computer system or program running on a computer system operable to produce data tables, transmit said data tables to an archive and receive data back from said archive, in one format or another.","As time elapses, the nature or requirements of the applications whose data is being archived changes. For example, new data may be collected and stored in new columns in an existing table, or the accuracy with which data is stored may change (in other words the \u201ctype\u201d of the column changes). Alternatively data that is no longer needed is not collected and the column is dropped from the table. When any of these changes occur (or other structural changes are made to the database) there remains the question of what happens to the data that is already archived. Some alternatives are listed below:","1. The archived data can all be recovered, have the same changes applied to it, and be resaved with those changes in place. However, not only is this a lengthy and expensive process, but also if the original data was archived for compliance purposes then there are potential issues with this form of recovery, since some part of the original data may no longer be stored. For example, casting a database field to a type with less precision (for instance reducing the number of decimal places of a fixed point type) will cause irrevocable data loss to the older archived data.","2. Take no action and leave the archived data unchanged. However, this will present problems when the data in the archive is queried. If the data is stored with multiple different schemas, it will be necessary to use different queries in each schema and also provide some additional procedure by which the results from these different queries are combined. Additionally, the results of the different queries may be formatted differently and be at different precisions.","No currently known technology provides a mechanism whereby a change to the database schema does not require modification to older data held in the archive, and at the same time enables queries written against the latest (in other words, current) schema to run against any and\/or all data in the archive.","According to an embodiment of the invention, there is provided a method of operating a computer system for storing and retrieving data from a data store, wherein the computer system has a data manager device operable to manage patterns in the stored data along with pointers relating to the patterns in a manner which enables reconstruction of the stored data in original form, the method comprising: storing a first data table entry applying a schema used at a first point in time along with pointer data and pattern space information collectively representing the data table entry at the first point in time; and generating, at a later point in time, a map responsive to a schema change, wherein said map comprises new pointer data and or new pattern space information.","Preferably, pointer data comprises one or more of table meta data and index data.","Preferably, pointer data comprises header information defining aspects of a schema.","Preferably, pointer data comprises table meta data, and wherein the table meta data comprises one or more selected from: field of a table; type of field; maximum value of field minimum value of field; another attribute of a field.","Preferably, pointer data comprises index data defining an ordering of pattern elements within the pattern space.","Preferably, pointer data comprises path data defining how a control function should traverse pattern elements.","Preferably, path data comprises instructions on one or more transformations.","Preferably, pointer data duplicates at least a portion of the pattern space.","Preferably, at least a portion of pointer data is immutable.","Preferably, a schema change causes the map to indicate changes to old pointer information.","Preferably, a schema change causes the map to indicate coalesced pointer information.","Preferably, a recursive process is employed to determine the data entry from coalesced pointer information.","Preferably, the schema change comprises dropping a column, and wherein the map indicates new columns, old index data and old pattern space information.","Preferably, the schema change comprises renaming a column, and wherein the map indicates a new column name and an old column name to be hidden.","Preferably, the schema change comprises adding a column, and wherein the map indicates new column information selected from: a null value; a literal default value; and a function of a value in another column.","Preferably, the map indicates new column information at least in part by reference to path data.","Preferably, the path data comprises one or more of navigation data and functional elements.","Preferably, the schema change comprises retyping a column, and wherein the map indicates at least one transformation leading to an entry in the new column.","Preferably, the schema change comprises retyping a column, and said transformation is defined at least in part by path data.","According to one aspect of the invention, there is provided a method as described above further comprising the step of querying stored data at a previous point in time, and wherein the data manager accesses at least one map generated responsive to a schema change to derive data supporting a query at that previous point in time.","Preferably, the schema change comprises splitting a column, and wherein the data manager generates map data relating to adding new columns and dropping a column.","Preferably, the schema change comprises merging a column, and wherein the data manager generates map data relating to dropping columns and adding at least one new column.","According to one embodiment of the invention, there is provided a computer system for storing and retrieving data from a data store, the computer system comprising: a pattern manager device operable to manage patterns in the stored data along with pointers relating to the patterns in a manner which enables reconstruction of the stored data in original form; a storage device for storing a first data table entry applying a schema used at a first point in time along with pointer data and pattern space information collectively representing the data table entry at the first point in time; and a map generator for generating, at a later point in time, a map responsive to a schema change, wherein said map comprises new pointer data and or new pattern space information.","According to one embodiment of the invention, there is provided a computer system for storing and retrieving data from a data store, comprising a data manager device operable to generate and manage ancillary data relating to (i) a plurality of data tables within the data store and (ii) a plurality of schema applied to produce said data tables, wherein said ancillary data comprises indication of at least one pattern within a pattern space of the data store and reference data from which individual field values of data tables can be determined from the pattern space.","According to one embodiment of the invention, there is provided a computer implemented method for handling archived data, the method comprising the steps of: transferring an extract of data from a data repository to an archive at a point T in time, wherein the data is represented by a first schema at time T; storing the at least one extract of data as a combination of (i) a header portion (ii) an index portion and (iii) a pointer to at least one pattern space in the archive, wherein the header portion contains information on how to interpret the patterns in the pattern space in order to recover the data in the form it existed in the data repository, and the index portion identifies patterns from within the pattern space that represent entire data records from the repository; receiving a data query at a time later than T wherein the data schema in the repository has changed to a second schema which differs from the first; returning, in response to said data query, data from the archive utilising data in said header portion, index portion and pattern space such that the first schema behaves in response to the query as if it had been created under the second schema.","Preferably, the step of querying further comprises performing a transformation on data.","Preferably, the transformation is selected from one or more of: dropping a column, renaming a column, adding a column, re-typing a column, querying at a point in time, splitting a column, merging a column.","Preferably, the at least one data extract is stored as immutable data.","Preferably, the header portion comprises at least (i) the names of the fields that appear in the records of the table and (ii) the types of these fields.","Preferably, the data repository is a: relational database, data warehouse or a star schema database.","According to one embodiment of the invention, there is provided a data structure for use in a computer system, the data structure comprising: (i) a pointer to a pattern space, wherein the pattern space comprises one or more patterns that have been discovered in an original data source; (ii) an index portion, wherein the index area identifies patterns from within the pattern space that represent entire data records from the original data source; and (iii) a header portion, wherein the header portion comprises metadata describing how to interpret the patterns in the pattern space in order to recover the data in the form it existed in the data repository, wherein collectively the header, index and pointer to the pattern space form a data extract describing the state of a data source at a point in time.","Preferably, the two or more extracts share a single pattern space.","According to one embodiment of the invention, there is provided a method of querying archived data, the method comprising the steps of: storing the data in a table T, wherein T is the union of two or more data table extracts T, T, T . . . TN, each extract having a different schema describing its data and stored in an archive; generating a map representing each schema change between extracts T, T, T . . . TN, receiving at a query manager a user request for data contained in one of the extracts; and applying the relevant map such that the query manager rewrites the schema of a first extract such that the data it represents behaves in response to the query as if it had been created under the schema of a second extract.","Preferably, each extract comprises immutable data.","According to one embodiment of the invention, there is provided a legacy data manager comprising: an interface configured to receive data from at least one production system; a pattern identifier operable to receive said data, find patterns in said data, store the identified patterns in a memory and generate a representation of the patterns using pointers; an index manager operable to receive said data, identify an index area, store said index in said memory, and generate a representation of indices using pointers; a header manager operable to define a header area, store it in memory, and generate a representation of headers using pointers; an interface with at least one data archive on a storage device configured to transfer data from the memory to the archive.","According to one embodiment of the invention, there is provided a computer system for archiving data comprising: a legacy data manager as described above; at least one data archive residing on a storage device operably connected to the legacy data manager; and at least one production system operable to generate data, operably connected to the legacy data manager.","Preferably, the computer system further comprises at least one user terminal interface for operably connecting at least one user terminal to the legacy data manager and\/or production system, and configured to receive data queries.","Preferably, the user terminal is a personal computer, thin client device or any other suitable electronic apparatus.","Like reference numerals appearing in the appended drawings are to be interpreted as representing functionally equivalent features described throughout this specification, unless otherwise stated.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 1","b":["10","20","30","40","10","30"]},"The legacy data manager  comprises: an archive interface  operable to facilitate communication between the legacy data manager  and archive , a production system interface  operable to facilitate communication between legacy data manager  and production system , a pattern identifier module , a query manager , a map generator , an index manager , a header manager . Also operably connected to legacy data manager  is a memory .","Usually, the production system  generates and\/or administrates at least one database . In the context of the present invention, the term \u201cdatabase\u201d is intended to be construed broadly to describe any structured collection of records or data. It is not intended to be limited to any particular database model and may therefore be selected from one or more of: hierarchical model, network model, relational model or any other. According to one embodiment, the apparatus and methods of the present invention are applied to a relational database. According to another embodiment, the apparatus and methods of the present invention are applied to a star schema, or other data warehousing model. The generation and\/or administration of data for the at least one database  may be done automatically by the production system , in response to user inputs to terminal , or a combination of both. In any event, data tables from the at least one database  are backed up into data archive  over time. According to the embodiments of the present invention this backup process is managed by the various components of the legacy data manager .","In order to carry out a database archiving operation, data must be transferred from database  to archive . However, according to one embodiment, data is not maintained in a separate database  and instead is transferred directly from production system  into archive  via the legacy data manager . In either case, this process may be initiated automatically by the legacy data manager , by the production system  and\/or in response to user inputs, e.g. into to terminal . The result of the database archiving operation is that the archive  is populated with data archived at different points in the past. Inevitably, various changes may be applied to the data over time. In particular, the data schema may be changed according to the changing requirements of the database as time goes on. The term \u201cschema\u201d is used broadly herein to describe the structure of a database system, or in other words, it is metadata describing the data. In a relational database, for example, the schema defines the tables, the fields in each table, and the relationships between fields and tables. However, as stated above, the embodiments of the present invention are not limited only to relational databases.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 2","FIG. 2"],"b":["10","20","10","30","102","30","20","30","1","210","1","1","220","2","230","30","2","1","2","240"]},"According to one example, a user, for instance situated at the terminal , wishes to run a query  against data in the archive. In the example shown in , this query is run against table T (). Table T () is the union of the extracts T () and T (), as described above. Since T and T have different schemas it is not generally possible to write a single query that validly runs against both tables. However, according to the embodiments of the present invention it is possible to retain the original data stored in T in an unchanged state. This is by virtue of a map  created by map generator . According to the example, in response to the schema change that occurred prior to the archiving of T, map generator  creates a map  that surrounds T, rewrites its schema and allows the original data to behave in response to the query  exactly as if it had been created under schema S. The function of the map  is described in more detail below. Broadly, however, the map  represents function(s) that allow the schema  to behave as if it is a copy of schema .","The query manager  is operable to receive user queries, for example, from user terminal  and, using map , run said user query  against data that has been stored using both schemas S and S. The effect of this is that data stored using different schemas behaves to the query as if it had been written using a single schema, e.g. in this case S.","Data Organization","According to an embodiment of the present invention, a temporary database is created in memory  by legacy data manager  from a set of data (i.e., a \u201cdata set\u201d) produced by the production system  by identifying patterns in the data set, storing the patterns in the temporary database, and generating a representation of the database structure using pointers to the stored patterns. According to a preferred embodiment, this representation is a triple of <header, index, (pattern)space>, which will be described in more detail below.","In the context of the present disclosure, \u201cpointers\u201d refer to a data type whose value refers directly to (in other words \u201cpoints to\u201d) another value stored elsewhere in the archive  using its address. When setting up data structures such as lists, queues, trees or any other, it is useful to have pointers to manage the way in which the structure is implemented and controlled. The use of pointers may allow for more rapid searching, sorting, and other operations on the database because these operations can be performed using individual patterns to represent field values of many records (tuples) in a single operation. Note: the terms \u201ctuple\u201d, \u201crow\u201d, and \u201crecord\u201d are used interchangeably throughout this specification.","Embodiments of the present invention may, for example, use and manipulate such a database as described in International Patent Application Publication No. WO 02\/063498, Method of Querying a Structure of Compressed Data.","The following embodiments, and where appropriate, examples, are described with reference to a data set for a table in archive , which may be for example a relational database, a database according to another hierarchical model, or a database according to any other database model. However, the described embodiments can also be used across several tables rather than for only a single table, and the description herein should not be considered as limiting the embodiments of the present invention to operating only on a single table of a database.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 3","b":["20","10","30","60","20","101"]},"The first constituent is the pattern space , referred to by pointer . The pattern space  is a random access area where the patterns that have been discovered in the original data table are stored. The process of identifying and storing patterns discovered in the data table is managed by the pattern identifier , which is operable to receive data from the production system  through interface , find patterns (e.g. using a suitable algorithm), store the identified patterns in memory  and generate a representation of patterns using appropriate pointers accordingly. According to a preferred embodiment, this representation is used to form a triple of <header, index, (pattern)space>.","The term \u201cpattern space\u201d is used herein to broadly describe a repository of all instances of data received by the legacy data manager and ultimately stored in archive . In other words, the pattern space  is a pool of data populated from the production system  and\/or original database . One example of how the patterns are discovered and generated can be found in U.S. patent application Ser. No. 11\/244,347 \u201cMethod and System for Implementing An Enhanced Database\u201d.","The use of pointers to reference the patterns is advantageous in that it can greatly reduce the amount of memory or other space required to store the data set by replacing duplicate patterns with additional pointers, which are normally considerably smaller in size than the patterns themselves.","The second constituent is the index area , referred to by pointer . The index area  identifies patterns from within the pattern space  that represent entire data records from the original data table. In essence, an index embodies a particular ordering with which the records are visited, and the index area is a repository of all such indices. Typically the index dictates the order in which the records appeared in the original table, but not necessarily. For example, it is also possible to have an index that references only a subset of the original records.","The index area is identified and managed by index manager , which is operable to receive incoming data from interface , manipulate said data in order to identify the index area, store this information in memory , and generate a representation of indices using appropriate pointers accordingly. According to a preferred embodiment, this representation is used to form the triple of <header, index, (pattern)space> as mentioned above, which is also generated in memory  and sent to archive  accordingly.","The third constituent of the structure is the header area , referred to by pointer . The header area  embodies the meta data associated with a given table. The header  is a part of the archive and, as such, is immutable in the sense that, once committed to the archive, it is not changed. If it is necessary to change the header, another header is created to represent the new header. Further, the header does not alter the data in the pattern space or elsewhere in the archive, again retaining immutability. Instead, the header provides information on how to interpret the patterns in the pattern space in order to recover the data that was in the table.","The meta data in the header comprises: (i) the names of the fields that appear in the records of the table and (ii) the types of these fields, i.e. whether they are integer fields, text fields and so on. From the type of data field used, it is possible to determine how the data is represented and the operations that can be performed on the data. The header area  may contain other attributes of the field such as its maximum and minimum values, whether the field is read-only etc. All aspects of the header area  are managed by header manager  which is operable to manipulate data incoming through interface  in order to define the header area, store it in memory , and generate a representation of headers using appropriate pointers accordingly. According to a preferred embodiment, this representation is used to form the triple of <header, index, (pattern)space> as mentioned above, which is also generated in memory  and sent to archive  accordingly.","Another piece of meta data that the header area  stores is navigation information for a given field. Accordingly, the header  contains more information than the traditional database schema. The term \u201cpath\u201d is used throughout the specification to broadly describe this navigation information. It describes the steps by which the legacy data manager  can start from an index entry in the index area  and recover the value of the field that appeared in the original record. This process involves the navigation of the pattern space . Recall that each index entry in index area  identifies a particular pattern that represents the entire data record within the pattern space . This particular pattern usually comprises pointers to other patterns which may themselves point to further patterns and so on. At the most basic level, there exist \u201cprimitive patterns\u201d that represent the actual values of the fields for any given record.","In summary, the three constituents described above play an inter-dependent role, each depending on data stored in the archive. The pattern space is simply a collection of patterns. There may be many more patterns in the space than are required to represent a single table. For instance, the pattern space may represent many different tables, or different views of the same table. The index  identifies which patterns are present in this instance and the order that they appear. The combination of index and pattern space almost allows recreation of a conceptual table which is a collection of, for example, cells in rows and columns. For instance, with the pattern space and index it is possible to reconstruct the cells in the order that they appeared in the table. However, at this point only the patterns exist to populate the cells. In order to illustrate, there may be the pattern 20050806 in a cell, but that information could represent anything, e.g. 6 Aug. 2005, 8 Jun. 2005, the integer 20050806, the fixed point number 2005.0806 or many other things. It is not possible to complete the restoration of the original table without the header  which provides the information of how to interpret the patterns that are visible. Thus the header can be said to provide the information that traditionally appears in the schema for a table, however, as will be evident to the skilled person, the header does more than a schema. Neither the pattern space nor index contribute to the schema. Referring again to , the map  represents the function(s) that allow the header (or schema, when considered on a simpler level)  to behave as if it is a copy of header . Note that it is effectively the header that is the target of the query because only the header can deliver back the original record stream. The map is a conceptual device because, in practice, a new header is created (which is not shown) which contains new paths and each individual path contains the part of the mapping that allows one field within the header  to behave as if it is the equivalent field from header .","Once the above manipulation of data has been completed, i.e. the data table has been split into the various constituents as described above, the legacy data manager  transfers the data from memory  into archive  through interface . While according to one embodiment, a temporary database is utilised in order to temporarily store various types of data during manipulation, according to another embodiment the legacy data manager  may not utilise a temporary database and may instead manipulate data received from the production system  in memory on-the-fly in the same manner described above but store it directly into archive .","In summary, navigation of a path consists of visiting patterns within pattern space , and following pointers therein to reach sub-patterns until a primitive pattern is reached and can be returned in response to a query. The navigation of a path in this sense is managed by query manager . The query manager  identifies which pointer to follow from a particular pattern by the identity of the field a user is trying to retrieve. In other words, the path that is stored in the meta data (in header area ) for a field therefore contains the instructions to determine which patterns the query manager  needs to traverse in order to reach the pattern corresponding to a given field. For example, assuming that every pattern in the pattern space  has been assigned a unique integer identifier and that an entry in the index area  is one of these identifiers, e.g. 626, a path might consist of a sequence of further integers (independent of those assigned to the patterns), e.g. 3, 0, 2.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 4","b":["10","410","105","420","105","430","105","105","440","450","105","105","416","460","105","105","105","420","470"]},"The header area  contains the meta data for each field and also the path (or navigation information), and the index area  contains a list of pointers (or indices) into the pattern space . However, the path need not consist simply of steps to follow through the pattern space. In addition, the path may also contain instructions on transformations to perform on the data that is fetched during a query. In the alternative, a path may simply contain a literal value or a reference to an existing primitive pattern.","The following operations are non-limiting examples of transformations which may be performed on the data during a query, according to embodiments of the present invention: 1. Dropping a Column; 2. Renaming Column; 3. Adding Column; 4. Re-typing a Column; 5. Querying at a Point in Time; and 6. Splitting\/Merging a Column. These are typical operations performed on data in the archive  by the legacy data manager .","1. Dropping a Column","Dropping a column means removing a column from a data table. It occurs when the data held in that column is no longer required in the production system . To drop a column from an already archived set of data, i.e. a set of data stored in archive , it is sufficient just to remove the column from the header  associated with that data set. For example if an initial header  contains the following four fields, e.g.:",{"@attributes":{"id":"p-0084","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"A","INTEGER","attributes_A"]},{"entry":[{},"B","CHAR(20)","attributes_B"]},{"entry":[{},"C","DATE","attributes_C"]},{"entry":[{},"D","FLOAT(15)","attributes_D"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"Then to drop field B the header  can be replaced with:",{"@attributes":{"id":"p-0086","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"A","INTEGER","attributes_A"]},{"entry":[{},"C","DATE","attributes_C"]},{"entry":[{},"D","FLOAT(15)","attributes_D"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0087","num":"0086"},"figref":["FIG. 5","FIG. 5"],"b":["500","510","520","550","570","580","590","560","530","540","500","510","520","570","580","590"]},"When there are a large number of fields in the table, it might be considered wasteful to duplicate n\u22121 field entries in order to delete a single column. Therefore, according to another embodiment of the present invention, the header contains a pointer to the previous header and a list of the changes (or \u201cdeltas\u201d) made to this header. Storing information in this way is advantageous for several reasons, for instance, it may save large quantities of storage space, allow particularly efficient recovery of data and such like.",{"@attributes":{"id":"p-0089","num":"0088"},"figref":["FIG. 6","FIG. 6"],"b":["610","105","105","640","105","105","630","510","105","640","650","640","105","660"]},"If a large number of schema changes take place, there may exist a long chain of headers that is unwieldy to use. Therefore, a further embodiment of the present invention allows for two or more elements in the chain to be coalesced into a single header that combines the effects of all of these elements. In order to illustrate, the following example is provided. Following an example from above in which three schema changes are performed, for instance \u201cDROP COLUMN B\u201d, \u201cDROP COLUMN D\u201d and \u201cDROP COLUMN A\u201d. In this example the result would be 4 headers (including the original one). According to one embodiment, \u201cdeltas\u201d are utilized such that each header contains just the changes made since the last header was created, and a pointer to the previous header.","Therefore header 0 could be:\n\n","After the first schema change, header 1 is then:\n\n","(Recall that setting the type to NULL was one way to indicate that the column is deleted).","Header 2 is:\n\n","Header 3 is:\n\n","If these exemplary headers are coalesced then the deltas are \u201crolled up\u201d to produce a single header that represents the combined effect of the four headers. This may be considered a recursive process, e.g. coalesce(header3)=remove(A,coalesce(header2)) etc. If this exemplary process is applied, the result is, for example, the header:\n\n","Note that according to this embodiment, this header does not point to any other headers because it operates completely stand-alone and independent of any other the other headers which existed before.","2. Renaming a Column","According to the embodiments of the invention, when a column is renamed, it is only necessary assign a new name for that column in the header . For example if a user wishes to rename column \u201cB\u201d in the earlier example (see above) to \u201cE\u201d, then the resultant header will be as follows:",{"@attributes":{"id":"p-0099","num":"0109"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"A","INTEGER","attributes_A"]},{"entry":[{},"E","CHAR(20)","attributes_B"]},{"entry":[{},"C","DATE","attributes_C"]},{"entry":[{},"D","FLOAT(15) ","attributes_D"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"Note how all the attributes of the column apart from its name remain unchanged. When using a chain of headers it is necessary to provide an element of the chain that not only defines the renamed column, but that also hides the old name. For example:",{"@attributes":{"id":"p-0101","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"B","NULL","NULL"]},{"entry":[{},"E","CHAR(20)","attributes_B"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}},"br":{}},"When adding a new column to a relational database it is necessary to define the initial values held in that column. Evidently, the existing table does not contain this column and the database requires to know the value(s) returned by requests for that column. These values are either defined as NULL, a literal default value for the column, or as a function of the value held in other columns in the table. According to embodiments of the present invention, this is accounted for using the \u201cpath\u201d object that is one of the attributes of each field.","As stated above, the path combines navigational elements and functional elements. If the default value for the new column is a literal or NULL value that already appears in the pattern space then it is possible to assign a path to this column that retrieves that value from the pattern space . If the literal value does not appear in the current pattern space, then it is possible to add a path with no navigational information but just a simple function at the end of the path that returns the literal value.","The following is an illustrative example of adding a column involving a more complex function. Suppose that the original table contained two columns (amongst others) called \u201cCost\u201d and \u201cPrice\u201d. For example:",{"@attributes":{"id":"p-0105","num":"0115"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Cost","INTEGER","attributes_cost"]},{"entry":[{},"Price","INTEGER","attributes_price"]},{"entry":[{},". . . ",". . . ",". . ."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"If a user wishes to add a new column to the table, in this example called \u201cprofit\u201d and whose values will be \u201cprice-cost\u201d, to do this the legacy data manager  creates a path that again has no navigational elements, but has a functional element that computes \u201cprice-cost\u201d and returns its value.","In the case where a user adds a column to a data table, there are several possibilities for how the data is stored. For instance, according to one embodiment, the original data table is stored as a triple of <header, index, pattern space> and the new data is stored as a triple of <header\u2032, index\u2032, pattern space\u2032>, where pattern space\u2032 is a copy of all of the original data plus the new data (i.e. pattern space+additional data(\u03b4)). According to another embodiment, once a change is made to the database (in this case adding a column), the additional data (\u03b4) may simply be stored in the original pattern space, without having a separate pattern space containing the original data plus the additional data. In other words, according to one embodiment, there is a single pattern space which is a repository for all patterns, and only a new header and index is created to reflect schema changes. Each time a change is made, a new header and index can be created and the additional data patterns added to the pattern space. These two possibilities are shown in .","As will be evident to the skilled reader, the different possibilities for archiving data in various combinations of the constituents (header, index, pattern space) apply to all relevant database changes, not just adding a column.","4. Re-Typing a Column","Re-typing a column commonly happens when the underlying application changes. For example, a production system may start recording times as well as dates on a transaction, or may record the price in dollars and cents rather than just dollars. When the type of a column changes it means that future values of that column will use a different representation to the values that have already been put into the archive. It is possible to change all the values already in the archive to match the new representation, but that would mean destroying the original data archived, not to mention being a lengthy and often expensive process. When a user wishes to query the old values in combination with the new values, it would be necessary to convert the old values to use the same representation as the new values. Also recall that the values themselves are a part of the pattern space, so cannot be transformed in place.","According to the embodiments of the invention, the transformation can be achieved by using the path structure again. After the schema change, the system rewrites the header entry so that the type of the column matches the new type. The path stored in the attributes for this column now becomes a copy of the previous path with an additional function added to the end of the path. This further function takes the value that would previously have been returned and rewrites it into the representation required by the new type. As an example, if the original field was called \u201cprice\u201d and had an INTEGER value, and a schema change was performed to increase the precision to, for instance, DECIMAL(6,2). This exemplary new type represents a fixed point number with six digits, two of which are to the right of the decimal point. One way to represent such a number is to store it as an integer but to transform it appropriately before displaying any results. For example the value 43.57 could be stored internally as integer 4357.","Therefore, according to the embodiments of the present invention, it is possible to assign a new entry (for example \u201cprice\u201d) in the header that has a certain type (for example of DECIMAL(6,2)) and whose path is a copy of the previous path but with a new function added to the end of the path. This function takes the value in the original representation and multiplies it by an factor (e.g. 100) to bring its representation into line with that used by the new data. Under this new schema a value that was stored as 35, for example, would be returned by the path to the query as 3500.","5. Querying at a Point in Time","If a user wishes to query the archive, and in particular the data as it stood at a particular instance in time, it is important not just to identify the data that is presented at that point in time, but also the schema that applied to that data. As is evident from above, whenever a schema change is applied to the archive, the system creates a new <header, index, space> triple for each table and sub-table in the archive. The system also marks these triples with the date and time at which the schema was changed. When a user wishes to query the state of the archive at a particular point in time, then the system recovers the data that was present at that moment in time, and then for each pattern space representing a part of a table the system finds the corresponding triple that was active at that point in time. Once the system has collected these triples together, it now has the appropriate means to run a query against the database as it stood at a point in time.","6. Splitting\/Merging a Column","Splitting a column may be considered a combination of adding two new columns (see point 3 above) and dropping one (see point 1 above). Similarly, merging a column may be considered dropping two columns and adding one new column.",{"@attributes":{"id":"p-0114","num":"0124"},"figref":"FIG. 8","b":["800","105","810","820","105","830","840","850","870","30","40","860"]},"The method described above may be implemented as computer software, hardware, of a combination thereof. In a particular implementation, the functions described herein may be implemented by a computing device that comprises one or more processors, a memory, a system bus, one or more input\/output devices and a computer-readable storage medium obtaining software or other executable logic. Herein, reference to software may encompass one or more applications, bytecode, one or more computer programs, one or more executables, one or more instructions, logic, machine code, one or more scripts, or source code, and vice versa, where appropriate. In particular embodiments, software includes one or more application programming interfaces (APIs). This disclosure contemplates any suitable software written or otherwise expressed in any suitable programming language or combination of programming languages. In particular embodiments, software is expressed as source code or object code. In particular embodiments, software is expressed in a higher-level programming language, such as, for example, C, Perl, or a suitable extension thereof. In particular embodiments, software is expressed in a lower-level programming language, such as assembly language (or machine code). In particular embodiments, software is expressed in JAVA, C, or C++. In particular embodiments, software is expressed in Hyper Text Markup Language (HTML), Extensible Markup Language (XML), or other suitable markup language.","The software may be stored in a computer-readable storage medium. Herein, reference to a computer-readable storage medium encompasses one or more non-transitory, tangible computer-readable storage media possessing structure. As an example and not by way of limitation, a computer-readable storage medium may include a semiconductor-based or other integrated circuit (IC) (such, as for example, a field-programmable gate array (FPGA) or an application-specific IC (ASIC)), a hard disk, an HDD, a hybrid hard drive (HHD), an optical disc, an optical disc drive (ODD), a magneto-optical disc, a magneto-optical drive, a floppy disk, a floppy disk drive (FDD), magnetic tape, a holographic storage medium, a solid-state drive (SSD), a RAM-drive, a SECURE DIGITAL card, a SECURE DIGITAL drive, or another suitable computer-readable storage medium or a combination of two or more of these, where appropriate. Herein, reference to a computer-readable storage medium excludes any medium that is not eligible for patent protection under 35 U.S.C. \u00a7101. Herein, reference to a computer-readable storage medium excludes transitory forms of signal transmission (such as a propagating electrical or electromagnetic signal per se) to the extent that they are not eligible for patent protection under 35 U.S.C. \u00a7101. A computer-readable non-transitory storage medium may be volatile, non-volatile, or a combination of volatile and non-volatile, where appropriate. This disclosure contemplates one or more computer-readable storage media implementing any suitable storage.","Those skilled in the art will appreciate that while this disclosure describes what is considered to be the best mode and, where appropriate, other modes of performing the invention, the invention should not be limited to the specific configurations and methods disclosed in this description of the preferred embodiment."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a better understanding of the invention and as to how the same may be carried into effect reference will now be made, by way of example only, to the accompanying drawings, in which:",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 2","b":["10","20"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 3","b":"20"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIGS. 7A and 7B"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
