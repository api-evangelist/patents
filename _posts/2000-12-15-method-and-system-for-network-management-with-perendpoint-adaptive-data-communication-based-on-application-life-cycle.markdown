---
title: Method and system for network management with per-endpoint adaptive data communication based on application life cycle
abstract: A method, system, apparatus, and computer program product is presented for management of a distributed data processing system. The present invention uses an improved iterator methodology to dynamically adapt the administrative communication operations of the network management system so as to minimize the potential impact on system performance, including customer applications, that might be caused by system management operations. In particular, the adjustments to the operations occur in accordance with a phase or life cycle state of system management applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07305485&OS=07305485&RS=07305485
owner: International Business Machines Corporation
number: 07305485
owner_city: Armonk
owner_country: US
publication_date: 20001215
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present application is related to the following applications: application Ser. No. 09\/738,337, filed Dec. 15, 2000, titled \u201cMethod and System for Network Management With Adaptive Monitoring and Discovery of Computer Systems Based on User Login\u201d; application Ser. No. 09\/737,726, filed Dec. 15, 2000, titled \u201cMethod and System for Network Management With Per-Endpoint Monitoring Based on Application Life Cycle\u201d; application Ser. No. 09\/737,434, filed Dec. 15, 2000, titled \u201cMethod and System for Network Management With Backup Status Gathering\u201d; application Ser. No. 09\/737,431, filed Dec. 15, 2000, titled \u201cMethod and System for Network Management With Redundant Monitoring and Categorization of Endpoints\u201d.","1. Field of the Invention","The present invention relates to an improved data processing system and, in particular, to a method and system for multiple computer or process coordinating. Still more particularly, the present invention provides a method and system for network management.","2. Description of Related Art","Technology expenditures have become a significant portion of operating costs for most enterprises, and businesses are constantly seeking ways to reduce information technology (IT) costs. This has given rise to an increasing number of outsourcing service providers, each promising, often contractually, to deliver reliable service while offloading the costly burdens of staffing, procuring, and maintaining an IT organization. While most service providers started as network pipe providers, they are moving into server outsourcing, application hosting, and desktop management. For those enterprises that do not outsource, they are demanding more accountability from their IT organizations as well as demanding that IT is integrated into their business goals. In both cases, \u201cservice level agreements\u201d have been employed to contractually guarantee service delivery between an IT organization and its customers. As a result, IT teams now require management solutions that focus on and support \u201cbusiness processes\u201d and \u201cservice delivery\u201d rather than just disk space monitoring and network pings.","IT solutions now require end-to-end management that includes network connectivity, server maintenance, and application management in order to succeed. The focus of IT organizations has turned to ensuring overall service delivery and not just the \u201ctowers\u201d of network, server, desktop, and application. Management systems must fulfill two broad goals: a flexible approach that allows rapid deployment and configuration of new services for the customer; and an ability to support rapid delivery of the management tools themselves. A successful management solution fits into a heterogeneous environment, provides openness with which it can knit together management tools and other types of applications, and a consistent approach to managing all of the IT assets.","With all of these requirements, a successful management approach will also require attention to the needs of the staff within the IT organization to accomplish these goals: the ability of an IT team to deploy an appropriate set of management tasks to match the delegated responsibilities of the IT staff; the ability of an IT team to navigate the relationships and effects of all of their technology assets, including networks, middleware, and applications; the ability of an IT team to define their roles and responsibilities consistently and securely across the various management tasks; the ability of an IT team to define groups of customers and their services consistently across the various management tasks; and the ability of an IT team to address, partition, and reach consistently the managed devices.","Many service providers have stated the need to be able to scale their capabilities to manage millions of devices. When one considers the number of customers in a home consumer network as well as pervasive devices, such as smart mobile phones, these numbers are quickly realized. Significant bottlenecks appear when typical IT solutions attempt to support more than several thousand devices.","Given such network spaces, a management system must be very resistant to failure so that service attributes, such as response time, uptime, and throughput, are delivered in accordance with guarantees in a service level agreement. In addition, a service provider may attempt to support as many customers as possible within a single network management system. The service provider's profit margins may materialize from the ability to bill the usage of a common network management system to multiple customers.","On the other hand, the service provider must be able to support contractual agreements on an individual basis. Service attributes, such as response time, uptime, and throughput, must be determinable for each customer. In order to do so, a network management system must provide a suite of network management tools that is able to perform device monitoring and discovery for each customer's network while integrating these abilities across a shared network backbone to gather the network management information into the service provider's distributed data processing system. By providing network management for each customer within an integrated system, a robust management system can enable a service provider to enter into quality-of-service (QOS) agreements with customers.","Hence, there is a direct relationship between the ability of a management system to provide network monitoring and discovery functionality and the ability of a service provider using the management system to serve multiple customers using a single management system. Preferably, the management system can replicate services, detect faults within a service, restart services, and reassign work to a replicated service. By implementing a common set of interfaces across all of their services, each service developer gains the benefits of system robustness. A well-designed, component-oriented, highly distributed system should accept a variety of services on a common infrastructure with built-in fault-tolerance and levels of service.","Distributed data processing systems with thousands of nodes are known in the prior art. The nodes can be geographically dispersed, and the overall computing environment can be managed in a distributed manner. The managed environment can be logically separated into a series of loosely connected managed regions, each with its management server for managing local resources. The management servers can coordinate activities across the enterprise and can permit remote site management and operation. Local resources within one region can be exported for the use of other regions.","Meeting quality-of-service objectives in a highly distributed system can be quite difficult. A service provider's management system should have an infrastructure that can accurately measure and report the level of service available for any resource throughout the system. In addition, the management system should be able to tune its operations so that management activities do not degrade the performance of the system as seen by the customers of the service operator. In particular, the management system should be able to adjust its bandwidth requirements so as to maximize the performance of the system with respect to communication metrics. However, within a system that performs network management tasks for a million devices or more, a tremendous amount of computational resources throughout the system could be consumed for administrative communications, making it particularly difficult to dynamically tune the bandwidth requirements of the system.","Therefore, it would be advantageous to provide a method and system that dynamically adapts the administrative communication operations so as to minimize the impact on system performance that is caused by the system management operations. It would be particularly advantageous if performance adjustment operations occurred in accordance with a phase or life cycle state of system management applications.","A method, system, apparatus, and computer program product is presented for management of a distributed data processing system. A management process discovers endpoints on a network within the distributed data processing system using a network management framework, and a state of the network is determined from a collective state of discovered endpoints. A data transfer parameter is then associated with each discovered endpoint on the network based on the determined state of the network. Data transfer operations between endpoints use components within the network management framework that rely upon the data transfer parameter associated with each endpoint. When performed in an object-oriented manner, a data iterator object at the discovered endpoint is updated in accordance with an updated data transfer parameter associated with the discovered endpoint.","The present invention provides a methodology for managing a distributed data processing system. The manner in which the system management is performed is described further below in more detail after the description of the preferred embodiment of the distributed computing environment in which the present invention operates.","With reference now to , a diagram depicts a known logical configuration of software and hardware resources. In this example, the software is organized in an object-oriented system. Application object , device driver object , and operating system object  communicate across network  with other objects and with hardware resources -.","In general, the objects require some type of processing, input\/output, or storage capability from the hardware resources. The objects may execute on the same device to which the hardware resource is connected, or the objects may be physically dispersed throughout a distributed computing environment. The objects request access to the hardware resource in a variety of manners, e.g. operating system calls to device drivers. Hardware resources are generally available on a first-come, first-serve basis in conjunction with some type of arbitration scheme to ensure that the requests for resources are fairly handled. In some cases, priority may be given to certain requesters, but in most implementations, all requests are eventually processed.","With reference now to , the present invention is preferably implemented in a large distributed computer environment  comprising up to thousands of \u201cnodes\u201d. The nodes will typically be geographically dispersed and the overall environment is \u201cmanaged\u201d in a distributed manner. Preferably, the managed environment is logically broken down into a series of loosely connected managed regions (MRs) , each with its own management server  for managing local resources with the managed region. The network typically will include other servers (not shown) for carrying out other distributed network functions. These include name servers, security servers, file servers, thread servers, time servers and the like. Multiple servers  coordinate activities across the enterprise and permit remote management and operation. Each server  serves a number of gateway machines , each of which in turn support a plurality of endpoints\/terminal nodes . The server  coordinates all activity within the managed region using a terminal node manager at server .","With reference now to , each gateway machine  runs a server component  of a system management framework. The server component  is a multi-threaded runtime process that comprises several components: an object request broker (ORB) , an authorization service , object location service  and basic object adapter (BOA) . Server component  also includes an object library . Preferably, ORB  runs continuously, separate from the operating system, and it communicates with both server and client processes through separate stubs and skeletons via an interprocess communication (IPC) facility . In particular, a secure remote procedure call (RPC) is used to invoke operations on remote objects. Gateway machine  also includes operating system  and thread mechanism .","The system management framework, also termed distributed kernel services (DKS), includes a client component  supported on each of the endpoint machines . The client component  is a low cost, low maintenance application suite that is preferably \u201cdataless\u201d in the sense that system management data is not cached or stored there in a persistent manner. Implementation of the management framework in this \u201cclient-server\u201d manner has significant advantages over the prior art, and it facilitates the connectivity of personal computers into the managed environment. It should be noted, however, that an endpoint may also have an ORB for remote object-oriented operations within the distributed environment, as explained in more detail further below.","Using an object-oriented approach, the system management framework facilitates execution of system management tasks required to manage the resources in the managed region. Such tasks are quite varied and include, without limitation, file and data distribution, network usage monitoring, user management, printer or other resource configuration management, and the like. In a preferred implementation, the object-oriented framework includes a Java runtime environment for well-known advantages, such as platform independence and standardized interfaces. Both gateways and endpoints operate portions of the system management tasks through cooperation between the client and server portions of the distributed kernel services.","In a large enterprise, such as the system that is illustrated in , there is preferably one server per managed region with some number of gateways. For a workgroup-size installation, e.g., a local area network, a single server-class machine may be used as both a server and a gateway. References herein to a distinct server and one or more gateway(s) should thus not be taken by way of limitation as these elements may be combined into a single platform. For intermediate size installations, the managed region grows breadth-wise, with additional gateways then being used to balance the load of the endpoints.","The server is the top-level authority over all gateway and endpoints. The server maintains an endpoint list, which keeps track of every endpoint in a managed region. This list preferably contains all information necessary to uniquely identify and manage endpoints including, without limitation, such information as name, location, and machine type. The server also maintains the mapping between endpoints and gateways, and this mapping is preferably dynamic.","As noted above, there are one or more gateways per managed region. Preferably, a gateway is a fully managed node that has been configured to operate as a gateway. In certain circumstances, though, a gateway may be regarded as an endpoint. A gateway always has a network interface card (NIC), so a gateway is also always an endpoint. A gateway usually uses itself as the first seed during a discovery process. Initially, a gateway does not have any information about endpoints. As endpoints login, the gateway builds an endpoint list for its endpoints. The gateway's duties preferably include: listening for endpoint login requests, listening for endpoint update requests, and (its main task) acting as a gateway for method invocations on endpoints.","As also discussed above, the endpoint is a machine running the system management framework client component, which is referred to herein as a management agent. The management agent has two main parts as illustrated in : daemon  and application runtime library . Daemon  is responsible for endpoint login and for spawning application endpoint executables. Once an executable is spawned, daemon  has no further interaction with it. Each executable is linked with application runtime library , which handles all further communication with the gateway.","Preferably, the server and each of the gateways is a distinct computer. For example, each computer may be a RISC System\/6000\u2122 (a reduced instruction set or so-called RISC-based workstation) running the AIX (Advanced Interactive Executive) operating system. Of course, other machines and\/or operating systems may be used as well for the gateway and server machines.","Each endpoint is also a computing device. In one preferred embodiment of the invention, most of the endpoints are personal computers, e.g., desktop machines or laptops. In this architecture, the endpoints need not be high powered or complex machines or workstations. An endpoint computer preferably includes a Web browser such as Netscape Navigator or Microsoft Internet Explorer. An endpoint computer thus may be connected to a gateway via the Internet, an intranet or some other computer network.","Preferably, the client-class framework running on each endpoint is a low-maintenance, low-cost framework that is ready to do management tasks but consumes few machine resources because it is normally in an idle state. Each endpoint may be \u201cdataless\u201d in the sense that system management data is not stored therein before or after a particular system management task is implemented or carried out.","With reference now to , a diagram depicts a logical configuration of software objects residing within a hardware network similar to that shown in . The endpoints in  are similar to the endpoints shown in . Object-oriented software, similar to the collection of objects shown in , executes on the endpoints. Endpoints  and  support application action object  and application object , device driver objects -, and operating system objects - that communicate across a network with other objects and hardware resources.","Resources can be grouped together by an enterprise into managed regions representing meaningful groups. Overlaid on these regions are domains that divide resources into groups of resources that are managed by gateways. The gateway machines provide access to the resources and also perform routine operations on the resources, such as polling.  shows that endpoints and objects can be grouped into managed regions that represent branch offices  and  of an enterprise, and certain resources are controlled by in central office . Neither a branch office nor a central office is necessarily restricted to a single physical location, but each represents some of the hardware resources of the distributed application framework, such as routers, system management servers, endpoints, gateways, and critical applications, such as corporate management Web servers. Different types of gateways can allow access to different types of resources, although a single gateway can serve as a portal to resources of different types.","With reference now to , a diagram depicts the logical relationships between components within a system management framework that includes two endpoints and a gateway.  shows more detail of the relationship between components at an endpoint. Network  includes gateway  and endpoints  and , which contain similar components, as indicated by the similar reference numerals used in the figure. An endpoint may support a set of applications  that use services provided by the distributed kernel services , which may rely upon a set of platform-specific operating system resources . Operating system resources may include TCP\/IP-type resources, SNMP-type resources, and other types of resources. For example, a subset of TCP\/IP-type resources may be a line printer (LPR) resource that allows an endpoint to receive print jobs from other endpoints. Applications  may also provide self-defined sets of resources that are accessible to other endpoints. Network device drivers  send and receive data through NIC hardware  to support communication at the endpoint.","With reference now to , a diagram depicts the logical relationships between components within a system management framework that includes a gateway supporting two DKS-enabled applications. Gateway  communicates with network  through NIC . Gateway  contains ORB  that supports DKS-enabled applications  and .  shows that a gateway can also support applications. In other words, a gateway should not be viewed as merely being a management platform but may also execute other types of applications.","With reference now to , a diagram depicts the logical relationships between components within a system management framework that includes two gateways supporting two endpoints. Gateway  communicates with network  through NIC . Gateway  contains ORB  that may provide a variety of services, as is explained in more detail further below. In this particular example,  shows that a gateway does not necessarily connect with individual endpoints.","Gateway  communicates through NIC  and network  with gateway  and its NIC . Gateway  contains ORB  for supporting a set of services. Gateway  communicates through NIC  and network  to endpoint  through its NIC  and to endpoint  through its NIC . Endpoint  contains ORB  while endpoint  does not contain an ORB. In this particular example,  also shows that an endpoint does not necessarily contain an ORB. Hence, any use of endpoint  as a resource is performed solely through management processes at gateway .",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIGS. 2F and 2G"},"As noted previously, the present invention is directed to a methodology for managing a distributed computing environment. A resource is a portion of a computer system's physical units, a portion of a computer system's logical units, or a portion of the computer system's functionality that is identifiable or addressable in some manner to other physical or logical units within the system.","With reference now to , a block diagram depicts components within the system management framework within a distributed computing environment such as that shown in . A network contains gateway  and endpoints  and . Gateway  runs ORB . In general, an ORB can support different services that are configured and run in conjunction with an ORB. In this case, distributed kernel services (DKS) include Network Endpoint Location Service (NELS) , IP Object Persistence (IPOP) service , and Gateway Service .","The Gateway Service processes action objects, which are explained in more detail below, and directly communicates with endpoints or agents to perform management operations. The gateway receives events from resources and passes the events to interested parties within the distributed system. The NELS works in combination with action objects and determines which gateway to use to reach a particular resource. A gateway is determined by using the discovery service of the appropriate topology driver, and the gateway location may change due to load balancing or failure of primary gateways.","Other resource level services may include an SNMP (Simple Network Management Protocol) service that provides protocol stacks, polling service, and trap receiver and filtering functions. The SNMP Service can be used directly by certain components and applications when higher performance is required or the location independence provided by the gateways and action objects is not desired. A Metadata Service can also be provided to distribute information concerning the structure of SNMP agents.","The representation of resources within DKS allows for the dynamic management and use of those resources by applications. DKS does not impose any particular representation, but it does provide an object-oriented structure for applications to model resources. The use of object technology allows models to present a unified appearance to management applications and hide the differences among the underlying physical or logical resources. Logical and physical resources can be modeled as separate objects and related to each other using relationship attributes.","By using objects, for example, a system may implement an abstract concept of a router and then use this abstraction within a range of different router hardware. The common portions can be placed into an abstract router class while modeling the important differences in subclasses, including representing a complex system with multiple objects. With an abstracted and encapsulated function, the management applications do not have to handle many details for each managed resource. A router usually has many critical parts, including a routing subsystem, memory buffers, control components, interfaces, and multiple layers of communication protocols. Using multiple objects has the burden of creating multiple object identifiers (OIDs) because each object instance has its own OID. However, a first order object can represent the entire resource and contain references to all of the constituent parts.","Each endpoint may support an object request broker, such as ORBs  and , for assisting in remote object-oriented operations within the DKS environment. Endpoint  contains DKS-enabled application  that utilizes object-oriented resources found within the distributed computing environment. Endpoint  contains target resource provider object or application  that services the requests from DKS-enabled application . A set of DKS services  and  support each particular endpoint.","Applications require some type of insulation from the specifics of the operations of gateways. In the DKS environment, applications create action objects that encapsulate command which are sent to gateways, and the applications wait for the return of the action object. Action objects contain all of the information necessary to run a command on a resource. The application does not need to know the specific protocol that is used to communicate with the resource. The application is unaware of the location of the resource because it issues an action object into the system, and the action object itself locates and moves to the correct gateway. The location independence allows the NELS to balance the load between gateways independently of the applications and also allows the gateways to handle resources or endpoints that move or need to be serviced by another gateway.","The communication between a gateway and an action object is asynchronous, and the action objects provide error handling and recovery. If one gateway goes down or becomes overloaded, another gateway is located for executing the action object, and communication is established again with the application from the new gateway. Once the controlling gateway of the selected endpoint has been identified, the action object will transport itself there for further processing of the command or data contained in the action object. If it is within the same ORB, it is a direct transport. If it is within another ORB, then the transport can be accomplished with a \u201cMoveto\u201d command or as a parameter on a method call.","Queuing the action object on the gateway results in a controlled process for the sending and receiving of data from the IP devices. As a general rule, the queued action objects are executed in the order that they arrive at the gateway. The action object may create child action objects if the collection of endpoints contains more than a single ORB ID or gateway ID. The parent action object is responsible for coordinating the completion status of any of its children. The creation of child action objects is transparent to the calling application. A gateway processes incoming action objects, assigns a priority, and performs additional security challenges to prevent rogue action object attacks. The action object is delivered to the gateway that must convert the information in the action object to a form suitable for the agent. The gateway manages multiple concurrent action objects targeted at one or more agents, returning the results of the operation to the calling managed object as appropriate.","In the preferred embodiment, potentially leasable target resources are Internet protocol (IP) commands, e.g. pings, and Simple Network Management Protocol (SNMP) commands that can be executed against endpoints in a managed region. Referring again to , each NIC at a gateway or an endpoint may be used to address an action object. Each NIC is represented as an object within the IPOP database, which is described in more detail further below.","The Action Object IP (AOIP) Class is a subclass of the Action Object Class. AOIP objects are the primary vehicle that establishes a connection between an application and a designated IP endpoint using a gateway or stand-alone service. In addition, the Action Object SNMP (AOSnmp) Class is also a subclass of the Action Object Class. AOSnmp objects are the primary vehicle that establishes a connection between an application and a designated SNMP endpoint via a gateway or the Gateway Service. However, the present invention is primarily concerned with IP endpoints.","The AOIP class should include the following: a constructor to initialize itself; an interface to the NELS; a mechanism by which the action object can use the ORB to transport itself to the selected gateway; a mechanism by which to communicate with the SNMP stack in a stand-alone mode; a security check verification of access rights to endpoints; a container for either data or commands to be executed at the gateway; a mechanism by which to pass commands or classes to the appropriate gateway or endpoint for completion; and public methods to facilitate the communication between objects.","The instantiation of an AOIP object creates a logical circuit between an application and the targeted gateway or endpoint. This circuit is persistent until command completion through normal operation or until an exception is thrown. When created, the AOIP object instantiates itself as an object and initializes any internal variables required. An action object IP may be capable of running a command from inception or waiting for a future command. A program that creates an AOIP object must supply the following elements: address of endpoints; function to be performed on the endpoint, class, or object; and data arguments specific to the command to be run. A small part of the action object must contain the return end path for the object. This may identify how to communicate with the action object in case of a breakdown in normal network communications. An action object can contain either a class or object containing program information or data to be delivered eventually to an endpoint or a set of commands to be performed at the appropriate gateway. Action objects IP return back a result for each address endpoint targeted.","Using commands such as \u201cPing\u201d, \u201cTrace Route\u201d, \u201cWake-On LAN\u201d, and \u201cDiscovery\u201d, the AOIP object performs the following services: facilitates the accumulation of metrics for the user connections; assists in the description of the topology of a connection; performs Wake-On LAN tasks using helper functions; and discovers active agents in the network environment.","The NELS service finds a route (data path) to communicate between the application and the appropriate endpoint. The NELS service converts input to protocol, network address, and gateway location for use by action objects. The NELS service is a thin service that supplies information discovered by the IPOP service. The primary roles of the NELS service are as follows: support the requests of applications for routes; maintain the gateway and endpoint caches that keep the route information; ensure the security of the requests; and perform the requests as efficiently as possible to enhance performance.","For example, an application requires a target endpoint (target resource) to be located. The target is ultimately known within the DKS space using traditional network values, i.e. a specific network address and a specific protocol identifier. An action object is generated on behalf of an application to resolve the network location of an endpoint. The action object asks the NELS service to resolve the network address and define the route to the endpoint in that network.","One of the following is passed to the action object to specify a destination endpoint: an EndpointAddress object; a fully decoded NetworkAddress object; and a string representing the IP address of the IP endpoint. In combination with the action objects, the NELS service determines which gateway to use to reach a particular resource. The appropriate gateway is determined using the discovery service of the appropriate topology driver and may change due to load balancing or failure of primary gateways. An \u201cEndpointAddress\u201d object must consist of a collection of at least one or more unique managed resource IDs. A managed resource ID decouples the protocol selection process from the application and allows the NELS service to have the flexibility to decide the best protocol to reach an endpoint. On return from the NELS service, an \u201cAddressEndpoint\u201d object is returned, which contains enough information to target the best place to communicate with the selected IP endpoints. It should be noted that the address may include protocol-dependent addresses as well as protocol-independent addresses, such as the virtual private network id and the IPOP Object ID. These additional addresses handle the case where duplicate addresses exist in the managed region.","When an action needs to be taken on a set of endpoints, the NELS service determines which endpoints are managed by which gateways. When the appropriate gateway is identified, a single copy of the action object is distributed to each identified gateway. The results from the endpoints are asynchronously merged back to the caller application through the appropriate gateways. Performing the actions asynchronously allows for tracking all results whether the endpoints are connected or disconnected. If the action object IP fails to execute an action object on the target gateway, NELS is consulted to identify an alternative path for the command. If an alternate path is found, the action object IP is transported to that gateway and executed. It may be assumed that the entire set of commands within one action object IP must fail before this recovery procedure is invoked.","With reference now to , a block diagram shows the manner in which data is stored by the IPOP (IP Object Persistence) service. IPOP service database  contains endpoint database table , system database table , and network database table . Each table contains a set of topological (topo) objects for facilitating the leasing of resources at IP endpoints and the execution of action objects. Information within IPOP service database  allows applications to generate action objects for resources previously identified as IP objects through a discovery process across the distributed computing environment.  merely shows that the topo objects may be separated into a variety of categories that facilitate processing on the various objects. The separation of physical network categories facilitates the efficient querying and storage of these objects while maintaining the physical network relationships in order to produce a graphical user interface of the network topology.","With reference now to , a block diagram shows the IPOP service in more detail. In the preferred embodiment of the present invention, an IP driver subsystem is implemented as a collection of software components for discovering, i.e. detecting, IP \u201cobjects\u201d, i.e. IP networks, IP systems, and IP endpoints by using physical network connections. This discovered physical network is used to create topology data that is then provided through other services via topology maps accessible through a graphical user interface (GUI) or for the manipulation of other applications. The IP driver system can also monitor objects for changes in IP topology and update databases with the new topology information. The IPOP service provides services for other applications to access the IP object database.","IP driver subsystem  contains a conglomeration of components, including one or more IP drivers . Every IP driver manages its own \u201cscope\u201d, which is described in more detail further below, and every IP driver is assigned to a topology manager within Topology Service , which can serve may than one IP driver. Topology Service  stores topology information obtained from discovery controller . The information stored within the Topology Service may include graphs, arcs, and the relationships between nodes determined by IP mapper . Users can be provided with a GUI to navigate the topology, which can be stored within a database within the Topology Service.","IPOP service  provides a persistent repository  for discovered IP objects. Discovery controller  detects IP objects in Physical IP networks , and monitor controller  monitors IP objects. A persistent repository, such as IPOP database , is updated to contain information about the discovered and monitored IP objects. IP driver may use temporary IP data store component  and IP data cache component  as necessary for caching IP objects or storing IP objects in persistent repository , respectively. As discovery controller  and monitor controller  perform detection and monitoring functions, events can be written to network event manager application  to alert network administrators of certain occurrences within the network, such as the discovery of duplicate IP addresses or invalid network masks.","External applications\/users  can be other users, such as network administrators at management consoles, or applications that use IP driver GUI interface  to configure IP driver , manage\/unmanage IP objects, and manipulate objects in persistent repository . Configuration service  provides configuration information to IP driver . IP driver controller  serves as central control of all other IP driver components.","Referring back to , a network discovery engine is a distributed collection of IP drivers that are used to ensure that operations on IP objects by gateways , , and  can scale to a large installation and provide fault-tolerant operation with dynamic start\/stop or reconfiguration of each IP driver. The IPOP Service manages discovered IP objects; to do so, the IPOP Service uses a distributed database in order to efficiently service query requests by a gateway to determine routing, identity, or a variety of details about an endpoint. The IPOP Service also services queries by the Topology Service in order to display a physical network or map them to a logical network, which is a subset of a physical network that is defined programmatically or by an administrator. IPOP fault tolerance is also achieved by distribution of IPOP data and the IPOP Service among many Endpoint ORBs.","One or more IP drivers can be deployed to provide distribution of IP discovery and promote scalability of IP driver subsystem services in large networks where a single IP driver subsystem is not sufficient to discover and monitor all IP objects. Each IP discovery driver performs discovery and monitoring on a collection of IP resources within the driver's \u201cscope\u201d. A driver's scope, which is explained in more detail below, is simply the set of IP subnets for which the driver is responsible for discovering and monitoring. Network administrators generally partition their networks into as many scopes as needed to provide distributed discovery and satisfactory performance.","A potential risk exists if the scope of one driver overlaps the scope of another, i.e., if two drivers attempt to discover\/monitor the same device. Accurately defining unique and independent scopes may require the development of a scope configuration tool to verify the uniqueness of scope definitions. Routers also pose a potential problem in that while the networks serviced by the routers will be in different scopes, a convention needs to be established to specify to which network the router \u201cbelongs\u201d, thereby limiting the router itself to the scope of a single driver.","Some ISPs may have to manage private networks whose addresses may not be unique across the installation, like 10.0.0.0 network. In order to manage private networks properly, first, the IP driver has to be installed inside the internal networks in order to be able to discover and manage the networks. Second, since the discovered IP addresses may not be unique in across an entire installation that consists of multiple regions, multiple customers, etc., a private network ID has to be assigned to the private network addresses. In the preferred embodiment, the unique name of a subnet becomes \u201cprivateNetworkId\\subnetAddress\u201d. Those customers that do not have duplicate networks address can just ignore the private network ID; the default private network ID is 0.","If Network Address Translator (NAT) is installed to translate the internal IP addresses to Internet IP addresses, users can install the IP drivers outside of NAT and manage the IP addresses inside the NAT. In this case, an IP driver will see only the translated IP addresses and discover only the IP addresses translated. If not all IP addresses inside the NAT are translated, an IP driver will not able to discover all of them. However, if IP drivers are installed this way, users do not have to configure the private network ID.","Scope configuration is important to the proper operation of the IP drivers because IP drivers assume that there are no overlaps in the drivers' scopes. Since there should be no overlaps, every IP driver has complete control over the objects within its scope. A particular IP driver does not need to know anything about the other IP drivers because there is no synchronization of information between IP drivers. The Configuration Service provides the services to allow the DKS components to store and retrieve configuration information for a variety of other services from anywhere in the networks. In particular, the scope configuration will be stored in the Configuration Services so that IP drivers and other applications can access the information.","The ranges of addresses that a driver will discover and monitor are determined by associating a subnet address with a subnet mask and associating the resulting range of addresses with a subnet priority. An IP driver is a collection of such ranges of addresses, and the subnet priority is used to help decide the system address. A system can belong to two or more subnets, such as is commonly seen with a Gateway. The system address is the address of one of the NICs that is used to make SNMP queries. A user interface can be provided, such as an administrator console, to write scope information into the Configuration Service. System administrators do not need to provide this information at all, however, as the IP drivers can use default values.","An IP driver gets its scope configuration information from the Configuration Service, which may be stored using the following format:\n\n","Typically, one IP driver manages only one scope. Hence, the \u201cscopeID\u201d and \u201cdriverID\u201d would be the same. However, the configuration can provide for more than one scope managed by the same driver. \u201cAnchorname\u201d is the name in the name space in which the Topology Service will put the IP networks objects.","A scope does not have to include an actual subnet configured in the network. Instead, users\/administrators can group subnets into a single, logical scope by applying a bigger subnet mask to the network address. For example, if a system has subnet \u201c147.0.0.0\u201d with mask of \u201c255.255.0.0\u201d and subnet \u201c147.1.0.0\u201d with a subnet mask of \u201c255.255.0.0\u201d, the subnets can be grouped into a single scope by applying a mask of \u201c255.254.0.0\u201d. Assume that the following table is the scope of IP Driver 2. The scope configuration for IP Driver 2 from the Configuration Service would be:\n\n",{"@attributes":{"id":"p-0110","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Subnet address","Subnet mask"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"147.0.0.0","255.255.0.0"]},{"entry":[{},"147.1.0.0","255.255.0.0"]},{"entry":[{},"146.100.0.0","255.255.0.0"]},{"entry":[{},"69.0.0.0","255.0.0.0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In general, an IP system is associated with a single IP address, and the \u201cscoping\u201d process is a straightforward association of a driver's ID with the system's IP address.","Routers and multi-homed systems, however, complicate the discovery and monitoring process because these devices may contain interfaces that are associated with different subnets. If all subnets of routers and multi-homed systems are in the scope of the same driver, the IP driver will manage the whole system. However, if the subnets of routers and multi-homed systems are across the scopes of different drivers, a convention is needed to determine a dominant interface: the IP driver that manages the dominant interface will manage the router object so that the router is not being detected and monitored by multiple drivers; each interface is still managed by the IP driver determined by its scope; the IP address of the dominant interface will be assigned as the system address of the router or multi-homed system; and the smallest (lowest) IP address of any interface on the router will determine which driver includes the router object within its scope.","Users can customize the configuration by using the subnet priority in the scope configuration. The subnet priority will be used to determinate the dominant interface before using the lowest IP address. If the subnet priorities are the same, the lowest IP address is then used. Since the default subnet priority would be \u201c0\u201d, then the lowest IP address would be used by default.","With reference now to , a network diagram depicts a network with a router that undergoes a scoping process. IP driver D1 will include the router in its scope because the subnet associated with that router interface is lower than the other three subnet addresses. However, each driver will still manage those interfaces inside the router in its scope. Drivers D2 and D3 will monitor the devices within their respective subnets, but only driver D1 will store information about the router itself in the IPOP database and the Topology Service database.","If driver D1's entire subnet is removed from the router, driver D2 will become the new \u201cowner\u201d of the router object because the subnet address associated with driver D2 is now the lowest address on the router. Because there is no synchronization of information between the drivers, the drivers will self-correct over time as they periodically rediscover their resources. When the old driver discovers that it no longer owns the router, it deletes the router's information from the databases. When the new driver discovers the router's lowest subnet address is now within its scope, the new driver takes ownership of the router and updates the various data bases with the router's information. If the new driver discovers the change before the old driver has deleted the object, then the router object may be briefly represented twice until the old owner deletes the original representation.","There are two kinds of associations between IP objects. One is \u201cIP endpoint in IP system\u201d and the other is \u201cIP endpoint in IP network\u201d. The implementation of associations relies on the fact that an IP endpoint has the object IDs (OIDs) of the IP system and the IP network in which it is located. Based on the scopes, an IP driver can partition all IP networks, IP Systems, and IP endpoints into different scopes. A network and all its IP endpoints will always be assigned in the same scope. However, a router may be assigned to an IP Driver, but some of its interfaces are assigned to different to different IP drivers. The IP drivers that do not manage the router but manage some of its interfaces will have to create interfaces but not the router object. Since those IP drivers do not have a router object ID to assign to its managed interfaces, they will assign a unique system name instead of object ID in the IP endpoint object to provide a link to the system object in a different driver.","Because of the inter-scope association, when the IP Persistence Service (IPOP) is queried to find all the IP endpoints in system, it will have to search not only IP endpoints with the system ID but also IP endpoints with its system name. If a distributed IP Persistence Service is implemented, the IP Persistence Service has to provide extra information for searching among IP Persistence Services.","An IP driver may use a Security Service to check the availability of the IP objects. In order to handle large number of objects, the Security Service requires the users to provide a naming hierarchy as the grouping mechanism. , described below, shows a security naming hierarchy of IP objects. An IP driver has to allow users to provide security down to the object level and to achieve high performance. In order to achieve this goal, the concepts of \u201canchor\u201d and \u201cunique object name\u201d are introduced. An anchor is a name in the naming space which can be used to plug in IP networks. Users can define, under the anchor, scopes that belong to the same customer or to a region. The anchor is then used by the Security Service to check if an user has access to the resource under the anchor. If users want the security group define inside a network, the unique object name is used. A unique object name is in the format of:\n\n","By using an IP-address, binary-tree, naming space, one can group all the IP addresses under a subnet in the same naming space that need to be checked by the Security Service.","For example, one can set up all IP addresses under subnet \u201c146.84.0.0:255.255.0.0\u201d under the naming space 12\/1\/0\/0\/1\/0\/0\/1\/0\/0\/1\/0\/1\/0\/1\/0\/0","and set the access rights based on this node name.","With reference now to , the IP Object Security Hierarchy is depicted. Under the root, there are two fixed security groups. One is \u201cdefault\u201d and the other is \u201call\u201d. The name of \u201cdefault\u201d can be configured by within the Configuration Service. Users are allowed to configure which subnets are under which customer by using the Configuration Service.","Under the first level security group, there are router groups and subnet groups. Those systems that have only one interface will be placed under the subnets group. Those systems that have more than one interface will be placed under the router group; a multi-home system will be placed under the router group.","Every IP object has a \u201csecurityGroup\u201d field to store which security group it is in. The following describes how security groups are assigned.","When a subnet is created and it is not configured for any customers, its securityGroup is \u201c\/default\/subnet\/subnetAddress\u201d. When a subnet is created and it is configured in the \u201ccustomer1\u201d domain, its \u201csecurityGroup\u201d value is \u201c\/customer1\/subnet\/subnetAddress\u201d.","When an IP endpoint is created and it is not configured for any customers, its \u201csecurityGroup\u201d value is \u201c\/default\/subnet\/subnetAddress\u201d. The subnet address is the address of the subnet in which the IP endpoint is located. When an IP endpoint is created and it is configured in the \u201ccustomer1\u201d domain, its \u201csecurityGroup\u201d value is \u201c\/customer1\/subnet\/subnetAddress\u201d. The subnet address is the address of the subnet in which the IP endpoint is located.","When a single interface IP system is created, it has the same \u201csecurityGroup\u201d value that its interface has. When a router or multi-home system is created, the \u201csecurityGroup\u201d value depends on whether all of the interfaces in the router or multi-home system are in the same customer group or not. If all of the interfaces of the router or multi-home system are in the same customer group, e.g., \u201ccustomer1\u201d, its \u201csecurityGroup\u201d value is \u201c\/customer1\/router\u201d. If the interfaces of the router or multi-home system are in more than one domain, its \u201csecurityGroup\u201d value is \u201c\/all\/router\u201d.","These are the default security groups created by an IP driver. After the security group is created for an object, IP driver will not change the security group unless a customer wants to change it.","The IP Monitor Controller, shown in , is responsible for monitoring the changes of IP topology and objects; as such, it is a type of polling engine, which is discussed in more detail further below. An IP driver stores the last polling times of an IP system in memory but not in the IPOP database. The last polling time is used to calculate when the next polling time will be. Since the last polling times are not stored in the IPOP database, when an IP Driver initializes, it has no knowledge about when the last polling times occurred. If polling is configured to occur at a specific time, an IP driver will do polling at the next specific polling time; otherwise, an IP driver will spread out the polling in the polling interval.","The IP Monitor Controller uses SNMP polls to determine if there have been any configuration changes in an IP system. It also looks for any IP endpoints added to or deleted from an IP system. The IP Monitor Controller also monitors the statuses of IP endpoints in an IP system. In order to reduce network traffic, an IP driver will use SNMP to get the status of all IP endpoints in an IP system in one query unless an SNMP agent is not running on the IP system. Otherwise, an IP driver will use \u201cPing\u201d instead of SNMP. An IP driver will use \u201cPing\u201d to get the status of an IP endpoint if it is the only IP endpoint in the system since the response from \u201cPing\u201d is quicker than SNMP.","With reference now to , a block diagram shows a set of components that may be used to implement adaptive discovery and adaptive polling. Login security subsystem  provides a typical authentication service, which may be used to verify the identity of users during a login process. All-user database  provides information about all users in the DKS system, and active user database  contains information about users that are currently logged into the DKS system.","Discovery engine , similar to discovery controller  in , detects IP objects within an IP network. Polling engine, similar to monitor controller  in , monitors IP objects. A persistent repository, such as IPOP database , is updated to contain information about the discovered and monitored IP objects. IPOP also obtains the list of all users from the security subsystem which queries its all-users database  when initially creating a DSC. During subsequent operations to map the location of a user to an ORB, the DSC manager will query the active user database .","The DSC manager queries IPOP for all endpoint data during the initial creation of DSCs and any additional information needed, such as decoding an ORB address to an endpoint in IPOP and back to a DSC using the IPOPOid, the ID of a network object as opposed to an address.","As explained in more detail further below with respect to , an administrator will fill out the security information with respect to access user or endpoint access and designate which users and endpoints will have a DSC. If not configured by the administrator, the default DSC will be used. While not all endpoints will have an associated DSC, IPOP endpoint data , login security subsystem , and security information  are needed in order to create the initial DSCs.","The DSC manager, acting as a DSC data consumer, explained in more detail further below, then listens on this data waiting for new endpoints or users or changes to existing ones. DSC configuration changes are advertised by a responsible network management application. Some configuration changes will trigger the creation of more DSCs, while others will cause DSC data in the DSC database to be merely updated.","All DSCs are stored in DSC database  by DSC creator , which also fetches DSCs upon configuration changes in order to determine whether or not a DSC already exists. The DSC manager primarily fetches DSCs from DSC database , but also adds runtime information, such as ORB ID, which is ultimately used to determine the manner in which the polling engine should adapt to the particular user or endpoint.","IPOP  also incorporates scope manager , which stores information about scopes, such as the maximum number of endpoints within each scope . Scope manager  computes relationships between endpoints and scopes, as necessary. IPOP  also stores the number of endpoints that have been discovered for each network or scope , which is used by discovery life cycle engine . The computed life cycles are then used to determine polling intervals as derived from polling intervals . This information is described further below in more detail with respect to .","With reference now to , a flowchart depicts a portion of an initialization process in which a network management system prepares for adaptive discovery and adaptive polling. The process begins with the assumption that a network administrator has already performed configuration processes on the network such that configuration information is properly stored where necessary. The discovery engine performs a discovery process to identify IP objects and stored those in the IPOP persistence storage (step ).","The DSC creator in the DSC manager generates \u201cinitial\u201d DSC objects and stores these within the DSC database (step ).","A source user then performs a login on a source endpoint (step ). An application may use a resource, termed a target resource, located somewhere within the distributed system, as described above. Hence, the endpoint on which the target resource is located is termed the \u201ctarget endpoint\u201d. The endpoint on which the application is executing is termed the \u201csource endpoint\u201d to distinguish it from the \u201ctarget endpoint\u201d, and the user of the application is termed the \u201csource user\u201d.","As part of the login process, the security subsystem updates the active user database for the ORB on which the application is executing (step ). The initialization process is then complete.","With reference now to , a flowchart depicts further detail of the initialization process in which the DSC objects are initially created and stored.  provides more detail for step  shown in .","The process shown in  provides an outline for the manner in which the DSC manager sets up associations between users and endpoints and between endpoints and endpoints. These associations are stored as special objects termed \u201cDSC objects\u201d. A DSC object is created for all possible combinations of users and endpoints and for all possible combinations of endpoints and endpoints. From one perspective, each DSC object provides guidance on a one-to-one authorization mapping between two points in which a first point (source point) can be a user or an endpoint and a second point (target point) is an endpoint.",{"@attributes":{"id":"p-0142","num":"0149"},"figref":"FIG. 7B"},"Not all network monitoring and management tasks require that a user initiate the task. Some network management applications will perform tasks automatically without a user being logged onto the system and using the network management application. At some point in time, an application executing on a source endpoint may automatically attempt to perform an action at a target endpoint. Prior to completing the necessary network management task, the system must check whether the source endpoint has the proper authorization to perform the task at the target endpoint in a manner similar to the case of the source user performing an action at a target endpoint.","When the system needs to perform an authorization process, the previously created and stored DSC objects can be used to assist in the authorization process. By storing the DSC objects within a distributed database, a portion of the authorization process has already been completed. Hence, the design of the system has required a tradeoff between time and effort invested during certain system configuration processes and time and effort invested during certain runtime processes. A configuration process may require more time to complete while the DSC objects are created, but runtime authorization processes become much more efficient.","The DSC objects are created and stored within a distributed database during certain configuration processes throughout the system. A new system usually undergoes a significant installation and configuration process. However, during the life of the system, endpoints may be added or deleted, and each addition or deletion generally requires some type of configuration process. Hence, the DSC objects can be created or deleted as needed on an ongoing basis.","The present system also provides an additional advantage by storing the DSC objects within a highly distributed database. Because the network management system provides an application framework over a highly distributed data processing system, the system avoids centralized bottlenecks that could occur if the authorization processes had to rely upon a centralized security database or application. The first DSC fetch requires relatively more time than might be required with a centralized subsystem. However, once fetched, a DSC is cached until listeners on the configuration data signal that a change has occurred, at which point the DSC cache must be flushed.","The process in  begins with the DSC manager fetching endpoint data from the IPOP database (step ). The IPOP database was already populated with IP objects during the discovery process, as mentioned in step  of . The DSC manager fetches user data from the all-user database in the security subsystem (step ). Configuration data is also fetched from the Configuration Service database or databases (step ), such as ORB IDs that are subsequently used to fetch the ORB address. A network administration application will also use the configuration service to store information defined by the administrator. The DSC manager then creates DSC objects for each user\/endpoint combination (step ) and for each endpoint\/endpoint combination (step ), and the DSC object creation process is then complete.","With reference now to , a flowchart depicts further detail of the initial DSC object creation process in which DSC objects are created and stored for an endpoint\/user combination.  provides more detail for step  in . The process shown in  is a loop through all users that can be identified within the all-user database. In other words, a set of user accounts or identities have already been created and stored over time. However, all users that have been authorized to use the system do not have the same authorized privileges. The process shown in  is one of the first steps towards storing information that will allow the system to differentiate between users so that it can adaptively monitor the system based partially on the identity of the user for which the system is performing a monitoring task.","The process in  begins by reading scope data for a target endpoint from the IPOP database (step ). The DSC creator within the DSC manager then reads scope data for a source user from the IPOP database (step ). A determination is then made as to whether or not the source user is allowed to access the target endpoint (step ). This determination can be made in the following manner. After the initial DSC is obtained, the source user information is used to make an authorization call to the security subsystem as to whether or not the source user has access to the security group defined in the DSC. It may be assumed that the security system can perform this function efficiently, although the present invention does not depend on auto-generation of security names or security trees. Once an authorization step is complete, the present system adapts the polling engine per the user\/endpoint combination. The present invention should not be understood as depending upon any particular implementation of security authorization.","If not, then the process branches to check whether another user identity should be processed. If the source user is allowed to access the target endpoint, then a DSC object is created for the current source user and current target endpoint that are being processed (step ). The DSC object is then stored within the DSC database (step ), and a check is made as to whether or not another source user identity requires processing (step ). If so, then the process loops back to get and process another user, otherwise the process is complete.","With reference now to , a flowchart depicts further detail of the initial DSC object creation process in which DSC objects are created and stored for an endpoint\/endpoint combination.  provides more detail for step  in . The process shown in  is a loop through all endpoints that can be identified within the IPOP database; the IPOP database was already populated with IP objects during the discovery process, as mentioned in step  of . During runtime operations, an application executing on a source endpoint may attempt to perform an action at a target endpoint. However, not all endpoints within the system have access to requesting actions at all other endpoints within the system. The network management system needs to attempt to determine whether or not a source endpoint is authorized to request an action from a target endpoint. The process shown in  is one of the first steps towards storing information that will allow the system to differentiate between endpoints so that it can adaptively monitor the system based partially on the identity of the source endpoint for which the system is performing a monitoring task.","The process in  begins by reading scope data for a target endpoint from the IPOP database (step ). The DSC creator within the DSC manager then reads scope data for a source endpoint from the IPOP database (step ). A determination is then made as to whether or not the source endpoint is allowed to access the target endpoint (step ) based on the scope defined in the DSC. For example, a simple scope of X.Y.Z.* will allow an address of X.Y.Z.Q access. If not, then the process branches to check whether another source endpoint should be processed. If the source endpoint is allowed to access the target endpoint, then a DSC object is created for the source endpoint and target endpoint that are currently being processed (step ). The DSC object is then stored within the DSC database (step ), and a check is made as to whether or not another source endpoint requires processing (step ). If so, then the process loops back to get and process another endpoint, otherwise the process is complete.","The present invention is applicable to variety of uses, and the previous figures described a general manner in which a device scope context can be associated with a source user or a source endpoint. The following figures describe a particular use of the present invention in which DSCs are used to perform polling tasks associated with determining whether or not systems are up or down.","With reference now to , a figure depicts a graphical user interface window that may be used by a network or system administrator to set monitoring parameters for adaptive monitoring associated with users and endpoints. Window  shows a dialog box that is associated with a network management application. Input area  allows a system or network administrator to set polling intervals and to specify whether the polling intervals are to be associated with a user or with an endpoint. Input field  allows the user to input a numerical value for the polling interval, which is the length of time between polls of an endpoint. Radio button  allows an administrator to associate the polling interval with a specific user as specified by drop-down menu . Radio button  allows an administrator to associate the polling interval with a specific endpoint as specified by drop-down menu .","Input area  allows a system or network administrator to specify whether the user or the endpoint is to be used as a primary DSC. As described above, DSC objects are created for both a user\/endpoint combination and an endpoint\/endpoint combination. Radio buttons - allow the user to select whether the polling time intervals that are associated with the user or that are associated with the endpoint are to be regarded as primary or controlling. If a user is logged onto to an ORB associated with an endpoint, such that it might be possible that the polling engine should poll on an interval associated with the network administrator, the selection of the primary DSC will determine whether the DSC should use the polling interval values associated with the user or the endpoint if available. Buttons  and  allow the user to set the values as necessary.","With reference now to , a flowchart shows a process by which the polling time parameters are set in the appropriate DSC objects after polling time parameters have been specified by an administrator. The process begins when the administrative application receives a request to set a polling interval (step ), e.g., when a user enters a polling interval value in window  in . A determination is then made as to whether or not the polling interval is to be associated with a source user (step ). If so, the DSC manager fetches a DSC for a specified user\/endpoint combination (step ), and the new polling interval is added as a property to the DCS (step ).","If the parameter is being associated with a user, as determined in step , then the process determines whether there are other target endpoints with which the polling interval should be associated (step ). If so, then the process loops back to step  to process another user\/endpoint combination. If not, then the process is complete for all user\/endpoint combinations.","If it is determined that the polling interval is to be associated with a source endpoint (step ), then the DSC manager fetches a DSC for a specified endpoint\/endpoint combination (step ), and the new polling interval is added as a property to the DCS (step ). The process then determines whether there are other target endpoints with which the polling interval should be associated (step ). If so, then the process loops back to step  to process another endpoint\/endpoint combination. If not, then the process is complete for all endpoint\/endpoint combinations.","If it is determined that the polling interval is not to be associated with a source endpoint at step , then the system can log or report an error (step ), and the process is complete.","With reference now to , a flowchart shows a process by which a polling time property is added to a DSC after polling time parameters have been specified by an administrator. The DSC manager gets a property vector from the DKS configuration service which has stored the values entered by the administrator in window  of  (step ) and sets the user-specified polling interval in the property vector (step ). In other words, the DSC manager and an administration application, such as that shown as window  in , communicate via properties stored by the configuration service. The DSC manager is then instructed to add rows to the DSC database for the new property (step ). The new property is advertised to \u201cconsumers\u201d or users of the property, as needed (step ), and the process is complete.","With reference now to , a flowchart shows a process for advertising newly specified polling time properties after polling time parameters have been specified by an administrator. The process begins with the DSC manager determining the DSC component or DSC consumer of the newly specified property (step ). The DSC consumer is then notified of the updated property (step ), and the process is complete.","With reference now to , a flowchart shows a process used by a polling engine to monitor systems within a network after polling time parameters have been specified by an administrator. The process begins with the system determining the appropriate network for which the polling engine is responsible for monitoring (step ). After the network is determined, then all of the systems within the network are identified (step ), and all of the endpoints within those systems are identified (step ). All of these data items are cached, as the polling engine will attempt to poll each of the endpoints on the appropriate intervals.","The polling engine then selects a target endpoint (step ) to be polled. A DSC object for the source endpoint for the polling request is obtained (step ), and a DSC object for the user logged on to the source endpoint is also obtained (step ). The polling engine then requests the DSC manager for a DSC to be used during the polling operation (step ). The polling engine then begins polling the target endpoint on the proper interval (step ), and the process is complete.","It should be noted that the polling process may be continuous; for example, the administrator has requested that the administration application continually monitor the status of a certain set of devices. In other cases, the administrator may be performing \u201cdemand polling\u201d on a more limited basis at the specific request of an administrator. Hence, the process shown in  may be part of a continuous loop through polling tasks.","With reference now to , a flowchart shows a process used by a polling engine to get a DSC for a user\/endpoint combination.  provides more detail for step  in . The process begins when the polling engine asks the ORB for a host name (step ), and then the polling engine asks a domain name server for an address associated with the host name (step ). The IPOP Service is requested to construct an endpoint from the address from the domain name server (step ), and the DSC manager is requested to construct a DSC object from the source endpoint and the target endpoint (step ). The process of obtaining this DSC is then complete.","With reference now to , a flowchart shows a process used by a polling engine to get a DSC for an endpoint\/endpoint combination.  provides more detail for step  in . The process begins when the polling engine asks the security authentication subsystem for the source user that is logged onto the same ORB on which the polling engine resides (step ). The DSC manager is requested to construct a DSC object for the source user and the target endpoint (step ). The process of obtaining this DSC is then complete.","With reference now to , a flowchart shows a process used by a polling engine to get a DSC from the DSC manager.  provides more detail for step  in . The process begins when the polling engine sends both newly constructed DSCs to the DSC manager (step ), and the DSC manager searches for a DSC within the DSC database that matches one of the two newly constructed DSCs (step ). While it is possible to have two matches, i.e. a user\/endpoint match and an endpoint\/endpoint match, the selection of a primary DSC, or similarly, the system enforcement of a default primary DSC, avoid collisions. The DSC manager then returns a matching DSC to the polling engine, if available, and the process is complete.","With reference now to , a flowchart shows a process used by a polling engine to queue a polling task. The process shown in  and  provides more detail for step  shown in . The process begins when a check is made as to whether a matching DSC is available (step ). If so, then the polling time interval is obtained from the DSC (step ). If not, then the polling time interval is set to a default value for this or all endpoints (step ). In either case, the polling engine stores the polling time interval in its cache for the endpoint (step ). A task data structure for the poll action on the target endpoint is then queued (step ), and the process is complete.","With reference now to , a flowchart shows a process used by a polling engine to perform a polling task on an endpoint. Again, the process shown in  and  provides more detail for step  shown in . The process begins by retrieving the next poll task from a task queue (step ). As the polling engine's main function is to poll systems within the highly distributed network, the polling engine may have a component whose sole purpose is to manage the task queue as a large event loop. A set of execution threads within a thread pool can be used as a set of resources; each polling task can be placed on a separate thread. The threads can then be blocked, put to sleep, etc., while the thread awaits the completion of its task.","The time of the last poll of the target endpoint is then retrieved (step ). The last poll time is then compared with the polling interval for the target endpoint, and a check is made as to whether or not enough time has passed since the last poll in accordance with the specified polling interval (step ). If so, then a ping is sent to the target endpoint (step ).","Before the polling engine asks the gateway for an application action object, such as application action object  shown in , the polling engine asks the DSC manager for a DSC by giving the DSC manager the source endpoint and the target endpoint. The DSC manager then looks for matches with the user\/target endpoint DSC and the source endpoint\/target endpoint DSC in the DSC database. If no DSC exists, then the default DSC is returned to the polling engine. If two DSCs exist, then the DSC manager will determine whether to use the user\/endpoint or endpoint\/endpoint DSC based on the primary DSC defined by the administrator, as explained above. If the polling engine receives no DSC, then the action is not authorized and the polling engine does not unnecessarily ask the gateway for an application action object.","At a subsequent point in time, the thread that is being used for the polling task awakes (step ), and a determination is made as to whether or not a good ping response has been received for the previous ping for this task (step ). If so, then the polling engine can report or log that the target endpoint is operational, i.e. up (step ), and the process for this poll task is complete.","If a good ping response has not been received, then a determination is made as to whether or not the ping has timed out (step ). If so, then the polling engine can report or log that the target endpoint is not operational, i.e. down (step ), and the process for this poll task is complete.","If the ping has not yet timed out at step , then the thread again waits for the response at step . If appropriate polling interval for this endpoint has not yet passed, then the endpoint should not yet be polled again, and the process branches to exit the thread (step ) and process another task in the task queue.","As described above with respect to , management processes within a network management framework can adaptively discover and monitor devices based partially on the identity of the applications, users, and endpoints that are involved in performing a monitoring task. As shown in , a status gathering process performed by a polling engine is one example of a monitoring process that may be performed. Users and\/or applications are authorized to perform certain actions within the system, such as on-demand polling, continuous polling, etc., and the polling intervals that are used by a monitor controller, i.e. polling engine, can vary depending upon the user or application that is responsible for requesting the actions.","The polling engine resides within an IP driver, which has been configured to listen for changes to properties in the IPOP database. Polling intervals can be changed by an administrator, and the updated intervals are dynamically retrieved by the polling engine prior to each new polling cycle, if necessary. In addition to the methods described above, the network application framework used by the present invention allows the management system to dynamically change the polling intervals in other ways.","As noted previously, within a system that performs network management tasks for a million devices or more, a tremendous amount of computational resources throughout the system could be consumed for the managerial functions. The network management tasks should be configured so as to minimize the impact of the network management processes on the performance of the rest of the system.","Moreover, the requirements for monitoring operations are not necessarily constant during the lifetime or uptime of a network. For example, during initialization phases when systems are being installed, an administrator may desire to perform more frequent status monitoring, while another administrator may desire to reduce network traffic to a minimum and would request very little monitoring. After a network reaches a steady state phase, the administrators may desire to change the frequency of the monitoring operations.","In order to provide these features, the network application framework used by the present invention performs monitoring operations in accordance with a phase\/life cycle of one or more network management applications. As the network management applications dynamically discover systems or devices within one or more networks, the present invention allows the management system to dynamically change the polling intervals based on the life cycle, i.e. age, stage, or phase, of the network and\/or its management applications.","For example, a service provider might manage multiple networks belonging to multiple customers, and it can be assumed that each network is brought online at different times. As the network management system installs, initializes, and monitors each network, the network passes through a series of discovery states, initialization states, etc., that each state represents an individual life cycle. In other words, a management application dynamically tunes its monitoring operations to reflect the state of a network.","In a highly distributed system, monitoring operations are performed by multiple components throughout the system. As described with respect to , an IP driver is responsible for monitoring one or more scopes, and multiple IP drivers are distributed throughout the overall distributed system. For example, a service provider may have a set of multiple IP drivers that are responsible for monitoring the networks of a one customer, and the service provider could have another set of IP drivers that are responsible for monitoring the networks of another customer. Each IP driver, including its monitor controller, discovery controller, etc., can tune a monitoring operation to each network's or scope's life cycle. In one perspective, since the operational state of an IP driver reflects the operational state of its monitored devices, the present invention can be described as providing monitoring operations in accordance with a phase or life cycle of a performance monitoring component, such as an IP driver.","Referring again to , IPOP provides storage for many different types of data, including information concerning the life cycle of a network, such as the polling intervals to be used by a polling engine depending upon the life cycle of a scope or network. The manner in which this information is maintained is described below in more detail with respect to ; the flowcharts in these figures refer to processes that operate upon a set of endpoints within a network, but it should be noted that the endpoints may be grouped into a set of endpoints as required by an administrator with respect to customer requirements, service provider requirements, etc., such as subnets, scopes, etc. It should be understood that some of the processes that are shown in the flowcharts are continually executed during the lifetime of the network management system; after the network management system has been configured and initialized and as long as the network management is active, these processes continue to monitor and update databases, etc.","With reference now to , a flowchart depicts an overall process by which a network management system dynamically changes the polling intervals for endpoints within networks based upon the life cycle of a scope or network. The process begins with IPOP determining the completion percentage for a certain discovery process for a given network (step ). The discovery life cycle engine within IPOP then determines the life cycle state for the network (step ), after which IPOP stores an updated polling interval value as derived from the life cycle state for each endpoint in the network (step ). When necessary, the IP driver for the network then fetches the updated polling interval for a given endpoint to perform some type of status monitoring or status gathering activity on the given endpoint (step ), and the process is complete.","With reference now to , a flowchart depicts a process by which a network management system computes a completion percentage for a discovery process within a given network. The process shown in  provides more detail for step  in . The process begins with IPOP asking the scope manager for the maximum number of endpoints that are possibly contained within a given network (step ). IPOP determines the number of endpoints that have been discovered for the network by the discovery controller (step ). IPOP then computes the discovery completion percentage for the network based on the number of endpoints which have been discovered for the network and the maximum possible number of endpoints for the network (step ). The discovery completion percentage can be stored for subsequent use, and the process is then complete.","With reference now to , a flowchart depicts a process by which a network management system updates a percentage of the number of endpoints discovered within a given network. The process begins when a determination is made as to whether a discovery process has discovered a new endpoint (step ). If not, then the discovery controller loops to continue monitoring for newly discovered endpoints. If a new endpoint has been discovered, then the maximum number of endpoints in the network is retrieved from the scope manager (step ). By incrementing the number of endpoints that have been discovered, the discovery completion percentage for the network is then computed and stored (step ), and the process is complete.","With reference now to , a flowchart depicts a process by which a network management system converts a percentage of the number of endpoints discovered in a given network to a life cycle state for a given network that is eventually used to determine an endpoint polling interval. It should be understood that the percentages used within  are only examples, and the network management system could be implemented in a manner that allows an administrator to set the percentage values as required. For example, a set of percentage values could be stored per customer, per network, per scope, etc.","The process begins by with the life cycle engine determining whether or not the discovery controller within an IP driver associated with a given network is active (step ). If not, then the discovery completion percentage is examined.","If the discovery completion percentage is less than a particular threshold (step ), such as 10%, then this scenario may reflect a situation in which an IP driver or discovery controller has been stopped very early in the discovery process, i.e. very early in the life cycle of the network management component, in which case an active polling process is probably not required. Hence, the life cycle engine returns a life cycle state equal to \u201cpre-discovery\u201d and an endpoint polling interval value equal to \u201clow\u201d (step ), after which the process is complete.","If the discovery completion percentage is greater than a particular threshold (step ), such as 85%, then this scenario may reflect a situation in which an administrator has run a discovery process but then turned off any future discovery since the discovery controller is not active. In this case, an active polling process might be desired to closely monitor those systems which have already been discovered. Hence, the discovery life cycle engine returns a life cycle state equal to \u201cpost-discovery\u201d and an endpoint polling interval value equal to \u201chigh\u201d (step ), after which the process is complete.","If the discovery completion percentage is somewhere in between the low threshold and the high threshold, the system might allow the polling interval to remain unchanged.","If the discovery controller is active, then the network management system should be finding or discovering devices or machines on the network through the operation of the discovery controller. The discovery life cycle engine then determines whether the discovery completion percentage is less than or equal to an initial discovery threshold (step ), such as less than 30% of the network having been previously discovered. In this situation, there may be a high rate of writes to the IPOP service because the network management system may be creating endpoint objects within IPOP has the endpoints are rapidly discovered. In this case, a low status polling interval is required since the endpoints have just been recently added to IPOP, i.e. the network management system does not need to poll a device from which it has just received information during the discovery process and for which the network management system can assume that the device is active or online. Hence, the discovery life cycle engine returns a life cycle state equal to \u201cdiscovery phase\u2014initialization\u201d and an endpoint polling interval value equal to \u201clow\u201d (step ), after which the process is complete.","If the discovery controller is active and the discovery completion percentage is not less than or equal to an initial discovery threshold, then the network management system should be finding or discovering devices or machines on the network through the operation of the discovery controller. The discovery life cycle engine then determines whether the discovery completion percentage is less than or equal to steady-state discovery threshold (step ), such as between 30-85% of the network having been previously discovered. In this situation, there may be a high rate of reads to the IPOP service to determine whether or not an endpoint being processed by an IP driver has already been discovered. In addition, IPOP may be experiencing a medium level of writes for creating endpoints. While an IP driver may use a local cache, the number of endpoints may grow too numerous or too quickly for the local cache to be much use, forcing the IP driver to query IPOP more often. Hence, the discovery life cycle engine returns a life cycle state equal to \u201cdiscovery phase\u2014steady-state\u201d and an endpoint polling interval value equal to \u201cmedium\u201d (step ), after which the process is complete.","If the discovery controller is active and the discovery completion percentage is greater than the steady-state discovery threshold, then the network management system should be mostly complete with finding or discovering devices or machines on the network through the operation of the discovery controller. The discovery life cycle engine then determines whether the discovery completion percentage is less than or equal to a status-gathering threshold (step ), such as greater than 85% but less than 100% of the network having been previously discovered. In this situation, there may be a high rate of reads to the IPOP service to determine whether or not an endpoint being processed by an IP driver has already been discovered. In addition, IPOP would be experiencing a low level of writes for creating endpoints as most endpoints have already been discovered. In this situation, an administrator may desire a high amount of polling. Hence, the discovery life cycle engine returns a life cycle state equal to \u201cstatus gathering\u201d and an endpoint polling interval value equal to \u201chigh\u201d (step ), after which the process is complete.","If the discovery life cycle engine does not place the discovery completion percentage within one of a set of predetermined ranges, then it may be assumed that an discovery life cycle has been previously set, and the IP driver will continue to use the polling intervals associated with the previously determine life cycle.","As described above with respect to , the network application framework used by the present invention performs monitoring operations in accordance with a phase\/life cycle of one or more network management applications. As the network management applications dynamically discover systems or devices within one or more networks, the present invention allows the management system to dynamically change the polling intervals based on the life cycle, i.e. age, stage, or phase, of the network and\/or its management applications.","In a similar manner, the network application framework of the present invention uses an improved iterator methodology to dynamically change the administrative communication operations of the network management system so as to minimize the impact on system performance, including customer applications, that might be caused by administrative operations. In particular, the adjustments to the operations also occur in accordance with a phase or life cycle state of system management applications. These features are described below in more detail with respect to .","With reference now to , a block diagram depicts some of the data that may be stored within the IPOP database to facilitate dynamically tuning the data communication operations of the network management system. The IPOP service stores data in a highly distributed database for a variety of purposes in the DKS system, as explained above with respect to other figures. IPOP  stores object-oriented data iterator , termed the Intelligent IPOP Iterator (IIPOPI), which facilitates the data transfer between an IPOP endpoint and another endpoint. IIPOPI  can be dynamically configured to transmit or receive a certain number of data items; in the present invention, the IIPOPI adapts based on the life cycle of an application or monitored network or scope.  explain the manner in which life cycle states are determined.","IPOP also provides application APIs , which any application can invoke to read and\/or write network object data from IPOP. IPOP also includes mapping functionality  that maps a life cycle state and an API type, taken together, to a data chunk size parameter that indicates the size of the data chunks to be transferred during data iteration operations by the IIPOPI. IPOP also includes IPOPOid address decoder functionality  that accepts an IPOPOid, which is an identifier associated with a network object, and produces its network address, such as an IP address.","The mapping operations rely upon configuration parameters that may be set by a system administrator interactively or may be otherwise provided through the configuration service. IPOP stores these parameters as API usage attributes , which comprises attributes that are customizable per application that uses the attributes. In other words, each application that requires the use of the IIPOPI can have its own configurable set of parameters; otherwise, the application may rely upon default parameters. As an example, the attributes for an IP driver are shown in  as attributes . These attributes include a primary API usage  by the identified application, e.g., IP driver; the primary API usage indicates whether the identified application uses the IIPOPI primarily for reading data from IPOP or for writing to IPOP in a given application life cycle state. For completeness, a set of API types  and application life cycle states  are shown; these are used by the attribute mapping facility to obtain the data transfer parameters to be used the IIPOPI.","With reference now to , a set of diagrams depict a graphical user interface window that may be used by an administrator as provided by a system management application in order to dynamically tune the data communication operations of the network management system.","Referring to , window  is a dialog box that may be used by an administrator to set the data transfer parameters, which are then stored for later use by the IIPOPI component shown in . A drop-down menu of choices may be provided for any parameters that may be chosen, or the user may enter values for the parameters. It should be understood that these parameters may be specified in a variety of manners, including a command line interface.","Drop-down menu  allows a user, such as a system administrator, to select an application name for which the parameters will be associated. \u201cSet\u201d button  allows a user to set the values as acceptable values, while \u201cClear\u201d button  allows the user to clear the values, either within window  and\/or within the parameter storage. Drop-down menu  allows a user to choose the application life cycle state for which parameters are being set; parameters may be set per life cycle state, if desired. Drop-down menu  preferably controls the values that appear in other drop-down menus in a hierarchical manner, as is known in the graphical user interface arts.","Column  lists the operational attributes within the state mapper facility in IPOP or within the IIPOPI, as necessary, for which an administrator may desire to set values. Column  lists the controls or entry fields by which the user may set those attribute values. Drop-down menu  provides values for the primary API type for the previously chosen life cycle state . Drop-down menu  provides values for the data chunk size for the previously chosen life cycle state .","Referring to , drop-down menu  provides values for a user to choose the application life cycle state, i.e. drop-down menu  shows all of the values that may appear when a user operates drop-down menu  in . Referring to , drop-down menu  provides values for a user to choose the primary API type, i.e. drop-down menu  shows all of the values that may appear when a user operates drop-down menu  in . Referring to , drop-down menu  provides values for a user to choose the data chunk size, i.e. drop-down menu  shows all of the values that may appear when a user operates drop-down menu  in .","With reference now to , some pseudo-code depicts a manner in which the present invention could be implemented in an object-oriented fashion.  shown how an IIPOPI (IntelligtentIPOPIterator) Class extends the standard Java \u201cIterator\u201d Class to include a data chunk size value, an application life cycle state value, an API usage value, the actual data content storage space, an application iteration count, and a vector position for tracking the data that has already been retrieved.  shows a simple IPOPOid Class for implementing an IPOPOid, including the type of IPOP object, its IP address, and its VPN ID, if necessary.","With reference now to , a flowchart depicts a manner in which the IPOP service can listen for configuration changes so the intelligent IPOP iterator can be dynamically changed while in operation. The process begins by initializing a listener for IPOP to listen for changes to configuration data that may affect the manner in which an instance of IIPOPI operates (step ). In other words, IPOP can listen for a change in the life cycle state for a particular application, network, or scope.  represents an non-terminating event loop; obviously, the process may terminate in conjunction with the termination of the supporting application.","A determination is then made as to whether an IPOP configuration change has been detected (step ). The process may loop indefinitely at this point listening for changes. If a change has been detected, then a check is made as to whether there are any active IPOP APIs (step ). In other words, IPOP can determine whether there are any active data transfers with instances of IIPOPI iterators. If so, then IPOP waits until it can update the appropriate IIPOPI instance. If there are no active IPOP APIs, then IPOP reconfigures one or more instances of IIPOPI, as necessary, by asking the state-to-chunk size mapper, such as mapper  shown in , to redetermine the chunk size. The IIPOPI instances can be updated in any appropriate manner, such as pushing new data chunk size values to the instances, updating a configuration value on which the instances listen, terminating and reinitializing the instances, etc. The process then continues looping within the event loop.","For example, an IP driver application located somewhere within the distributed data processing system controlled by the DKS framework may be actively discovering and monitoring devices. As it does so, the life cycle state for the IP driver, which is responsible for managing one or more particular networks or scopes, may change, as explained above with respect to . If the life cycle state changes, then the listener will detect the change, and the manner in which the IIPOPI operates will also automatically change. Moreover, as a network \u201cages\u201d, the manner in which applications store and retrieve data from IPOP will change as the underlying mechanism for storing and retrieving data, i.e. IIPOPI, changes. This is particularly useful because the bandwidth requirements of the IP driver subsystem may change with the evolving ages of the networks controlled by the IP driver subsystem. A specific IP driver example is explained in more detail with respect to .","With reference now to , a set of flowcharts depict the runtime operations of an application's request to IPOP to read a large amount of data for which the management system implements an intelligent iterator. The process begins when an IP driver uses an IPOP API to fetch a set of endpoints associated with a particular network IPOPOid (step ) by passing a network address and a network VPN ID, if necessary (as shown in ), into the API request. In other words, an IP driver may request all endpoints that are located within the physical network identified by the specified IPOPOid. Using the network IPOPOid, IPOP queries its endpoint table in the IPOP database for all endpoints residing in the specified network (step ). IPOP accumulates the located endpoints and creates an iterator from an appropriate database call (step ).","IPOP then creates an IntelligentIPOPIterator (IIPOPI) from the iterator object created in the previous step. As controlled by the life cycle state and API usage, the data chunk size parameter indicates various sizes to be used for data transfers, either by a configuration value or a default value. In general, various size could be used, but in this example, two sizes are used: \u201cLong\u201d and \u201cShort\u201d. If the data chunk size is \u201cLong\u201d, then the IIPOPI instance creates a large data vector, and if the data chunk size is \u201cShort\u201d, then the IIPOPI instance creates a small data vector. The IPOP service, acting as a sort of server for the IIPOPI instance, sends the IIPOPI instance back to the IP driver application with the IIPOPI instance's count variable set to zero (step ).","The IP driver application uses an appropriate API to read an endpoint, e.g., by invoking a method such as \u201cgetElement(iteratorPosition)\u201d to obtain the next endpoint, ostensibly from the IPOP database by actually obtained via an IIPOPI instance (step ). The count variable in the IIPOPI instance is incremented by one (step ), and a determination is made as to whether the value of the count variable is greater than or equal to the data chunk size (step ). If not, then the process branches without refreshing its cache.","If the count variable is greater than or equal to the data chunk size, then the IIPOPI instance refreshes its vector contents from the IPOP database (step ) and resets its count variable. The IIPOPI instance converts its iterator position\/pointer to a data vector position in order to know the location from which to read data from its storage vector of cached data (step ). The data is then fetched from the vector and returned to the application (step ), and the process is complete.","In summary, if the IIPOPI instance has already retrieved a chunk of data, then the data would be quickly returned to the IP driver application. If the IIPOPI instance does not have any data locally, either because it has not yet retrieved data from the IPOP database or has merely exhausted its local cache, then the IIPOPI instance retrieves the next chunk of data from the IPOP database on behalf of the IP driver application. In this manner, the IP driver application is not aware of the iterator mechanism for sending and retrieving data.","The advantages of the present invention should be apparent in view of the detailed description of the invention that is provided above. In prior art systems, a Java Iterator class could be used to control data communication between two points, and ideally, standard iterator objects have all of the data local to the consuming application.","However, in the present invention, the distributed data system is very large, potentially comprising millions of endpoints, and the memory available at each individual device may not be capable of receiving large amounts of data through a standard Iterator object. In addition, the data is not stored locally but is distributed throughout the system.","In contrast, the present invention uses an improved iterator methodology to provide a method and system that dynamically adapts the administrative communication operations of the network management system so as to minimize the impact on system performance, including customer applications, that is caused by the system management operations. In particular, the adjustments to the operations occur in accordance with a phase or life cycle state of system management applications.","The present invention has advantages because it limits the number of different object to only three types (Network, Endpoint, and System), which in turn limits the number of tables within the highly distributed database that is implemented in the system; the database grows in rows and not columns, making data access much more efficient. An application can tune the amount of data that is to be chunked in the intelligent IPOP iterator. The iterator of the present invention allows efficient bandwidth usage in a system of a million or more devices in which database tables would be too large to send across a network using currently available queue mechanisms. Hence, memory usage on the endpoint that is executing a given application can be dynamically adjusted, i.e. tuned, thereby tuning the communication bandwidth between the IPOP endpoint and the application endpoint that is sending or receiving data. A consuming application can use one API while the system administratively performs multiple data operations in chunks.","It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of instructions in a computer readable medium and a variety of other forms, regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include media such as EPROM, ROM, tape, paper, floppy disc, hard disk drive, RAM, and CD-ROMs and transmission-type media, such as digital and analog communications links.","The description of the present invention has been presented for purposes of illustration but is not intended to be exhaustive or limited to the disclosed embodiments. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiments were chosen to explain the principles of the invention and its practical applications and to enable others of ordinary skill in the art to understand the invention in order to implement various embodiments with various modifications as might be suited to other contemplated uses."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, further objectives, and advantages thereof, will be best understood by reference to the following detailed description when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2C"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 2D","FIG. 2A"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2E"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2F"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2G"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 3","FIGS. 2D-2E"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 5C"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 7B"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 7C"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 7D"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 8B"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 8C"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 8D"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 9A"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 9B"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 9C"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 9D"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 9E"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 9F"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 10A"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 10B"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 10C"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 10D"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIGS. 12A-12D"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIGS. 13A-13B"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIGS. 15A-15B"}]},"DETDESC":[{},{}]}
