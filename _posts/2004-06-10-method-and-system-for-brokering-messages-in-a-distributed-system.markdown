---
title: Method and system for brokering messages in a distributed system
abstract: A system and method for brokering messages in a distributed system is disclosed, in which a resource, such as a hypertext file specified by a user agent, is preprocessed to request the services of a message broker configured to communicate messages among a plurality of non-compatible clients and servers for sending a message to an application at an application server in a protocol not supported by the user agent. In response, markup is generated and sent back to the user agent.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08849892&OS=08849892&RS=08849892
owner: Verizon Patent and Licensing Inc.
number: 08849892
owner_city: Basking Ridge
owner_country: US
publication_date: 20040610
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENT","Overview of Message Registry and Brokering","Exemplary Message Broker Structure and Instructions","Server-Side Preprocessing","Hardware Overview"],"p":["The present invention relates to information technology (IT) and more particularly to brokering messages in a distributed computing system.","Distributed computing is a technique for allocating application data processing among several computing resources. In the information technology industry, there is much interest in distributed computing due to the efficiencies gained by utilizing several different processors for common applications. Some distributed computing platforms are known as client\/server platforms, because each computing resource represents either a client or a server. A client resource is a consumer of application services and operates by sending requests to a server over a network. Clients generally represent the users of a system, such as a person at an application workstation. A server resource is a provider of application services and operates by receiving request messages from clients, performing data processing based on those requests, and sending reply messages to the clients. Servers generally represent the components that maintain enterprise data resources and implement business policies.","Implementation of a distributed platform often involves the integration of various types of heterogeneous computing and network resources into a single, enterprise-wide network. There are many products, standards, and communication protocols available for doing this, and many enterprises make use of several of them. This heterogeneity creates a significant problem with regards to interoperability. Several different applications running on various operating systems and hardware may interface with numerous incompatible messaging and network communication protocols. Application programmers have to deal with the complexities and intricacies of all of these protocols in order for their applications to work in heterogeneous distributed computing environments.","Additionally, programmers may need to provide a means for their applications to determine optimal transport mechanisms for their messages. This may be needed on both client and server resources. At least one message broker has been developed for transport of messages, such as the one described in the commonly-assigned U.S. Pat. No. 5,790,809 issued on Aug. 4, 1998, to Ralph Holmes, entitled REGISTRY COMMUNICATIONS MIDDLEWARE, the contents of which are hereby incorporated by reference in their entirety.","The increasing popularity and heterogeneity of distributing computing systems, however, have emphasized the importance of finding approaches that can scale well, especially in terms of deploying and maintaining distributed systems, in the presence of many more users and diverse types of applications than previously thought feasible. A need therefore exists for an approach to brokering messages in a distributed system that is scalable in terms of current demands for numbers of users and diversity of application servers.","The present invention stems from the recognition that one impediment to scalability is in the diversity of client-side computing devices for providing the user interface aspect to distributed applications. For example, if each client-side device had to include its own component of a message brokering system, then deploying a new or upgrading a message brokering infrastructure would require updating the message brokering component installed on each of the diversity of client-side computing devices.","Accordingly, this need for scalability in a distributed system, as well as other needs, is addressed by the present invention by providing a resource containing markup and at least one instruction, such as a file specified by browser or other kind of a user agent, that can be preprocessed at a server to request the services of a message broker configured to communicate messages among a plurality of non-compatible clients and servers. Each server can be handled by many clients, and the resource can be used or distributed to many servers, resulting in a leverage effect that increases scalability since upgrades can be deployed by updating the smaller number of servers or even the common resource. In addition, updating the resource can preferably be facilitated when the specified resource is a file containing markup, for example, text added to the data of a document to convey information about the document, such as descriptive markup (tags), references, markup declarations, and processing instructions.","One aspect of the present invention relates to a server for exchanging messages over a distributed system, comprising a message broker, a storage device, and a preprocessor. The message broker is configured for encapsulating and exchanging messages among a plurality of clients and servers using incompatible protocols, and the storage device stores a resource (such as a file) containing markup and at least one instruction for calling a message broker to communicate the message to an application at an application server. The preprocessor is configured for preprocessing the resource in response to a communication from a user specifying the resource. In response to executing the instruction, the message broker is called to communicate the message to the application at the application server in a protocol not supported by the user agent. Markup is generated based on the markup contained in the resource and sent to the user agent. The instructions may be written in any language, especially a server-side language such as PHP, ASP, Perl, or ColdFusion, that outputs hypertext markup, performs a variety of processing, and then returns with markup for the client to render.","Another aspect of the present invention pertains to a method of communicating a message in a distributed computer system from a user agent to an application at an application server. In accordance with such a method, a communication from a user agent is received identifying a resource stored at a server, such as a hypertext GET or POST message generated by a browser. The resource, which may be a hypertext file, contains markup and at least one instruction for calling a message broker to communicate the message to the application at the application server. In response, the resource is preprocessed and the instruction is executed so that the message broker is called to communicate the message to the application at the application server in a protocol not supported by the user agent. Markup is generated based on the markup contained in the resource and sent back to the user agent.","Still another aspect of the present invention involves a computer-readable medium storing a resource containing markup and one or more instructions for communicating a message in a distributed computer system from a user agent to an application at an application server. The one or more instructions are configured to be preprocessed by a hypertext server in response to a communication from a user agent identifying the computer-readable medium. When executed, the instructions cause one or more processors to call a message broker to communicate the message to the application at the application server in a protocol not supported by the user agent and generate markup based the markup contained in the resource.","Still other aspects, features, and advantages of the present invention are readily apparent from the following detailed description, simply by illustrating a number of particular embodiments and implementations, including the best mode contemplated for carrying out the present invention. The present invention is also capable of other and different embodiments, and its several details can be modified in various obvious respects, all without departing from the spirit and scope of the present invention. Accordingly, the drawings and description are to be regarded as illustrative in nature, and not as restrictive.","A system, method, and software for brokering messages in a distributed system are described. In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It is apparent, however, to one skilled in the art that the present invention may be practiced without these specific details or with an equivalent arrangement. In other instances, well-known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.","Referring to , a message broker  is depicted as a single, standard interface to both client  and server applications . The message broker  can be thought of as a system that resides on each individual client and server resource, and may be implemented as a library to provide a single, standard interface to each client  and server application  to shield these applications from the complexities of various proprietary messaging products  and network protocols . The operating systems, messaging products , and network protocols  shown are only a sample of those that may be supported by the message broker .","The message broker  may accept request messages from Client applications  as part of a dialog. The client applications  may run under various operating systems, as indicated. The request messages represent a solicitation for a response and\/or an instruction to perform a process. They are generated by the client applications  with the intent of being delivered to a server application . Server application  may also be run under various operating systems, as shown. Since the message broker  software resides on the same hardware components as the applications, the link between the message broker  and the client applications  represents a software process. Although four examples of operating systems and terminal emulators are illustrated, the message broker  may support many more.","The message broker  then executes a process of encapsulating the client's  request message into a message-broker-defined message. This process is depicted in greater detail below. The message broker  determines the appropriate messaging product  and then converts the message into the proprietary protocol of this messaging product . In some situations, the message broker  may actually serve as the messaging product ; in these cases, it will convert the message to the proprietary protocol of the network transport  (e.g., Systems Network Architecture (SNA) LU6.2, Transmission Control Protocol over Internet Protocol (TCP\/IP), etc.).","The messaging product  will use an appropriate network protocol for transporting the message over an available network . At the other end, the messaging product  receives the message and passes it off to the server-side message broker . The message broker  converts the message from the proprietary protocol of the messaging product  to a message that is recognizable to the server application . If a response from the server application  is appropriate, the preceding process is repeated to send the response message back to the client application .","Referring to , the role that the message broker  assumes in logical layers of client\/server communications is illustrated. In this diagram, the resource is identified on the front of each layer, the interface it provides is identified on the top of each layer, and the semantics used in the interface are identified to the right of each layer.","A top layer  represents the user of the application who interfaces with an application via application-defined user\/resource interfaces, exchanging business-oriented information with the application.","The next layer down  represents the application, interfacing with the message broker  via use of a set of message broker instructions. The semantics used for the message broker instructions are business-oriented client\/server transactions, and represent the only protocol that the application programmers need to deal with.","Next down are layers  and . The layer  next represents the message broker communications agent. The message broker communications agent interfaces with messaging products (i.e., communications middleware) via product-specific interfaces. The semantics used are specific to the messaging product. The layer  represents the communications middleware messaging products, which interface with the network via network protocol interfaces, using data transmission semantics. A bottom layer , representing network protocols, may include such types as SNA LU6.2 or TCP\/IP.","In some cases, the message broker communications agent  may actually span across the communications middleware layer . For example, the message broker communications agent  may translate client request messages into actual TCP\/IP messages to send directly over the TCP\/IP network.","Referring to , an exemplary internal logical structure of the message broker  is shown to illustrate a typical client\/server conversation utilizing the message broker .","A client application  generates a request message that needs to be sent to a distant server application . A typical example of a request message may be a request for a customer's monthly billing revenue from a company's customer billing database located on a distant server. The client and server are connected by an enterprise data network , and have several messaging products  available to transport their messages over the network . They will use the message broker  as an interface to all of these messaging products  and network  protocols.","The client application  communicates with message broker  via an Application Programming Interface (API)  of the message broker. The API may include a set of exemplary message broker instructions as follows:","The message broker instruction set is a set of commands that the message broker  uses to communicate with both client  and server applications . This exemplary limited set of commands represents a communications protocol that client\/server application programmers may use for their applications to communicate with the message broker  and, thus, the enterprise network.","There are two sets of instructions: one for use by client applications , and one for use by server applications . Since an application can potentially function as either a client or a server, both sets of instructions are included in the instruction set for every application. As noted previously, the instruction set is maintained within the API  of the message broker , as well as each client  and server application .","The client instructions and their parameters may be specified as follows:","REGISTER\u2014Establishes a session between the calling application and the message broker . This session is between the calling application and the message broker , and not between applications. The session includes a message broker control area, which is memory allocated by the REGISTER instruction in the message broker and passed back to the calling application. The message broker control area represents a unique instance of the registering process, and a new message broker control area is established for each issuance of the REGISTER instruction by the client.","Parameters of REGISTER:","FEEDBACK\u2014Field used to return to the calling application an indication as to whether the message broker  was able to complete the function requested.","REG-OPTIONS\u2014This parameter contains several fields, most of them optional, providing information used to identify the client application . One field of this parameter is a one-character designation indicating whether the calling application is a client or a server.","MBCA-PTR\u2014Field used to uniquely identify the message broker control area by serving as a pointer to the message broker control area. It designates a specific session established by a REGISTER instruction, and identifies subsequent calls to the message broker  as part of a specific session. Each issuance of the REGISTER instruction designates a different session and therefore has a different value for this field (e.g., MBCA-PTR1, MBCA-PTR2, etc.).","DEREGISTER\u2014Terminates activities of the client\/server applications, and releases any associated message broker managed resources. Parameters may be the same as those for REGISTER.","SENDREQUEST\u2014Used to send a client request to a server. May include the same parameters as REGISTER, plus the following:","WS-TEST-MSG\u2014This field is the address of the actual message being sent by the client to the Server.","WS-MSG-LEN\u2014This field indicates the length of the client message.","RECEIVEREPLY\u2014Used to receive a reply to a previous request. The message broker control area is the same one used for the SENDREQUEST verb. RECEIVEREPLY may include the same parameters as REGISTER, plus the following:","WS-OUT-MSG-PTR\u2014This field is a pointer to the reply message.","WS-OUT-MSG-LEN\u2014This field indicates the length of the reply message.","CONVERSE\u2014Used to conduct a synchronous request\/reply transaction. CONVERSE may include the same parameters as SENDREQUEST and RECEIVEREPY combined.","The Server instructions and their parameters may be specified as follows:","REGISTER\u2014Same definition as client version of instruction. A server issues a REGISTER instruction in response to the message broker's request to do so.","DEREGISTER\u2014May have the same definition as the client version of DEREGISTER.","RECEIVEREQUEST\u2014Used to receive a request message sent by the client. The message itself will be received unmodified by the message broker , and then may be processed by the server. RECEIVEREQUEST may include the same parameters as REGISTER, plus the following:","WS-REQUEST-MSG\u2014This field is the address of the message being sent to the server by the client.","WS-REQUEST-LEN\u2014This field indicates the length of the message.","SENDREPLY\u2014Used to send the server's reply to the client's message. SENDREPLY may include the same parameters as REGISTER, plus the following:","WS-SENDREPLY-MSG\u2014This field is the address of the reply to be sent to the client by the server.","WS-SENDREPLY-LEN\u2014This field indicates the length of the reply.","With continued reference to , the client application  initiates a session by registering itself as a client with the message broker , which is accomplished by issuing a REGISTER verb, which is read by the API . A message broker component identified as the Instruction Execution  validates the parameters and processes each instruction. When a REGISTER instruction is received by the API , instruction execution  generates a message broker control area and sends the message broker control area address back to the client  via the API . This message broker control area is used to store and process communications between the client  and the message broker .","The client application  then issues a SENDREQUEST instruction to the message broker . SENDREQUEST commands the message broker  to send the client's request message, generated previously by the client , to the server . The actual request message will also be sent to the message broker  as a parameter of the SENDREQUEST instruction. This message is in a format defined by the specific client application  that generated it, and will remain unmodified by the message broker . The message broker  simply delivers it to the server .","Alternatively, the client  may issue a CONVERSE instruction, which establishes a two-way, conversational dialog with the server . This may be considered equivalent to issuing a SENDREQUEST and RECEIVEREPLY instruction in combination. By issuing solely a SENDREQUEST instruction, the client  may establish either a conversational or a one-way dialog with the server , depending on the instruction's parameters.","With continued reference to , the SENDREQUEST instruction is received and recognized by the API . The message broker  then initiates the instruction execution  process.","The instruction execution  process validates the parameters of the instruction and resolves the destination address. It reads, from the client application's message, the name of the server application  for which the client's request is intended. It then queries a directory services database  to determine the physical network destination for that server application . The directory services database  includes physical network routing codes for each client\/server application on the network. When a request or reply message is passed to the message broker  to deliver to a specific application on the network, the message broker  determines where that application resides by translating its name to a physical network node via the directory services database . Thus, when an application is migrated to another node on the network, it is possible to update only the directory services database , as opposed to updating every client\/server application.","In an exemplary embodiment, the network destination of an application is represented by a three-part name, including a domain, a service name, and a service qualifier. The domain refers to a distinct sub-network of the enterprise-wide network. The service name refers to the function, rather than the physical location of the destination node and is the identifier of the destination. The service qualifier refers to a specific instance of the service name function, in cases where there is more than one instance. An example would be specifying a service name function of geographical customer data into service qualifiers of \u201ceast\u201d and \u201cwest.\u201d","With continued reference to , the instruction execution  launches execution of the SENDREQUEST instruction by issuing a Generalized IPC (Inter-Process Communications) Request to a generalized IPC interface . IPC refers to components and processes between the message broker  at the client  end and the message broker  at the server  end and includes messaging products , data networks , and anything that supports the communications between the client processes and the server processes.","The generalized IPC interface  is the component of the message broker  that is responsible for selecting the appropriate IPC products for transporting the client's message to the server . The generalized IPC interface  includes a generalized view of all of the messaging  and Network  products available, and selects one for use in the current session. It is also responsible for translating the message envelope (the message itself remains unmodified) to the appropriate format of the selected IPC product. The generalized IPC request is a command issued by the instruction execution  process to the generalized IPC interface . It includes the client's message, server's network address, and a request to send the message.","The generalized IPC interface  is shown in greater detail in , which is a dataflow diagram illustrating the operation of the Interface . Referring to , the generalized IPC interface  is identified within a broken line. It includes three primary logical components: a generalized IPC interface request processor , an IPC product qualification , and an IPC messaging interface . It also includes a database of available services information , which may be a partitioned database of the directory services database , or a separate database.","The generalized IPC interface request processor  provides a formal and initial interface to the instruction execution . The generalized IPC interface request processor  receives a generalized IPC request  and determines what services may be appropriate to process the request. It then compiles these services into a services list , which is forwarded to the IPC product qualification . The services list  can be a set of data items, each item identifying a message-broker-defined service that may appropriately process the request. Examples of such services are persistent queuing, message recovery, and time-out.","The IPC product qualification component  determines which messaging product  is to be used for transporting the client's message over the data network . This determination may be based on two inputs: the services list  from the request processor , and a list of available IPC products  from the available services information database . The available services information database , which may reside with the directory services database , includes preprogrammed lists of available IPC products (which includes messaging products  and data network  protocols) and information regarding their conditions for use. Based on the content of the services list  for the particular request, and the available IPC products , the IPC product qualification component  selects an appropriate IPC product  to use. It then sends the identification of this selected IPC product  to the IPC messaging interface .","The IPC messaging interface  provides the message broker's interface to the selected IPC products, including the selected messaging product . As previously noted, IPC refers to components utilized for transporting the message from the client's message broker  to the server's message broker ; this may include primarily industry-standard messaging products  and data network products . The IPC messaging interface  translates the generalized IPC request  to a format specified and utilized by the selected messaging product  and also initiates a dialog with the messaging product . When the generalized IPC request  (which includes the client's native request message) is translated to an appropriate messaging product  format, a formatted request  is passed to the messaging product  for transport over the data network  to a distant server .","Referring back to , at the server end, the messaging product  receives the message from the network , and delivers the message  to the message broker  via the generalized IPC interface . This delivery of the message  to the message broker , along with the entire process conducted by the message broker  at the server end, is controlled by a message broker component identified as a message broker process monitor . The message broker process monitor  controls the server's  receiving and processing of messages. Its objectives are to maintain a high level of server throughput of messages, manage the desired number of server tasks to process workloads, control server capacity and utilization by terminating\/reactivating server tasks as workload demands change, and to provide application-defined mechanisms for controlling server resource allocation.","Referring to , the message broker process monitor  is shown in greater detail to illustrate its operation. The message broker process monitor  may include three primary components: a queue monitor (QM) , a process monitor (PM) , and a control monitor (CM) .","As server-bound messages are retrieved from the network  by the messaging products , they are held in queues pending retrieval by the message broker . Each queue is assigned a class of service to indicate its priority. Each queue monitor  is assigned to a queue or a range of queues, therefore to a class of service or range of classes. The queue monitor  monitors these queues by receiving queue status data  from the messaging products . By tracking which messages are released for server processing, the queue monitor  knows the server's current level of utilization and its capacity for handling additional messages. When the queue monitor  determines the server has sufficient resource capacity for handling additional messages, the queue monitor  selects a message from a specific queue for subsequent processing. It then sends to the process monitor  information  specified for a server thread  to retrieve the message. The server thread  represents a processing link between the operating system of the server  and registry . It may be used by the server application  to request and receive the client's message.","The process monitor  sends a request  to the server  to set up a thread by registering itself with the message broker . The server  then issues a register instruction to the message broker , establishing a session between the server  and the message broker , similar to the manner previously described with regard to the client . The server  then issues a RECEIVEREQUEST instruction, allowing it to receive the client's request message via the server thread .","The RECEIVEREQUEST instruction is received by the API  and passed to instruction execution  for processing. Instruction execution  validates the parameters. From the WS-REQUEST-MSG parameter, the message broker  knows where the message is and can retrieve it via the generalized IPC interface . The IPC interface  retrieves the message  and extracts the client's native request message from it. The extracted client's request message is then passed to the server  for application-specific processing.","The control monitor  serves a utility function, providing systems management and configuration for the message broker . For example, it may provide a graphical user interface (GUI)  to a systems operator to allow an operator to perform system administration functions. It also may allow the operator to modify the domain of queues managed by each queue monitor .","Referring to , after processing the client's request message, and if a reply is appropriate, the Server  issues a SENDREPLY instruction. This instruction includes the server's reply message as a parameter, which is identified as WS-SENDREPLY-MSG. This instruction may processed similarly to the SENDREQUEST instruction discussed previously.","Conventional models of decentralized computing where each user has a full-featured and independent microcomputer have displaced a centralized model in which multiple users used dumb terminals to work on a shared minicomputer or mainframe server. Networked personal computers may operate as \u201cfat clients,\u201d often providing everything except some file storage and printing locally.","A thin client, on the other hand, is designed to be especially small so that the bulk of the data processing occurs on the server side. Thin clients can be advantageous, particularly in local area network environments. One benefit of thin clients is ease of maintenance: with fat clients, especially those suffering from poor networking support of various operating systems, installing a new application for all clients is likely to mean having to physically visit every user's workstation to install the application, or having to modify client-side configuration options; whereas with thin clients the maintenance tasks are centralized on the server and so need only be done once.","A thin client can be implemented by a web browser or other kind of user agent, often on a network personal computer or workstation. Browsers typically operate by requesting a resource identified by a Uniform Resource Locator (URL) from a network server, receiving markup in response, and rendering the markup for the user. The resource requested, received, and rendered is typically a hypertext file in the marked up in the HyperText Markup Language (HTML), the eXtensible Markup Language (XML), or other markup language such as the Standard General Markup Language (SGML), etc. Other exemplary thin clients include gopher clients; they are stateless and are not required to know how to interpret and display objects much more complex than menus and plain text. Gopher servers, on the other hand, can search databases and provide gateways to other services.","One way to develop client data entry applications is to use a server-side preprocessing language, an open source, server-side, scripting language embedded in markup language files used to create dynamic Web pages. When a user agent requests a server-side scripted file, the file is passed to a preprocessing engine, which reads the file line by line to determine and execute the instructions scripted in the file, and returns the markup generated by the preprocessor to the browser.","One server-side scripting language is known as the PHP Hypertext Preprocessor and others include Application Server Pages (ASP), and ColdFusion. With reference to PHP in particular, PHP script is enclosed in a hypertext document within special PHP tags. Because PHP is embedded within tags, the author of the code can alternate between markup and PHP instead of having to rely on heavy amounts of code to output hypertext markup. And, because PHP is typically executed on the server, the client does not view the PHP code, thus adding security to the system.","The Common Gateway Interface (CGI) is a specification for transferring information between a World Wide Web server and a CGI program. A CGI program is designed to accept and return data that conforms to the CGI specification. The program may be written in any programming language, including at least C, Perl, Java, or Visual Basic. CGI programs enable Web servers to interact dynamically with users. Many HTML pages that contain forms, for example, use a CGI program to process the form's data once it has been submitted. PHP can perform any task that any CGI program can perform, but its strength lies in its compatibility with many types of databases. Also, PHP can communicate across networks using Internet Message Access Protocol (IMAP), Simple Network Management Protocol (SNMP), Network News Transfer Protocol (NNTP), Post Office Protocol (POP3), or HyperText Transfer Protocol (HTTP).","Another way to provide dynamic feedback for Web users is to include scripts or programs that run on the user's machine rather than on the Web server. These programs may include Java applets, Java scripts, or ActiveX controls. These solutions are known collectively as client-side solutions, and require relatively fat clients.","Referring to , an intermediary client  is depicted as an interface between a user agent  (e.g., a client browser) and the message broker , according to an embodiment of the present invention. For this example, the message broker  resides on an edge server , the same resource as the intermediary client , thus providing a single, standard interface to intermediary client  and server application  to advantageously shield these applications from the complexities of various proprietary messaging products  and network protocols . The operating systems, messaging products , and network protocols  shown are only a sample of those that may be supported by the message broker . By handling the interface between the user agent  and the message broker , the intermediary client , which may include a web server, enables user agents , which may be lightweight clients such as web browsers, to advantageously enjoy the benefits of communications utilizing the message broker  without exposure of the user agent  to overhead needed to utilize the message broker , as, in client\/server applications, a thin client is designed to be especially small so that the bulk of the data processing occurs on the server. Additionally, it is possible that the user of the user agent  is unable to view code and messages sent by the intermediary client , and thus a level of security is added to the system. If an application of the intermediary client  is modified, the user agent  (e.g., a browser) may be easily updated by a user simply refreshing a display, instead of a server having to affirmatively deploy new versions of applications to a multitude of user machines.","The user agent  requests service from a server application , which may be on a server distant from the user agent . The request may be initiated by a user clicking a Uniform Resource Locator (URL) on a browser. This initial request may have caused the web server (e.g., the intermediary client ) hosting the resource specified by the URL to access a file including, e.g., HTML and PHP tags. The intermediary client  parses the file, causing the web browser to transmit HTML to the user agent  for displaying a form for the user to complete. When the user completes the form and submits the information requested, the intermediary client  requests execution of the PHP code by an appropriate PHP engine. If the PHP code includes native instructions for the message broker , then the code is executed to appropriately transmit, via a request message, the information to the message broker  for further processing and transmission to the desired server application .","Message broker  accepts request messages from intermediary client applications  as part of a dialog. The intermediary client applications  may run under various operating systems, as indicated previously with regard to client applications . The request messages represent a solicitation for a response and\/or an instruction to perform a process. They are generated by the intermediary client applications  with the intent of being delivered to the server application , which may include a distant server. Server application  may also be run under various operating systems, as shown. Since the message broker  software resides on the same hardware components as the applications, the message broker  and the intermediary client applications  are linked via a software process. Although only one user agent  is shown, many user agents  supported by many various operating systems and\/or terminal emulators may communicate with the edge server , the intermediary client  and the message broker .","The message broker  then executes a process of encapsulating the intermediary client's  request message into a message-broker-defined message. This process is depicted in greater detail below. The message broker  determines the appropriate messaging product  and then converts the message into the proprietary protocol of this messaging product . In some situations, the message broker  may actually serve as the messaging product ; in these cases, it will convert the message to the proprietary protocol of the network transport  (e.g., Systems Network Architecture (SNA) LU6.2, Transmission Control Protocol over Internet Protocol (TCP\/IP), etc.).","The messaging product  will use an appropriate network protocol for transporting the message over an available network . At the other end, the messaging product  receives the message and passes it off to the server-side message broker . The message broker  converts the message from the proprietary protocol of the Messaging Product  to a message that is recognizable to the desired server application . If a response from the Server application  is appropriate, the preceding process is repeated to send the response message back to the intermediary client application , for potential processing and further delivery to the user agent .",{"@attributes":{"id":"p-0093","num":"0092"},"figref":"FIG. 6","i":"b ","b":["612","602","620","622","624","626","104","602","602","612","612","612","626","620","622","624","602"]},"The user may only receive information regarding display of forms or queries on the user's screen, and thus may not see information that is processed by the intermediary client  for transmission to the server applications  via the message broker .","The intermediary client  may obtain network destination information (e.g., domain, a service name, and a service qualifier) used by the message broker  for its instruction set by querying the user via the web server and the browser, or the intermediary client  may determine network destination of an application independently or from other sources. HTML including script code such as PHP, ASP, ColdFusion, or Perl code may be parsed by the intermediary client  for execution by appropriate engines. The code may include any of the instructions for using the message broker  so that data obtained, e.g., from the user via interaction with the browser included in user agent , may be processed by the intermediary client  to generate a message to be sent to the server application  via the message broker . Thus, if the server application  receives a request for information from a particular node in the network, the server application  may send a request, via the message broker , to the user agent , whereby the intermediary client  receives the message and generates an appropriate query or display screen for interactively obtaining data from the user agent . Alternatively, the intermediary client may be configured to communicate messages for applications written in, and thus compatible with, any programming language (e.g., Common Business Oriented Language (COBOL), Programming Language I (PL\/I), FORmula TRANslator (FORTRAN), C, C++, Pascal, LISt Processing language (LISP), etc.).","If the user agent  desires sending information to a particular node on the network , the user may request, via a URL for a form or query provided by the web server included in the intermediary client , that the information obtained from the form be sent to the desired destination node. For this example, the user agent  is embodied as a thin client, and may only receive display data and transmit data in response to applications running on the edge server  handling the user agent's  needs.","Referring to , a process flowchart illustrates exemplary steps performed when an intermediary client communicates via the message broker  when the intermediary client issues a SENDREQUEST instruction to send a message to a Server Application . A similar operation may be conducted if a CONVERSE instruction were utilized.","In step , the user agent  initiates a request for a server application  to process. This request is to be delivered to the server application , which may reside on a distant machine. In step , the user agent  requests service from an intermediary client  (e.g., a web server included with the intermediary client ). This request, for example, may take the format of requesting a form by a user selecting, or clicking on a link specifying a Uniform Resource Locator, filling in information on a form displayed by the user agent's  browser by a web server included in the intermediary client , and selecting a submit button. In step , the intermediary client  may recognize intermediary-client-specific instructions which the intermediary client  may process utilizing engines , , ,  appropriate for processing the instructions (e.g., PHP, ColdFusion, Perl, ASP).","In step , the engine , , , or  issues a REGISTER instruction to the message broker . The REGISTER instruction establishes a communications session between the intermediary client  and message broker . The instruction execution component  of the message broker  validates the parameters of the REGISTER instruction (step ) and builds a message broker control area (MBCA), which includes a memory allocation used for passing instruction parameters (including the client's message) between the intermediary client  and the message broker  (step ).","The intermediary client , in step , issues a SENDREQUEST verb to the message broker . The intermediary client  sends its request message as a parameter of the SENDREQUEST instruction. The instruction execution component  of the message broker  validates the parameters of the SENDREQUEST verb (step ) and determines the physical network routing address of the intended server application  by extracting the server application name from the intermediary client's  message and translating that name to a network destination via a query to the directory services database  (step ). The directory services database  will return a network destination in the form of a domain, a service name, and a service qualifier, as discussed previously.","In step , the instruction execution component , as part of processing the SENDREQUEST instruction, issues a generalized IPC request  to the generalized IPC interface . The generalized IPC request  instructs the IPC interface  to perform certain functions for delivering the message, as discussed below. The generalized IPC request  also includes the intermediary client's  message and the server's  network address.","With continued reference to , in step , the generalized IPC interface request processor  compiles a list of services that are appropriate for processing the generalized IPC request . These services may be performed by the messaging product . The services list  that is generated is used by the IPC product qualification component  in step  to select an IPC product. The IPC product qualification  also receives the list of available IPC products  from the available services information database .","In step , the IPC product qualification  matches the required services from the services list  to those offered from certain IPC products identified in the available IPC products list , and selects an appropriate IPC product. The selected IPC product may include a messaging product  and\/or a data network  transport protocol. Identification of the selected IPC product is then sent to the IPC messaging interface component .","In step , the IPC messaging interface component  formats the generalized IPC request  (which it has received from instruction execution ) into a message that may be proprietary to the selected IPC product. The procedures for this translation of formats, e.g., may have been programmed into the IPC messaging interface component . Then, in step , the Interface  establishes a communications session with the selected messaging product  in a manner that is appropriate for the selected messaging product . Once the session is established, the message is passed to the messaging product , which proceeds to deliver the message over the network . At this point, the referenced \u201cmessage\u201d includes the intermediary client's  native request message packaged in an envelope that the message broker  has formatted specifically for the selected IPC products.","The message is transported in step  over the network  in a manner that is appropriate for the particular network protocol that is in use.","In step , the message broker  at the Server  site is prepared to receive the message. A queue monitor (QM) component  of the message broker process monitor  monitors the message in a particular queue by receiving queue status data  from each of the connected messaging products . The queue monitor  also tracks server resource capacity by being programmed with initial server capacity and tracking each message that is sent to the server . Thus, the queue monitor  knows the current server utilization and its capacity for processing additional messages. As part of step , the queue monitor  assesses the current capacity of the server  and determines when the next message may be retrieved.","Referring to , in step , the queue monitor  determines that the next message is to be retrieved and issues information  for a server thread . The server thread  represents a processing link between the operating system of the server  and message broker , and may be used by the server application  to request and receive the message. The server thread information  is issued by the queue monitor  to the process monitor (PM) .","In step , the process monitor  issues a request  for a server thread to the operating system of the server . This serves as a trigger for the server application  to establish a session with the message broker , by issuing a REGISTER instruction.","Then, in step , the server  issues the REGISTER instruction, which is read by the message broker's API  and passed to instruction execution , thus establishing the server's session with the message broker .","In step , instruction execution  processes the server's  REGISTER instruction similarly to the processing of the intermediary client's  REGISTER instruction. It builds an MBCA that is specific to the current session. Then, in step , the server  issues a RECEIVEREQUEST instruction to the message broker . The RECEIVEREQUEST instruction instructs the message broker  to send the intermediary client's  message to the Server .","In step , the instruction execution process  validates the parameters of the RECEIVEREQUEST instruction. One of these parameters will be populated with the address in memory of the intermediary client's  request message. In step , instruction execution  extracts the intermediary client's  native request message from the packaged message that was delivered over the network , and passes the request message to the server .","The server , in step , processes the intermediary client's request message in a manner that is specific to the application and independent of the message broker . A server  reply to the intermediary client  request may or may not be required, as determined in step . If a reply is required, the server  issues a SENDREPLY instruction in step , which is processed in the same manner as an intermediary client's  SENDREQUEST instruction, beginning in step . The server's  reply is then delivered to the intermediary client , as indicated in step . The server  then proceeds to issue another RECEIVEREQUEST instruction in step .","If a reply is not required, as determined in step , the server  issues another RECEIVEREQUEST instruction in step . If no more request messages are in queue for the server , a message stating \u201cNo More Messages\u201d is returned to the server  from message broker , as indicated in step . Then the process ends with step , in which the server  issues a DEREGISTER instruction. The DEREGISTER instruction instructs the message broker  to end the session.","If, in step , the \u201cNo More Messages\u201d message is not returned, an assumption is made that more request messages are in queue. The process returns to step , in which the instruction execution  processes the RECEIVEREQUEST instruction by validating the parameters.",{"@attributes":{"id":"p-0115","num":"0114"},"figref":"FIG. 8","b":["800","800","801","803","801","800","805","801","803","805","803","800","807","801","803","809","801"]},"The computer system  may be coupled via the bus  to a display , such as a cathode ray tube (CRT), liquid crystal display, active matrix display, or plasma display, for displaying information to a computer user. An input device , such as a keyboard including alphanumeric and other keys, is coupled to the bus  for communicating information and command selections to the processor . Another type of user input device is a cursor control , such as a mouse, a trackball, or cursor direction keys, for communicating direction information and command selections to the processor  and for controlling cursor movement on the display .","According to one embodiment of the invention, the processes of the intermediary client  and the message broker  are provided by at least one computer system  in response to the processor  executing an arrangement of instructions contained in main memory . Such instructions can be read into main memory  from another computer-readable medium, such as the storage device . Execution of the arrangement of instructions contained in main memory  causes the processor  to perform the process steps described herein. One or more processors in a multi-processing arrangement may also be employed to execute the instructions contained in main memory . In alternative embodiments, hard-wired circuitry may be used in place of or in combination with software instructions to implement the embodiment of the present invention. Thus, embodiments of the present invention are not limited to any specific combination of hardware circuitry and software.","The computer system  also includes a communication interface  coupled to bus . The communication interface  provides a two-way data communication coupling to a network link  connected to a local network . For example, the communication interface  may be a digital subscriber line (DSL) card or modem, an integrated services digital network (ISDN) card, a cable modem, a telephone modem, or any other communication interface to provide a data communication connection to a corresponding type of communication line. As another example, communication interface  may be a local area network (LAN) card (e.g. for Ethernet\u2122 or an Asynchronous Transfer Model (ATM) network) to provide a data communication connection to a compatible LAN. Wireless links can also be implemented. In any such implementation, communication interface  sends and receives electrical, electromagnetic, or optical signals that carry digital data streams representing various types of information. Further, the communication interface  can include peripheral interface devices, such as a Universal Serial Bus (USB) interface, a PCMCIA (Personal Computer Memory Card International Association) interface, etc. Although a single communication interface  is depicted in , multiple communication interfaces can also be employed.","The network link  typically provides data communication through one or more networks to other data devices. For example, the network link  may provide a connection through local network  to a host computer , which has connectivity to a network  (e.g. a wide area network (WAN) or the global packet data communication network now commonly referred to as the \u201cInternet\u201d) or to data equipment operated by a service provider. The local network  and network  both use electrical, electromagnetic, or optical signals to convey information and instructions. The signals through the various networks and the signals on network link  and through communication interface , which communicate digital data with computer system , are exemplary forms of carrier waves bearing the information and instructions.","The computer system  can send messages and receive data, including program code, through the network(s), network link , and communication interface . In the Internet example, a server (not shown) might transmit requested code belonging to an application program for implementing an embodiment of the present invention through the network , local network  and communication interface . The processor  may execute the transmitted code while being received and\/or store the code in storage device , or other non-volatile storage for later execution. In this manner, computer system  may obtain application code in the form of a carrier wave.","The term \u201ccomputer-readable medium\u201d as used herein refers to any medium that participates in providing instructions to the processor  for execution. Such a medium may take many forms, including but not limited to non-volatile media, volatile media, and transmission media. Non-volatile media include, for example, optical or magnetic disks, such as storage device . Volatile media include dynamic memory, such as main memory . Transmission media include coaxial cables, copper wire and fiber optics, including the wires that comprise bus . Transmission media can also take the form of acoustic, optical, or electromagnetic waves, such as those generated during radio frequency (RF) and infrared (IR) data communications. Common forms of computer-readable media include, for example, a floppy disk, a flexible disk, hard disk, magnetic tape, any other magnetic medium, a CD-ROM, CDRW, DVD, any other optical medium, punch cards, paper tape, optical mark sheets, any other physical medium with patterns of holes or other optically recognizable indicia, a RAM, a PROM, and EPROM, a FLASH-EPROM, any other memory chip or cartridge, a carrier wave, or any other medium from which a computer can read.","Various forms of computer-readable media may be involved in providing instructions to a processor for execution. For example, the instructions for carrying out at least part of the present invention may initially be borne on a magnetic disk of a remote computer. In such a scenario, the remote computer loads the instructions into main memory and sends the instructions over a telephone line using a modem. A modem of a local computer system receives the data on the telephone line and uses an infrared transmitter to convert the data to an infrared signal and transmit the infrared signal to a portable computing device, such as a personal digital assistant (PDA) or a laptop. An infrared detector on the portable computing device receives the information and instructions borne by the infrared signal and places the data on a bus. The bus conveys the data to main memory, from which a processor retrieves and executes the instructions. The instructions received by main memory can optionally be stored on storage device either before or after execution by the processor.","While the present invention has been described in connection with a number of embodiments and implementations, the present invention is not so limited but covers various obvious modifications and equivalent arrangements, which fall within the purview of the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings and in which like reference numerals refer to similar elements and in which:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6","i":"a "},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6","i":"b "},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7","i":"a "},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 7","FIG. 7"],"i":["b ","a"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
