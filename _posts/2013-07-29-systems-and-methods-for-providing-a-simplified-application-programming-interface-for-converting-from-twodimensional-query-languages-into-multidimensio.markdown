---
title: Systems and methods for providing a simplified application programming interface for converting from two-dimensional query languages into multi-dimensional query languages to query multi-dimensional data sources and MDX servers
abstract: Apparatus and methods are provided for querying OLAP data sources and other MDX servers utilizing a two-dimensional query language. Aspects of the apparatus and methods receive a query written in a two-dimensional query language, such as LINQ, convert the query into a query compatible with a multi-dimensional query language, such as MDX, and employ the converted query to query the OLAP data source.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09355143&OS=09355143&RS=09355143
owner: 
number: 09355143
owner_city: 
owner_country: 
publication_date: 20130729
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application claims the benefit of the filing date of U.S. provisional patent application No. 61\/676,998 entitled \u201cSimplified LINQ Query API, Process of Translation from LINQ and Other Two Dimensional Query Languages into Multidimensional Query eXtensions (MDX) Query Language, Object-Multidimensional Mapping\u201d, which was filed on Jul. 29, 2012, by the same inventor of this application. That provisional application is hereby incorporated by reference as if fully set forth herein.","The invention relates generally to computer based query languages and more particularly to the conversion of a two-dimensional query language such as Language Integrated Query (\u201cLINQ) into a query language for multi-dimensional Online Analytical Processing (\u201cOLAP\u201d) such as Multi-Dimensional eXpressions (\u201cMDX\u201d).","In computing, online analytical processing, or OLAP is an method for answering multi-dimensional analytical queries swiftly. Typically OLAP is employed for ad-hoc queries and business reporting such as sales reports, marketing, management reports, budgeting, financial reporting etc. The basic element of an OLAP system is an OLAP or multi-dimensional cube (data source). It is made up of facts called measures which are categorized by dimensions. Measures are derived from the records in the fact table and dimensions are derived from the dimension tables. Measure Group in SSAS corresponds to a set of measure columns from a fact (transactional) table in its relational data source. Measure in an SSAS cube corresponds to a not key column in a fact (transactional) table in its relational data source. Measure column is typically of some numeric type. Dimension in an SSAS cube corresponds to a reference (dimensional) table in its relational data source. Dimension Attribute in an SSAS cube corresponds to either a column in a reference (dimensional) table or to a foreign key or date\/time column in a transactional (fact) table in its relational data source. Dimension Attributes are quite often of string or date\/time type.","Below we introduce new terms specific to object-multidimensional mapping:","Measure Property\u2014a property of a class or column of a table or a cube measure suitable for aggregation functions.","Dimensional Property\u2014a property of a class or a column of a table or a cube dimensional attribute most often used as a grouping (or sorting\/joining\/identifying) key.","OLAP tools enable users to analyze multi-dimensional data interactively from multiple perspectives using three basic analytical operations: consolidation (roll-up), drill-down, and slicing and dicing. Consolidation involves the aggregation of data in one or more dimensions. For example, all sales offices of a company are combined to forecast future sales. Drill-down is more granular and enables examination of the details. For example, the sales of a product are collected for a particular area. Slicing and dicing allows taking out (slicing) a specific set of data from the OLAP cube and examining (dicing) the slices from different viewpoints.","MDX, which was introduced by Microsoft\u00ae, is a powerful query language that can be used to query multidimensional OLAP data sources and other MDX servers such as SSAS Multidimensional, SSAS Tabular and Essbase. But MDX is a difficult language to master and thus it is difficult for the average programmer to write error free code. It is also difficult to employ for unit testing and refactoring due to a lack of tooling support. MDX is verbose when it comes to dimensional attribute and measure references specification and it does not support Object Oriented Programming (\u201cOOP\u201d). Additionally, MDX queries cannot be reused for data sources that do not support MDX like relational databases or in-memory objects. When MDX is used to query data from .NET applications developers have to add plumbing code (e.g. low-level code that bridges between the application and lower layers) to convert query parameters to MDX fragments and to convert query results from ADOMD.NET format into .NET object graphs.","For example, creating a reporting web-application in .NET using conventional techniques would require the following steps:","1. A developer creates classes and other data structures together with calculation and data verification\/cleaning logic in .NET (domain layer, .NET environment);","2. A developer creates dynamic reporting layouts that may handle user actions like mouse clicks for data drill-down (in ASP.NET Web-forms, in ASP.NET MVC or in Silverlight; .NET environment, presentation layer);","3. A developer (typically a different developer since very few developers know both MDX and .NET well enough) creates parameterized MDX queries that filter, join, aggregate and sort data according to parameters (or builds non-parameterized MDX queries dynamically from .NET method parameters) and embeds these queries as strings into .NET code (data access layer, MS SQL Server Analysis Services environment);","4. A developer writes code that submits embedded MDX query strings into ADOMD.NET command, passes all parameters into that command and executes it; and,","5. A developer writes code that marshals the results of ADOMD.NET command execution (step 4) that are in a form of ADOMD.NET flattened record sets into a composition of associated .NET objects designed at step 1.","LINQ, which is a Microsoft\u00ae.NET Framework component that adds data querying capabilities to .NET languages, does not suffer from the same issues as MDX, but in its present form LINQ cannot be used to query OLAP data sources and other MDX servers such as SSAS and Essbase. LINQ also requires specification of aggregations, groupings, sorting and joins in each query. Such requirements complicate LINQ queries, slow down LINQ learning, adoption, query development and testing, and make LINQ queries more fragile to design changes.","In view of the foregoing, it would be advantageous to provide an improved query language. It would further be advantageous to provide such a query language that may be employed to query OLAP data sources and other MDX servers. It would be still further advantageous to provide such as query language that is relatively simple to learn and which is less prone to errors when coding. It would also be advantageous to provide such a query language that allows a single developer to perform steps 1-3 above without the developer having to perform steps 4 and 5.","Many advantages of the invention will be determined and are attained by the invention, which in a broadest sense provides a two-dimensional query language that can operate to query multi-dimensional OLAP data sources and other MDX servers. It provides users the ability to employ simple semantics of two-dimensional relational query languages like LINQ or SQL together with the power of implicit data aggregation, sorting and joins of multidimensional query languages like MDX. Also users will be able to use a wider range of reporting tools, application frameworks and UI .NET components that do not support OLAP cubes and MDX servers directly, but can work with LINQ (e.g. ActiveReports, XtraReports, Visual Studio LightSwitch, WCF Data Services and OData Web API services, ASP.NET LinqDataSource and ObjectDataSource, ASPxGridView in LINQ Server Mode).","One or more embodiments of the invention provide an apparatus configured to retrieve data from an OLAP data source. The data source having associated meta-data. The apparatus includes a computing device in electrical communication with a network. The apparatus also includes an API configured to operate within the computing device and configured to receive a two-dimensional query written in a two-dimensional query language. The computing device is configured to convert the two-dimensional query into a multi-dimensional query that is compatible with a multi-dimensional query language. The computing device is also configured to retrieve, from the data source, data responsive to the multi-dimensional query.","One or more embodiments of the invention also provide a method of retrieving data from an OLAP data source, where the data source has associated meta-data. The method includes providing a computing device that selectively communicates with a network. The method further includes providing an API operating on the computing device. The computing device receives as input via the API a two-dimensional query formulated in a two-dimensional query language. The computing device converts the two-dimensional query into a multi-dimensional query and employs the multi-dimensional query to retrieve data from the data source and helps to convert the result recordsets into a graph of connected .NET objects (entities)","The invention will next be described in connection with certain illustrated embodiments and practices. However, it will be clear to those skilled in the art that various modifications, additions, and subtractions can be made without departing from the spirit or scope of the claims.","Referring to the drawings in detail wherein like reference numerals identify like elements throughout the various figures, there is illustrated in  a two-dimensional query language that is capable of querying multi-dimensional OLAP data sources and other MDX servers. While the following description will be limited to LINQ and MDX, those skilled in the art will recognize that the invention is not so limited. The following description is equally applicable to any component, tool or application that employs a two-dimensional relational query language, similar to LINQ or Structured Query Language (\u201cSQL\u201d), which is converted into multi-dimensional query language, similar to MDX. One skilled in the art will understand from this disclosure how to apply the disclosed methods to these other component(s), tool(s) and\/or application(s) without undue experimentation.","Aspects of the invention provide the following general features: 1. a LINQ Application Programming Interface (\u201cAPI\u201d) is modified to simplify the creation of LINQ queries (simplified LINQ queries interchangeably referred to herein as Simple Dimensional eXtension (\u201cSDX\u201d) or LINQ) and to make LINQ more compatible with querying OLAP and other data sources; 2. a LINQ query is translated\/converted into a MDX query; and, 3. methods are provided for designing and implementing Object-Multidimensional-Mapping (\u201cOMM\u201d) components that translate one or more LINQ queries into one or more MDX queries, pass the generated MDX query into an ADOMD.NET component for execution in a binary coded operating device, takes result data from ADOMD.NET and converts it from ADOMD.NET format into .NET and ADO.NET Entity Framework format and returns results compatible with expectations of LINQ and ADO.NET Entity Framework. As an aside, OMM is similar to Object-Relational Mapping (\u201cORM\u201d), but maps objects and single-dimensional relational languages to multidimensional results and languages.","Using some or all of the above features, users who create new applications, reports and queries will be able to create queries to multi-dimensional OLAP data sources and MDX servers using SDX, LINQ and any language supported by .NET and by using data returned by such queries in .NET applications and reports. Applications will be able to execute LINQ queries, consume the data returned by such queries and may act upon the results of these queries. Thus, in contrast to the example presented in the background section above, a reporting web-application in .NET could be created using the invention by the following steps:","1. A developer creates classes and other data structures together with calculation and data verification\/cleaning logic in .NET (domain layer, .NET environment);","2. A developer creates interactive reporting layouts that may handle user actions like mouse clicks for data drill-down (in ASP.NET Web-forms, in ASP.NET MVC or in Silverlight, presentation layer, .NET environment); and,","3. A developer creates LINQ queries that filter, join, aggregate and sort data. The developer does not need to create and populate parameters, or embed LINQ queries as strings into .NET code because LINQ is integrated into .NET (data access layer, .NET environment). Further, the developer does not need to write code for steps 4-5 in the background example, since this work is handled by the SSAS Entity Framework Provider component and Microsoft ADO.NET Entity Framework. Thus development and testing, work and time are saved. Further, step 3 can be performed by the same developer since it is common for .NET developers to also know LINQ (which is part of .NET).","The above aspects are preferably implemented as a computer program stored  on a computer  which causes the computer  to function as a data retrieving system, for retrieving data stored on cubic or tabular data structures in locally  or remotely  located MDX servers accessible over the Internet  or some other compatible network , without utilizing MDX as an API. The program is executed on a Windows\u00ae operation system (\u201cOS\u201d) (this limitation is imposed by the fact that Microsoft ADOMD.NET is currently only existing for Windows OS. If this changes in the future then this limitation will change accordingly). The program causes the computer to execute LINQ to achieve one or optionally more of joining, grouping, aggregating, filtering and\/or sorting data. The program utilizes SDX dialect of LINQ along with metadata of the cubic data structures and MDX servers so that aggregation, joining and grouping operators of LINQ are optional rather than required, thereby enabling the reduction\/simplification of standard LINQ queries.","The following illustrates an example of how to simplify the LINQ API and make LINQ more useable for querying OLAP and other data sources.","Simplify \u201cAggregations\u201d in a LINQ Query: Make implicit aggregations\u2014aggregate all Measure Properties listed for projection in a \u201cselect\u201d clause, even if no aggregation functions are explicitly specified in a query. A more detailed explanation of the process for determining Measure Properties suitable for aggregation among all projected properties listed in Select( ) will be set forth later in this disclosure. In order to determine a kind of an aggregation function, specify it in metadata outside of a query (e.g. in a cube metadata, file or .Net manifest as attributes). If a kind of an aggregation function is indicated explicitly somewhere in a LINQ query, use all regular LINQ conventions for the aggregation of those Measure and\/or Dimensional Properties with an explicit aggregation function. Aggregate all other Measure Properties implicitly. If a kind of an aggregation function is not specified anywhere, neither in metadata nor in a query, use Sum( ) as a default.","By way of a non-limiting example:",{"@attributes":{"id":"p-0035","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Query 1 - Standard LINQ to Entities (conventional):",{}]},{"entry":[{},"from order in context.OrderDetails",{}]},{"entry":[{},"select new",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\u2003Quantity = context.OrderDetails.Sum(o => o.Quantity),",{}]},{"entry":[{},"\u2003\u2003Discount = context.OrderDetails.Sum(o => o.Discount),",{}]},{"entry":[{},"\u2003\u2003UnitPrice = context.OrderDetails.Average(o => o.UnitPrice)",{}]},{"entry":[{},"}",{}]},{"entry":[{},"Query 2 - SDX (new):",{}]},{"entry":[{},"from order in context.OrderDetails",{}]},{"entry":[{},"select new",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\u2003order.Quantity,",{}]},{"entry":[{},"\u2003\u2003order.Discount,",{}]},{"entry":[{},"\u2003\u2003order.UnitPrice",{}]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Simplify \u201cGroup By\u201d section in a LINQ Query: Make implicit groupings\u2014group results of queries by default, even if there is no \u201cgroup . . . by\u201d section or GroupBy( ) extension method explicitly specified in a query. When \u201cgroup . . . by\u201d is missing in a query use all Dimensional Properties specified in a projection part of a query as grouping keys. A more detailed explanation of the process for determining what projection properties (columns) are suitable for grouping will be set forth later in [0030] of this disclosure. If an explicit \u201cgroup . . . by\u201d clause is present in a LINQ query, use all standard LINQ conventions for grouping.","By way of a non-limiting example the following 2 queries return the same result:",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"Query 3 - Standard LINQ (conventional):",{}]},{"entry":[{},{},"from orderDetails in context.OrderDetails",{}]},{"entry":[{},{},"group orderDetails by orderDetails.ProductID into grouped",{}]},{"entry":[{},{},"select new",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003\u2003grouped.Key, \/\/ group by key - orderDetails.ProductID",{}]},{"entry":[{},{},"\u2003\u2003grouped.Sum(g => g.Quantity),",{}]},{"entry":[{},{},"\u2003\u2003grouped.Sum(g => g. Discount),",{}]},{"entry":[{},{},"\u2003\u2003grouped.Average(g => g. UnitPrice)",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"Query 4 - SDX (new):",{}]},{"entry":[{},{},"from orderDetails in context.OrderDetails",{}]},{"entry":[{},{},"select new",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003\u2003orderDetails.ProductID, \/\/ group by key",{}]},{"entry":[{},{},"\u2003\u2003orderDetails.Quantity,",{}]},{"entry":[{},{},"\u2003\u2003orderDetails.Discount,",{}]},{"entry":[{},{},"\u2003\u2003orderDetails.UnitPrice",{}]},{"entry":[{},{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"Simplify \u201corderby\u201d clause in a LINQ Query: Sort query results containing Dimensional Properties implicitly\u2014sort query results by default, even if there is no explicit \u201corderby\u201d keyword and OrderBy( ) extension method in a query. If \u201corderby\u201d clause is not present in a LINQ query sort by all Dimensional Properties included into projection (\u201cselect\u201d clause of a query) by either \u201cselect\u201d keyword or Select( ) extension method. A more detailed explanation of the process for determining what projection properties (columns) should be used as Dimensional Properties (sort keys) when both \u201corderby\u201d keyword and OrderBy( ) extension method are missing will be set forth later in this disclosure. If there are multiple sort keys in a query, sort them in the same sequence in which Dimensional Properties (columns) are specified in a query. If an explicit \u201corderby\u201d clause is present in a LINQ query, first sort explicitly indicated properties (columns) using all standard LINQ conventions for sorting, then also sort all other Dimensional Properties implicitly.","By way of a non-limiting example:",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"Query 5 - Standard LINQ (conventional):",{}]},{"entry":[{},{},"from orderDetails in context.OrderDetails",{}]},{"entry":[{},{},"orderby",{}]},{"entry":[{},{},"orderDetails.ProductID,",{}]},{"entry":[{},{},"orderDetails.OrderID",{}]},{"entry":[{},{},"select new",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003\u2003orderDetails.ProductID,",{}]},{"entry":[{},{},"\u2003\u2003orderDetails.OrderID,",{}]},{"entry":[{},{},"\u2003\u2003orderDetails.Quantity,",{}]},{"entry":[{},{},"\u2003\u2003orderDetails.Discount,",{}]},{"entry":[{},{},"\u2003\u2003orderDetails.UnitPrice",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"Query 6 - SDX (new):",{}]},{"entry":[{},{},"from orderDetails in context.OrderDetails",{}]},{"entry":[{},{},"select new",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003\u2003orderDetails.ProductID,",{}]},{"entry":[{},{},"\u2003\u2003orderDetails.OrderID,",{}]},{"entry":[{},{},"\u2003\u2003orderDetails.Quantity,",{}]},{"entry":[{},{},"\u2003\u2003orderDetails.Discount,",{}]},{"entry":[{},{},"\u2003\u2003orderDetails.UnitPrice",{}]},{"entry":[{},{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Simplify \u201cjoins\u201d in a LINQ Query: Make joins implicitly\u2014join query results, even if there is no explicit join keywords or extension methods in a query. Allow to specify a query like it is a cross-join (e.g. by using multiple \u201cfrom\u201d . . . without corresponding \u201cjoin\u201d); but instead of returning a Cartesian product in such a case, return a normal joined Recordset using default join conditions specified in metadata outside of a query (e.g. in a cube definition, database keys and constraints, class associations, .Net manifest or metadata file). Thus instead of having to repeat each join condition specification in each query SDX allows the specification of joins only once in metadata outside of queries. It also enables the writing of very simple queries for several related entities with no navigational properties. Thus users can reduce coupling between entities (classes they query) by removing some or all of the navigational properties (associations) from the entities without impacting query complexity. If an explicit \u201cjoin\u201d clause is present in a LINQ query, use all standard LINQ joining rules for that specific join, but all other entities should still be joined with implicit default join conditions specified in metadata. If there is no metadata about joins is present, return a cross-join (Cartesian product).","By way of a non-limiting example the following 2 queries return the same joined result:",{"@attributes":{"id":"p-0041","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"Query 7 - Standard LINQ (conventional)",{}]},{"entry":[{},{},"from order in context.OrderDetails",{}]},{"entry":[{},{},"join customer in context.Customers",{}]},{"entry":[{},{},"on customer.OrderID equals order.OrderID",{}]},{"entry":[{},{},"join product in context.Products",{}]},{"entry":[{},{},"on product.ProductID equals order.ProductID",{}]},{"entry":[{},{},"select new",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003\u2003CustomerID = customer.CustomerID,",{}]},{"entry":[{},{},"\u2003\u2003CompanyName = customer.CompanyName,",{}]},{"entry":[{},{},"\u2003\u2003Country = customer.Country,",{}]},{"entry":[{},{},"\u2003\u2003CategoryID = product.CategoryID,",{}]},{"entry":[{},{},"\u2003\u2003Quantity = order.Quantity",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"Query 8 - SDX (new):",{}]},{"entry":[{},{},"from customer in context.Customers",{}]},{"entry":[{},{},"from product in context.Products",{}]},{"entry":[{},{},"from order in context.OrderDetails",{}]},{"entry":[{},{},"orderby customer.Country,",{}]},{"entry":[{},{},"product.CategoryID,",{}]},{"entry":[{},{},"customer.CompanyName",{}]},{"entry":[{},{},"select new",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003\u2003CustomerID = customer.CustomerID,",{}]},{"entry":[{},{},"\u2003\u2003CompanyName = customer.CompanyName,",{}]},{"entry":[{},{},"\u2003\u2003Country = customer.Country,",{}]},{"entry":[{},{},"\u2003\u2003CategoryID = product.CategoryID,",{}]},{"entry":[{},{},"\u2003\u2003Quantity = order.Quantity",{}]},{"entry":[{},{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"Using LINQ with languages other than LINQ in the same single query: Introduce a new set of methods\u2014extension methods or operators that allow insertion of query fragments written in non-LINQ query languages (e.g. MDX, SQL) with an intention to return either Recordsets or scalar values.","By way of a non-limiting example:",{"@attributes":{"id":"p-0043","num":"0042"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Query 9 - Standard LINQ (conventional) - There is no analogy for this",{}]},{"entry":[{},"in a conventional LINQ yet.",{}]},{"entry":[{},"Query 10 - SDX (new):",{}]},{"entry":[{},"from customer in context.Customers",{}]},{"entry":[{},"from order in context.OrderDetails",{}]},{"entry":[{},"select new",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\u2003UniqueName = MdxHelper.CalculatedMemberAsString(",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201c[Measures].[CustomerID UniqueName]\u201d",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003, \u201c[Customers].[Customer ID].CurrentMember.",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003UniqueName\u201d),",{}]},{"entry":[{},"\u2003\u2003Calculation = MdxHelper.CalculatedMemberAsInt(",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201c[Measures].[CustomerID Calculation]\u201d",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003, \u201c3 * 4\u201d),",{}]},{"entry":[{},"}",{}]},{"entry":[{},"Query 11 - Standard LINQ (conventional) - There is no analogy ",{}]},{"entry":[{},"for this in a standard LINQ yet.",{}]},{"entry":[{},"Query 12 - SDX (new):",{}]},{"entry":[{},"from table1 in context.Table1",{}]},{"entry":[{},"join otherLanguageQuery in context.TableMdxQuery(\u201cmdx query\u201d)",{}]},{"entry":[{},"on . . .",{}]},{"entry":[{},"where context.ScalarMdxQuery(\u201cmdx query\u201d).AsInteger( ) ==",{}]},{"entry":[{},"table1.Date.Month",{}]},{"entry":[{},"select new",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\u2003Month = table1.Date.Month,",{}]},{"entry":[{},"\u2003\u2003MdxValue = context.ScalarMdxQuery(\u201cmdx query\u201d).AsString( ),",{}]},{"entry":[{},"\u2003\u2003MdxSource = context.TableMdxQuery(\u201cmdx query\u201d)",{}]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The following illustrates an example of how to translate\/covert from LINQ to MDX. Differentiating between Measure Properties and Dimensional Properties: Either reserve and use separate data types for Measure Properties (e.g. \u201cDouble\u201d and \u201cDecimal\u201d only, or new special custom types (class or struct)) or specify Measure Properties in metadata outside of a query (e.g. list of measures in OLAP cube metadata, list of Measure Properties in a file or class properties marked with special attributes like MeasurePropertyAttribute (metadata in .Net manifest)). Consider all non-Measure properties to be Dimensional properties.","Alternatively reserve data types for Dimensional Properties (e.g. String and Integer, or new custom types) or specify all Dimensional Properties in metadata outside of a query (e.g. list of cube dimensions and dimensional attributes, list of primary and foreign keys of a table, list of dimensional properties in a file or properties marked with a special attribute like DimensionalPropertyAttribute). Consider all non-Dimensional Properties to be Measure Properties.","Converting a LINQ query where projection properties (columns) can be specified in any order, into a MDX query which employs multiple axes and limits a sequence in which measures and dimensions have to be specified: Both LINQ to Entities and SQL queries internally return Recordsets where each row contains columns for both Dimensional and Measure Properties in the same sequence specified in a query projection (LINQ \u201cselect\u201d clause). Measures can be mixed with dimensions in any order in the same single row. There is no distinction between Dimensional and Measure Properties in standard LINQ and SQL languages. MDX, however, is a multidimensional query language that does not allow mixing dimensional attributes and measures in the same result row in any arbitrary sequence (discussed further below). A typical MDX query employs 2 separate axes: ON COLUMNS (axis(0)) and ON ROWS (axis(1)). ON COLUMNS axis is mandatory if someone needs to query non-default measures. There is no exact equivalent for ON COLUMNS axis in LINQ or SQL.","The above issue is resolved by aspects of the invention as follows: (i) users are allowed to specify both Dimensional and Measure Properties in LINQ or SQL like queries in any order as they did before; (ii) when converting a query in LINQ or SQL into a query in MDX or similar language Measure Properties are always put into \u201cON COLUMNS\u201d axis of the query regardless of an order of respective properties (columns) in LINQ select clause, but associated with an original position of a Measure Property in LINQ select clause; (iii) Dimensional Properties (columns) are always put into \u201cON ROWS\u201d axis when translating into MDX, but associated with an original position of a Dimensional Property in LINQ select clause; and (iv) never use any axis other than \u201cWHERE\u201d, \u201cON COLUMNS\u201d and\/or \u201cON ROWS\u201d when translating into MDX. (v) At this point generated MDX can execute, but it returns all Dimensional Properties on the left side, and all Measure Properties on the right side of the result Recordset. An Object-Multidimensional Mapping component should rearrange a sequence of columns in a result Recordset according to the order specified in the original select clause of a query in LINQ or SQL. That original order is tracked during steps (iii) and (iv). If (v) is omitted, LINQ or SQL semantics would change and LINQ provider would throw an exception when converting the result Recordset into .Net objects (entities). A further description of this solution extended with design and implementation details specific to ADOMD.NET and ADO.NET Entity Framework is set forth later in this disclosure.","By way of a non-limiting example: If a SDX query is issued similar to the following:",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"from orderDetails in context.OrderDetails",{}]},{"entry":[{},"select new",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\u2003orderDetails.ProductID, --Dimensional Property",{}]},{"entry":[{},"\u2003\u2003orderDetails.Quantity, --Measure Property",{}]},{"entry":[{},"\u2003\u2003orderDetails.OrderID, --Dimensional Property",{}]},{"entry":[{},"\u2003\u2003orderDetails.Discount, --Measure Property",{}]},{"entry":[{},"\u2003\u2003orderDetails.UnitPrice",{}]},{"entry":[{},"}",{}]},{"entry":[{},"It will be translated into MDX as follows:",{}]},{"entry":[{},"SELECT",{}]},{"entry":[{},"{ --Measures are separate",{}]},{"entry":[{},"\u2003\u2003[Measures].[Quantity],",{}]},{"entry":[{},"\u2003\u2003[Measures].[Discount],",{}]},{"entry":[{},"\u2003\u2003[Measures].[Unit Price]",{}]},{"entry":[{},"} ON COLUMNS,",{}]},{"entry":[{},"NON EMPTY",{}]},{"entry":[{},"( --Dimensional attributes are separate",{}]},{"entry":[{},"\u2003\u2003[Products].[Product ID].[Product ID],",{}]},{"entry":[{},"\u2003\u2003[Orders].[Order ID].[Order ID]",{}]},{"entry":[{},") ON ROWS",{}]},{"entry":[{},"FROM [NorthwindEF]"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"While not preferred, the following are possible alternative ways to address the issue of mixing Measure Properties with Dimensional Properties which would still fall within a scope of the invention. Users could specify all Dimensional Properties before any Measure Properties in all of their LINQ queries. Drawbacks to this solution are that it would be difficult to catch errors before run time and it is difficult to always separate Dimensional Properties from Measure Properties. Another possible solution would be to specify measures mixed with dimensional attributes in MDX queries by putting all of them onto a single ON ROWS axis using the MDX CrossJoin function. However, such a solution would return a Recordset with a different cardinality from what is expected by LINQ or SQL query semantics. MDX query would return a new row for each new measure specified. LINQ provider would throw an exception when converting the result Recordset into .Net objects. Mapper design pattern or other similar solution could re-map (un-pivot) related measures scattered in multiple rows back to a single row with multiple measures, but such a solution would have an adverse impact on performance.","Converting a LINQ query that returns both Dimensional and Measure Properties into a MDX query while preserving existing LINQ and SQL implied relational filtering semantics: The following explains how to return a Recordset containing only such a combination of Dimensional and Measure Properties that relate to each other in a cube data sources. It also explains how to filter out properly null valued cross-join combinations of dimensions and measures without filtering out records with measures that do exist in an underlying fact table but have null values.","Default MDX behavior in SSAS and other MDX OLAP servers is to return a Cartesian product of all permutations between different dimensions and measures including combinations that do not exist in a cube relational data source (e.g. do not make logical sense). SSAS will return results with NULL values for those combinations that do not exist. A typical solution used by other MDX generation tools is to apply NON EMPTY keyword. While that solution limits the result Recordset to those combinations of dimensions and measures that are actually present in a cube relational data source, it has a tendency to also filter out null measure values that do exist in the data source. This total filtering of all null values is a different behavior from semantics in LINQ, SQL and other relational query languages. Such null filtering behavior may distort the results and sometimes it is useful to know what measures have null values.","Aspects of the invention employ the EXISTS MDX function with 3 parameters, where the 3rd parameter is a name of a measure group which should be referenced by selected dimensions. Such a solution preserves relational query languages semantics, does not distort the results and works faster. If a LINQ query queries multiple measure groups, a separate EXISTS function should be used per each measure group and EXISTS functions should be nested into each other. Second argument of each EXISTS function may refer to a set of measures from a measure group mentioned in a third argument.","By way of a non-limiting example:",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Input LINQ:",{}]},{"entry":[{},"from customer in context.Customers",{}]},{"entry":[{},"from order in context.OrderDetails",{}]},{"entry":[{},"from product in context.Products",{}]},{"entry":[{},"select new",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\u2003customer.CustomerID,",{}]},{"entry":[{},"\u2003\u2003customer.CompanyName,",{}]},{"entry":[{},"\u2003\u2003order.Quantity,",{}]},{"entry":[{},"\u2003\u2003order.Discount,",{}]},{"entry":[{},"\u2003\u2003product.UnitsInStock",{}]},{"entry":[{},"}",{}]},{"entry":[{},"Output MDX:",{}]},{"entry":[{},"SELECT",{}]},{"entry":[{},"EXISTS",{}]},{"entry":[{},"(",{}]},{"entry":[{},"\u2003\u2003EXISTS",{}]},{"entry":[{},"\u2003\u2003(",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003{(",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003[Customers].[Customer ID].[Customer ID],",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003[Customers].[Company Name].[Company Name]",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003)},",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003[Measures].[Units In Stock]",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003},",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cProducts\u201d --2nd Measure group name",{}]},{"entry":[{},"\u2003\u2003)",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003[Measures].[Quantity],",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003[Measures].[Discount]",{}]},{"entry":[{},"\u2003\u2003},",{}]},{"entry":[{},"\u2003\u2003\u201cOrderDetails\u201d --1st Measure group name",{}]},{"entry":[{},")",{}]},{"entry":[{},"ON ROWS,",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\u2003[Measures].[Quantity], --measure from the 1st measure group",{}]},{"entry":[{},"\u2003\u2003[Measures].[Discount], --measure from the 1st measure group",{}]},{"entry":[{},"\u2003\u2003[Measures].[Units In Stock] --measure from the 2nd measure",{}]},{"entry":[{},"\u2003\u2003 group",{}]},{"entry":[{},"}",{}]},{"entry":[{},"ON COLUMNS",{}]},{"entry":[{},"FROM [NorthwindEF]"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Matching columns from MDX result recordset with column names following [DimensionName].[HierarchyName].[LevelName] pattern to LINQ (or SQL) result column names following [ColumnName] pattern: Use positional binding, generate a dimensional attribute name or a measure name in MDX query in the same relative position where a matching LINQ Dimensional or Measure Property was specified by LINQ select clause. Typically 2 separate axes will be used in a generated MDX query, but the result Recordset has a shape of a regular table and a solution for this problem is described above (i-v). A specific design and implementation details will be described more fully below.","The following is a non-limiting example using the above techniques and features to convert\/translate from LINQ\/SDX to MDX:",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"Input SDX:",{}]},{"entry":[{},{},"(",{}]},{"entry":[{},{},"from customer in context.Customers",{}]},{"entry":[{},{},"from order in context.OrderDetails",{}]},{"entry":[{},{},"where (\u201cItaly\u201d == customer.Country",{}]},{"entry":[{},{},"\u2003\u2003|| customer.Country == \u201cUSA\u201d)",{}]},{"entry":[{},{},"\u2003\u2003&& order.Discount != 0",{}]},{"entry":[{},{},"\u2003\u2003&& order.Quantity >= 100",{}]},{"entry":[{},{},"orderby customer.Country,",{}]},{"entry":[{},{},"\u2003\u2003customer.Region ascending,",{}]},{"entry":[{},{},"\u2003\u2003order.Discount descending",{}]},{"entry":[{},{},"select new",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003\u2003customer.CustomerID,",{}]},{"entry":[{},{},"\u2003\u2003order.Quantity,",{}]},{"entry":[{},{},"\u2003\u2003customer.CompanyName,",{}]},{"entry":[{},{},"\u2003\u2003order.Discount",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},").Take(8)",{}]},{"entry":[{},{},"Output MDX:",{}]},{"entry":[{},{},"SELECT",{}]},{"entry":[{},{},"NON EMPTY",{}]},{"entry":[{},{},"(",{}]},{"entry":[{},{},"HEAD",{}]},{"entry":[{},{},"(",{}]},{"entry":[{},{},"ORDER",{}]},{"entry":[{},{},"(",{}]},{"entry":[{},{},"ORDER",{}]},{"entry":[{},{},"(",{}]},{"entry":[{},{},"ORDER",{}]},{"entry":[{},{},"(",{}]},{"entry":[{},{},"(",{}]},{"entry":[{},{},"FILTER",{}]},{"entry":[{},{},"(",{}]},{"entry":[{},{},"(",{}]},{"entry":[{},{},"[Customers].[Customer ID].[Customer ID],",{}]},{"entry":[{},{},"[Customers].[Company Name].[Company Name]",{}]},{"entry":[{},{},")",{}]},{"entry":[{},{},",",{}]},{"entry":[{},{},"((([Customers].[Country].MemberValue = \u2018Italy\u2019) OR",{}]},{"entry":[{},{},"([Customers].[Country].MemberValue = \u2018USA\u2019)) AND",{}]},{"entry":[{},{},"([Measures].[Discount] <> 0))",{}]},{"entry":[{},{},"AND ([Measures].[Quantity] >= 100)",{}]},{"entry":[{},{},")",{}]},{"entry":[{},{},")",{}]},{"entry":[{},{},",",{}]},{"entry":[{},{},"[Measures].[Discount],",{}]},{"entry":[{},{},"BDESC",{}]},{"entry":[{},{},")",{}]},{"entry":[{},{},",",{}]},{"entry":[{},{},"[Customers].[Region].MemberValue,",{}]},{"entry":[{},{},"BASC",{}]},{"entry":[{},{},")",{}]},{"entry":[{},{},",",{}]},{"entry":[{},{},"[Customers].[Country].MemberValue,",{}]},{"entry":[{},{},"BASC",{}]},{"entry":[{},{},")",{}]},{"entry":[{},{},",",{}]},{"entry":[{},{},"8",{}]},{"entry":[{},{},")",{}]},{"entry":[{},{},")",{}]},{"entry":[{},{},"ON ROWS,",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"[Measures].[Quantity],",{}]},{"entry":[{},{},"[Measures].[Discount]",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"ON COLUMNS",{}]},{"entry":[{},{},"FROM [NorthwindEF]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"Design and Implementation Considerations for Object-Multidimensional Mapping Component and LINQ to MDX Translation with SSAS Entity Framework Provider as an Example: Converting a LINQ query where projection properties (columns) can be specified in any order into MDX query which employs multiple axes and limits a sequence in which measures and dimensions have to be specified.","As stated above, both LINQ and SQL queries return Recordsets where each row contains columns for both Dimensional and Measure Properties in a sequence specified by a query projection (LINQ \u201cselect\u201d clause). Measures can be mixed with dimensions in any order in the same single row. There is even no distinction between Dimensional and Measure Properties in a standard LINQ and SQL languages. But MDX does not allow such behavior. Someone has to specify all Dimensional Properties in ON ROWS axis and Measure Properties in ON COLUMNS axis in a MDX query in order to get all specified properties in the same single row. However, such action results in a Recordset where all Dimensional Properties are returned on the left side of the Recordset and all Measure Properties are on the right side. If someone issued a LINQ query similar to the following:",{"@attributes":{"id":"p-0059","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"from orderDetails in context.OrderDetails",{}]},{"entry":[{},"select new",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\u2003orderDetails.ProductID, --Dimensional Property",{}]},{"entry":[{},"\u2003\u2003orderDetails.Quantity, --Measure Property",{}]},{"entry":[{},"\u2003\u2003orderDetails.OrderID, --Dimensional Property",{}]},{"entry":[{},"\u2003\u2003orderDetails.Discount, --Measure Property",{}]},{"entry":[{},"\u2003\u2003orderDetails.UnitPrice",{}]},{"entry":[{},"}",{}]},{"entry":[{},"and converted it into MDX like that:",{}]},{"entry":[{},"SELECT",{}]},{"entry":[{},"{ --Measures are separate",{}]},{"entry":[{},"\u2003\u2003[Measures].[Quantity],",{}]},{"entry":[{},"\u2003\u2003[Measures].[Discount],",{}]},{"entry":[{},"\u2003\u2003[Measures].[Unit Price]",{}]},{"entry":[{},"} ON COLUMNS,",{}]},{"entry":[{},"NON EMPTY",{}]},{"entry":[{},"( --Dimensional attributes are separate",{}]},{"entry":[{},"\u2003\u2003[Products].[Product ID].[Product ID],",{}]},{"entry":[{},"\u2003\u2003[Orders].[Order ID].[Order ID]",{}]},{"entry":[{},") ON ROWS",{}]},{"entry":[{},"FROM [NorthwindEF]"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"As stated above, a possible solution would be to specify all Dimensional Properties before any Measure Properties in all LINQ queries, but that solution would be difficult to follow because it would be difficult to realize errors before run time and it is difficult to remember what properties are Dimensional Properties and what are Measure Properties.","Another solution is to put both Dimensional and Measure Properties into a single ON ROWS axis using CrossJoin MDX function and put any member from \u201cAll\u201d level of any attribute hierarchy into ON COLUMNS axis. (Note: if ON COLUMNS axis is left empty (\u201c{ }\u201d) no measure values will be returned, only measure captions). Such MDX query will execute and return multiple rows (one per each measure) with a single measure value per single row. But LINQ provider (e.g. Entity Framework) expects multiple related measures in the same row. In order to avoid an error in a LINQ provider when it tries to populate object graph (entities) from MDX result Recordset, a class extending AdomdDataReader (e.g. SsasDataReader P of ) should re-map multiple rows with a single measure value into a single row with multiple related measures expected by a LINQ provider (e.g. by ADO.NET Entity Framework) before returning the result Recordset back to a LINQ provider. A good implementation is to use Mapper design pattern to do that kind of re-mapping.","A preferred but not required solution which provides better performance is to:\n\n",{"@attributes":{"id":"p-0063","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003public override string GetString(int ordinal)",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003return",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003StoreDataReader.GetString(MdxColumnsOrder[ordinal]);",{}]},{"entry":[{},"\u2003\u2003\u2003}",{}]},{"entry":[{},"The following is a full working non-limiting sample implementation of",{}]},{"entry":[{},"ColumnOrderTracker (P4) class:",{}]},{"entry":[{},"using System;",{}]},{"entry":[{},"using System.Collections.Generic;",{}]},{"entry":[{},"using System.Linq;",{}]},{"entry":[{},"namespace",{}]},{"entry":[{},"AgileDesign.SsasEntityFrameworkProvider.Internal.MdxGeneration",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003class ColumnOrderTracker",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003\/\/Column indexes are 0-based in AdomdDataReader",{}]},{"entry":[{},"\u2003\u2003int linqColumnIndex;",{}]},{"entry":[{},"\u2003\u2003int columnsAxisColumnIndex;",{}]},{"entry":[{},"\u2003\u2003public int ColumnsAxisColumnIndex",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003get { return columnsAxisColumnIndex; }",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003int rowsAxisColumnIndex;",{}]},{"entry":[{},"\u2003\u2003public int RowsAxisColumnIndex",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003get { return rowsAxisColumnIndex; }",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003Dictionary<int, Func<int>> linqToMdxColumnsOrder_Delayed;",{}]},{"entry":[{},"\u2003\u2003IDictionary<int, Func<int>> LinqToMdxColumnsOrder_Delayed",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003get",{}]},{"entry":[{},"\u2003\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003return linqToMdxColumnsOrder_Delayed",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003?? (linqToMdxColumnsOrder_Delayed = new",{}]},{"entry":[{},"Dictionary<int, Func<int>>( ));",{}]},{"entry":[{},"\u2003\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003public IDictionary<int, int> LinqToMdxColumnsOrder",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003get",{}]},{"entry":[{},"\u2003\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003return LinqToMdxColumnsOrder_Delayed",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003.ToDictionary(i => i.Key, i => i.Value( ));",{}]},{"entry":[{},"\u2003\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003public void UpdateColumnsAxisColumnOrder( )",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003int currentColumnsAxisColumnIndex =",{}]},{"entry":[{},"\u2003\u2003\u2003ColumnsAxisColumnIndex;",{}]},{"entry":[{},"\u2003\u2003\u2003LinqToMdxColumnsOrder_Delayed[linqColumnIndex]",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003= (( ) => RowsAxisColumnIndex +",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003currentColumnsAxisColumnIndex);",{}]},{"entry":[{},"\u2003\u2003\u2003columnsAxisColumnIndex = ColumnsAxisColumnIndex + 1;",{}]},{"entry":[{},"\u2003\u2003\u2003linqColumnIndex = linqColumnIndex + 1;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003public void UpdateRowsAxisColumnOrder( )",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003int currentRowsAxisColumnIndex = RowsAxisColumnIndex;",{}]},{"entry":[{},"\u2003\u2003\u2003LinqToMdxColumnsOrder_Delayed[linqColumnIndex]",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003= (( ) => currentRowsAxisColumnIndex);",{}]},{"entry":[{},"\u2003\u2003\u2003rowsAxisColumnIndex = RowsAxisColumnIndex + 1;",{}]},{"entry":[{},"\u2003\u2003\u2003linqColumnIndex = linqColumnIndex + 1;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"input - SDX query:",{}]},{"entry":[{},"from customer in context.Customers",{}]},{"entry":[{},"from product in context.Products",{}]},{"entry":[{},"from order in context.OrderDetails",{}]},{"entry":[{},"select new",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\u2003CustomerID = customer.CustomerID,",{}]},{"entry":[{},"\u2003\u2003CompanyName = customer.CompanyName,",{}]},{"entry":[{},"\u2003\u2003Quantity = order.Quantity,",{}]},{"entry":[{},"\u2003\u2003Country = customer.Country,",{}]},{"entry":[{},"\u2003\u2003CategoryID = product.CategoryID",{}]},{"entry":[{},"}",{}]},{"entry":[{},"output - input translated into MDX:",{}]},{"entry":[{},"SELECT",{}]},{"entry":[{},"NON EMPTY",{}]},{"entry":[{},"(",{}]},{"entry":[{},"[Customers].[Customer ID].[Customer ID],",{}]},{"entry":[{},"[Customers].[Company Name].[Company Name],",{}]},{"entry":[{},"[Customers].[Country].[Country],",{}]},{"entry":[{},"[Categories].[Category ID].[Category ID]",{}]},{"entry":[{},")",{}]},{"entry":[{},"ON ROWS,",{}]},{"entry":[{},"{",{}]},{"entry":[{},"[Measures].[Quantity]",{}]},{"entry":[{},"}",{}]},{"entry":[{},"ON COLUMNS",{}]},{"entry":[{},"FROM [NorthwindEF]"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"6"},"Translating .NET variables and method parameters in LINQ where clause into MDX members and MDX filter( ) function values: This can be done in 3 steps:","1. When overriding DbProviderServices.CreateDbCommandDefinition( ) add parameters to a result DbCommand per each parameter expression of DbParameterReferenceExpression type from commandTree.Parameters collection of commandTree input parameter. Names of DbCommand parameters should match with keys in DbCommandTree.Parameters dictionary. Do not assign parameter values for parameters in DbCommand. Do not use \u201c@\u201d for parameters in DbCommand.","2. When generating MDX translate DbParameterReferenceExpression.ParameterName into a parameter value placeholder named as a parameter. (e.g. if parameter name is \u201cp_linq_country\u201d translate it into \u201c<p_linq_country>\u201d)","3. In SsasCommand replace the named parameter value placeholder with the actual parameter value before MDX is executed. Entity Framework will populate parameters in SsasCommand.Parameters with their values before SsasCommand is executed.","Data and control flow for replacing parameter placeholders with respective values is almost the same as for passing MdxColumnOrder mapping from MdxGenerator to SsasCommand steps shown on left part of . The difference is that MdxSelectStatement (P) and ColumnOrderTracker (P) are not involved, and there is no need in out parameter and additional properties when passing named parameter placeholders from MdxGenerator (P) to SsasCommand (P) because parameter placeholders are passed into SsasCommand (P) as parts of generated MDX string.","Converting a LINQ query that does not have measure properties among projected properties in it its select clause into MDX: ADOMD.NET can execute an MDX query that has an empty set \u201c{ }\u201d in ON COLUMNS axis, but it will not return values of Measure Properties in such a case, it will return only measure captions. To resolve this issue, the program generates a dummy calculated member with any fake value, and puts that calculated member into ON COLUMNS axis.","By way of a non-limiting example:","WITH MEMBER [Measures].[Dummy] AS NULL SELECT [Customers].[Company Name].[Company Name] ON ROWS, [Measures].[Dummy] ON COLUMNS FROM [NorthwindEF]","Constants that are generated by Entity Framework in a command tree: Entity Framework sometimes generates constants in the command tree which is an input to MDX generation component (e.g. MdxGenerator (P)). Typically the constant looks like a column named \u201cCx\u201d (e.g. C) and that constant's value is \u201c1\u201d. Regardless that MDX generation component does not need or use that constant value, LINQ to MDX generation and MDX query execution components cannot entirely ignore that constant. Entity Framework expects the constant value to be returned as a result of LINQ query, and if that constant is missing in the result Recordset Entity Framework throws an error. To resolve this issue: (a) Extend AdomdDataReader class (e.g. SsasDataReader (P)) to return a constant value=\u201c1\u201d in place of original Cx constant. MDX generation component (MdxGenerator (P)) should supply a position of that constant into extended AdomdDataReader (e.g. SsasDataReader (P)), and the extended AdomdDataReader returns 1 whenever the position of a constant Cx is requested. (b) MDX generation component generates a calculated member-measure with a constant value=\u201c1\u201d in a position corresponding to that constant. In such a case AdomdDataReader just returns the value from Cx column as is, without any manipulations with the result Recordset.","Supplying a cube name into MDX query generated by MDX generation component of a LINQ provider: ADO.NET Entity Framework does not supply a cube name into SQL or MDX generation classes; it provides them with a command tree only. Neither the command tree nor an original LINQ query contains anything related to a cube name. But a MDX query must specify a correct cube name in it's FROM clause in order to be executed successfully. A resolution to this issue is to save a cube name into a shared persistent storage like connection string in an application configuration file and read that cube name from that storage later during each MDX generation. Another resolution to this issue, which also works with dynamically supplied cube names, is to extend AdomdConnection class (e.g. SsasConnection (P)) with a new property for a cube name (e.g. SsasConnection.CubeName) and assign a cube name to that property before running LINQ query. But in this case MDX generation component (MdxGenerator (P)) still does not have an access to that cube name. Thus MDX generation component should use a placeholder instead of a real cube name. Also AdomdDataReader class (e.g. SsasDataReader (P)) should be extended with a behavior that reads cube name from an instance of an extended connection class (e.g. from SsasConnection.CubeName) and replaces cube name placeholder with a real cube name.","By way of a non-limiting example:",{"@attributes":{"id":"p-0072","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LINQ input",{}]},{"entry":[{},"from customer in context.Customers",{}]},{"entry":[{},"select new",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\u2003CompanyName = customer.CompanyName,",{}]},{"entry":[{},"}",{}]},{"entry":[{},"is translated by MdxGenerator into this unfinished MDX:",{}]},{"entry":[{},"WITH MEMBER [Measures].[Dummy] AS NULL",{}]},{"entry":[{},"SELECT [Customers].[Company Name].[Company Name] ON ROWS,",{}]},{"entry":[{},"[Measures].[Dummy] ON COLUMNS",{}]},{"entry":[{},"FROM <CubeNamePlaceholder>",{}]},{"entry":[{},"And finally SsasDataReader converts it into an executable MDX ",{}]},{"entry":[{},"statement with a proper cube name:",{}]},{"entry":[{},"WITH MEMBER [Measures].[Dummy] AS NULL",{}]},{"entry":[{},"SELECT [Customers].[Company Name].[Company Name] ON ROWS,",{}]},{"entry":[{},"[Measures].[Dummy] ON COLUMNS",{}]},{"entry":[{},"FROM [NorthwindEF]"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},{"@attributes":{"id":"p-0073","num":"0078"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"from customer in context.CubeName(\u201c[NorthwindEF]\u201d).Customers",{}]},{"entry":[{},"select new",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\u2003CustomerID = customer.CustomerID,",{}]},{"entry":[{},"\u2003\u2003CompanyName = customer.CompanyName,",{}]},{"entry":[{},"\u2003\u2003Country = customer.Country",{}]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Associating a Dimensional Property name in LINQ query with a cube dimension name in MDX query in order to generate an MDX query with a fully qualified dimensional attribute following [DimensionName].[HierarchyName].[LevelName] MDX Pattern: LINQ query references only class names and their property names. There is no reference to a dimension name in LINQ. The following illustrates how to get a dimension name when generating MDX.","A simple solution would be to generate MDX with dimensional attribute references without a corresponding dimension name. But this solution will not work if there are properties with the same name but belonging to different classes (and dimensions) in the same LINQ query. Also a MDX query that misses dimension names in its dimensional attribute references will execute slower.","A better solution is to use some form of persistent metadata in order to map a name of a class-owner of a dimensional property to a dimension name, persist and reuse that metadata mapping during MDX generation. The following are some non-limiting examples of how to map properties to dimensions and how to store those mappings in metadata:","a. Use .NET attributes taking dimension name as a parameter and persisting that information into .NET manifest.","b. Use XML file saved on disk.","c. Use some class naming convention\u2014for instance a convention when name of a class coincides with a dimension name.","SSAS Entity Framework Provider can use any of these approaches because it reuses naming conventions, mapping attributes or XML mappings used by ADO.NET Entity Framework infrastructure. Entity Framework associates table name with a class by means of any of these techniques, and SSAS Entity Framework Provider takes a table name from Entity Framework and uses it as a dimension name, optionally using AddSpacesToCamelCasingWordsConvention naming convention to convert a table name like \u201cSomeName\u201d into a dimension name like \u201cSome Name\u201d.","Thus it is seen that a two-dimensional query language that can operate to query multi-dimensional OLAP data sources and other MDX servers is provided. Although particular embodiments have been disclosed herein in detail, this has been done for purposes of illustration only, and is not intended to be limiting with respect to the scope of the claims, which follow. In particular, it is contemplated by the inventor that various substitutions, alterations, and modifications may be made without departing from the spirit and scope of the invention as defined by the claims. For example, the system is described as being set up as a program running on a computer that communicates over the Internet, local area network or inter-process channels with a data source. However, the system could also function with multiple computers and\/or servers configured to perform the various operations and\/or communications could take place via a network other than the Internet. Other aspects, advantages, and modifications are considered to be within the scope of the following claims. The claims presented are representative of the inventions disclosed herein. Other, unclaimed inventions are also contemplated. The inventors reserve the right to pursue such inventions in later claims.","Insofar as embodiments of the invention described above are implemented, at least in part, using a computer system, it will be appreciated that a computer program for implementing at least part of the described methods and\/or the described systems is envisaged as an aspect of the invention. The computer system may be any suitable apparatus, system or device, electronic, optical, or a combination thereof. For example, the computer system may be a programmable data processing apparatus, a computer, a Digital Signal Processor, an optical computer or a microprocessor. The computer program may be embodied as source code and undergo compilation for implementation on a computer, or may be embodied as object code, for example.","It is also conceivable that some or all of the functionality ascribed to the computer program or computer system aforementioned may be implemented in hardware, for example by one or more application specific integrated circuits and\/or optical elements. Suitably, the computer program can be stored on a carrier medium in computer usable form, which is also envisaged as an aspect of the invention. For example, the carrier medium may be solid-state memory, optical or magneto-optical memory such as a readable and\/or writable disk for example a compact disk (CD) or a digital versatile disk (DVD), or magnetic memory such as disk or tape, and the computer system can utilize the program to configure it for operation. The computer program may also be supplied from a remote source embodied in a carrier medium such as an electronic signal, including a radio frequency carrier wave or an optical carrier wave.","It is accordingly intended that all matter contained in the above description or shown in the accompanying drawings be interpreted as illustrative rather than in a limiting sense. It is also to be understood that the following claims are intended to cover all of the generic and specific features of the invention as described herein, and all statements of the scope of the invention which, as a matter of language, might be said to fall there between."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a better understanding of the invention, reference is made to the following description, taken in conjunction with the accompanying drawings, in which like reference characters refer to like parts throughout, and in which:",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
