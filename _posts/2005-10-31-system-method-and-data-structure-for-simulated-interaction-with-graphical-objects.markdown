---
title: System, method and data structure for simulated interaction with graphical objects
abstract: Object simulation and interaction of and between computer-generated or graphical objects in a virtual space includes neutral scene graphs, data structures and procedures for using such graphs and data structures.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07676356&OS=07676356&RS=07676356
owner: Immersion Corporation
number: 07676356
owner_city: San Jose
owner_country: US
publication_date: 20051031
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF EMBODIMENTS OF THE INVENTION","Description of Embodiments of Neutral Scene Graphs, Object-Manipulation, and Impedance Mode Techniques","Embodiment of Object-Manipulation Structure and Procedure","Embodiment of Impedance Mode Structure and Procedure","Embodiment of Virtual Hand Toolkit (VHT) and Virtual Hand Suite"],"p":["This application is a continuation of U.S. patent application Ser. No. 09\/675,811, now U.S. Pat. No. 7,050,955, entitled \u201cSystem, Method and Data Structure for Simulated Interaction with Graphical Objects\u201d, filed Sep. 29, 2000 which, in turn, claims the benefit of U.S. Provisional Patent Application Ser. No. 60\/157,272 filed Oct. 1, 1999 entitled \u201cData Structures and Algorithms For Simulated Interaction With Graphical Objects\u201d, both of which applications are hereby incorporated by reference as if set forth fully herein and are commonly owned.","This invention pertains generally to computer graphics and to two-dimensional and three-dimensional simulation and interaction with objects represented by such graphics, and more particularly to system, method, data structures, and computer programs for simulated interaction with such graphical and virtual objects.","Heretofore the ability to integrate real-time three-dimensional hand interaction into software applications has been some what limited and has required a relatively high level of skill among practitioners. Complex three-dimensional worlds have not been easy to simulate and frequently such simulations where performed in a rudimentary manner as the required results would not support the massive efforts needed to understand the simulated environment, objects in that environment, or the input\/output devices with interaction with the environment and objects would be made. Nor has it been practical to was time developing complex scene graphs and mapping between the several scene graphs that might typically be present. System interaction and the visual and tactile\/force feedback were also in need of improvement, particularly where it was desired that visual feedback cues be synchronized with tactile and force cues, especially for had grasping interactions of virtual objects.","These and other limitations have been addressed by the inventive system, method, data structures, computer program, and computer program product of the invention.","The invention provides structure, method, computer program and computer program product for novel object simulation and interaction of and between computer generated or graphical objects in virtual space. These include novel Neutral Scene Graphs data structures and procedures for using such graphs, Object-Manipulation Procedures, and impedance mode procedures and techniques for simulating physical interaction with computer generated graphical objects in virtual space.","Aspects and embodiments of the invention are now described relative to the figures. Three aspects of the invention are first described all pertaining to different aspects of simulation and interaction between computer generated or graphical objects in virtual space. These aspects involve: (i) Neutral Scene Graphs, (ii) Object-Manipulation Algorithms and Procedures, and (iii) Impedance mode procedures and techniques. In general each of the aspects involves a certain methodological or procedural steps that are conveniently implemented on either a general computer system of the type having a processor and memory coupled to the processor, input\/output devices, and other elements that are known in the art of personal computers. The invention may also be practiced with special purpose computers or in hardware. Data structures are also created and used relative to at least some of the inventive procedures.","After these three aspects have been described in some detail, the implementation of one particular embodiment of the invention as computer software is described in considerable detail so that the interaction between the above described three aspects and other elements of a simulation and interaction system and method may more clearly be understood. This implementation is referred to as the Virtual hand Toolkit (VHT) which is a component of the Virtual hand Suite 2000.","Neutral Scene Graph","In a first aspect, the invention provides a system, apparatus, method and computer program and computer program product for relating two or more scene-graph data structures. As used in this description as well as in the applicable arts, a scene graph may be thought of broadly as a data structure that structures or organizes a collection of nodes into a hierarchy through the use of directed edges. In addition, a scene graph typically has no cycles, which means that it is not typically possible to follow a sequence of edges and arrive at the starting node. The technical term for this type of graph structure is a directed acyclic graph (DAG). Directed acyclic graphs are known in the art and not described in further detail here. In practice, non-terminal nodes (that is, those nodes with directed edges leaving the node) of a scene graph are called or referred to as group nodes. Group nodes may also contain one or more homogeneous transformation matrices. A path in a scene graph is a set of nodes and edges that ends at a terminal node. The product of any transformation matrices encountered in a path provides the frame (position, orientation) of the terminal node with respect to the node at the start of the path.","A Neutral Scene Graph (NSG) is a structure as well as a mechanism or procedure for relating two or more scene graphs. An NSG may for example, provide a topological mapping between multiple scene graphs. An NSG is typically a directed acyclic graph (DAG) where each node may contain pointers to one or more nodes in the scene graphs the NSG is to relate.","One use for such an NSG is to synchronize two or more \u201casynchronous\u201d scene graphs in time. A set of \u201csynchronizing\u201d NSGs may, for example, be used to synchronize a set of \u201casynchronous\u201d scene graphs. In addition to synchronizing asynchronous scene graphs, NSGs may also provide additional information, functions, one or a set of indicators, flags, transformations, instructions for data manipulation, other information, and the like. An NSG may but does not need to preserve the connectivity of the graphs it relates.","A transformation introduced by an NSG may provide a mapping between a node in a first graph to a node in a second graph or between a node in the second graph to a node in the first graph. Where more than two graphs are involved, the NSG may introduce multiple transformations for mapping nodes in and between each of the two or more graphs. The direction of the mapping may be provided by a flag or other indicator or information item. Other flags, indicators, or information items may be used to hold information about the state of synchronization of various graphs.","Graph traversals of an NSG may provide a mechanism for asynchronously synchronizing the nodes in one or more graphs. The one or more graphs may be updated independently and\/or in separate threads or processes.","A set of NSGs may also be used to map between two or more sets of graphs. A separate NSG may be used to synchronize each graph pair.","In one exemplary embodiment, illustrated in , one NSG synchronizes two scene graphs, graph A (SG-A) and graph B (SG-B), and each node in the NSG (nodes shown as square box) contains two pointers, one to a node in graph A (nodes shown as round circles) and one to a node in graph B (nodes shown as triangles). NSG pointers are also illustrated as are scene graph edged using different arrow heads as indicated in the figure key.","In another exemplary embodiment, an NSG provides the mapping between: (1) a graphical scene graph (GSG), such as OpenInventor, OpenGL Optimizer, Performer, and the like, or any other graphical scene graph application program interface (API); and (2) a haptic scene graph (HSG) or an interaction scene graph (ISG). In this second embodiment, the HSG is typically a scene graph of the type used for fast collision detection between virtual objects in a simulated two-dimensional (2D) or three-dimensional (3D) environment. In this embodiment, the NSG is constructed to map the haptic scene graph (HSG) and the graphical scene graph (GSG). There is a transformation in each NSG node that is a function that converts a homogeneous transformation matrix in HSG form into a transformation matrix in the desired GSG form. This transformation is invertible, and the direction of the update is controlled by a flag, indicator, or other control device. In some instances, the transformation may be a unity or identity transformation.","The Neutral Scene Graph (NSG) described here is particularly useful since typically computer graphics associated with a 2D or 3D simulation only needs to be updated from between about 10 times per second to about 60 times per second since these rates are typically sufficient to support visual observation. In contrast, a haptic (i.e., force feedback) display and the associated interactive mathematical model of the simulation typically requires (or at least greatly benefits from) much faster update, such as more than 100 times per second and typically from about 1000. times per second to 2000 times per second or more. Thus, the graphical update (e.g. 10-60 times\/second update frequency) can advantageously be run or executed in a separate computer program software thread, and at a much different update rate, from the corresponding haptic or interaction thread (e.g. 1000-2000 times\/second update frequency). Those workers in the art will appreciate that these data update frequencies are provided for the purpose of illustration and that the invention itself is not limited to any particular update rate or frequency. The inventive NSG provides an efficient mechanism to ensure that the updated graphical data remains synchronized with the corresponding updated haptic or interaction data, even if and when they are updated at different times and intervals.","In a second aspect, the invention also provides an object-manipulation data structure, procedure, algorithm, computer program and computer program product which uses a static-friction approximation with parameters to allow user control over the ease of manipulation or control of virtual objects. Each collision event detected between a portion of a grasping (or contacting) virtual object (such as a graphical hand) and a virtual object to be grasped (or contacted) yields a contact normal data (or signal), which is input to a state machine and more particularly to a manipulation finite-state machine (MFSM).","Each virtual object to be grasped (or otherwise contacted) has an associated MFSM that in turn has an associated grasping virtual object \u201cparent,\u201d referred to as the GParent. (For simplicity of explanation, a grasping type contact will be assumed for purposes of description here, but the invention is not limited only to grasping type contact.) A GParent is a virtual object that is capable of grasping another virtual object. A GParent may be any virtual object independent of a virtual object to be grasped, and each GParent virtual object may have any number of other virtual objects using it as a GParent. Collision information between a virtual object to be grasped and its GParent is used in the inventive algorithm, method, and computer program. The state of the manipulation finite-state machine (MFSM) determines how a virtual object behaves with respect to it GParent.","An exemplary embodiment of a MFSM is illustrated in , and includes the following states: NONE, ONE, G, and RELEASE. In the \u201cNONE\u201d state, the virtual object to be grasped is not in a graspable state. In the \u201cONE\u201d state, there are insufficient contacts and contact normals to fully constrain the virtual object with respect to the GParent. The object may only be manipulated around by the contact point. In the \u201cG\u201d state, there are at least three \u201cgrasping\u201d contact points whose contact normals each have at least some specified minimum angular separation. The virtual object to be grasped is considered fully constrained by its GParent. In the \u201cRELEASE\u201d state, the object was previously constrained to the GParent but is now in the process of being released.","Transition of and between the states in the exemplary embodiment of the MFSM of  are governed by various parameters including but not limited to the following parameters: minimum normal angle (MinNormalAngle), minimum drop angle (MinDropAngle), number of drop fingers (NumDropFingers), and grasp one cone slope (GraspOneConeSlope).","The minimum normal angle (MinNormalAngle) parameter includes an angular quantity giving the minimum angular separation of all contact normals required to enter a G state.","The minimum drop angle (MinDropAngle) parameter is an angular quantity specifying the angle limit for a GParent Manipulator relative to a reference datum necessary for the manipulator to not be classified as a Drop Finger. A Manipulator is defined as the vector from a reference point on the GParent to a contact point on the parent so that the MinDropAngle specifies the angle limit for a GParent Manipulator relative to a reference datum necessary for the manipulator to not be classified as a Drop Finger. When the GParent is a graphical hand, this manipulator is the vector from the metacarpaophalangeal joint of the hand to the contract point on the finger. The MinDropAngle may be defined as the angle of a manipulator relative to the palm of the hand (i.e., the metacarpus), beyond which, the manipulator is classified as a Drop Finger. The minimum drop angle (MinDropAngle) may also be defined as a maximum allowable change in angle of a manipulator relative to an angle of the manipulator while the finger is in contact with the virtual object to be grasped (such as the angle of the manipulator just before contact ceases).","The number of drop fingers (NumDropFingers) parameter includes the number of manipulators whose angles do not exceed the MinDropAngle requirement, beyond which number the grasped virtual object enters the Release state.","The grasp one cone slope (GraspOneConeSlope) parameter includes the angular tolerance of the contact normal for maintaining a ONE state.","The MFSM may optionally depend on either the position or velocity of the contact points, but generally need not depend on either the position or velocity of the contact points. The contact condition may be characterized merely by a normal, so the virtual object to be grasped does not have to be in actual contact with a GParent to undergo a state transition. A separate invisible (e.g., non-rendered) representation of the virtual object may be used by the MFSM, and may be increased in size, scaled, or otherwise augmented or padded with a manipulation layer to make it easier to manipulate or to otherwise alter or augment its manipulation characteristics. This also permits virtual objects to be manipulated remotely.","With further reference to the state diagram of , the diagram illustrates possible state transitions between the states of the MFSM that can occur during the state recalculation. These transitions include a transition from NONE to ONE in response to a \u201cnew contact\u201d condition, and a transition between ONE and NONE in response to a \u201c0 contact\u201d (zero contact) condition. New contact is the condition when a point on the GParent, which in the previous iteration was not in contact with the virtual object to be grasped, comes into contact with the virtual object. Zero Contact (or no contact) is the condition when in the previous algorithm iteration there was at least one point on the GParent in contact with the virtual object to be grasped, but there are no longer any such contact points. The manipulation state also transitions from RELEASE to NONE in response to the \u201c0 contact\u201d condition. Manipulation state transitions from the ONE state to the G state when there are a good set of normals and three contacts. Normals are considered to be good when there is at least one pair of contract normals which have an angle between them exceeding the MinNormalAngle parameter. The manipulation state in the MSFM transitions from G to RELEASE when the number of \u201cmanipulators\u201d which have an angle less than the minimum drop angle is not greater than or equal to NumDropFingers. An example value for NumDropFingers is 2. Once the state machine is in the ONE state, it will remain in that state when any new contact condition occurs, unless conditions are met to transition to the G state.","One embodiment of the inventive grasping method, algorithm, procedure, and computer program includes the following steps. While the grasping or manipulation simulation is running (typically by executing the simulation program in processor and memory of a general purpose digital computer), the neutral scene graph (described above) synchronization procedure is executed to synchronize the graphical scene graph and the interaction (or haptic or collision) scene graph. In this embodiment, the graphical scene graph comprises an OpenGL representation of the GParent and virtual object to be grasped. Also in this embodiment, the interaction scene graph comprises features of the GParent and virtual object that may be different from their respective OpenGL representations. For instance, the virtual object may be scaled larger to make it easier to grasp, have sharp edges smoothed so a haptic display does not go unstable, be represented by one or a set of simpler geometric shapes to make interaction calculations more efficient, and the like (Step ). Next, the virtual objects that are in the ONE or G state are either in contact with the GParent or are being grasped by it, and are thus constrained to move based on their relationship with their associated GParent, (Step ). More than one MFSM will be provided when there is more than one virtual object to be grasped, a single MFSM process being allocated to each virtual object to be grasped.","Collision checks are then performed between the manipulator and the virtual environment (Step ). Here the manipulator is defined to include the portion of the GParent in contact with a virtual object. In a useful embodiment, collision checking is done using the VClip algorithm known in the art. In one embodiment of the invention, collision detection may utilized the techniques described in co-pending U.S. Utility application Ser. No. 09\/432,362 filed Nov. 3, 1999 and entitled \u201cSystem And Method For Constraining A Graphical Hand From Penetrating Simulated Graphical Objects,\u201d which is hereby incorporated by reference.","For each collision that is detected, the collision information, including (1) the contact point between the manipulator (i.e., the object pointed to by GParent, which is sometimes referred to as the Virtual End Effector) and the virtual object, (2) the normal to the contact point, and the like, are sent to the MFSM corresponding to the object that is colliding with the manipulator (Step ). Finally, the grasping state for all MFSMs are recalculated at the interaction update rate, which is typically as fast as the interaction software thread can run. Exemplary pseudo code for the grasping algorithm is set forth immediately below:",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"while( simulation running )"},{"entry":"\u2003perform NSG synchronization with graphics and collision graph"},{"entry":"\u2003for all objects in the ONE or G3 states, constrain their placement and"},{"entry":"\u2003movement to the placement and movement of the associated"},{"entry":"\u2003manipulator (a.k.a. VEE)"},{"entry":"\u2003perform collision check between manipulator and virtual environment"},{"entry":"\u2003for each collision"},{"entry":"\u2003\u2003send collision information (contact point, normal, etc.) to the"},{"entry":"\u2003\u2003MFSM corresponding to the object colliding with the manipulator"},{"entry":"\u2003recalculate grasping state for all MFSMs"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Exemplary computer program source code for one particular embodiment of the manipulation (grasping) state-machine class is provided in Appendix I. A CDROM containing executable code is provided in Appendix II, and a Programmer's Guide is provided in Appendix III.","In yet another aspect, the subject invention provides a haptic-control technique for low-bandwidth updates of a force-feedback controller and a force-feedback controller and method of control incorporating or utilizing these low-bandwidth haptic-control updates. This inventive technique is particularly applicable to situations where a simulation is executing asynchronously (either on the same computer in a different thread or on a separate computer) from an associated force-control process.","For the purpose of this description, we refer to a Physical End Effector (PEE) as a physical device (typically a mechanical or electromechanical device) which can apply force to a physical user, and we refer to a virtual end effector (VEE) as the virtual object or objects that represent this PEE device in a computer simulation.","The computer simulation software thread communicates to the force-control software thread a Local Surface Approximation (LSA) of a virtual object (or objects) in a region local to a VEE. The force-control software thread then computes the actual force to be generated by the PEE. The control process executes a real-time (or substantially real-time or near real-time) control loop that uses the LSA information to generate a realistic force approximation to the LSA for display on the PEE.","An Local Surface Approximation (LSA) includes an approximation of at least one, and advantageously, each of the factors in a region near the VEE that are likely to influence the VEE. The LSA description may, for example, include information about the geometry, velocity, acceleration, compliance, texture, temperature, color, smell, taste, and the like, or any other physical, static, dynamical or any other property associated with one or more nearby virtual objects. A geometric approximation may, for example, include: (1) a single polygon (such as a virtual object tangent plane), (2) an approximating polyhedron, (3) a parametric surface (such as NURBS or subdivision surfaces), and the like.","Each LSA may also optionally contain information about the surface texture of a portion of a nearby virtual object. Such surface texture may include any haptic-related contact properties, such as contact model parameters like stiffness and damping. Such parameters may be encoded as multiple textures on the geometric surface. Associated with an LSA may be one or a set of flags or other indicia to give information about the contact state, or separation distance, and grasp state of the neighboring virtual objects.","Each VEE in the simulation may have multiple possible LSA's associated with it due to the multiple virtual objects in a simulation. Two exemplary embodiments of procedures for associating LSAs with VEEs are now described. In the first possible procedure, the LSAs are sorted by contact state with assignment to a VEE the LSA closest to it. In a second possible procedure, a new composite LSA that encompasses all LSA's within a fixed distance of the VEE is constructed.","One embodiment of the host-computer-side procedure and algorithm is now described. While the simulation is running or executing on a general purpose computer, collision detection checks are performed between the VEE and the virtual environment (Step ). In one embodiment of the invention, collision detection may utilized the techniques described in co-pending U.S. Utility application Ser. No. 09\/432,362 filed Nov. 3, 1999 and entitled \u201cSystem And Method For Constraining A Graphical Hand From Penetrating Simulated Graphical Objects,\u201d which is hereby incorporated by reference.","The paragraph above describes the collision-check step, now the remaining steps follow: Construct a set of LSAs for each potential collision between the VEEs and all the virtual objects. Each LSA in the set corresponds to the object portion that is in contact or potential contact with the VEEs (See ). The set of LSAs are stored a memory buffer.","For each VEE find the subset of LSAs in the memory buffer that correspond to that particular VEE. Perform one of the following two steps: (i) combine the subset LSA into a single set, and )ii) select the most significant LSA out of the subset. In either case, one LSA is constructed of selected for each VEE. The final step is to send this LSA to the PEE controller.","An exemplary embodiment of the host side procedure is summarized in pseudo-code immediately below.",{"@attributes":{"id":"p-0049","num":"0048"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003while( simulation running )"]},{"entry":[{},"\u2003\u2003perform collision check between VEE and virtual environment"]},{"entry":[{},"\u2003\u2003for( each collision pair )"]},{"entry":[{},"\u2003\u2003\u2003construct LSA to the object portion of the contact pair"]},{"entry":[{},"\u2003\u2003\u2003send LSA to command buffer"]},{"entry":[{},"\u2003\u2003for( each LSA in command buffer )"]},{"entry":[{},"\u2003\u2003\u2003for( each VEE )"]},{"entry":[{},"\u2003\u2003\u2003\u2003construct single LSA corresponding to all LSAs for this"]},{"entry":[{},"\u2003\u2003\u2003\u2003VEE, OR find closest LSA to VEE"]},{"entry":[{},"send LSA to PEE controller"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"On the force-control side this procedure and algorithm uses two asynchronous threads of execution, the slow-thread and the fast-thread. The slow-thread uses the LSA information and the Physical End Effector (PEE) model to calculate the corresponding interaction force-field (spatial distribution of interaction forces due to LSA\/PEE configuration). The fast-thread uses the latest available force-field (calculated by the slow-thread) and the feedback from the sensors (high bandwidth information) to control the actuator device. Hence, the fast-thread is the dedicated servo controller for the force actuators. De-coupling the slow-thread enables the fast-thread to run at kilohertz rates increasing haptic feedback fidelity.","The fast-thread may employ a variety of control algorithm including control algorithms known in the art and proprietary control algorithms. Such control algorithms, may for example include position control and force control. For example, for position control, the force applied by the PEE is determined based on the discrepancy between desired position and\/or velocity of the VEE with respect to the haptic surface texture. For force control, the force applied by the PEE is determined based on the discrepancy between applied and computed forces.","The slow-thread loop and fast-thread loop procedures for each Physical End Effector (PEE) are now described. For the slow code thread loop the procedure for each PEE is as follows: First, the LSA is projected into the actuator domain. Next, the PEE model is projected into the actuator domain. Finally, collision detection is performed in the actuator domain to calculate or otherwise determine a corresponding force field.","The fast code thread loop runs at a higher frequency such as for example between 1 kHz and 2 kHz. For each PEE, the fast sensors are read and mapped. Fast sensors may for example include feedback or other signals or data from encoders, tachometers force sensors, or the like. Next, discrepancies between current (measured) and desired force field are calculated. Finally, the corresponding control signal is calculated and then applied to affect the desired control","An exemplary embodiment of the Physical End Effector (PEE) side slow-thread and fast-thread loop control procedures are summarized in pseudo-code immediately below.",{"@attributes":{"id":"p-0055","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"SLOW-THREAD LOOP"},{"entry":"for( each Physical End Effector- PEE )"},{"entry":"\u2003project LSA into actuator-domain"},{"entry":"\u2003project PEE model into actuator-domain"},{"entry":"\u2003perform collision detection in actuator domain to calculate"},{"entry":"\u2003corresponding force field."},{"entry":"-FASTER-THREAD LOOP (1KHz)"},{"entry":"for( each PEE)"},{"entry":"\u2003read and map fast sensors (feedback from encoders, tachometers force"},{"entry":"\u2003sensors, etc.)"},{"entry":"\u2003calculate discrepancies between current (measured) and desired force"},{"entry":"\u2003field"},{"entry":"\u2003calculate and apply corresponding control signal."},{"entry":"for( each PEE )"},{"entry":"\u2003project LSA into actuator-domain"},{"entry":"\u2003project PEE model into actuator-domain"},{"entry":"\u2003perform collision detection in actuator domain to calculate"},{"entry":"\u2003corresponding force field."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The Virtual Hand Toolkit (VHT) is the application development component of the VirtualHand Suite 2000, which also includes the Device Configuration Utility and the Device Manager. The later two components are described in detail in the VirtualHand Suite User's Guide. These technology is developed by Virtual Technology, Inc. of Palo Alto, Calif.","Virtual Technology Inc (Vti) hardware will typically ship with basic software to help users access devices however, purchasing the VirtualHand Suite offers significant additional functionality, including the complete set of libraries included in the VHT. The goal of VHT is to help developers easily integrate real-time 3D hand interaction into their software applications thus minimizing development efforts. Complex 3D simulated worlds are not easy to implement, and programmers can't afford to spend the time required to understand all the inner workings of advanced input\/output devices such as the CyberGlove, CyberTouch and CyberGrasp. Nor can they waste time on other complex issues such as collision-detection, haptic scene graphs, event models and global system response.","In a conventional application development environment, with an integrated graphical user interface, programmers are provided with implicit operation of the mouse, windows, document containers and various widgets. The Virtual Hand Toolkit (VHT) takes a similar approach, offering automatic management of virtual hands, a simulated world with graphical representation and an expandible model for handling interactions between world entities.","The VHT is transparent to the programmer's work, as its core is based on a multi-threaded architecture backed with event-based synchronization. This is similar to GUI-based applications where the programmer need not manage the mouse or service GUI events. The application development process should focus on application-specific functionality, not low-level details. To develop an application that makes use of Virtual Technologies' whole-hand input devices, the softwar designer is provided with an application model that consists of three major components:\n\n","The Virtual Hand Toolkit (VHT) is divided into a number of functional components. This fact is reflected in the division of the libraries. The toolkit is now implemented by two libraries and a set of support libraries.","All purchased VTi hardware comes basic software that includes the Device Configuration Utility, Device Manager and the Device layer part of the Virtual Hand Toolkit. This includes VTi hardware support in the form of device proxy classes as well as a set of classes for doing 3D math and finally a set of exception classes. The basic device layer is described in detail in Chapter 4.","The main functionality of the VHT is contained in the Core layer and includes both the haptic and neutral scene graphs, simulation support, collision interface, model import, human hand support (including grasping and ghosting).","Third-party support packages and interfaces are located in separate specific libraries. For example, support for the Cosmo\/Optimizer display engine and import into the VHT is located in a separate library. Also, local geometry level collision detection is externalized and the VHS includes two modules that may be used. The relationships between these levels can be seen in .","The next sections describe all the components of the VHT and the typical usage of each of the classes that make them up.","A complete working example is also presented throughout the chapters, for a hands-on experience of application development.","Those workers having ordinary skill in the art are assumed to have a working understanding of C++ programming language and are proficient with a development environment on their platform (such as Windows NT or SGI IRIX). Some basic knowledge of 3D graphics is also assumed. Additional background information to provide or supplement this knowledge is provided in standard textbooks such as: , J. Foley, A. van Dam, S. Feiner, J. Hughes. 2nd Edition, Addison-Wesley, 1996; and , Bjarne Stroustrup, 3rd Edition, Addison-Wesley, 1997; each of which is hereby incorporated by reference. In this section, an overview of the Virtual Hand Toolkit (VHT) is presented. Simple examples are used to illustrate the usage of the main classes in the VHT. Furthermore, the proper development environment settings (for NT\/2000 and IRIX) are explained. For a fuller understanding and discussion of the classes, please refer to the subsequent sections (chapters).","Virtual Human Hand","In an application, the Virtual Human Hand class (vhtHumanHand) is the high-level front-end for Virtual Technologies' whole-hand input devices. It lets the developer easily specify what kind of devices are to be operated, and where they are serviced. Then it takes care of all further operations automatically. The aim is to make these advanced I\/O devices as transparent as possible, much like the computer mouse in traditional applications.\n\nObject Manipulation and Interaction\n","Developing an interactive 3D application is a complex process because of the necessity of defining simulated objects and controlling their state at run-time. The VHT has a significant section dedicated to these particular tasks. The Haptic Hierarchy and associated import filters provide a simple way to specify the geometrical and physical details of digital objects. The Collision Detection Engine keeps track of any contact between objects as they move or change shape and provides the simulation environment with this information in a multi-threaded fashion.","Rendering","Most applications need to present the mathematical and geometrical information discussed in the previous sections in a more visual form, namely as 3D digital objects. Although that particular task does not involve the VHT, close cooperation is required to achieve realistic rendering. For this the VHT provides a Data-Neutral Scene Graph that binds user-specific data with haptic objects for synchronization, or notification of haptic events. It also offers the functionality to render digital hands that closely mimic the behavior of a human hand being measured by a VTi instrumented glove such has the CyberGlove.","Creating an Application","There are three simple steps to follow when using the VHT as the main haptic simulation loop of your application. In this guide, we present the most common approach: connecting to a CyberGlove and a six degree-of-freedom (6-DOF) position tracker (Polhemus or Ascension), associating the devices to the application's virtual hand (vhtHumanHand instance), and creating the support environment with the vhtEngine and vhtSimulation classes. If you have not already done so, you should refer to the VirtualHand Suite User's Guide as well as the hardware manuals before proceeding further.","Setting-Up a Virtual Hand","The Virtual Hand Toolkit uses a client\/server architecture in which the user's application acts as the client. The physical devices reside on the server side, also known as the Device Manager. The Device Manager can be running on the same machine as your application, or on any other machine on your network (or even the Internet, although performance may suffer). In either case, it is necessary to specify which of the devices are going to be used by the application.","The address of a CyberGlove is given through a helper class named vhtlOConn. The straightforward use of vhtlOConn is through VTi's resource registry, which is specified in an external file. If the VTI_REGISTRY_FILE environment variable specifies a registry file, then to attach to the default glove you only have to do:\n\n","One can also provide all the details in your code. We will use as an example a setup in which the Device Manager is running on the same machine as the application (localhost), the device being used is a CyberGlove (cyberglove) and it is connected on the first serial port (COM1) and running at maximum speed (115200 baud).","The address of the CyberGlove is specified as:",{"@attributes":{"id":"p-0074","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":"vhtlOConn gloveAddress(\u201ccyberglove\u201d, \u201clocalhost\u201d, \u201c12345\u201d, \u201ccom1\u201d, \u201c115200\u201d);"}},"The third parameter in the gloveAddress specification is the port number of the Device Manager which by default is 12345. Should you encounter problems connecting, you should contact the person who installed the Device Manager to know if it is expecting connections on a different port number.","Once the address is specified, the actual connection to the server is obtained by creating a device proxy, using the class vhtCyberGlove. This is easily achieved by using the following line:\n\n","When the vhtCyberGlove instance is created, it does all the necessary work to locate the Device Manager, to find the right device and to create a continuous connection between the application and the Device Manager.","In a similar fashion, a proxy to the default tracker is instantiated by:",{"@attributes":{"id":"p-0078","num":"0000"},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":"vhtTracker*tracker=new vhtTracker(vhtlOConn::getDefault(vhtlOConn::tracker));"}},"We can also specify which of the tracker's position receivers to use (some have more than one). An individual tracker receiver is supplied by the vhtTracker::getLogicalDevice method, which returns a vht6Dof Device instance. Thus, the following code segment gets the first receiver on the tracker, and associates it with the glove defined previously through the helper class vhtHandMaster:\n\n","At this point, the vhtHumanHand object is ready to be used as a data-acquisition device. We are interested in using it at a higher-level, so the next step is to set up a more elaborate environment.","Setting-Up a vhtEngine","The vhtEngine is a central container for the VHT runtime context. For normal operations, you will create a single instance of the vhtEngine class in your application, like this:\n\n","When the global vhtEngine object is available, the vhtHumanHand created in the previous section can be registered for automatic management. This is done with a call to the vhtEngine::registerHand method:\n\n","Once the hand is registered, the automatic update mechanism of the vhtEngine will take care of fetching the latest data from the devices it relates to. By default, the vhtEngine does all operations from its own thread of execution, including managing the vhtHumanHand instance.","Creating a Simulation Framework","The two previous steps created a transparent infrastructure for an application that will perform hand-based manipulation. The next step is to supply the extension path through which the application will interact with the VHT and provide it with the simulation logic. The VHT requires that some kind of simulation logic be registered with the vhtEngine. For the most basic cases, you can use the vhtSimulation class. You register a simulation object in the vhtEngine instance as follows:\n\n","When the vhtEngine instance has all its necessary information, the start( ) method can be called. At that point, a private thread is launched and it will work in the background to do all the necessary management.","Putting Objects in the Environment","The VHT helps applications deal with more than just hand data\u2014it is designed to ease the task of developing applications that require the manipulation of arbitrary 3D digital objects. For this purpose, a haptic scene graph framework is provided, along with an external data import mechanism.","The haptic scene graph can be constructed by specifying the geometry of simple objects from within the application. Given the complexity of the average digital object, applications will most likely import object descriptions from data files generated by third party 3D modellers.","Specifying Objects","Two kind of geometries are supported as nodes of the haptic scene graph: polyhedrons, and elementary common shapes like spheres and cubes.","Polyhedrons are useful for approximating most surfaces found on objects. It is common for 3D modellers to generate triangle-based faces of complex geometries, as they are simple to manage and they have good properties for visual rendering. In the VHT, instances of the vhtVertexGeometry class represent polyhedrons.","When analytical surfaces are required, one can use the elementary common shapes by instantiating objects using the vhtVertexBox, vhtVertexSphere and other basic shape classes. While these geometries are not as common in real-world simulations, they offer the advantage of being well-defined. Although this current version of the VHT does not perform any optimization on these surfaces, future versions will take advantage of their known mathematical properties to process operations faster than with general polyhedra.","Adding Objects","Creating Shapes Explicitly Using the VHT","One may create a polyhedron object by defining a set of vertices and assigning them, with the vertex count, to a vhtVertexGeometry. The resulting polyhedron is then assigned to a vhtShape3D instance. For a simple unit cube, this is done in the following fashion:",{"@attributes":{"id":"p-0092","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"vhtVertexGeometry *polyhedron"]},{"entry":[{},"vhtShape3D \u2003\u2003\u2003\u2003*object;"]},{"entry":[{},"vhtVector3d \u2003\u2003*vertices;"]},{"entry":[{},"vertices= new vhtVector3d[8];"]},{"entry":[{},"vertices[0][0]= 0.0; vertices[0][1]= 0.0; vertices[0][2]= 0.0;"]},{"entry":[{},"vertices[1][0]= 1.0; vertices[1][1]= 0.0; vertices[1][2]= 0.0;"]},{"entry":[{},"vertices[2][0]= 1.0; vertices[2][1]= 1.0; vertices[2][2]= 0.0;"]},{"entry":[{},"vertices[3][0]= 0.0; vertices[3][1]= 1.0; vertices[3][2]= 0.0;"]},{"entry":[{},"vertices[4][0]= 0.0; vertices[4][1]= 0.0; vertices[4][2]= 1.0;"]},{"entry":[{},"vertices[5][0]= 1.0; vertices[5][1]= 0.0; vertices[5][2]= 1.0;"]},{"entry":[{},"vertices[6][0]= 1.0; vertices[6][1]= 1.0; vertices[6][2]= 1.0;"]},{"entry":[{},"vertices[7][0]= 0.0; vertices[7][1]= 1.0; vertices[7][2]= 1.0;"]},{"entry":[{},"polyhedron = new vhtVertexGeometry( );"]},{"entry":[{},"polyhedron->setVertices(vertices, 8);"]},{"entry":[{},"object= new vhtShape3D(polyhedron);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"To create the same cube, but this time using elementary shapes, you only need to specify the right geometry:",{"@attributes":{"id":"p-0094","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"vhtVertexBox \u2003\u2003\u2003*box;"]},{"entry":[{},"vhtShape3D *object;"]},{"entry":[{},"box= new vhtVertexBox(1.0, 1.0, 1.0);"]},{"entry":[{},"object= new vhtShape3D(box);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Note that this procedure actually creates a geometry template for the collision engine your application will use. This will be discussed further in the section on collisions.","Using a NodeParser","Most applications will import scene graphs from data sets obtained elsewhere, rather than creating them from scratch. The VHT is equipped with a well-defined mechanism for handling such imports. The vhtNodeParser is an extensible class that defines the generic steps required to scan a graph of visual geometries and to reproduce an equivalent haptic scene graph.","The VHT also includes a parser that can import the popular CosmoCode scene graph (i.e. VRML). To transform a VRML scene graph into an haptic scene graph managed by the VHT, you need to first load the VRML file using Cosmo, create an instance of the vhtCosmoParser, and finally use the vhtEngine::registerVisualGraph method to take care of the transposal of the CosmoCode scene into the VHT environment. The following code does this for a VRML model of an airplane:",{"@attributes":{"id":"p-0098","num":"0109"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"vhtCosmoParser cParser;"},{"entry":"opGenLoader *loader;"},{"entry":"csGroup *cosmoScene;"},{"entry":"vhtDataNode *neutralNode;"},{"entry":"loader = new opGenLoader(false, NULL, false);"},{"entry":"cosmoScene= (csGroup *)loader->load(\u201cairplane\u201d);"},{"entry":"theEngine->registerVisualGraph(cosmoScene, &cParser, neutralNode);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"To import other kinds of scene graphs (e.g., 3D Studio Max\u2192, SoftImage\u2192), you will have to create a subclass of the vhtNodeParser that knows how to handle the details of a scene file. This procedure is explained in detail in the chapter on model import.","Adding Simulation Logic","The scope of the VHT does not cover the actual simulation of digital objects. The developer is responsible for creating his or her own digital environment. The role of the VHT is to make it easy to \u201chand enable\u201d such simulations. However, the VHT does provide an expansion path which aims to aid the user with the implementation of simulation logic.","First of all, the VHT is equipped with a powerful collision detection engine (vhtCollisionEngine). Managed by the vhtEngine, this collision engine monitors the haptic scene graph and the virtual human hand, and detects any interpenetration between two given objects. Secondly, the vhtSimulation class is a stencil for providing logic to virtual objects. Finally, the exchange of information between virtual objects, visual representations and haptic states is organized by the data-neutral scene graph of the vhtEngine.","Subclassing vhtSimulation","For simple applications, the simulation logic is implemented by the method handleConstraints of a vhtSimulation subclass. This method is called by the vhtEngine after all attached devices have been updated, to analyse the current situation and take care of interaction between the objects.","As an example, we will create the simulation logic for a cube that spins on itself. It will be provided by the class UserSimulation, which has the following declaration:",{"@attributes":{"id":"p-0104","num":"0115"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#include <vhandtk\/vhtSimulation.h>"]},{"entry":[{},"class UserSimulation : public vhtSimulation"]},{"entry":[{},"{"]},{"entry":[{},"\u2003protected:"]},{"entry":[{},"\u2003\u2003SimHand *demoCentral;"]},{"entry":[{},"\u2003public:"]},{"entry":[{},"\u2003\u2003UserSimulation(SimHand *aDemo);"]},{"entry":[{},"\u2003\u2003virtual void handleConstraints(void);"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"For the purpose of the example, it is assumed that the SimHand class has a the getCube method that provides a vhtTransformGroup instance containing the cubic shape. The implementation of handleConstraints is then only doing a one degree rotation of the cube transform:",{"@attributes":{"id":"p-0106","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"UserSimulation::UserSimulation(SimHand *aDemo)"},{"entry":"\u2003: vhtSimulation( )"},{"entry":"{"},{"entry":"\u2003\u2003\u2003\/\/ Record the root of all the information."},{"entry":"\u2003\u2003\u2003demoCentral= aDemo;"},{"entry":"\u2003\u2003\u2003setHapticSceneGraph(aDemo->getSceneRoot( ));"},{"entry":"}"},{"entry":"void UserSimulation::handleConstraints(void)"},{"entry":"{"},{"entry":"\u2003\u2003\/\/ Refresh all transforms"},{"entry":"\u2003aDemo->getSceneRoot( )->refresh( );"},{"entry":"\u2003\/\/ Rotate the cube about local X axis."},{"entry":"\u2003vhtTransform3D xform = demoCentral->getCube( )->getTransform( );"},{"entry":"\u2003xform.rotX(M_PI\/360.0);"},{"entry":"\u2003demoCentral->getCube( )->setTransform(xform);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"To use the custom simulation, the vhtEngine would use the following lines during setup phase (rather than the one shown in the section Creating a Simulation Framework):\n\n","A substantial requirement of any interactive simulation is to recreate physical presence and to give virtual objects the ability to be more than mere graphical shapes. The goal is to have them move in digital space and react to the collisions that may occur. The collision detection engine is normally used by a subclass of vhtSimulation to detect these situations and then act upon them (during the handleConstraints phase). The following is only a brief overview of the collision detection capabilities of the VHT, and you should refer to the collision detection example in Chapter 8 to learn how to use it effectively.","The Collision Detection Engine","As you would expect, the class vhtCollisionEngine implements collision detection. A single instance needs to be created and used by the vhtSimulation instance. The simulation has very little work to do to get the vhtCollisionEngine up to speed. It simply needs to register the haptic scene graph with the vhtCollisionEngine instance, using the vhtCollisionEngine::setHapticSceneGraph method. After this, it can get the current collision status between objects by retrieving the collision list, as illustrated in the following section.","The Collision List","At any given moment during the simulation, the set of objects that are colliding is available through the vhtCollisionEngine::getCollisionList. This method returns a vhtArray instance, which is filled with vhtCollisionPair objects that represent collisions. The simulation logic can use this list in the following fashion:",{"@attributes":{"id":"p-0111","num":"0125"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"vhtArray *collisionList;"]},{"entry":[{},"vhtCollisionPair *currentPair;"]},{"entry":[{},"unsigned int i, nbrCollisions;"]},{"entry":[{},"collisionList = ourCollisionEngine->collisionCheck( );"]},{"entry":[{},"nbrCollisions= collisionList->getNumEntries( );"]},{"entry":[{},"for (i= 0; i < nbrCollisions; i++) {"]},{"entry":[{},"\u2003\u2003currentPair= (vhtCollisionPair *)collisionList->getEntry(i);"]},{"entry":[{},"\u2003\u2003...custom reactions to the collision..."]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"We assume in this code that an object of type vhtCollisionEngine has already been created and is referenced by the pointer ourCollisionEngine.","Updating the State of Objects","When programming a 3D simulation, a good portion of the work will involve updating the state of the virtual objects so that they behave in the desired manner. This includes behavioral updates as well as collision-response updates. The combination of these updates will lead to a desired graphical update. The changes that occur in the graph are very much dependant on the nature of the nodes. The following lines demonstrate a common situation where a vhtTransformGroup node is modified so that the underlying subgraph it contains is repositioned in space:\n\n","The previous sections have dealt with the more invisible parts of an application. We have now reached the point where it's time to actually start seeing the result of all those computations that take effect in the application. As for the simulation logic, the scope of the VHT doesn't cover 3D rendering. However, since it is such an important operation, the VHT does provide an expansion path for making it easy to draw virtual objects.","Refreshing from the Data Neutral Graph","During the execution of an application, the VHT will detect collisions and work in concert with the simulation logic to react to them, normally by at least displacing objects. For example, you can picture the haptic action of pushing a cube using the hand. This section describes how the information is transferred from the haptic scene graph into the visual scene graph, so that visual geometries move appropriately.","Yet another graph, the data neutral graph, will provide the glue between the two scene graphs. Typically, the data neutral graph is created as objects are imported and transferred into the haptic scene graph, as mentioned in the section Using a NodeParser. The data neutral scene graph mechanism is explained in Chapter 5.","The VHT holds any independent collidable object as a vhtComponent node of the haptic scene graph. In the simple case, the visual update is a simple matter of transferring the transformation matrices from the vhtComponent nodes into the equivalent nodes of the visual scene graph. This is valid if the visual objects don't have non-collidable mobile sub-elements (for example, a car which doesn't have spinning wheels).","The VHT facilitates that operation by keeping an optimized list of data neutral nodes which link the matching vhtComponent and visual instances. That list is accessed with the vhtEngine::getComponentUpdaters. The list is made of instances of vhtNodeHolder, which are simply convenient place holders for data neutral nodes. The method vhtNodeHolder::getData returns the actual data neutral node.","In the following code segment, the first element of the list of data neutral nodes associated with vhtComponents is queried. Then, a loop iterates through the elements of the list. At each iteration, it extracts the CosmoCode node and its vhtComponent equivalent (if any), and copies the transformation of the vhtComponent into the CosmoCode node's matrix, using the correct ordering of matrix elements. Note that this example is based on a utilization of the vhtCosmoParser class, which always create a map between vhtComponent and csTransform instances. For this reason, no class checking is implemented in the loop, but in general such a blind operation would be error-prone.",{"@attributes":{"id":"p-0120","num":"0140"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"csMatrix4f fastXform;"},{"entry":"vhtNodeHolder *updateCursor;"},{"entry":"vhtCosmoNode *mapNode;"},{"entry":"vhtComponent *xformGroup;"},{"entry":"updateCursor= globalEngine->getComponentUpdaters( );"},{"entry":"while (updateCursor != NULL) {"},{"entry":"\u2003\u2003mapNode= (vhtCosmoNode *)updateCursor->getData( );"},{"entry":"\u2003\u2003if ((xformGroup= (vhtComponent *)mapNode->getHaptic( )) !="},{"entry":"\u2003\u2003NULL) {"},{"entry":"\u2003\u2003\u2003csTransform *transformNode;"},{"entry":"\u2003\u2003\u2003vhtTransform3D *xform;"},{"entry":"\u2003\u2003\u2003double scaling, matrix[4][4];"},{"entry":"\u2003\u2003\u2003unsigned int i;"},{"entry":"\u2003\u2003\u2003if ((transformNode= (csTransform *)mapNode->getCosmo( )) !="},{"entry":"\u2003\u2003\u2003NULL) {"},{"entry":"\u2003\u2003\u2003\u2003xform= xformGroup->getLM( );"},{"entry":"\u2003\u2003\u2003\u2003xform.getTransform(matrix);"},{"entry":"\u2003\u2003\u2003\u2003fastXform.setCol(0, matrix[0][0], matrix[0][1], matrix[0][2],"},{"entry":"\u2003\u2003\u2003\u2003matrix[0][3] );"},{"entry":"\u2003\u2003\u2003\u2003fastXform.setCol(1, matrix[1][0], matrix[1][1], matrix[1][2],"},{"entry":"\u2003\u2003\u2003\u2003matrix[1][3] );"},{"entry":"\u2003\u2003\u2003\u2003fastXform.setCol(2, matrix[2][0], matrix[2][1], matrix[2][2],"},{"entry":"\u2003\u2003\u2003\u2003matrix[2][3] );"},{"entry":"\u2003\u2003\u2003\u2003fastXform.setCol(3, matrix[3][0], matrix[3][1], matrix[3][2],"},{"entry":"\u2003\u2003\u2003\u2003matrix[3][3]);"},{"entry":"\u2003\u2003\u2003\u2003transformNode->setMatrix(fastXform);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003updateCursor= updateCursor->getNext( );"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The VHT device layer is included with all VTi hardware products. It contains a set of classes to facilitate access to input devices. These devices include CyberGlove, CyberTouch and CyberGrasp, as well as Polhemus and Ascension 6-DOF trackers. Since all direct hardware interaction is done by the Device Manager, instances of these classes provide a proxy representation of hardware devices. The proxy mode is distributed, so hardware may even be at remote locations and accessed via a TCP\/IP network.","Addressing a Device's Proxy","The class vhtlOConn describes a single device connection. Each instance of the class vhtlOConn defines the address for specific piece of hardware. Thus an application that uses both glove and tracker data will define two instances of vhtlOConn, one that describes the glove and one that describes the tracker.","Most applications will build vhtlOConn objects by referring to predefined entries in the device registry, which is maintained by the DCU (see the VHS User's Guide for more details about the DCU). To access a default device defined in the registry, the application code will use the vhtlOConn::getDefault method. For example, the statement to get the glove proxy address using the registry defaults is:\n\n","In and of itself, a vhtlOConn object does not actually create the proxy connection to the Device Manager. To do so, the particular device's proxy must be created using one of the Device classes.","Scene Graphs","To deal with geometrical information in a formal way, the VHT uses scene graphs that contain high-level descriptions of geometries. Scene graphs are widely used in computer graphics applications for representing geometric relationships between all the components in a scene. Popular examples of scene-graph-based API's include OpenInventor, Performer, OpenGL Optimizer and VRML97. Readers unfamiliar with scene graphs are encouraged to read texts covering some of the API's mentioned above.","Note that the VHT scene graphs are primarily oriented toward haptic and dynamic operations, rather than graphic rendering.","The information necessary to build a good representation of a virtual environment is quite complex, and requires a special flexibility in terms of geometrical and visual data management. Because of that, the VHT does not rely on a single scene graph to manage the virtual environment. Instead, it relies on a mapping, mechanism to link haptic and visual information while giving a maximum flexibility for developers to use the most appropriate scene description within their applications. This section discuss the Haptic Scene Graph and the Data Neutral Scene Graph of the VHT. The VHT scene graphs are also designed to release developers from constraining their own data structures in order to accommodate the VHT.","Haptic Scene Graph","The haptic scene graph is an organizational data structure used to store virtual environment information such as geometry, coordinate transformations and grouping properties, for the purpose of collision detection, haptic feedback and simulation. Each object in a scene, often referred to as a node, can be viewed as the composition of a number of geometric entities positioned in space according to a coordinate frame local to the object. In turn, each object has a coordinate transformation from the global frame that defines the basis of its local coordinate frame. The haptic scene graph includes facilities to transform positions expressed in a local coordinate frame to a global one, and for the exhaustive parsing of all elements in a formal order.","Finally, it should be noted that from a theoretical standpoint, the VHT haptic scene graph is a directed tree without cycles, rather than a general graph. This limitation might be removed in the future.","Fundamental Haptic Scene Graph Classes","From the above discussion, you can see that any useful scene graph will generally contain at least two types of nodes, namely transformation grouping nodes and geometric nodes. By organizing these two types of nodes into a tree-like data structure, we obtain a hierarchy of geometric transformations applied on atomic geometrical shapes. In the VHT, the vhtTransformGroup and vhtShape3D classes provide the basic set of scene graph nodes. The haptic scene graph can be constructed by inserting nodes one by one from method calls, or by using a model parser like the vhtCosmoParser.","A vhtTransformGroup instance is constructed either with a default transformation, or by passing a homogeneous transformation matrix into the constructor. In the VHT, homogeneous transformations are stored in vhtTransform3D instances. A vhtTransform3D object represents a three-dimensional coordinate transformation, including both arbitrary rotation and translation components.","Transformation instances contain two variables that each hold a type of homogeneous transformations. First, the variable vhtTransformGroup::LM (local matrix) contains a transformation from the local coordinate frame to the global frame (world). The global frame is defined as the frame at the root of the scene graph. Secondly, the variable vhtTransformGroup::transform contains a transformation from the local frame to the frame of the parent node. LM transformations are obtained by just pre-multiplying (i.e. right multiplication) all transforms found along a direct path from the root node to the transform group. The instance variables are accessed through the methods setLM\/getLM and setTransform\/getTransform respectively.","To create hierarchies of nodes, we need to be able to define the relationships between the nodes. This is accomplished with the help of the addChild(vhtNode*nPtr) method of the vhtTransformGroup class. To build a simple hierarchy with two levels, one of which is translated 10 units along the x axis, we could write:",{"@attributes":{"id":"p-0134","num":"0157"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"vhtTransformGroup *root= new vhtTransformGroup( );"]},{"entry":[{},"\u2003\/\/ Define that node as the root node of the haptic graph."]},{"entry":[{},"root->setRoot( );"]},{"entry":[{},"vhtTransform3D xform(10.0, 0.0, 0.0);"]},{"entry":[{},"vhtTransformGroup *newFrame= new vhtTransformGroup(xform);"]},{"entry":[{},"root->addChild(newFrame);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"A haptic scene graph is permitted to have only one node defined as the root node. The root node is defined by calling the setRoot method on the chosen instance. Note that the root property is a singleton setting in the sense that each user application may have only one root node.","The haptic scene graph becomes interesting when it is populated with actual geometric objects. This is accomplished by adding nodes of the vhtShape3D class. A vhtShape3D instance is actually a geometry container, which is used to store different types of geometry. To better accommodate geometries expressed as NURBS, polygons, implicit definitions and so on, the vhtShape3D contains an instance variable that points to the actual geometric information. This allows users to define new geometries specific to their needs by class inheritance while still retaining all the benefits of the haptic scene graph.","As an example, consider making a cube with unit dimensions. The VHT provides a geometric convenience class called vhtVertexBox for making box-like objects. This class is one of a few elementary primitive shapes of the VHT available to the developer. Other shapes include:\n\n","To build a box shape, we must set the geometry of a vhtShape3D object to our newly-created box. The code for this is:",{"@attributes":{"id":"p-0139","num":"0165"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["vhtVertexBox *box = new vhtVertexBox( );","\/\/ Default size is 1X1X1."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"vhtShape3D *boxShape = new vhtShape3D(box);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{},"ul":{"@attributes":{"id":"ul0017","list-style":"none"},"li":["vhtVertexSphere*sphere=new vhtVertexSphere( );","vhtShape3D*sphereShape=new vhtShape3D(sphere);"]}},"The VHT currently includes pre-defined classes only for convex vertex-based geometries. However, users are free to extend the geometry classes to suit their need. Once a vhtShape3D object has been created, it can be added as a child to a vhtTransformGroup node (a vhtShape3D can be the child of only one grouping node a the time). Thus to translate our unit cube 10 units in the x direction, we could reuse the vhtTransformGroup variable introduced in the previous code example as such:\n\n",{"@attributes":{"id":"p-0141","num":"0170"},"figref":"FIG. 5"},"The children of a grouping node are kept in an ordered list, which can be queried with the getChild method.","As a closing note to this section, it should be noted that every type of node class of the VHT haptic scene graph is equipped with a render method. By invoking this method, you get a visual representation of the node sent into the current OpenGL context. For vhtShape3D nodes, the render method simply calls the render method of the first vhtGeometry that has been set. Since the VHT by default only includes support for vertex based geometries, this method will render a point cloud for each vhtShape3D. The geometry rendered can be manipulated by defining an appropriate vhtCollisionFactory framework. Note that if a user application uses the VClip interface, the rendered geometry will contain face information (i.e. solid shaded geometries).","For vhtTransformGroup objects, the render method will apply coordinate frame modifications to the GL_MODELVIEW stack. In addition, the render method will recursively call apply the render method to all children node contained in the grouping nodes. Thus for a haptic scene graph with a well-defined root, the application only needs to do the following to get a visual representation of the current haptic scene graph:\n\n","In the previous section, the scene graph was not being modified after it has been constructed. But most user applications will require that objects in the virtual environment move in some manner. Since we have access to the transform of a vhtTransform3D node, it is fairly clear that we can just modify the coordinate frame of each geometry directly. Using the above code samples, we could add the following line to create motion:\n\n","That statement displaces the cube from its original position (10,0,0) to the point (11,0,0). If we do this in a loop that draws the haptic scene graph, once per frame, the cube will seem to move along the x-axis at a fairly high rate of speed. However, there is one detail that prevents this from working properly. The render method of all haptic scene graph nodes uses the node's LM matrix for OpenGL, which have to be synchronized with the changes caused to a node. In order to keep the transform and the LM in synch, it is necessary to call the refresh method. Refresh is a recursive method that works on all nodes in a subgraph so it needs only be called on the root node. Primarily, refresh will ensure that all LM's and transform matrices agree with each other. Thus we need to add one more statement to the previous one:\n\n","The reader may be somewhat confused at this point about what exactly a haptic scene graph should be used for. In the above discussion, it was shown how to construct a simple scene graph, how to render one and finally how to manipulate one in real time. From the point of view of the VHT, a haptic scene graph is primarily a collision data structure that describes the current state (position, orientation, geometry) of the shapes that constitute a scene.","In a typical user application, the haptic scene graph will be generated by some import mechanism (see Chapter 10), or some other algorithmic technique. Once this is done, a collision engine object will run over the scene graph and generate collision geometry for each vhtShape3D. Once this is done, the vhtSimulation component of the application will execute an update loop on the haptic scene, and the collision engine in tandem.","Seen from this point of view, the render method demonstrated above is primarily for debugging complex scenes in which the collision geometry needs to be rendered. We defer a detailed discussion of this framework to Chapter 8.","Haptic Scene Graphs\u2014More Details","This section discusses some of the more advanced features of the haptic scene graph classes: generic grouping nodes, vhtComponent nodes and the human hand scene graph.","The vhtTransformGroup previously introduced is one type of grouping node offered by the VHT. The parent class of vhtTransformGroup is vhtGroup, which is also the superclass of all other grouping nodes. It provides generic child management methods such as numChildren, setChild and detachChild.","The method numChildren returns the number of immediate children that are in the group on which it was called (children of children are not taken in account). In the above sample code, the root node has one child. When a specific haptic scene graph layout is required and its position in the children list is known, the setChild method can be used to specify the child index for a new addition. This can be used instead of the addChild method. Note that the VHT does not impose any limitation on the way user applications can order children in a grouping node. In particular, it is possible to have a single child with an index of 10. This would mean that the first 9 children of the group would be empty slots (NULL pointers). In this case, a child that is added afterward with the addChild method will get the index value of 11.","Finally vhtGroup::detachChild is used to remove a child from the scene graph. It takes either a child index or a child object pointer as its argument, and cause the specified child to be removed from the scene graph. The nodes are not deleted, but the connection to the haptic scene graph is broken. This can be used to move subgraphs from one location to another in the scene graph.","The vhtSwitch node is a grouping node that has an \u201cactive child\u201d property. During a haptic scene graph traversal, only the active child (if any) is used. This is useful for scene operations like varying level-of-detail, where a group node will have several versions of the same subgraph in varying resolutions. Depending on the user viewpoint, the best subgraph is chosen. This behavior is accessible through the methods currentChild and setWhichChild. The first method returns a vhtNode instance, which is the head of the active subgraph. The second takes a single integer argument that is the index of the desired active vhtNode.","The vhtComponent is yet another type of grouping node. It is intended as a convenient reference node for rigid objects composed of several vhtShape3D nodes. Most geometric modelling software builds geometries using some primitives that can be added together. The VHT supports this type of construction through the vhtComponent node. All children of a vhtComponent instance have fast pointers to the component. The pointers are accessed by using the getComponent method of the vhtNode class. The convenience of this type of object is in aggregate processing such as collision detection and hand-grasping algorithms.","The vhtComponent importance is shown in the light of collision detection. For now, note that by default, only vhtShape3D nodes that have different vhtComponent parents can be collided. For the moment, consider a simple example of constructing a geometry that resembles a barbell. It can be thought of as composed of three cylinders, a long thin one representing the bar and two short thick ones for the weights. By using the center of the bar as the local coordinate system, all three shapes can be vhtShape3D nodes (and their associated geometry). Now in an application the barbell might be spinning and flying (as barbells often do). By making the entire barbell nodes a subgraph of a vhtComponent instance, we need only update the transform of the component and refresh. The haptic scene graph will automatically treat all the children of the component as a rigid body and optimize the refresh action.","Data Neutral Scene Graph","The VHT's haptic scene graph is oriented toward other tasks than graphic rendering. Examples of the previous section have demonstrated the haptic scene graph features by eventually drawing its content; yet this was mostly done for the sake of pedagogy. In a user application, the rendering is most likely to use a different approach, oriented toward visual quality and the use of some drawing package. This is why the VHT provides an additional type of scene graph, called the Data Neutral Scene Graph.","The Data Neutral Scene Graph acts as a mapping mechanism between the Haptic Scene Graph and other information, typically a visual description of the scene on which the application works. Thus an application using the VHT is expected to contain in general three scene graphs: the visual graph, the haptic graph, and the data neutral graph that will map associated nodes from first two graphs.","The primary class used in the Data Neutral Scene Graph is vhtDataNode. It provides the basic graph management methods, and it can point to an associated node that belongs to the Haptic Scene Graph. Conversely, a node in the Haptic Scene Graph that has been associated by a vhtDataNode will point back to that instance, thus providing a mapping to some external information. The Data Neutral Scene Graph is a stencil for developing customized versions according to an application requirements.","The support for the CosmoCode rendering library is implemented in this very fashion. The VHT derives the vhtDataNode into a vhtCosmoNode class by supplying a placeholder for csNode instances. As the CosmoCode import filter provided by the class vhtCosmoParser traverses a CosmoCode scene graph, it creates instances of vhtCosmoNode, and links them with the corresponding dual instances of csNode and vhtNode. The vhtCosmoParser shows the simplicity of expanding the VHT to communicate with an external scene graph.","The VHT also provides a CosmoCode tree parser (vhtCosmoParser class), which traverses CosmoCode scene graph, created from VRML files. This parser descends the CosmoCode tree, creates a haptic node for each appropriate csNode, and finally creates instances of vhtCosmoNode that act as a bidirectional maps between the visual and haptic nodes. So for an application that imports and draws VRML files using CosmoCode, three scene graphs would be used: the CosmoCode scene graph for rendering, the haptic scene graph, for collision detection and force feedback, and finally the data neutral nodes to exchange modifications such as movements to either the visual or the haptic scenes.","The main features of the vhtDataNode are the getParent and getChildren methods, which return both a vhtDataNode instance. The children of a vhtDataNode are organized as a linked list, rather then an ordered list as in the haptic scene graph grouping nodes. This linked-list is browsed by using the getNext\/getPrevious methods. Finally, the haptic node (a vhtNode object) associated with a data neutral node is defined and accessed with the setHaptic\/getHaptic methods. All other functionality is subclass dependant.","In an application that makes use of the multi-threaded abilities of the VHT and links with an external scene graph or some other data structure, synchronous data integrity must be maintained explicitly. The VHT provides a locking mechanism that works in conjunction with the vhtSimulation class discussed below. This is accomplished by calling vhtNode::sceneGraphLock and then calling vhtNode::sceneGraphUnlock to unlock the graph. These calls are fairly expensive in terms of performance and data latency so locking should be centralized in user application code and used as sparingly as possible.","As an example of a situation where locking is required, consider a CosmoCode scene graph that is connected via a data neutral scene graph to a haptic scene graph. The haptic scene graph is updated by some vhtSimulation method that the user code has inherited. Once per graphic rendering frame, the LM matrices corresponding to all vhtComponent classes in the haptic scene graph need to update their corresponding nodes in the CosmoCode scene graph so that the visual matches the haptic. During this process, the vhtSimulation instance must be paused or blocked from updating the component nodes while they are being read or else the visual scene graph might display two superimposed haptic frames. In pseudo-code, this would be accomplished as following:",{"@attributes":{"id":"p-0165","num":"0197"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void graphicalRender(void)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\u2003.. .pre-processing ..."]},{"entry":[{},"\u2003\u2003hapticRootNode->sceneGraphLock( );"]},{"entry":[{},"\u2003\u2003\u2003... copy component LM matricies to CosmoCode ..."]},{"entry":[{},"\u2003\u2003hapticRootNode->sceneGraphUnlock( );"]},{"entry":[{},"\u2003\u2003\u2003... post-processing ..."]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"This section is devoted to the vhtHumanHand class and its uses. In the previous sections, we have mentioned the vhtHumanHand class in a number of places. This class is one of the largest and most complex in the VHT, providing integrated support for a CyberGlove, a tracker and a CyberGrasp. The human hand class manages all data updates, kinematic calculations, graphical updates and it can draw itself in any OpenGL context.","Human Hand Constructors","By having a vhtHumanHand instance in an user application, the CyberGlove and other device functionality is available for little or no work. The vhtHumanHand class has a large set of constructors. This variety is provided to allow maximum flexibility for user applications. The constructor arguments are all used to specify device objects that the vhtHumanHand object will use to get data from and to send data to.","The default constructor is defined as:",{"@attributes":{"id":"p-0168","num":"0000"},"ul":{"@attributes":{"id":"ul0022","list-style":"none"},"li":"vhtHumanHand::vhtHumanHand(GHM::Handedness h=GHM::rightHand);"}},"This instantiates an unconnected hand object that has the indicated handedness. By default, the handedness is right; a left handedness is obtained by providing the GHM::leftHand parameter to the constructor.","For users that have a CyberGlove and an associated 6 DOF tracking device, the following set of constructors will be more useful,",{"@attributes":{"id":"p-0170","num":"0202"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"vhtHumanHand(vhtGlove *aGlove, vhtTracker *aTracker,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003GHM::Handedness h="]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003GHM::rightHand);"]},{"entry":[{},"vhtHumanHand(vhtHandMaster *aMaster, GHM::Handedness h="]},{"entry":[{},"GHM::rightHand);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The first constructor instantiates a human hand with the provided glove and tracker objects. These device objects should be connected to their respective hardware before being used in this constructor. It is possible to use glove or tracker emulators in place of an actual device's proxy. The second constructor uses the vhtHandMaster object, which is simply a storage mechanism for a glove and tracker pair.","For users that also have a CyberGrasp system, the following pair of constructors will be used:",{"@attributes":{"id":"p-0172","num":"0204"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["vhtHumanHand(vhtGlove *aGlove, vhtTracker *aTracker,",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003vhtCyberGrasp *aGrasp, GHM::Handedness","h="]},{"entry":"GHM::rightHand);"},{"entry":"vhtHumanHand(vhtHandMaster *aMaster, vhtCyberGrasp *aGrasp,"},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003GHM::Handedness","h="]},{"entry":"GHM::rightHand);"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"These two constructors are only different to the two previous constructors by the addition of a vhtCyberGrasp parameter.","Hand Device Management","Once the application has instantiated a vhtHumanHand, the supplied device's proxies will be controlled and updated as required by the instance. At any time, the user application can extract the device's proxies in use by the vhtHumanHand. by invoking the methods getHandMaster and getCyberGrasp. The vhtHumanHand also contains an update method, which will refresh the proxies states with the latest hardware values for all attached devices (by calling their respective update methods).","All connected hardware devices managed by the vhtHumanHand may be disconnected with the disconnect method. This method calls the associated disconnect methods of each attached device.","Hand Kinematics","The human hand class includes a complete kinematic model of a human hand (right or left hand). This model provides a mapping from the glove and tracker data into a hierarchy of homogeneous transformations representing the kinematic chain of each finger.","The hand kinematics are automatically updated when the vhtHumanHand::update method is called. The kinematics calculation unit may be accessed with a call to vhtHumanHand::getKinematics, which returns the vhtKinematics used by the hand.","The vhtKinematics class provides a number of important methods for users who wish to integrate hands into their own applications. Many users will want to extract the position and orientation of each finger element. This can be accomplished with the vhtKinematics::getKinematics method. This method takes a finger and joint specifier (from the GHM) and returns the current vhtTransform3D object, as a reference.","Hand Scene Graph","The vhtHumanHand class has an internal representation of a hand as a haptic scene graph. This scene graph can be manipulated just like any other haptic scene graph (see Chapter 5). Access to the root node of this scene graph is provided by the getHapticRoot method. This method returns a pointer to a vhtGroup instance, whose children represent the chains of finger segments and the palm.","The hand haptic scene graph will need periodic calls to refresh its internal subgraph to keep it in synch with the application global haptic scene graph. These calls are performed automatically when then vhtHumanHand is registered with the vhtEngine. In order for this to take place, each hand must be registered with the active engine object using the vhtEngine::registerHand method. Hand registration also takes care of adding the hand scene graph to the current haptic scene graph root node, as a child.","The hand haptic scene graph is organized into six subgraphs, one for each finger starting with the thumb and one for the palm. Each finger is stored in an extension of the vhtGroup class, called vhtHumanFinger. Instances of this class contain pointers to each of the three phalanges, the metacarpal, the proximal and the distal. An individual phalanx may be accessed via the method vhtHumanFinger::getPhalanx.","The vhtPhalanx class is derived from the vhtTransformGroup class. Each phalanx has a child that is a vhtShape3D and which contains the geometry representing that phalanx. Note that the geometry stored in the phalanx class is not the geometry that is drawn on the screen, but rather an optimized geometry used for collision detection in the VHT.","Both the finger and phalanx classes provide pointers back to the vhtHumanHand class that contains them. This can be very useful in collision detection, when only the vhtShape3D is returned from the collision engine. Chapter 8: Collision Detection, gives an example that uses this access technique.","Visual Hand Geometry","The vhtHumanHand class is equipped with a visual geometry that can draw itself in an OpenGL context. The visual geometry is accessible through getVisualGeometry and setVisualGeometry access methods, which return and set a vhtHandGeometry instance.","Once the user has an active OpenGL context and an active vhtHumanHand class it is very simple to draw the current hand configuration. The first step is to allocate a vhtOglDrawer object. This object knows how to traverse and draw the vhtHandGeometry class. During the rendering loop, the method vhtOglDrawer::renderHand should be called to draw the current hand configuration. The first argument to this method is the current camera transformation, as represented by a vhtTransform3D object, and the second argument is the hand to be drawn. An example to accomplish this is:",{"@attributes":{"id":"p-0186","num":"0218"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void init( )"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003... some init code ..."]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003drawer = new vhtOglDrawer( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003cameraXForm= new vhtTransform3D( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003... some more init code ..."]},{"entry":[{},"}"]},{"entry":[{},"void renderCallback(void)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003... some render code ..."]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003drawer->renderHand( cameraXForm, hand );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003... some more render code ..."]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"This section introduces the VHT's support for the CyberGrasp force feedback device.","If the CyberGrasp is used by an application to \u2018feel\u2019 virtual objects, the use of the impedance mode will achieve the best performance. This mode runs a control law on the Force Control Unit (FCU) at 1000 Hz to control the force feedback. In this mode, the VHT uses objects of type vhtContactPatch to supply the dedicated hardware unit with predictive information about the physical environment simulated by the application.","A vhtContactPatch instance represents a tangent plane approximation to the surface of the virtual object which is touched by a particular finger. Contact patches can be constructed in a variety of ways, depending on the user application.","When the vhtHumanHand::update method is invoked, a query is done for each finger in the haptic graph to determine if a contact patch has been set. If there are any fresh patches, they are sent over to the controller. Although each finger has 3 phalanges, and each phalanx allows a separate contact patch, the CyberGrasp device has only one degree of freedom per finger. For this reason, the \u2018best\u2019 patch is chosen for each finger as the closest patch to the distal joint. For example, if two patches are set on the index finger, one for the metacarpal and one for the distal, only the distal patch will be sent to the controller.","After each call to vhtHumanHand::update, the patches on all phalanx are reset. In order to continue to \u2018feel\u2019 an object, a new set of patches will have to be set before the next call to the update method.","Grasping Virtual Objects","Once an application has constructed a vhtHumanHand object, a scene graph and a collision mechanism, the VHT provides a mechanism for allowing vhtComponent objects to attach themselves to the virtual hand. This procedure is more commonly known as \u2018grasping\u2019.","Each vhtComponent has a method getGraspManager that returns an object of type vhtGraspStateManager. The grasp state manager encapsulates an algorithm for allowing scene components to be automatically \u2018picked up\u2019 by a virtual hand. The basic idea is that when a virtual hand collides with a vhtComponent graph, each hand part (phalanx, palm) generates some collision information, including the surface normal at the collision point. If these contact normals provide sufficient friction, the component will be attached to the hand.","Although the algorithm is somewhat complex, in practice, using this feature is very simple. The included demo simgrasping illustrates the procedure. We include the relevant handleConstraints method from the demo here:",{"@attributes":{"id":"p-0195","num":"0227"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"void UserSimulation::handleConstraints(void)"},{"entry":"{"},{"entry":"\u2003\/\/ This method will look at all ongoing collisions, sort the collisions"},{"entry":"\u2003\/\/ that occur between fingers and other objects, and generate patches for"},{"entry":"\u2003\/\/ the grasp to create the right forces at the user's fingers."},{"entry":"\u2003\/\/ Get the list of all collision pairs."},{"entry":"\u2003demoCentral->getSceneRoot( )->refresh( );"},{"entry":"\u2003\/\/ first constrain grasped objects"},{"entry":"\u2003demoCentral->getCube( )->getGraspManager( )->constrain( );"},{"entry":"\u2003\/\/ reset grasp state machine"},{"entry":"\u2003demoCentral->getCube( )->getGraspManager( )->reset( );"},{"entry":"\u2003vhtArray *pairList = collisionEngine->collisionCheck( );"},{"entry":"\u2003\u2003if ( pairList->getNumEntries( ) > 0 ) {"},{"entry":"\u2003\u2003\u2003vhtCollisionPair *pair;"},{"entry":"\u2002\u2003\u2003vhtShape3D *obj1;"},{"entry":"\u2003\u2003\u2003vhtShape3D *obj2;"},{"entry":"\u2003\u2003\u2003vhtShape3D *objectNode;"},{"entry":"\u2003\u2003\u2003vhtShape3D *handNode;"},{"entry":"\u2003\u2003\u2003vhtPhalanx *phalanx;"},{"entry":"\u2003\u2003\u2003vhtVector3d wpObj, wpHand;"},{"entry":"\u2003\u2003\u2003vhtVector3d normal;"},{"entry":"\u2003\u2003\u2003vhtTransform3D xform;"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/ Gor each collision,"},{"entry":"\u2003\u2003\u2003\/\/ \u20021) if it is hand-object we check for grasping,"},{"entry":"\u2003\u2003\u2003\/\/ \u20022) if it is obj-obj we add to assembly list."},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/ Loop over all collisions, handling each one."},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003for ( int i= 0; i < pairList->getNumEntries( ); i++ ) {"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Get a pair of colliding objects."},{"entry":"\u2003\u2003\u2003\u2003pair = (vhtCollisionPair *)pairList->getEntry( i );"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Get the colliding objects."},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003obj1 = pair->getObject1( );"},{"entry":"\u2003\u2003\u2003\u2003obj2 = pair->getObject2( );"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Look only for hand-object collisions."},{"entry":"\u2003\u2003\u2003\u2003int obj1Type = obj1->getPhysicalAttributes( )->getType( );"},{"entry":"\u2003\u2003\u2003\u2003int obj2Type = obj2->getPhysicalAttributes( )->getType( );"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\/\/ External (hand) object collision."},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003if ((obj1Type == vhtPhysicalAttributes::humanHand"},{"entry":"&& obj2Type == vhtPhysicalAttributes::dynamic)"},{"entry":"\u2003\u2003\u2003\u2003\u2003|| (obj1Type == vhtPhysicalAttributes::dynamic"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003&& obj2Type == vhtPhysicalAttributes::humanHand)) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/ For hand shapes, isDynamic( ) == false."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\u2003if ( obj1->getPhysicalAttributes( )->isDynamic( ) ) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003wpObj = pair->getWitness1( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003wpHand = pair->getWitness2( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003objectNode = obj1;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003handNode = obj2;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003normal = pair->getContactNormal1( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003else {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003wpObj = pair->getWitness2( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003wpHand = pair->getWitness1( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003objectNode = obj2;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003handNode = obj1;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003normal = pair->getContactNormal2( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003phalanx = (vhtPhalanx *)handNode->getParent( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\u2003\/\/ set object grasping, using fingertips (distal joints) only"},{"entry":"\u2003\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\u2003if( phalanx->getJointType( ) == GHM::distal ) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002if( pair->getLastMTD( ) < .2 ) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003objectNode->getComponent( )->getGraspManager( )->"},{"entry":"addPhalanxNormal( normal, phalanx );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"..."},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"There are three significant parts to this code segment. The second and third lines of code in this method call the vhtGraspStateManager::constrain( ) and vhtGraspStateManager::reset( ) methods respectively. The constrain method tells the state manager to enforce the current grasping state. This means that if the normal conditions are sufficient, the component will be fixed relative to the virtual hand. The second method resets the cached collision information in the state manager. The purpose of this is to allow components to be released from a grasped state. If there are no collision reports after a reset call, the next constrain call will result in the component being released.","After this, there is some code to extract the collision events for the current frame. It is important to see that we isolate all collisions between a hand and any other scene component. Once this is done, the last code segment sets the phalanx and normal for the current collision event with the vhtGraspStateManager::addPhalanxNormal( ) method. Calls to this method cache the normal and phalanx information to allow a call to constrain to determine if the component should be grasped.","An additional trick has been added is to make object grasping particularly easy, contact normals are set for all MTD's less that 0.2. This means that even if the fingers are not touching the object (they could be 2 mm away), the grasping algorithm is invoked. For more exact grasping, this threshold should be less than or equal to zero.","One-Fingered Grasping","In some situations, it is useful to allow components to be constrained to a single phalanx. The vhtGraspStateManager facilitates this with the setUseGraspOneState method. When this is enabled, any single point contact (from addPhalanxNormal) will result in the component being constrained to that hand part. It is the responsibility of the user application to release the component (via a reset call).","Ghost Hand Support","In a virtual environment, one of the most psychologically disturbing events is watching as a virtual hand passes right through a virtual object in the scene. The human brain rejects this type of event strongly enough that it reduces the suspension of disbelief most applications of this type are trying to achieve. For this reason, the VHT includes support for a ghost hand algorithm that attempts to prevent such interpenetrations.","The ghost hand algorithm works by trying to find a vector that can be added to the current tracker position that will place the hand outside of all objects in the scene. This algorithm also has a coherence property, in that the hand should move the minimum amount from the previous frame to achieve this non-penetration. Thus moving the virtual hand down through a virtual cube will result in the graphical hand remaining on top of the cube.","In the situation where the graphical hand has been constrained by the ghosting algorithm, a non-zero offset vector exists that is added to the tracker. Once the physical hand moves in a direction away from contact, the graphical hand will try to converge this offset vector to zero by a small increment each frame (this is controlled by the get\/setConvergenceRate method).","In practice, the ghost hand algorithm performs well; however it may be noted that the algorithm may generally degrade with decreasing haptic fame rate.","This functionality is encapsulated in a subclass of the vhtHumanHand called vhtGhostHumanHand. Objects of this class can be constructed exactly as a regular vhtHumanHand, and in fact behave in exactly the same way most of the time. However, there is one additional method, vhtGhostHumanHand::setContactPair( ). In practice, the user application simply needs to tell the ghost hand about all the collision pairs caused by hand-scene collisions. The update method will take care of the graphical constraint calculations.","Haptic Simulations","Applications that use the VHT for hand-based interaction or haptic scene graph simulation are most likely to have a similar program structure. In most cases, at the beginning of each frame, the most recent data is obtained from all external hardware devices, then the haptic scene graph is updated, and then user processing is performed based on the fresh data. The VHT source code segments presented in previous example have such structure. In each case, the user action is to render the scene or the hand. The VHT contains a formalized set of classes that encapsulate such a haptic simulation.","The front-end class for haptic simulation is vhtEngine. In an application, a single instance is used to register and to manage all hands in a scene, the scene graph, and allow for importing arbitrary scene graphs. The vhtEngine class also uses multi-threading to update all of its members without the intervention from the user application. User applications simply have to set any vhtHumanHand using the registerHand method (there is currently a limit of 4 hands that can be registered simultaneously). The scene graph to manage is set with the method setHapticSceneGraph. Once these two parameters have been defined, the engine can be started. For example:",{"@attributes":{"id":"p-0207","num":"0239"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"vhtHumanHand *hand= new vhtHumanHand(master);"]},{"entry":[{},"vhtGroup *root= buildUserSceneGraph( );"]},{"entry":[{},"vhtEngine *engine= new vhtEngine( );"]},{"entry":[{},"engine->setHapticSceneGraph(root);"]},{"entry":[{},"engine->registerHand(hand);"]},{"entry":[{},"\/\/ run the haptic thread"]},{"entry":[{},"engine->start( );"]},{"entry":[{},"... do other processing ..."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Invoking the start method spawns the multi-threaded management of the vhtEngine, which is also referred to as the haptic simulation. While a haptic simulation is running, any of the nodes in the scene graph can be queried or changed as well as any aspect of the registered hands. As mentioned in the previous section, due to the multi-threading nature of haptic simulations, all scene graph nodes should be locked during data reads and\/or writes.","The above framework enables user applications to easily query data from a running haptic simulation. This can be useful for graphical rendering or for telerobotic applications. However it may be necessary to have a smaller grain synchronization between the application and each update loop of the simulation. For this the VHT provides the vhtSimulation class. A vhtEngine instance invokes the dissimulation method of an associated vhtSimulation object once per frame. By extending vhtSimulation class, user applications can insert arbitrary processing into the haptic simulation. The method vhtEngine::useSimulation is used to set the user-defined vhtSimulation object.","By default, the vhtSimulation::doSimulation method:performs the scene graph refresh and hand updates. Before the scene graph is locked by the vhtSimulation, the method preLockProcess is called. After all external data is updated, but while the scene graph is locked, the method handleConstraints is called. After the scene graph is unlocked, postLockProcess is called. It is only necessary to inherit those methods that the user application actually needs to call. For many applications this will either be none or just handleConstraints. The three methods, preLockProcess, handleConstraints and postLockProcess do no action in the library provided vhtSimulation. Users are encouraged to subclass and use these entry points.","We conclude this section with an example that reworks the previous spinning cube demo into the vhtSimulation framework. In addition, we add a human hand and demonstrate the use of locking to draw the current state of the haptic scene graph using OpenGL.","Collision Detection","The determination of contact between two virtual graphical objects constitutes the field of collision detection. Contact information can take many forms, some applications only require boolean knowledge of collisions whereas others need detailed contact parameters such as surface normals and penetration depths. The VHT collision mechanism supports all of these requirements by providing a modular interface structure. In this framework, users may customize the collision detection to any desired degree.","Collision detection algorithms are almost always the primary source of performance degradation in applications that check for collisions. For this reason, the VHT system consists of several layers of optimized techniques to ensure the highest possible performance. The collision detection process can be divided into two steps: wide mode followed by local mode.","In wide mode, an algorithm tries to reduce the large number of possible collision pairs to the smallest possible set. The VHT collision system uses a number of techniques to globally cull all possible collision pairs to a smaller set of probable collision pairs. The algorithm does this in a conservative manner so that collisions are never missed.","In local mode, also known as pair-wise collision detection, two shapes are compared at the actual geometry level to determine detailed contact information. Information such as contact normals, closest points, etc. is calculated. VHT includes support for two implementations of an algorithm known as GJK (for Gilbert-Johnson-Keethri) for performing these computations.","The collision framework also provides for user customization of the entire local mode process. This modularity allows for the creation of high performance collision modules specialized for each user application. An overview of the collision engine structure is presented in .","The management of collision geometries, wide mode and other collision processing is handled internally in the vhtCollisionEngine class. An object of type vhtCollisionEngine is constructed by specifying a haptic scene graph and a collision factory to use. This chapter contains an overview of the factory and engine construction and use.","The Collision Factory","In the VHT, a collision framework is a pair of objects, a vhtCollisionEngine and an associated vhtCollisionFactory. The collision engine operates on data that are produced by its collision factory. However the vhtCollisionFactory class is an interface class (pure virtual) that sub-classes must implement.","The two virtual methods in the vhtCollisionFactory are:",{"@attributes":{"id":"p-0220","num":"0252"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"vhtCollisionPair \u2003*generateCollisionPair( vhtShape3D &obj1,"},{"entry":"vhtShape3D &obj2 );"},{"entry":"vhtGeometry \u2003\u2003\u2003\u2003*generateCollisionGeometry( vhtShape3D &obj );"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The first method determines if two vhtShape3D nodes can collide, and if so, generates an appropriate vhtCollisionPair object. The second method analyzes the geometry template stored in the vhtShape3D node and generates an optimized collision geometry representation.","The VHT includes an implementation of these two methods for two popular GJK implementations, VClip (from MERL, www.merl.com) and SOLID (www.win.tue.nl\/cs\/tt\/gino\/solid). These interfaces are included in separate libraries from the core VHT.","To use the VClip implementation, simply include the vclip factory class definition in the source code:\n\n","The primary point of access for collision detection is the class vhtCollisionEngine. This class manages all collision-related data structures and performs the hierarchical culling of all geometry pairs in the scene graph. The user application only has to specify the scene graph on which they want collision information, and an associated factory:\n\n",{"@attributes":{"id":"p-0225","num":"0262"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003vhtArray *pairList = collisionEngine->collisionCheck( );"]},{"entry":[{},"\u2003vhtCollisionPair *collisionPair;"]},{"entry":[{},"\u2003for( unsigned int i=0; i < pairList->getNumEntries( ); i++ ) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003collisionPair = (vhtCollisionPair *)pairList->getEntry(i)"]},{"entry":[{},"\u2003... process collision event...."]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The list of pairs produced by this call will include all vhtShape3D nodes in the scene graph that are within collision epsilon distance of each other. This value can be accessed with the get\/set methods:\n\n","The collision engine class assumes that the haptic scene graph used in the constructor is static, in the sense that no subgraphs are added or deleted. If the application removes or adds nodes to the haptic scene graph, the vhtCollisionEngine::regenerateDataStructures method should be called, as in the following example:\n\n","The vhtCollisionPair class contains detailed information on the collision state of two vhtShape3D nodes. The collision pair object is constructed using the factory associated with the collision engine, and is returned after collision checking.","In the current framework, in order for a collision pair to be constructed, both vhtShape3D objects must: have valid collision geometry, have compatible attributes (see below), have vhtComponent parents, and be children of different components.","Every vhtShape3D object contains a vhtPhysicalAttributes member which is used to prune possible collision pairs. There are four types of attributes:\n\n","Scene graph objects that are driven by some external sensors, should have vhtExternalAttributes. The vhtHumanHandAttributes type is provided as a specialization of external attributes. Only vhtShape3D's associated with vhtHumanHand instances have this type of attribute. Objects that move in some manner during the simulation but not from external data sources should have vhtDynamicAttributes, and objects that do not move during the simulation (i.e. walls) should have vhtNonDynamicAttributes. By default, all vhtShape3D objects have vhtDynamicAttributes, and all hand related objects (i.e. vhtPhalanx) have vhtExternalAttributes.","Physical attributes can be set using the vhtShape3D::setPhysicalAttributes method. The collision allowances for each possible pair are shown in the table below.",{"@attributes":{"id":"p-0233","num":"0278"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"HumanHand","External","Dynamic","Non-Dynamic"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["HumanHand","No","No","Yes","No"]},{"entry":["External","\u2014","No","Yes","No"]},{"entry":["Dynamic","\u2014","\u2014","Yes","Yes"]},{"entry":["Non-Dynamic","\u2014","\u2014","\u2014","No"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Given the collision framework presented above, the user application is now faced with an array of vhtCollisionPair objects that describe the proximity state of the current haptic scene graph. In the VHS, it is the responsibility of the user application to decide how the collision pair list is processed. For this purpose, the vhtCollisionPair class contains a significant amount of information about the two shapes and their collision state. In this section, the vhtCollisionPair class is reviewed.","The two vhtShape3D nodes can be obtained from the methods getObject1 and getObject2. The current distance between the two objects is obtained from\n\n","This method returns a signed double value that is the minimum translation distance (MTD) between object 1 and object2. The MTD is the smallest distance that one object must be translated so that the two objects just touch. For non-penetrating objects, it is the same as their closest distance, but for penetrating objects it gives the deepest penetration depth.","The collider may be executed by the user application directly by calling getMTD. This method invokes the collider associated with the collision pair and updates all collision information.","Other information available from the vhtCollisionPair structure are the points, in each objects coordinate frame, on the surface that are closest. These are known as witness points and are returned by getWitness1, and getWitness2:\n\n","The surface normal at the witness point (in each object's frame) is given by getContactNormal1 and getContactNormal2:\n\n","Given both the witness point and the contact normal, a unique tangent plane to the surface of each object can be constructed. This can be useful for haptic-feedback applications involving devices such as the CyberGrasp or CyberTouch.","Typical user applications would like to have the witness points and contact normals in the world frame so that they can be compared or manipulated. This is simply accomplished by transforming the witness points and rotating the normals:\n\n","Collision detection is an example of a user process where one would like to be in synchronization with the haptic simulation frame rate. For this reason, it is common to write a vhtSimulation subclass that overrides the handleConstraints method and performs collision detection and collision response. We present a complete example of a hand touching an object below. The purpose of this section is to describe the collision detection and response layout.","The class SimGrasp is similar to the SixHand class. As before, the UserSimulation class is inherited from vhtSimulation. In this case however, the UserSimulation instance actually checks the results of the collision detection algorithm. The haptic scene graph consists of a single object and a hand, so all collisions will be object-hand. The algorithm finds the appropriate normal and offset for a tangent plane on the surface of the object for each detected contact. These tangent planes are used to provide force-feedback information to an attached CyberGrasp controller.","In the code the method handleConstraints contains the collision response code:",{"@attributes":{"id":"p-0245","num":"0299"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void UserSimulation::handleConstraints(void)"]},{"entry":[{},"{"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Before any collision checks can occur, the scene graph should be refreshed to ensure all transformation matrices are correct, as follows:\n\n",{"@attributes":{"id":"p-0247","num":"0302"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"vhtArray *pairList = collisionEngine->collisionCheck( );"]},{"entry":[{},"if ( pairList->getNumEntries( ) > 0 ) {"]},{"entry":[{},"\u2003vhtCollisionPair *pair;"]},{"entry":[{},"\u2003vhtShape3D *obj1;"]},{"entry":[{},"\u2003vhtShape3D *obj2;"]},{"entry":[{},"\u2003vhtShape3D *objectNode;"]},{"entry":[{},"\u2003vhtShape3D *handNode;"]},{"entry":[{},"\u2003vhtPhalanx *phalanx;"]},{"entry":[{},"\u2003vhtVector3d wpObj, wpHand;"]},{"entry":[{},"\u2003vhtVector3d normal;"]},{"entry":[{},"\u2003vhtTransform3D xform;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Loop over all the collision pairs, extracting and processing each one immediately.",{"@attributes":{"id":"p-0249","num":"0304"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"for ( int i= 0; i < pairList->getNumEntries( ); i++ ) {"]},{"entry":[{},"\u2003vhtVector3d wpObj, wpHand;"]},{"entry":[{},"\u2003vhtVector3d normal;"]},{"entry":[{},"\u2003vhtTransform3D xform;"]},{"entry":[{},"\u2003\/\/ Get a pair of colliding objects."]},{"entry":[{},"\u2003pair = (vhtCollisionPair *)pairList->getEntry( i );"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0250","num":"0305"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Get the colliding objects."]},{"entry":[{},"obj1 = pair->getObject1( );"]},{"entry":[{},"obj2 = pair->getObject2( );"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0251","num":"0306"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if ( obj1->getPhysicalAttributes( )->isDynamic( ) ) {"]},{"entry":[{},"\u2003wpObj = pair->getWitness1( );"]},{"entry":[{},"\u2003wpHand = pair->getWitness2( );"]},{"entry":[{},"\u2003objectNode = obj1;"]},{"entry":[{},"\u2003handNode = obj2;"]},{"entry":[{},"\u2003normal = pair->getContactNormal1( );"]},{"entry":[{},"}"]},{"entry":[{},"else {"]},{"entry":[{},"\u2003wpObj = pair->getWitness2( );"]},{"entry":[{},"\u2003wpHand = pair->getWitness1( );"]},{"entry":[{},"\u2003objectNode = obj2;"]},{"entry":[{},"\u2003handNode = obj1;"]},{"entry":[{},"\u2003normal = pair->getContactNormal2( );"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Respond to the collision. In this case, the collision information is used to generate a vhtContactPatch object that can be sent to the CyberGrasp device.",{"@attributes":{"id":"p-0253","num":"0308"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Get the phalanx of the colliding tip."},{"entry":"phalanx = (vhtPhalanx *)handNode->getParent( );"},{"entry":"\/\/ Set the contact patches for the distal joints, to activate CyberGrasp."},{"entry":"if ( phalanx->getJointType( ) == GHM::distal ) {"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Transform the normal and witness point to world frame.",{"@attributes":{"id":"p-0255","num":"0310"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u2003\u2003\u2003xform = objectNode->getLM( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003xform.transform( wpObj );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003xform.rotate( normal );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\/\/ Create the contact patch, define its parameters."]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003vhtContactPatch patch( wpObj, normal );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003patch.setDistance( pair->getLastMTD( ) );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003patch.setStiffness( .5 );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003patch.setDamping( .5 );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003phalanx->setContactPatch( &patch );"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This method represents a typical collision handling scenario. The basic purpose of this code is to parse the collision list and for each distal joint collision event encountered, send an appropriate message to the connected CyberGrasp force feedback device.","The first thing this code does is retrieve the current collision list and check to see if there are any collisions reported.","For each collision event the code extracts the vhtCollisionPair object which corresponds to two objects in collision proximity. See the Programmer's Reference Manual for a full description of this class' functionality.","The next step is to determine which two objects are colliding. This code example uses the fact that all hand-related shape nodes have external attributes. By checking each object in the pair for this property, we can determine which one is a hand node and which one is an object. From this, we use the fact that all hand shape nodes are children of a phalanx (including the palm) to retrieve the hand object.","This portion of the code completes the collision detection phase. Once the colliding objects have been identified, the code moves into the collision response phase. In this example the response will be just to construct and send a contact patch to the CyberGrasp controller unit corresponding to the surface of the object being touched.","Contact patches are tangent plane representations of the surface of objects. These tangent planes are specified in world coordinates. Using rotate instead of transform preserves the unit length character of normal vectors. By updating the contact patches sent to the grasp controller on every haptic frame, it is possible to feel the surface of complex geometric objects. Somewhat by way of summary, the collision framework provided by the VHS consists of two primary components, a collision factory and a collision engine. Once these two pieces have been constructed and associated with a haptic scene graph, a single engine method provides a list of collision pairs. User applications are then free to use any or all of the provided information to construct their own response. In conjunction with the VHS hand class, it is straightforward to implement grasping and ghost hand behavior.","Model Import","The VHS programming framework is structured so that it is very simple to integrate into 3rd party rendering or visualization environments. In this chapter, the mechanism by which scene graphs can be imported from an arbitrary data structure (or file) is discussed. Once a scene graph has been imported into the VHS, there is a mechanism for synchronizing the position and orientation of all shapes in the scene very rapidly. This mechanism is also discussed.","The VHS ships with an associated library VHTCosmo that provides an interface to the Cosmo\/Optimizer SDK. This will be the basis of the description in this section.","The fundamental structure behind scene graph import and synchronization is a structure known as the neutral scene graph (NSG). The NSG provides a (non-bijective) mapping between any external scene graphs nodes and the VHT scene graph nodes. The NSG is non-bijective in the sense that there does not need to be an exact 1-1 correspondence between every node (although in practice this will usually be the case).","The external interface consists of the following steps:\n\n","The NSG is a graph of nodes of type vhtDataNode. The base class has all the functionality necessary to manipulate and construct a simple graph. For the purpose of model import, a subclass of the vhtDataNode must be constructed so that a pointer to the 3rd party graph (3PG) is available. For Cosmo\/Optimizer, this is simple:",{"@attributes":{"id":"p-0267","num":"0326"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/: A neutral cosmo node pointer."},{"entry":"\/\/ An implementation of the neutral scene graph specialized for"},{"entry":"\/\/ the Cosmo\/Optimizer rendering infrastructure."},{"entry":"class vhtCosmoNode : public vhtDataNode {"},{"entry":"\u2002protected:"},{"entry":"\u2003\u2003csNode *cosmoDual;"},{"entry":"\u2003\u2003\/\/: Cosmo node dual to this."},{"entry":"\u2002public:"},{"entry":"\u2003\u2003vhtCosmoNode(void);"},{"entry":"\u2003\u2003\/\/: Construct a null neutral node."},{"entry":"\u2003\u2003vhtCosmoNode(vhtDataNode *aParent);"},{"entry":"\u2003\u2003\/\/: Construct a node with given parent."},{"entry":"\u2003\u2003\/\/!param: aParent \u2212 Parent node."},{"entry":"\u2003\u2003virtual ~vhtCosmoNode(void);"},{"entry":"\u2003\u2003\/\/: Destruct."},{"entry":"\u2003\u2003inline csNode *getCosmo(void) { return cosmoDual; }"},{"entry":"\u2003\u2003\/\/: Get the associated cosmo node."},{"entry":"\u2003\u2003inline void setCosmo(csNode *aCosmo) { cosmoDual= aCosmo; }"},{"entry":"\u2003\u2003\/\/: Set the associated cosmo node."},{"entry":"\u2003\u2003\/\/!param: aCosmo \u2212 Associated cosmo node."},{"entry":"\u2002};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The resulting neutral node simply adds the storage of a csNode, the base class for all node types in Cosmo. This class is an easily modifiable template for supporting other scene graph types.","Node Parser","The node parser mechanism is an abstract interface for copying a tree. The basic technique for tree copying involves a depth first traversal and a stack. Since Cosmo is easily amenable to this approach, only this technique will be discussed, however, the approach will have to be modified for other 3rd party data structures that differ significantly from Cosmo.","First, the abstract interface for the vhtNodeParser:",{"@attributes":{"id":"p-0271","num":"0330"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class vhtNodeParser {"]},{"entry":[{},"\u2002public:"]},{"entry":[{},"\u2003enum ParseFlags {"]},{"entry":[{},"\u2003\u2003ready, finished, aborted"]},{"entry":[{},"\u2003};"]},{"entry":[{},"\u2003\/\/: The states of a parser."]},{"entry":[{},"\u2003enum ParseResult {"]},{"entry":[{},"\u2003\u2003prContinue, prAbort, prRetry, prFinished"]},{"entry":[{},"\u2003};"]},{"entry":[{},"\u2003\/\/: Operation states that occur during the descent."]},{"entry":[{},"\u2002protected:"]},{"entry":[{},"\u2003ParseFlags status;"]},{"entry":[{},"\u2002public:"]},{"entry":[{},"\u2003\u2003vhtNodeParser(void);"]},{"entry":[{},"\u2003\u2003virtual ~vhtNodeParser(void);"]},{"entry":[{},"\u2003\u2003virtual vhtDataNode *parse(void *aNode);"]},{"entry":[{},"\u2003\u2003virtual void *preProcess(void *someData);"]},{"entry":[{},"\u2003\u2003virtual vhtDataNode *postProcess(void *someData,"]},{"entry":[{},"\u2003\u2003vhtDataNode *aTree);"]},{"entry":[{},"\u2003\u2003virtual vhtDataNode *descend(void *someData)= 0;"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"To initiate parsing of a 3rd party scene, the method parse will be called. The parse method first calls result1=preprocess(aNode), then result2 =descend(aNode) and finally result=postProcess(result1, result2). The final variable result is returned. For most standard parsers, only the descend method needs to be implemented. This is the approach taken by the vhtCosmoParser, which implements the descend method:",{"@attributes":{"id":"p-0273","num":"0332"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"vhtDataNode *vhtCosmoParser::descend(void *someData)"},{"entry":"{"},{"entry":"\u2002initialNode= NULL;"},{"entry":"\u2002m_sgRoot= NULL;"},{"entry":"\u2002if (traverser == NULL) {"},{"entry":"\u2003traverser= new vhtDFTraverser(this);"},{"entry":"}"},{"entry":"\u2002if (((csNode *)someData)->isOfType(csTransform::getClassType( ))) {"},{"entry":"\u2003m_sgRoot= new vhtComponent( );"},{"entry":"\u2003initialNode= new vhtCosmoNode(NULL);"},{"entry":"\u2003initialNode->setCosmo((csGroup *)someData);"},{"entry":"\u2003initialNode->setHaptic(m_sgRoot);"},{"entry":"\u2003traverser->apply((csGroup *)someData);"},{"entry":"\u2002}"},{"entry":"\u2002return initialNode;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Optimizer provides a basic depth first traversal class that can be used to traverse Cosmo scene graphs. This has been subclassed to a vhtDFTraverser. The argument to descend is the root node of the Cosmo scene graph (CSG) that is to be parsed.","This code first creates a vhtComponent to match the root node of the CSG, then creates the appropriate neutral node and links it bidirectionally to the HSG and the CSG. Finally, the Optimizer traversal is initiated.","Once the traversal has been started, the DFTraverser calls preNode before each node is visited and postNode after each node is visited. This is a standard in order tree traversal. In the vhtDFTraverser, the preNode method is implemented as:",{"@attributes":{"id":"p-0277","num":"0336"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"opTravDisp vhtDFTraverser::preNode( csNode *&currNode,"]},{"entry":[{},"const opActionInfo &action )"]},{"entry":[{},"{"]},{"entry":[{},"\u2002vhtCosmoNode *dataNode;"]},{"entry":[{},"\u2002opTravDisp rv = opTravCont;"]},{"entry":[{},"\u2002if (currNode == owner->initialNode->getCosmo( )) return rv;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"ul":{"@attributes":{"id":"ul0042","list-style":"none"},"li":{"@attributes":{"id":"ul0042-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0043","list-style":"none"},"li":["dataNode=new vhtCosmoNode(owner->currentDataNode);","dataNode->setCosmo(currNode);\n\nThen for each Cosmo node type, the corresponding vhtNode must be constructed and linked to the corresponding neutral node. In this case, Cosmo shapeClass objects are mapped into vhtShape3D objects.\n"]}}}},{"@attributes":{"id":"p-0278","num":"0339"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2002bool success = false;"},{"entry":"\u2002\/\/"},{"entry":"\u2002\/\/ shape 3D"},{"entry":"\/\/"},{"entry":"if ((currNode->getType( ))->isDerivedFrom(shapeClass)) {"},{"entry":"\u2003\u2003\u2003vhtShape3D *pointNode = createGeometryNode( currNode );"},{"entry":"\u2003\u2003\u2003if( pointNode ) {"},{"entry":"\u2003\u2003\u2003\u2003fatherStack.push( pointNode );"},{"entry":"\u2003\u2003\u2003\u2003pointNode->setName( currNode->getName( ) );"},{"entry":"\u2003\u2003\u2003\u2003\/\/ register with NSG"},{"entry":"\u2003\u2003\u2003\u2003owner->currentDataNode->addChild(dataNode);"},{"entry":"\u2003\u2003\u2003\u2003dataNode->setHaptic(pointNode);"},{"entry":"\u2003\u2003\u2003\u2003success = true;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0279","num":"0340"},"tables":{"@attributes":{"id":"TABLE-US-00034","num":"00034"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"else if(currNode->getType( )->isDerivedFrom(transformClass)) {"]},{"entry":[{},"\u2003\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\u2003\/\/ a transform group node"]},{"entry":[{},"\u2003\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\u2003vhtTransformGroup *newGroup;"]},{"entry":[{},"\u2003\u2003\u2003if (owner->currentDataNode == owner->initialNode) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003newGroup = createComponent( currNode );"]},{"entry":[{},"\u2003\u2003\u2003} else {"]},{"entry":[{},"\u2003\u2003\u2003\u2003newGroup = createTransformGroup( currNode );"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003fatherStack.push( newGroup );"]},{"entry":[{},"\u2003\u2003\u2003owner->currentDataNode->addChild(dataNode);"]},{"entry":[{},"\u2003\u2003\u2003dataNode->setHaptic(newGroup);"]},{"entry":[{},"\u2003\u2003\u2003success = true;"]},{"entry":[{},"}"]},{"entry":[{},"etc..."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The associated postNode method simply maintains the stack so that the top is always the current neutral parent node.","To construct a vhtShape3D node, the above code segment uses an associated method createGeometryNode. The geometry extracted from the CSG must be mapped somehow into geometry that will be useful for an associated collision engine to use. However there is no knowledge in this method of the exact geometry format that could be required, so the VHT uses the concept of a geometry template.","A geometry template is a generic description of the geometry that a collision factory can use to construct collider specific geometry from. Geometry templates are stored in specializations of the vhtGeometry class. If all colliders are based on convex hull algorithms, then only the vertices of the geometry are needed, and for this a vhtVertexGeometry object may be used.","In the context of Cosmo, the createGeometryNode method contains the following code:",{"@attributes":{"id":"p-0283","num":"0344"},"tables":{"@attributes":{"id":"TABLE-US-00035","num":"00035"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"csGeometry *g= shape->getGeometry(i);"},{"entry":"\u2003\/\/ extract all geoSets"},{"entry":"\u2003if ((g != NULL) && g->getType( )->isDerivedFrom(geoSetClass)) {"},{"entry":"\u2003\u2002csMFVec3f *coords ="},{"entry":"\u2003\u2002((csCoordSet3f *)((csGeoSet *)g)->getCoordSet( ))->point( );"},{"entry":"\u2003\u2002\/\/"},{"entry":"\u2003\u2002\/\/ copy vertices"},{"entry":"\u2003\u2002\/\/"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0284","num":"0345"},"tables":{"@attributes":{"id":"TABLE-US-00036","num":"00036"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"unsigned int numPoints = coords->getCount( );"},{"entry":"if( numPoints > 3 ) {"},{"entry":"\u2003\u2003\u2003vhtVector3d *vertex = new vhtVector3d[numPoints];"},{"entry":"\u2003\u2003\u2003csVec3f currCSVec;"},{"entry":"\u2003\u2003\u2003for(unsigned int i=0; i < numPoints; i++ ) {"},{"entry":"\u2003\u2003\u2003\u2003currCSVec = coords->get(i);"},{"entry":"\u2003\u2003\u2003\u2003vertex[i] = vhtVector3d( owner->m_scale * currCSVec[0]"},{"entry":"\u2003\u2003\u2003\u2003\u2003, owner->m_scale * currCSVec[1]"},{"entry":"\u2003\u2003\u2003\u2003\u2003, owner->m_scale * currCSVec[2] );"},{"entry":"\u2003\u2003\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{},"ul":{"@attributes":{"id":"ul0044","list-style":"none"},"li":{"@attributes":{"id":"ul0044-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0045","list-style":"none"},"li":["vhtVertexGeometry*pointGeom=new vhtVertexGeometry( );","pointGeom->setVertices(vertex, numPoints);\n\nConstruct the vhtShape3D node and set its properties.\n"]}}}},{"@attributes":{"id":"p-0285","num":"0348"},"tables":{"@attributes":{"id":"TABLE-US-00037","num":"00037"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/ construct shape node"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003pointNode = new vhtShape3D( pointGeom );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/ set dynamic props"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003vhtDynamicAttributes *dynamic ="]},{"entry":[{},"\u2003\u2003\u2003\u2003new vhtDynamicAttributes( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003pointNode->setPhysicalAttributes( dynamic );"]},{"entry":[{},"\u2003\u2003\u2003\u2003vhtMassProperties massProp;"]},{"entry":[{},"\u2003\u2003\u2003\u2003massProp.computeHomogeneousMassProp( pointNode );"]},{"entry":[{},"\u2003\u2003\u2003\u2003dynamic->setMassProperties( massProp );"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In this case, once a HSG has been built using this parser the constructor for vhtCollisionEngine, or the method vhtCollisionEngine::regenerateDataStructures( ) will add additional geometry nodes to the vhtShape3D class that are specialized for the selected collider.","The node parsing mechanism is the most complex aspect of the model import framework. Once this has been completed the application is nearly ready to go.","Scene Graph Import","To actually use a node parser in an application is very simple. Both example programs in the Demos\/Vrml directory on the VirtualHand Suite distribution CD use the Cosmo node parser. The parser is used in the method addVrmlModel:",{"@attributes":{"id":"p-0289","num":"0352"},"tables":{"@attributes":{"id":"TABLE-US-00038","num":"00038"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"void CosmoView::addVrmlModel( char *filename )"},{"entry":"{"},{"entry":"\u2003\u2003\/\/ load the Vrml file"},{"entry":"\u2003\u2003opGenLoader *loader = new opGenLoader( false, NULL, false );"},{"entry":"\u2003\u2003csGroup *tmpNode = loader->load( filename );"},{"entry":"delete loader;"},{"entry":"\u2003\u2003if( tmpNode ) {"},{"entry":"\u2003\u2003\u2003\u2003\/\/ top node must be a transform for CosmoParser to work"},{"entry":"\u2003\u2003\u2003\u2003csTransform *vrmlScene = new csTransform( );"},{"entry":"\u2003\u2003\u2003\u2003vrmlScene->addChild( tmpNode );"},{"entry":"\u2003\u2003\u2003\u2003\/\/ add to scene"},{"entry":"\u2003\u2003\u2003\u2003m_sceneRoot->addChild( vrmlScene );"},{"entry":"\u2003\u2003\u2003\u2003\/\/ set scene center"},{"entry":"\u2003\u2003\u2003\u2003csSphereBound sph;"},{"entry":"\u2003\u2003\u2003\u2003((csNode*) vrmlScene)->getSphereBound(sph);"},{"entry":"\u2003\u2003\u2003\u2003m_sceneRoot->setCenter(sph.center);"},{"entry":"\u2003\u2003\u2003\u2003\/\/ adjust camera"},{"entry":"\u2003\u2003\u2003\u2003setCameraFOV( );"},{"entry":"\u2003\u2003\u2003\u2003m_camera->draw(m_drawAction);"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Note that the vrmlScene must be of type"},{"entry":"\u2003\u2003\u2003\u2003csTransform* for the parser to work."},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003vhtCosmoParser *cosmoParser = new vhtCosmoParser( );"},{"entry":"\u2003\u2003\u2003\u2003vhtCosmoNode\u2003\u2003*neutralNode\u2003\u2003="},{"entry":"(vhtCosmoNode\u2003\u2003*)m_engine->registerVisualGraph( vrmlScene,"},{"entry":"cosmoParser, true );"},{"entry":"\u2003\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Only the final two lines of this method actually use the Cosmo node parser. The first portion of the method loads a VRML model using the Optimizer loader. The loaded model is added to the Cosmo scene and the scene parameters are adjusted.","Finally, the node parser is constructed and passed into the corresponding vhtEngine for this simulation. The method vhtEngine::registerVisualGraph performs three functions, first it calls the node parser descend method, second calls the vhtSimulation::addSubgraph method. This is useful for performing special simulation processing on the new HSG sub-graph. Finally, the engine maintains a list of all vhtComponent nodes in the entire HSG.","Synchronization","After all the above steps have been completed, the HSG and NSG constructed the simulation is ready to run. During the simulation loop, it is necessary to copy the transformation matrices from the HSG into the visual graph to maintain visual consistency. This is the synchronization problem.","The vhtEngine maintains a list of all components in the HSG. In most applications, only the transforms for the components will need to be synchronized with the visual graph since all others can be calculated from them. To optimize this, the engine has a method getComponentUpdaters that provides the component list. The idea is to traverse this list once per frame and copy all the transformations from the HSG into the visual scene graph.","Again the example of Cosmo is used. Once per render loop frame, the method updateHSGData is invoked:",{"@attributes":{"id":"p-0295","num":"0358"},"tables":{"@attributes":{"id":"TABLE-US-00039","num":"00039"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"void CosmoView::updateHSGData( void )"},{"entry":"{"},{"entry":"\u2003\u2003\u2003\u2003It is critical in a multithreaded application to ensure that the transforms are"},{"entry":"not being updated by the other thread while they are being copied."},{"entry":"\u2003\u2003m_engine->getHapticSceneGraph( )->sceneGraphLock( );"},{"entry":"Get the component list from the engine."},{"entry":"\u2003\u2003\/\/ traversal data types"},{"entry":"\u2003\u2003vhtNodeHolder *nodeList = m_engine->getComponentUpdaters( );"},{"entry":"\u2003\u2003vhtNodeHolder *nodeCursor = nodeList;"},{"entry":"\u2003\u2003vhtCosmoNode *currNode = NULL;"},{"entry":"\u2003\u2003vhtComponent *currComponent = NULL;"},{"entry":"\u2003\u2003\/\/ transformation matrix"},{"entry":"\u2003\u2003double xform[4][4];"},{"entry":"\u2003\u2003vhtTransform3D vhtXForm;"},{"entry":"\u2003\u2003csMatrix4f\u2003\u2003cosmoXForm;"},{"entry":"\u2003\u2003Walk through the component list, getting copying transformation matrix as we"},{"entry":"go."},{"entry":"\u2003\u2003while( nodeCursor != NULL ) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ get next component updater node"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003currNode = (vhtCosmoNode *)nodeCusor->getData( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003currComponent = (vhtComponent *)currNode->getHaptic( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ get latest transform"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003vhtXForm = currComponent->getTransform( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003vhtXForm.getTransform( xform );"},{"entry":"\u2003\u2003\u2003\u2003Copy to a cosmo transformation."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003cosmoXForm.setCol(0, xform[0][0], xform[0][1], xform[0][2], xform[0][3] );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003cosmoXForm.setCol(1, xform[1][0], xform[1][1], xform[1][2], xform[1][3] );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003cosmoXForm.setCol(2, xform[2][0], xform[2][1], xform[2][2], xform[2][3] );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003cosmoXForm.setCol(3, xform[3][0], xform[3][1], xform[3][2], xform[3][3] );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ set the corresponding cosmo node"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003((csTransform *)currNode->getCosmo( ))->setMatrix(cosmoXForm);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ next list item"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003nodeCursor = nodeCursor->getNext( );"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003\/\/ unset mutex"},{"entry":"\u2003\u2003m_engine->getHapticSceneGraph( )->sceneGraphUnlock( );"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The neutral node architecture provides the node container class vhtNodeHolder as a simple way of constructing and traversing lists of vhtDataNode objects.","Additional Description","The foregoing descriptions of specific embodiments of the present invention have been presented for purposes of illustration and description. They are not intended to be exhaustive or to limit the invention to the precise forms disclosed, and obviously many modifications and variations are possible in light of the above teaching. The embodiments were chosen and described in order to best explain the principles of the invention and its practical application, to thereby enable others skilled in the art to best utilize the invention and various embodiments with various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the claims appended hereto and their equivalents.","All publications and patent applications cited in this specification are herein incorporated by reference as if each individual publication or patent application were specifically and individually indicated to be incorporated by reference."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
