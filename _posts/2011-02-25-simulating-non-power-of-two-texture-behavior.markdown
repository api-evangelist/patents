---
title: Simulating non power of two texture behavior
abstract: Aspects of the invention relate generally to enforcing elements of the OpenGL ES specification. More specifically, regardless of whether or not the underlying API system would allow NPOT textures, the systems and methods herein may disallow them. As a result, objects bound with these textures may be considered errors, non-renderable, and rendered in black. In order to accomplish this, various functions may be tracked to determine whether an NPOT texture that uses mips is being bound to an object, and if so, treat the condition as an error and bind (then draw) the object with a black texture.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08711166&OS=08711166&RS=08711166
owner: Google Inc.
number: 08711166
owner_city: Mountain View
owner_country: US
publication_date: 20110225
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["Graphics application programming interfaces (\u201cAPI\u201d) are used by programmers to create 2D and 3D graphics. The Open Graphics Library (\u201cOpen GL\u201d) is a widely used API. The Open GL architecture allows programmers to produce consistent visual display results on any OpenGL API-compliant hardware regardless of the operating system. OpenGL for embedded systems (\u201cOpenGL ES\u201d) is a subset of the OpenGL API designed for embedded devices such as mobile phones, PDAs, and video game consoles.","OpenGL and OpenGL ES may use \u201ctextures\u201d or images that are generally used to give 3d objects greater detail. For example, as shown in , cube  is not textured.  depicts a texture  which may be applied to cube  to generate cube  shown in . When cube  is drawn, the system must determine which colors to draw it and make the texture \u201cfit\u201d to the object. In one example, for each pixel in cube , the system will choose 1 or 4 pixels from texture  and average them together. Which pixels the system selects may vary depending upon the texture and the object. For example, if the texture of  is red, white and blue, the system may select a red, white or blue pixel. As a result of using these averages, when cube  is rotated, the cube may actually flicker different colors as it moves around the view.","In order to avoid flickering and increase efficiency, OpenGL and OpenGL ES may use \u201cmipmapping.\u201d Mipmapping allows the system to generate smaller versions of textures called \u201cmipmaps\u201d or \u201cmips.\u201d Each mip may be \u00bc the size of the previous one. For each mip, the colors of the original texture (or the next larger mip) may be used to compute what color the smaller mip should be. As shown in , mips - may be considered smaller versions of texture , each being some combination of red, white, and blue pixels. The smallest mip may be a 1\u00d71 pixel map.  is an enlargement of mips -.","When the system draws a cube with a texture that uses mips, it may choose the appropriately sized mip. For example, if the cube is so small or far away that it is only 1 pixel large, the system will choose the smallest mip. If there is only 1 pixel in the smallest mip, the flickering may now be fixed. In some examples, the mips may make the image clearer. For example,  depicts two textured cubes,  drawn using the \u201caverage\u201d method described above and  using the \u201cmip\u201d method.","Most of the various versions of OpenGL allow texture to be drawn in any dimension up to a certain maximum size. The base specifications for OpenGL and OpenGL ES require that if (a) a texture has mips and (b) the texture has been set to use mips, the texture's dimensions must be a power of 2. In other words, the width and height of the texture must be 1, 2, 4, 8, 16, 32, 64, 128, etc., up to the maximum power of two that the particular version of GL allows. For example, a texture that is 128\u00d764 pixels is a power of 2 (\u201cPOT\u201d) texture. A texture that is 127\u00d764 is a non power of 2 (\u201cNPOT\u201d) texture. The base OpenGL specification designates NPOTs as an error. As a result, the system will ignore the NPOT texture and instead treat the texture as though it was all black. Many versions of OpenGL have optional extensions which remove this restriction. These extensions allow NPOT textures to be drawn just like POT textures.","However, many computing systems do not support these extensions. If a programmer prepares a program assuming that the extensions exist (as they do on his personal machine), he may prepare his program only later to discover that the program may not work on systems which do not utilize these extensions.","Aspects of the invention relate generally to enforcing elements of the OpenGL ES specification. More specifically, regardless of whether or not the underlying API system would allow NPOT textures, the systems and methods described herein may disallow them. As a result, objects bound with these textures may be considered errors, non-renderable, and\/or rendered in black. In order to accomplish this, various functions may be tracked to determine whether an NPOT texture that uses mips is being bound to an object, and if so, treat the condition as an error and bind (then draw) the object with a black texture. Later, the NPOT texture which uses mips may be bound to the object such that when the user queries for which texture was bound to the object, the user will not know that a black texture was bound. The user may then \u201ccorrect\u201d the black object, by replacing the NPOT texture with a power of two texture. Thus, a user using an OpenGL emulator with the features described herein may be able to generate images with the same characteristics for devices using either OpenGL or OpenGL ES. This effectively removes the need for extensions and results in code or images which will be displayed the same way on computing systems which support OpenGL or OpenGL ES.","One aspect of the invention provides a computer-implemented method for binding textures and generating an image of an object using a graphics library including functions and elements. The method includes receiving a request from a user to use a first function to bind one or more textures to the object and to draw the object and identifying a plurality of textures including the one or more textures. For each texture of the plurality of textures, a processor determines whether the texture is an NPOT texture comprising a length dimension or a width dimension which is not a power of 2. For each NPOT texture, whether that texture is set to use mips is also determined. For each of the one or more textures which is an NPOT texture and set to use mips, a black texture is bound to the object and the object is drawn in black. The first function is called and after drawing the object in black, the one or more textures is bound to the object. In one example, any of the one or more NPOT textures set to use mips is drawn in black.","Another aspect of the invention provides a computer-implemented method for binding textures and generating an image of an object using a graphics library including functions and elements. The method includes generating a variable to track a number of NPOT textures comprising a length dimension or a width dimension which is not a power of 2, the NPOT textures being set to use mips; tracking the use of a first function; setting a value for the variable based on the use of the second function; and receiving a request from a user to use a second function to bind one or more textures to the object and draw the object. If the value indicates that there are NPOT textures set to use mips, then the method also includes: (a) identifying a plurality of textures including the one or more textures; (b) for each texture of the plurality of textures, determining, by a processor, whether the texture is an NPOT texture; (c) for each NPOT texture, determining whether the texture is set to use mips; (d) for each of the one or more textures which is an NPOT texture and set to use mips, binding a black texture to the object; (e) drawing the object in black; (f) calling the second function; and (g) after drawing the object in black, binding the one or more textures to the object.","In one example, if the value indicates that there are no NPOT textures set to use mips, then the method also includes calling the second function and binding the one or more textures to the object. In another example, the method also includes drawing any of the one or more NPOT textures set to use mips in black.","Yet another aspect of the invention provides a computer-implemented method for binding textures and generating an image of an object using a graphics library including functions and elements. The method includes generating a variable to track a number of NPOT textures comprising a length dimension or a width dimension which is not a power of 2, and which are set to use mips; tracking the use of a first function; setting a value for the variable based on the use of the first function; tracking the use of a second function; identifying, by a processor, a plurality of textures of the library; identifying N texture binding locations based on the use of the second function, where each of the N texture binding location is associated with a respective texture of the plurality of textures; and receiving a request from a user to use a third function to bind one or more textures to the object and draw the object. If the value indicates that there are NPOT textures set to use mips, the method also includes (a) for each of the N texture binding locations, the processor determining whether the respective texture is an NPOT texture; (b) for each NPOT texture, determining whether the texture is set to use mips; (c) for each of the one or more textures which is an NPOT texture and set to use mips, binding a black texture to the object; (d) drawing the object in black; (e) calling the third function; and (f) after drawing the object in black, binding the one or more textures to the object.","In one example, if the value indicates that there are no NPOT textures set to use mips, the method also includes calling the first function and binding the one or more textures to the object. In another example, the method also includes drawing any of the one or more NPOT textures set to use mips in black.","Still a further aspect of the invention provides a computer-implemented method for binding textures and generating an image of an object using a graphics library including functions and elements. The method also includes generating a variable to track a number of NPOT textures each comprising a length dimension or a width dimension which is not a power of 2, the NPOT textures being set to use mips; tracking the use of a first function; setting a value for the variable based on the use of the first function; tracking the use of a second function; identifying, by a processor, a plurality of textures of the library; identifying N texture binding locations based on the use of the second function, where each of the N texture binding locations is associated with a respective texture of the plurality of textures; tracking the use of a third function; identifying one or more of the N texture binding locations based on the use of the third function; and receiving a request from a user to use a fourth function to bind one or more textures to the object and draw the object. If the value indicates that there are NPOT textures set to use mips, the method also includes (a) for each of the identified one or more N texture binding locations, determining by the processor whether the respective texture is an NPOT texture; (b) for each NPOT texture, determining whether the texture is set to use mips; (c) for each of the one or more textures which is an NPOT texture and set to use mips, binding a black texture to the object; (d) drawing the object in black; (e) calling the fourth function; and (f) after drawing the object in black, binding the one or more textures to the object.","In one example if the value indicates that there are no NPOT textures set to use mips, the method also includes calling the first function and binding the one or more textures to the object. In another example, the method also includes drawing any of the one or more NPOT textures set to use mips in black.","A further aspect of the invention provides a computer. The computer includes memory storing a graphics library including functions and elements for binding textures and generating an image of an object. The computer also includes a processor coupled to the memory. The processor is operable to receive a request from a user to use a first function to bind one or more textures to the object and to draw the object and identify a plurality of textures including the one or more textures. For each texture of the plurality of textures, the processor is operable to determine whether the texture is an NPOT texture comprising a length dimension or a width dimension which is not a power of 2. For each NPOT texture, the processor is operable to determine whether that texture is set to use mips. For each of the one or more textures which is an NPOT texture and set to use mips, the processor is operable to bind a black texture to the object. The processor is also operable to draw the object in black, call the first function, and after the object is drawn in black, bind the one or more textures to the object.","In one example, the processor is also operable to draw any of the one or more NPOT textures set to use mips in black.","Yet a further aspect of the invention provides a computer. The computer includes memory storing a graphics library including functions and elements for binding textures and generating an image of an object. The computer also includes a processor coupled to the memory. The processor is operable to generate a variable to track a number of NPOT textures comprising a length dimension or a width dimension which is not a power of 2, the NPOT textures being set to use mips; track the use of a first function. The processor is also operable to set a value for the variable based on the use of the second function and receive a request from a user to use a second function to bind one or more textures to the object and draw the object. If the value indicates that there are NPOT textures set to use mips, the processor is operable to: (a) identify a plurality of textures including the one or more textures; (b) for each texture of the plurality of textures, determine whether the texture is an NPOT texture; (c) for each NPOT texture, determine whether the texture is set to use mips; (d) for each of the one or more textures which is an NPOT texture and set to use mips, bind a black texture to the object; (e) draw the object in black; (f) call the second function; and (g) after the object is drawn in black, bind the one or more textures to the object.","In one example, the processor is also operable to, if the value indicates that there are no NPOT textures set to use mips, (a) call the second function and (b) bind the one or more textures to the object. In another example, the processor is also operable to draw any of the one or more NPOT textures set to use mips in black.","Another aspect of the invention provides a computer. The computer includes memory storing a graphics library including functions and elements for binding textures and generating an image of an object. The computer also includes a processor coupled to the memory. The processor is operable to generate a variable to track a number of NPOT textures comprising a length dimension or a width dimension which is not a power of 2, and which are set to use mips; track the use of a first function; set a value for the variable based on the use of the first function; and track the use of a second function. The processor is also operable to identify a plurality of textures of the library; identify N texture binding locations based on the use of the second function, where each of the N texture binding location is associated with a respective texture of the plurality of textures; and receive a request from a user to use a third function to bind one or more textures to the object and draw the object. If the value indicates that there are NPOT textures set to use mips, the processor is also operable to (a) for each of the N texture binding locations, determine whether the respective texture is an NPOT texture; (b) for each NPOT texture, determine whether the texture is set to use mips; (c) for each of the one or more textures which is an NPOT texture and set to use mips, bind a black texture to the object; (d) draw the object in black; (e) call the third function; and (f) after the object is drawn in black, bind the one or more textures to the object.","In one example, the processor is also operable to, if the value indicates that there are no NPOT textures set to use mips, call the first function and bind the one or more textures to the object. In another example, the processor is further operable to draw any of the one or more NPOT textures set to use mips in black.","Still a further aspect of the invention provides a computer. The computer includes memory storing a graphics library including functions and elements for binding textures and generating an image of an object. The computer also includes a processor coupled to the memory. The processor is operable to generate a variable to track a number of NPOT textures each comprising a length dimension or a width dimension which is not a power of 2, the NPOT textures being set to use mips; track the use of a first function; set a value for the variable based on the use of the first function; track the use of a second function; and identify a plurality of textures of the library. The processor is also operable to identify N texture binding locations based on the use of the second function, where each of the N texture binding locations is associated with a respective texture of the plurality of textures; track the use of a third function; identify one or more of the N texture binding locations based on the use of the third function; and receive a request from a user to use a fourth function to bind one or more textures to the object and draw the object. If the value indicates that there are NPOT textures set to use mips, the method also includes (a) for each of the identified one or more N texture binding locations, determine whether the respective texture is an NPOT texture; (b) for each NPOT texture, determine whether the texture is set to use mips; (c) for each of the one or more textures which is an NPOT texture and set to use mips, bind a black texture to the object; (d) draw the object in black; (e) call the fourth function; and (f) after the object is drawn in black, bind the one or more textures to the object.","In one example the processor further operable to, if the value indicates that there are no NPOT textures set to use mips, call the first function and bind the one or more textures to the object. In another example, the processor also operable to draw any of the one or more NPOT textures set to use mips in black.","In one aspect of the invention, an emulator program may receive a request to call a particular function from a library. The particular function may render primitives from array data to bind one or more textures to a respective object and draw the object. A plurality of textures, including the one or more textures, may be identified. The plurality of textures may, for example, include all of the textures in the library. For each texture of the plurality of textures, the emulator determines whether the texture is NPOT. For each NPOT texture, the emulator determines whether the texture is set to use mips. For each of the one or more textures which is NPOT and set to use mips, the emulator binds a black texture to the respective object and draw the object in black. Next, the particular function (as identified in the request) may be called. The particular function may be used to bind the one or more textures to the respective object identified in the original request. Accordingly, when a user queries the emulator to identify which textures have been bound, the user may receive the one or more textures of the request, and not the black texture which was bound to complete the draw.","As shown in , a system  in accordance with one aspect of the invention includes a computer  containing a processor , memory  and other components typically present in general purpose computers.","The memory  stores information accessible by processor , including instructions , and data  that may be executed or otherwise used by the processor . The memory  may be of any type capable of storing information accessible by the processor, including a computer-readable medium, or other medium that stores data that may be read with the aid of an electronic device, such as a hard-drive, memory card, flash drive, ROM, RAM, DVD or other optical disks, as well as other write-capable and read-only memories. In that regard, memory may include short term or temporary storage as well as long term or persistent storage. Systems and methods may include different combinations of the foregoing, whereby different portions of the instructions and data are stored on different types of media.","The instructions  may be any set of instructions to be executed directly (such as machine code) or indirectly (such as scripts) by the processor. For example, the instructions may be stored as computer code on the computer-readable medium. In that regard, the terms \u201cinstructions\u201d and \u201cprograms\u201d may be used interchangeably herein. The instructions may be stored in object code format for direct processing by the processor, or in any other computer language including scripts or collections of independent source code modules that are interpreted on demand or compiled in advance. Functions, methods and routines of the instructions are explained in more detail below.","The data  may be retrieved, stored or modified by processor  in accordance with the instructions . For instance, although the architecture is not limited by any particular data structure, the data may be stored in computer registers, in a relational database as a table having a plurality of different fields and records, XML documents or flat files. The data may also be formatted in any computer-readable format. By further way of example only, image data may be stored as bitmaps comprised of grids of pixels that are stored in accordance with formats that are compressed or uncompressed, lossless or lossy, and bitmap or vector-based, as well as computer instructions for drawing graphics. The data may comprise any information sufficient to identify the relevant information, such as numbers, descriptive text, proprietary codes, references to data stored in other areas of the same memory or different memories (including other network locations or servers) or information that is used by a function to calculate the relevant data.","The processor  may be any conventional processor, such as processors from Intel Corporation or Advanced Micro Devices. Alternatively, the processor may be a dedicated controller such as an ASIC. Although  functionally illustrates the processor and memory as being within the same block, it may be understood by those of ordinary skill in the art that the processor and memory may actually comprise multiple processors and memories that may or may not be stored within the same physical housing. For example, memory may be a hard drive or other storage media located in a server farm of a data center. Accordingly, references to a processor, computer or memory may be understood to include references to a collection of processors or computers or memories that may or may not operate in parallel.","The computer  may be at one node of a network  and capable of directly and indirectly receiving data from other nodes of the network. Computer  may be a client device capable of sending and receiving information with other devices, such as client device  and server , on the network. The client device may send and receive information over the network and display information to a user on display . Computer  may also comprise a plurality of computers that exchange information with different nodes of a network for the purpose of receiving, processing and transmitting data.","Network , and intervening nodes between client  and other devices, may comprise various configurations and use various protocols including the Internet, World Wide Web, intranets, virtual private networks, local Ethernet networks, private networks using communication protocols proprietary to one or more companies, cellular and wireless networks (e.g., WiFi), instant messaging, HTTP and SMTP, and various combinations of the foregoing. Although only a few computers are depicted in , it should be appreciated that a typical system can include a large number of connected computers.","Computer  may be a personal computer intended for use by a person , and have all of the components normally used in connection with a personal computer such as an electronic display  (e.g., a monitor having a screen, a touch-screen, a projector, a television, a computer printer or any other electrical device that is operable to display information), end user input  (e.g., a mouse, keyboard, touch-screen or microphone). The client device may also include a camera , position component , accelerometer, speakers, a network interface device, a battery power supply  or other power source, and all of the components used for connecting these elements to one another.","Although client device  may comprise a full-sized personal computer, it may alternatively comprise mobile devices capable of wirelessly exchanging data with a server over a network such as the Internet. By way of example only, client device  may be a wireless-enabled PDA, a cellular phone, netbook, or tablet PC capable of obtaining information via the Internet or other network. The user may input information using a small keyboard, a keypad, or a touch screen.","Data  may include a graphics library  of functions and elements used to draw graphics or images. For example, the graphics library may include the OpenGL and OpenGL ES libraries. This information may be used by a set of instructions, for example, an emulator, in order to allow a programmer to generate 2D or 3D graphics.","The graphics library may include various information, such as the textures and mips described above, which may be used by client devices to render images from memory. The library may also include functions which operate on textures. For example, these functions may include functions that: select an active texture unit (such as glActiveTexture), bind a named texture to a texturing target (such as glBindTexture), generate texture names (such as glGenTextures), delete named textures (such as glDeleteTextures), copy pixels into a 2D texture image (such as glCopyTexImage2D), specify a two-dimensional texture image in a compressed format (such as glCompressedTexImage2D), link a program object such as (such as glLinkProgram), specify a two-dimensional texture image (such as glTexImage2D), set texture parameters (such as glTexParameter), install a program object as part of current rendering state (such as glUseProgram), specify the value of a uniform variable for the current program object (such as glUniform), and render primitives from array data (such as glDrawArrays or glDrawElements).","The library may also include secondary or different versions of the functions described above. For example, these different versions may be used to track and record when the \u201creal\u201d function is created, edited, used, etc. In some examples, the different versions may be \u201cwrapped\u201d versions of the real function. The wrapped versions may include a wrapper or set of code which operates on a function to determine how the function is executed.","The processor may use the wrappers to monitor the use of the functions and recall their various states. For example, the wrappers may include a single layer or may be multilayered. Diagram  of  shows that a standard OpenGL program structure includes the user program (which calls the functions) and OpenGL. The single layer wrapper of diagram  acts as an intermediary between the user program and OpenGL.","In another example, shown in , the wrapper may have multiple layers, where each particular layer  is depicted as a rectangular block. The first level may include the OpenGL file that defines the OpenGL functions (the \u201cofficial file\u201d). Minor modifications to this file may allow the emulator to change the calls for the OpenGL ES functions to the calls for the wrappers themselves. In one example, a user program may call a particular function to perform some task. In response, the official file may actually call the particular function's wrapper (or the wrapped version of the function). This may be the second layer of the wrapper. The functions in this second layer of the wrapper may translate from C to C++ and call the third layer of the wrapper. The third layer then uses the C++ to instruct the fourth layer of the wrapper to write commands to memory using a set of low level features. In some examples, these low level features may be defined in about 50 different files. The commands may be read out of the fifth layer. The fifth layer then calls the real OpenGL function to complete some action. This fifth layer may also utilize a set of classes to assist it in recording values.","Various wrapping techniques may be used so long as the emulator is able to perform the operations described herein with regard to each particular function type.","In addition to the features described above, the library may also include additional features known as \u201cshader\u201d programs. These shaders may be mini programs that the emulator uses to draw images. The shader programs may be defined by a user. Each shader identifies inputs called \u201cuniforms,\u201d which may include textures.","Various operations in accordance with aspects of the invention may now be described. It should also be understood that the following operations do not have to be performed in the precise order described below. Rather, various steps can be handled in a different order or simultaneously, and steps may be added or removed.","A user (here, a programmer) may use the API to draw 3D graphics. For example, the user selects an object and a texture to bind to the object. The user may then call glDrawArrays or glDrawElements to bind the texture to the object. Rather than calling the real glDraw (Arrays or Elements) function, the emulator may call a wrapped version of the function and use the wrapped version to examine the state of all of the textures of the library. For each texture identified, the emulator may query OpenGL and determine whether the texture is NPOT. If the texture is NPOT, the emulator may also determine whether the texture is set to use mips. If the texture is NPOT and set to use mips, this may be recognized as an error condition. Rather than binding the texture (or appropriate mip) to the object, a default or black texture may be bound to the object and the object may be rendered in black. If the texture is not NPOT or is not set to use mips, the texture (or appropriate mip) may be bound to the object.","Next, the emulator may call the real glDraw function to actually bind the texture to the object. Thereafter, if the user queries OpenGL asking which textures have been bound, the emulator will return the NPOT and mip texture bound to the object. In this regard, the user will see the black object but may conclude that the texture was bound to the object. The user does not know that the black texture was actually bound to the object and the emulator may function just as the user expects the specification to function without using extensions.","As shown in flow diagram  of , the emulator may receive a request to call a glDraw function to bind one or more textures to a respective object at block . At block , a plurality of textures, including the one or more textures, is identified. The plurality of textures may, for example, include all of the textures in the library. For each texture of the plurality of textures, the emulator determines whether the texture is NPOT at block . For each NPOT texture, the emulator determines whether the texture is set to use mips at block . For each of the one or more textures which is NPOT and set to use mips, the emulator binds a black texture to the respective object and draw the object in black at block . Next, the real glDraw function (as identified in the request) is called at block . The real glDraw function is then used to bind the one or more textures to the respective object identified in the original request at block . Accordingly, when a user queries the emulator to identify which textures have been bound, the user will receive the one or more textures of the request, and not the black texture which was bound, to complete the draw.","In order to check the state of each of the textures to determine whether a particular texture should be drawn in black may require a query to OpenGL for each texture. Querying the state of OpenGL may be very slow, and in fact, as there are multiple textures, and making multiple requests may make the process unacceptably slow. However, because NPOT textures using mips are an error condition, there may be relatively few instances of them. In order to increase efficiency, the emulator may track how many textures are NPOT and which of those NPOT textures use mips. If there are no NPOT textures, the textures need not be examined and may bound.","The state of all of the textures may be tracked by using a general tally. For example, a variable \u201cnon_renderable_texture_count\u201d may be created and initially set to 0. The non-renderable texture may be any texture that is NPOT and set to use mips. Any time a texture is added, deleted or modified, the non_renderable_texture_count may be updated. In this regard, the emulator may track the total number of textures which are both NPOT and use mips.","In order to identify when and which textures are created and deleted, the emulator may utilize wrapped versions of functions which generate texture names and delete named textures. For example, there may be wrapped versions of the functions glGenTextures and glDeleteTextures. When a texture is created, if it is NPOT and uses mips, the non_renderable_texture_count may be increased. This may allow the emulator to track the state of the textures. When the user calls such functions to complete some tasks, the wrapped version may be called to examine any changes to the textures. In one case, when a texture is deleted, if the texture is NPOT and uses mips (i.e., non-renderable), the non_renderable_texture_count is decreased. After the changes have been recorded, for example in the wrappers, the real version of the function may be called to complete the tasks identified by the user.","In order to identify which textures are NPOT and use mips, the emulator may use wrapped versions of functions that define the dimensions of a specific mip in a texture. This may include those functions which copy pixels into a 2D texture image, specify that a two-dimensional texture image in a compressed format, and specify a two-dimensional texture image may be wrapped. For example, there may be wrapped versions of glCopyTexImage2D, glCompressedTexImage2D, and glTexImage2D. When the user calls these functions, the wrapped version may be called first to examine any changes to these functions.","In one case, the mips may be numbered from 0 to N, where 0 is the largest mip in the texture and N is the smallest. If the user is defining mips 1 to N and the user specifies NPOT dimensions, the non_renderable_texture_count may be increased. If the user is defining mip 0 first using POT dimensions, but the texture was previously non-renderable (i.e., NPOT and using mips), non_renderable_texture_count may be decreased. Similarly, if the user selects new NPOT dimensions for the mips, non_renderable_texture_count may be increased. Once the wrapped version has identified any changes to non_renderable_texture_count, the real function (as requested by the user) may be called.","In order to identify which textures are NPOT and use mips, the emulator may use wrapped versions of functions that defined whether a texture uses mips. For example, functions which set texture parameters, such as glTexParameter, may be wrapped in order to track the setting of various associated features that define whether a texture is NPOT and uses mips. Thus, when the user calls the function glTexParameter, the emulator may call the wrapped version to examine any changes to this function and its associated features","For example, glTexParameter may be used with the parameter GL_TEXTURE_MIN_FILTER. This function is a minifying function that may be used whenever the pixel being textured maps to an area greater than one texture element. If GL_TEXTURE_MIN_FILTER is set to GL_NEAREST_MIPMAP_NEAREST (which chooses the mip that most closely matches the size of the pixel being textured and uses the texture element nearest to the center of the pixel to produce a texture value), GL_NEAREST_MIPMAP_LINEAR (which chooses the two mips that most closely match the size of the pixel being textured and uses the texture element nearest to the center of the pixel to produce a texture value from each mip), or GL_LINEAR_MIPMAP_LINEAR (which chooses the two mipmaps that most closely match the size of the pixel being textured and uses the weighted average of the four texture elements that are closest to the center of the pixel to produce a texture value from each mip), then the texture may be non-renderable.","In another example, glTexParameter may be used with the parameter GL_TEXTURE_WRAP_S or GL_TEXTURE_WRAP_T, which set the wrap parameters for the texture coordinates S and T, respectively. GL_REPEAT may cause the integer part of the S coordinate to be ignored. As a result, only the fractional part of the coordinate is used and a repeating pattern is created. If the texture is NPOT, then setting GL_TEXTURE_WRAP_S or GL_TEXTURE_WRAP_T to GL_REPEAT may make the texture non-renderable.","In one example, before changing a setting, if the texture is currently not renderable, non_renderable_texture_count may be decreased, and if the new settings make the texture not renderable, non_renderable_texture_count may be increased.","By using wrapped versions of the functions described above, non_renderable_texture_count may always identify the total number of NPOT textures which use mips. If the non_renderable_texture_count is 0, the textures need not even be examined.","As shown in flow diagram  of , an exemplary emulator program generates a variable to track a number of non-renderable textures which are NPOT and are set to use mips at block . The use of glGentTextures and glDeleteTextures is then tracked at block . The emulator then adjusts the variable based on the use of glGenTextures and glDeleteTextures at block . The use of glCopyTexImage2D, glCompressedTexImage2D, and glTexImage2D is also tracked at block . The emulator then adjusts the variable based on the use of glCopyTexImage2D, glCompressedTexImage2D, and glTexImage2D at block . The use of glTexParameter and associated features are tracked at block . The variable is adjusted based on the user of glTexParameter at block .","As shown in block , the emulator may receive a request to call a glDraw function to bind one or more textures to a respective object. At block , the emulator determines whether the variable is greater than 0. If so, at block , a plurality of textures, including the one or more textures, is identified. The plurality of textures may, for example, include all of the textures in the library. For each texture of the plurality of textures, the emulator determines whether the texture is NPOT at block . For each NPOT texture, the emulator determines whether the texture is set to use mips at block . For each of the one or more textures which is NPOT and set to use mips, the emulator binds a black texture to the respective object and draw the object in black at block . Next, the real glDraw function (as identified in the request) is called at block . The real glDraw function is then used to bind the one or more textures to the respective object identified in the original request at block .","Returning to block , if the variable is equal to 0, the emulator moves to block , and the real glDraw function (as identified in the request) is called. The real glDraw function is then used to bind the one or more textures to the respective object identified in the original request at block .","Although NPOT textures set to use mips may be considered an infrequent error condition, it is possible that a program drawing an object for display may use one. The results of drawing the object in black may not be obvious and the user may not even notice the issue. Therefore it may be even more beneficial in these circumstances to make the process even more efficient by not querying OpenGL and if tracking even more states.","In order to avoid having to query OpenGL to identify the state of the various textures, the emulator may track and record exactly which particular textures are going to be bound. In order to accomplish this, the emulator may use wrapped versions of functions which select an active texture unit and bind a named texture to a texturing target. For example, OpenGL has a set of texture binding locations numbered 0 to N. In one case, OpenGL ES 2.0 may require 16 locations. Each location may have two binding targets, a 2D binding target, and a cube map binding target. Thus, the emulator may call wrapped versions of glActiveTexture (which selects the texture binding location) and glBindTexture (which sets the binding targets of the current texture binding location), to keep track of which textures are used in which targets at which locations.","So if non_renderable_texture_count is greater than 0, the emulator would may have to examine all of the N texture binding locations to determine whether any of them are non-renderable. Again, if a texture is non-renderable, the emulator may bind a black texture in the wrapper as described above.","As shown in flow diagram  of , at block  the exemplary emulator program conducts the steps of blocks - of . At block , a plurality of textures is identified. The plurality of textures may include, for example, all of the textures in the library. At block , the emulator tracks the user of glActiveTexture and glBindTexture. At block , the emulator identifies N texture binding locations based on the use of glActiveTexture and glBindTexture. Each of the N texture binding locations is associated a respective texture of the plurality of textures.","As shown in block , the emulator may receive a request to call a glDraw function to bind one or more textures to a respective object. At block , the emulator determines whether the variable is greater than 0. If so, at block , for ach of the N texture binding locations, the emulator determines whether the associated texture is NPOT. For each NPOT texture, the emulator determines whether the texture is set to use mips at block . For each of the one or more textures which is NPOT and set to use mips, the emulator binds a black texture to the respective object and draw the object in black at block . Next, the real glDraw function (as identified in the request) is called at block . The real glDraw function is then used to bind the one or more textures to the respective object identified in the original request at block .","Returning to block , if the variable is equal to 0, the emulator moves to block , and the real glDraw function (as identified in the request) is called. The real glDraw function is then used to bind the one or more textures to the respective object identified in the original request at block .","If N is a large number, such as 16, checking N locations before calling a glDraw function may be a very slow process. In addition some implementations of OpenGL may support 32, 64, or more textures which may make it even slower. Generally, a user may utilize only a few textures, at a time. Therefore, in order to increase the efficiency, the emulator may track additional information to identify exactly which textures are being used.","For example, the emulator may track the shader programs described above. In order to identify when and which shader programs are being used, functions which link a program object, such as glLinkProgram, may be wrapped. These types of functions may determine whether two shader programs may operate together. If a link is successful, the shader may be queried to identify which uniform inputs are being used. This information may be stored by the glLinkProgram wrapper. Only after a link is successful can the shader be queried to determine whether any of the inputs are of the type texture.","For each uniform input which is a texture, in order to identify which actual texture (or texture location) it references, a wrapped version of the functions which specify the values for the uniform inputs to the shader program, such as glUniform, may be used. If the uniform input being set on the current program is of the type texture, the glUniform may identify which texture binding location is being used. This texture binding location may also be stored by the wrapped version.","Accordingly, when a user calls a glDraw function and if non_renderable_texture_count is greater than 0, instead of going through all of the texture binding locations, the emulator may used the wrapped functions to identify the specific textures being used. Thus, instead of examining N or more textures, the emulator may examine the wrapped versions of these features to identify only those textures which are actually being used by the current shader program.","As shown in flow diagram  of , at block  the exemplary emulator program conducts the steps of blocks - of . At block , a plurality of textures is identified. The plurality of textures may, for example, include all of the textures in the library. At block , the emulator tracks the user of glActiveTexture and glBindTexture. At block , the emulator identifies N texture binding locations based on the use of glActiveTexture and glBindTexture. Each of the N texture binding locations is associated a respective texture of the plurality of textures. The emulator also tracks the use of glLinkProgram at block . At block , the emulator identifies shader programs with texture inputs based on the use of glLinkProgram. At block , the emulator tracks the use of glUniform. The emulator identifies one or more of the N binding locations based on the use of glUniform at block .","As shown in block , the emulator may receive a request to call a glDraw function to bind one or more textures to a respective object. At block , the emulator determines whether the variable is greater than 0. If so, at block , for each of the N identified one or more texture binding locations, the emulator determines whether the associated texture is NPOT. For each NPOT texture, the emulator determines whether the texture is set to use mips at block . For each of the one or more textures which is NPOT and set to use mips, the emulator binds a black texture to the respective object and draw the object in black at block . Next, the real glDraw function (as identified in the request) is called at block . The real glDraw function is then used to bind the one or more textures to the respective object identified in the original request at block .","Returning to block , if the variable is equal to 0, the emulator moves to block , and the real glDraw function (as identified in the request) is called. The real glDraw function is then used to bind the one or more textures to the respective object identified in the original request at block .","As these and other variations and combinations of the features discussed above can be utilized without departing from the invention as defined by the claims, the foregoing description of exemplary embodiments should be taken by way of illustration rather than by way of limitation of the invention as defined by the claims. It may also be understood that the provision of examples of the invention (as well as clauses phrased as \u201csuch as,\u201d \u201ce.g.\u201d, \u201cincluding\u201d and the like) should not be interpreted as limiting the invention to the specific examples; rather, the examples are intended to illustrate only some of many possible aspects."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1C"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1D"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 1E"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 1F"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 2B","FIG. 2A"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
