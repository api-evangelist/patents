---
title: Embedding of a non-imperative programming language for data transformation operations within an imperative programming language
abstract: In an embodiment, a method of computer program compilation is presented. In this method, a compiler for a first programming language is provided. In one example, the first programming language allows a data assignment to depend on a result of a previous data assignment. Source code including a first portion written in the first programming language and a second portion written in a second programming language is accessed, with the second portion representing a data transformation from a first data structure accessible in the first portion to a second data structure accessible in the first portion. In one example, the second programming language prevents a data assignment that depends on a result of a previous data assignment. The source code is compiled using the compiler to generate executable code to be executed by an engine for the first programming language, which includes an interpretation engine to interpret the second portion.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09047095&OS=09047095&RS=09047095
owner: SAP SE
number: 09047095
owner_city: Walldorf
owner_country: DE
publication_date: 20110712
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD","BACKGROUND","DETAILED DESCRIPTION"],"p":["The present disclosure relates generally to programming of computer-based systems. In an example embodiment, the disclosure relates to the embedding within a program written in a first programming language source code that is written in a second programming language.","Many different programming languages have been developed over several decades to address a wide variety of applications or problems. Examples of these programming languages include FORTRAN, C, COBOL, LISP, C++, Java, and many others. In many cases, a particular programming language has been developed to address a specific type of application. For example, FORTRAN was primarily developed for mathematical and control system environments, COBOL was intended primarily for business applications, and LISP was directed to list processing tasks. However, given the continually increasing size and complexity of modern computer programs, many cases exist in which no single programming language is ideally suited to address all types of tasks that are to be handled within a single computer program.","The description that follows includes illustrative systems, methods, techniques, instruction sequences, and computing machine program products that embody illustrative embodiments. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide an understanding of various embodiments of the inventive subject matter. It will be evident, however, to those skilled in the art that embodiments of the inventive subject matter may be practiced without these specific details. In general, well-known instruction instances, protocols, structures, and techniques have not been shown in detail.","The embodiments described herein provide various techniques for embedding source code written in one programming language within source code written in another programming language. This capability may allow a computer programmer to write computer program source code in two or more languages within a single program or executable code set. In one example, a programmer may select a first language for a particular set of tasks, and select a second language for another set of tasks.","In the embodiments discussed below, the embedding of one programming language in within another may take multiple forms. In one example, the source code of a second programming language may be provided as text or character strings within the first programming language, with any compilation or interpretation of the second programming language occurring at runtime of the first programming language. In another example, the second programming language may be embedded syntactically within the syntax of the first programming language. To facilitate this type of embedding, the compiler of the first programming language may be extended to compile the source code written in the second programming language, or the compiler of the first language may include, or communicate with, a compiler for the second language, in which case the source code written in the second programming language may be compiled during the compile time of the first programming language. In yet other implementations, some combination of these two examples may be employed.","Computer programs for a variety of environments and applications are often written in an imperative language, such as FORTRAN and C. Similarly, many business and enterprise-resource computer applications are written in. ABAP (Advanced Business Application Programming), created by SAP AG of Walldorf, Germany. Generally, an imperative programming language allows a computer programmer to accomplish computer-related tasks by way of writing a computer program that includes a list of computer-executable statements that are to be executed in a particular order. At least some of the statements, such as statements in which a variable is both an input and an output (for example, the incrementing of a variable) generate \u201cside effects\u201d which alter the current \u201cstate\u201d of the program. As a result, the state of the program at a particular point in time during execution is typically dependent upon the order in which the statements are executed up to that point.","An important task often performed within a computer program is the transformation or mapping of data from one type of data structure to another. This type of transformation occurs, for example, when passing data from one computer program layer to another, such as when calling an application programming interface (API). Examples of this type of data transformation include the mapping of data from hierarchical tables to \u201cflat\u201d or non-hierarchical tables, and vice-versa. At times, the data structures involved may be rather large and\/or complex, thus possibly requiring a significant amount of time to complete the transformation.","To make such data transformations more efficient, optimization of the code performing the transformation may be desired. For example, in some cases, portions of the code may be \u201cparallelized\u201d by being executed on different processors in order to reduce overall execution time. However, when such code is written using an imperative language, the potential for side effects may limit the amount of parallelization and other optimization that is possible. Additionally, any imperative language code that may be optimized may be difficult for an imperative language compiler to determine.","Generally, imperative programming languages are distinguished from declarative programming languages, which typically allow a computer programmer to define the expected results of a program, as opposed to explicitly defining the specific operations, and desired order thereof, to achieve those results. A type of declarative programming language is a functional programming language, in which an output of a function or task is dependent only upon the values of the inputs to that function, as opposed to other outputs of the function. Thus, functional programming generally avoids the generation of side effects to other portions of a function. This lack of side effects allows parallelization and other optimization to be employed more easily for source code written in a declarative language compared to one expressed in an imperative language.","At least some of the embodiments described herein facilitate the embedding of source code written in a non-imperative programming language within source code written in an imperative programming language. By allowing a programmer or programming team to write programming code in such a fashion, legacy imperative source code may be retained and utilized while the programmer develops more time-critical or often-used portions of the source code in a non-imperative programming language to employ parallelization and other optimization techniques more easily, thus enhancing performance of the overall executable code. Such enhancement is especially significant if the compiler for the imperative language is not particularly adept at employing sophisticated optimization techniques found in newer compilers. Other aspects of the embodiments discussed herein may be ascertained from the following detailed description.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","102","100","104","106","108"]},"To allow the interpretation (or compilation) of the second portion  of the source code , the computing system  may include, in one example, a library  that includes a class definition  for the second programming language. In one implementation, the class definition  includes information used to properly interpret (or compile), possibly optimize, and execute the logic represented in the second portion  of the source code . In other implementations, other methods or data structures other than a class definition may be employed to provide the information used to process the second portion  of the source code , such as syntactically embedding the second programming language within the syntax of the first programming language, as described above.","The compiler , in conjunction with the class definition  in the library , compiles the source code  to generate executable code  that may be executed or run on the computing system  or another computing system not shown in . In one example, the executable code  includes or creates an object  representing the programming logic of the second portion  of the source code . Also provided is an execution engine  for the first programming language, which may include, or be coupled with, an interpretation engine  for the second programming language that may perform any interpretation or compilation and optimization of the second portion  of the source code  to yield the object  representing the second portion , and the subsequent execution of the representation of the second portion  in the object . Such an interpretation engine  may be a single instance capable of executing any parts of the executable code  generated from the second portion  of the source code . In one example, all compilation or interpretation, optimization, and execution occurs during runtime of the executable code  after compilation by the first language compiler  has completed. In another example, the second portion  of the source code  may be compiled prior to runtime by way of a second programming language compiler integrated with, or coupled to, the first programming language compiler , as indicated above.","In one example, the second programming language may be a scripting language, such that source code written in the second language is interpreted as it is being executed instead of being compiled completely beforehand. In other embodiments, the second programming language may be a language that is compiled completely before execution begins, as described above. In yet other examples, the second programming language may be one in which the source code is at least partially compiled prior to execution, as mentioned earlier. In cases in which the first programming language is bytecode-based (such as Java\u2122, by Oracle Corporation), the source code for the second programming language may be compiled to the bytecode used for the first programming language.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 2","FIG. 1"],"b":["200","200","100","200","200","202","204","206"]},"In one example, the engine for the first programming language includes, or is coupled to, an interpretation engine to interpret the second portion of the source code during execution of the executable code. As a result, the logic reflected in the second portion of the source code may operate directly upon data structures of the first portion of the source code associated with the first programming language. Such an approach may reduce or eliminate any data serialization or \u201cmarshalling\u201d that may otherwise be necessary to pass data from one execution engine to another. In the examples described in greater detail below, the second programming language is a non-imperative scripting language directed to the transformation or \u201cmapping\u201d of data from a source data structure to a destination (or \u201cresult\u201d) data structure. Typically, transformation operations of this type are notorious for their consumption of processing bandwidth. Also, such functions may be executed repeatedly, especially in computer programs in which the data in one or more data structures are transformed or mapped from one format used by one portion of a program to a significantly different format employed by another portion of the program. Examples of such mappings may include, but are not limited to, mapping a hierarchical data structure to a flat table, mapping a flat table to a hierarchical data structure, mapping a table or hierarchical data structure to another table or hierarchical data structure, and enhancing or modifying a table or hierarchical data structure. However, in other examples, the second programming language may be directed to other specific types of operations, or may be a more general-purpose programming language intended for a wider variety of tasks.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3","b":["300","108","104","300","108","302","108","108","108","108","108","114"]},"In conjunction with, the interpretation or the compilation of the second portion  of the source code , an object may be created for the interpreted or compiled second portion  (operation ). In one example, the created object is an instance of an object-oriented class for the first programming language, with the class defining the programming logic (for example, data structure mapping) of the second portion . The object may include, for example, an evaluation tree representing that logic, as mentioned above.","In one implementation, the interpretation\/compilation of the second portion , and\/or the creation of the object representing the logic of the second portion , may be performed by the interpretation engine  of  during runtime of the executable code . In one example, the second portion  is coded as a character string or other set of data that may then be read and compiled or interpreted via the interpretation engine . Example character strings including the second portion  are discussed in greater detail below in conjunction with .","In one example, at this point in the method , the object and\/or the interpreted or compiled second portion  are not associated with any data typing information that may describe source or destination data structures that may be involved in the desired mapping. Instead, the elements or nodes of a source or destination data structure associated with the mapping may be referred to via an abstraction mechanism involving the use of formal parameters in the second portion . Accordingly, variables or elements of the data structures specified in the first portion  of the source code  may then be bound to the formal parameters of the interpreted or compiled second portion  (operation ). In one example, these bindings are noted in the generated object representing the second portion  of the source code .","By waiting to bind variables (and their types) to formal parameters until runtime of the executable code , mappings may be written for data structures that are created dynamically during runtime. Conversely, other mappings that are generally compiled prior to runtime, such as those written in an imperative programming language, cannot be applied to data types that are dynamically created at runtime. In some implementations, not all of the variables, components, or elements of the data structures associated with the mapping may be bound to a formal parameter, as the second portion  may not reference those variables, components, or elements.","In addition to binding variables to formal parameters, the representation of the second portion  of the source code  may be finalized (operation ). In one example, as part of a finalization process, the interpretation engine  may perform a validity check on the representation or object, such as checking various aspects of the mapping with the variables that have been bound to the formal parameters of the second portion  for validity, such as an assignment of data from one source data type to the same type or a compatible result data type.","As part of the finalization process, the representation of the second portion  (in other words, the mapping) may also be optimized to allow parallelization of multiple mapping operations. In one example, such parallelization may include insertion or copying of multiple lines of a table data structure, insertion or copying of multiple components of a source hierarchical data structure to corresponding components of a result data structure, and\/or the like.","After finalization of the object or representation of the second portion  of the source code , the finalized object or representation may be stored in shared memory so that multiple execution sessions or threads may access and employ the object (operation ). Storing the mapping in such a fashion will prevent the recompilation or reinterpretation of the mapping each time the mapping is to be executed. In one example, the executable code  may maintain an implicit cache of compiled or interpreted mappings for use in multiple threads, user sessions, and so on. In other implementations, the runtime system for the second programming language may cache compiled mappings in a similar fashion for second portions  of the source code  that are executed multiple times.","Also after finalization of the mapping, the mapping may be executed (operation ). In at least some of the examples discussed herein, executable code  generated from the first portion  of the source code  may identify a source data structure and a result data structure, and invoke the mapping generated from the second portion  of the source code  to perform the transformation of data from the source data structure to the result data structure. More generally, multiple source and\/or result data structures may be utilized in a mapping in other examples.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 4","b":"118"},"However, \u201cpull-mode\u201d mappings, in which preexisting data or content of the result data structure controls at least some of the mapping operation, are often useful in cases in which the result data structure is partially or wholly initialized prior to the mapping operation. To allow the use of pull-mode mappings, at least some components of the result data structure may be designated as input or source data while maintaining a non-imperative or functional coding structure. In one example, result data structure components may be designated as \u201cwrite-only\u201d for the mapping operation so that those components may be updated during the mapping, while other result data structure components may be designated as \u201cread-only\u201d so that those components may provide source data to control the mapping process. In marking at least some of the result data structure components in such a manner, the non-imperative nature of the mapping, and the potential benefits of optimization that may follow therefrom, may be maintained. In one example, compilation of the mapping code provides for automatic marking of the data structures based on the initial input and output parameter declarations and inspection of the program constructs. In another example, the user may mark the result data structure components manually.","In , a first result parameter A is shown as a result data structure of type A having two components, COMP1 (of type AS1) and COMP2 (of type AS2). Each of these components COMP1, COMP2 includes two components of element type E, with COMP1 having components M and N, while COMP2 includes two components X and Y. In this example, component M is marked as read-only, indicating that the data in those components may be employed as source data, and thus are not to be written during the mapping. Oppositely, all of component COMP2, including its subcomponents X, Y, is marked as write-only, indicating that X and Y are to be updated during the mapping, and thus are not to provide source data for, or otherwise control or direct, the mapping operation. In one example, the marking of COMP2 as a write-only component causes all subcomponents of COMP2 (in this case, components X and Y) to be marked as write-only as well to ensure consistency in write-only and read-only components to maintain the non-imperative nature of the mapping. In such an implementation, marking a component as read-only will cause all subcomponents or sub-nodes of that component to be designated in a similar fashion.","In , a second result parameter B is a table of type B that includes table lines of type L, with the entire table being marked as write-only. As a result, none of the table serving as the second result parameter B may be employed as a source of data for the mapping operation.","A third result parameter C for the mapping operation is a table of type B that includes a number of lines, with each line including a structure of type CS. Further, each such structure includes two components: component COMP1 (including a structure of type CS1) and COMP2 (including a structure of type CS2). In this example, COMP1 is marked as a read-only component capable of being employed in a pull-mode mapping, while COMP2 is designated as a write-only component, and thus cannot provide source data or otherwise control the mapping operation.","In one implementation, the interpretation engine  determines the designations for at least some of the components of the result data structures based on the context in which each component is employed in the second portion  of the source code . In one example, the interpretation engine  produces an error or exception at the time of compilation of the second portion  if a conflict between read-only and write-only designations occurs. For instance, a component which is designated as read-only that contains a write-only subcomponent (or vice-versa) would cause such a compile-time error or exception. In another example, the programmer may explicitly designate which components are read-only and write-only in the second portion  of the source code , as mentioned above. Also, in some embodiments, not all of the result data structure components need be designated, such as, for example, subcomponent N of the component COMP1 of the first result parameter A. This lack of designation may occur if the component in question is not employed as either a source or result component in the mapping. As a result, component COMP1 of the first result parameter A is a read-write structure, instead of a read-only or write-only structure.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIGS. 5A through 5G","b":["108","104","106","104","108"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 5A","b":["500","108"]},"Shown thereafter is a set of statements of the first portion  of the source code  (written in the first programming language) to employ the second portion  to perform a mapping operation (). Each of the methods or functions shown may be included in the interpretation engine  of  in one implementation. The first of the statements shown in  may cause the creation of an object MAPPER of a class CL_MAPPING using a method CREATE_FROM_SCRIPT based on the input character string LINES, according to some examples described above. As part of the object creation process, the method CL_MAPPING may also perform one or more finalization or optimization tasks, as discussed above. After the object MAPPER is created, a call to a method BIND_SOURCE causes the data structure LV_SRC to be bound to the formal parameter \u2018src\u2019 of the second portion . Similarly, a call to a method BIND_TARGET binds a data structure LV_DST to the formal parameter \u2018dst\u2019 of the second portion . In response to the bindings, further optimization of the resulting executable code may be performed, as some optimizations may not be discoverable until the binding process has been performed. Once the bindings are complete, the first portion  executes the mapping of the LV_SRC data structure to the LV_DST data structure by initiating the method EXECUTE.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 5A","FIG. 5A"],"b":["108","104"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 5B","b":["500","108","108"]},"In the first portion  of the source code  (), the component Z of the data structure LV_DST is initialized with the character \u2018D\u2019. Thereafter, the object MAPPER is created using the CREATE_FROM_SCRIPT method, and the result data structure LV_DST is bound to the formal parameter \u2018dst\u2019 of the second portion, as was performed in the example of . Since no source data structure is specified for this mapping, a call to the method BIND_SOURCE is not performed. After the creation of the object MAPPER and subsequent binding, the mapping is accomplished via a call to the EXECUTE method associated with the MAPPER object. The mapping thus results in the X component of the LV_DST data structure being set to 69190, the Y component being written with the \u2018Walldorf\u2019 character string, and the Z component being cleared in spite of having previously been initialized to the character value \u2018D\u2019.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 5C","FIG. 5A"],"b":["500","108","106","104","108","104"]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 5D","b":"500"},"In the first portion  of the source code  shown in , the KEY.A component of the data structure LV_SRC is set to the 69190 value cited in the second portion . As with other examples discussed above, the MAPPER object is created using the second portion  as input, the LV_SRC data structure is bound to the \u2018src\u2019 formal parameter, an LV_DST data structure is bound to the formal parameter\u2018dst\u2019, and the mapping described in the second portion  is executed. As a result of the mapping operation, the X component of the LV_DST data structure is set to 69190, and the Y component is set to\u2018Walldorf\u2019 in response to the KEY.A component of the LV_SRC data structure holding the value of 69190. Additionally, the Z component of the LV_DST data structure, not having been set as a result of the mapping operation, does not hold a defined value. In another example, the components of all data structures, including the Z component of the LV_DST data structure, would have a type-conforming initial value generated at the time of instantiation of the data structure, such as a zero for numerical data types, NULL for character strings, and so on. In that case, as a result of the mapping of , the Z component of the LV_DST data structure would continue to possess its initial value after the mapping.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 5E","b":["500","108","104"]},"As in previous examples discussed above, a MAPPER object is created using the second portion  of the source code  written in the second programming language, and the LV_SRC data structure is bound to the \u2018src\u2019 formal parameter. Also, a table LT_DST is bound to the\u2018dst_tab\u2019 formal parameter, after which the mapping operation is executed. Presuming the LV_SRC data structure is initialized as shown in the example of  (in other words, the KEY.A component equals 69190, the B component holds the character string\u2018Walldorf\u2019, and the C component holds the character\u2018D\u2019), the mapping operation assigns the 69190 integer to the X component of the first table line of LT_DST, sets the Y component of the second table line of LT_DST to \u2018Walldorf\u2019, and writes the character \u2018D\u2019 to the Z component of the third table line of LT_DST.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 5F"},"In the specific examples of , the parameter\u2018src_tab\u2019 in the \u2018for\u2019 statement and the\u2018dst_tab\u2019 parameter in the \u2018insert\u2019 statements are regarded as \u201ccontext nodes\u201d for the assignment statements listed in the statement block. More specifically,\u2018src_tab\u2019 is a source context node for all source variables within the enclosed \u2018for\u2019 loop of , while\u2018dst_tab\u2019 of  is a result context node for all source or destination variables within the block associated with the \u2018insert\u2019 statement. In some examples, the top-level source context node of the mapping definition is the first source parameter listed in the mapping definition, while the top-level result context node is the first result parameter listed. In at least one implementation, these context nodes help enforce the non-imperative nature of the mapping by ensuring that a source parameter cannot appear on the result side of an assignment, while a result parameter cannot appear on the input side of an assignment. In addition, use of context nodes may greatly simplify the programming of large data structure transformations due to the abbreviated syntax associated with the context nodes.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIG. 5G","FIG. 5G"],"b":"500","sup":["2","2"]},"In the first portion  of the source code  employing the second portion , the MAPPER object is created using the mapping definition, an LT_SRC table and an LT_ITEM table are assigned to the\u2018src_tab\u2019 and\u2018item_tab\u2019 parameters, respectively, and an LT_DST table is assigned to the\u2018dst_tab\u2019 formal parameter. After the bindings are specified, the mapping is executed via the EXECUTE method.","Presuming the presence of at least four \u2018item\u2019 lines in LT_ITEM having a component PARENT.E value of 69190, the mapping iterates through each \u2018src\u2019 line in the LT_SRC table having a component KEY.A with a matching value. Presuming one such \u2018src\u2019 line matches, four separate lines (corresponding to the four \u2018item\u2019 lines in LT_ITEM) are inserted into the LT_DST data structure. Further, for each LT_ITEM line, the X component is assigned the matching KEY.A value of 69190, the Y component is assigned with the component F value of the current \u2018item\u2019 line of LT_ITEM (shown as \u2018Walldorf North\u2019, \u2018Walldorf South\u2019, \u2018Walldorf East\u2019, and \u2018Walldorf West\u2019, respectively), and the Z component is assigned with the component KEY.D value of the current \u2018item\u2019 line (in each case, 1). Thus, specific lines may be inserted and populated based on particular component value matches between the LT_ITEM and LT_SRC data structures.","Other types of statements or operations, such as alternative types of assignments, looping structures, conditional statements, and the like, may also be employed in other examples for the second programming language discussed above. For example, the second programming language may include an explicit serialization command that allows a programmer to specify the execution order of at least two data assignments explicitly. An example of such a command may be \u201cassignment_A THEN assignment_B\u201d. For instance, assignment_A may involve the copying of an input data structure to an output data structure, while assignment_B may cause a particular component of the data structure to then be assigned a different value. Such a serialization command may thus provide information to an optimization process that assignment_A and assignment_B are to be performed in the specified order, similar to what is presumed in an imperative programming language.","In at least some of the examples discussed above, a programmer may possess the ability to write at least some portions of source code in an alternative language other than that directly supported by the compiler. Such capability may allow the programmer to employ the alternative language in cases in which such a language is better suited than the original language for a particular task at hand.","While many of the examples cited above refer to computer programs, such as those that may be executed on a general-purpose computer system, other examples may be employed in other environments, such as embedded computing systems, including those in which a single set of executable code is loaded and executed on the embedded computing system at any one time.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 6","FIG. 6"],"b":["610","612","614","616","618","622","619","617","620"]},"Turning specifically to the enterprise application platform , web servers , and Application Program Interface (API) servers  are coupled to, and provide web and programmatic interfaces to, application servers . The application servers  are, in turn, shown to be coupled to one or more database servers  that may facilitate access to one or more databases . The web servers , Application Program Interface (API) servers , application servers , and database servers  may host cross-functional services . The application servers  may further host domain applications .","The cross-functional services  may provide user services and processes that utilize the enterprise application platform . For example, the cross-functional services  may provide portal services (e.g., web services), database services, and connectivity to the domain applications  for users that operate the client machine , the client\/server machine , and the small device client machine . In addition, the cross-functional services  may provide an environment for delivering enhancements to existing applications and for integrating third party and legacy applications with existing cross-functional services  and domain applications . Further, while the system  shown in  employs a client-server architecture, the present disclosure is of course not limited to such an architecture, and could equally well find application in a distributed, or peer-to-peer, architecture system.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 7","b":["612","612","632","634","632","740","742","744","746","748"]},"The portal modules  may enable a single point of access to other cross-functional services  and domain applications  for the client machine , the small device client machine , and the client\/server machine . The portal modules  may be utilized to process, author, and maintain web pages that present content (e.g., user interface elements and navigational controls) to the user. In addition, the portal modules  may enable user roles, a construct that associates a role with a specialized environment that is utilized by a user to execute tasks, utilize services, and exchange information with other users and within a defined scope. For example, the role may determine the content that is available to the user and the activities that the user may perform. The portal modules  may include, in one implementation, a generation module, a communication module, a receiving module, and a regenerating module. In addition, the portal modules  may comply with web services standards and\/or utilize a variety of Internet technologies, including, but not limited to, Java, J2EE, SAP's Advanced Business Application Programming Language (ABAP) and Web Dynpro, XML, JCA, JAAS, X.509, LDAP, WSDL, WSRR, SOAP, UDDI, and Microsoft.NET.","The relational database modules  may provide support services for access to the database  () that includes a user interface library. The relational database modules  may provide support for object relational mapping, database independence, and distributed computing. The relational database modules  may be utilized to add, delete, update, and manage database elements. In addition, the relational database modules  may comply with database standards and\/or utilize a variety of database technologies including, but not limited to, SQL, SQLDBC, Oracle, MySQL, Unicode, and JDBC.","The connector and messaging modules  may enable communication across different types of messaging systems that are utilized by the cross-functional services  and the domain applications  by providing a common messaging application processing interface. The connector and messaging modules  may enable asynchronous communication on the enterprise application platform .","The Application Program Interface (API) modules  may enable the development of service-based applications by exposing an interface to existing and new applications as services. Repositories may be included in the platform as a central place to find available services when building applications.","The development modules  may provide a development environment for the addition, integration, updating, and extension of software components on the enterprise application platform  without impacting existing cross-functional services  and domain applications .","Turning to the domain applications , the customer relationship management applications  may enable access to and facilitate collecting and storing of relevant personalized information from multiple data sources and business processes. Enterprise personnel that are tasked with developing a buyer into a long-term customer may utilize the customer relationship management applications  to provide assistance to the buyer throughout a customer engagement cycle.","Enterprise personnel may utilize the financial applications  and business processes to track and control financial transactions within the enterprise application platform . The financial applications  may facilitate the execution of operational, analytical and collaborative tasks that are associated with financial management. Specifically, the financial applications  may enable the performance of tasks related to financial accountability, planning, forecasting, and managing the cost of finance.","The human resources applications  may be utilized by enterprise personal and business processes to manage, deploy, and track enterprise personnel. Specifically, the human resources applications  may enable the analysis of human resource issues and facilitate human resource decisions based on real-time information.","The product life cycle management applications  may enable the management of a product throughout the life cycle of the product. For example, the product life cycle management applications  may enable collaborative engineering, custom product development, project management, asset management, and quality management among business partners.","The supply chain management applications  may enable monitoring of performances that are observed in supply chains. The supply chain management applications  may facilitate adherence to production plans and on-time delivery of products and services.","The third-party applications , as well as legacy applications , may be integrated with domain applications  and utilize cross-functional services  on the enterprise application platform .",{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 8","b":"800"},"The machine is capable of executing a set of instructions (sequential or otherwise) that specify actions to be taken by that machine. Further, while only a single machine is illustrated, the term \u201cmachine\u201d shall also be taken to include any collection of machines that individually or jointly execute a set (or multiple sets) of instructions to perform any one or more of the methodologies discussed herein.","The example of the processing system  includes a processor  (for example, a central processing unit (CPU), a graphics processing unit (GPU), or both), a main memory  (for example, random access memory), and static memory  (for example, static random-access memory), which communicate with each other via bus . The processing system  may further include video display unit  (for example, a plasma display, a liquid crystal display (LCD), or a cathode ray tube (CRT)). The processing system  also includes an alphanumeric input device  (for example, a keyboard), a user interface (UI) navigation device  (for example, a mouse), a disk drive unit , a signal generation device  (for example, a speaker), and a network interface device .","The disk drive unit  (a type of non-volatile memory storage) includes a machine-readable medium  on which is stored one or more sets of data structures and instructions  (for example, software) embodying or utilized by any one or more of the methodologies or functions described herein. The data structures and instructions  may also reside, completely or at least partially, within the main memory , the static memory , and\/or within the processor  during execution thereof by processing system , with the main memory  and processor  also constituting machine-readable, tangible media.","The data structures and instructions  may further be transmitted or received over a computer network  via network interface device  utilizing any one of a number of well-known transfer protocols (for example, HyperText Transfer Protocol (HTTP)).","Certain embodiments are described herein as including logic or a number of components, modules, or mechanisms. Modules may constitute either software modules (for example, code embodied on a machine-readable medium or in a transmission signal) or hardware modules. A hardware module is a tangible unit capable of performing certain operations and may be configured or arranged in a certain manner. In example embodiments, one or more computer systems (for example, the processing system ) or one or more hardware modules of a computer system (for example, a processor  or a group of processors) may be configured by software (for example, an application or application portion) as a hardware module that operates to perform certain operations as described herein.","In various embodiments, a hardware module may be implemented mechanically or electronically. For example, a hardware module may include dedicated circuitry or logic that is permanently configured (for example, as a special-purpose processor, such as a field-programmable gate array (FPGA) or an application-specific integrated circuit (ASIC)) to perform certain operations. A hardware module may also include programmable logic or circuitry (for example, as encompassed within a general-purpose processor  or other programmable processor) that is temporarily configured by software to perform certain operations. It will be appreciated that the decision to implement a hardware module mechanically, in dedicated and permanently configured circuitry, or in temporarily configured circuitry (for example, configured by software) may be driven by cost and time considerations.","Accordingly, the term \u201chardware module\u201d should be understood to encompass a tangible entity, be that an entity that is physically constructed, permanently configured (for example, hardwired) or temporarily configured (for example, programmed) to operate in a certain manner and\/or to perform certain operations described herein. Considering embodiments in which hardware modules are temporarily configured (for example, programmed), each of the hardware modules need not be configured or instantiated at any one instance in time. For example, where the hardware modules include a general-purpose processor  that is configured using software, the general-purpose processor  may be configured as respective different hardware modules at different times. Software may accordingly configure a processor , for example, to constitute a particular hardware module at one instance of time and to constitute a different hardware module at a different instance of time.","Modules can provide information to, and receive information from, other modules. For example, the described modules may be regarded as being communicatively coupled. Where multiples of such hardware modules exist contemporaneously, communications may be achieved through signal transmissions (such as, for example, over appropriate circuits and buses) that connect the modules. In embodiments in which multiple modules are configured or instantiated at different times, communications between such modules may be achieved, for example, through the storage and retrieval of information in memory structures to which the multiple modules have access. For example, one module may perform an operation and store the output of that operation in a memory device to which it is communicatively coupled. A further module may then, at a later time, access the memory device to retrieve and process the stored output. Modules may also initiate communications with input or output devices, and can operate on a resource (for example, a collection of information).","The various operations of example methods described herein may be performed, at least partially, by one or more processors  that are temporarily configured (for example, by software) or permanently configured to perform the relevant operations. Whether temporarily or permanently configured, such processors  may constitute processor-implemented modules that operate to perform one or more operations or functions. The modules referred to herein may, in some example embodiments, include processor-implemented modules.","Similarly, the methods described herein may be at least partially processor-implemented. For example, at least some of the operations of a method may be performed by one or more processors  or processor-implemented modules. The performance of certain of the operations may be distributed among the one or more processors , not only residing within a single machine but deployed across a number of machines. In some example embodiments, the processors  may be located in a single location (for example, within a home environment, within an office environment, or as a server farm), while in other embodiments, the processors  may be distributed across a number of locations.","While the embodiments are described with reference to various implementations and exploitations, it will be understood that these embodiments are illustrative and that the scope of claims provided below is not limited to the embodiments described herein. In general, techniques for providing managerial access to a managed system may be implemented with facilities consistent with any hardware system or hardware systems defined herein. Many variations, modifications, additions, and improvements are possible.","Plural instances may be provided for components, operations; or structures described herein as a single instance. Finally, boundaries between various components, operations, and data stores are somewhat arbitrary, and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the claims. In general, structures and functionality presented as separate components in the exemplary configurations may be implemented as a combined structure or component. Similarly, structures and functionality presented as a single component may be implemented as separate components. These and other variations, modifications, additions, and improvements fall within the scope of the claims and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":["The present disclosure is illustrated by way of example and not limitation in the figures of the accompanying drawings, in which like references indicate similar elements and in which:",{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0007","num":"0006"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIGS. 5A through 5G","FIG. 1"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 6","FIG. 1"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
