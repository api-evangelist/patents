---
title: Platform for data aggregation, communication, rule evaluation, and combinations thereof, using templated auto-generation
abstract: Embodiments of the present invention provide platforms for data aggregation, communication, rule evaluation, and combinations thereof. The platform may include three distinct functional layers; a core layer, an adaptive layer and an intelligence layer. Furthermore, the platform may include a data block, messaging block, rule block, or combinations thereof. Generally, the platform may facilitate data acquisition, storage, and manipulation between and among clients and data sources in a generic manner. That is, clients may communicate and make requests independent of a target system or database type. The platform may process the communications and requests in a manner suitable to the target system or database type. The platform may also evaluate rules received from the clients in a manner generic to the client application. Instances of the platform for a given application may be efficiently created using a template-based mechanism. In this manner, the platform may be used to support a variety of end user applications in a flexible, scalable manner.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08402081&OS=08402081&RS=08402081
owner: Atigeo, LLC
number: 08402081
owner_city: Bellevue
owner_country: US
publication_date: 20090225
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION(S)","TECHNICAL FIELD","BACKGROUND","DETAILED DESCRIPTION","Example 1","Example 2","Example 3","Example 4"],"p":["This application claims the benefit of the filing date of U.S. Provisional Application Ser. No. 61\/067,162, filed Feb. 25, 2008, the entire disclosure of which is considered to be part of the disclosure of the instant application and is hereby incorporated by reference herein for any purpose.","Embodiments of the invention relate to methods and systems for robust data handling, in particular generic formulations for dynamically communicating, manipulating, storing, or taking a combination of those actions with a variety of data sources and client types.","Widespread use and acceptance of computer systems has resulted in a proliferation of data. A wide variety of enterprises and individuals generate and store large amounts of data. Data mining and analysis has therefore become increasingly important as people and enterprises try to glean intelligence from their data.","However, data mining and analysis efforts have been hampered by the large and disparate formats in which data may be stored and manipulated. Custom software is typically required to build system-wide solutions that combine data in a particular way, or implement a specific analysis technique.","For example, a retail store seeking to store, mine and analyze their data in a meaningful way faces a variety of challenges. The store may want to collect data from a variety of locations. One source of data is the store itself\u2014inventory on hand, and daily sales, for example. Another source of data are the store's suppliers. The suppliers all may have their own data about inventory availability, price, and selection. The store's customers may also have their own data about their purchase history at that and other stores and demographic data, for example.","Store personnel generally are required to make a variety of decisions\u2014such as which items to order, and how much of each item to order and at what time. Knowledge and the ability to analyze data from all of the above-mentioned sources may be able to aid in this decision, but only if the data is readily available and can be analyzed in accordance with criteria that will be useful to the store personnel.","Creating a software solution that is able to aid the store personnel in a meaningful way may require the ability to interface with the disparate systems that hold the store data, supplier data or data of other external entities, and customer data. Moreover, the software solution must be able to manipulate this information in accordance with the analytical criteria the store personnel would like evaluated.","Of course, many existing software systems aimed to mitigate communication between specific disparate data types or conduct a specific type of analysis on a given set of data. However, software developers routinely focus only on the problem at hand and build a specific software solution to connect the store's database with the database of the supplier, for example. The software itself is likely to depend on the particular data attributes used by the store and the supplier. Similarly, a software developer is likely to build an analytics solution that specifically answers the question posed by the store personnel. The analytics solution may be hardcoded to process the specific attribute types contained in the supplier and store databases, and compute one or a series of specific calculations desired by store personnel.","Accordingly, when the store or the supplier or a customer changes or adds a database type, a data attribute, or when store personnel would like data analyzed in a new manner, the software developer is required to intervene and change the software code used to analyze the data. This process may be cumbersome and it may limit the store's ability to have rich interactions with its data and change the analytical techniques used or the type of data analyzed.","Furthermore, due to the specific nature of the software involved, the store's solution will be unsuitable for another entity trying to perform a completely different data analysis task. For example, the store's inventory software solution would be completely unsuitable for analyzing traffic patterns on a nearby interstate. To handle traffic pattern analysis, the software developer would need to develop a new software solution from the ground up.","A brief summary of challenges in three areas are described below: 1) storing and sharing data amongst different database types; 2) communicating between different and unknown system types; and 3) acting on stored information.","Storing and Sharing Data","A brief overview of database storage and interoperability challenges will be described with reference to . Electronic databases, such as database  in , store data and are configured to access and manipulate the stored data according to various objects specified by the database, such as ObjectA in . An object is generally a collection of data and methods for manipulating the data. The objects may specify a variety of methods for manipulating the data, including methods for creating, reading, updating or deleting data entries in the database. MethodA and MethodB are shown in  associated with ObjectA.","An application programming interface (API)  provides access to the methods in the database . The API , for example, supports MethodA and MethodB used in the database . Clients access the database  by communicating a message  to the API . The message includes one of the functions supported by the API. So, for example, in , Client  passes a message  that includes a request to execute \u2018MethodA\u2019 and parameters for the execution of MethodA. Recall that MethodA is a specific method supported by the database .","Accordingly, the API  may achieve relatively high performance, because little if any manipulation must be performed on the received message  before passing a function call  to the database  to perform MethodA with the enclosed parameters. However, the API  is not very flexible.","For example, if database  stores customer information, ObjectA may refer to a customer, and MethodA may include a method entitled \u2018GetCustomer\u2019 which operates to retrieve a customer number based on an order number and a purchase date. Code used to implement the API  may then include the statement:","int GetCustomer (int OrderNumber, Date Time, PurchaseDate);","\u2018int\u2019 indicates the API is expecting an integer (the customer number) returned from this call. The API also expects an integer order number and a date\/time formatted purchase date to be transmitted along with the request. Message  must then include \u201cGetCustomer (OrderNumber, PurchaseDate)\u201d.","The API then passes the message  as a function call  to the database . Databases have various internal mechanisms for communication and formatting for function calls and parameters including any of a variety of querying languages specific to the database type such as SQL, a relational database query language or the like. The API  is specific to the database  and formats the message  into a proper function call  for the database .","There are several drawbacks to this approach for database communication that become increasingly apparent as databases become increasingly complex and numerous.","A first drawback is that the API  supports only the specific methods supported by the database . Once the source code for the API  is compiled, it becomes a static entity and cannot support any further methods. If the database  is changed to a different database that supports, say, MethodC instead of MethodA, the API  will not be able to generate a function call for MethodC. The API  will need to be rewritten and recompiled to support the new method. This requires that the API  be taken off-line (stopped or taken out of service) while a new API is written, compiled, and put back into service.","Another drawback is that the API  supports only the specific communication language used by the database . The API  only formats messages for a particular database language. Again, if the database  is changed to a different database utilizing some other internal language, the API  must be rewritten and recompiled, requiring time and a suitably skilled operator to perform the update.","The above drawbacks to database communication apply generally to all available database types including relational databases and object-oriented databases. Older database models, such as hierarchical and network models, also have the described drawbacks.","Communicating Between Different or Unknown System Types","As data collection and mining become increasingly important and sophisticated, communicating among complex systems for storing and manipulating data has become difficult. Separate applications or systems have their own internal methods of communicating and syntax and vocabulary for storing and manipulating data. A same or similar procedure may have different names in different databases or systems, for example. One application may want to call that procedure in a variety of different databases.","Present systems handle this communication difficulty by calling the specific procedure name for each system of interest. For example, a code fragment from a first system may call an IOrderFulfillment interface as part of the implementation of a call implementing an interface for accepting orders. An interface is generally a portion of code that receives calls from clients and mediates access to an underlying procedure or data store. The Accept Order class may be coded as follows:",{"@attributes":{"id":"p-0026","num":"0025"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public void AcceptOrder (string Order)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\u2003\u2003IOrderFulfillment iof = new OrderFulfillmnet( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003iof.FulfillOrder(Order);"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This class needs to communicate with the IOrderfulfillment interface, implemented by a second system. The Fulfillment interface may itself need to communicate with a further interface, such as a shipment interface. The second system may encode an order fulfillment interface as follows:",{"@attributes":{"id":"p-0028","num":"0027"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public interface IOrderFulfillment"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003void FulfillOrder (string Order);"]},{"entry":[{},"}"]},{"entry":[{},"public class OrderFulfillment : IOrderFulfillment"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003public void FulfillOrder(string Order)"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003IOrderShipment iof = new OrderShipment( );"]},{"entry":[{},"\u2003\u2003iof.ShipOrder(Order);"]},{"entry":[{},"\u2003\u2003iof = new OrderShipmentEx( );"]},{"entry":[{},"\u2003\u2003iof.ShipOrder(Order);"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The above examples contains two separate calls to an order shipment interface\u2014one to OrderShipment( ) and one to OrderShipmentEx( ). These two consecutive calls are necessary to communicate with a third and fourth system, each of which implement the order shipment interface. One implementation, the third system, codes the order shipment interface as:\n\n","Another implementation, the fourth system, implements the order shipment interface as:\n\n","The second system above was accordingly required to make two consecutive calls, one to the order shipment interface as specifically implemented by the third system and the other to the order shipment interface as specifically implemented by the fourth system. A problem may arise if the third or fourth system, or both, are changed to different or new systems that no longer support the particular format of the calls made by the second system. If the implementation of the shipment interface changes, the implementation of the fulfillment interface of system two must be correspondingly changed and recompiled, which may be undesirable.","Acting on Stored Information","A variety of actions may be desirable using collected, stored data. In particular, an organization or entity may desire to evaluate a variety of conditions on stored data. However, the conditions will vary according to the type of data and the purposes of the requestor. For example, a thermostat application may desire to set a temperature to a warm setting if stored data indicates it is cold outside and it is the morning. This is a simple example of a type of rule that an application may desire to evaluate. The permutations of rules may vary widely according to the end use of an application, and the types of data available.","The common approach to the execution of rules would be to hard code the rule into the software system. So for example, a thermostat application may contain lines of code that are specific to the condition and action described above, that is, to temperature and temperature settings. The code would explicitly recite parameters such as \u2018temperature\u2019 and \u2018set\u2019. Should the users of a temperature application want to implement a different rule\u2014for example, if an occupant is detected in a room, set the temperature to a certain level, or if it is night then set temperature to cold\u2014a new code would be required to implement and evaluate the rule. This may require taking the system offline, preparing code, recompiling the code, and restarting the system.","The above description identifies some of the challenges in supplying a robust, scalable, rule-based expert system. While software may be prepared to interface specific disparate data systems and evaluate rules for a particular given end use, the resultant software application may be no more flexible than before. That is, the software is still confined to the particular use for which it was designed, and the specific systems for which it was designed to integrate. The addition or subtraction of systems, or the revision, addition, or subtraction of rules to be evaluated may require stopping the system, commissioning the preparation of specific new software code, re-compiling the software, and redeploying the software solution. This procedure may be cumbersome and limit the usefulness of any one particular software solution. Ultimately the time involved in a system shutdown, code drafting, re-compiling, and re-deployment, along with additional time for testing, may be prohibitive in designing or deploying a system change.","Certain details are set forth below to provide a sufficient understanding of embodiments of the invention. However, it will be clear to one skilled in the art that embodiments of the invention may be practiced without various of these particular details. In some instances, well-known computer systems and architecture, software operations and protocols have not been shown in detail in order to avoid unnecessarily obscuring the described embodiments of the invention. Embodiments of the present invention may be implemented in all or in part as executable instructions encoded in a computer-readable medium that, when executed, cause one or more processors to perform the functionalities described. In some embodiments, hardware or firmware may be used in all or in part to perform the functionalities.","Section headings may be used in this document. The section headings are intended only as an explanatory guide to the document. The section headings are not meant to imply that all information related to the heading is found in that section, or that no information related to that heading may be found in other sections. To the contrary, embodiments of the present invention provide integrated systems whose individual components may be highly interrelated. Accordingly, information about any one component may impact the functionality and workings of other components. Accordingly, individual components should be interpreted in light of the entire description herein, and their description is not isolated to any one section.",{"@attributes":{"id":"p-0057","num":"0058"},"figref":["FIG. 2","FIG. 2"],"b":["100","100","60","55","50","50","55","60","50","55","60"]},"Generally, then, the layers , ,  represent a conceptual distance from a data source in that the components depicted in the core layer  are process data that is closer to raw data stored in one or more data sources (not shown). These components\u2014such as data, messaging, security and management, in some embodiments manipulate raw data to abstract, communicate, apply security or manage the data. The adaptive layer  may provide some context to the data, providing and manipulating information concerning, for example, preferences, context, and rules and interaction. The intelligence layer  may further add information to enrich the context of the data or transactions involving data. For example, the intelligence layer  may generate knowledge based on the data manipulated by the core layer  and context-enriched by the adaptive layer . The intelligence layer  may uncover or recognize patterns or relationships in the data, or infer additional information about the data based in some examples on both the data and the context or preferences provided by the adaptive layer . Any of a variety of intelligence modules may be used to impart a variety of different types of intelligence to the data gathered and processed by the core layer  and context-enriched by the adaptive layer . Finally, any of a variety of applications  may be written and implemented on any suitable computing device to put the functionality provided by the platform  to one or more specific end uses. Donation functionality and point of service applications, for example, will be described further below. Other applications may be implemented in other embodiments.",{"@attributes":{"id":"p-0059","num":"0060"},"figref":["FIG. 3","FIG. 3"],"b":["100","100","150","140","140","150","150","140","100","150","150","100","100","140","100","100","140","100"]},"As will be described further below, the platform  generally represents an architecture that can implement a rule-based expert system. The platform  communicates, stores, and manipulates data in a generic way such that any number of clients and data sources may be added, deleted, or changed. The platform  may be implemented by one or more computing devices with sufficient memory and software to implement the functionalities described. The platform  includes three components: a data block , a messaging block , and a rule block . Although all three components are shown in the platform , in some embodiments one or more of the blocks may not be implemented. Each of the \u2018blocks\u2019 , , and  generally include one or more processors and associated memory storing encoded software sufficient to perform the described functionalities. One or more of the blocks ,  and  may utilize a same processor and memory in some embodiments. Each of the three blocks , , and  may be implemented by the same, or by different, processors. The three blocks , , and  may be in communication with each other and communicate as generally described below.","Data Block","The data block  generally provides a set of functionality for bringing databases online in a dynamic manner after system initialization, and interacting with those databases. The data block  may utilize web services to interface with functionality encapsulated in stored procedures.  is a schematic illustration of am example of the data block . A client data agent  may communicate with the data block  to generate one or more tables in one or more of the databases . The client data agent  accordingly communicates an XML schema  to the data block . The XML schema  may be used to specify desired structure. As will be described further below, the XML schema  may describe desired data characteristics in a way that is generic to several database types. The data block  may accordingly receive the XML schema  and format the information from the XML schema  in a manner particular to the type of database for which it is destined. For example, the XML schema  may be designed to represent an entity , and the XML schema  may contain information about attributes of the entity  and instructions for and manipulating the entity . So, for example, the resultant table created in one of the databases  by the data block  may include create, read, update, delete (CRUD) functionality for each of the entities, such as the entity . The CRUD functionality may be created by the data block  automatically generating a set of stored procedures  for regulating interactions with the databases . A set of web services  and  are provided in the data block for interaction with the client data application , the client data agent , or both.","Accordingly, the data block  includes a database code generation facility at . The database code generation facility  functions to generate the explicit database code for one or more of the databases  corresponding to the desired database structures represented in the XML schema . Data store integration web services  are provided to interface with the client data agent . Data block  also includes the stored procedures  that may be used to manipulate data in one or more of the databases . In particular, the data block  may maintain a variety of functions for adding additional data sources, structures, or both, including but not limited to: create database, delete database, delete table for entity, create entity, delete entity, update entity, and read entity. Data access web services  are provided for communication with the client data application . In this manner, a flexible web services interface for clients is provided to the data block . By generating database code and storing procedures within the data block , the specifics of the databases  may be transparent to the clients . Accordingly any of the individual databases , , and  may be changed, or new databases added, or one or more databases removed, without requiring any change to the clients . Communication between the data block  and the databases  may occur in any manner. In some embodiments, a traditional configuration file is not used to store connection strings communicated from the clients , such as the connection strings  and . Instead, the data block  uses SOAP messages to interact with the databases . The connections may be specified in SOAP headers, which may be secure SOAP headers in some embodiments.","A system  implementing an example of a data block  according to an embodiment of the present invention is shown in . A generic API creates an interface between a client  and a data source, such as a database . A data engine  processes messages received by the generic API  into function calls for the database . The generic API  supports its own abstracted set of commands, such as \u2018Execute\u2019 as shown in , as will be described in further detail below. A client  sends a message  containing a command supported by the API  (\u2018Execute\u2019 as shown in ) and a payload. The payload will be described further below but generally contains an XML schema including one or more references to a specific method supported by the database . The data engine  processes the message  and generates function calls ,  for the database . In this manner, if the methods of database  change, or database  itself is swapped out for a different database having different methods, the generic API  does not need to be altered or recompiled in any way. Instead, the client  may assemble a different payload for the message  as appropriate.","When the database  responds to the function call, the data engine  may format the response in a manner usable by any programming language able to receive a response from the data engine . When the data engine  is implemented as a web-service, for example, the data engine  will be able to communicate a response to any client  capable of receiving a web service response. For example, the data engine  may format a response as a serialized version of an XML schema that can be de-serialized in any client and programming language that can manipulate XML. Information regarding exceptions and errors may also be included in the returned XML schema response.","An example of a code portion used to implement the generic API  may include a generic statement such as:","object ExecuteMethod (string Payload)","This statement indicates the generic API expects an object returned and will perform an ExecuteMethod procedure using a passed-in payload, which will be of a string type and are described further below. The returned object may be a serialized form of an XML schema instance, for example.","The generic API  may support other methods that are generally variations of ExecuteMethod. Other methods may call into ExecuteMethod. The other methods may be specifically for different types of return data. Return data types may include those specified by ADO.NET, a suite of data access technologies included in the Microsoft .NET Framework. ADO.NET specifies a variety of possible return types including DataSet, Scalar, XML, DataReader, and None. The generic API  may support functions for each of these return types.","The generic API  may be implemented as a web service such that the client , or multiple clients (not shown in ), can communicate with the generic API  from a remote location using http and SOAP protocols. SOAP (Simple Object Access Protocol) is an XML-based protocol for exchanging information and is generic and modular. Accordingly, SOAP may be advantageous when the message  communicated with the generic API  includes XML, as will be described further below.","The generic API  as well as the data engine , which will be described further below, may be implemented using any programming language, including any language that supports the implementation of web services, including but not limited to C#, VB.NET, C++, and Java.","Referring back to , the client  develops a payload for transmission to the generic API . The client  may be a human operator in some embodiments, while in other embodiments the client  is another computer process which generates the message  including the payload. While only one client is shown in , any number may be passing messages to the generic API , simultaneously or at different times. Since the generic API  supports a generic execute command, such as \u201cExecuteMethod\u201d in the code portion above, specific methods to be accessed within the database  are provided in the payload. The payload should include the names of the methods to be called and any necessary parameters for calling the methods. The payload is formatted in a manner such that the data engine can process the payload and format the information contained in the payload into the function calls  and , for example, for the database .","A schematic illustration of an embodiment of a payload  is shown in . The schema payload includes a reference to MethodA at payload element  and reference to MethodB at payload element . MethodA includes references to Parameter and Parameter at elements  and . A trigger indicator referenced in element  indicates an end of the parameters for MethodA. The Parameter and Parameter references have associated metadata including type attributes referenced in elements ,  and values referenced in elements , . Metadata is information about data and includes the type attributes described. Metadata may also include other information about data. Accordingly, other metadata, such as a direction attribute, may be included in other embodiments, and some attributes may not be included in other embodiments of schema payloads. For example, one or more parameters may be associated with a method in a schema payload that indicates an anticipated return type of the method. The return type parameter will not have a value associated with it.","MethodB includes Parameter referenced in element  having type and value, referenced in elements  and , respectively. Trigger indicator referenced in elements  indicates an end of the parameters for MethodB. Any number of methods may generally be referenced in a schema payload, and multiple instances of a same method may be included as well. The payload  may be implemented as an XML schema and coded accordingly. The trigger indicators  and  may be implemented by, for example, the end method tags of an XML schema, where element , a start of a method reference may be implemented by a <method> tag and trigger indicator  implemented as an <\/method> tag.","An example of an XML schema that may be utilized as the payload  to implement a \u201cGetCustomer\u201d method using an order number and a purchase date is as follows:",{"@attributes":{"id":"p-0075","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003<Method Name = \u201cGetCustomer\u201d>"},{"entry":"\u2003\u2003<Parameter Name= \u201cOrderNumber\u201d Type= \u201cint\u201d Direction= \u201cIn\u201d>"},{"entry":"\u2003\u2003123"},{"entry":"<\/Parameter>"},{"entry":"\u2003\u2003<Parameter Name= \u201cPurchaseDate\u201d Type= \u201cDateTime\u201d> 2005-03-18"},{"entry":"<\/Parameter>"},{"entry":"\u2003\u2003<Parameter Name= \u201cReturn\u201d Type= \u201cint\u201d Direction= \u201cout\u201d>"},{"entry":"\u2003\u2003<\/Parameter>"},{"entry":"\u2003\u2003<\/Method>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The above XML schema payload specifies a method GetCustomer containing parameters OrderNumber and PurchaseDate. The OrderNumber parameter in the schema above is of an integer type. The Direction parameter indicates the parameter passed in has meaning for the call into the API (not the return). In the above example, \u2018123\u2019 is the order number being passed in. The PurchaseDate parameter in the schema above is of the type DateTime, and the date 2005 Mar. 18 is being passed to the API. The parameter Return in the example schema above indicates that a return type of integer is expected. <\/Method> is a trigger indicator indicating an end of the information associated with that method.","Referring back again to , once the payload is received by the generic API , the data engine  processes the payload to formulate specific function calls ,  for the database .","An embodiment of a method  for operation of the data engine to process the payload  is shown in . The payload  may be loaded  into memory for faster access if desired. In some embodiments, only a portion of the payload is loaded into memory accessible to the data engine, and that portion is traversed. The data engine then traverses  the payload by loading a portion of the payload into memory and processing the portion in memory. As the traversing proceeds, a next portion of the payload may be loaded into memory for traversal, and so on, until the entire payload has been traversed. The data engine can implement a MemoryStream function to examine the payload from memory. The processed portion is then offloaded, and the next portion of the payload may be loaded into memory and processed. In other embodiments, the payload may be parsed by the data engine. The data engine parses the payload by validating the entire payload and loading it all into memory.","Traversing rather than parsing can increase the performance of the data engine . In one embodiment where the data engine  is implemented in a Microsoft NET Framework, the data engine  uses an XMLTextReader to traverse  the payload. The traversing operation may not perform data validation typically done when reading XML, and does not parse the XML types as it goes, they are simply read.","As the payload is traversed , the data engine  identifies  the start of a method call, such as MethodA  in . In some embodiments, the actual name of the method call is passed in, such as MethodA  and the data engine  will utilize this name in the function call  in  for the database. However, in other embodiments only a portion of a name of the method call is passed and the data engine  may reformat the name contained in element  of  into an actual function call supported by the database by, for example, adding suffixes or other characters, as will be described further below. Information regarding how to reformat the name in element  into a function call name may be included in a data template, described further below.","Once the start of the method call is identified, the data engine  assembles  parameters associated with the method call. Referring back to , for example, Parameter along with its metadata is unpacked from the payload  and stored as a properly formatted parameter for a function call. When traversing an XML schema, for example, a stored parameter may be generated for each portion of the XML schema following the method indication. The properly formatted parameter may be temporarily stored as objects. As described further below, the stored parameters are communicated to the database, and then they may be discarded. In some embodiments, the data engine may check the stored parameters to determine if the parameters are complete, and if a parameter is missing an element, or if the method name is faulty, the information related to the faulty method or parameter in the payload may be discarded or skipped.","As the data engine continues to process the payload, a trigger indicator is then identified , such as the indicator  in . Once the trigger indicator is identified, the data engine  calls  the identified method using the parameters assembled . The data engine  then identifies  a next method call in the payload, and the process shown in  may repeat.","Structurally, embodiments of the data engine , shown in , may include a processor coupled to a computer-readable medium containing executable code causing the processor to perform any or all of the actions shown in  and described with reference to . The data engine  may be implemented in software, hardware or combinations thereof. Embodiments of the data engine  may be implemented as a web service and accessed using http, including the use of SOAP transport for communicating XML. The processor implementing the data engine  may be the same as that implementing the generic API  in some embodiments.","Accordingly, the above description has provided an explanation of how a data engine may support a generic API to receive messages including a payload and process the payload into one or more specific function calls to a database. By providing a generic API, the generic API need not be recompiled or rewritten when one or more client entities want to communicate new or different calls to the API. However, as described above with reference to , existing APIs are coded to format function calls in a particular language depending on the type of database for which the call is destined\u2014such as Oracle, SQL, or the like. The data engine  may also provide functionality to flexibly format function calls for any of a variety of databases as will now be described. In this manner, the generic API  also need not be recompiled or rewritten if the type of target database changes.","When a data engine receives a payload destined to apply to a certain type of target database, the data engine can formulate the method calls to the target database in a manner specific to the type of the target database. Database types may include, for example, Oracle, SQL, or any other database type or format. To do this, the data engine should receive an indication of the target entity. With reference to , an indication of a target database type  may be communicated by the client  to the data engine . The data engine  may receive the target type indication  in a variety of ways. In one embodiment, the data engine  identifies the type of database by reading a configuration file accessible to the data engine. For example, when the data engine is implemented as a web service, a connection string to any OLEDB (Object Linking and Embedding Database), including Oracle and SQL, may be used as a web.config setting. The data engine web service could then read the web.config setting at each call, or at other periods in some embodiments. In some embodiments, the data engine determines the target database type by referencing the configuration file on a default basis. That is, if no other target database indication is provided, the data engine may use the target database type specified in a configuration file accessible to the data engine.","In other embodiments, the indicator  of the target database type is transmitted in parallel with the message . When the client  communicates with the data engine  over http, a SOAP header may be used to pass the indicator . The SOAP header can be inspected on a call-by-call basis. The SOAP header may be prepared using a connection string in a configuration file residing with the client . The data engine may inspect the SOAP header to determine the type of the target database on every call, in some embodiments or periodically according to the particular implementation and use of the data engine.","When the type of database to be involved changes, the client  can change the indicator  or transmit a new indicator  without changing the message  or the process of communicating the payload. The SOAP header or configuration file is simply updated to indicate the new or different target database. The data engine  uses the target type indicator  to change the way data unpacked from the message  is formatted into individual calls ,  to the target database. Thus, formulating a request to a new or different database type does not require recompilation of any code within the data engine. The type of target can thus be changed without changing the payload or re-compiling the generic API executed by the data engine. A new template may simply be used, as described further below, that allows the data engine  to format the call in a manner appropriate for the new target type.","To facilitate formatting function calls in accordance with any of a variety of possible database types, as indicated by the target type , templates are provided in a template memory  in communication with the data engine . The template memory  may be integral with a computing system used to implement the data engine , or may be a separate data storage subsystem. The template memory  contains templates describing how method calls are formatted for each of a variety of database types. In some embodiments, the template further describes how data may be manipulated within each database (for example, create, read, update, delete and other operations). The data template may describe how each operation maps into specific commands for the target database type. Data templates may be implemented as XML schemas. In some embodiments, the data templates advantageously require a small amount of memory such that they are able to be stored in cache memory. Of course, the size of the cache memory will be dependent on the availability and cost of the memory. As an example of the size of a data template, in some embodiments, a data template suitable to prepare messages for a SQL server is less than 4 kilobytes.","Any number of data templates may be provided, with typically one data template per database type with which the data engine may have to access or communicate. In some embodiments where certain functions of different database types are identical, the database types may share a single data template. Data templates may be deleted when a certain database type is no longer needed or desired. Data templates may be added when a database type is added or anticipated. Accordingly, when a destination database type changes, or a new database is added, a new template may simply be added to the template memory  without a need to recompile the generic API  or change the operation of the data engine .","An embodiment of a method  implemented by the data engine  to generate a function call is schematically depicted in . The data engine receives  an indicator of the target type, as described above. The data engine may then load  a data template corresponding to the target type into a cache or other accessible memory for faster access. If the data template has already been loaded due to a pre-loading procedure or recent use, for example, the data template need not be reloaded. Alternatively, the data engine could access the data template at a remote location without loading the template into the cache.","The data engine then traverses  the data template, to unpack the template  and generate statements specialized to the database type. The statements  are then used by the data engine in combination with data received in the payload, described above, to generate a method call for the database, as generally described above with reference to . That is, with reference to , once the data engine has identified a method call and assembled parameters from a payload, the data engine may utilize database specific statements generated from a data template to generate an appropriate method name for the target database and format parameters for the target database. So, for a single input payload, the data engine could generate any of a variety of statements, based on the data template used to format the information extracted from the payload.","Accordingly, embodiments of data engines and generic APIs have been described above that allow flexible communication with a variety of databases. Any method call may be handled by the generic API without recompilation, at least in part because the data engine extracts specific method names from a payload. Additionally, the payload may be formatted for any destination database type in accordance with data templates. Embodiments of data engines according to the present invention may provide functionality beyond the formatting of method calls, however, to include an auto-generation functionality. The data engine itself may perform the auto-generation functionality in some embodiments, or a separate auto-generation engine may be provided operating on a same or different processor than the data engine.","As known, databases may contain various database-specific objects that impart additional functionality to the database. An API specific to the database type has been traditionally required to access or utilize these database-specific objects and a database administrator was typically required in prior systems to generate new objects in a target database. However, an embodiment of an auto-generation engine according to the present invention may generate data templates for any database object, allowing their use by the data engine as described above. Additionally, using embodiments of a data engine and auto-generation engine, such as the auto-generation engine  in , objects may be automatically generated in a target database, including tables, procedures, indices and triggers. In this manner, new objects and entities can be supported without specific database administrator intervention.","To facilitate auto-generation functionality, one or more database templates for the implementation of commands in a target database are generated. These templates describing command implementations may be XML schemas and may be stored in the template memory  in . Alternatively, the templates may be stored in one or more target databases or other content-management system. An embodiment of a method  for creating a template for database commands is shown in . One or more commands are identified for implementation . Generally, any command supported in an API may be manipulated according to the method  of  by analyzing the command, identifying and retaining static content and replacing variables with placeholders. Accordingly, to identify commands , commands of interest are selected from a particular API. For example, some database types (such as Oracle) support various APIs or versions of a database engine, and some (such as SQL) support various language syntaxes. Generally, any API and\/or syntax may be supported according to embodiments of the present invention. The particular commands identified  may include, for example, create, insert, retrieve, select, update, procedure, trigger, index, function, getmail, sendmail, and the like.","A template is then be generated . The template may be an XML schema including an element for each command identified. Any XML editor or other program may be used to generate the statement template, such as Visual Studio XML Schema Editor or XMLSpy. Each command identified  will be included as an element in the template. An example of a database template  is shown in . A statement  of the template  includes a formatted command  with placeholders for the variable information. The statement  also includes a reference  to one or more placeholder templates describing how to format information to replace the placeholder contained in the formatted command . The database template  further includes a placeholder template . The placeholder template  includes a format  and a fieldmask  which together will describe how to generate a string using input data to replace the placeholders in the formatted command . Although only one statement  and placeholder template  are shown in , any number may be generated.","Once the template  is generated including elements for each desired command and elements for each placeholder, referring back to , the template is included for placeholder formatting  and then stored  in a location accessible to the auto-generation engine. The templates may be stored in the file system, or in some embodiments, in a database or a content-management system. The templates will be used subsequently as described below to generate objects within various target databases.","Once templates are generated as described above and with reference to , a processing engine, such as the data engine  may utilize the template to generate structures in a target database. By utilizing the templates, a client or other transmitting entity can cause a structure or procedure to be stored in a database, without requiring knowledge of the particular syntax necessary to create the structure or procedure in the database.","Operation of an auto-generation engine is described with reference to , and a detailed example of one embodiment is provided below. A payload is received . The payload is similar to data payloads described above and depicted in , but contains different information. An example of a payload  is shown in . The payload  is an XML schema containing an entity name element  and a plurality of attribute elements - associated with the entity element . Each of the attribute elements - may include one or more parameters. Although only one entity element  is shown in the payload , a number of elements may be included, and each element may generally have any number of attributes.","Following a call into the generic API and the receipt of the payload  (), an appropriate database template is loaded  into memory. As described above with respect to the data engine and data templates, an indication of the target database type may be received in a variety of ways, for example by loading a web.config file or by inspecting SOAP headers. The template may be loaded from cache, or if not in cache, the template may be loaded from the file system or any other stored location, including a statement template repository which may be the same or different than the template memory  in . The auto-generation engine prepares completed statements  for execution by looping through the database template  of . Placeholders in the formatted statement  are replaced with information from the payload  of  as directed by the placeholder templates . Generally, the format element  of the placeholder template  provides a format, including any delimiting characters or other syntax. The fieldmask element  specifies which parameters of the attributes - from the payload  of  should be inserted into the format  and in which order. Parameters from each of the attributes - are formatted according to the placeholder template  and replace the placeholder in the formatted statement . Once all placeholders are replaced and the statement is complete, the statement is executed , referring back to , generating objects in the target database. The statement is executed in one embodiment by the processing capabilities of the target database. In another embodiment, the auto-generation engine executes the statements, generating the objects in the target database. For example, a table, procedure, email folder or PL SQL package may be stored in the target database in accordance with the executed statements. Once stored in the target database, the objects may be populated, called, or otherwise used by any process, including a data engine, as described above.","A detailed example of operation of an embodiment of an auto-generation engine is now described to aid understanding.","A XML schema used as a payload passed to the auto-generation engine may include:",{"@attributes":{"id":"p-0102","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<EntitySchema Entity=\u201cProvider\u201d xmlns=\u201chttp:\/\/tempuri.org\/"]},{"entry":[{},"DBSchema.xsd\u201d>"]},{"entry":[{},"<Attribute Name=\u201cProviderID\u201d Type=\u201cuniqueidentifier\u201d Size=\u201c\u201d"]},{"entry":[{},"Null=\u201cNOT NULL\u201d Default=\u201cDEFAULT (NEWID( ))\u201d ID=\u201c0\u201d"]},{"entry":[{},"Key=\u201cNonKey\u201d \/>"]},{"entry":[{},"<Attribute Name=\u201cProviderName\u201d Type=\u201cnvarchar\u201d Size=\u201c(50)\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Null=\u201cNOT NULL\u201d"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Default=\u201cDEFAULT (\u2018Name\u2019)\u201d ID=\u201c1\u201d Key=\u201cNonKey\u201d \/>"]},{"entry":[{},"<Attribute Name=\u201cProviderDescription\u201d Type=\u201cnvarchar\u201d"]},{"entry":[{},"Size=\u201c(255)\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Null=\u201cNOT"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NULL\u201d Default=\u201cDEFAULT (\u2018Provider\u2019)\u201d ID=\u201c2\u201d"]},{"entry":[{},"Key=\u201cNonKey\u201d \/>"]},{"entry":[{},"- <Constraint ConstraintString=\u201c\u201d Type=\u201cPRIMARY KEY\u201d"]},{"entry":[{},"TemplateID=\u201c9\u201d>"]},{"entry":[{},"<Format>,CONSTRAINT PK_ut{0} PRIMARY KEY"]},{"entry":[{},"CLUSTERED"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"({1})<\/Format>"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<AttributeID>0<\/AttributeID>"]},{"entry":[{},"<\/Constraint>"]},{"entry":[{},"<\/EntitySchema>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The above payload is designed to trigger the creation of a \u201cProvider\u201d entity in a target database. The attributes of the \u201cProvider\u201d entity are \u201cProviderID, ProviderName and ProviderDescription.\u201d Each attribute has a variety of associated parameters, as listed in the payload.","A first statement in a database template used to process this payload may include:",{"@attributes":{"id":"p-0105","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Statement HasConstraints=\u201ctrue\u201d HasBusinessRule=\u201cfalse\u201d>"]},{"entry":[{},"<Format>create table ut{0} ({1} {2})<\/Format>"]},{"entry":[{},"<Attributes ID=\u201c0\u201d AttributesString=\u201c\u201d TemplateID=\u201c0\u201d \/>"]},{"entry":[{},"<\/Statement>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The formatted statement is \u201ccreate table ut\u201d with various placeholders indicated between the { } brackets. The first {0} placeholder is replaced with the entity name \u201cProvider\u201d. The Attributes ID and TemplateID specifies how to process the attributes of the payload for insertion into the {1} placeholder. Here, the TemplateID 0 will be used to process the attributes.","TemplateID 0 may be contained as an element within the template and may include:",{"@attributes":{"id":"p-0108","num":"0109"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Template ID=\u201c0\u201d Sepparator=\u201c,\u201d>"]},{"entry":[{},"<Format>{0} {1}{2} {3} {4}<\/Format>"]},{"entry":[{},"<FieldsMask>:Name,Type,Size,Null,Default<\/FieldsMask>"]},{"entry":[{},"<\/Template>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"For each attribute, this template will be used to format the attribute's parameters by replacing the placeholder in the format statement with the payload information corresponding to the fieldsmask indicator. In the example above, for the ProviderID attribute, this would result in \u201cProviderID uniqueidentifier <Size not specified> NOT NULL DEFAULT NEWID( )\u201d. A similar string is generated for each attribute, and the collection of strings is used to replace the {1} value in the create table template statement, above.","A next statement in the template may be:",{"@attributes":{"id":"p-0111","num":"0112"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Statement HasConstraints=\u201cfalse\u201d HasBusinessRule=\u201cfalse\u201d>"]},{"entry":[{},"<Format>create procedure uspCreate{0} ({1}) AS INSERT INTO"]},{"entry":[{},"ut{0} ({2}) VALUES ({3})<\/Format>"]},{"entry":[{},"<Attributes ID=\u201c0\u201d AttributesString=\u201c\u201d TemplateID=\u201c1\u201d \/>"]},{"entry":[{},"<Attributes ID=\u201c1\u201d AttributesString=\u201c\u201d TemplateID=\u201c2\u201d \/>"]},{"entry":[{},"<Attributes ID=\u201c2\u201d AttributesString=\u201c\u201d TemplateID=\u201c3\u201d \/>"]},{"entry":[{},"<\/Statement>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The placeholder {0} is replaced with the entity name from the payload, \u201cProvider\u201d, resulting in \u201ccreate procedure uspCreateProvider\u201d. Then, the attributes (ProviderID, ProviderName, ProviderDescription) are processed according to TemplateID 1, as indicated by the Attributes ID line for insertion into the {1} placeholder. TemplateID 1 may include:",{"@attributes":{"id":"p-0113","num":"0114"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Template ID=\u201c1\u201d Sepparator=\u201c,\u201d>"]},{"entry":[{},"<Format>@{0} {1}{2} {3}<\/Format>"]},{"entry":[{},"<FieldsMask>:Name,Type,Size,Input<\/FieldsMask>"]},{"entry":[{},"<\/Template>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This results in a string being generated for each attribute in the payload as described above. For ProviderID, the string would be \u201c@ProviderID uniqueidentifier IN\u201d. The strings generated with each attribute are concatenated and inserted into the {1} placeholder. The next placeholder in the statement is processed according to Template ID 2 which may include:",{"@attributes":{"id":"p-0115","num":"0116"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Template ID=\u201c2\u201d Sepparator=\u201c,\u201d>"]},{"entry":[{},"<Format>{0}<\/Format>"]},{"entry":[{},"<FieldsMask>:Name<\/FieldsMask>"]},{"entry":[{},"<\/Template>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The string generated for ProviderID would simply be \u201cProviderID\u201d. The string generated for each attribute is concatenated and inserted into placeholder {2}.","The attributes are then processed according to Template ID 3, which may include:",{"@attributes":{"id":"p-0118","num":"0119"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Template ID=\u201c3\u201d Sepparator=\u201c,\u201d>"]},{"entry":[{},"<Format>@{0}<\/Format>"]},{"entry":[{},"<FieldsMask>:Name<\/FieldsMask>"]},{"entry":[{},"<\/Template>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The string generated for the Provider attribute would be \u201c@Provider\u201d. Again, the strings for all the attributes are concatenated and inserted into the {3} placeholder. Ultimately, after replacing all placeholders the overall statement created will be:","create procedure uspCreateProvider (@ProviderID unigueidenfifier IN, @ProviderName nvarchar(50) IN, @ProviderDescription nvarchar(255) IN) AS INSERT INTO utProvider (ProviderID, ProviderName, ProviderDescription) VALUES (@Provider, @ProviderName, @ProviderDescription)","This statement can be executed to generate a procedure in a target database. This procedure may later be used by other engines or programs accessing the database. This alleviates the need for a database administrator to manually establish the procedure in the database. Once the information is passed to the API as a payload, the auto-generation engine automatically creates the appropriate procedure in an end database.","Embodiments of the present invention provide data handling platforms, which may be included in system  shown in  including or running an embodiment of a data engine  as described herein. The data engine  may include one or more processors or other computational cores that process requests received from any type of client, including clients ,  and  in . The clients may include, for example, a user through a user interface, or some other process, program or machine transmitting information to the data engine . Any of the requesting entities ,  and  may communicate with the data engine over any known means of communication, wired or wireless, electronic or optical. In some embodiments, the sending entity may communicate with the data engine over http and utilize SOAP headers, as described above. Embodiments of data engines described herein, such as data engine , may advantageously be implemented as a web service. Generally any programming language may be used, including any language that supports the implementation of web services, including but not limited to C#, VB.NET, C++, and Java. Implementing the data engine as a web service allows any transmitting or receiving entity to communicate with the data engine easily in a well-known, scalable manner. The data engine  is able to process incoming messages according to embodiments of methods described above with reference.","One instance of the data engine  is sufficient in some embodiments to service any number of sending entity requests to any number of available databases. Three available databases, ,  and  are shown in . Of course, the number of clients, databases, and requests to be served is a function of the ultimate application of the system and speed of the processor(s) used by the data engine, as well as the speed of the communication interfaces. Embodiments of the data engine may generally be implemented to interface with any system-level software platforms including, but not limited to, Windows, Linux and Java. Memory , or other computer-readable medium, may be coupled to or form part of the data engine . The memory  may contain the executable code causing the data engine  to perform the various functions described herein. Further template memory  stores data templates as described above. The template memory  may be separate from the memory  or they may be combined. A cache (not shown) may also be coupled to the data engine for storing loaded templates from the template memory , although in some cases the cache may be included in the memory  or the template memory  itself.","As was described generally above with reference to , the data engine may be part of a larger data handling platform  in some embodiments\u2014with other portions of the data handling platform provided to communicate messages, and take action on the data. To communicate with other components of the data handling platform , the data block  may be configured to publish messages to a shared message bus, as will be described further below, and may be subscribed to receive certain types of messages that may be published by other components or systems to a shared message bus. For example, in some examples, when the data block  stores a new data item, it may publish a message indicating that a new data item has been stored. Other systems or components that may need to take action based on that data item are subscribed to that type of message, and may be so notified by a messaging block, examples of which are described below.","Messaging Block","Examples of a data block have been described above that may facilitate interaction with one or more database types in a generic manner. That is, the data block provides the specific interaction with an end database. The client need not know, or provide software code specific to, the end database to be manipulated. Referring back to , the data block  may accordingly provide an interface between one or more of the clients  for placing data into one or more of the data sources . One or more of the clients  may want to communicate with one another, such as by calling software procedures that one or more of the clients  provides. As was generally described above, a typical software approach to hard coding interactions between one or more of the clients  may limit the ability of the system to change without requiring significant code rewrites. Accordingly, a message broker capable of calling methods independent of the syntax of the end system called may be used. The messaging block  may provide such a message broker functionality.",{"@attributes":{"id":"p-0126","num":"0127"},"figref":"FIG. 14","b":["120","120","1310","1310","140","140","140","140","1310","1310","110","130","1310","1310"],"i":["b ","c ","b ","c"]},"Event schemas  are stored in a memory accessible to or part of the message bus . Each of the event schemas  provides associated database infrastructure so messages received of the event type specified in the schema may be created and utilized by one or more publishers . Each of the event schemas  may accordingly come to be associated with one or more of the publishers . The publishers  are stored data structures representing a source of an event or message. So, for example, if the client will be sending messages to the message bus , the client may establish one or more publishers . Publishers  may be stored in the form of XML arrays to facilitate the use of SOAP in embodiments of the present invention. A publisher may be notified by the message bus  of responses to the publishing of an event. Accordingly, a uniform resource identifier (URI) or other mechanism for notifying a publisher may be stored.","Publishers may create a message by calling a publisher subscriber web service \u201cCreateEvent\u201d. The web service may be implemented by the messaging block . An entry may be made in a specific event table related to an event schema. A trigger on the event table inserts data into a notification table that may include a time dispatched. The message bus  may include a router that polls for the notifications  and ensures that messages are dispatched in a timely fashion.","Subscribers  are data structures containing information about a destination of a message or event. Similarly to publishers, , each subscriber  may include a uniform resource identifier (URI) or other mechanism for notifying a subscriber. For example, the URI for a subscriber may be a web page where a subscriber manages a plurality of subscriptions. So, for example, a client interested in receiving messages from the message bus  may establish one or more subscribers . Each of the subscribers  may be subscribed to messages from one or more of the publishers . Subscribers  may be stored in the form of XML arrays to facilitate the use of SOAP. Accordingly, clients interested in passing messages to the message bus  may establish one or more publishers  capable of publishing events having a type corresponding to one or more of the event schemas . Clients interested in receiving messages from the message bus  may establish one or more subscribers . A client may establish both publishers and subscribers to both send and receive messages.","To notify one or more subscribers , a message bus router included in the message bus  may call a notify function of an event notification web service. A notification URI may be overridden with a subscription URI for each event. In return, subscribers  may call an acknowledgement web service to acknowledge receiving the message.","A message received from a publisher  may be stored at the message bus . The entire message may be stored, or in some embodiments, only events  contained in the message are stored, as will be described further below. The message bus  determines where to send the message based on subscriptions . The subscriptions  are data structures containing information about a subscription, that may refer back to a subscriber and a type of message the subscriber is interested in receiving, such as one or more of the event schemas . Other information, such as a filtering mechanism, may also be included in the subscriptions . The message bus  may maintain the subscriptions . Individual subscriptions may be added or deleted without altering or interrupting the general functionality of the message bus . By adding a new subscription, or altering a subscription stored in the subscriptions , the message bus  will begin to route messages differently, without any of the code for the operation of the message bus  having to be altered. By way of summary, the message bus  receives a messages, stores at least part of the message, consults the subscriptions  to determine which subscribers  are interested in messages of the type received, and then generates notifications  for the interested subscribers. Accordingly, while clients may be affected by the content of messages, they may pass messages only to and from the messaging block  in embodiments of the invention, and may not need to communicate with any other client directly. In some embodiments of the present invention clients may never communicate with other clients directly, and all communication may be routed through the messaging block .","By storing messages, or portions of messages, at the message bus  and verifying notifications , the message bus  may ensure that communication is accurate and continuous. Furthermore, by storing the events , scalability and fault tolerance of the system may be improved relative to a system where such information is not persisted. For example, storing messages may prevent or reduce the incidence of lost messages due to a failure of communication with a particular client. Instead, the message may be stored until it may be properly delivered. Publishers and subscribers may expose functionality corresponding to object methods as web services. Objects that access these methods may be shared across clients as similar objects expressed as serialized XML and translated to language specific objects as needed by clients.","Accordingly, clients may communicate messages to the message bus . The messages may be SOAP messages in some embodiments.  is a schematic illustration of a message  according to an embodiment of the present invention. The message  includes an event identifier . The event identifier specifies the type of event, and may correspond to one of the event schemas  of . The message  further includes a decoder XML schema . The decoder XML schema indicates how to decode the message . That is, when the message bus  receives the message , the message bus  may decode the message  in accordance with the decoder XML schema . The message  further includes XML content . The XML content  describes the event, and may be wrapped in a CDATA section, such that it may not be processed itself by the message bus . The generation and processing of messages includes the generation of XML schema content that may in some embodiments be analogous to the generation and processing of XML schema content described above with respect to the data block . The message  further includes a publisher identifier  that may include a URI corresponding to the publisher having posted the event. Messages and notifications sent by the message bus  to client systems may have an analogous structure. In some embodiments, messages may be encrypted so that only authorized subscribers or client may access messages. Generally, any encryption methods may be used.","The messaging block  may include an API that implements a variety of functionalities to maintain the publishers, subscribers, and subscriptions described above with reference to . For example, an API implemented by the messaging block  may include, but is not limited to, some or all of the following procedures: CreatePublisher, ReadPublisher, DeletePublisher, CreateSubscriber, ReadSubscriber, DeleteSubscriber, CreateSubscription, ReadSubscription, DeleteSubscription, and CreateEvent. In one example, a user at a client may prepare an XML payload representing a publisher, subscriber, or subscription schema. The user then selects a function of the API, such as CreatePublisher, to operate on the XML payload. A simple user interface may be provided at the client system to facilitate this entry, which may include a text box for entry of the XML payload and a plurality of buttons corresponding to each of the methods implemented by the API, such as \u201cCreatePublisher.\u201d Once selected, the API may de-serialize the XML instance entered by the user into an appropriate object of a code type used by the messaging block , such as, but not limited to, C#. The API is again called using the generated object, and appropriate objects for the messaging engine  may be created. For example, the API of the messaging block  may then return an XML result of the call and update the XML payload with any specific object names and formatting used by the messaging block , the message bus , or both, in processing the request represented by the XML payload. For example, the XML payload may be processed by any of the methods implemented in the API to have the syntax usable by any type of messaging engine, such as a BizTalk messaging engine. Because the API providing the object names and syntax is implemented by the messaging block , the client system and need not be aware of the particular syntax or object names in order to establish a publisher, subscriber, or subscription. Detailed code examples of methods implemented by the API are provided below in the examples section. The examples are not intended to limit the use of the messaging engine  to any particular software language, database type, or messaging system. Rather, the examples illustrate how to implement the described functionality in one particular environment as an aid to understanding and appreciating how the methodology may also be extended to other environments, software languages, and messaging systems.","The messaging block  may communicate with the data block  for managing one or more data tables containing the notifications , events , publishers , subscribers , or subscriptions . That is, in some examples, the data block  may be used to generate database tables for the events , publishers , subscribers , subscriptions , or combinations thereof. Recall, as described generally above, the data block  may create and manipulate tables in an automatic manner based on stored templates. Accordingly, templates may be stored particular to the storage, use, or both, of the message block components shown in . In this manner, stored software code used by the messaging block  may be auto-generated and stored by the data block  using one or more stored templates. Similarly, the data block  may be used to generate or process messages published to or received on the messaging bus. For example, with reference to , the data engine  may execute a message in an analogous manner to execution of a payload . That is, in some examples, all or a portion of the message may serve as a payload for the data block .","An example of a system  utilizing an embodiment of the messaging block  is shown in . An example of establishing an account will be described. In the system , a variety of client systems make use of account information including an order management system  that may record orders associated with an account, a billing management system  that may process billing and payment information associated with an account, a customer management system  that may process and record interactions associated with an account, and a tracking management system  that may track all messaging traffic for an entire enterprise. Each of the systems , , , and  may be co-located or in disparate locations, and may in some embodiments operate in part on a same computing device, although different computing devices may be used. A user interacts with the system  through a user interface . The user interface  may be separate from the systems , , , and  as shown, or may be an integral part of any or all of those systems. Further, the user interface  may indicate an interface with an actual user, system administrator, or with a computer process that serves as the user as described. The user interface , as well as the systems , , , and  are in communication with the messaging block .","As another example, referring to , a method for adding the billing management system  to the system  will be described. A publisher is created in the messaging block for the billing management system  using a publisher schema. An event schema is created for each of the events of interest that may occur inside of the billing management system , such as but not limited to change billing address, add billing address, update balance owed. One or more subscribers may be created for each of the created events. For example, if the administrator is aware that the customer management system  would like to subscribe to one or more of the events, a subscriber may accordingly be created. For each subscriber, a subscription may be created for implementing the delivery of a notification in the subscribing system. In some examples, the billing management system  itself may be modified for use in the system  coupled to the messaging block . For example, a processor or computer system implementing the billing management system  may execute additional software including instructions to call a method CreateEvent and post an XML payload describing a billing change, or other event. Existing software executed by the billing management system  may be modified for this purpose by, for example, identifying locations in the software code executed by the billing management system  where events may be posted. These code locations may then be modified to post events using the CreateEvent method.","In some examples, it may not be desirable or possible to alter software code being executed by a system, such as the billing management system . Accordingly, in some embodiments messages may be generated by the billing management system  in a manner that does not require altering software code being executed by the billing management system . For example, the billing management system  may be, prior to interfacing with the messaging block , coupled to a database  for storing billing information or other data maintained by the billing management system . In one embodiment, for integration with the messaging block , a trigger may be added to the database  that would post a change to the database  into a message queue. The posting may be accomplished through, for example, a C# Assembly loaded in the database engine running on the database , or through a stored procedure in the database . Accordingly, the software code executed by the billing management system  itself may not require alteration. In other examples, changes to the database  may be stored in another database (not shown), another table, or another file system. In still another example, a web service call may be made that would post database changes directly to the message bus of the messaging block . In these examples, a Windows service, web service, or other process called by the message bus, may access the changes and create an event to be persisted on the message bus of the messaging block .","That is, a generic Assembly may be prepared having a method accepting XML as input and includes code that, when executed, maps the XML into an event payload and pushes the payload to either a message queue or the message bus. The Assembly is deployed in the database . An administrator of the billing management system  may then post changes to certain, or all, entities, to the method call of the Assembly deployed in the database . In this manner, an intermediary system may be placed between the billing management system , the database , or both, that generates events corresponding to changes of the database . In this manner, software code executed by the billing management system  may not require alteration or recompilation.","The examples described above may still require some cooperation on the part of a system administrator for the billing management system , even if the code itself may not require alteration or recompilation. In some examples, however, systems may be integrated with the messaging block  without such cooperation. In particular, a trigger may be generated in each table in the database  corresponding to an entity of interest to the system . A generic assembly may be written having a method that accepts XML and maps the XML to an event payload, and pushes the event to either a message queue in the database  or the message bus of the messaging block . The assembly is then deployed in the database . The trigger previously generated in each table calls the assembly and method to generate the events. Then, as above, an intermediary between the messaging block  and the database  pushes the events onto the message bus of the messaging block . By using triggers in tables of the database , no identification of entities of interest may be required within the billing management system .","In still other examples, access may not be feasible for changes to either the billing management system  or the database . Rather, the billing management system  may provide only a procedure allowing changes to entities to be obtained. To capture messages generated by the billing management system  in this example, a different approach may be used. A polling event schema may be created in the messaging block . A publisher for the polling event schema may be created in the messaging block  corresponding to the message bus. A subscriber may be created in the messaging block  corresponding to the polling event schema. A subscription may be created in the messaging block  for the subscriber. The subscription may be a recurring subscription with a periodic renewal time, such as five minutes. A web service endpoint may be created in the messaging block  itself specifying the location of the subscription as an endpoint. The messaging block  may call the procedure provided by the billing management system  to receive changes. The changes may be processed into an appropriate XML event and posted to the message bus.",{"@attributes":{"id":"p-0142","num":"0143"},"figref":["FIG. 17","FIG. 16","FIG. 16"],"b":["120","1505","1510","1515","1520","1602","1605","1610","1505","1510","1515","1520","1615","1505","1510","1515","1520","1602","1605","1610","1615","120"]},"In use, a user may create  an XML payload corresponding to account information. The XML payload may be created in any suitable manner, such as by utilizing a web application containing all fields of an account or a wizard that may collect information for an account. Other methods may be used in other embodiments. The user's system may then pass  a message including the XML payload and an indicator that the message corresponds to an account event to the messaging block . The messaging block  may then query the subscriptions and identify  subscribers to account events and generate notifications for the subscribers. Should a new system be added to the implementation of , and the new system also function to utilize account information, the new system may also receive notification of account events by creating a corresponding subscriber entity and subscription with the messaging block .","Accordingly, embodiments of messaging blocks according to the present invention may provide a publish and subscribe engine that may allow systems to access information generated by other systems in a generic manner independent of system type. Indeed, neither the system generating the message, nor the systems receiving the message, may need to know anything about the type or style of the originating or destination system. Instead, the communication is facilitated by the messaging block, allowing systems to be added, removed, or changed, in a flexible manner that may not require altering or re-compiling the software code that operates the messaging block itself. The messaging block  may also facilitate communication within the platform . The data block  and rule block  may subscribe to and publish messages on the message bus. Referring back to , any of the other components resident in the intelligence layer , adaptive layer , or core layer , may also publish message on, and receive notifications from, the message bus. In this manner, the messaging block  serves as a mediator of communications for the platform .","Rule Block","Referring back to , examples of the data block  and the messaging block  have been described above. Briefly, the data block  facilitates data storage and interaction with data sources  in a generic manner. The messaging block  facilitates message passing between one or more of the clients  in a generic manner. Accordingly, the platform  provides a flexible system for managing interactions between and among the clients  and the data sources . It may be desirable to act upon the data gathered and stored by the platform , also in a generic manner. Accordingly, the rule block  may be provided to evaluate rules dynamically through message passing.","An example of operation of the rule block  will be described with reference to . One or more rules, such as the rule , may be maintained by the client . An XML document  describing the rules  is communicated to the rule block . Rule schemas described by the XML document  may be defined during run time, or at start up. In some examples, rules may be inferred. That is, a rule may be generated in an automated fashion based on interactions or data available to the platform. For example, rules may be inferred based on an entity's interaction with different computing devices. Rules may also be inferred based on contextual information about an interaction. For example, if an entity sets a room temperature to seventy degrees at a certain time while the outside light was at a certain level, a rule may be inferred and stored with the rule block  that if it is a certain time and the outside light it at a certain level, an action to set the inner temperature to seventy degrees should be taken. Other types of rules may be inferred using other information available to the platform.","As with other blocks described above, communication with the rule block  may occur through SOAP messaging to a Web service implemented by the rule block . The XML document  generally will include an if\/then statement. The \u201cif\u201d statement may specify a condition, while the \u201cthen\u201d statement may specify an action to be taken on satisfaction of the condition. The statements may reference data stored in one or more locations accessible to the rule block . Accordingly, the rule block  may access one or more data stores to retrieve information used to evaluate the if and then statements contained in the XML document. Accordingly, the rule block  evaluates the condition contained in the XML document , and executes the then clause if the condition is satisfied. Results  of the rule evaluation may be returned to the client. In this manner, rules may be independently maintained by the clients  and changed at any time. A variety of functionalities may be provided by the rule block  including, but not limited to: handling functions with an unknown number of parameters, predefined trigonometric and logarithmic functions, user-defined custom functions, variable values resolved using a callback delegate, expressions which may contain string literals, where variable values, and function return values can be strings, arithmetic operators such as +, \u2212, \/, *, ^, Boolean operators such as <, >, =, &, |, !, < >, >=, <=, and string concatenation with & or +. Functionality may be obtained from third party libraries, such as bcParser.NET or others. In an analogous manner to the data block , described above, the rule block  may be in communication with a rule template cache (not shown). The rule template cache may contain XML templates, one corresponding to each type of rule, and describe what logic to apply for each type.","In this manner, the rule block  may provide an engine for in-memory evaluation of a rule. Software applications of any nature may post requests to the rule block  to evaluate rules and return results of the evaluation. In this manner, the requesting application may not need to hard code rules and structure inside of their own applications. Accordingly, users may change the rules as needs and purposes change and the applications are decoupled from the rule changes.","The rule block  may communicate with the messaging block  and subscribe to or publish messages to the message bus. On receipt of messages of interest, the rule block  may take a specified action, as described above, and a result of a rule evaluation may be to publish a certain type of message back to the message bus such that other systems may be notified of the action.","System Example: Text-to-Pledge System","Accordingly, embodiments of the platform  shown in  may be used to implement a rules-based system dealing with substantially any kind of content. The specifics of the contents, including attributes and methods of particular objects, publishers, and subscribers are provided by the clients, while programming specifics concerning software code syntax, and database particulars, are provided by the platform . In this manner, the platform  may be used to process data and rules, and mediate messages in any of a variety of systems, and maybe put to any use. As an example, an application is described below for processing charity pledges made by individuals using mobile devices. This application is provided by way of example only, and it is to be understood that the platform  may be used in the service of virtually any end application.","Referring now to , a system  is shown for processing charity pledges using an example of the platform . While charity pledges are given as an example, the system  may generally be used to manage any type of SMS campaign. A pledge database  is coupled to the data block  for storing pledge information including, but not limited to, email contact information, mobile phone numbers, and pledge amounts. By utilizing the data block  to interface with the pledge database , the pledge database may be changed without requiring any changes in software run by mobile contributors or the SMS gateway , as generally described above.","An SMS gateway  may be established as a publisher with the messaging block . The messaging block  may, for example, expose a web service to the SMS gateway . In some embodiments an SMS message preparation block  may be provided to format text messages received from the SMS gateway  into messages suitable for the messaging block , as generally described above. Any number of other subscribers may also be registered with the messaging block . A user may utilize a mobile device , to transmit a text message containing an amount of a pledge they wish to make to the SMS gateway . The mobile device  may take substantially any form including but not limited to, a cell phone or a digital assistant. Other devices, which may not be mobile, may also be used including a kiosk, a POS terminal, a set-top box, or other devices. The mobile device  may also be utilized to text a \u2018help\u2019 command to the SMS gateway , as may be required by an SMS aggregator for the use of an SMS system in some examples. An owner of an SMS short code used to address text messages may be required to respond to such a \u2018help\u2019 message with instructions. Accordingly, the platform  may be able to distinguish between a \u2018pledge\u2019 message containing a pledge amount and a \u2018help\u2019 message requiring an instructional response. While a text messaging example has been described, the client device may communicate using other mechanisms, for example, a pledge may be initiated through a web browser on the client device, an email message, another mobile web application, or through a native application on the client device.","An incoming communication, such as a text message, sent from the mobile device  may be received by the SMS gateway  and packaged into a message suitable for the messaging block  by the SMS message preparation block . In other embodiments, the SMS gateway  itself may be configured to package the text message into a message suitable for the messaging block . The resulting message generated by the SMS message preparation block  may be passed to the messaging block  and stored, for example using the data block . The data block  may communicate information, such as pledge amounts, mobile device IDs and phone numbers, to the pledge database . The storage of data using the data block  may cause the data block  to publish a message to a message bus of the messaging block . So, for example, the data block  may publish a message indicative of a \u2018new message received\u2019 event onto the message bus. The rule block  may be subscribed to \u2018new message received\u2019 events, and may accordingly receive the message. The rule block  may be configured to examine the message stored in the data block  and take one of two actions: 1) publish a pledge confirmation event to the message bus; or 2) publish a help message event to the message bus, depending on whether the message stored in the data block  was a pledge or help message. Other actions may be taken by the rule block in other embodiments.","A pledge confirmation system  may be subscribed to pledge confirmation events, and receive a pledge confirmation message published to the message bus by the rule block . On receipt of the pledge confirmation message, the pledge confirmation system  may be configured to, for example, email a confirmation message to the entity who originated the pledge.","A help processing system  may be subscribed to help message events and, on receipt of a help message event, the help processing system  may take action by sending a text message containing requisite instructions to a mobile phone ID associated with the event.","While SMS is used in this example, the mobile device  may also run a mobile web application for pledging. The mobile web application may record a pledge amount and an associated mobile device ID, such as a phone number, or any other identifier of a user pledging, such as an email address. Other information may be captured in other embodiments.","Point-of-Sale System","Embodiments of a platform according to the present invention may also be used to implement a point of sale system , an example of which is shown in . A client device  may be used to initiate a request to place an order or publish content or data. The client device  may be any of a variety of electronic devices including, but not limited to, a cell phone, kiosk, or a point of sale terminal which may include payment capability such as a credit card reader, or more generally any device with an Internet browser or messaging capability. The client device  may be mobile or fixed. An application operating on the client device  may be used to indicate what type of purchase is desired. For example, a user at a concert or other event may indicate they are interested in purchasing a concession, by for example, selecting a \u2018concessions\u2019 link or application on the client device .","Responsive to the indication the user is interested in concessions, an application on the client device  may communicate with the messaging block  by, for example, calling a web service exposed by the messaging block , to publish a \u2018looking for concessions\u2019 message on the message bus. In some embodiments, the client device  may communicate with a gateway  or other communication hub  that in turn communicates with the messaging block , as shown in . In some embodiments, a message preparation block  may be used to format messages from the gateway  or other communication hub  for the messaging block . That is, an application operating on the client device  or gateway  may be registered as a publisher with the messaging block  and may publish an event corresponding to a user indicating a desire for concessions. The messaging block  may accordingly identify subscribers to that type of message, as generally described above. In some examples, a message preparation block  may be used between the gateway  or other communication hub  and the messaging block  to format a message in a suitable manner for the messaging block .","A concession manager  application may be registered as a subscriber with the messaging block , and may have a subscription to \u2018looking for concessions\u2019 messages. Accordingly, when the messaging block publishes such a message, the concession manager  may be notified. The concession manager  may access a concession inventory  accessible at a location where the user indicated his desire for concessions. The data block  may facilitate data access and storage to the concession inventory . The concession manager  or the data block  may publish a message to the message bus containing information about the types, sizes, promotions and other data pertaining to the concessions.","A profile manager  application may also be registered as a subscriber with the messaging block , and may also have a subscription to \u2018looking for concessions\u2019 messages. Responsive to such a message, the profile manager  may utilize the data block  to access profile storage  to access concession related preferences of a user issuing the request for concessions. The profile manager  or data block  may then publish a message to the message bus containing the user's concession related preferences.","The rule block  may be subscribed to the concession availability messages and the profile messages published by the concession manager  and the profile manager , respectively. The messages may contain metadata indicating they are responsive to the same initial request from a user. Accordingly, on receipt of both messages at the rule block , the rule block  may evaluate which of the concession items satisfy the concession preferences. For example, if one concession preference is for \u201clarge sizes\u201d, the rule block  may return all available concessions that are of size large or bigger. The rule block  may then publish a message to the message bus containing preference-matched concessions.","The gateway  or other communication hub , or both, may be subscribed to the preference-matched concession messages, and may then communicate with the client device  to display the choices specified by the preference-matched concession messages.","A user may then make a selection at the client device  from among the preference-matched concession choices. The selection is communicated to the gateway  or other communication hub , or both, that may publish an order event to the message bus. Although not shown in , an ordering system and a payment system may be subscribed to the order messages and receive notification of the order.","Although an gateway  and message preparation block  are shown in , in other examples, a different interface may be provided to the platform , such as a web interface or kiosk connection. The type of interface implemented will depend in part on the type of client device used. The platform  may have more than one interface to accommodate a variety of client device types. Generally, any number of communication hubs may be present, and any number of client devices may communicate with each hub.","Referring again to , in some examples, the client device  may be mobile. As a user enters a location, such as a store, they may be recognized by their client device , for example through use of an RFID tag on the client device  and a tag reader positioned at the location or by bluetooth communications. In some examples, other positioning technologies may be used such as GPS, cell tower triangulation, WiFi-based positioning, or combinations thereof. The detection of the user may be an event that is communicated to the message bus of the platform . An identification of the user, the client device , or both, may also be published to the message bus.","The concession manager system  may be subscribed to detected user events, and may be notified of the user's presence at a location. Using methods as described generally above, the platform may then notify the client device  of available concessions or other items at the location which match preferences of the user. The notification may proceed through generally any manner, including but not limited to SMS, email message, notification in an application on the mobile device, or combinations thereof. In this manner, a retail location may interact with the platform to notify incoming potential customers of items that match one or more of the potential customer's preferences. The system remains sufficiently robust that operation may continue if the retail location's database changes or migrates to a new data format.","From the foregoing it will be appreciated that, although specific embodiments of the invention have been described herein for purposes of illustration, various modifications may be made without deviating from the spirit and scope of the invention.","The following is an example of a code excerpt implementing a portion of a data engine generic API. The code is commented to describe what each portion accomplishes. The example is not intended to be limiting, other methods, parameter types, values, databases, and languages may be supported in other examples.",{"@attributes":{"id":"p-0169","num":"0170"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\u2003\/\/\/ <param name=\u201cEntity\u201d>XML Payload to be passed to the"},{"entry":"\u2003\u2003\u2003\/\/\/ \u201cas Root identified\u201d stored procedure.<\/param>"},{"entry":"\u2003\u2003\u2003\/\/\/ <param name=\u201cSPSuffix\u201d>string to be appended before the"},{"entry":"\u2003\u2003\u2003\/\/\/ Root Name to build the stored procedure name to call.<\/param>"},{"entry":"\u2003\u2003\u2003\/\/\/ <param name=\u201cretType\u201d>Enum specifying the return type"},{"entry":"\u2003\u2003\u2003\/\/\/ from this generic Method.<\/param>"},{"entry":"\u2003\u2003\u2003\/\/\/ <returns>Returns an object corrsponding to None,"},{"entry":"\u2003\u2003\u2003\/\/\/ DataSet, DataReader or Scalar\/String.<\/returns>"},{"entry":"\u2003\u2003\u2003\/\/\/ <example>This sample shows how to call the ExecuteSP method."},{"entry":"\u2003\u2003\u2003\/\/\/ <code>"},{"entry":"\u2003\u2003\u2003\/\/\/"},{"entry":"\u2003\u2003\u2003\/\/\/ localhost.DBAPI db = new localhost.DBAPI"},{"entry":"\u2003\u2003\u2003\/\/\/ db.ExecuteSP(@\u201d"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2003\u2003\/\/\/ ","<Person>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2003\u2003\/\/\/ ","<Param1 DATA_TYPE=\u201cuniqueidentifier\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2003\u2003\u2003\/\/\/ ABCDEFAB-0000-1111-2222-333344445555}<\/Param1>"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003\/\/\/ ","<Param2 DATA_TYPE=\u201cnvarchar\u201d>some text<\/Param2>"]},{"entry":["\u2003\u2003\u2003\/\/\/ ","<Param3 DATA_TYPE=\u201cint\u201d>3<\/Param3>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003\/\/\/ ","<\/Person>,"]},{"entry":["\u2003\u2003\u2003\/\/\/ ","\u201cCreate\u201d,"]},{"entry":["\u2003\u2003\u2003\/\/\/ ","ReturnType.DataSet"]},{"entry":["\u2003\u2003\u2003\/\/\/ ","\u201d)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\u2003\/\/\/"},{"entry":"\u2003\u2003\u2003\/\/\/ <\/code>"},{"entry":"\u2003\u2003\u2003\/\/\/ <\/example>"},{"entry":"\u2003\u2003\u2003\/\/\/ this will execute the stored procedure uspCreatePerson"},{"entry":"\u2003\u2003\u2003\/\/\/ from the Database we are accessing"},{"entry":"\u2003\u2003\u2003\/\/\/"},{"entry":"\u2003\u2003\u2003\/\/\/ First we load the Entity XML Payload into a Memory stream"},{"entry":"\u2003\u2003\u2003\/\/\/ for fast access. Then we initialize an XMLReader with the"},{"entry":"\u2003\u2003\u2003\/\/\/ Memory Stream. We use an XMLReader for fast forward traversing"},{"entry":"\u2003\u2003\u2003\/\/\/ of the Memory Stream. We traverse the Entity XML payload, grab"},{"entry":"\u2003\u2003\u2003\/\/\/ the Root and concatenate the Root to the literal"},{"entry":"\u2003\u2003\u2003\/\/\/ \u201cusp\u201d + SPSuffix resulting in the name of the stored procedure"},{"entry":"\u2003\u2003\u2003\/\/\/ we want to execute. Then we traverse the child elements of the"},{"entry":"\u2003\u2003\u2003\/\/\/ Entity XML Payload and for each node we build a DbParameter"},{"entry":"\u2003\u2003\u2003\/\/\/ corresponding to the element name and with the DBType parsed"},{"entry":"\u2003\u2003\u2003\/\/\/ as the DATA_TYPE attribute of that element passed in parameters"},{"entry":"\u2003\u2003\u2003\/\/\/ Paraml, Param2, Param3, ... ParamN will correspond to the"},{"entry":"\u2003\u2003\u2003\/\/\/ parameters of the Stored Procedure then we execute the DbCommand"},{"entry":"\u2003\u2003\u2003\/\/\/ either as an ExecuteNonQuery for ReturnType.None or as"},{"entry":"\u2003\u2003\u2003\/\/\/ ExecuteNonQuery for ResultType.Scalar, in this case though we"},{"entry":"\u2003\u2003\u2003\/\/\/ either read the scalar as one of the output params or we execute"},{"entry":"\u2003\u2003\u2003\/\/\/ DataAdapter.Fill(ds) to get a DataSet from the executed stored"},{"entry":"\u2003\u2003\u2003\/\/\/"},{"entry":"\u2003\u2003\u2003\/\/\/"},{"entry":"\u2003\u2003\u2003private object ExecuteSP("},{"entry":"\u2003\u2003\u2003\u2003string Entity, string SPSuffix, ReturnType retType)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003DbCommand cmd = null;"},{"entry":"\u2003\u2003\u2003\u2003InitDBTemplateFromSOAPHeaders( ); \/\/based on the existence of a passed"},{"entry":"\u2003\u2003\u2003\u2003\/\/in Soap Header we override the connection string from"},{"entry":"\u2003\u2003\u2003\u2003\/\/web-config with the one passed in the header"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003object ret = null;"},{"entry":"\u2003\u2003\u2003\u2003try"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\/\/\/we trace the entry point into this method we use the"},{"entry":"\u2003\/\/\/Trace statement in order to be able to trace"},{"entry":"\u2003\u2003\u2003\u2003\u2003\/\/\/ on production boxes and to influence the level of"},{"entry":"\u2003\u2003\u2003\u2003\u2003\/\/\/tracing with a trace-flag in the Web-Config"},{"entry":"\u2003\u2003\u2003\u2003\u2003System.Diagnostics.Trace.WriteLineIf(traceSwitch.TraceVerbose,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u201cInfo : Executing DBAPI.CreateEntity\u201d);"},{"entry":"\u2003\u2003\u2003\u2003\u2003System.Diagnostics.Trace.WriteLinelf(traceSwitch.TraceVerbose,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u201cEntity: \u201d + Entity);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/ we specify that the encoded way of the Entity payload was ASCII"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Encoding en = Encoding.ASCII;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/ load the payload into a Memory Stream for fast access"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003MemoryStream s = new MemoryStream(en.GetBytes(Entity));"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/and then cosntruct a fast-forward only XmlTextReader to traverse"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/ the payload sequentially"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003XmlTextReader xtr = new XmlTextReader(s);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003string NodeValue = \u201c\u201d;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003string NodeName = \u201c\u201d;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003string NodeAttribute = \u201c\u201d;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003string ParamDir = \u201c\u201d;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003string ParamSize = \u201c\u201d;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003int ParamSizeInt = 0;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/we read the Root and grab the Name of the Element and concatenate"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/ it to the name of the Stored Procedure"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003xtr.Read( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003string EntitySchema = xtr.Name;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Encoding ascii = Encoding.ASCII;"},{"entry":"\u2003\/\/\/CreateDbCommand is a private method that uses the DbProvider Factory object"},{"entry":"to \/\/\/generate the appropriate ADO.NET objects specific to a Data Provider"},{"entry":"\u2003cmd = CreateDbCommand(SPSuffix.Length > 0 ?"},{"entry":"\u2003\/\/\/_Procedure Name is initialized in the constructor of the Web-Service as part of"},{"entry":"the \/\/\/DatabaseTemplate Schema;"},{"entry":"\u2003String.Format(_ProcedureName, EntitySchema, SPSuffix) :"},{"entry":"\u2003EntitySchema);"},{"entry":"\u2003\u2003\u2003\u2003\/\/\/we loop and traverse the Entity payload looking for starting"},{"entry":"\u2003\u2003\u2003\u2003\/\/\/ of an XML Element, for attributes, for content"},{"entry":"\u2003\u2003\u2003\u2003\/\/\/and eventually for the End Tag of an element; we save these"},{"entry":"\u2003\u2003\u2003\u2003\/\/\/ values in NodeValue, NodeAttribute and NodeName"},{"entry":"\u2003\u2003\u2003\u2003while (xtr.Read( ))"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003switch (xtr.NodeType)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/once we hit the start of an element we grab both the"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/ element Name as well as the value of the DATA_TYPE"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/ attribute"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003case XmlNodeType.Element:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003NodeName = string.Format(_ParameterFormat, xtr.Name);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003NodeAttribute = xtr.GetAttribute(\u201dDATA_ TYPE\u201d);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003ParamDir = xtr.GetAttribute(\u201dDIRECTION\u201d);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003ParamSize = xtr.GetAttribute(\u201dSIZE\u201d); break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/once we hit the NodeType Text we know we found"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/ the content of the Element"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003case XmlNodeType.Text:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003NodeValue = xtr.Value; break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/once we hit the NodeType CDATA we append the CDATA"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/ content to the rest of the content"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003case XmlNodeType.CDATA:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003NodeValue += \u201c \u201d + xtr.Value;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003NodeValue.Trim( ); break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/and once we find the closing Tag of the XML Element"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/ we look to see if all 3 required information about the"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/element were found - if it is the root or a malformed"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/ element we skip it - and then we proceed with"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/the creation of a DbParameter corresponding to the"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/ found information"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003case XmlNodeType.EndElement:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (NodeName.Length >0)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/in case no DATA_TYPE attribute was found we"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/ make the NodeAttribute \u201cnvarchar\u201d by default"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (NodeAttribute == null \u2225\u2009NodeAttribute.Length == 0)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003NodeAttribute = \u201cString\u201d;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/in case no DIRECTION attribute was found"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/ we make the ParamDir IN by default"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (ParamDir == null \u2225\u2009ParamDir.Length == 0)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ParamDir = \u201cInput\u201d;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/in case there was a SIZE attribute found we"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/ make the ParamSizeInt the integer"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/corresponding to the SIZE of the SqlParam"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (ParamSize != null && ParamSize.Length > 0)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ParamSizeInt = int.Parse(ParamSize);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003DbType dbType = DbType.String;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003DbParameter p = _dbProvider.CreateParameter( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (ParamSizeInt > 0)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003p.Size = ParamSizeInt;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/the direction of the DbParamter is"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/assumed to be IN unless otherwise specified"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ParameterDirection direction ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(ParameterDirection)Enum.Parse("},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003typeof(ParameterDirection), ParamDir, true);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003p.ParameterName = NodeName;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003p.Direction = direction;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003p.Value = DBNull.Value;"},{"entry":"\u2003\/\/\/this function adds the generic DbParameter object to the collection of"},{"entry":"\/\/\/parameters of the Command object"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003AddDbParameter(p, ref cmd, NodeAttribute);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003dbType = p.DbType;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/if we don't find any value for the XML"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/ Element then ignore this Parameter"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/after that convert the passed in XML"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/\/Element value to the appropriate SqlDbType"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (NodeValue.Length > 0)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003switch (dbType)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003case DbType.Guid:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003p.Value = new System.Guid(NodeValue);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003case DbType.DateTime:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003p.Value = DateTime.Parse(NodeValue);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003case DbType.Int32:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003p.Value = int.Parse(NodeValue);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003case DbType.Binary:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003p.Value = ascii.GetBytes("},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003NodeValue.PadRight(90, \u2018F\u2019));"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003case DbType.Decimal:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003p.Value = Decimal.Parse(NodeValue);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003case DbType. String:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003p.Value = NodeValue;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003default:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003p.Value = NodeValue;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003p.Value = System.DBNull.Value;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003NodeName = NodeAttribute = \u201c\u201d;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003NodeValue = ParamDir = ParamSize = \u201c\u201d;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ParamSizeInt = 0;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003default:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\/\/\/dependent on the return type we execute a stored procedure which returns a"},{"entry":"\/\/\/DbDataReader, nothing, Scalar or a DataSet"},{"entry":"\u2003\u2003\u2003switch (retType)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003case ReturnType.DataReader:"},{"entry":"\u2003\u2003\u2003\u2003\u2003DbDataReader dr = cmd.ExecuteReader( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003StringBuilder sb = new StringBuilder(@\u201c<RESPONSE>\u201d);"},{"entry":"\u2003\u2003\u2003\u2003\u2003while (dr.Read( ))"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003sb.AppendFormat(@\u201c<{0}>\u201d, EntitySchema);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003for (int i = 0; i <dr.VisibleFieldCount; i++)"},{"entry":"\u2003\u2003\u2003\u2003sb.AppendFormat(@\u201c<{0 }>{1 }<\/{0 }>\u201d, dr.GetName(i),"},{"entry":"\u2003\u2003\u2003\u2003\u2003dr.GetValue(i).ToString( ));"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003sb.AppendFormat(@\u201c<\/{0}>\u201d, EntitySchema);"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003dr.Close( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003sb.Append(@\u201c<\/RESPONSE>\u201d);"},{"entry":"\u2003\u2003\u2003\u2003\u2003ret = sb.ToString( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003case ReturnType.None:"},{"entry":"\u2003\u2003\u2003\u2003\u2003cmd.ExecuteNonQuery( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003StringBuilder sbNone = new StringBuilder(@\u201c<RESPONSE>\u201d);"},{"entry":"\u2003\u2003\u2003\u2003\u2003foreach (DbParameter p in cmd.Parameters)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (p.Direction == ParameterDirection.Output \u2225"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003p.Direction == ParameterDirection.InputOutput)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003sbNone.AppendFormat(@\u201c<{0}>{1 }<\/{0 }>\u201d, p.ParameterName,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003p.Value.ToString( ));"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003sbNone.Append(@\u201c<\/RESPONSE>\u201d);"},{"entry":"\u2003\u2003\u2003\u2003\u2003ret = sbNone.ToString( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003case ReturnType.Scalar:"},{"entry":"\u2003\u2003\u2003\u2003\u2003ret = cmd.ExecuteScalar( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003case ReturnType.DataSet:"},{"entry":"\u2003\u2003\u2003\u2003\u2003DbDataAdapter da = _dbProvider.CreateDataAdapter( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003da.SelectCommand = cmd;"},{"entry":"\u2003\u2003\u2003\u2003\u2003DataSet ds = new DataSet( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003da.Fill(ds);"},{"entry":"\u2003\u2003\u2003\u2003\u2003ret = ds;"},{"entry":"\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003catch (XmlException xe)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003System.Diagnostics.Trace.WriteLineIf(traceSwitch.TraceError,"},{"entry":"\u2003\u2003\u2003\u2003String.Format(@\u201cERROR reading XML in DBAPI.ExecuteSP("},{"entry":"\u2003\u2003\u2003\u2003Entity: {0}, SPSuffix: {1}, ReturnType: {2} >> Error: {3})\u201d,"},{"entry":"\u2003\u2003\u2003\u2003Entity, SPSuffix, retType, xe.Message));"},{"entry":"\u2003\u2003\u2003throw (xe);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003catch (DbException de)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003System.Diagnostics.Trace.WriteLineIf(traceSwitch.TraceError,"},{"entry":"\u2003\u2003\u2003\u2003String.Format(@\u201cSQL ERROR in DBAPI.ExecuteSP(Entity: {0},"},{"entry":"\u2003\u2003\u2003\u2003\u2003SPSuffix: {1}, ReturnType: {2} >> Error: {3})\u201d,"},{"entry":"\u2003\u2003\u2003\u2003Entity, SPSuffix, retType, de.Message));"},{"entry":"\u2003\u2003\u2003throw (de);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003catch (Exception x)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003System.Diagnostics.Trace.WriteLineIf(traceSwitch.TraceError,"},{"entry":"\u2003\u2003\u2003\u2003String.Format(@\u201cERROR in DBAPI.ExecuteSP(Entity: {0},"},{"entry":"\u2003\u2003\u2003\u2003\u2003SPSuffix: {1}, ReturnType: {2} >> Error: {3})\u201d,"},{"entry":"\u2003\u2003\u2003\u2003Entity, SPSuffix, retType, x.Message));"},{"entry":"\u2003\u2003\u2003throw (x);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003finally"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003cmd.Connection.Close( );"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003return ret;"},{"entry":"\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In Example 1, the example API made use of the function CreateDbCommand. An example of an implementation of this command is:",{"@attributes":{"id":"p-0171","num":"0172"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"private DbCommand CreateDbCommand(string CommandText)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003DbCommand cmd = _dbProvider.CreateCommand( );"]},{"entry":[{},"\u2003cmd.CommandText = CommandText;"]},{"entry":[{},"\u2003cmd.CommandType = CommandType.StoredProcedure;"]},{"entry":[{},"\u2003cmd.Connection = _dbConnection;"]},{"entry":[{},"\u2003cmd.Connection.Open( );"]},{"entry":[{},"\u2003return cmd;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"\/\/\/ _dbProvider is used to create the command. The Factory object _dbProvider, once properly constructed, knows how to instantiate the appropriate ADO.NET objects specific to each DataProvider. The _dbProvider object can be initialized with reference to the constructor of the Web-Service:",{"@attributes":{"id":"p-0173","num":"0174"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003public DBAPI( )"},{"entry":"\u2003{"},{"entry":"\u2003\u2003_providerName ="},{"entry":"\u2003\u2003ConfigurationSettings.AppSettings[\u201cproviderName\u201d];"},{"entry":"\u2003\u2003_dbProvider = DbProviderFactories.GetFactory(_providerName);"},{"entry":"\u2003\u2003_dbConnection = _dbProvider.CreateConnection( );"},{"entry":"\u2003\u2003_dbConnection.ConnectionString ="},{"entry":"ConfigurationSettings.AppSettings[\u201cConnection\u201d];"},{"entry":"\u2003\u2003InitCache( );"},{"entry":"\u2003\u2003GDBCL.DatabaseTemplate DatabaseTemplate ="},{"entry":"\u2003Context.Cache[_CacheKey] as GDBCL.DatabaseTemplate;"},{"entry":"\u2003\u2003_ProcedureName = DatabaseTemplate.ProcedureName;"},{"entry":"\u2003\u2003_ParameterFormat = DatabaseTemplate.ParameterFormat;"},{"entry":"\u2003\u2003InitializeComponent( );"},{"entry":"\u2003\u2003this._EventLogMachine ="},{"entry":"ConfigurationSettings.AppSettings[\u201cEventLogMachine\u201d];"},{"entry":"\u2003\u2003this._EventLogName ="},{"entry":"\u2003\u2003ConfigurationSettings.AppSettings[\u201cEventLogName\u201d];"},{"entry":"\u2003\u2003this._EventLogSource ="},{"entry":"\u2003\u2003ConfigurationSettings.AppSettings[\u201cEventLogSource\u201d];"},{"entry":"\u2003\u2003this._TraceSwitch ="},{"entry":"\u2003\u2003ConfigurationSettings.AppSettings[\u201cTraceSwitch\u201d];"},{"entry":"\u2003\u2003traceSwitch = new TraceSwitch(this._TraceSwitch, \u201cTrace Switch"},{"entry":"\u2003\u2003\u2003for \u201d + this._EventLogName);"},{"entry":"\u2003\u2003traceSwitch.Level ="},{"entry":"\u2003\u2003(System.Diagnostics.TraceLevel)System.Int32.Parse("},{"entry":"\u2003\u2003\u2003ConfigurationSettings.AppSettings[\u201ctraceSwitch\u201d]);"},{"entry":"\u2003\u2003SetupListeners( );"},{"entry":"\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"\/\/\/ The providerName is a String in the configuration file. Examples of such a string are System.Data.SqlClient or System.Data.OracleClient. Once we get an instance of the Provider Factory object, we can use it to create on the fly appropriate ADO.NET object for any Data Provider.","An example of functions of a data engine generic API according to the present invention are shown below. Functions to manage entities in target databases may be implemented using the ExecuteSP function described in Example 1. Specifically, in this example, four functions for managing an entity are implemented\u2014CreateEntity, ReadEntity, UpdateEntity, and DeleteEntity. CreateEntity is implemented as follows:",{"@attributes":{"id":"p-0176","num":"0177"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2009[WebMethod]"]},{"entry":[{},"\u2009[SoapHeader(\u201cdbwsHeader\u201d,Direction=SoapHeaderDirection.In)]"]},{"entry":[{},"public string CreateEntity(string Entity)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003return ExecuteSP(Entity, \u201cCreate\u201d, ReturnType.None).ToString( );"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Similarly, the other functions of the API are ExecuteSP_DataReader, ExecuteSP_DataSet, ExecuteSP_None, ExecuteSP_Scalar They all are implemented by passing in appropriate parameters into the same function, ExecuteSP. For example ExecuteSP_DataReader is implemented as:",{"@attributes":{"id":"p-0178","num":"0179"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2009[WebMethod]"]},{"entry":[{},"\u2009[SoapHeader(\u201cdbwsHeader\u201d, Direction = SoapHeaderDirection.In)]"]},{"entry":[{},"public string ExecuteSP_DataReader(string Entity)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003return (string)ExecuteSP(Entity, \u201c\u201d, ReturnType.DataReader);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"If you look back at the signature of the function ExecuteSP, you can see that it has a very flexible signature that allows us to serve any type of request from the previously presented functions:","private object ExecuteSP(string Entity, string SPSuffix, ReturnType retType)","Entity, represents the XML string passed into the API, SPSuffix represents a string that gets prepended to the passed in Stored Procedure Name. For example in the case of the CRUD functions presented previously, the Create, Read, Update and Delete, suffixes can be prepended to the Stored Procedure name. In this manner, an Entity with the same XML payloads as we showed previously as the Person Entity can be managed. The third parameter allows different types of returned objects from the API.","Examples of methods provided by an API implemented by the messaging engine  are provided below. In particular, the methods below are an example of software code used to implement CreatePublisher, ReadPublisher, DeletePublisher, ReadSubscription, and CreateEvent for operation with a BizTalk message bus. While BizTalk is used here as an example, any messaging system, including a custom system, may be used and appropriate software code drafted using the particularities of the message system.","CreatePublisher",{"@attributes":{"id":"p-0183","num":"0184"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2009[WebMethod]"]},{"entry":[{},"public void CreatePublisher(Publisher Publisher)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003ReceivePort rcvPort = CreateReceivePort(Publisher.Name);"]},{"entry":[{},"\u2003CreateReceiveLocation(rcvPort, Publisher.TransportType,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Publisher.ReceivePipeline,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003Publisher.URL);"]},{"entry":[{},"\u2003CreateSendPortGroup(Publisher.Name,"]},{"entry":[{},"\u2003GetXmlFromFilter(Publisher.Filter));"]},{"entry":[{},"\u2003_catalog.SaveChanges( );"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The function of the CreatePublisher method is to create a publisher using specific BizTalk objects. Basically, creation of a publisher in BizTalk may include: creating a ReceivePort with a same name as the Publisher, creating a ReceiveLocation associated with the ReceivePort having a same Name, TransportType, ReceivePipeline, and LocationURI of the Publisher, creating a SendPortGroup having a same Name and Filter as the Publisher.","ReadPublisher",{"@attributes":{"id":"p-0185","num":"0186"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2009[WebMethod]"]},{"entry":[{},"public Publishers ReadPublisher(string PublisherName)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003Publishers pubs = new Publishers( );"]},{"entry":[{},"\u2003int pbsCount;"]},{"entry":[{},"\u2003if (PublisherName.Length == 0)"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003pbsCount = _catalog.ReceivePorts.Count;"]},{"entry":[{},"\u2003\u2003pubs.Publisher = new Publisher[pbsCount];"]},{"entry":[{},"\u2003\u2003for(int i=0; i<pbsCount; i++)"]},{"entry":[{},"\u2003\u2003\u2003pubs.Publisher[i] = GetPublisher(_catalog.ReceivePorts[i]);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003else"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003pubs.Publisher = new Publisher[1];"]},{"entry":[{},"\u2003\u2003pubs.Publisher[0] ="]},{"entry":[{},"\u2003\u2003GetPublisher(_catalog.ReceivePorts[PublisherName]);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003return pubs;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This method creates a Publishers array, checks the PublisherName passed in for an empty name, returns publishers identified by that Name, allocates an array of Publisher objects when the PublisherName is empty and adds publishers emitted by the BizTalk catalog object to the empty PublisherName. The ReadPublisher method uses a GetPublisher method to implement a search for a given Publisher by looking up the BizTalk object-model starting with a ReceivePort object. An example of code used to implement GetPublisher is:",{"@attributes":{"id":"p-0187","num":"0188"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"private Publisher GetPublisher(ReceivePort rPort)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003Publisher pub = new Publisher( );"]},{"entry":[{},"\u2003if (rPort.ReceiveLocations.Count == 0)"]},{"entry":[{},"\u2003\u2003return pub;"]},{"entry":[{},"\u2003ReceiveLocation rLoc = rPort.ReceiveLocations[0];"]},{"entry":[{},"\u2003pub.Name = rPort.Name;"]},{"entry":[{},"\u2003pub.URL = rLoc.Address;"]},{"entry":[{},"\u2003pub.TransportType = rLoc.TransportType.Name;"]},{"entry":[{},"\u2003SendPortGroup spg = _catalog.SendPortGroups[pub.Name];"]},{"entry":[{},"\u2003if (spg != null)"]},{"entry":[{},"\u2003\u2003pub.Filter = GetFilterFromXml(spg.Filter);"]},{"entry":[{},"\u2003return pub;"]},{"entry":[{},"}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"DeletePublisher"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[WebMethod]"]},{"entry":[{},"public void DeletePublisher(string PublisherName)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\u2003\u2003DeleteSendPortGroup(PublisherName);"]},{"entry":[{},"\u2003\u2003\u2003\u2003DeleteReceivePort(PublisherName);"]},{"entry":[{},"\u2003\u2003\u2003\u2003_catalog.SaveChanges( );"]},{"entry":[{},"}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"ReadSubscription"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2009[WebMethod]"]},{"entry":[{},"public Subscriptions ReadSubscription(Subscription subscription)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003Subscriptions subs = new Subscriptions( );"]},{"entry":[{},"\u2003Subscription s;"]},{"entry":[{},"\u2003SendPortGroup spg;"]},{"entry":[{},"\u2003int sbsCount = 0;"]},{"entry":[{},"\u2003int index = 0;"]},{"entry":[{},"\u2003if (subscription.PublisherName.Length == 0 &&"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"subscription.SubscriberName.Length == 0)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003\/\/get all subscription"]},{"entry":[{},"\u2003\u2003for (int i = 0; i < _catalog.SendPortGroups.Count; i++)"]},{"entry":[{},"\u2003\u2003\u2003sbsCount +="]},{"entry":[{},"\u2003\u2003_catalog.SendPortGroups[i].SendPorts.Count;"]},{"entry":[{},"\u2003\u2003subs.Subscription = new Subscription[sbsCount];"]},{"entry":[{},"\u2003\u2003for (int i = 0; i < _catalog.SendPortGroups.Count; i++)"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003for (int j = 0;"]},{"entry":[{},"\u2003\u2003\u2003j < _catalog.SendPortGroups[i].SendPorts.Count; j++)"]},{"entry":[{},"\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003s = new Subscription( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003s.PublisherName = _catalog.SendPortGroups[i].Name;"]},{"entry":[{},"\u2003\u2003\u2003\u2003s.SubscriberName ="]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"((SendPort)_catalog.SendPortGroups[i].SendPorts[j]).Name;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u2003\u2003subs.Subscription[index++] = s;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003else if (subscription.PublisherName.Length == 0)"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003\/\/get all subscription for given subscriber"]},{"entry":[{},"\u2003\u2003subs.Subscription ="]},{"entry":[{},"\u2003\u2003new Subscription[_catalog.SendPortGroups.Count];"]},{"entry":[{},"\u2003\u2003for (int i = 0; i< _catalog.SendPortGroups.Count ; i++)"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003spg = _catalog.SendPortGroups[i];"]},{"entry":[{},"\u2003\u2003\u2003for (int j = 0; j < spg.SendPorts.Count ; j++)"]},{"entry":[{},"\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003if (((SendPort)spg.SendPorts[j]).Name =="]},{"entry":[{},"\u2003\u2003\u2003\u2003subscription.SubscriberName)"]},{"entry":[{},"\u2003\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003s = new Subscription( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003s.PublisherName = spg.Name;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003s.SubscriberName = subscription.SubscriberName;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003subs.Subscription[index++] = s;"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003else if(subscription.SubscriberName.Length == 0)"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003\/\/ get all subscription for given Publisher"]},{"entry":[{},"\u2003\u2003spg = _catalog.SendPortGroups[subscription.PublisherName];"]},{"entry":[{},"\u2003\u2003sbsCount = spg.SendPorts.Count;"]},{"entry":[{},"\u2003\u2003subs.Subscription = new Subscription[sbsCount];"]},{"entry":[{},"\u2003\u2003for(int i = 0; i < sbsCount; i++)"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003s = new Subscription( );"]},{"entry":[{},"\u2003\u2003\u2003s.PublisherName = subscription.PublisherName;"]},{"entry":[{},"\u2003\u2003\u2003s.SubscriberName =((SendPort)spg.SendPorts[i]).Name;"]},{"entry":[{},"\u2003\u2003\u2003subs.Subscription[i] = s;"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003else"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003\/\/return empty array of subscriptions"]},{"entry":[{},"\u2003\u2003subs.Subscription = new Subscription[1];"]},{"entry":[{},"\u2003\u2003subs.Subscription[0] = subscription;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003return subs;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The ReadSubscription method builds an array with all subscriptions in the system when there is no given PublisherName and no given SubscriberName as part of the incoming Subscription parameter. A total number of SendPortGroups in the BizTalk database is retrieved and array of Subscriptions objects of that size allocated. A list of associated SendPorts is retrieved for each SendPortGroup. For each SendPort, a Subscription object is created. The Subscription\u2192PublisherName is set to the SendPortGroup\u2192Name. The Subscription\u2192SubscriberName is set to the current SendPort\u2192Name in the iteration. The Subscription object is attached to the array of Subscriptions that will be returned.","CreateEvent",{"@attributes":{"id":"p-0189","num":"0190"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2009[WebMethod]"]},{"entry":[{},"public void CreateEvent(Event vEvent)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003Publishers pubs = ReadPublisher(vEvent.PublisherName);"]},{"entry":[{},"\u2003foreach(Publisher pub in pubs.Publisher)"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003if (pub.TransportType == TransportType.file)"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003string GUID = System.Guid.NewGuid( ).ToString( );"]},{"entry":[{},"\u2003\u2003\u2003string FileName = String.Format(@\u201c{0}\\{1}-{2}.xml\u201d,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"pub.URL.Substring(0,"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u2003\u2003pub.URL.LastIndexOf(@\u201c\\\u201d)), pub.Name, GUID);"]},{"entry":[{},"\u2003\u2003\u2003StreamWriter outFile = new StreamWriter(FileName, true);"]},{"entry":[{},"\u2003\u2003\u2003outFile.Write(vEvent.Content);"]},{"entry":[{},"\u2003\u2003\u2003outFile.Close( );"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The CreateEvent method may allow clients to push an Event on a message bus. The above implementation reflects a case when a Publisher pushes events by copying an XML payload into a folder on a target machine. Other implementations may also be used. Generally, messages may be written by any mechanism to a Receive Port's location, from where the message bus may pick the messages up and process them. The mechanism used to push a file into the Location of a Receive Port may include, but is not limited to, manually copying the files, an http post, or having an application create files in a specific location.","The CreateEvent method above generally gets meta-data associated with the Publishers of the Name passed in. For a zero-length PublisherName, all Publisher objects are obtained. For a given PublisherName, a specific Publisher is obtained. For each Publisher object returned, the TransportType and URL of the Publisher is obtained. A file is created, with a name having a unique identifier. The Content field of the passed in Event object is written to the file, and the file is closed."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0035","num":"0036"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0036","num":"0037"},"figref":"FIG. 2","b":"100"},{"@attributes":{"id":"p-0037","num":"0038"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0038","num":"0039"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0039","num":"0040"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0040","num":"0041"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0041","num":"0042"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0042","num":"0043"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0043","num":"0044"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0044","num":"0045"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0045","num":"0046"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0046","num":"0047"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0047","num":"0048"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0048","num":"0049"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0049","num":"0050"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0050","num":"0051"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0051","num":"0052"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0052","num":"0053"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0053","num":"0054"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0054","num":"0055"},"figref":"FIG. 20"}]},"DETDESC":[{},{}]}
