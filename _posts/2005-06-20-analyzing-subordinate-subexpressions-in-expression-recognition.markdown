---
title: Analyzing subordinate sub-expressions in expression recognition
abstract: A mechanism for recognizing and inputting handwritten mathematical expressions into a computer by providing part of a multi-path framework is described. The part of the multi-path framework includes a subordinate sub-expression analysis component. A method for analyzing a handwritten mathematical expression for a subordinate sub-expression includes identifying sub-expressions based on dominant symbols and determining a character for potential dominant symbols based upon sub-expression information. A determination may be made whether an expression structure candidate is valid and valid expression structure candidates may be stored in a parse tree.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07929767&OS=07929767&RS=07929767
owner: Microsoft Corporation
number: 07929767
owner_city: Redmond
owner_country: US
publication_date: 20050620
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims priority to and the benefit of U.S. Provisional Application No. 60\/611,847, filed Sep. 22, 2004, which is herein incorporated by reference.","When writing scientific literature and articles using a computer, users often must input various and sometimes complex mathematical expressions. Today, a user has to input the mathematical expressions in an indirect manner. For example,  show two systems for inputting a mathematical expression: a structured expression editor, such as Equation Editor by Microsoft\u00ae Corporation of Redmond, Wash. (); and an expression descript language, such as LTX Equation Editor ().  shows a large tool box  which contains items ---N corresponding to various mathematical symbols and structures. The input of expressions may be laborious for some as a user has to find the proper symbol or structure from the groupings.  shows a second system that is oriented more towards an expert in the area of mathematical expression script languages. Users have to become experts of the script language before they may utilize the language to input expressions freely. Both systems are designed for the mathematical expression to be inputted by a keyboard.","The use of an electronic pen and\/or stylus input device is a more natural method for users to input mathematical expressions. The tablet style computer allows a user to enter handwritten notes; however, mathematical expressions have not been recognized with high accuracy by existing handwriting recognition software packages. A need exists for handwritten mathematical expression recognition to enable pen-based input. Comparing to printed expressions, more ambiguities exist in handwritten expressions. Firstly, it is hard to differentiate symbols from each other just by using shape information. For example, \u2018X\u2019 is very similar to \u2018\u00d7\u2019, such as for designating a multiplication operation. Another typical example is a \u2018dot\u2019. When a dot is located at a position of a subscript, it is a decimal dot. However, when the dot is at a mid-level position, it is a dot operator. Secondly, there are many uncertainties in a layout structure. For example, a numerator may expand to a region outside of a fraction line because there is not enough room above the line.","With the rise in use of the tablet style computer, applications are being created and\/or updated to implement handwritten annotation recognition. However, handwritten text recognition and ink document analysis are the only recognition and analysis systems enabled in a freehand input system. Handwritten mathematical expression recognition has not been available yet.","Handwritten notations systems for text input allows a user to freely write notes. However, conventional systems do not allow a user to input handwritten mathematical expressions. The invention is a mechanism for recognizing and inputting handwritten mathematical expressions into a computer by providing part of a multi-path framework. The part of the multi-path framework includes a subordinate sub-expression analysis component. Claims are directed to systems for identifying sub-expressions of a handwritten mathematical expression based on dominant symbols and determining a character for potential dominant symbols based upon sub-expression information. Expression structure candidates are determined to be valid and valid expression structure candidates are stored in a parse tree.","In the following description of the various embodiments, reference is made to the accompanying drawings, which form a part hereof, and in which is shown by way of illustration of various embodiments in which the invention may be practiced. It is to be understood that other embodiments may be utilized and structural and functional modifications may be made without departing from the scope of the present invention.",{"@attributes":{"id":"p-0095","num":"0094"},"figref":"FIG. 2A","b":["200","200","200","200"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an illustrative system for implementing the invention includes a general-purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.","Computer  typically includes a variety of computer readable media. Computer readable media may be any available media that may be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, random access memory (RAM), read only memory (ROM), electronically erasable programmable read only memory (EEPROM), flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which may be used to store the desired information and which may accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as ROM  and RAM . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disc drive  that reads from or writes to a removable, nonvolatile optical disc  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that may be used in the illustrative operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disc drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in , provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components may either be the same as or different from operating system , application programs , other program modules  , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a digital camera (not shown), a keyboard , and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","In one embodiment, a pen digitizer  and accompanying pen or stylus  are provided in order to digitally capture freehand input. Although a direct connection between the pen digitizer  and the user input interface  is shown, in practice, the pen digitizer  may be coupled to the processing unit  directly, via a parallel port or other interface and the system bus  as known in the art. Furthermore, although the digitizer  is shown apart from the monitor , the usable input area of the digitizer  may be co-extensive with the display area of the monitor . Further still, the digitizer  may be integrated in the monitor , or may exist as a separate device overlaying or otherwise appended to the monitor .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are illustrative and other means of establishing a communications link between the computers may be used.","It will be appreciated that the network connections shown are illustrative and other means of establishing a communications link between the computers may be used. The existence of any of various well-known protocols such as TCP\/IP, Ethernet, FTP, HTTP and the like is presumed, and the system may be operated in a client-server configuration to permit a user to retrieve web pages from a web-based server. Any of various conventional web browsers may be used to display and manipulate data on web pages.","A programming interface (or more simply, interface) may be viewed as any mechanism, process, protocol for enabling one or more segment(s) of code to communicate with or access the functionality provided by one or more other segment(s) of code. Alternatively, a programming interface may be viewed as one or more mechanism(s), method(s), function call(s), module(s), object(s), etc. of a component of a system capable of communicative coupling to one or more mechanism(s), method(s), function call(s), module(s), etc. of other component(s). The term \u201csegment of code\u201d in the preceding sentence is intended to include one or more instructions or lines of code, and includes, e.g., code modules, objects, subroutines, functions, and so on, regardless of the terminology applied or whether the code segments are separately compiled, or whether the code segments are provided as source, intermediate, or object code, whether the code segments are utilized in a runtime system or process, or whether they are located on the same or different machines or distributed across multiple machines, or whether the functionality represented by the segments of code are implemented wholly in software, wholly in hardware, or a combination of hardware and software.","Notionally, a programming interface may be viewed generically, as shown in  or .  illustrates an interface Interface as a conduit through which first and second code segments communicate.  illustrates an interface as comprising interface objects I and I (which may or may not be part of the first and second code segments), which enable first and second code segments of a system to communicate via medium M. In the view of , one may consider interface objects I and I as separate interfaces of the same system and one may also consider that objects I and I plus medium M comprise the interface. Although  show bi-directional flow and interfaces on each side of the flow, certain implementations may only have information flow in one direction (or no information flow as described below) or may only have an interface object on one side. By way of example, and not limitation, terms such as application programming interface (API), entry point, method, function, subroutine, remote procedure call, and component object model (COM) interface, are encompassed within the definition of programming interface.","Aspects of such a programming interface may include the method whereby the first code segment transmits information (where \u201cinformation\u201d is used in its broadest sense and includes data, commands, requests, etc.) to the second code segment; the method whereby the second code segment receives the information; and the structure, sequence, syntax, organization, schema, timing and content of the information. In this regard, the underlying transport medium itself may be unimportant to the operation of the interface, whether the medium be wired or wireless, or a combination of both, as long as the information is transported in the manner defined by the interface. In certain situations, information may not be passed in one or both directions in the conventional sense, as the information transfer may be either via another mechanism (e.g. information placed in a buffer, file, etc. separate from information flow between the code segments) or non-existent, as when one code segment simply accesses functionality performed by a second code segment. Any or all of these aspects may be important in a given situation, e.g., depending on whether the code segments are part of a system in a loosely coupled or tightly coupled configuration, and so this list should be considered illustrative and non-limiting.","This notion of a programming interface is known to those skilled in the art and is clear from the foregoing detailed description of the invention. There are, however, other ways to implement a programming interface, and, unless expressly excluded, these too are intended to be encompassed by the claims set forth at the end of this specification. Such other ways may appear to be more sophisticated or complex than the simplistic view of , but they nonetheless perform a similar function to accomplish the same overall result. We will now briefly describe some illustrative alternative implementations of a programming interface.","A communication from one code segment to another may be accomplished indirectly by breaking the communication into multiple discrete communications. This is depicted schematically in  D and E. As shown, some interfaces may be described in terms of divisible sets of functionality. Thus, the interface functionality of  may be factored to achieve the same result, just as one may mathematically provide 24, or 2 times 2 times 3 times 2. Accordingly, as illustrated in , the function provided by interface Interface may be subdivided to convert the communications of the interface into multiple interfaces InterfaceA, InterfaceB, InterfaceC, etc. while achieving the same result. As illustrated in , the function provided by interface I may be subdivided into multiple interfaces I, I, I, etc. while achieving the same result. Similarly, interface I of the second code segment which receives information from the first code segment may be factored into multiple interfaces I, I, I, etc. When factoring, the number of interfaces included with the 1st code segment need not match the number of interfaces included with the 2nd code segment. In either of the cases of , the functional spirit of interfaces Interface and I remain the same as with , respectively. The factoring of interfaces may also follow associative, commutative, and other mathematical properties such that the factoring may be difficult to recognize. For instance, ordering of operations may be unimportant, and consequently, a function carried out by an interface may be carried out well in advance of reaching the interface, by another piece of code or interface, or performed by a separate component of the system. Moreover, one of ordinary skill in the programming arts may appreciate that there are a variety of ways of making different function calls that achieve the same result.","In some cases, it may be possible to ignore, add or redefine certain aspects (e.g., parameters) of a programming interface while still accomplishing the intended result. This is illustrated in . For example, assume interface Interface of  includes a function call Square (input, precision, output), a call that includes three parameters, input, precision and output, and which is issued from the 1 st Code Segment to the 2nd Code Segment. If the middle parameter precision is of no concern in a given scenario, as shown in , it could just as well be ignored or even replaced with a meaningless (in this situation) parameter. One may also add an additional parameter of no concern. In either event, the functionality of square may be achieved, so long as output is returned after input is squared by the second code segment. Precision may very well be a meaningful parameter to some downstream or other portion of the computing system; however, once it is recognized that precision is not necessary for the narrow purpose of calculating the square, it may be replaced or ignored. For example, instead of passing a valid precision value, a meaningless value such as a birth date could be passed without adversely affecting the result. Similarly, as shown in , interface I is replaced by interface I\u2032, redefined to ignore or add parameters to the interface. Interface I may similarly be redefined as interface I\u2032, redefined to ignore unnecessary parameters, or parameters that may be processed elsewhere. The point here is that in some cases a programming interface may include aspects, such as parameters, which are not needed for some purpose, and so they may be ignored or redefined, or processed elsewhere for other purposes.","It may also be feasible to merge some or all of the functionality of two separate code modules such that the \u201cinterface\u201d between them changes form. For example, the functionality of  may be converted to the functionality of , respectively. In , the previous 1st and 2nd Code Segments of  are merged into a module containing both of them. In this case, the code segments may still be communicating with each other but the interface may be adapted to a form which is more suitable to the single module. Thus, for example, formal Call and Return statements may no longer be necessary, but similar processing or response(s) pursuant to interface Interface may still be in effect. Similarly, shown in , part (or all) of interface I from  may be written inline into interface I to form interface I\u2033. As illustrated, interface I is divided into Iand I, and interface portion Ihas been coded in-line with interface I to form interface I\u2033. For a concrete example, consider that the interface I from  performs a function call square (input, output), which is received by interface I, which after processing the value passed with input (to square it) by the second code segment, passes back the squared result with output. In such a case, the processing performed by the second code segment (squaring input) may be performed by the first code segment without a call to the interface.","A communication from one code segment to another may be accomplished indirectly by breaking the communication into multiple discrete communications. This is depicted schematically in . As shown in , one or more piece(s) of middleware (Divorce Interface(s), since they divorce functionality and\/or interface functions from the original interface) are provided to convert the communications on the first interface, Interface, to conform them to a different interface, in this case interfaces InterfaceA, InterfaceB and InterfaceC. This might be done, e.g., where there is an installed base of applications designed to communicate with, say, an operating system in accordance with an Interface protocol, but then the operating system is changed to use a different interface, in this case interfaces InterfaceA, InterfaceB and InterfaceC. The point is that the original interface used by the 2nd Code Segment is changed such that it is no longer compatible with the interface used by the 1st Code Segment, and so an intermediary is used to make the old and new interfaces compatible. Similarly, as shown in , a third code segment may be introduced with divorce interface DI to receive the communications from interface I and with divorce interface DI to transmit the interface functionality to, for example, interfaces Iand I, redesigned to work with DI, but to provide the same functional result. Similarly, DI and DI may work together to translate the functionality of interfaces I and I of  to a new operating system, while providing the same or similar functional result.","Yet another possible variant is to dynamically rewrite the code to replace the interface functionality with something else but which achieves the same overall result. For example, there may be a system in which a code segment presented in an intermediate language (e.g. Microsoft IL, Java ByteCode, etc.) is provided to a Just-in-Time (JIT) compiler or interpreter in an execution environment (such as that provided by the Net framework, the Java runtime environment, or other similar runtime type environments). The JIT compiler may be written so as to dynamically convert the communications from the 1 st Code Segment to the 2nd Code Segment, i.e., to conform them to a different interface as may be required by the 2nd Code Segment (either the original or a different 2nd Code Segment). This is depicted in . As can be seen in , this approach is similar to the Divorce scenario described above. It might be done, e.g., where an installed base of applications are designed to communicate with an operating system in accordance with an Interface protocol, but then the operating system is changed to use a different interface. The JIT Compiler could be used to conform the communications on the fly from the installed-base applications to the new interface of the operating system. As depicted in , this approach of dynamically rewriting the interface(s) may be applied to dynamically factor, or otherwise alter the interface(s) as well.","It is also noted that the above-described scenarios for achieving the same or similar result as an interface via alternative embodiments may also be combined in various ways, serially and\/or in parallel, or with other intervening code. Thus, the alternative embodiments presented above are not mutually exclusive and may be mixed, matched and combined to produce the same or equivalent scenarios to the generic scenarios presented in . It is also noted that, as with most programming constructs, there are other similar ways of achieving the same or similar functionality of an interface which may not be described herein, but nonetheless are represented by the spirit and scope of the invention, i.e., it is noted that it is at least partly the functionality represented by, and the advantageous results enabled by, an interface that underlie the value of an interface.","Handwritten mathematical expression recognition is needed to enable pen-based input of mathematical expressions. Aspects of the present invention propose a framework for handwritten mathematical expression recognition, which may output multiple expression candidates. In accordance with one embodiment, the multi-path framework utilizes multi-path algorithms and outputs multiple results in several components, including symbol grouping and recognition, tabular structure analysis, subordinate sub-expression analysis, and subscript\/superscript analysis, and character determination. The system may output multiple recognition candidates for each handwritten expression by combining multiple results from the various components. With a correction user interface (U), a user may select a proper choice from the candidates supplied by the system. Aspects of the present invention enable more natural input of mathematical expressions.","Definitions","Stroke is a trajectory of a pen tip between a pen down position and a pen up position. A stroke may be described by a series of points with timestamps (x, y, time).","Symbol includes of one or multiple strokes. A symbol is a handwritten version of pre-defined mathematical characters including Latin alphabets, digits, Greek letters, etc.","Expression is a meaningful combination of mathematical symbols.","Character is the corresponding computer code of a handwritten symbol. Symbol recognition takes the strokes of a symbol as input and outputs the corresponding character of the symbol.","Dominant symbol is a mathematical symbol that may be attached to subordinate sub-expressions. The spatial relationships between dominant symbols and its sub-expressions are variants to the dominant symbols' types. A description of relational types is described below under the section entitled, \u201cSubordinate Sub-expression Analysis\u201d.","Sub-expression is a meaningful sub-part of an expression. An expression may include several sub-expressions, which form a tree structure according to their relationships of principal and subordinate. A sub-expression is an expression. There are two kinds of sub-expressions. A subordinate sub-expression is a sub-expression subordinate to a dominant symbol. Subscript and superscript sub-expressions are sub-expressions that are a subscript or superscript of another symbol.","BST tree (baseline structure tree) is a data structure for representing an expression. In the representation, an expression is a tree, whose levels are baselines. Baseline means that symbols within a baseline are located in a horizontal line. Here, a baseline is a synonym of sub-expression.","Parse tree is an extended version of a BST tree. A parse tree may store multiple results for components of the system and support the functionality of providing multiple recognized candidates for a handwritten expression. A parse tree may be included within a data structure for a computer-readable medium.","Symbol recognizer is the model that implements symbol recognition. The symbol recognizer analyzes all available information, such as shape and time series information of a symbol to recognize the symbols.","On-line features are features that use time series information. Usually, a stroke has the time information of each point of the stroke.","Off-line features do not use time series information, instead they use shape information. Off-line features in symbol recognition are often extracted based on image and pixels.","The Gaussian Mixture Model (GMM) is a mixture probability distribution model. A GMM is a linear combination of K Gaussian components.","Tabular structure includes matrix and multi-line expression. Both structures may be divided into rows and\/or columns. Multi-line expressions always have only one column and have only one curly bracket on the left side. Matrices have brackets on both the left and right sides.","A matrix is a group of structured strokes that may be divided into multiple rows and\/or columns and surrounded by a pair of brackets at both the left and right sides (). Column vectors () and determinants () are also regarded as special matrices.","A multi-line expression is a group of strokes that may be divided into several left aligned rows which are led by a left curly bracket ().","Brackets in tabular structure analysis are a group of symbols that encapsulate tabular structures. For matrices, it may be a bracket, a square bracket or a vertical line at both the left and right side. For multi-line expression, it may be curly bracket at the left side.","Multi-Path Framework Overview",{"@attributes":{"id":"p-0134","num":"0133"},"figref":"FIG. 3","b":["300","303","305","307","309","311","303","307","309"]},"The symbol grouping and recognition component  receives a handwritten mathematical expression  and is responsible for grouping strokes into symbols and for recognizing the symbols. The output of component  is how strokes are grouped to symbols, and possible character candidates and corresponding confidences for each symbol.","Compared to plain text, mathematical expression is a more complex structured layout. Expressions have specific structures. For example, an N-array summation (\u2018\u03a3\u2019) has two attached sub-expressions, above and below sub-expressions to express below and above summation limits. Also, subscripts and superscripts are typical structures in expressions. Aside from hierarchical structures, tabular expression is high level structure, where multiple sub-expressions are at the same level forming a table. Such structure information is useful for recognizing expressions. The structure analysis component is configured to determine structure information. In accordance with at least one aspect of the present invention, the structure analysis component includes the following three sub-components: the tabular structure analysis component ; the subordinate sub-expression analysis component ; and the subscript, superscript analysis and character determination component .","Tabular structure analysis component  includes matrix and multiple-line structure recognition. Tabular structure analysis component  identifies each table and the content of each cell in each table. After tabular structure analysis component  identifies tabular structure, later structure analysis components regard each cell as a sub-expression and analyze the structure for each cell further. Subordinate sub-expression analysis component  is used to find subordinate sub-expressions for each dominant symbol. Subscript, superscript analysis and character determination component  finds subscript and superscript structures and decides each symbol's final character at the same time.","After being processed by the structure analysis component, a tree structure of sub-expressions is found, and the characters of the symbols are decided for the input handwritten mathematical expression. However, the inherent semantic structure is not yet represented in a data structure of a parse tree. Therefore, the semantic structure analysis component  is used to translate the linear symbols that are in a sub-expression into a syntax tree and to adjust the parse tree according to the syntax tree, resulting in a recognized mathematical expression .",{"@attributes":{"id":"p-0139","num":"0138"},"figref":["FIG. 4","FIG. 5","FIG. 5","FIG. 4"],"b":["501","503","551","581","505","507","551","581","563","565","509","563","577","579","565","511"],"sup":"2"},"In accordance with aspects of the present invention, a data structure stores the multiple results obtained by all the multi-path algorithms. The structure is passed from the first component to the last component. Every component gets the structure from the previous component, performs its analysis operation, and then writes its results back into the structure, passing the structure to the next component. After recognition is complete, the system gets the data structure saving multiple results from many components. With the data structure, a whole expression's candidate may be determined by selecting a result for each multi-path component sequentially. Furthermore, the system may determine multiple expression candidates with different selections and then rank the candidates based on a combined score, which may include scores of various components.","Before describing the data structure of multi-results, a data structure representing a single structured expression is described. A baseline structure tree (BST) is used to represent an expression. One point of a BST tree is to view an expression as a tree including multi-level baselines. Within a baseline, symbols are horizontal neighbors. In the layout, the symbols lie in a horizontal line.",{"@attributes":{"id":"p-0142","num":"0141"},"figref":"FIG. 6","b":["601","603"]},"A BST symbol node, shown by a rectangular shape, such as , is a middle-level node between a symbol node and a relational node. The BST symbol node is child node of a relational node. A BST symbol node may have a symbol node and a relational node as its child nodes. A BST symbol node is configured to represent a compound of a dominant symbol and its sub-baselines (sub-expressions). A single symbol, which has no sub-baselines (sub-expressions), is wrapped into a BST symbol node with a tag \u201cnormal\u201d in order to become a child of a relational node. The following tags are defined for a BST symbol node:","Normal: a symbol without subordinates.","Decorated: a symbol with subscript or superscript.","Fraction: a fraction line with denominator and numerator.","Radical: a radical sign with radicand.","Integral: an integral sign with integral limits.","N-Array: an N-Array sign (\u03a3, \u03a0) with above or below limits.","Limits: a symbol \u201clim\u201d with its below subordinate.","Hats: a hat sign (^, \u2212) with its decorated subordinate.","A relational node, shown by a rounded rectangular shape, such as , represents a baseline (sub-expression), which includes several BST symbol nodes located on a horizontal line. Its children are BST symbol nodes. The following tags are defined for a relational node:","Above: a sub-expression above fraction line or N-Array sign.","Below: a sub-expression below fraction line or N-Array sign.","Radicand: a sub-expression that is a radicand of a radical sign.","Radical index: a sub-expression that is radical index of a radical sign.","Superscript: a superscript sub-expression.","Subscript: a subscript sub-expression.","Expression: the main (top-level) sub-expression.","Aside from the above four types of nodes, another type of node, a solution node, is included in the system to represent various results for the same object.  shows how to use solution nodes to represent two interpretations of strokes. Solution1 means \u201cb\u22124ac\u201d, while Solution2 means \u201cbz\u22124ac\u201d. As  shows, the two solutions refer to the same set of strokes. In implementation, it is also necessary to perform these multiple references to the same objects. Because multiple results may be outputted from three components, duplication of a tree or a sub-tree for each of these results would require a huge amount of memory due to exponential combinations. Moreover, the idea of simple duplication also results in unnecessary repeated calculations for same objects. For example, symbols of \u201cb2\u22124ac\u201d are a sub-expression in the result  from . To implement duplication, subscript, superscript analysis, and character determination has to be done at least twice for the sub-expression because symbols of \u201cb2\u22124ac\u201d are duplicated for each way of grouping strokes. As shown in , results  and  are duplicated for both results  and . Therefore, in accordance with aspects of the present invention, a data structure is implemented where the same child objects may be referred to by multiple parent objects. With this implementation, an extended BST tree is not just a tree structure, but a directional acyclic graph. With such a new type of node and design of multiple references, a BST tree may be extended to a data structure, which may store multiple results obtained by the components. In one embodiment, an extended BST tree is parsed component by component and is often referred to as a parse tree. A parse tree may be included within a data structure.","The following paragraphs will use the example in  to explain how the parse tree evolves by each component.","Handwritten Expression Input ","Before recognition starts, the expression is a set of strokes without structure information. As shown in , the system collects all ink strokes and creates a parse tree, which is a sequence of strokes. At this point, all stroke nodes are located under a root expression node, parallel to each other.","Symbol Grouping and Recognition ","This component takes the input of strokes, and groups the strokes into symbols using a dynamic programming algorithm. Symbol nodes are created to store results at this stage. During dynamic programming, a symbol recognizer is called to test if several strokes could be a meaningful symbol. In this component, there are multiple ways to group strokes. So solution nodes are created in the parse tree to store the multiple results.  shows the parse tree after the symbol grouping and recognition component has determined its results.",{"@attributes":{"id":"p-0164","num":"0163"},"figref":["FIG. 9","FIG. 9"]},"The symbol recognizer is called again for each grouped symbol to find possible character candidates and corresponding confidences. The character candidates and confidences are stored at corresponding symbol nodes. They will be passed on to the next component. Later a structure analysis component performs its operation based on the symbol node information.","Subordinate sub-expression analysis component ","This component finds subordinate sub-expressions subordinate to dominant symbols. The component finds all possible dominant symbol candidates. Then it tentatively looks for subordinate symbols for the candidates using spatial information, such as symbol distance, size, etc. If subordinate symbols are found, then the candidate is a real dominant symbol. Otherwise, the candidate is not a dominant symbol. For each real dominant symbol, the found subordinate symbols construct a subordinate sub-expression.",{"@attributes":{"id":"p-0167","num":"0166"},"figref":["FIG. 10","FIG. 10"]},"Subscript, Superscript Analysis and Character Determination Component ","Subscript and superscript structures are identified in this step. Subscript and superscript structures are not only related to the symbols' spatial relationship, they are also dependent on the symbols' characters. For example, \u2018\u00d7\u2019, as used for multiplication operations, can not be a subscript. Therefore, the component performs two tasks, subscript, superscript analysis and character determination, at the same time. Moreover, syntax analysis is utilized in the component to verify that multiple results outputted by this component are valid in the sense of expression grammar.",{"@attributes":{"id":"p-0169","num":"0168"},"figref":"FIG. 11","sup":"2"},"Semantic Structure Analysis","After previous processing, a tree structure of sub-expressions is built up and every character is determined. But semantic structure is not discovered in its sub-expressions. In order to make recognized expression become a semantic structure, text strings translated from sub-expressions are parsed by syntax analysis and transformed into a syntax tree. Finally, this component revises the parse tree according to the results of syntax analysis. The system names the final parse tree as a semantic tree of the expression.","A semantic tree corresponds to the semantic structure of an expression. In the tree, high level math concepts, such as operators, operands, and priorities etc., are defined. With the semantic tree, the expression may be calculable.  shows how to represent a semantic tree using BST symbol and relational nodes. There, symbol \u201c\u2212\u201d becomes a BST symbol, because it is an operator. This BST symbol has two relational nodes, representing two operands respectively.","The component uses a context-free parser to do syntax analysis. The parser algorithm is a well-known technique, widely applied in the fields of language compiler, natural language processing, knowledge-based system, etc. In the system, a library of grammar rules for mathematical expression may be built. The library may include in excess of 1,000 grammar rules. The following are three example rules about a fraction structure:","FRACTION\u2212>FRACTIONLINE DENOMINATOR NUMERATOR","DENOMINATOR\u2212>SYMBOL_LEFTCONTROL OPERAND SYMBOL_RIGHTCONTROL","NUMERATOR\u2212>SYMBOL_LEFTCONTROL OPERAND SYMBOL_RIGHTCONTROL","Aspects of the present invention recognize a multitude of symbols including Latin alphabets (a, b, c, A, B, C, etc.), Greek letters (\u03b1, \u03b2, \u03b8, \u03bb, \u03c9, etc.), Latin digits (1, 2, 3, 4, 5, etc.), Operators (\u03a3, \u03a0, \u222b, \u00b1, \u00d7, etc.), and frequently used mathematical symbols (\u2202, etc.). Aspects of the present invention also support frequently used expression types, including Arithmetic operations (+, \u2212, \u00d7, \/, etc.), Fraction (-), Radical (\u221a), Integral (\u222b), N-Array (\u03a3, \u03a0), Limits (lim), multi-letter functions (sin, cos, tan, log, In, etc.), Hats (\u00e2, , etc.), and matrix and\/or multi-line expressions. In one embodiment, in excess of 150 different mathematical symbols may be recognized by the system.","Symbol Grouping and Recognition","Referring back to , the symbol grouping and recognition component  is one part of the whole mathematical expression recognition system . The output of component  is how strokes are grouped to symbols and possible character candidates and a corresponding confidence for each symbol. Symbol grouping groups strokes into math symbols. Symbol recognition recognizes the symbols using all available information, e.g. shape, time series, and context. As described above, due to ambiguities of a symbol, symbol recognition outputs multiple recognition results.","An on-line handwritten symbol written on a digitizing tablet is represented as a sequence of strokes, which are the loci of the pen tip from its pen-down to pen-up position. On-line recognition is considerably different from off-line recognition because of the dynamic information on writing. Symbol recognition methods are roughly classified into three major groups: statistical method, structure and syntax analysis method, and model matching methods. In accordance with at least one aspect of the present invention, statistical methods are used to recognize symbols. A statistical symbol recognition method consists of two processes, a training stage and a recognition stage. The training framework and recognition framework are shown in .","In the training stage, a large amount of training data is assumed available to build some statistical model. Handwritten strokes are first smoothed and normalized to a fixed size. In sequence, some statistical features are extracted from the unknown symbol. Dimensional reduction is used to optimize these features. Next, Gaussian Mixture Models (GMM) are trained as a classifier. Then, discriminative training is adopted to optimize the GMM. In the recognition stage, after preprocessing and feature extraction, the unknown symbol is classified to the class whose members have the most similar features. GMM is a mixture probability distribution model, which provides better similarity measurement than template based classifiers.","Many mathematical symbols are written with multiple strokes. For instance, \u2018A\u2019 may be written with 3 strokes. Usually, an expression consists of several symbols, and each symbol may have one or multiple strokes. But in the input data, all strokes of the symbols are mixed together. Therefore, the first step of handwritten expression recognition is to identify which strokes construct a symbol, and how many symbols are in the handwriting expression. After the identification, ink strokes are grouped into symbols. Then, a subsequent structure analysis may perform further recognition based on the new data representation provided by the symbol grouping step.","Symbol grouping and symbol recognition interacts with each other during the recognition process.  shows the flowchart of symbol grouping and recognition. Symbol grouping and recognition  receives input strokes  from the parse tree (as shown in ), and groups input strokes  into symbols  using dynamic programming algorithm. During dynamic programming, symbol recognizer is called to test whether several strokes could be a meaningful symbol. In this component, there are possible multiple results of symbol grouping. Symbol grouping  and symbol recognition  create solution nodes in a parse tree to write back the multiple results.  shows the changed parse tree after symbol recognition and grouping. Symbol nodes are created at this stage. Then symbol recognizer is called again for each grouped symbol to find possible characters candidates and confidences. Character candidates and confidence of a grouped symbol are stored by corresponding symbol nodes. They are passed to succeeding components through the parse tree. The structure analysis component performs its operation at a later time based on the symbol node information.","Symbol Recognition","In one embodiment, an approach based upon Gaussian Mixture Model (GMM) is used to implement symbol recognition. An off-line feature is used in the GMM based symbol recognition. For computing off-line features, the writing direction for each point in the symbol strokes is calculated. The writing direction is the tangent direction of a sampling point. Usually, a tangent direction is not easy to calculate. For sampling point t, the tangent direction is estimated by using the line direction between sampling point t-1 and sampling point t. The angle (\u03b1) between this line and the horizontal line is the value of the writing direction of point t. The writing direction is defined by:",{"@attributes":{"id":"p-0183","num":"0182"},"maths":[{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"\u0394","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"x","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}},{"mrow":[{"mi":"x","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},{"mi":"x","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"t","mo":"-","mn":"1"}}}],"mo":"-"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00001-2","num":"00001.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"\u0394","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"y","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}},{"mrow":[{"mi":"y","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},{"mi":"y","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"t","mo":"-","mn":"1"}}}],"mo":"-"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00001-3","num":"00001.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"cos","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"\u03b1","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}},"mo":"=","mfrac":{"mrow":{"mi":"\u0394","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"x","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}},"msqrt":{"mrow":{"mrow":[{"mi":"\u0394","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msup":{"mi":"x","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}},{"mi":"\u0394","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msup":{"mi":"y","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}}],"mo":"+"}}}}}},{"@attributes":{"id":"MATH-US-00001-4","num":"00001.4"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"sin","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"\u03b1","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}},"mo":"=","mfrac":{"mrow":{"mi":"\u0394","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"y","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}},"msqrt":{"mrow":{"mrow":[{"mi":"\u0394","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msup":{"mi":"x","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}},{"mi":"\u0394","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msup":{"mi":"y","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}}],"mo":"+"}}}}}}]},{"@attributes":{"id":"p-0184","num":"0183"},"figref":["FIG. 17","FIG. 17"],"sup":"th "},"Because the size of different images is different, it is inconvenient to measure them. So, the image was normalized to a fixed scale of 64\u00d764 pixels in symbol recognition. In this example, a nonlinear normalization is used. After normalization, the center of the normalized image should correspond to the gravity point. Normalization may be expressed as:\n\n\n\n\n\nwhere (x, y) is a point of original image, and (m, n) is a corresponding point in a normalized image. Here, five corresponding points may be obtained to solve this equation:\n\n(0,0)\u2192(0,0),\n\n(0,0)\u2192(0, M),\n\n(Y,0)\u2192(N,0),\n\n(X, Y)\u2192(M, N),\n\n(Centroid)\u2192(M\/2,N\/2),\n\nwhere X, Y is the width and height of the original image, and M, N is width and height of the normalized image, respectively. After these six (6) parameters are calculated, the origin point will be normalized using the above two equations. The centroid point may be calculated by:\n",{"@attributes":{"id":"p-0186","num":"0185"},"maths":[{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"CX","mo":"=","mfrac":{"mrow":[{"munderover":{"mo":"\u2211","mrow":[{"mi":"i","mo":"=","mn":"1"},{"mi":["m","n"],"mo":"\u00d7"}]},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mrow":[{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"i"}},{"mi":"x","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"i"}}],"mo":"\u2062"}},{"munderover":{"mo":"\u2211","mrow":[{"mi":"i","mo":"=","mn":"1"},{"mi":["m","n"],"mo":"\u00d7"}]},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"i"}}}]}}}},{"@attributes":{"id":"MATH-US-00002-2","num":"00002.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"CY","mo":"=","mfrac":{"mrow":[{"munderover":{"mo":"\u2211","mrow":[{"mi":"i","mo":"=","mn":"1"},{"mi":["m","n"],"mo":"\u00d7"}]},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mrow":[{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"i"}},{"mi":"y","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"i"}}],"mo":"\u2062"}},{"munderover":{"mo":"\u2211","mrow":[{"mi":"i","mo":"=","mn":"1"},{"mi":["m","n"],"mo":"\u00d7"}]},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"i"}}}]}}}}],"br":{},"sup":"th "},"The writing direction of each point is classified to eight (8) levels.  shows the quantified 8 directions. For example, as shown in , if the writing direction \u03b1 of a point is 140\u00b0, then the quantified direction value is 4.","The commonly used mesh statistical method may be used to obtain a feature vector. The image may be evenly subdivided into 8 rows and 8 columns, so that the size of each sub-region is 8\u00d78. The number of each direction in each sub-region is counted. A 512-dimension feature vector (8 rows\u00d78 columns\u00d78 directions) is obtained. For example, there are five black pixels in a sub-region. Writing directions of the 5 pixels are 30\u00b0, 40\u00b0, 50\u00b0, 80\u00b0, 110\u00b0. The quantified direction of each pixel, 1, 1, 2, 2, 3, may be obtained respectively. The 8 dimensional feature vector of this sub-region is 2, 2, 1, 0, 0, 0, 0, 0. All 64 sub-regions have such an 8 dimensional feature vector and finally a 512-dimensional feature vector may be generated.","Dimension reduction is another step in symbol recognition. Two reasons for using dimension reduction include cost and relativity. A 512-dimension system requires much more in calculation and some features may be correlated to other features, e.g., redundant information exists in the 512-dimension feature. In accordance with at least one aspect of the present invention, the 512-dimension feature is transformed to a 128-dimension feature. Any of a number of different dimension reduction techniques may be used for this purpose and those skilled in the art would understand the various techniques.","A technique commonly used for dimensionality reduction is Fisher's Linear Discriminant (FLD). It should be understood by those skilled in the art that FLD is commonly known. FLD is an example of a class specific method, in the sense that it tries to \u201cshape\u201d the scatter in order to make it more reliable for classification. This method selects the projection Win such a way that the ratio of the between-class scatter and the within-scatter is maximized. The between-class scatter matrix may be defined as:",{"@attributes":{"id":"p-0191","num":"0190"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"msub":{"mi":["S","B"]},"mo":"=","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"c"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mrow":{"msub":{"mi":["P","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["\u03bc","i"]},"mo":"-","mi":"\u03bc"}}},"mo":"\u2062","msup":{"mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["\u03bc","i"]},"mo":"-","mi":"\u03bc"}},"mi":"T"}}}},"mo":","}}},"br":{}},{"@attributes":{"id":"p-0192","num":"0191"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"msub":{"mi":["S","w"]},"mo":"=","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"x"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":{"mi":["P","i"]},"mo":["\u2062","\u2062"],"mfrac":{"mn":"1","msub":{"mi":["N","i"]}},"mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"j","mo":"=","mn":"1"},"msub":{"mi":["N","i"]}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["x","j"]},{"mi":["\u03bc","i"]}],"mo":"-"}},"mo":"\u2062","msup":{"mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["x","j"]},{"mi":["\u03bc","i"]}],"mo":"-"}},"mi":"T"}}}}}},"mo":","}}},"br":{},"sub":["i ","i","i ","i","i ","i","opt"]},{"@attributes":{"id":"p-0193","num":"0192"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["W","opt"]},"mo":"=","mrow":{"mrow":[{"mi":["arg","max"],"mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mfrac":{"mrow":[{"mo":["\uf603","\uf604"],"mrow":{"msup":{"mi":["W","T"]},"mo":["\u2062","\u2062"],"msub":{"mi":["S","B"]},"mi":"W"}},{"mo":["\uf603","\uf604"],"mrow":{"msup":{"mi":["W","T"]},"mo":["\u2062","\u2062"],"msub":{"mi":["S","w"]},"mi":"W"}}]}},{"mo":["[","]"],"mrow":{"msub":[{"mi":"w","mn":"1"},{"mi":"w","mn":"2"},{"mi":["w","m"]}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":"\u2026"}}],"mo":"="}}}}},"This ratio is maximized when the column vectors of projection matrix W are the eigenvectors of SSassociated with the largest eigen values. The result is to maximize the between-class scatter while minimizing the within-class scatter.","To avoid the ill-pose problem when computing the eigen values of the matrix SS, one embodiment of the present invention adopts the method as described in Swets, Daniel L. and Weng, John, , IEEE Trans Pattern Analysis and Machine Intelligence, vol. 18, pp. 831-836, 1996. It should be understood by those skilled in the art, this method is merely illustrative and that any other similar methods may be used for the purpose.","H and \u039b are computed such that, S=H\u039bH, where H is orthogonal and \u039b is diagonal. Then,",{"@attributes":{"id":"p-0197","num":"0196"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"msup":{"mrow":{"mo":["(",")"],"mrow":{"mi":"H","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mi":"\u039b","mrow":{"mo":"-","mfrac":{"mn":["1","2"]}}}}},"mi":"t"},"mo":"\u2062","mrow":{"msub":{"mi":["S","w"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"H","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mi":"\u039b","mrow":{"mo":"-","mfrac":{"mn":["1","2"]}}}}}}},"mo":"=","mi":"I"}}}},"U and \u03a3 are then computed such that,",{"@attributes":{"id":"p-0199","num":"0198"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"msup":{"mrow":{"mo":["(",")"],"mrow":{"mi":"H","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mi":"\u039b","mrow":{"mo":"-","mfrac":{"mn":["1","2"]}}}}},"mi":"t"},"mo":"\u2062","mrow":{"msub":{"mi":["S","b"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"H","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mi":"\u039b","mrow":{"mo":"-","mfrac":{"mn":["1","2"]}}}}}}},{"mi":"U","mo":"\u2062","mrow":{"mo":["\u2211","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mi":["U","t"]}}}],"mo":"="},"mo":","}}},"br":{}},{"@attributes":{"id":"p-0200","num":"0199"},"maths":[{"@attributes":{"id":"MATH-US-00008","num":"00008"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"msubsup":{"mi":["S","w"],"mrow":{"mo":"-","mn":"1"}},"mo":"=","mrow":{"mi":"H","mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":[{"mi":"\u039b","mrow":{"mo":"-","mn":"1"}},{"mi":["H","t"]}]}},"mo":",","mi":"and"}}},{"@attributes":{"id":"MATH-US-00008-2","num":"00008.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["S","b"]},"mo":"=","mrow":{"mi":["H","U"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mi":"\u039b","mfrac":{"mn":["1","2"]}},"mrow":{"mo":["\u2211","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msup":[{"mi":["U","t"]},{"mi":"\u039b","mfrac":{"mn":["1","2"]}},{"mi":["H","t"]}],"mo":["\u2062","\u2062"]}}}}}}]},"Defining,",{"@attributes":{"id":"p-0202","num":"0201"},"maths":{"@attributes":{"id":"MATH-US-00009","num":"00009"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mo":"\u2207","mrow":{"mo":"=","mrow":{"mi":["H","U"],"mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mi":"\u039b","mrow":{"mo":"-","mfrac":{"mn":["1","2"]}}}}}},"mo":","}}},"br":{},"sub":["w","b "],"sup":"\u22121"},{"@attributes":{"id":"p-0203","num":"0202"},"maths":{"@attributes":{"id":"MATH-US-00010","num":"00010"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"msubsup":{"mi":["S","w"],"mrow":{"mo":"-","mn":"1"}},"mo":"\u2062","msub":{"mi":["S","b"]}},{"mi":["H","H","U"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msup":[{"mi":"\u039b","mrow":{"mo":"-","mn":"1"}},{"mi":["H","t"]},{"mi":"\u039b","mfrac":{"mn":["1","2"]}}],"mrow":{"mo":["\u2211","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msup":[{"mi":["U","t"]},{"mi":"\u039b","mfrac":{"mn":["1","2"]}},{"mi":["H","t"]}],"mo":["\u2062","\u2062"]}}}],"mo":"="}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mo":"\u2207","mrow":{"mo":["\u2211","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mo":"\u2207","mrow":{"mo":"-","mn":"1"}}}}}}}]}}}},"Fisher's Linear Discriminant (FLD) technique may be applied to transform a 512-dimension off-line feature into a 128-dimension feature. When this feature is fed into a GMM for symbol recognition purpose, dimension reduction significantly reduces calculation costs. In addition, recognition accuracy is also improved. The FLD technique maximizes the between-class scatter while minimizing the within-class scatter. As a result, the classification capacity of the reduced feature may be optimized.","The computation of product of a high-dimensional matrix and a high-dimensional vector is costly. The computation cost could be reduced by various techniques, such as quantification.","Gaussian Mixture Model (GMM) is a mixture probability distribution model. The probability of a symbol class may be represented by a GMM. If the number of symbol classes is C, C GMMs are required for classification task. A GMM is a linear combination of K Gaussian components, given by",{"@attributes":{"id":"p-0207","num":"0206"},"maths":{"@attributes":{"id":"MATH-US-00011","num":"00011"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"x"}},{"munderover":{"mo":"\u2211","mrow":{"mi":"k","mo":"=","mn":"1"},"mi":"K"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"p","mo":["(","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.em","height":"0.ex"}}},"mrow":{"mrow":{"mrow":[{"mi":"x","mo":["\u2062","\u2062"],"mrow":[{"mo":["\uf603",")"],"mi":"k"},{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"k"}}]},{"mrow":[{"munderover":{"mo":"\u2211","mrow":{"mi":"k","mo":"=","mn":"1"},"mi":"K"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mrow":[{"msub":{"mi":["N","k"]},"mo":["(","\u2062",")"],"mrow":{"mrow":{"mi":"x","mo":"|","msub":{"mi":["\u03bc","k"]}},"mo":",","munder":{"mo":"\u2211","mi":"k"}},"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"k"}}],"mo":"\u2062"}},{"munderover":{"mo":"\u2211","mrow":{"mi":"k","mo":"=","mn":"1"},"mi":"K"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mrow":{"msub":{"mi":["N","k"]},"mo":["(","\u2062",")"],"mrow":{"mrow":{"mi":"x","mo":"|","msub":{"mi":["\u03bc","k"]}},"mo":",","munder":{"mo":"\u2211","mi":"k"}},"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mo":"\u2062","msub":{"mi":["c","k"]}}}],"mo":"="}],"mo":"="},"mo":","}}}],"mo":"="}}},"br":{},"sub":["k ","k"]},{"@attributes":{"id":"p-0208","num":"0207"},"maths":{"@attributes":{"id":"MATH-US-00012","num":"00012"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"k","mo":"=","mn":"1"},"mi":"K"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["c","k"]}},"mo":"=","mn":"1"},{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","k"],"mo":"|"}}}],"mo":","}}},"br":{}},{"@attributes":{"id":"p-0209","num":"0208"},"maths":{"@attributes":{"id":"MATH-US-00013","num":"00013"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"mi":"p","mo":["(",")"],"mrow":{"mi":["x","k"],"mo":"|"}},{"mrow":[{"msub":{"mi":["N","k"]},"mo":["(","\u2062",")"],"mrow":{"mrow":{"mi":"x","mo":"|","msub":{"mi":["\u03bc","k"]}},"mo":",","munder":{"mo":"\u2211","mi":"k"}},"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"munderover":{"mo":"\u2211","mrow":{"mi":"j","mo":"=","mn":"1"},"mi":"D"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mfrac":{"mn":"1","mrow":{"msup":{"mrow":[{"mo":["(",")"],"mrow":{"mn":"2","mo":"\u2062","mi":"\u03c0"}},{"mi":"D","mo":"\/","mn":"2"}]},"mo":"\u2062","msubsup":{"mi":["\u03c3","j","d"]}}},"mo":"\u2062","mrow":{"mi":"exp","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mo":"-","mfrac":{"mn":["1","2"]}},"mo":"\u2062","mfrac":{"msup":{"mrow":{"mo":["(",")"],"mrow":{"mi":"x","mo":"-","msub":{"mi":["\u03bc","j"]}}},"mn":"2"},"msubsup":{"mi":["\u03c3","j"],"mn":"2"}}}}}}}],"mo":"="}],"mo":"="},"mo":","}}},"br":{},"sub":["k","k","k "],"sup":"th "},"Next, a set of class conditional likelihood functions is considered:\n\n(: \u039b)=(),\n\nwhere i=1,2, . . . , C defined by the parameter set A (including \u03bc, \u03c3, c).\n","The classifier\/recognizer operates under the following decision rule (classifier):",{"@attributes":{"id":"p-0212","num":"0211"},"maths":{"@attributes":{"id":"MATH-US-00014","num":"00014"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"C","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"X"}},{"mrow":[{"msub":{"mi":["C","i"]},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"if","mrow":{"msub":{"mi":["g","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["X","\u039b"],"mo":";"}}}},{"munder":{"mi":["max","j"]},"mo":"\u2062","mrow":{"msub":{"mi":["g","j"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["X","\u039b"],"mo":";"}}}}],"mo":"="}],"mo":"="}}}},"The Expectation-Maximum (EM) algorithm is a general method of finding the maximum Likelihood Estimation (MLE). In accordance with at least one aspect of the present invention, an EM algorithm is used to train a GMM via EM. The following is a process of training a GMM.","The process begins with data set X of N feature vectors x,n=1, . . . , N, an initial set of K Gaussian components with N=N(x|\u03bc, \u03a3), and K mixture weights C, k=1, . . . , K. N is number of training symbols and the dimension feature is 128.","Then, the responsibility p(k|x) of each component PDF for each training symbol feature (128-dimension) is determined as",{"@attributes":{"id":"p-0216","num":"0215"},"maths":{"@attributes":{"id":"MATH-US-00015","num":"00015"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"msub":{"mi":["p","kn"]},"mo":"=","mrow":{"mrow":{"mi":"p","mo":["(",")"],"mrow":{"mi":"k","mo":"|","msub":{"mi":["x","n"]}}},"mo":"=","mfrac":{"mrow":[{"mrow":[{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["x","n"]},"mo":"|","mi":"k"}}},{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"k"}}],"mo":"\u2062"},{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["x","n"]}}}]}}},"mo":","}}},"br":{}},{"@attributes":{"id":"p-0217","num":"0216"},"maths":{"@attributes":{"id":"MATH-US-00016","num":"00016"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["x","n"]}}},{"munderover":{"mo":"\u2211","mrow":{"mi":"k","mo":"=","mn":"1"},"mi":"K"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mrow":[{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["x","n"]},"mo":"|","mi":"k"}}},{"mrow":{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"k"}},"mo":"."}],"mo":"\u2062"}}],"mo":"="}}}},"Next, components' probability distribution functions (PDFs) and weights are re-estimated based on the data and responsibilities:",{"@attributes":{"id":"p-0219","num":"0218"},"maths":[{"@attributes":{"id":"MATH-US-00017","num":"00017"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mover":{"mi":"p","mo":"^"},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"k"}},{"mfrac":{"mn":"1","mi":"N"},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"n","mo":"=","mn":"1"},"mi":"N"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["p","kn"]}}}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00017-2","num":"00017.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mover":{"mi":"\u03bc","mo":"^"},"mo":"=","mfrac":{"mrow":[{"munder":{"mo":"\u2211","mi":"n"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":[{"mi":["p","kn"]},{"mi":["x","n"]}],"mo":"\u2062"}},{"munder":{"mo":"\u2211","mi":"n"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["p","kn"]}}]}}}},{"@attributes":{"id":"MATH-US-00017-3","num":"00017.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msubsup":{"mover":{"mi":"\u03c3","mo":"^"},"mi":"ik","mn":"2"},"mo":"=","mfrac":{"mrow":[{"munder":{"mo":"\u2211","mi":"n"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mrow":{"msub":{"mi":["p","kn"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["x","in"]},{"mover":{"mi":"\u03bc","mo":"^"},"mi":"ik"}],"mo":"-"}}},"mn":"2"}},{"munder":{"mo":"\u2211","mi":"n"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["p","kn"]}}]}},{"mi":"i","mo":"=","mn":"1"},{"mi":"D","mo":"."}],"mo":[",",",",",","\u2062",","],"mn":"2","mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}}}}]},"The responsibility of each component PDF for each training symbol feature is determined, and the component PDFs and weights are re-estimated until GMM likelihood p(x)=\u03a0p(x) of the entire training data set does not change appreciably:",{"@attributes":{"id":"p-0221","num":"0220"},"maths":{"@attributes":{"id":"MATH-US-00018","num":"00018"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"mi":["\u0394","L"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mfrac":{"mrow":[{"msub":[{"mi":["L","Current"]},{"mi":["L","previous"]}],"mo":"-"},{"mo":["\uf603","\uf604"],"msub":{"mi":["L","Previous"]}}]},"mo":"<","mrow":{"mn":"1","mo":"\u00d7","msup":{"mn":"10","mrow":{"mo":"-","mn":"4"}}}}],"mo":"="},"mo":","}}},"br":{}},"Finally, the Gaussian Mixture Models are saved as classifier parameters.","One component in the pattern matching approach to symbol recognition is the training algorithm, which aims to produce typical (reference) patterns or models for accurate pattern comparison. In accordance with at least one aspect of the present invention, the method of classifier design by way of distribution estimation and the discriminative method of minimizing classification error rate (MCE) are used. In general, after EM training, the MCE method provides a significant reduction of recognition error rate. On a training sample, a loss function is computed to approximate the classification error, and on a training dataset, the empirical loss is minimized by gradient descent to optimize the classifier parameters. Let the discriminant function of class \u03c9equate to:",{"@attributes":{"id":"p-0224","num":"0223"},"maths":{"@attributes":{"id":"MATH-US-00019","num":"00019"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":["g","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["X","\u039b"],"mo":";"}}},{"munder":{"mi":["max","j"]},"mo":"\u2062","mrow":{"mrow":{"msub":{"mi":["g","j"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["X","\u039b"],"mo":";"}}},"mo":"."}}],"mo":"="}}}},"One difficulty associated with the MCE training approach lies in the derivation of an objective function that has to be not only consistent with the performance measure, i.e., the error rate, but also suitable for optimization. The error rate based on a finite data set is a piecewise constant function of the classifier parameter \u039b, and thus a poor candidate for optimization by a simple numerical search method. Following the methods as described in Juang, Biing-Whang et al., , IEEE Transaction on Speech and Audio Processing, vol. 5, no. 3, May 1997, the misclassification measure of a pattern from class \u03c9is given by:",{"@attributes":{"id":"p-0226","num":"0225"},"maths":{"@attributes":{"id":"MATH-US-00020","num":"00020"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"msub":{"mi":["d","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"x"}},{"mrow":{"mo":"-","mrow":{"msub":{"mi":["g","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","\u039b"],"mo":";"}}}},"mo":"+","msup":{"mrow":[{"mi":"log","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mfrac":{"mn":"1","mrow":{"mi":"M","mo":"-","mn":"1"}},"mo":"\u2062","mrow":{"munder":{"mo":"\u2211","mrow":{"mi":"j","mo":",","mrow":{"mi":["j","i"],"mo":"\u2260"}}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"exp","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mrow":{"msub":{"mi":["g","j"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","\u039b"],"mo":";"}}},"mo":"\u2062","mi":"\u03b7"}}}}}}},{"mn":"1","mo":"\/","mi":"\u03b7"}]}}],"mo":"="},"mo":","}}},"br":{},"sup":"th ","sub":["i","i"]},"A loss function may be defined as:",{"@attributes":{"id":"p-0228","num":"0227"},"maths":{"@attributes":{"id":"MATH-US-00021","num":"00021"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"msub":{"mi":["l","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["X","\u039b"],"mo":";"}}},{"mrow":{"mi":"l","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["d","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"X"}}}},"mo":"=","mfrac":{"mn":"1","mrow":{"mn":"1","mo":"+","mrow":{"mi":"exp","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mo":"-","mi":"\u03b3"},{"msub":{"mi":["d","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"X"}}],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}}}}}],"mo":"="},"mo":","}}},"br":{},"sub":"i"},{"@attributes":{"id":"p-0229","num":"0228"},"maths":{"@attributes":{"id":"MATH-US-00022","num":"00022"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"mi":"l","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["X","\u039b"],"mo":";"}}},{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"C"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mrow":[{"msub":{"mi":["l","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["X","\u039b"],"mo":";"}}},{"mo":["(",")"],"mrow":{"mi":"x","mo":"\u2208","msub":{"mi":["C","i"]}}}],"mo":["\u2062","\u2062"],"mn":"1"}}],"mo":"="},"mo":","}}},"br":{}},{"@attributes":{"id":"p-0230","num":"0229"},"maths":{"@attributes":{"id":"MATH-US-00023","num":"00023"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mn":"1","mo":"\u2062","mrow":{"mo":["(",")"],"mi":"x"}},{"mo":"{","mtable":{"mtr":[{"mtd":[{"mn":"1"},{"mrow":{"mi":["x","is","true"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}]},{"mtd":[{"mn":"0"},{"mrow":{"mi":["x","is","false"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}]}]}}],"mo":"="}}}},"So the expected loss may be defined as:",{"@attributes":{"id":"p-0232","num":"0231"},"maths":{"@attributes":{"id":"MATH-US-00024","num":"00024"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"L","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"\u039b"}},{"mrow":[{"msub":{"mi":["E","X"]},"mo":"\u2062","mrow":{"mo":["{","}"],"mrow":{"mi":"l","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["X","\u039b"],"mo":";"}}}}},{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"C"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":{"mo":"\u222b","mrow":{"mi":"x","mo":"\u2208","msub":{"mi":["C","i"]}}},"mo":"\u2062","mrow":{"mrow":[{"msub":{"mi":["l","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","\u039b"],"mo":";"}}},{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"x"}},{"mrow":{"mo":"\u2146","mi":"x"},"mo":"."}],"mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.2em","height":"0.2ex"}}}}}}],"mo":"="}],"mo":"="}}}},"In discriminative learning, the parameters of GMM are adjusted to minimize the classification error on the training dataset. Various minimization algorithms may be used to minimize the expected loss. The generalized probabilistic descent (GDP) algorithm is an algorithm that may be used to accomplish this task. In the GPD-based minimization algorithm, the above target function L(\u039b) is minimized according to an iterative procedure. The parameters are updated by following equation:\n\n\u039b=\u039b\u2212\u03b5(x,\u039b)|,\n\nwhere t is iteration times and \u03b5(t) is a small positive number satisfying:\n",{"@attributes":{"id":"p-0234","num":"0233"},"maths":{"@attributes":{"id":"MATH-US-00025","num":"00025"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"t","mo":"=","mn":"1"},"mi":"\u221e"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["\u025b","t"]}},"mo":"=","mi":"\u221e"},{"mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"t","mo":"=","mn":"1"},"mi":"\u221e"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msubsup":{"mi":["\u025b","t"],"mn":"2"}},"mo":"<","mi":"\u221e"},{"msub":{"mi":["\u025b","t"]},"mo":">","mn":"0."}],"mo":[",",","]}}}},"The following GMM parameter transformations maintain the following constraints during adaptation:",{"@attributes":{"id":"p-0236","num":"0235"},"maths":[{"@attributes":{"id":"MATH-US-00026","num":"00026"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":["c","jk"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"t","mo":"+","mn":"1"}}},{"mrow":[{"msub":{"mi":["c","jk"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},{"mrow":{"mi":"\u025b","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},"mo":"\u2062","mfrac":{"mrow":[{"mo":"\u2202","mrow":{"msub":{"mi":["l","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","\u039b"],"mo":";"}}}},{"mo":"\u2202","mrow":{"msub":{"mi":["c","jk"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}}]}}],"mo":"-"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00026-2","num":"00026.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":["\u03bc","jkl"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"t","mo":"+","mn":"1"}}},{"mrow":[{"msub":{"mi":["c","jkl"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},{"mrow":{"mi":"\u025b","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},"mo":"\u2062","mfrac":{"mrow":[{"mo":"\u2202","mrow":{"msub":{"mi":["l","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","\u039b"],"mo":";"}}}},{"mo":"\u2202","mrow":{"msub":{"mi":["\u03bc","jkl"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}}]}}],"mo":"-"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00026-3","num":"00026.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":["\u03c3","jkl"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"t","mo":"+","mn":"1"}}},{"mrow":[{"msub":{"mi":["\u03c3","jkl"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},{"mrow":{"mi":"\u025b","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},"mo":"\u2062","mfrac":{"mrow":[{"mo":"\u2202","mrow":{"msub":{"mi":["l","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","\u039b"],"mo":";"}}}},{"mo":"\u2202","mrow":{"msub":{"mi":["\u03c3","jkl"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}}]}}],"mo":"-"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00026-4","num":"00026.4"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"\u025b","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},{"mrow":{"msub":{"mi":"\u025b","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","mfrac":{"mi":"t","msub":{"mi":["T","max"]}}}}},"mo":"."}],"mo":"="}}}]},"In another embodiment, a two-layer classifier may be used to implement symbol recognition.  is the flowchart of a two-layer symbol recognition. First, symbol recognizer extracts off-line features  of the strokes  which may be a symbol grouped by symbol grouping. Subspace classifier  is used to classify the features and gives character candidates with confidence. If the top-1 confidence of the first candidate is high enough , the symbol recognizer will output the candidates and confidence directly . Otherwise, the recognition will go to the second layer. On-line features will be extracted  and the nearest center classifier  is used to give new character candidates and confidence.","The off-line classifier is a template-based classifier, which uses the same approaches of feature extraction and dimension reduction with GMM recognition. The online classifier is also based on a template matching approach. The online classifier extracts on-line features, and uses a classic Dynamic Time Warping (DTW) algorithm to calculate the distance between a template and a test pattern.","For on-line feature extraction, dominant points are first detected at strokes. Dominant points are important points that may represent strokes well. If dominant points are removed from strokes, the strokes will be distorted significantly. In this example as shown in , the following three types of dominant points are used: pen-down and pen-up points, corner points, and mid-points. A pen-down and pen-up points are used firstly. A pen-down point is the first point of a stroke and a pen-up point is the last point of a stroke. If a writing direction of a point changes above a threshold amount from that of its previous point, we call this point as a corner point. The third type is the mid-points, which are points between two dominant points with above types. If a distance of two dominant points is too far, a third type of dominant point is created.","With the dominant points detected, a local feature for each dominant point is extracted. Local features include the tangent direction and curvature direction. Every dominant point has a 4 dimensional feature: f=(cos \u03b1(i), sin \u03b1(i), cos \u03b2(i), sin \u03b2(i)). The tangent direction (\u03b1) is shown in . In , the angle (\u03b1) between the two lines is the approximate curvature direction (\u03b2). The curvature direction feature is described as:\n\ncos \u03b2()=cos \u03b1(1)cos \u03b1(1)+sin \u03b1(1)sin \u03b1(1)\n\nsin \u03b2()=cos \u03b1(1)sin \u03b1(1)\u2212sin \u03b1(1)cos \u03b1(1)\n","Finally, the feature vector sequence: F=fff. . . f, where m is the number of dominant points, and f=(cos \u03b1(i), sin \u03b1(i), cos \u03b2(i), sin \u03b2())is generated.","In accordance with aspects of the present invention, symbol grouping depends on the confidence of symbol recognition. Generally, symbol recognition may tell the degree of similarity between a test pattern and an appointed symbol, but may not tell the degree that the given strokes are similar to a symbol.","Sometimes, strokes may not be a symbol, but symbol recognition gives a very high confidence to the top-1 candidate. As described above,  shows two examples. In a usual symbol recognizer,  may be recognized as \u201cH\u201d, and  may be recognized as \u201cF\u201d with high confidence. In dynamic programming,  may be grouped into a symbol with high probability.","In order to resolve this ambiguity, in symbol recognition, a special symbol, a non-symbol, which means a stroke is not a symbol, is introduced. In other words, the symbol recognizer views non-symbols as \u201cspecial symbols\u201d. Moreover, symbol recognition may give confidence of a non-symbol. It provides a decision base for symbol grouping. As described above, many non-symbol samples are generated from labeled expression data. Because symbols in expression data are labeled, other stroke combinations are all non-symbols. These samples are added into a dataset as a type of \u201cspecial symbol\u201d. So if the system recognizes strokes as the \u201cspecial symbol\u201d, these strokes are grouped into a symbol with a lower confidence.","Symbol Grouping","The task of symbol grouping is to separate strokes into several groups, which are most likely to be symbols. If any combination of strokes is considered in the calculation, the searching space is very large. For example, the number of different ways to only separate n strokes into 2 groups is 2\u22121. However, the exact group number is unknown before symbol grouping is done. If all stroke combination of 3 groups, . . . , n groups is considered, the searching space is so huge that calculation for grouping is not feasible at all.","To alleviate the computations, in accordance with one aspect of the present invention, an assumption is made that users write a symbol with several strokes which are consecutive in time order. Such an assumption is reasonable for most handwritten expression. Although a dot for an \u2018i\u2019 and a cross bar for a \u2018t\u2019 may be appended after a writer has completed an math expression, few people write half a symbol then finish the symbol after completing the remainder of the sentence or other writing.","With this assumption, in accordance with one aspect of the present invention, the strokes may be sorted by time order. A consideration is made as to how to separate a stroke sequence into several segments, where each segment is a symbol, as shown in . Now the number of different ways to group strokes is 2. Although the searching space is still large, it has been reduced sharply. Moreover, the assumption allows the use of a dynamic programming algorithm to search for an optimal solution for the problem. It should be understood by those skilled in the art that 2is the count of separating strokes into only 2 groups if no above time order assumption. However, the group (symbol) count is unknown before the calculation. So the count may be any one of 1, 2 . . . , n, if the assumption described in the next paragraph is not incorporated. Therefore, the number of different ways separating n strokes without time order assumption is much greater than the number with time order assumption. In accordance with at least one aspect of the present invention, the stroke count of a symbol may always be below a fixed number. Because the vast majority of mathematical symbols are simple, users may write them with several strokes. Such a situation also reduces the searching space. Moreover, such a situation makes it easier to implement a dynamic programming approach after a relational score between neighboring symbols is involved.","A stroke sequence may be defined as strokes 1,2, . . . N. There may be many different ways to separate strokes in the stroke sequence into segments, e.g., to group the strokes into groups. For example, (n=1, n\u22121), (n, n\u22121), . . . (n, n\u22121=N) is one illustrative way to separate the N strokes into segments. A measurement may be defined to measure the different ways of grouping. With a defined measurement, different ways of grouping strokes may be compared, and an optimization technique may be used to find the solution.","In accordance with at least one aspect of the present invention, a way to group strokes may be evaluated based upon two aspects. First, a determination is made as to how likely a group is a symbol according to intra-group information. For the given segmentation, there are p(1), . . . , p(k) scores to measure the k groups. Second, a determination is made as to the relationships between neighboring groups to determine how likely two groups may be neighbors. p(i|i\u22121) is defined to be the relational score between the i\u22121and igroups, where i is from 1 to k. If i is equal to 1, p(1|0) is the likelihood that the group would be a first symbol of the stroke sequence. Therefore, the measurement for a way to group strokes may be defined by:",{"@attributes":{"id":"p-0250","num":"0249"},"maths":{"@attributes":{"id":"MATH-US-00027","num":"00027"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"Measurement","mo":"=","mrow":{"munderover":{"mo":"\u220f","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"k"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"i","mo":"|","mrow":{"mi":"i","mo":"-","mn":"1"}}}},{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"i"}}],"mo":"\u00d7"}}}}}}},"Although the searching space is reduced sharply, it is practically infeasible to calculate the scores for all ways and compare them to get the optimal one by brute force. There is a good characteristic in the grouping problem. If s, . . . , sare symbols for a stroke sequence. If the strokes of sare erased, s, . . . , sare the symbols for the remaining stroke sequence. Formulaically, if (n=1, n\u22121), . . . (n, n\u22121), . . . (n, n\u22121=N) is an optimal way of grouping the N strokes, then (n=1, n\u22121), . . . (n, n\u22121) is also an optimal way of grouping the sub-sequence (n, n\u22121) of strokes. As such, dynamic programming may be utilized to obtain a global optimization based on the combinations of the local optimizations.","S(1, i) is defined as the score of the optimal segmentation for sequence (1, i). If the scores S(1, i), where i is from 1 to N\u22121, are already known, the optimization for sequence (1, N) may be calculated as:",{"@attributes":{"id":"p-0253","num":"0252"},"maths":{"@attributes":{"id":"MATH-US-00028","num":"00028"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"mi":"S","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":",","mi":"N"}}},{"munder":{"mi":"Max","mrow":{"mi":["l","L"],"mo":["\u2264","\u2264"],"mn":"5"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"S","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":",","mrow":{"mi":["N","L"],"mo":"-"}}}},{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":["N","L"],"mo":["-","+"],"mn":"1"},{"mi":"N","mo":"|","mn":"1"},{"mi":["N","L"],"mo":"-"}],"mo":[",",","]}}},{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":["N","L"],"mo":["-","+"],"mn":"1"},"mo":",","mi":"N"}}}],"mo":["\u00d7","\u00d7"]}}}],"mo":"="},"mo":","}}},"br":{}},"The use of space analysis alone to determine whether several strokes may be a math symbol is rather difficult.  shows an example of this problem, where strokes within box  are not much different from strokes within box  from the perspective of spatial information. However, strokes within box  should be grouped to a symbol because the strokes are part of the character \u2018A.\u2019 Therefore, besides spatial information, symbol recognition is an important information source for symbol grouping. Symbol recognition may output possible character candidates and their corresponding confidences for any given strokes, which may be utilized in the calculation for grouping.","Usually, symbol recognition assumes given strokes must be a predefined symbol, and symbol recognition outputs the top-n likely candidates for the given strokes. For the task of symbol grouping, one aspect is that symbol recognition determine if given strokes are a predefined math symbol, and with how much confidence. The non-symbol is similar to a common symbol, so that symbol recognition may recognize the non-symbol and give its confidence. But the non-symbol is also a special symbol, which means given strokes are not a math symbol if the strokes are recognized as a non-symbol.","Thus, symbol recognition may output the top-n character candidates and their confidences. Moreover, there may be possible non-symbols in the candidates, with the summation of all confidences being equal to 1. As described above, determination of a score, which is likelihood that given strokes are a math symbol would be helpful. In accordance with at least one aspect of the present invention, the score Sis defined as the confidence summation of all candidates which are symbols.","Usually, system recognition has to normalize inputting strokes to its inner scale, and the recognition operates best in the inner scale. But different from text handwriting, where characters are almost the same size, the sizes of math symbols may vary, especially when the mathematical symbols are located at different levels of within an expression. Under such conditions, the normalization loses some needed space information. Several spatial features may be used to compensate for this weakness.","As described above, the distance feature (d) is one feature for determining grouping. This feature prevents over-grouping of strokes. At different levels of grouping such a symbol, the function string, the definition and the calculation of distance are different. In (a) of , there is an obvious distance between \u2018a\u2019 and \u2018+\u2019, so \u2018a\u2019 and \u2018+\u2019 should not be grouped together.","The size difference feature (\u03b4) prevents a symbol and its subscript or superscript from being grouped. In (b) of , the size difference may be used to distinguish some special letters, such as lower case \u2018o\u2019 and upper case \u2018O\u2019. Without this feature, it may be difficult for a recognition engine to distinguish lower case and upper case letters correctly.","The offset feature (\u03c3) is another feature in symbol grouping which is used to guarantee symbol strokes located in the same horizontal line. As shown in (c) of , \u201ca+b\u201d and \u201cc+d\u201d are not grouped into a symbol because there is a fraction line between them.","After the feature extraction, a decision function is constructed to combine the features to get a score, which is the probability that the stroke set is a correct group. The decision function is constructed as the following:",{"@attributes":{"id":"p-0262","num":"0261"},"maths":{"@attributes":{"id":"MATH-US-00029","num":"00029"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["d","\u03b4","\u03c3"],"mo":[",",","]}}},"mo":"=","mfrac":{"mn":"1","mrow":{"mn":"1","mo":"+","mrow":{"mo":["(",")"],"mrow":{"msup":[{"mrow":{"mo":["(",")"],"mfrac":{"mo":"\u2146","msub":{"mo":"\u2146","mn":"0"}}},"mi":"a"},{"mrow":{"mo":["(",")"],"mfrac":{"mi":"\u03b4","msub":{"mi":"\u03b4","mn":"0"}}},"mi":"\u03b2"},{"mrow":{"mo":["(",")"],"mfrac":{"mi":"\u03c3","msub":{"mi":"\u03c3","mn":"0"}}},"mi":"\u03b3"}],"mo":["+","+"]}}}}},{"mo":["(",")"],"mrow":{"mi":["\u03b1","\u03b2"],"mo":[",",","],"mrow":{"mi":"\u03b3","mo":">","mn":"1"}}}],"mo":[",",","]}}},"br":{},"sub":["0","0","0 ","s "]},"Now, with the two scores from intra-group information, the following formula may be used to combine the two scores to determine a final intra-group score:\n\n=()\u00d7(),\n\nwhere p is a weight corresponding to how much the score given by the symbol recognition subsystem may be trusted. Moreover, a different weight p may be used for a different character. For example, if the symbol recognition subsystem gives robust confidence for character \u2018A,\u2019 a big weight p for character \u2018A\u2019 may be used. By doing this, better flexibility in determining symbol recognition may be obtained.\n","Besides weight p, d, \u03b4, \u03c3and \u03b1, \u03b2, \u03b3 also depend on the character given by symbol recognition. In accordance with at least one aspect of the present invention, supported characters are categorized into certain number of clusters. Each cluster has independent model parameters, which may be trained with a training program. The design of cluster-dependent parameters achieves better accuracy performance than a system with only one set of parameters.","A mathematical expression is a two dimensional (2D) layout of symbols. Some symbols have unique spatial structures. For instance, symbol \u2018\u03a3\u2019 usually has other associated symbols in the regions directly above and directly below the symbol, such as shown in . The rich spatial information may be used to solve the grouping problem. A typical example is the symbol \u2018\u03b8\u2019. If inter-group spatial information is not considered, symbol \u2018\u03b8\u2019 is often separated into two symbols: \u20180\u2019 and \u2018\u2212\u2019, such as shown in . However, it is not possible that \u20180\u2019 and \u2018\u2212\u2019 overlap each other spatially in an expression. This correlates to the understanding that the separation is incorrect.","In the system in accordance with at least one aspect of the present invention, nine spatial relations are defined for inter-symbol spatial relationships, such as shown in . They are horizon, superscript, subscript, above region, below region, overlap, left-horizon, left-super, and left-sub. During the calculation for grouping problem, whether a break is correct or not is not know. If a tentative break lies in a symbol, the relationship of two groups separated by the break are classified into nine classes. However, such a configuration of the nine classes is meaningful only for inter-symbol spatial relations. As such, in accordance with at least one aspect of the present invention, the intra-symbol relationship is defined to better model the situation of a break lying in a symbol, such as shown in .","In sum, there are ten spatial relationships defined in the system. Given two neighboring groups, spatial features are extracted from the two groups. A Gaussian Mixture Model may be used to fit its feature distribution for each relationship. With the Gaussian models, a classifier identifies the spatial relationship between two groups. Moreover, the classifier may give the confidence for the identified relationship. The confidence may be defined as p(R|F), where F is the spatial features and R is one of ten relationships.","A mathematical expression is also a syntax structure. Although a user may write math symbols in any order, which perhaps is not consistent with the syntax structure, it is still reasonable to utilize the temporal context information to calculate grouping. For example, if a user writes a digit, it is possible that the next written symbol is also a digit. Therefore, a bi-gram probability may be built in the system to utilize the temporal context information.","The bi-gram probability is built by combing spatial relationships together. The bi-gram probability is defined as p(S|S,R), where Sis the previous character, Sis the next character, and R is one of ten relations. p(S|SR) may be calculated by:",{"@attributes":{"id":"p-0270","num":"0269"},"maths":{"@attributes":{"id":"MATH-US-00030","num":"00030"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"mi":"p","mo":["(",")"],"mrow":{"mrow":{"msub":[{"mi":"S","mn":"2"},{"mi":"S","mn":"1"}],"mo":"|"},"mo":",","mi":"R"}},{"mfrac":[{"mrow":[{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":"S","mn":"1"},{"mi":"S","mn":"2"}],"mo":[",",","],"mi":"R"}}},{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":"S","mn":"1"},"mo":",","mi":"R"}}}]},{"mrow":[{"mi":"C","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":"S","mn":"1"},{"mi":"S","mn":"2"}],"mo":[",",","],"mi":"R"}}},{"mi":"C","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":"S","mn":"1"},"mo":",","mi":"R"}}}]}],"mo":"="}],"mo":"="},"mo":","}}},"br":{},"sub":["1","2","1","2","1","1 "]},"Because the bi-gram probability p(S|S,R) depends on the characters of the symbols, given two neighboring groups, symbol recognition may output their character candidates and confidences. An inter-group score may be calculated as:",{"@attributes":{"id":"p-0272","num":"0271"},"maths":{"@attributes":{"id":"MATH-US-00031","num":"00031"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["S","b"]},"mo":"=","mrow":{"munder":{"mo":"\u220f","mrow":{"msub":[{"mi":"S","mn":"1"},{"mi":"S","mn":"2"}],"mo":[",",","],"mi":"R"}},"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":"S","mn":"1"}}},{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":"S","mn":"2"}}},{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["R","F"],"mo":"|"}}},{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"msub":[{"mi":"S","mn":"2"},{"mi":"S","mn":"1"}],"mo":"|"},"mo":",","mi":"R"}}}],"mo":["\u00d7","\u00d7","\u00d7"]}}}}}},"br":{}},"Returning to , tabular structure analysis for handwritten mathematical expressions component  is another module in the mathematical expression recognition system. Tabular structure includes matrix and multi-line expression. It may be useful to divide a group of handwritten strokes into columns and rows and thus form matrices or multi-line expressions. Each cell of the results may be further recognized as a sub-expression by other modules or recursively processed if it still contains tabular structures.","The algorithm of tabular structure analysis in the recognition system for mathematical expression includes three parts. Firstly, X-Y projection divides the inputted strokes into rows and columns. This affects those divisible parts and has no negative effect for non-tabular structures. Secondly, those candidates of tabular structures given in the previous step are accepted or rejected by judging whether brackets exist. Thirdly, some rows and columns may be merged to correct the over segmentation problem in the X-Y projection. The main difference between matrices and multi-line expressions is the surrounding brackets. This is judged in the second step. If a structure is judged to be a multi-line expression, all columns may be merged into one column in the third step.","Tabular structure analysis is the process of dividing strokes into rows and columns. Blank is a feature for tabular structures. Rows and\/or columns are divisible when there are blanks among them. An X-Y projection is used to identify the blanks in the rows and\/or columns of strokes, such as shown in .","The following is an illustrative implementation with respect to . Firstly, a whole input block is projected on the X axis and divided into columns. For example, as shown in , the whole input block is divided into seven columns, C, C, . . . C. Secondly, the maximum divisible columns from left to right are searched incrementally. Each column is projected to the Y axis with previous divisible columns to judge whether these columns are also divisible. If divisible, searching continues to the next divisible column. Otherwise, a determination is made as to whether previous divisible columns exist. If previous divisible columns do not exist, no further determinations are needed and the process continues. Otherwise, the previous divisible columns are used to form a tabular structure and previous divisible columns are set to empty.","For example, column Cin  is first processed and shown as indivisible. Moving to the next column, column Cis divided into 3 rows. Column Cis the same as column Cand the combination of these two columns also form 3 rows. Although column Chas only one stroke, as shown in row R, and thus is indivisible, the Y projection on the combination of columns C, C, and Cidentifies a structure of 3 rows and 3 columns. After processing columns Cand C, a tabular structure of 3 rows and 5 columns is obtained. Because over segmentation problem exists (e.g., columns Cand Cshould not be separated from column C), such a tabular structure may contain empty cells which will be eliminated later. Column Cis then processed next. As with column C, column Cis indivisible so the previous five columns are regarded as a candidate of a tabular structure and processing continues as described in the following.","A bracket is a component of tabular structures. If a pair of brackets is found at the left and right sides of a candidate which is given in the previous X-Y projection, the candidate is accepted as a matrix. If there is only one curved bracket at the left side and the right side has an opening, the candidate is accepted as a multi-line expression. Otherwise, the candidate is rejected and processed by other modules as appropriate. For example, if some superscript and subscript elements are aligned as a vector, they may be a candidate given by X-Y projection. However, because the left and right strokes are not brackets, the false candidate may be rejected at this point.","A symbol should satisfy the following two requirements to be accepted as a bracket. One is that its symbol recognition result should be a valid bracket which is described above. The other requirement is that the height of the symbol is large enough to encapsulate the candidate and that the proportion between the width and the height of the symbol is small enough in comparison to one or more thresholds. Such criterion may be controlled by two pre-defined thresholds.","A simple X-Y projection may introduce the over segmentation problem described above with reference to . The system may not be configured to support matrices which contain empty cells. If some columns which have empty cells are found after the X-Y projection, they may be merged with one of the neighboring columns. The distance to the left neighbor and right neighbor may be compared and such a column will be merged with the nearer neighbor. For example, columns Cand Cin  are nearer to column Ccomparing with the distance to column C. So columns C, C, and Care merged into one.","Next, the distances between any two neighboring columns are compared with a pre-defined threshold. Those columns whose distances are very short may also be merged to reduce over segmentation further. If the right side of the tabular structure is opening, then it is recognized as a multi-line expression and all columns are merged into one. Finally, rows may be also merged when the distances between rows are short enough when compared to a pre-defined threshold. Such a determination and process may be used to correct the over segmentation for those cells that only contain a fraction.","Subordinate Sub-Expression Analysis","Mathematical expression is data with structure information. Besides subscript and superscript structures, there are above and below spatial relations (\u03a3) and pre-superscript spatial relations (\u221a) in expressions. To represent the relationship between symbols, people use more layout types for expressions in both handwritten notes and printed documents. This makes expression structure analysis much different than text layout analysis, where regular words, lines, paragraphs exist.","The data structure of a mathematical expression is inherently a tree structure. Logically, an expression may be divided into several sub-expressions and a sub-expression may be subordinate to a symbol which is in another sub-expression. With the subordinate relationship, the sub-expressions form a tree. Therefore, the inherent hierarchical sub-expression structure for the system may be found. For further processing, an entire expression may be subdivided into several parts. The following describes the task as structure analysis.","In accordance with at least one aspect of the present invention, two sub-expression types are distinguished to be handled. The first type is a sub-expression subordinate to special structural symbols, such as \u03a3, \u221a, \u222b, which are named as dominant symbols. These symbols always imply unique layout relations existing in expressions. The second type is a sub-expression of a subscript or a superscript, which also often appears in common text. In accordance with one aspect of the present invention, the first type of sub-expressions is found in an expression and the recursive structure is then determined. The other type will be processed by the next component.","The subordinate sub-expression analysis component is a component of the system of expression recognition. Three points are described again for the sake of consistency. A parse tree is used and passed by all components in the mathematical expression system. The parse tree may be an extended BST tree, which is defined herein.",{"@attributes":{"id":"p-0286","num":"0285"},"figref":"FIG. 3","b":["307","303"]},"As described herein, there are so many ambiguities in a handwritten mathematical expression. Structure ambiguity is one of the ambiguities. Sometimes, it is not easy to judge if a symbol is inside a radical sign or not.  is such an example. The ambiguity is whether the symbol \u201cc\u201d is inside or outside the radical sign. In accordance with at least one aspect of the present invention, multiple results are outputted to resolve these kinds of ambiguities.","As mentioned herein, an expression is a tree of sub-expressions.  shows this concept clearly. In , the content in each rectangle is a sub-expression. The left two sub-expressions are subordinate to the fraction line and the right sub-expression is subordinate to the radical sign. The two dominant symbols lie in the main sub-expression. The four sub-expressions form a tree structure. Sub-expressions may include one or more symbols. Within a sub-expression, there are no other spatial relations except horizontal spatial relations between symbols. This component mainly analyzes the first type of sub-expression, namely the subordinate sub-expression. In the component, subscript and superscript are handled in the same way to deal with horizontal relationships. The subtle distinctions among them are processed by the next component.","Dominant symbols imply particular layout types in expressions. They are separated from other symbols and used as hints by this component. In Table-1, the rows are dominant symbols supported by the component so far and the columns are the types of their relationships with the corresponding sub-expressions. The marks in cells of the table body mean dominant symbols may have the corresponding types of sub-expressions. For example, there are two cells marked in the first row, so that fraction line may have two sub-expressions, one is the numerator above the fraction line and the other is the denominator below the fraction line.",{"@attributes":{"id":"p-0290","num":"0289"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example Dominant Symbols and Relationships"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Above","Below","Contain","Index"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2014 (fraction line)","\u2713","\u2713",{},{}]},{"entry":["\u03a0 (N-Array product),","\u2713","\u2713"]},{"entry":"\u03a3 (N-Array sum)"},{"entry":["\u222b (Single integral sign)","\u2713","\u2713"]},{"entry":[{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00004","he":"2.79mm","wi":"1.44mm","file":"US07929767-20110419-P00003.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}},{},"\u2713"]},{"entry":["\u221a (radical sign)",{},{},"\u2713","\u2713"]},{"entry":["-, \u2192 (hat symbols)",{},"\u2713"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"This component uses a graph search algorithm, which includes the steps of constructing a relational graph and searching the Top-N optimized spanning tree. In the graph, vertexes are symbols and edges are possible relationships between symbols and their corresponding intensity. It is also possible that there are multiple relations between two symbols due to spatial ambiguities.","The graph is not the final description of symbol relationships. There are many conflicts in the graph. One is, as mentioned above, multiple relationships exist between two symbols, but actually only one is valid. Another example is a symbol may be subordinate to multiple symbols in the graph. So after graph construction, a search process is performed in the graph to decide which relations are valid. These valid relations (edges) finally form an optimal spanning tree on the graph. Moreover, the search algorithm investigates almost all possible combinations of edges during the process. It may evaluate all combinations, which are spanning trees, and record Top-N optimal results. This component performs the following two tasks. First, the component finds subordinate sub-expressions for each dominant symbol. By doing this, Top-N hierarchical trees of a sub-expression are constructed. These multiple results are mapped to a parse tree for further processing.","Second, the component decides characters of dominant symbols. The symbol recognition component supplies a list of character candidates for each symbol, but the character of the final symbol is still undetermined. Actually, it is impossible to decide a unique character for each symbol only by symbol recognition. For example, \u2018Minus\u2019 and \u2018Fraction line\u2019 may not be classified from each other by a symbol recognizer. For such a case, structure context information is needed, because \u2018Fraction line\u2019 has two sub-expressions\u2014denominator and numerator. So the component also may determine characters of dominant symbols with structure information.","The input of this component is a handle of the parse tree. By this handle, this component may access the whole parse tree. Arriving at this point, the parse tree has been processed by the symbol grouping and recognition component. It has created some symbols grouping and recognition solution nodes in the parse tree to represent the multiple results of the symbol grouping and recognition component. For an intuitive image, an example snap shot of the parse tree at this time is given at . This component accesses one solution node, gets all the descendent symbols node of the solution nodes, processes the symbols nodes, writes back multi-results, accesses another solution node and continues until all symbols grouping and recognition solution nodes are processed. This component will create a new subordinate sub-expression analysis solution node in the parse tree for each result. Processed by this component, the parse tree may look like .","In construction of a graph, calculating relational scores for edges may be needed. A relational score is a measure of the intensity of a relationship. Five relational types are taken into consideration. Beside the four relational types in Table 1, the horizontal relationship enabled for any math symbol is considered. So for each couple of math symbols, there are five possible edges between them initially. Edges with a lower score than a specified threshold are removed in order to reduce memory cost and time cost. The following are some concepts in the calculation.","For each symbol and for each enabled relational type, a rectangle centered control region is calculated from a fairly large training set. The control region is a centered rectangle which is infinite and truncated. In , the two shadowed rectangles represent the two rectangle centered control regions for \u2018Above\u2019 and \u2018Below\u2019 sub-expression types respectively.  is an example to describe how the control region is truncated.","The score is calculated to measure to what extent a point (x, y) is subordinate to a specified control region according to sub-expression type R. If the point is located inside the centered rectangle of a control region, the score will be set to 1.0, the biggest score value. In the alternative, if the point is not located in the control region, the score will be set to 0.0, the smallest score value. The general principle when calculating a relational score is that the nearer the point is to the centered rectangle, the bigger the score will be and the farther the point is to the centered rectangle, the smaller the score will be.  is the equation used to calculate the score. In , f(x,y) represents the score. O(x),O(x) represent the offsets of the point (x, y) to the according rectangle respectively. \u03bb, \u03bb, x, yare specified thresholds.  is the graphical description of the equation in .","Given a symbol, the bounding box may be determined. This component calculates symbol score to a control region by the corresponding bounding box. First, it samples a specified large number of points in the bounding box uniformly. Second, it calculates point relational score for each sampled point one by one using the method mentioned above. Third, it averages all those score obtained at the second step to get the symbol relational score.  is a formal description where S is the bounding box of a symbol to calculate relational score, R is the according infinite but truncated control region and (x, y) is point in S.  is an intuitive description of such an operation.","The relational score from the previous step has a shortcoming in that it does not take the global information into consideration. But a third symbol may affect the relationship between two symbols. There are two cases. The first case is that the subordinate symbols subordinates to a more specific dominant symbol. For example, in the left part of , symbol \u201ca\u201d is above the fraction line and is contained by the radical sign. Because the radical sign is above the fraction line, it is the more specific dominant symbol related to the symbol \u201ca\u201d. In this case, the radical sign affects the relationship between the symbol \u201ca\u201d and the fraction line. There is no direct relationship between the symbol \u201ca\u201d and the fraction line at all because of the existence of the more specified radical sign. The other case is that two symbols having some relationship with each other are separated by a third dominant symbol. The right part of  shows this case. If the fraction line does not exit, the index relationship between the symbol \u201c3\u201d and the radical sign will be assigned a high score. Such does not occur here. Because of the existence of the fraction line, the symbol \u201c3\u201d becomes the numerator and the radical sign becomes the denominator. The two symbols have no direct relationship any more.","The relational score needs to be adjusted with reference to global information for both of the two cases mentioned above. For the first case that the subordinate symbols subordinates to a more specific dominant symbol, the original relational score is subtracted a value equal to the product of two relation scores. One is the relational score between the subordinate symbol and the more specific dominant symbol. The other is the relational score between the more specific dominant symbol and the subordinate symbol. In , the above relational score between the symbol \u201ca\u201d and the fraction line is subtracted from the value of the relational score between the symbol \u201ca\u201d and the radical sign which is a more specific dominant symbol to the symbol \u201ca\u201d. For the other case that two symbols having some relationship are separated by a third symbol, the relational score between the two symbols is subtracted from a value equal to the product of the relational scores between the third symbol and the two symbol respectively. In , the index relational score between the symbol \u201c3\u201d and the radical sign is subtracted from a value of the product of the above relational score between the symbol \u201c3\u201d and the fraction line and the below relational score between the radical sign and the fraction line which is a separator. Generally speaking, to adjust the relational score between two symbols, all the other dominant symbols must be gone though to perform the two rules mentioned above.  is an overall formal equation to be used to adjust the relational score by global information in this component.","In this graph, an edge represents a relationship between two linked math symbols. Because of the ambiguity in handwritten mathematical expressions, there may be more than one relationship between each couple of math symbols. An edge will be created for each couple of symbols and for each relational type. In order to build such a graph, the horizontal relationship is also taken into consideration. All math symbols including dominant symbols may have a horizontal relationship with the symbols behind them. So there will be two types of edges namely the paternity edges and the brotherhood edges in the obtained graph. In order to reduce time cost and storage cost, edges with relational score lower than a specified threshold will be pruned.  is such a relational graph.","The recursive structure of a mathematical expression may be expressed by a tree. So a search process will be performed in the relational graph for the according tree structures. The search process considers both the two types of edges for each symbol. In order to resolve the structure ambiguities of mathematical expression, the top-N optimized spanning tree will be reserved.  is the search process and  is the input and output of the search process.","Results found by the previous search process are optimal only with respect to local relational scores, and thus may not guarantee that the result is valid globally. For example, in a result found by the search process, the fraction line may have a numerator, but no denominator. But this kind of global structural information must be considered. So structure validity checking is involved in the subordinate sub-expression analysis component to verify if the results are valid, after previously finding multiple results. Finally, only valid and optimal results will be outputted to the parse tree. An overall configuration of the subordinate sub-expression analysis component is illustrated in .","Subscript, Superscript Analysis and Character Determination","The symbol grouping and recognition component supplies multiple character candidates with confidences for each symbol. The subordinate sub-expression analysis component finds out sub-expressions for each dominant symbol but it does not step into subtle distinctions among subscript, super script and horizontal relations within each sub-expression. This component performs two tasks, one is to select a unique character for each symbol and the other is to analyze the subscript and superscript structures within a sub-expression. In order to deal with the ambiguities existing in a handwritten mathematical expression, aspects of the present invention adopt a graphical search algorithm. The first step is to build a graph for a sub-expression and the second step is to search in the graph for the top-N optimized spanning trees each of which represents a unique mathematical sub-expression.","The subscript, superscript analysis and character determination component is a component of the whole handwritten mathematical expression recognition system which aims to supply a natural way for humans to input a mathematical expression into computers. The input of this component is a handle of a parse tree. By this handle, the component may access the whole parse tree. Arriving at this point, the parse tree has been processed by the subordinate sub-expression analysis component. It analyzes sub-expressions associated with dominant symbols and creates a new relational node for each such sub-expression. Dominant symbols also belong to some sub-expressions. For an intuitive image, an example snap shot of the parse tree at this time is given at . This component accesses one relational node, gets all the child symbol nodes of the node, processes the symbols nodes, writes back multi-results, accesses another relational node and continues until all the relational nodes are processed. This component will create a new subscript\/superscript and character determination solution node in the parse tree for each result. Processed by this component, the parse tree may look like .","The algorithm deals with each sub-expression in the same way.  is the flowchart of this algorithm. The first step is to sort all the symbols in a sub-expression from left to right. After the symbols are sorted, a graph is built based on the symbols. Then a searching process is performed on the graph to find the top-N optimized spanning trees. Each spanning tree represents a unique mathematical sub-expression. To confirm the validation of each spanning tree, a syntax analyze process is performed on each spanning tree. In this process, invalid spanning trees are removed. The last step is to write back the multiple possible results of the sub-expression to the parse tree. Not only the structure of the sub-expression is unique, but also the character of each symbol is also unique in a specified spanning tree.","There are only three types of relationships namely subscript relation, horizontal relation, and superscript relationship within a sub-expression. A graph includes vertexes and edges. Each vertex represents a particular symbol of the given sub-expression. For each couple of symbols, for each character of a symbol and for each relational type being considered an edge will be created. The edge records the characters of two linked symbols and the relational type between them. In addition, a score as an intensity measure of an edge is also recorded in the edge. In order to reduce the storage cost and time cost, any edge with a lower score than a specified threshold is pruned.  is a finished graph. The score of an edge is the product of three parts as shown in . The first part is a space score which represents the spatial relationship between the two linked symbols. The second part is a context probability score, such as a bi-gram probability, which represents a short syntax grammar for mathematical expressions. The third part is the product of confidences of the corresponding two symbol characters which come from the symbol grouping and recognition component.  is the equation to calculate the edge score. In this equation, A, B are two symbols and R is a specified relational type. The left part is the score of R relationship between A and B. There are four factors in the right part. The first one is the normalized space score for the R relationship between A and B. The second part is the context probability, such as a bi-gram probability. The last two factors are confidences of A and B respectively supplied by the symbol grouping and recognition component.","In order to calculate the space score for symbols A and B with respect to relation R, an offset in a vertical direction is calculated by the equation in  firstly. The second step is to calculate space score by the equation in , and then normalize the space score.","Given the characters of A and B and the specified relational type, a bi-gram probability may be expressed by the equation in . It is a conditional probability of B, given the characters of A and the relation R. A large mathematical expression set is used to obtain bi-gram probabilities for all couples of characters and for all the three relational type in consideration. This information is kept down in a table. So, the bi-gram probability for two symbols with respect to a specified relational type may be looked up in a prepared table.","The task of the next step is to find the top-N optimized spanning trees from the built graph that is to select the n\u22121 best edges from all the edges in the graph if there are n vertexes under the following constraints. Edges in the spanning tree must agree with each other in the structure of the mathematical expression. Edges in the spanning tree must agree with each other in the character of each math symbol.","The search process gets more than one spanning trees each of which represents a unique mathematical sub-expression. Because the search process only utilizes local information, the obtained top-N spanning trees may not represent valid mathematical expressions. In order to resolve this problem, each spanning tree will be analyzed by the inherent grammar in mathematical expressions. The well known Earley's context-free parsing algorithm, as described in Grune, D. and Jacob, C. J. H., , Ellis Horwood, Chichester, 1990 and Earley, J., -, Comm. ACM 13, 2 pp. 94-102, February 1970, is adopted here. It should be understood by those skilled in the art that the above described algorithm is commonly known and understood by those skilled in the art. Spanning trees are converted to linear format that may be analyzed by the algorithm. Only valid spanning tree may pass the algorithm. Those spanning tree that cannot pass the algorithm will be removed.  gives an example of this process.","Mathematical Expression User Interface","Whether due to illegible or poor handwriting of a user or an incorrect evaluation of strokes, inaccurate results may occur. In response, the user will need to correct the inaccuracies. In accordance with one embodiment, there are two places where a correction user interface may be provided: on ink, the handwritten version, or on text, the recognized version. Once ink is recognized, structures in ink are identified. Ink strokes are grouped into symbols and sub-expressions are identified. Corrections on ink may be provided based on the ink structures such as symbols and sub-expressions.","A user interface (UI) in accordance with aspects of the present invention allows users to modify recognized results and helps users to get mathematical expressions correctly, easily, and efficiently. In accordance with aspects of the present invention, the UI may be an input panel, a dialog, or other type of UI that allows a user to handwrite, convert, and\/or correct the recognition results and to place the results into an application program the user wants placed, such as into a word processing application program document. An example UI of a mathematical expression input panel may be divided into four parts: an input or handwriting area, a rendering or display result area, a tools area, and a function panel as shown in .","One part of the interface is the input area or handwriting area. Users may write, erase, and select strokes in the input area. There are three modes for the input area: writing, erasing and selecting. The modes are indicated by three icons in the mode area at the left of the input area. The recognition results are shown in the rendering area or result display area below the input area. The area may be shown automatically after the program gets the parse result and hidden automatically when users begin to write or erase, or the area may be shown at all times. The description text may be also shown in the rendering area after users click on the icons in the function panel. There is a button \u201cInsert\u201d at the right of the rendering area. After getting the desired result, users may click \u201cInsert\u201d to send the results to the active application. The function panel is at the right of the input area. There are twelve icons, which represent different function names, in the function panel. The whole layout is compact and functional.","There are two types of ambiguities in the results of mathematical recognition, structural ambiguity and symbol ambiguity. For example, the original strokes have two different grouping schemes in  and each scheme is reasonable. The stroke  may be interpreted as \u2018c\u2019, \u2018(\u2019 or \u20181\u2019 and each interpretation may be correct under different conditions. Candidates for a symbol, sub-expression and the entire expression are provided by the underlying mathematical expression recognition engine. Providing candidates makes it easy for users to make a choice to correct the recognition errors.","A thin line is displayed underneath each sub-expression and the entire expression to indicate that there are candidates. When users hover on a line, the line becomes thickened, as shown in . Users may then click on the thickened line. After clicking on the line, a candidate menu will pop up, as shown in . If a pen hovers above the bounding box of one symbol, the color of the symbol will be changed, for example to gray, indicating there are candidates for the symbol. After a user clicks on the symbol (actually, anywhere inside the bounding box of the symbol), the candidates menu will pop up for users to make a choice, as shown in . Another way users may open the candidates menu is to click anywhere inside the bounding box of a symbol, a sub-expression, or the entire expression, and the system will open the candidates menu for the unit that has the smallest bounding box encompassing the spot the user clicked on. This method allows users not to have to accurately position the pen. Users may click and select in a large enough area to get the candidates menu. The application minimizes the number of operations of the user.","To provide better candidates, candidates at different levels may be provided. For example, when the whole expression is selected, the first time users click to open the candidates menu, top n candidates, where n may be any reasonable number, for example, 3, 5, 8 and so on, of the whole expression may be shown, as shown in . After users choose a candidate from the candidates menu, e.g., the first candidate, more candidates with the same grouping scheme as the candidate selected in the first round may be shown, as shown in . This gives users more choices. Typically, the more candidates shown, the more likely the correct recognition result may be in the candidates list. This maybe measured by the accuracy of symbol recognition and structure recognition given the number of candidates. For example, in one implementation, the accuracy of symbol recognition increases by about 6.5% when the number of candidates provided is increased from 1 to 5. Similarly, the accuracy of structure recognition increased about 8% when the number of candidates provided is increased from 1 to 5. Because candidates are provided for symbols, sub-expressions and the entire expression, the chances that the correct symbol, sub-expression and whole expression is provided are increased.","The mathematical expression input panel is a pen-based application and the interactions may be optimized for a pen. For example, in one implementation, the program may launch the parser automatically two seconds after the user stops editing. The rendering area may be shown automatically after the program gets the parse result and hidden automatically when the user begins to write or erase. A symbol eraser may be implemented, e.g., after the recognition, when a user uses the eraser to erase all strokes of a symbol at a time. The reason for the symbol eraser is when a user erases some strokes after the recognition, it is more likely there is an error with the whole symbol. With the symbol eraser, a user may erase more than one stroke in one removal operation.","There are three dashed lines in gray as reference lines in the input area, as shown in . The middle line gives a user a reference baseline to write. The top and bottom lines give the user upper and lower reference limit lines respectively. The three lines maybe designed such that they do not interfere with the user's focus on the strokes.","Due to the algorithm limitation, there may not be a right choice under some conditions, as shown in . Users may specify the meaning of related strokes in the mathematical expression input panel through some operations. There are twelve functions in the function panel, as shown in . From top to bottom, from left to right, they are \u201cRegroup,\u201d \u201cPromote,\u201d e.g., to a superscript, \u201cDemote,\u201d e.g., to a subscript, \u201cRadical Expression,\u201d \u201cFraction,\u201d \u201cIntegration,\u201d \u201cSummation,\u201d \u201cProduct,\u201d \u201cFunction Name,\u201d \u201cParenthesis,\u201d \u201cSquare Bracket,\u201d and \u201cCurly Bracket.\u201d There are ToolTips attached to all icons in the function panel. The effect of each function is represented by their names. For example, the function \u201cRadical Expression\u201d specifies the selected strokes as a radical expression.","The functions may be divided into three parts according to their operations. The operations of \u201cRadical Expression,\u201d \u201cFraction,\u201d \u201cIntegration,\u201d \u201cSummation,\u201d and \u201cProduct\u201d are:","Select some strokes, as shown in .","Click the icon in the function panel. In this example, the icon is ","Act according to the description text in the rendering area to specify the power and root of the evolution. In the example, since there is no power, users will click button \u201cCancel\u201d, as shown in . Then users will select the root of the evolution, as shown in . After pressing button \u201cOK\u201d, the correct result is shown in .","The operations of \u201cRegroup\u201d, \u201cPromote\u201d, \u201cDemote\u201d and \u201cFunction Name\u201d are:","Select some strokes.","Click the icon in the function panel.","The strokes selected will be grouped together and recognized as a single symbol or promoted, such as becoming a superscript, or demoted, such as becoming a subscript, or recognized as a function name, such as sin.","The operations of \u201cParenthesis\u201d, \u201cSquare Bracket\u201d and \u201cCurly Bracket\u201d are:","Select some strokes.","Click the icon in the function panel.","Select left parenthesis and press button \u201cOK\u201d.","Select right parenthesis and press button \u201cOK\u201d.","The output data maybe in MathML format, bitmaps or any other format that may represent mathematical expressions.",{"@attributes":{"id":"p-0334","num":"0333"},"figref":["FIGS. 72-85","FIG. 72"],"b":["7200","7200"]},"In this example, the dialog box  is modeless and resizable. A portion of the dialog box  is handwriting area . To the right of handwriting area  are three writing tools: pen , eraser , and clear all . Below handwriting area , an \u201cInitiate\u201d button  is separated from the other buttons. When the dialog box is resized, handwriting area  may be resized accordingly; however, the user interface  may be configured so that the ink and\/or the buttons for writing tools , , and  do not move or change size. The relative positions of the buttons and ink may also be configured to remain the same.","When a user activates the pen button , she initiates a writing mode. Similarly, when she activates the eraser button , she initiates an erasing mode. These two modes may be exclusive, i.e., when one is on, the other must be off. When there is no ink in the handwriting area , the clear all  button and the Initiate button  may be configured to be disabled. When there is ink, these two buttons may be configured to be enabled. When the user activates the clear all button , all the ink within handwriting area  is removed and the user initiates a writing mode. When a user activates the Initiate button , all the ink is sent to the mathematical expression recognizer and the user initiates the writing mode.","In accordance with one embodiment, handwriting area  defaults to the writing mode and is cleared every time the dialog box  is opened. As such, no ink is saved. If a user selects an equation that was previously entered by handwriting, the dialog box  will not open with the original handwriting filled in. In an alternative embodiment, the user interface  may be preconfigured and\/or allow for a user to configure the user interface  so that selection of an equation that was previously entered in handwriting will open the dialog box  with the original handwriting filled in.","The text \u201cWrite equation here and hit Initiate\u201d  may be configured to appear as a watermark in handwriting area . Such a configuration helps a user to know where to start. Once the user starts writing, the watermark is removed and the clear all button  and Initiate button  may be enabled, such as shown in .","Once the user finishes writing, she may activate the Initiate button  to start the mathematical expression recognition operation as described herein. The system may be configured to show a progress bar , such as shown in . The user may stop the recognition process by activating a Stop button . When the user activates the Stop button , the recognition system stops and the progress bar  goes away. Progress speed in the progress bar  may be estimated by the number of strokes and other parameters provided by the mathematical expression recognizer and\/or by any other of a number of different methods. When the recognition process is finished, a result display area is shown, with the recognized equation.","As shown in , result display area  is below handwriting area . When a recognized equation is first shown , an IP  is placed at the end of the equation, e.g., a vertical flashing bar, such as shown. The cursor  in result display area  may be the \u201cI\u201d beam, which is similar to the cursor display position shown in other application programs, such as Microsoft\u00ae Word. A user may insert and select with the IP  in result display area . Common keys on a keyboard, such as arrow keys, backspace, and delete, may operate in result display area . Three buttons are provided in the result display area: all symbols , delete , and undo . Corresponding operations and functions of these buttons are described herein below.","A light gray mask may be applied to one or more portions of the upper zone of dialog box . Such a mask may be used to guide the attention of the user away from the upper zone and focus on the result display area  as correction functionalities may be provided there. A user still may erase, clear, and rewrite in the handwriting area . When the user moves her cursor position into the upper zone, the mask may be removed. In such a situation, the cursor may become an arrow. When the user moves her cursor position into handwriting area , the cursor may become the pen cursor, indicating that the user may write. As soon as the user writes or erases a stroke, result display area  may be emptied or may be collapsed. Otherwise, result display area  stays. In one implementation, when the user activates the Initiate button , a determination is made as to whether there have been any changes to the ink since the last time the Initiate button  was activated. If not, the mathematical expression recognizer is not started and the last recognized equation is displayed. In another implementation, no matter whether there have been any changes to the ink, all the ink is recognized again as if for the first time.","If the user is satisfied with the result, she may activate a Transfer button  to insert the recognized equation  into the application program, such as Microsoft\u00ae Word. In response, any ink in handwriting area  is cleared, and the result display area  is collapsed. The data sent to the application program may be in a specific type of format, such as MathML, bitmap, or any other format acceptable by the application program. When there is more than one application program open, the data may be configured to be sent to the application program in focus.","With the correction on ink configuration described above, one problem is that users may find difficulty understanding ink structure errors, such as symbol grouping errors. For example, in the equation shown in , strokes for the summation sign are not grouped together. One stroke, or group, is recognized as a fraction line, and another stroke, or group, is recognized as a \u201c2.\u201d","Although possible to correct this inaccuracy on the ink, it is easier for a user to identify what is inaccurate in the recognized equation . For example, in the equation  shown in , the user may determine that the summation sign is missing and that other elements have been recognized. The user then may delete what is wrong and insert a summation sign.","Besides grouping errors, another common type of error is a layout error, e.g., superscript\/subscript relationships and control regions of dominant symbols, which are recognized inaccurately. Direct manipulation, such as gesture and drag\/drop, are simple and convenient ways to correct these errors.","Correction on text may include providing candidates, allowing rewriting, enabling drag and drop, and providing editing capabilities. Multiple candidates are provided for an equation, sub-expressions, and symbols. Users may rewrite part of an equation. Drag and drop allows easy and convenient correction of layout errors. By providing IP, allowing soft keyboard entry of symbols, and allowing insertion, selection, and deletion, sufficient editing capabilities ensure all errors may be corrected. In addition to correction user interface provided in result display area , users may also write and\/or erase in handwriting area .","The system may be configured to implement \u201cpin\u201d functionality, i.e., when a user makes a correction to a candidate, the changes are reflected in other candidates. Or, the system may be configured not to implement the \u201cpin\u201d functionality, i.e. when a user makes a correction to a candidate, the changes are not respected by other candidates. In such a configuration, one implementation may be once users make a correction, such as choosing a candidate from the candidate list, rewrite, insertion, and deletion, candidates for the entire equation will not continue to be shown, because the candidates may be far off from what the user has corrected so far and may cause user confusion. Similarly, if the correction is inside a sub-expression, candidates for the sub-expression will not continue to be shown. Candidates for a written symbol may always be available.","A user may select any part of the recognized equation , as long as the selection is allowed. If the user activates anywhere else in the recognized equation , selection goes away and IP  is placed where clicked.","When a user selects the entire equation, candidates  for the equation  are provided in the dropdown menu . In the example shown in , the entire equation  is selected. When the user activates the dropdown button , candidates  for the equation  are shown. The user may choose from the candidates list. In response, the equation in result display area  is replaced by the selected candidate, selection goes away, and IP  is placed at the end of the equation. If the user does not want to choose anything from the list, she may choose \u201cEnter Expression Again\u201d  to rewrite the equation. When the user chooses \u201cEnter Expression Again\u201d , it may perform the same operation as choosing the clear all button , i.e., all ink is cleared, and result display area  is collapsed.","When a user selects a single character, candidates for the character are provided in the dropdown menu. In the example shown in , the character \u201ct\u201d  is selected. When the user activates the dropdown button  below the character , candidates  for the character  are shown. The user may select \u201c+\u201d from the list. In such a situation, character \u201ct\u201d  will be replaced by \u201c+,\u201d selection goes away, and IP is placed after \u201c+.\u201d If the correct character is not in the list, the user may rewrite the character in the \u201cEnter Expression Again\u201d area . The \u201cEnter Expression Again\u201d area  is for quick writing to correct errors. For example, the \u201cEnter Expression Again\u201d area  may be a fix-sized, without the pen , eraser , and clear all  tools. When the user activates an Initiate button , dropdown menu  stays. The ink that is written is fed to the mathematical expression recognizer system. When a result is returned, dropdown menu  goes away, and selection is replaced by the recognition result, after which IP is placed.","During the recognition process, a progress bar may be shown. In such a situation, the user may activate a Stop button to stop the recognition. When the user activates the Stop button, dropdown menu  stays, and the progress bar goes away.","If the user chooses a dominant symbol from the list or the recognition result is a single dominant symbol, placeholders for control regions such as above fraction line, below fraction line, lower limit, upper limit, etc., are inserted along with the symbol. As illustrated in , placeholders  and  are shown as dotted line boxes. Alternatively, other designs may be used to show placeholders, such as using a blank area instead of dotted line boxes. The user may place IP in a placeholder ,  and insert symbols and\/or drag and drop into the placeholders , . In the example shown in , the user selects the integral sign to replace the character \u201c1.\u201d Placeholders for the lower limit  and upper limit  are inserted. Locations of the placeholders are the same as default drop zones, which is described herein below.","When a user selects a sub-expression, candidates for the sub-expression are provided in the dropdown menu. In the example shown in , the sub-expression \u221a{square root over (x+)}y+c is selected. The user activates the dropdown button  below the selection. Candidates  for the sub-expression are then shown. In this example, no candidate is correct. As such, the user may rewrite the sub-expression in area . When the user activates an Initiate button , dropdown menu  stays. The ink that is written is fed to the mathematical expression recognizer system. When the result is returned, dropdown menu  goes away, and the selection is replaced by the recognition result, after which IP is placed. During the recognition process, a progress bar may be shown. In such a situation, the user may activate a Stop button to stop the recognition. When the user activates the Stop button, dropdown menu  stays, and the progress bar goes away. If the sub-expression happens to be a single character, candidates for the character will be shown.","If the selection is neither a character nor a sub-expression, no candidates are provided in the dropdown menu. The users may rewrite the expression. In the example shown in , the part",{"@attributes":{"id":"p-0355","num":"0354"},"maths":{"@attributes":{"id":"MATH-US-00032","num":"00032"},"math":{"@attributes":{"overflow":"scroll"},"msubsup":{"mi":"n","mrow":{"mo":"-","mn":"1"},"mfrac":{"mrow":{"mn":"1","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mi":"\u03c3"},"mn":"2"}}}},"br":{},"b":["8033","8003","8005","8039","8039","8039"]},"When there is a selection, a user may drag and drop the selection. For example, the user may drag and drop to change subscript\/superscript relationships, range of a radical sign, range of the numerator and denominator, etc. Drop locations may be shown in the user interface such as an \u201cI\u201d beam or shaded boxes shown in , , and . Alternatively, other designs may be used to show the drop locations. In the example shown in , the superscript is selected to be dropped to after m, i.e., changed from a superscript to a non-superscript. In the example shown in , the superscript is selected to be dropped to the subscript of , i.e., changed from a superscript to a subscript. In the example shown in , the expression yis selected to be dropped inside the radical sign after the character \u201ct\u201d. In this situation, when there is a selection, the dropdown button described above may be shown. However, when the user starts dragging the selection, the dropdown button goes away.","The drop zones for each character maybe defined. For example, for a fraction line, the drop zones are Above, Below, Before and After. For an integral sign, the drop zones are Upper Limit (to the side of centered), Lower Limit (to the side of centered), Before and After.","The size of the drop zones may be configured based upon any of a number of different manners, including, but not limited to, the size of the result display area plus a buffer zone. The buffer zone may include the Before zone of the first character, the After, Superscript, and Subscript zones of the last character, and the Hat zones of all the characters. When there is nothing in a zone, the size of the zone is the bounding box of a single character. A dotted line \u201cI\u201d bar may be configured to indicate Before and After drop zones, and a shaded rectangle may be configured to indicate Above, Below, Radicand, Index, Hat, Base, Upper Limit, Lower Limit, Superscript, and Subscript drop zones.","The cursor position may be moved to a location that is the intersection of several drop zones. Rules may be devised to decide which drop zone to show. For example,\n\n","After the drop, the layout of the recognized equation may need to be changed. For example, a fraction line may need to be lengthened or shortened or a summation sign may need to be pushed down because it now has an upper limit.","Sufficient editing capabilities may be provided to ensure all errors in the recognized equation may be corrected. Three tools are provided in the result display area: all symbols, delete, and undo. Their behavior is explained below in Table 2.",{"@attributes":{"id":"p-0362","num":"0366"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example Behavior of Editing Tool Buttons"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Button",{},"Enable\/"]},{"entry":["Label","Action","Disable"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["all","Opens symbol (character) picker. Users choose a","Always"]},{"entry":["symbols","character and insert. The character is inserted","enabled."]},{"entry":[{},"at the IP. Note that if there is a selection"]},{"entry":[{},"(which may be multiple characters), the"]},{"entry":[{},"character will replace the selection."]},{"entry":["delete","At IP, deletes the character to the right. When there","Always"]},{"entry":[{},"is selection, deletes selection.","enabled."]},{"entry":["undo","Undo previous action, including candidate","Disabled"]},{"entry":[{},"selection, convert, insertion of a single","when"]},{"entry":[{},"character, deletion, and drag\/drop.","there is no"]},{"entry":[{},{},"previous"]},{"entry":[{},{},"action."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"The symbol picker  may be as simple as a list of all characters supported by the mathematical expression recognition system. Alternatively, symbol picker  may be implemented in the form of a keyboard with all the characters as buttons on the keyboard. For example, symbol picker  may replicate a categorization of all symbols, excluding those not supported by the mathematical expression recognizer system. For example, the categories may include: Algebra, Arrows, Binary Operators, Calculus, Geometry, Greek and Latin Characters, Operators with Limits, Relational and Logical Operators, Trigonometry, etc. A smaller set of categories may alternatively be employed. A dropdown menu  may be used to switch between categories, with regular symbols  being listed on the left, while dominant symbols  are separately listed on the right. Symbol picker  may be a modeless dialog box that users keep open to insert multiple symbols. For example, users may dock the dialog box below the text window.","When a user clicks on a symbol, it is inserted at the IP. In the example shown in , the user inserts the summation sign to replace the selection",{"@attributes":{"id":"p-0365","num":"0369"},"maths":{"@attributes":{"id":"MATH-US-00033","num":"00033"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msubsup":{"mi":"n","mrow":{"mo":"-","mn":"1"},"mfrac":{"mrow":{"mn":"1","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mi":"\u03c3"},"mn":"2"}},"mo":"."}}},"br":{},"b":["8541","8551","8553","8541","8551","8553"]},"If the user does not place anything in a placeholder  or , in one implementation, the placeholder is left empty in the result display area. The user may select and delete a placeholder  and\/or . Locations of lower limit  and upper limit  placeholders are centered for most operators except for a single integral where locations of the lower limit and upper limit placeholders are to the side. As mentioned previously, the user may erase and rewrite in the handwriting area and have the handwritten equation recognized again.","With respect to an application programming interface (API), various aspects of the present invention may be provided through an API. For example, public APIs may interface with an operating system to allow the operating system to provide the various features of the present invention. In one embodiment, a software architecture stored on one or more computer-readable media for processing data representative of a handwritten mathematical expression recognition computation may include a component configured to recognize handwritten mathematical expressions and an application programming interface to access the component. An API may receive a request to recognize a handwritten mathematical expression, access the necessary function(s) of the recognition component to perform the operation, and then send the results back to an operating system. The operating system may use the data provided from the API to perform the various features of the present invention. Software applications may also perform various aspects of the present invention through APIs in the same way as described in the above example.","While illustrative systems and methods as described herein embodying various aspects of the present invention are shown, it will be understood by those skilled in the art, that the invention is not limited to these embodiments. Modifications may be made by those skilled in the art, particularly in light of the foregoing teachings. For example, each of the elements of the aforementioned embodiments may be utilized alone or in combination or sub-combination with elements of the other embodiments. It will also be appreciated and understood that modifications may be made without departing from the true spirit and scope of the present invention. The description is thus to be regarded as illustrative instead of restrictive on the present invention."],"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","A. Factoring","B. Redefinition","C. Inline Coding","D. Divorce","E. Rewriting"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF THE DRAWINGS","p":["A more complete understanding of the present invention and the advantages thereof may be acquired by referring to the following description in consideration of the accompanying drawings, in which like reference numbers indicate like features, and wherein:",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIGS. 2B through 2M"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 11","FIG. 10"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIGS. 29A-29D"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIGS. 30A-30B"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 36","FIG. 35"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 37"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 38"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 39","FIG. 38"]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 40"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 41"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 42"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 43"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 44"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 45","FIG. 46"]},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 47"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 48"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 49"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 50"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 51"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 52"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 53"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 54"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 55"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 56"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 57"},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 58"},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 59"},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 60"},{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 61"},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 62"},{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 63"},{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 64"},{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 65"},{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 66"},{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 67"},{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 68"},{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 69"},{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 70"},{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 71"},{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 72"},{"@attributes":{"id":"p-0081","num":"0080"},"figref":["FIG. 73","FIG. 72"]},{"@attributes":{"id":"p-0082","num":"0081"},"figref":["FIG. 74","FIG. 73"]},{"@attributes":{"id":"p-0083","num":"0082"},"figref":["FIG. 75","FIG. 73"]},{"@attributes":{"id":"p-0084","num":"0083"},"figref":["FIG. 76","FIG. 75"]},{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 77"},{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIG. 78"},{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 79"},{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 80"},{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 81"},{"@attributes":{"id":"p-0090","num":"0089"},"figref":"FIG. 82"},{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 83"},{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 84"},{"@attributes":{"id":"p-0093","num":"0092"},"figref":"FIG. 85"}]},"DETDESC":[{},{}]}
