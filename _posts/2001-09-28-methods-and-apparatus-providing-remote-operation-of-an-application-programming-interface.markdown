---
title: Methods and apparatus providing remote operation of an application programming interface
abstract: A system can analyze an application programming interface definition to automatically produce software string generator and parser software components allowing remote access to functions within the application programming interface definition by processes that are not natively compatible with the computing system environment in which the application programming interface operates. A first string generator processes can produce an encapsulated function call from a first process, such as a Java-based process, that calls a first function in a first computing environment. A second parser process operates in a second computing environment to receive the encapsulated function call and to invoke a second function call in a second process, such as a C-based process. Results from the second function call are returned to a second string generator which produces an encapsulated response that is returned to a first parser process. The first parser process maps the encapsulated response back into first function call parameters for return to the first process, thus providing access to second functions of the application programming interface by the first process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07010796&OS=07010796&RS=07010796
owner: EMC Corporation
number: 07010796
owner_city: Hopkinton
owner_country: US
publication_date: 20010928
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EMBODIMENTS OF THE INVENTION"],"p":["The present invention generally relates to the operation of software applications in a remote manner, and more particularly, to systems and techniques which allow for remote operation of an application programming interface.","Many types of conventional computerized devices include hardware (i.e., circuitry and\/or software that other software applications (i.e., executing processes) or devices can access via one or more interfaces commonly referred to as application programming interfaces (APIs). As an example, a data storage system can include a collection of disk drives that may be coupled via a high-speed connection (e.g., SCSI, Fiber-Channel, or the like) to a computer system which operates as a data storage server that allows software applications to access and manage data stored within the data storage system. The server computer system may operate a data storage access software system which provides the processing logic and functionality required to access and manage the data stored within the data storage system. The data storage access software can provide a set of functions that collectively define an application programming interface. Other software applications that require access to data within the data storage system can incorporate the application programming interface into their code and can make calls to functions defined within the application programming interface. By providing such functions via an application programming interface, the low-level processing required to send, receive and\/or manage data to, from, or within the data storage system is encapsulated within the data storage access software functions. Other software applications thus only need to make calls to the required functions of the application programming interface in order to include such complex processing.","A typical conventional application programming interface defines a set of functions and respective function parameters which another entity (i.e., the calling entity) such as a software process may invoke by making a call to one or more of the functions defined by or within the application programming interface. When the calling entity invokes a function call to a function defined within the application programming interface, the calling entity typically supplies any required input values for any input parameters required for that function call. When an application programming interface function call is made in this manner, the code of the function (i.e., the processing logic included within the software application which provides the application programming interface) receives any associated input parameters and processes these input parameters according to the processing logic for that function. The processing logic of the function may produce data or other information which is output or returned from the function as a series of one or more output parameters. The calling entity can access the data processed by the function by referencing the output values associated with the output parameters which it receives as a result of having invoked the function call to the application programming interface.","During the process of developing a software application, a software developer writes application code (e.g., C code) to include the aforementioned functLon calls to functions defined within an application programming interface as needed to accomplish the goals of the software application under development. As an example, if a software developer is developing a database application, the database application code may be written to include function calls to functions within an application programing interface provided by the data storage access software mentioned above to allow the database application to store and retrieve data from the data storage system during its operation or execution.","In some situations, a software application operating on a computer system might require access to a function within an application programming interface which is available (i.e., which executes) on another computer system. Conventional software mechanisms have been developed to allow a software application operating on one computer system to remotely invoke the processing functionality associated with a function of an application programming interface provided on another computer system. An example of such a conventional software package is called remote procedure call or RPC. To use RPC, a software developer includes special RPC function calls into the code of the software application that requires remote access to the application programming interface. In addition, the software developer must manually create software that operates on the remote computer system which contains the application programming interface in order to receive and process an RPC function call. In other words, the software developer must manually develop a client side piece of software which invokes RPC function calls and must also manually develop a server side piece of software to receive and process those calls in conjunction with the application programming interface.","Conventional techniques and mechanisms for accessing functions provided by an application programming interface can suffer from a variety of deficiencies. In particular, in a software application that uses RPC as a mechanism for remotely accessing functions provided by an application programming interface, both the client and server side software applications are limited to incorporating RPC function calls for only the current set of functions provided by the application programming interface. In other words, only those functions which are available at the time of development of the client and server software application are available for access by RPC. This is because the RPC code must be manually developed for each application programming interface function that is to be accessed. If additional functions are incorporated into the application programming interface at a later time after development of the client and server software application which uses RPC, those new functions will not be available for use by the client and server software applications. In order for the client and server software applications to take advantage of these new functions, the software developer must modify the RPC function call statements and software code within the client and server portions of the software. This is largely a manual effort which requires a programmer to modify and recompile the source code in order for RPC to be aware of the additional functions available for use within the application programming interface. To this end, systems such as RPC require manual generation of the functions and data structures for use in operating an application programming interface from a remote process.","In addition, native compatibility must exist between the client and server computer systems that use RPC. Generally what is meant by \u201cnative compatibility\u201d is that variable and parameter type definitions for parameters passed between a client and server software application that use RPC function call mechanisms to remotely access functions of application programming interface must be the same format between the different operating platforms or environments in which the client and server portions of software application operate.","As an example, if the client side portion of a software application uses RPC function calls and is written in the C programming language and uses C variables and type definitions which conform to standard C language type definitions, the server side portion of the software application which receives the RPC function calls must also be written in the C programming language in order to define variables which conform to the same C language type definitions as the client side portion of the software application. Accordingly, it is inherently difficult for a client side software application written in one programming language, such as Java, to incorporate RPC function calls which are to be sent to a server side software application written in another programming language, such as the C or C++ language which uses different variable and type definitions. One reasons for this is because data structures defined in the Java programming language environment are generally incompatible in size and type with data structures defined using C or C++ language type definitions. Accordingly, conventional uses of RPC require that the client and server side portions of software be developed using the same programming language and use the same type definitions for parameters passed using RPC function calls.","The present invention provides mechanisms and techniques for accessing a second application programming interface in a second computing environment from a first process operating in a first computing environment that cannot natively access the second application programming interface. In one embodiment, the method includes the steps of detecting a first function call made by a first process in the first computing environment. Based on the first function call, the method generates an encapsulated function call for transfer from the first computing environment to the second computing environment. The encapsulated function call contains a mapping of first function call parameter values (e.g., input parameters) useable in the first computing environment to first meta parameter values, which may be strings, for example. The method then transfers the encapsulated function call containing the first meta parameter values from the first computing environment to the second computing environment.","Another method embodiment receives the encapsulated function call containing first meta parameters (the input parameters in this example) from the first computing environment. The method then parses the encapsulated function call to map the first meta parameters into second function call parameters associated with a second function definition in the second application programming interface definition. The method then invokes operation of the second function associated with the second process (i.e., using the input parameter values from the first meta parameters). In this manner, the first function can make a first function call to a \u201cparallel\u201d or equivalent stub function in the first computing environment which causes embodiments of the invention to invoke the string generator in the first computing environment to convert the first function call parameters into first meta parameters which are then passed, as an encapsulated function call, to a second parser process operating in the second computing environment. The second parser process receives the encapsulated function call and maps the first meta parameters into second function call parameters usable by the second function. The second parser process also then invokes the second function within the second application programming interface bypassing the second function the second function call parameters.","When the second function has completed its processing, the second string generator configured according to this embodiment of the invention receives second function call parameter values (e.g., output parameters) as output from invocation of second function. The method then maps the second function call parameters (i.e., the output parameters) into second meta parameters within an encapsulated response and transfers the encapsulated response to the first computing environment. A first parser process in the first computing environment can receive the encapsulated response and can parse the second meta parameters in this encapsulated response into first function call parameters (e.g., into output parameters that receive the output value of the second function from the second meta parameters) for return to the first process to complete the first function call.","Other embodiments of the invention relate to methods for automatically generating software components that allow or provide for operation of an application programming interface in a second computing environment from a first process in a first computing environment, in which the first process is not natively compatible with the second computing environment. One such method embodiment comprises the steps of analyzing a second application programming interface definition associated with a second computing environment to discover second function definitions in the second application programming interface definition. Based on the step of analyzing, the method automatically generates, for each second function definition discovered in the second application programming interface definition a plurality of software components.","In particular, a first string generator is generated that is capable of receiving a first function call in the first computing environment from a first process and encapsulating the first function call (e.g., input parameters from this function call) into an encapsulated function call. A second parser is generated that is capable of receiving the encapsulated function call and parsing the encapsulated function call (e.g., receive the input parameter values) to invoke a corresponding second function definition in the second application programming interface definition for operation within the second computing environment. A second string generator capable of receiving an output from the second function call (e.g., receiving output parameters) from a second process in the second computing environment and encapsulating the output (e.g., the values of the output parameters) into an encapsulated response. The method also generates a first parser capable of receiving the encapsulated response and parsing the encapsulated response to return the output (e.g., the output values of the output parameters from within the encapsulated response) to the first function in the first process operating in the first computing environment. In this manner, embodiments of the invention can analyze an application programming interface, such as a C or C++ language application programming interface definition (i.e., a C-based application programming interface), and produce software components that allow processes such as Java processes to access (e.g., invoke) functions within the C-based application programming interface.","Other embodiments of the invention include a computerized device, such as a workstation or other computer system, configured to process all of the method operations disclosed herein as embodiments of the invention. In such embodiments, the computer system includes an interface, a memory system, a processor and an interconnection mechanism connecting the interface, the processor and the memory system. In such embodiments, the memory system is encoded with one or more software applications (e.g., code) that when performed (e.g., executed) on the processor, produces software processes that cause the computer system to operate processes that can obtain access to a second application programming interface in a second computing environment from a first process operating in a first computing environment that cannot natively access the second application programming interface, and\/or that can automatically generate applications allowing operation of an application programming interface in a second computing environment from a first process in a first computing environment, in which the first process is not natively compatible with the second computing environment. Such software processes can perform all of the method embodiments and operations explained herein as embodiments of the invention.","Other arrangements of embodiments of the invention that are disclosed herein include software programs to perform the method embodiment operations summarized above and disclosed in detail below. More particularly, a computer program product is disclosed which has a computer-readable medium including computer program logic encoded thereon that embodies the steps and operations explained herein as the processing of the embodiments of the invention. The computer program logic, when executed on at least one processor with a computer system, causes the processor to perform the operations (e.g., the methods, operations or steps) indicated herein as embodiments of the invention. Such arrangements of the invention are typically provided as software, code and\/or other data arranged or encoded on any type of computer readable medium such as an optical medium (e.g., CD-ROM), floppy or hard disk, or other a storage medium such as firmware or microcode in one or more Read Only Memory (ROM) or Random Access Memory (RAM) or other microchips or as an Application Specific Integrated Circuit (ASIC). The software, firmware or other such configurations can be installed and operated within a computer system to cause the computer system to perform the techniques explained herein as embodiments of the invention.","It is to be understood that the system of the invention can be embodied strictly as a software program, as software and hardware, or as hardware alone (e.g., via implementation in circuitry). Example embodiments of the invention may be implemented within the EMC Control Center (ECC) software application that provides access to storage area network (SAN) managed resources in a SAN environment via an application programming interface. ECC is manufactured by EMC Corporation of Hopkinton, Mass., USA.","Generally, the present invention provides techniques and mechanisms that allow a software application operating as a first process in a first computing system environment to access (i.e., when executing as a process) functions associated with an application programming interface which operates or is available in a second computing system environment that is not natively compatible with the first computing system environment. By way of example, consider a computing system environment having two interconnected computer systems. The first computing system can be a \u201cserver\u201d computer which operates a Java-based server application as a first process. The second computing system may be an agent or interface computer system which operates a C-based agent application as a second process that provides an application programming interface that provides function calls accessible by other applications using C or C++ language constructs and semantics. As used herein, what is meant by a \u201cC-based\u201d or \u201cC-style\u201d environment is one that operates applications developed using the C and\/or C++ programming languages. The second or agent computing system can operate, for example, as an interface to a data storage system in which case the agent or interface software provides the application programming interface to allows other applications to access data within the data storage system.","Operation of the second or agent application programming interface however requires providing C-style function calls to functions defined within the application programming interface. Using conventional application programming interface access techniques, the Java-based server process (i.e., the first process) is not be able to easily or natively formulate or make C-style function calls to the functions within the C-based application programming interface provided by the agent (i.e., second) process. However, by utilizing embodiments of the invention, the Java-based server software is capable of invoking \u201cfirst\u201d Java-based function calls to \u201csecond\u201d C-based functions within the C-based application programming interface provided by the agent process operating on the agent computer system.","The terms \u201cfirst\u201d and \u201csecond\u201d will be used herein to distinguish between processes and other components that exist or operate within the different computing environments, such as Java and C-based environments. It is to be understood that the system of the invention is not limited to allowing only processes in Java and C environments to interoperate in the manner explained herein. Rather, the analysis and operational techniques explained herein can be used with many different types of different environments in which an application programming interface is accessed from an environment which is not native to that application programming interface.","Generally, to achieve this operation, embodiments of the invention initially perform an analysis and preprocessing operation on an application programming interface definition that is written in accordance with a programming language, such as a C-based application programming interface, in conjunction with a language grammar describing the syntax, constructs and semantics of the programming language, such as a C language grammar, and further in conjunction with support code for grammar processing. The inputs and details related to the analysis and application programming interface processing operations will be explained in more detail later. Generally however, as a result of the analysis and preprocessing of the application programming interface definition, embodiments of the invention produce software components that include two string generator and two parser processes, one each for both the server (i.e. the first, which may be a Jva-based) and the agent (i.e., the second, which may be a C-based) computing system environments. In addition, embodiments of the invention also produce an application programming interface definition that is useable in the first (e.g., in the Java) computing system environment and that contains callable function definitions that correspond one-to-one with function definitions in the second application programming interface definition that is analyzed. Embodiments of the invention then utilize the string generator and parser processes at runtime to allow first function calls made by the first (e.g., a Java-based) process to be mapped, transferred, and then executed as second function calls (e.g., as C-based function calls) within the second (e.g., C-based) process. In other words, embodiments of the invention allow the operation of application programming interface function calls between the two different and incompatible computing environments.","Before providing a detailed description of the application programming interface analysis and preprocessing briefly mentioned above, an explanation of the runtime operation of embodiments of the invention will be provided with respect to an example computing system environment illustrated in .",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 1","b":["100","100","110","120","130","140","110","120","130","140","100"]},"The client computer system  operates, executes, interprets, runs or otherwise performs a client process  that in this example is a web-based or Java-based process that a user of the client computer  can operate. Examples of the client process  are an Internet browser application, a Java or other type of applet, or a customized console software application that can interact with the first computing environment  to perform various functions.","The first or server computing environment  can be any type of computing system such as a workstation, personal computer, minicomputer, mainframe, network device, computerized device or the like. In this example, the first computing environment  represents a Java-based server computer system that operates as a server computer on behalf of the client computer . By Java-based, what is meant is that the first computing environment  includes a computer system configured to operate one or more server software applications written in the Java programming language, such as the first process  (e.g., a Java-based server) in this example. The first computing environment  in this example also includes a first API string generator , a first parser process  and a first API definition  generated and configured to operate according to embodiments of the invention as will be explained herein.","The second computing environment  can also be any type of computing system, computerized device or the like. In this example arrangement, the second computing environment  represents an agent computer system that operates a C-based software application execution environment that includes operation of software applications developed in the C programming language, such as the second process  which is a C-based agent process in this example. The second computing environment  in this example also includes a second API string generator , a second parser process  and a second API definition . As will be explained further, the second API definition  provides second function definitions - which, when invoked were called by other software applications cause the second process  to perform processing. In other words, the second process  represents the processing logic invoked as a result of a second function definitions - being called within the second API definition .","Throughout the explanation of embodiments of the invention, the terms \u201cfirst\u201d and \u201csecond\u201d will be used to refer to and to distinguish processes and operations (e.g., function calls, function definitions, data structure definitions and so forth) within the first and second computing environments  and .","According to one example embodiment, the first process  that operates in the first computing environment  is a storage management server process that allows one or more network storage managers (i.e., persons responsible for managing data storage systems within storage area networks) to operate one or more client processes  (only one shown for this example) from client computer systems  (e.g., over a network) to interact with the first process  to perform network storage management functions. Such functions involve the management of data within the data storage system resource . To access the data storage system resource , the first process  requires the ability to access the second functions - provided by the second process , which in this example is developed in the C programming language and operates as an agent process to provide the data access and management functions - defined within the second API definition . In other words, the second or agent process  provides a number of second functions - related to manipulation and access to the data storage system  that must be accessed using C-language function call semantics.","The second API definition  may be, for example, one or more C include files (e.g., \u201c.h\u201d files) that define and provide C function call headers for each particular second function definition - that provides access to the data storage system resource . C-based software applications requiring access to such functions can include the second API definition  into their source code in order to have access to the data storage system resource  through the second process . Examples of the second process  and its corresponding second API definition  and second function - are embodied within the SymAPI software product suite produced by EMC Corporation of Hopkinton, Mass., U.S.A.","Since the first process  is developed using the Java programming language, the first process , without the assistance of embodiments of the invention, cannot easily or \u201cnatively\u201d access the second functions - defined within the C-based second API definition  as provided by the second process . In other words, the Java process  cannot make native C function calls to the C functions - defined in the second API definition  due to the inherent limitations and differences between function calls, data structures and other aspects of the object oriented Java programming language as compared to the non-object oriented C programming language.","One operation of embodiments of the invention involves performing and analysis and processing technique (to be explained in detail) upon the second API definition  in order to automatically generate or produce the second API string generator  (a C-based software process), the second parser process  (another C-based software process), the first API string generator  (a Java-based software process), the first parser process  (another Java-based software process) and the first API definition  (a Java version of certain functions associated with the second application programming interface ). Prior to such an analysis and API processing operation, the C-based agent process  and its corresponding second API definition  can exist as an off-the-shelf product. However, during the analysis and processing of the second API definition  according to the techniques explained herein, a collection of first function call definitions (which are Java based in this example) are created within the first API definition  that may be natively accessed by the first process  within the first computing environment  with the assistance of the first API string generator  and the first parser process .","Generally, this allows the first process  to make first function calls to the first function definitions - within the first API definition  in a natively compatible format, such as by making Java-based function calls. The first API string generator  can accept  such first function calls and can pass a \u201cmeta\u201d or encapsulated version of the first function call parameter values associated with first function calls - to the second computing environment . As will be explained shortly, the first API string generator  converts or encapsulates the first function call parameters into an encapsulated function call  containing meta parameters which are an intermediate or universal representation of the parameter values and which are exchangeable between the first and second computing environments , . Within the second computing environment , the second parser process  receives the encapsulated function call  and is able to extract, parser or map the first meta parameters into function call parameters (e.g., into C-based values) required to invoke  one or more corresponding second function calls - defined within the second API definition  in order to activate the functionality of the second process . When the second process  has completed processing of all of the second function call(s), the resulting second function call parameters (i.e., the output of the second function as performed by the second process ) are accepted  by the second API string generator  which converts the second function call parameters into corresponding second meta parameters which are passed as an encapsulated response  back to the first computing environment  to be received by the first parser process . The first parser process  receives the encapsulated response  and is able to parse the encapsulated response to extract or map the second meta parameter values into the corresponding first function call parameters for return  to the first process . In this manner, the processing techniques of the invention provide the first process  with the ability to access functionality defined by the second API definition , even though such functionality cannot be natively accessed by the first process .","A more detailed description of the runtime operation and interaction between the software components ,  and  through  will be provided next with respect to the flow chart of processing steps illustrated in  and in conjunction with an explanation of example data access and processing operations between the first and second processes  and .",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 2","FIG. 1"],"b":["126","136","116"]},"According to the general runtime operation of the computing system environment , a user (e.g., storage administrator) operating the client process  on the client computer  provides a request for data  to the Java-based first process  (operating as a server on behalf of the client process). Based on the request for data , the first process  may determine that access is required to information within the data storage system resource . As explained above, such access can only be provided in this example by operating a second function - defined within the second API definition  which is carried out by the second process . In order for the Java-based first process  to access one or more of the second functions - provided by the second process  as defined in the second API definition , the software developer of the first process  provides an equivalent Java function call - to a first function within the code of the first process . In other words, the first process  includes a call to a corresponding first function definition - defined within the Java-based first application programming interface definition . This first function call - can accept Java data structures defined according to Java type definitions.","Accordingly, in step , during runtime operation of the first process , the first process  makes a first function call  to a first function - defined within a first application programming interface definition . The first application programming interface  may be a Java class that includes Java objects for each function call -. The first process  can obtain access to the first API definition , for example, by inheriting or including a reference to the first API definition  within its code. Upon making the first function call  in step , the first process  activates the first API string generator  to receive the first function call  and any first function call parameters associated with that first function call. In other words, the first function call whose header is defined within the first API  references Java software code within the first API string generator . By making such a first function call , the first process  provides first function call parameters in a format that is natively compatible with the first computing environment , such as by providing one or more Java-based data structures. Some of the first function call parameters within the first function call  may be input parameters in which the first process  provides input data for processing by the second process , while other first function call parameters may be output parameters which the first process  expects to receive back after the second process  processes the input parameters.","In step , the first API string generator  (activated as a result of the first process  making the first function call  to a first function - within the first API definition ) detects the first function call  made by the first process  within the first computing environment . By detects, what is meant is that the first API string generator  receives the first function call  and any of its associated first function call parameters (not specifically shown or enumerated in ).","In step , the first API string generator , based upon the first function call , generates an encapsulated function call  or transfer from the first computing environment  to the second computing environment . The encapsulated function call  contains a mapping of first function call parameter values (from the first function call ) which are usable (i.e., natively accessible) by processes in the first computing environment  to first meta parameter values within the encapsulated function call .","Next, in step , the first API string generator  transfers the encapsulated function call  containing the first meta parameter values from the first computing environment  to the second computing environment .","Generally then, in steps  and , the first API string generator  converts the first function call parameters within the first function call  into first meta parameters which are collectively referred to herein as an encapsulated function call . In one embodiment, the first meta parameters represent an alphanumeric character string of the information that contains any values of the first function call parameters of the first function call . In other words, the first API string generator  converts the parameters into a string which is then transferred as an encapsulated function call  to the second computing environment  for receipt, as will be explained shortly, by the second parser process .",{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 3","FIG. 2","FIG. 3","FIG. 1"],"b":["202","203","129","129","1","162","126","162","1","3","162","139","1","139","136","129","129","1"]},"In addition, the first API definition  includes first API definition data structures - that define mappings  between first function call parameters (FFCP) and corresponding first meta parameters (FMP). The first function call parameters in  represent any parameters values that the corresponding second function -, defined within the second application programming interface definition , will require as input. In this particular example, the first function call  includes a representation by a meta parameter data structure named FC which maps to a first meta parameter FMP and which indicates that a second function (SECOND FUNCTION, defined in the second application programming interface ) is the equivalent function as the first function call . In other words, the first function call definition  has an equivalent second function call definition - within the second application programming interface . The remaining first function call parameters FFCP through FFCP map to corresponding first meta parameters FMP through FMP which as noted above serve, in this example, as input parameters to a corresponding second function call definition within the second application programming interface .","In one embodiment, first function calls such as first function call  are defined in a Java-based format usable by Java-based first processes (e.g., ) and the first function calls - map to second function calls - within the second application programming interface . The second function calls are defined in a C-based format usable by a C-based second processes, such as second process .","As shown at location  within the code (e.g., Java code) of the first process , the first process  inherits the first application programming interface definition . This allows the first process  to have access to the function call definitions (e.g., ) within the first application programming interface definition . During operation (e.g., execution or interpretation) of the first process , upon invocation  of the first function call , the first process  makes a call  to the encapsulate function call  within the first API string generator  by calling the first function call definition . In other words, the encapsulated function  operates as the code or body of the first function call  and creates the encapsulated function .","To create or generate the encapsulated function , the first API string generator  also accesses the first application programming interface definition  that defines the first function calls (e.g., ) usable by first processes (e.g., ) in the first computing environment . Specifically, the first API string generator  references the first API definition data structures -. Using this information, the encapsulate function call  can extract the first function call parameters FFCP (i.e., any input parameters data structures used or required by the first function call , ) from the first function call  (called using the function definition ) into first meta parameters  using the mapping  within the first application programming interface . For each of the first function call parameters FFCP through FFCP, the encapsulate function  can select a respective first application programming interface definition data structure from the map  that can represent the first function call parameter FFCP as a first meta parameter FMP. In other words, when the first process  makes the first function call , the encapsulate function call  is activated  to receive the first function call parameters FFCP through FFCP (i.e., any input parameters, values) and can consult the first API definition data structures - to determine an appropriate respective first meta parameter data structure FMP through FMP that can be used to represent each respective first function call parameter. Once such a meta parameter data structure is selected from the map , the encapsulate function  copies the first function call parameter (i.e., the input parameter value) into the respective first meta parameter. In one embodiment, this copy procedure produces a set of first meta parameters that contain strings that represent the respective values of the first function call parameters.","An example of this processing is illustrated in  by the first meta parameters FMP through FMP. Note in this example that the first meta parameter FMP is not mapped to a specific function call parameter, but rather represents the identity of the first function call  itself, whereas the first meta parameters FMP through FMP contain string values that contain the input values of the first function call parameters FFCP through FFCP. Accordingly, the collection of first meta parameters FMP through FMP identify the first function call ,  (using FMP) as well as any first function call input parameters associated with that first function call. In this manner, the first API string generator  generates the encapsulated function call  for transfer (step  in ) to the second computing environment  for receipt by the second parser process .","After step  in , the second parser process  within the second computing environment  receives and processes the encapsulated function call .","Accordingly, prior to completing the discussion of the remaining processing steps in  that occur within the first computing environment , attention is directed now to  that contains a flow chart of processing steps  through  which occur within the second computing environment  in order to receive and process an encapsulated function call  and to produce and return an encapsulated response  back to the first computing environment .",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 5","FIG. 5","FIGS. 6 and 7","FIGS. 6 and 7","FIGS. 3 and 4","FIG. 3","FIG. 6","FIG. 7","FIG. 4","FIGS. 3 and 4","FIGS. 6 and 7"],"b":["130","250","256","138","137","250","256","153","261","262","139","136","261","136","130","154","137","154","154","120","130"]},"In step  in , the second parser process  () receives the encapsulated function call  that contains the first meta parameters (i.e.,  from ) from the first computing environment .","In step , the second parser process  parses the encapsulated function call  to map the first meta parameter values ( from  which represent input parameters values) into second function call parameter values  () defined within a corresponding second application programming interface definition data structures section - of the second application programming interface definition .","Next, in step , the second parser process  invokes operation of the second function ,  () associated with the second process  by passing the second function  the second function call parameter values  extracted from the first meta parameters FMP through FMP. In other words, the second function  in the second application programming interface  is invoked within the second process  using any required input parameters values as received within the set of first meta parameters values FMP through FMP (collectively  in ).",{"@attributes":{"id":"p-0068","num":"0067"},"figref":["FIG. 6","FIG. 6","FIG. 3","FIG. 3"],"b":["250","252","138","153","1","3","164","126","138","273","274","139"]},"In particular, the second parser process  can access second API definition data structures - which contain a mapping  that indicates which first meta parameter values map to which second function call parameter values. Also as shown in this example, the first meta parameter value FMP identifies which specific second function call  within the second API definition - is to be invoked within the second process . Using this information, the second parser process  can thus map the first meta parameter values FMP through FMP into corresponding second function call parameter values SFCP through SFCP (i.e., input values) and can then call or otherwise invoke operation of the second function code  within the second process , passing the second function  the second function call parameter values  as input. This causes the second process  to operate or otherwise perfomi the second function code  to interact with the data storage system resource  by sending data storage system commands  that produce data storage system results . The second process  may then return data storage system results  as output within the second function call parameter values SFCP through SFCP back to the second function . This processing and a corresponding example operation will be explained now with respect to steps  to  in  and an example illustrated in .","Returning attention now to the flow chart of processing steps shown in , in step , the second API string generator  operating within the second computing environment  receives the second function call parameter values as output from invocation of the second function .","In step , the second API string generator  maps the second function call parameters into second meta parameters. In other words, in steps  and , upon completion of operation of the second function  within the second process , any return results or output are provided to the second API string generator  which receives the second function call parameters and maps them into corresponding second meta parameters.","Next, in step , the second API string generator  places the second meta parameters into an encapsulated response  for return to the first computing environment . The second meta parameters in one embodiment of the invention are alphanumeric character strings which represent a string conversion and concatenation of the values returned in each of the second function call parameters produced from processing the second function code  in the second process .","In step , the second API string generator  transfers the encapsulated response  back to the first parser process  operating within the first computing environment . Thereafter, the first parser process  operates as previously explained with respect to  in order to process the second meta parameters contained within the encapsulated response  for return to the first process .",{"@attributes":{"id":"p-0074","num":"0073"},"figref":["FIG. 7","FIG. 5","FIG. 7"],"b":["253","256","136","261","1","3","1","3","261","261","137","263","2","4","265","139","2","137","1","2","4","261","1","4","263","154","137","139","139","2","265"]},"Generally, as explained above, the second parser process  can receive and map the first meta parameters into second function call parameters defined within the second API definition  for use by the second process . The second parser process  thus converts the first meta parameters within the encapsulated function call  into values that are compatible for activation of a corresponding second function call definition (corresponding to the first function call , ) within the second API definition . The second parser process  then calls the appropriate second function call definition - thus activating the functionality of second process , which in this example accesses the data storage system resource . Thereafter, the second process  operates on the return data  and returns second function call parameter values  (e.g., output parameter values) back to the second API string generator  within the second computing environment . The second API string generator  then operates in a similar manner as explained above with respect to the first API string generator  to convert these C-based second function call parameter values  returned from the second process  into second meta parameters (e.g., strings)  and places the second meta parameters into the encapsulated response . The second API string generator  then returns the encapsulated response  back to the first parser process  operating within the first computing environment .","Directing attention now back to step  in , the first parser process  operating within the first computing environment  receives an encapsulated response  from the second computing environment . The encapsulated response  contains second meta parameter values  produced in the second computing environment  from performance of at least one second function call  defined within the second application programming interface . The second function call (of which there may be more than one) corresponds to the first function call  (or as illustrated in detail as  in ) detected by the first API string generator  in the first computing environment . In other words, the encapsulated response  represents any return values  that the second process  in second computing environment  produces as a result of having processed the values associated with the first meta parameters  in the encapsulated function call .","Next, in step , the first parser process  parses the encapsulated response  in order to map the second meta parameter values (e.g., the strings containing output values of the second function )  back to the first function call parameters FFCP through FFCP for use by the first process  in the first computing environment . Generally, the processing of step  is the reverse processing of step  in that the first parser process  converts second meta parameters  within the encapsulated response  into return values  to be supplied (i.e.,  in ) back to the first process  within the appropriate first function call parameters of the first function call .","In step , the first process  then accesses the first function call parameters returned from the encapsulated response , as provided  by the first parser process , as shown in the example in .",{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIG. 4","FIG. 2","FIG. 4","FIG. 2"],"b":["204","206","161","129","1","204","205","127","154","130","162","173","127","154","174","193","126"]},"The functionality of the first parser process  illustrated in  thus performs a reverse mapping operation as compared to the first API string generator  previously explained with respect to . That is, the first API string generator  in  generates a string of input meta parameter values based on input function call parameters. The string generator  then passes the input meta parameter values to the second computing environment for invocation of a function within the second API definition . Upon completion of the function, the second API string generator  operates in a similar manner as the first API string generator  to create a string of output second meta parameter values representing the second function call parameters  returned or output as a result of the processing performed by the second process . When the second meta parameter values (e.g., the output parameters) are returned to the first computing environment  within the encapsulated response , the first parser process  is responsible for mapping the second meta parameter values into the appropriate first function call parameters  (e.g., output parameters) for return to the first function call  in the first process .","With respect to the illustration in , the first parser process  receives the encapsulated response  to the first function call . The encapsulated response includes second meta parameters SMP through SMP. In this particular example, the second meta parameters happen to correspond one-to-one with the first meta parameters FMP through FMP provided in the encapsulated function call  (). In other words, the second meta parameters contain any return or output information, data or function values produced as a result of operation of the second process  in response to receipt of the first meta parameter values within the encapsulated function call .","It is to be understood that there need not be a one-to-one correspondence between the input and output parameters for the first and second meta parameters and first and second function call parameter values. That is, it may be the case in another example that the first function call  uses a set of first function call parameters that contain input parameters values that are then mapped to first meta parameters, and that the second function ,  accepts these and produces a set of output parameter values that are different and are thus mapped (i.e., by the second parser string generator  in ) into different second meta parameters for return to the first function  in a set of different first function call parameters. In other words, in the aforementioned example, the first function call parameters FFCP through FFCP all contained input values that were mapped () to first meta parameters FMP through FMP which were then provided as input values to the second function  () second function call parameters SFCP through SFCP. These same second function call parameters SFCP through SFCP also were used as output parameters from the second function  and were mapped back into second meta parameters SMP through SMP (). In the alternative, it may be the case for example that the first () and corresponding second function () can use certain parameters as input parameters and other parameters as output parameters in which case one corresponding set of first function call parameters FFCP's, first meta parameters and second function call parameters SFCPs would be used in  as opposed to a different set of parameters for .","Also as shown in , when the first parser process  receives the encapsulated response , the first parser process  parses the encapsulated response  to detect the second meta parameters SMP through SMP. Then, for each of the second meta parameters that are detected in the encapsulated response , the first parser process  selects a respective first application programming interface definition data structure  within the first application programming interface  (specifically -) that can map the second meta parameter to an appropriate first function call parameter. In other words, for each output meta parameter within the encapsulated response , the first parser process parses the encapsulated response and determines an appropriate data structure (a Java data structure in this particular example) that maps to the meta parameter in order to receive the output value from the meta parameter. Thereafter, the first parser process  copies the second meta parameter values SMP through SMP into respective first application programming interface definition data structures  to produce first function call parameters that contain the values of the second meta parameters. The first parser process  then returns the resulting first function call parameters FFCP through FFCP back to the first function call  made within the first process .","As a result of this processing, the first function call  and hence the first process  receive return data or output processed according to one or more second functions provided by the second process  in the second computing environment . This embodiment of the invention thus allows the first process  to access functions within the second API definition  even though the first process  cannot make natively compatible function calls to the second API definition .","In the aforementioned example embodiments of the invention, the first function calls - defined within the first application programming interface  are defined in a Java-based format usable by Java-based first processes . In addition, the second function calls - defined within the second application programming interface definition  are defined in a C-based format usable by C-based second processes . It is to be understood that these are example embodiments of the invention and that the invention is not limited to operation in only Java and C computing environments. Embodiments of the invention can also be used to provide similar functionality to allow programs written in other languages besides Java and C to operate in a similar manner.","In addition, in the aforementioned example, the first function call ,  maps directly to, or corresponds one-to-one with, a second function call definition ,  defined within the second application programming interface definition . As an example, if the first function call  were a \u201cREAD_DATA\u201d function call formatted according to Java syntax and semantics, a similar corresponding second function call named \u201cREAD_DATA\u201d that accepts C parameters exists within the second API definition . Accordingly, when the second parser process  within the second computing environment  receives an encapsulated function call  for the \u201cREAD_DATA\u201d first function call, the second parser process  can perform a one-to-one mapping or conversion of the first meta parameters (e.g., string values) of the encapsulated function call  into C-based second function call parameters associated with the \u201cREAD_DATA\u201d second function calls defined within the second API definition . As noted above, also in the former example, the parameters used for the first and second functions  and  are all both input and output parameters, though this does not have to be the case and this is by way of example only.","It is to be understood that the aforementioned technique for passing the identities and parameter values for function calls between the first computing environment  into second computing environment  are explained by way of example embodiments only. That is, the aforementioned technique of using a meta parameter such as a string value to contain an identity of a corresponding function within the second API definition  which is to be invoked upon receipt of the encapsulated function call  is one technique for providing such function identification. In an alternative arrangement, there can be separate and distinct encapsulated function calls  that correspond to one or more specific second functions within the second API definition . Using the \u201cREAD_DATA\u201d example from above, there can be a \u201cREAD_DATA\u201d encapsulated function call  that only requires receipt of the specific first function call parameters FFCP through FFCP. First meta parameter FMP would not be required in this alternative embodiment since the actual function call itself  identifies or corresponds to the specific second function or functions within the second API definition  to which the first meta parameters should be passed.","It is further to be understood that in one embodiment of the invention, the first meta parameters contain strings that represent values of the first function call parameters. In addition, the second meta parameters contains strings that represent values of the second function call parameters returned from the second process . The use of alphanumeric character strings to represent values of the function call parameters (both first and second function calls within the first and second computing environments) is done by way of example only. Other techniques of encoding data into different interchangeable formats could be used as well.",{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 8","b":["110","120","130","120","130","120","130","110","120","130","110","120","130","111","121","131","112","122","132","113","123","133","114","124","134","114","124","134","110","120","130"]},"The memory systems ,  and  are encoded with software applications as illustrated. In particular, the memory system  in the client computer system  is encoded with a client application . In the first and second computer systems -A and -A, the respective memory systems  and  are encoded with the following software applications: respective first and second applications -A and -A; respective first and second application programming interface string generator applications -A and -A; respective first and second parser applications -A and -A; and respective first and second application programming interface definitions  and . The respective applications , -A, -A, -A and -A, -A and -A represent software code such as data and\/or logic instructions (e.g., stored in the memory or on another computer readable medium such as a disk or other storage media) that embody the processing functionality of respective portions of embodiments of the invention. Generally, the respective processors ,  and  in each of the computer systems , -A and -A can access their respective memory system ,  and  via the respective interconnection mechanism , ,  in order to launch, run, execute, interpret or otherwise perform the logic instructions of the applications , -A, -A, -A and -A, -A and -A in order to produce the respective processes  and , ,  and ,  and . In other words, the processes  and , ,  and ,  and  represent one or more portions of the applications , -A, -A, -A and -A, -A when performing within or upon the respective processors ,  and\/or .","Is to be understood that embodiments of the invention include the applications -A, -A, -A and -A, -A and -A (i.e., the un-executed or non-performing logic instructions and\/or data) encoded within a computer readable medium such as a floppy disk, hard disk or in an optical medium, or in firmware, read only memory (ROM), or, as in this example, as executable code within the memory systems  and\/or  (e.g., within random access memory or RAM). It is also to be understood that other embodiments of the invention comprise the applications -A, -A, -A and -A, -A and -A operating as respective processes , ,  and ,  and  operating within the processors , . While not shown in this example, those skilled in the art will understand that the computer systems , -A and -A may also include other processes and\/or software and hardware components, such as operating systems, which have been left out of the illustrations for ease of description of embodiments of the invention.",{"@attributes":{"id":"p-0092","num":"0091"},"figref":["FIG. 9","FIG. 3","FIG. 3"],"b":["300","300","420","420","139","405","139","420","418","410","418","418","415","418","127","137","428","422","129","129","1","129","2","428","430","128","422","420","138"]},"In this example, the second application programming interface definition  is a C-based include file that defines second function calls that the second process  () can operate to provide the capability of the second functions - defined within the API definition . In other words, the application programming interface definition  may be a source code file such as a C-style include or \u201c.h\u201d file which defines second function definitions - (e.g., function calls) associated with the application programming interface that the second process  can operate upon (e.g., provide the function code for). Other C-based software applications can access the functions of the application programming interface  by including the second application programming interface definition file  into their source code along with calls to the specific second functions - defined within the second application programming interface .","Generally, based on the analysis of this second API definition  in conjunction with the other inputs  through  and some additional processing which will be explained, embodiments of the invention produce the aforementioned software components , , , ,  that, as explained above, can allow a program or software application that is developed in a different programming language (e.g., Java) or that operates on a different computing system platform (e.g., a Java based platform) to access the functions within the API definition. Prior to the explanation of the operation of the grammar API processor  as illustrated in , some details concerning the contents of the support code  and the functions and data structures file  will be provided to assist in understanding the analysis operation discussed thereafter.","In this example, the support code  for grammar processing contains C-code instructions such as \u201cprintf statements\u201d indicating what the grammar API processor  is to produce as output upon the occurrence of detecting a specific second function definition  (e.g., as shown in ) while parsing the second application programming interface definition . The specific second functions  that the support code  is associated with are defined in the second functions and data structures file . That is, the grammar API processor  operates to take as input the grammar  to generate parser code . The parser code  is then linked with the support code  to make the API processor . The API processor  operates to takes as input the second API definition  and the functions and data structures file  (which lists the functions of interest, such as  in  for use by the first process ) to completely parse the second API  and then uses the support code  to produce the string generators  and , grammars  and , and first API definition .","Generally, the support code  provides call back functions and post processing functions that operate on a knowledge base created from the initial parsing of the API  by the grammar application programming interface processor . Thereafter, the parser output  is linked with the support code . The functions and data structure file  is used by the support code  during the initial parse of the second application programming interface  in order to build up the knowledge base. The functions and data structure file  indicates what functions are of interest (i.e., are callable by the first process  in ) and what overrides need to be made to the default heuristics of how parameters are handled for such functions. By the end of the parsing phase, all of the decisions have been made about how each function (e.g.,  in ) and each argument is to be handled as either input or output.","The functions and data structures file  thus defines a set of default overriding heuristics or rules for certain variable data structures defined within the second application programming interface definition  if those data structures need to override the default heuristic provided by . By way of example, in addition to specifying which second function definitions within the second API definition  are of interest for \u201cconversion\u201d for use in the first computing environment , the second API definition  also contains one or more global type definitions for variables and parameters that are accessible by the second function definitions. As those skilled in the art understand, application programming interface definition files can contain many data structures  () which are globally accessible from many functions  within the application programming interface . The functions and data structures file  lists or otherwise indicates only those parameters or data structures that require overriding from the default heuristics handling specified in . In other words, the functions and data structures file  lists exceptions for data structures within the second API definition  that are either input or output to second function definitions listed within the functions and data structures file  and specifies the role that those parameters are to take in a function call as opposed to their default role specified in . As indicated above, the second functions listed within the functions and data structures file  are those functions for which a first process  will be able to access as first functions  () using the aforementioned techniques. As an example, if an \u201cint *\u201d parameter by default is interpreted as an output parameter to a function call  in the second application programming interface definition , if in another specific function it is meant to be an input parameter (as opposed to the default handling as an output parameter), then the functions and data structures file  can specify that this parameter for this function is to be treated as an input parameter. In addition, if all \u201cint \u201d parameters in a function should be interpreted as input parameters in the entire application programming interface , then the functions and data structures file  can specify this as well.","According to one embodiment of the invention, the grammar API processor  is an off-the-shelf software product which is publicly available. In particular, the grammar API processor  in one example embodiment is one or more software processes contained within the Purdue Compiler Construction Toolset available from the www.antlr.org.",{"@attributes":{"id":"p-0099","num":"0098"},"figref":["FIG. 10","FIG. 9"],"b":"300"},"In step , the grammar API processor  analyzes the second application programming interface definition  associated with the second computing environment (, which is a C language application operating environment) to discover second function definitions in the second application programming interface definition  and produces parser output . As mentioned above, in the embodiment illustrated in FIG. , the functions and data structures file  indicates which particular second functions the grammar API processor  attempts to discover and process during analysis in step . The parser output  is then linked with the support code  to produce the application programming interface processor .","In step , based in the analysis in step , the grammar API processor  (now operating as ) automatically generates, for each second function definition discovered in the application programming interface definition  (and, in this example, corresponding to those listed in the functions and data structures file ), a number of software components , , ,  and .","In step , the API processor  generates a first string generator  which, as explained above, is capable of receiving a first function call in the first computing environment  from a first process  and encapsulating the first function call into an encapsulated function call . In one embodiment of the invention, the first string generator  which is automatically generated in step  is created or generated upon detecting or discovering each second function call definition, as listed within the functions and data structures file . Upon discovering each second function call definition, the API processor  invokes the appropriate corresponding support code  to perform the processing steps illustrated in .",{"@attributes":{"id":"p-0103","num":"0102"},"figref":["FIG. 11","FIG. 10"],"b":["452","127"]},"In step , the API processor  produces a set of first application programming interface definition data structures - that define first function call parameters that correspond to second function call parameters associated with the second function call definition. An example of this processing was discussed above.","Next, in step , the processor  produces a set of functions (e.g., ) that can generate the set of first meta parameters  that can represent the first application programming interface definition data structures - when a function  gets called from the first process . In step  then, after having created a set of first application programming interface data definition structures - from the processing explained above with respect to step , the API processor  produces corresponding functions that can produce the set of first meta parameters  that can represent the first application programming interface data definition structures. In one embodiment of the invention, the first meta parameters (e.g., ) represent alphanumeric character strings defined according to a data structure format usable within the first computing environment . As an example, if the first computing environment  is a Java-based software operation environment, then the first meta parameters  can be Java string parameters that map to first function call parameters  () made by a Java function call to the first function by the first process .","In step , the API processor  produces a first string generator function (associated with the second function call definition  currently being processed) that can receive, from a first process  that can operate in the first computing environment , a first function call  () that corresponds to the second function call definition . The first string generator function (e.g.,  in ) is capable of mapping the first function call parameters provided by the first function call to respective first meta parameters for encapsulation within an encapsulated function call  for transfer to the second computing environment  (i.e., during run-time). In other words, in step , the API processor  produces as output, and as part of the first API string generator , a function  that can receive the function call to the first function  within the first process  and that can map the first function call parameters to first meta parameters  as discussed above with respect to the example illustration in .","Returning attention now to the flow chart of processing steps in , in step , the API processor  also automatically generates a second parser  (i.e., which can operate at runtime as the second parser process). The second parser  produced in step  is capable of receiving an encapsulated function call  as previously explained with respect to . The second parser  produced in step  is also capable of parsing the encapsulated function call  to invoke a corresponding second function ,  () in a second process  defined in the second application programming interface definition  for operation within the second computing environment .","As illustrated in , production of the second parser process  involves the API processor  first producing a second API specific grammar  which defines the functions and data structures of the second functions and second data structures listed in the functions and data structures file  from the second application programming interface . In other words, the second API specific grammar  is a stripped down version of the second API interface definition  that only contains the second functions and data structures inferred from processing the second application programming interface definition  as explained above. This grammar  along with language grammar  are then processed by the API processor  in order to produce the second parser process  which converts meta parameters received within an encapsulated function call  into corresponding C-based second function call parameters usable by second function calls  defined within the second API definition .",{"@attributes":{"id":"p-0109","num":"0108"},"figref":["FIG. 12","FIG. 10"],"b":["453","138"]},"In step , the API processor  receives the second application programming interface specific grammar  produced as a result of the step of analyzing the second application programming interface definition (i.e., step ).","Next, in step , the API processor  processes the second application programming interface specific grammar  to produce the second parser  by converting second function call definitions  within the second application programming interface specific grammar  into parser routines (e.g., parse function call  in the example in ) that can accept and parse first meta parameters  () within encapsulated function calls  to provide second function call parameters  () to second function calls  associated with a second process  that can operate in the second computing environment . In other words, in step , the API processor  produces a respective second parsing function for each second function call definition . The respective parsing function is capable of receiving an encapsulated function call  that contains meta parameters  associated with the second function call definition  and is capable of mapping or converting or copying the values of the first meta parameters  into second function call parameters  and then is capable of invoking the second function call  to operate the second function  within the second process  by providing the second function call  with the second function call parameters . This processing was explained above with respect to .","Returning attention now again to the flow chart of processing steps in , in step , the API processor  in  automatically generates a second string generator  capable of receiving an output of a second function  (as in the example in ) of the second process  in the second computing environment  and encapsulating the output into an encapsulated response . An example of the processing capable of being performed by a second string generator  produced as a result of the processing of step  is shown in  and has previously been explained.",{"@attributes":{"id":"p-0113","num":"0112"},"figref":["FIG. 13","FIG. 10","FIG. 13","FIG. 10"],"b":["454","418","137","454","262","418","139","415"]},"In step , the API processor  produces a set of second meta parameters (e.g.,  in ) that can represent second function call parameters  () used by the second function call definition . The second meta parameters are produced by accessing the second application programming interface definition data structures - defined in the second application programming interface definition , as listed or otherwise identified within the functions and data structures file . That is, as noted above, the functions and data structures file  indicates which data structures  are to be used to allow second function definitions  to be accessed by a first process  (via calls to corresponding first functions ) operating in another computing environment . The second string generator  includes the ability to receive an output from a second function operation  within the second process  and to convert the second function call parameter values  into second meta parameters  for encapsulating within an encapsulated response . Accordingly, in step , the API processor  produces a set of second meta parameters  that represent or map to corresponding second function call parameters used by the second function call definitions .","Next, in step , the API processor  produces a second string generator function (e.g., the encapsulated response function  illustrated in ) and that can receive, from the second process  that operates in the second computing environment , the second function call parameters  produced as output from the second process  by performing the second function call . The second string generator function  (e.g., ENCAPSULATE RESPONSE in ) is capable of mapping the second function call parameters  provided from invocation of the second function call  into second meta parameters  for encapsulation within an encapsulated response  for transfer back to the first computing environment . In this manner, the encapsulated response function code  is generated to allow return results from the second function  to be sent back to the first process  via an encapsulated response .","Returning attention once again to the flow chart of processing steps in , step  is performed by the API processor  to automatically generate the first parser  which is capable, when operating as a process, of receiving an encapsulated response  and parsing the encapsulated response  to return second function output  to the first function  originally called from the first process  operating in the first computing environment . As discussed in detail above with respect to , the first parser process  is capable of receiving the encapsulated response  and mapping the second meta parameters  back into first function call parameters  for return to the first process .",{"@attributes":{"id":"p-0117","num":"0116"},"figref":["FIG. 14","FIG. 10","FIG. 9"],"b":["455","128","428","128","418","430"]},"Recall from the aforementioned explanation that the first computing environment is a Java-based computing environment in one embodiment of the invention. As such, the first API specific grammar  defines or contains Java specific data structures - and function call definitions - produced when the API processor  detects a second function definition  within the second API definition . In other words, during analysis of the second API definition , support code for second functions can produce the appropriate text for the first API specific grammar  which may be a file formatted according to a Java specific API grammar. Accordingly, instead of using a C-based grammar API processor , this example embodiment of the invention uses a secondary API processor  which is a Java-based grammar processor. An example of such a secondary application programming interface processor  is the ANTLR Java-based grammar processor produced by a company called jGuru and the software is available at www.antlr.org. The secondary API processor  can produce Java code based upon the analysis of the first API specific grammar . Specifically, the secondary API processor  can produce the Java code for the first parser process .","In step , the secondary API processor  receives the first application programming interface specific grammar  produced as a result of the step  () which performed the analysis of the second application programming interface definition .","Next, in step , the secondary API processor  processes the first application programming interface specific grammar  to produce the first parser process  (i.e., to produce the code that when executed provides the first parser process) by converting first function call definitions defined within the first application programming interface specific grammar  into Java-based parser routines  (as in the example in ). The parser routines  can accept and parse meta parameters (specifically, second meta parameters as in the example illustrated in ) within encapsulated responses  to provide first function call parameters  which are returned back to the first function call  associated with the first process  that operates in the first computing environment . In other words, in step , the secondary API processor  can detect function call definitions within the first API specific grammar  and can produce parsing functions  that are capable of converting second meta parameters  into first function call parameters  associated with each of these function call definitions.","In this manner, as explained above with respect to the example in , the first parser process  is able to parse encapsulated responses  and return results to the function calls  made by the first process . This allows the first process  access to second function call definitions  defined within the second application programming interface definition  operating within the second computing environment .","Using the aforementioned processing techniques, the embodiments of the invention illustrated with respect to  and with the flow chart of processing steps in  are capable of performing an analysis on an application programming interface definition written, for example, in the C programming language and are capable of producing string generators and parser processes which allow encapsulated function calls  to be transferred from one computing environment to another at which point those function calls are processed using a second API which is otherwise unavailable to the first computing environment (i.e., to the first process initially making the function call to the first API). Thereafter, when the function call is processed in the other computing environment, a string generator process can operate to encapsulate return values into an encapsulated response  for return to the original computing environment which operates the first process which initially made the first function call. Since meta parameters are used to represent function call parameter values passed between the two computing system operating environments, incompatibility differences associated with the way in which function calls are actually invoked are insulated from one computing environment to the other. This allows a computing environment such as Java to allow Java processes to invoke C functions provided by a C application programming interface operating in another computing system.","Those skilled in the art will understand that there can be many other variations made to the operations of the embodiments explained above while still achieving the same objectives of the invention. Such variations are intended to be covered by the scope of this invention. As such, the foregoing description of embodiments of the invention is not intended to be limiting. Rather, any limitations to embodiments of the invention are presented in the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing and other objects, features and advantages of the invention will be apparent from the following more particular description of preferred embodiments of the invention, as illustrated in the accompanying drawings in which like reference characters refer to the same parts throughout the different views. The drawings are not necessarily to scale, with emphasis instead being placed upon illustrating the embodiments, principles and concepts of the invention.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 10","FIG. 9"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
