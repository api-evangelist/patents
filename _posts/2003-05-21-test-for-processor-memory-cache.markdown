---
title: Test for processor memory cache
abstract: Systems, methods, software products test a memory cache of a processor that includes a test engine (e.g., a BISTE). High level test source code is formulated to use routines in API source code that, when compiled into machine test code, interfaces with the test engine. The machine test code is executed with the processor to test the memory cache to detect one or more faulty memory blocks in the memory cache. If any of the faulty memory blocks are detected, the test engine is instructed, through the machine test code, to set one or more bits in registers to functionally replace the faulty memory blocks with redundant blocks of the memory cache.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07058864&OS=07058864&RS=07058864
owner: Hewlett-Packard Development Company, L.P.
number: 07058864
owner_city: Houston
owner_country: US
publication_date: 20030521
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE FIGURES"],"p":["Complex processors are often tested after manufacture and prior to customer shipment. Typically this testing includes (a) evaluating the processor's internal memory cache, and (b) repairing the memory cache if faults are found. To facilitate testing, the processor's designer uses a workstation to create a macro script. The macro script is a set of instructions written in low level assembly language with predefined macros that aid in constructing complex test sequences. The macro script is expanded into an assembly language source sequence that is then assembled into machine code.","The machine code is loaded into non-volatile memory of a testing device. Typically this testing device varies power supply voltages to the processor during testing to verify correct processor functionality over its full operational voltage range. Each memory block of the memory cache is individually tested. The memory cache includes redundant memory blocks to be used in place of any faulty memory blocks\u2014so long as the faulty memory blocks are detected during testing of the processor. The processor has a one-time programmable (\u201cOTP\u201d) memory (also known as a fuse) that encodes the faulty memory blocks such that the redundant memory blocks are later used in place of the faulty memory blocks, thereby repairing the memory cache. The processor also contains a built-in-self-test engine (\u201cBISTE\u201d) that reads the OTP memory to map the redundant memory blocks to the faulty memory blocks in repairing the memory cache. The BISTE is controlled by the machine code when executed by the processor.","While the use of macros aid the designer in creating complex test sequences, the macro script and expanded assembly language source are difficult to comprehend and maintain due to their low-level interaction with the processor and the BISTE. The time and cost associated with developing and modifying macro scripts to accommodate new or different tests is therefore significant.","In various embodiments, one method tests memory cache of a processor that includes a test engine, including: formulating high level test source code to use routines in API source code that, when compiled into machine test code, interfaces with the test engine; executing the machine test code with the processor to test the memory cache to detect one or more faulty memory blocks in the memory cache; and, if any of the faulty memory blocks are detected, instructing the test engine, through the machine test code, to set one or more bits in registers to functionally replace the faulty memory blocks with redundant blocks of the memory cache.","One software product includes instructions, stored on computer-readable media, wherein the instructions, when executed by a computer, perform steps for testing a memory cache of a processor, including: formulating machine test code; executing the machine test code on the processor to test the memory cache to detect one or more faulty memory blocks in the memory cache; and, if any faulty memory blocks are detected, utilizing routines to set one or more bits in registers to map the faulty memory blocks to redundant memory cache blocks.","In various embodiments, one system tests a memory cache of a processor of the type that includes a test engine and programmable memory, including: machine test code means, compiled from high level test source code, and API source code, for defining tests to be performed by the test engine; and API code means for interfacing with the test engine in performing the tests to identify faulty memory blocks of the memory cache.","In various embodiments, a processor includes a memory cache for caching data within the processor. A test engine is responsive to machine test code, compiled from high level test source code using routines in API source code, to (a) test the memory cache to detect faulty memory blocks of the memory cache and (b) to set one or more bits that functionally replace the faulty memory blocks with redundant blocks of the memory cache.",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1","b":["50","68","58","68","74","70","76","58","68","52","58","55","54","60","58","60","78","68"]},"Workstation  is for example used to create high level test source code  that defines tests to be performed on processor . BISTE API source code  may be developed on workstation  to facilitate creation, development and maintenance of high level source code . BISTE API source code  provides pre-developed routines that, when compiled into BISTE API code , interface with BISTE . High level test source code  and BISTE API source code  are, for example, compiled by a compiler  within workstation  and then transferred to test unit  as machine test code . Machine test code  thereby contains high level test code , generated from high level test source code , and BISTE API code , generated from BISTE API source code . Machine test code  is for example stored within non-volatile memory  of test unit .","High level test code  calls routines within BISTE API code  to access and control BISTE  through control registers . In one example, high level test code  contains calls to routines of BISTE API code  to perform specific tests on memory cache  and to return test results to test unit . Workstation  may interact with test unit  to display these test results. BISTE API code  may further contain higher level routines to repeat one or more of the tests before returning test results. BISTE API code  may therefore contain a hierarchy of routines to access and control BISTE .","Memory cache  is divided into memory blocks  that facilitate testing and repair. Certain memory blocks  may contain faults and are illustratively shown as faulty memory blocks . Memory cache  therefore has redundant memory blocks  used to repair memory cache  through operation of BISTE . BISTE  tests memory cache  and determines bits to be set in OTP memory  to identify faulty memory blocks .","BISTE  is used in post-manufacture testing, e.g., within test unit , and during normal operation, when processor  operates within a customer's computer system. During normal operation, this computing system effectively replaces test unit  by storing machine test code  within separate non-volatile memory. In either case, therefore, BISTE  performs tests on memory cache  during power-up to detect and functionally replace faulty memory blocks  and ensure operability of processor . Specifically, BISTE  reads the OTP memory bits to map redundant memory blocks  to faulty memory blocks , making memory cache  fully operational.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2","b":["62","62","90","92","94","61","90","78","78","90","92","92","94","74"]},"Six pass cache test function  is one example of one function of high level routines  called by high level test code . Six pass cache test function  calls cache test function  of low level routines , which in turn calls write BISTE control register function  of BISTE control routines . High level test code  may call other functions of low level routines  and BISTE control routines  as a matter of design choice. In one embodiment, there are two register access levels to BISTE ; specifically, control registers  to BISTE registers  of BISTE . Accordingly, BISTE control routines  may therefore include read BISTE register function , to read BISTE registers , and write BISTE register function , to write BISTE registers , to facilitate access to BISTE registers  and control registers .","The following pseudo code illustrates one example of high level test source code  utilizing BISTE API source code  that, when compiled into machine test code  by compiler  and executed by processor , controls BISTE  to test memory cache . Specifically, the pseudo code tests memory blocks  of memory cache , generates reports of test results, and effects repairs to memory cache  by calling a function \u201cIdentifyBadMemoryBlock\u201d. IdentifyBadMemoryBlock generates an output identifying the faulty memory to program mapping information into OTP memory ; this information is later used by BISTE  to set register bits and map redundant memory blocks  to faulty memory blocks  on power-up of processor .",{"@attributes":{"id":"p-0020","num":"0019"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"* * * * * * Pseudo Code * * * * * *"},{"entry":"uses BISTE_API;"},{"entry":"FUNCTION TestMemoryCache;"},{"entry":"VARIABLES"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Result : boolean;","{ Stores the pass\/fail result from the test }"]},{"entry":[{},"CacheMemoryBlock: BlockIndex;","{ Used to step through memory blocks }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"BEGIN"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FOR CacheMemoryBlock:=FirstCacheBlock TO LastCacheBlock DO"]},{"entry":[{},"BEGIN"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"252pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Result := SixPassCacheTest (CacheMemoryBlock);"]},{"entry":[{},"IF Result = FALSE THEN"]},{"entry":[{},"BEGIN"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ Errors indicate that the block must be repaired }"]},{"entry":[{},"IdentifyBadMemoryBlock(CacheMemoryBlock); { Keep track of bad blocks }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"252pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"END"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"END;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"END;"},{"entry":"* * * * * * Pseudo Code * * * * * *"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In the above pseudo code, FirstCacheBlock is an identifier defining a first block of memory blocks , and LastCacheBlock is an identifier defining a last block of memory blocks . A function TestMemoryCache contains a for-loop indexing from FirstCacheBlock to LastCacheBlock, to step through each block of memory blocks .","Each block of memory blocks  is then tested by six pass cache test function  of high level routines , . Six pass cache test function  returns a Boolean value indicating whether the test passed (true) or the test failed (false). If the test fails, an IdentifyBadMemoryBlock function generates an output referencing the failed memory block, identified by CacheMemoryBlock.","The following code segments illustrate one example of a \u2018#define\u2019 statement specifying bit fields within BISTE registers . The segments specifically illustrate the use of a macro statement that generates source code for a processor instruction that writes bit values passed as parameters to BISTE registers . A source code statement is shown utilizing the macro and the \u2018#define\u2019 statement to produce a processor assembly code instruction to load a bit pattern specified in the \u2018#define\u2019 statement into BISTE registers .","#define:",{"@attributes":{"id":"p-0024","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":["#define L1_INDEX_CNTL_PERIOD 0,5,3,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X\n\nMacro:\n","BistPutField MACRO r,x,pos,len,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,t depd r,pos,len,t\n    \n    ","BistPutField %r3,L1_INDEX_CNTL_PERIOD,arg4"]}},"Through the \u2018#define\u2019 statement, a first string of characters identifies a second string of characters. During macro expansion, at each location where the first string is used in the source code, the first string is replaced by the second string. For example, such \u2018#define\u2019 statements may be used to specify bit field properties (e.g., location, size, default values) for use in other macros. The bit field properties are stored as comma-separated items in the second string; the position and number of the items are kept constant. If for example the third item in the second string is defined as a bit length for a register field, the third item in the second string of other associated '#define statements will also specify a register field bit length. If an item is not required for a particular definition, an \u2018x\u2019 fills the space in the second string to maintain the number and order of the items in the second string.","By way of example, in the above \u2018#define\u2019, a first string identifier \u201cL1_INDEX_CNTL_PERIOD\u201d identifies twenty-five items separated by commas in the second string; though only twenty items are actually used of the twenty-five items. Additional parameters are included at the end of the second string and filled with \u2018x\u2019 characters to reserve space for future use, removing the necessity of later modifying other macros utilizing the \u2018#define\u2019 statements when additional parameters are required in the second string. Such \u2018#define\u2019 statements can be used in a plurality of macros without parameter-order confusion and without creating multiple copies of bit field information that is difficult to maintain.","The \u2018macro\u2019 definition utilizes multiple parameters as provided by the \u2018#define\u2019 statement. In the above example, the macro is identified by the name \u2018BistPutField\u2019 at the start of the macro definition. This is followed by a directive, \u2018.MACRO\u2019, which is then followed by a list of twenty-seven parameters. The center twenty-five parameters are based on the same number and order of items specified by the \u2018#define\u2019 statement. The macro has one additional parameter, \u2018r\u2019, at the front, and a second additional parameter, \u2018t\u2019, at the end. The lines shown between the \u2018.MACRO\u2019 directive and the \u2018.ENDM\u2019 directive, in the above example, specify text to be substituted with macro expansion of the identifier \u2018BistPutField\u2019. In this example, \u2018depd\u2019 is a processor instruction that takes four parameters\u2014\u2018r\u2019, \u2018pos\u2019, \u2018len\u2019, and \u2018t\u2019\u2014that are substituted by parameters passed during invocation.","In the example, the \u2018BistPutField\u2019 macro is invoked with just three items. The first items, \u2018%r3\u2019, is a register identifier. The second item, \u2018L1_INDEX_CNTL_PERIOD\u2019, identifies the \u2018#define\u2019 statement; and the third item, \u2018arg4\u2019, identifies a parameter used by the processor instruction \u2018depd\u2019. The second item is replaced by the second string of the \u2018#define\u2019 statement such that the macro item list consists of the twenty-seven items. In one example of operation, the macro uses relevant items from the list to produce the following assembly code:\n\n","The \u2018#define\u2019 statement facilitates grouping of many common items into a single list. This single list assists in construction and maintenance of common items since the \u2018#define\u2019 statement may be used in a plurality of macro definitions and source code statements.",{"@attributes":{"id":"p-0030","num":"0033"},"figref":"FIG. 3","b":["110","78","68","110","54","55","60","74","78"]},"Process  starts at step  and continues with step . Step  creates high level test source code  to use pre-developed routines of BISTE API source code .","Step  expands any \u2018#define\u2019 statements and macros utilized in high level test source code  and BISTE API source code , in preparation for a compilation process in step .","In step , compiler  generates machine test code  from the expanded source code of step . Machine test code  contains BISTE API code , generated from BISTE API source code , and high level test code , generated from high level test source code . In step , compiler  also notifies the user of any errors detected during compilation of the source code.","Step  is a decision. If errors were detected during the compilation process of step , process  continues with step ; otherwise process  continues with step .","Step  provides for editing of high level test source code , to correct errors identified during the compilation process of step . Upon reading and fully appreciating this disclosure, one skilled in the art appreciates that the creation  of high level test source code  may involve an interactive editing process using editing software on workstation , for example. When source code  compiles without errors, process  continues with step .","Step  loads machine test code , generated in step , into test unit . Process  continues with step .","Step  executes machine test code  on processor . In one embodiment, machine test code  performs tests on memory cache  using BISTE . Machine test code  may also instruct BISTE  to set its registers  to map the redundant memory blocks to the faulty memory blocks.","In step , machine test code  accumulates results from BISTE  and transfers the results to test unit .","Step  generates a display or report of the results received from machine test code . Process  terminates at step .","The creation of high level test source code  and generation of machine test code  for testing memory cache  of processor  is simplified and expedited by use of BISTE API source code . Further, the use of \u2018#define\u2019 statements and macros in the source code (created during the development of BISTE API source code ) increases readability and maintainability of the processor's complex sequences used to control BISTE .","Changes may be made in the above methods, apparatus and systems without departing from the scope hereof. For example, OTP memory  may be other memory, e.g., erasable-programmable read only memory (\u201cEPROM\u201d), electrically erasable programmable read only memory (\u201cEEPROM\u201d), non-volatile random access memory (\u201cNVRAM\u201d), etc. It should thus be noted that the matter contained in the above description or shown in the accompanying drawings should be interpreted as illustrative and not in a limiting sense. The following claims are intended to cover all generic and specific features described herein, as well as all statements of the scope of the present method and system, which, as a matter of language, might be said to fall there between."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
