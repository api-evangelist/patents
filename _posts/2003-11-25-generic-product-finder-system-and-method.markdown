---
title: Generic product finder system and method
abstract: A generic product finder system that provides the capability of managing and performing searches on configurable products in a J2EE application. The generic product finder system includes a manager component for performing searches in response to a search query; a product component for persisting a plurality of product information and interacting with the manger component in conducting searches of the product information; a product metadata component that interacts with the manager component for defining a product; and a search configuration component that interacts with the manager component for constructing a set of search rules in a product search configuration. Internally, the product finder system represents products with a specification divided into parameters representing characteristics and optional attributes. This specification exists in a generic state by the use of Java objects. Multiple product specifications may co-exist and their information is persisted by the use of entity beans. The generic product also contains a session bean that acts as manager and single point-of-entry to the product information. Since the products are maintained in a generic form, search rules can be constructed and applied to the product set to perform complex queries.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07386562&OS=07386562&RS=07386562
owner: ABB Technology AG
number: 07386562
owner_city: Zurich
owner_country: CH
publication_date: 20031125
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The field the of the invention relates generally to data processing, and more specifically to methods and systems for managing and performing searches on configurable products.","Java 2 Platform, Enterprise Edition (J2EE) is a set of technologies and specifications developed by Sun Microsystems and supported by many computer and software vendors. J2EE is an environment for developing and deploying enterprise applications. The J2EE platform includes a set of services, application programming interfaces and protocols that provide the functionality for developing multi-tiered, web-based applications.","J2EE applications are made up of components. A J2EE component is a self-contained, functional software unit that is assembled into a J2EE application with its related classes and files and that communicates with other components. The J2EE specification defines the following J2EE components: (1) application clients and applets that run on the client; (2) Java Servlet and JavaServer Pages (JSP) technology components that run on the server; and (3) Enterprise JavaBeans (EJB) components that run on the server.","J2EE components are assembled into a J2EE application verified to be well-formed (i.e., syntactically correct) and in compliance with the J2EE specification, and deployed to production, where they are run and managed by the J2EE server. Deployment is the process whereby software is installed into an operational environment. Deployment descriptors (DDs) are XML files provided with each application that describes how the application should be deployed. DDs are used by the J2EE runtime execution environment to provide and enforce the quality of service attributes described in the DD.","An enterprise bean is a component that implements a business task or business entity and resides in an EJB container, either as an entity bean, a session bean, or a message-driven bean. A container is a standardize runtime environment that provides specific component services. An entity bean represents persistent data maintained in a database. An entity bean can manage its own persistence or delegate this function to its container. An entity bean is identified by a primary key. A primary key in an EJB is the subset of its attributes that are guaranteed to be unique. Persistence mechanisms in EJB containers are closely tied to databases. Entity beans map cleanly to tables. Each column maps to an attribute and each row maps to an entity. If the container hosting the entity bean crashes, the entity bean, its primary key and any remote references survive the crash. A message-driven bean is an asynchronous message consumer. A message-driven bean has no state for a specific client, but its instance variables may contain state across the handling of client messages, including an open database connection and an object reference to a EJB object. A client accesses a message-driven bean by sending messages to the destination for which the bean is a message listener. A session bean is created by the client and usually exists only for the duration of a single client-server session. A session bean performs operations such as calculations or accessing a database for the client. Although a session bean may be transactional, it is not recoverable should a system crash occur. Session bean objects can be either stateless or can maintain conversational state across methods and transactions. If a session bean manages state, then the EJB container manages this state if the object must be removed from memory. However, the session bean object itself must manage its own persistent data.","Extensible Markup Language (XML) enables definition of the tags (markups) needed to identify the content, data, and text in XML documents. It differs from HTML, in that HTML has fixed tags that deal mainly with style or presentation. XML tags use angle brackets as delimiters and identify the data rather than specifying how to display it. The XML approach is to wrap each data item in start\/end tags; i.e., <start tag name> data <end tag name>. XML documents are well-formed with every tag having an identical closing tag, and with all tags completely nested. Attributes are bundled in with the start tag and take the form attribute-name=\u201cattribute-value\u201d. XML documents undergo a transformation into a language with style tags under the control of a stylesheet before it can be presented by a browser or other presentation mechanism. Typically, XML is transformed into HTML for presentation. J2EE deployment descriptors are expressed in XML with schemas defining allowed elements.","XML Schema Definition (XSD) specifies a formal description for the elements in an XML document. An XML schema represents the interrelationship between the attributes and elements of an XML object. The XSD description can be used to verify that each item of content in a document adheres to the description of the element in which the content is to be placed. XSD is written in XML and therefore does not require intermediate processing by a parser. Elements are defined within a set of tags as in XML or HTML. XSD is also self-documenting. XML schema provide two basic kinds of datatypes: primitive and derived. A primitive datatype is not defined in terms of other types. Examples of primitive datatypes are string, Boolean, float, double, decimal, binary, ID, IDREF. A derived datatype is defined in terms of existing datatypes. Examples of derived datatypes built into the XML schema are language, integer, date, time.","An XML schema includes a preamble followed by declarations. The preamble is a group of at least three attributes within the <schema> element. The different possible attributes are name, ref, type, use, value, id and form. The declarations allow the description of datatypes, element types, element attributes and content models. XML schema provide two types of datatype definitions. Simple definitions are used to create derived datatypes; complex definitions are used to describe content models. A simple type definition is a set of constraints on the value space and lexical space of a datatype. A complex type definition is a set of attribute declarations and a content type that pertain to the attributes and children of the element that is being specified. An <attribute> declaration associates an attribute name with a specific simple datatype. An <element> declaration provides a description that can be used for validation, provides value constraints, establishes constraining relationships between related elements and attributes. An element may contain annotation elements, datatype declarations (simple of complex), and related child elements. An element has a number of different possible attributes including name, ref, type, minOccurs, maxOccurs, default, fixed and id. The attributes minOccurs and maxOccurs describe the cardinality of child elements. The attribute minOccurs represents the minimum number of occurrences allowed; maxOccurs represents the maximum number of occurrences allowed with the default value the same as the value of minOccurs if no value is specified.","The generic product finder system is a Java 2 Platform, Enterprise Edition (J2EE) component that provides the capability of managing and performing searches on configurable products. In the context of the present invention, configurable products includes any type of product that can be described in a specification and stored electronically in a computer database. Configurable products include any product that has been configured using the techniques described herein. Internally, the product finder represents products with a specification divided into parameters representing characteristics and optional attributes. This specification exists in a generic state by the use of Java objects.","In an exemplary embodiment, the generic product finder system for managing and performing searches on configurable products in a J2EE application includes a manager component for performing searches in response to a search query; a product component for persisting a plurality of product information and interacting with the manger component in conducting searches of the product information, a product metadata component tat interacts with the manager component for defining a product; and a search configuration component that interacts with the manager component for constructing a set of search rules in a product search configuration, wherein the set of search rules include weight values to apply to product information for ordering of partial matches in determining products to identify as a result of the search performed.","In an exemplary embodiment, a method for managing and performing searches on configurable products in a J2EE application includes: (1) creating a manager component that conducts searches in a response to a search query; (2) generating a product metadata component that interacts with the product manager component to define a generic product specification; (3) persisting a plurality of product information that interacts with the manager component in conducting searches of the product information; (4) generating a search configuration component that interacts with the manager component in conducting searches for product information that matches a criterion in the search query; constructing a set of search rules to use in searching the plurality of product information; and applying weight values to product information to order partial matches in determining products to identify as a result of the search performed.","A computer program product for managing and performing searches on configurable products, the computer program product comprising:","a recording medium;","program instructions recorded on the recording medium for conducting searches in response to a search query;","program instructions recorded on the recording medium for defining a product specification;","program instructions recorded on the recording medium for persisting a plurality of product information and interacting with the program instructions for conducting searches for use in conducting searches of the product information for matching products;","program instructions recorded on the recording medium for generating a search configuration and interactive with the program instructions for conducting searches for product information that match a criterion in the search query;","program instructions recorded on the recording medium for defining a search configuration for each type of product; and","program instructions recorded on the recording medium for applying weight values to product information to order partial matches in determining products to identify as a result of the search performed.","The following description of the present invention is provided as an enabling teaching of the invention in its best, currently known embodiment. Those skilled in the relevant art will recognize that many changes can be made to the embodiment described, while still obtaining the beneficial results of the present invention. It will also be apparent that some of the desired benefits of the present invention can be obtained by selecting some of the features of the present invention without using other features. Accordingly, those who work in the art will recognize that many modifications and adaptations to the present invention are possible and may even be desirable in certain circumstances, and are a part of the present invention. Thus, the following description is provided as illustrative of the principles of the present invention and not in limitation thereof, since the scope of the present invention is defined by the claims.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 1","b":["10","20","50","30","40","30","60","70"]},"The product finder system  represents products by a set of parameters (also known as the \u201cspecification\u201d) that are divided into characteristics and optional attributes. Internally, hashmaps are used to store the specification for a product instance as Java objects (products ). The product specification is a set of information whose type and semantics are unknown. A separate set of product metadata  is to be configured in XML. This XML metadata  is used by the product finder system  when inspecting the contents of a product instance (products ). The XML metadata  allows for deciphering this generic information into something concrete to work with. Multiple types of products may be defined in the XML and can co-exist in the persisted data . In their natural state there is no distinction among persisted products .","Now that generic products  can be stored and maintained in the product manager , complex queries need to be constructed for retrieving products. By complex queries, it is meant that behavior other than a simple \u201cis equal\u201d on the entire product can be initiated. The complex queries are determined by search rules, which may include any of the following, alone or in combination:\n\n","In the above list of search rules, granularity of match behavior defined at a parameter level refers to the fact that the search rules can be configured on the smallest granularity of a parameter, as opposed to rough granularity on the entire search specification. For example, one search configuration may indicate that a specific parameter: (1) has irregular data normalized, (2) is required to be matched for inclusion in partial match search results, (3) is given a default value to match if a value is not specified in a search query, (4) is considered a match if the numeric value does not exceed a threshold, and\/or (5) has a low impact weight for intelligent ordering of partial matches.","These complex search rules (search configuration ) can be defined in XML, and multiple sets of search rules can be applied at different times. The search rules combine with the product metadata  to determine matches  between a query specification  (supplied by an external query to the product finder) and the set of persisted product information .","The characteristics that distinguish the generic product finder system  are:\n\n",{"@attributes":{"id":"p-0035","num":"0043"},"figref":"FIGS. 2A-2D","b":["20","30","20","50","30","10"]},"The product schema definition in  includes an annotation element  that describes the schema (e.g., Product Specification Schema) and comments  (delimited by <! comment>) that indicate product characteristics are divided into parameters and accessories. Parameters are used to define core characteristics of the product. Accessories are used to define add-on optional items. Each attribute is defined by a series of three space-separated values. The first element in each line is the name of the attribute; the second element indicates the type of data; and the third element determines the attribute's default value, if any, and indicates whether or not the attribute is required. A \u201crequired\u201d attribute value must be specified in the document; an \u201coptional\u201d value need not be specified; a \u201cdefault\u201d value is the value to use if a value is not specified in the document. The product specification schema for \u201cparameter type\u201d is indicated at  in . It includes descriptions of attributes  for the \u201cparameter\u201d element with a list of enumeration values. Also provided in the schema for the \u201cparameter\u201d element are restricted attributes  with a list of enumeration values. The product specification schema for \u201caccessory type\u201d is indicated at  in . It includes descriptions of attributes  for the \u201caccessory\u201d element with a list of enumeration values. Also provided in the schema for \u201caccessory\u201d element are restricted attributes  () with a list of enumeration values.",{"@attributes":{"id":"p-0037","num":"0045"},"figref":["FIGS. 3A-3C","FIG. 3A","FIGS. 3A-3B","FIG. 3B","FIG. 3B","FIGS. 3B-3C","FIG. 3C"],"b":["300","302","304","306","308","310","312","314"]},{"@attributes":{"id":"p-0038","num":"0046"},"figref":["FIGS. 4A-4C","FIGS. 4A-4B","FIGS. 4B-4C"],"b":["400","410","420"]},{"@attributes":{"id":"p-0039","num":"0047"},"figref":["FIGS. 5A-5B","FIG. 5A","FIG. 5B"],"b":["500","502","504","506","508","510"]},{"@attributes":{"id":"p-0040","num":"0048"},"figref":["FIGS. 6A-6B","FIGS. 6A-6B","FIG. 6B"],"b":["610","620"]},"It is important to note that although the present invention has been described in the context of a fully functioning data processing system, those skilled in the art will appreciate that the mechanisms of the invention are capable of being distributed in the form of computer program instructions in a variety of forms which when executed on the data processing system perform the methods described herein. The present invention applies regardless of the type of signal bearing medium used to carry out the distribution. Examples of signal bearing mediums include nonvolatile hard-coded mediums such as read-only memories, recordable type mediums such as floppy disks, hard disk drives and CD-ROMS, and transmission type mediums such as digital and analog communication links.","While the invention has been particularly shown and described with reference to a preferred embodiment thereof, it will be understood by those skilled in the art that various other changes in form and detail may be made without departing from the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF DRAWINGS","p":["The invention is better understood by reading the following detailed description of the invention in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIGS. 2A-2D"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIGS. 3A-3C"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 4A-4C"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 5A-5B"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 6A-6B"}]},"DETDESC":[{},{}]}
