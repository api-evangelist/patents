---
title: System and method for enterprise authentication
abstract: A method for adaptively authenticating a subject, said method adapted to cooperate with a security provider interface hierarchy, said method comprising the steps of providing for the implementation of an authentication interface adapted to extend and implement at least a portion of the security provider hierarchy, providing for the authentication of the subject when so directed by the authentication interface, and providing for the association of a signed principal with the subject upon the successful authentication of the subject.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07017051&OS=07017051&RS=07017051
owner: BEA Systems, Inc.
number: 07017051
owner_city: San Jose
owner_country: US
publication_date: 20030224
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCES","COPYRIGHT NOTICE","FIELD OF THE DISCLOSURE","BACKGROUND","DETAILED DESCRIPTION"],"p":["This application is related to the following co-pending application which is hereby incorporated by reference in its entirety: SYSTEM AND METHOD FOR AUTHENTICATING A SUBJECT, U.S. Patent Application Serial No. 10\/373,533 Inventor: Paul Patrick, filed on Feb. 24, 2003.","This application is related to the following publications which are each hereby incorporated by reference in their entirety: (Release 7.0, Aug. 30, 2002); (Release 7.0, Jun. 28, 2002).","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","The present invention disclosure relates to enterprise authentication, and in r, the Java\u2122 Authentication and Authorization Service.","Heterogeneous computer systems typically require multiple authentication sms. For example, in order to access a particular enterprise application, a user e to login to their workstation, a network, and finally the application itself. This process is cumbersome since it requires the user to interact with different authentication mechanisms, each of which may require the user to remember a unique user name and password. An additional drawback is that each authentication mechanism may be tightly integrated with the mechanism used to obtain authentication information from the user. This merger of the two mechanisms makes it difficult to integrate new authentication techniques.","The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. It should be noted that references to \u201can\u201d or \u201cone\u201d embodiment in this disclosure are not necessarily to the same embodiment, and such references mean at least one.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},"JAAS is a component of the Java\u2122 programming language environment and is available from Sun Microsystems, Inc. of Santa Clara, Calif. In one embodiment, JAAS can be used to authenticate users. JAAS implements a modular authentication framework where applications or processes requiring authentication services are kept logically separate from those services. This permits changes to authentication technologies without requiring in kind modifications to applications or processes.","Referring to , JAAS authentication is comprised of a LoginContext application programming interface (API) front-end  and a back-end including one or more authentication (or login) modules \u2013, connected via a LoginModule service provider interface (SPI) . In one embodiment, an interface can be a convention for communication between software and\/or hardware components. In another embodiment, an interface can be a class definition in an objected oriented programming language, such as Java\u2122. An application program\/process  can access authentication services through the API  while authentication module providers write to (or \u201cplug\u201d into) the application-independent SPI . In one embodiment, API  and SPI  can be implemented as the following Java\u2122 classes:",{"@attributes":{"id":"p-0018","num":"0017"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public final class LoginContext {"]},{"entry":[{},"\u2003\u2003public LoginContext(String name) { }"]},{"entry":[{},"\u2003\u2003public void login( ) { }"]},{"entry":[{},"\u2003\u2003public void logout( ) { }"]},{"entry":[{},"\u2003\u2003public Subject getSubject( ) { }"]},{"entry":[{},"}"]},{"entry":[{},"public interface LoginModule {"]},{"entry":[{},"\u2003\u2003boolean login( );"]},{"entry":[{},"\u2003\u2003boolean commit( );"]},{"entry":[{},"\u2003\u2003boolean abort( );"]},{"entry":[{},"\u2003\u2003boolean logout( );"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"LoginContext  can consult configuration  to determine which specific login modules \u2013 to invoke in performing authentication of a subject. Depending on the requirements of a particular login module, different types of proof (e.g., user name, password, biometric data such as a finger print, retina scan, voice print, etc.) may be required for authentication. In some cases, a login module must communicate with the source of an authentication request to obtain such information. In one embodiment, a JAAS CallbackHandler interface (not shown) can be used to provide this information in an application independent fashion. For example, application  can implement the CallbackHandler interface and provide it to each login module via the LoginContext . Login modules can thereafter use the CallbackHandler to gather any required proof from the application.","The configuration  for a given application  can specify which login modules are required and which are optional. The required and optional login modules for a given application comprise an authentication stack. Stacking allows multiple authentication mechanisms to be supported (e.g., in a heterogeneous environment). Referring to , one stack is comprised of modules \u2013 and another is comprised of modules  and . By way of a non-limiting illustration, module  may authenticate a subject for a given workstation, module  may authenticate the subject for a given network, and finally module  may authenticate the subject for an enterprise application. In this example, configuration  would specify that all three are required for application . Upon successful authentication, each login module associates one or more principals with the subject.","In one embodiment, the login method of the LoginContext can perform multiple authentication in two phases. In the first phase, each login module is invoked to perform authentication of the subject. If the required login modules succeed in authentication, the second phase invokes each login module's commit method causing any relevant principals to be associated with the subject. In one embodiment, if either phase fails, the LoginContext can invoke the abort method for each login module and thus role back the authentication.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2","b":"200"},"The WLSS framework is not limited to authentication. It has an open, general-purpose architecture that allows security vendors to provide new services (e.g., authorization, role mapping, auditing, principal validation, etc.) that plug into WLSS through a set of Security Service Provider Interfaces (SSPI's) . In one embodiment, SSPI's are available for Authentication, Authorization, Auditing, Role Mapping, Keystore and Principal Validation. WLSS also includes default security provider implementations  for these SSPI's, including JAAS-based Authentication  and Principal Validation . In one embodiment, an interface can be implemented in the Java\u2122 programming language or other paradigms that support inheritance of interfaces.","To provide open and extensible management of security services, in one embodiment WLSS implements Java\u2122 Management Extensions (JMX). JMX was developed by Sun Microsystems, Inc. and other companies. JMX provides a tiered architecture for integrating managed resources and the applications that manage them. Each managed resource includes a set of attributes that can be configured and monitored for management purposes. Theses attributes are exposed through one or more managed beans (MBeans). The bottom-most tier is the instrumentation level. It allows management of a resource through one or more MBeans. There is a direct mapping between Java\u2122 Beans and MBeans, thus allowing for straightforward implementation of management capabilities if a resource happens to be a Java\u2122 Bean. The middle tier is the agent level. Agents provide for communicating with one or more MBeans synchronously or asnycronously (e.g., polling). The upper-most tier is the management level. This level provides user-accessible management components and tools that consolidate the services of agents.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3","ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["Determine the type of custom security provider to create (e.g., authentication).","Identify the appropriate SSPI's to implement in order to create the runtime class(es) for the security provider.","Identify the appropriate MBean SSPI's to implemented in order to manage the security provider run-time class.","Implement the SSPI's by providing implementations for each of their methods. The methods should contain specific algorithms for the security services offered by the security provider."]}}}},{"@attributes":{"id":"p-0026","num":"0029"},"figref":"FIG. 3","b":["202","204","304"]},{"@attributes":{"id":"p-0027","num":"0030"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["METHOD","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["initialize","Initializes the security provider. Takes as a parameter"]},{"entry":["(ProviderMBean)","a ProviderMBean. This parameter allows the security"]},{"entry":[{},"provider to be managed in the WLSS framework by"]},{"entry":[{},"passing configuration information contained in the"]},{"entry":[{},"MBean to the provider."]},{"entry":["GetDescription","Returns a text description of the security provider. For"]},{"entry":[{},"example, \u201cWebLogic\u2009\u00ae Authentication provider,"]},{"entry":[{},"version 1.0\u201d."]},{"entry":["Shutdown","Terminates the security provider."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The SecurityProvider interface  is extended by an AuthenticationProvider interface . The AuthenticationProvider interface exposes the services of an authentication provider implementation to the WLSS framework such that the authentication provider can be manipulated (e.g., initialized, started, stopped, etc.) by the framework. In one embodiment, the AuthenticationProvider interface includes the following methods:",{"@attributes":{"id":"p-0029","num":"0032"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["METHOD","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["getLoginModuleConfiguration","Returns the App ConfigurationEntry"]},{"entry":[{},"for this Authentication provider's"]},{"entry":[{},"JAAS LoginModule. The"]},{"entry":[{},"AppConfigurationEntry is a"]},{"entry":[{},"configuration specific to this"]},{"entry":[{},"Authentication provider that is needed"]},{"entry":[{},"to properly execute login authentication"]},{"entry":[{},"in a security realm. In one embodiment,"]},{"entry":[{},"a security realm contains a set of"]},{"entry":[{},"security configuration settings, including"]},{"entry":[{},"a set of security providers to use (for"]},{"entry":[{},"example, for authentication and"]},{"entry":[{},"authorization)."]},{"entry":[{},"The AppConfigurationEntry parameter"]},{"entry":[{},"represents a single LoginModule"]},{"entry":[{},"entry configured for an application."]},{"entry":[{},"In one embodiment, each respective"]},{"entry":[{},"AppConfigurationEntry can contain"]},{"entry":[{},"a LoginModule name, a control flag"]},{"entry":[{},"(specifying whether this LoginModule"]},{"entry":[{},"is REQUIRED, REQUISITE,"]},{"entry":[{},"SUFFICIENT, or OPTIONAL), and"]},{"entry":[{},"LoginModule-specific options."]},{"entry":["getPrincipalValidator","Returns this Authentication provider's"]},{"entry":[{},"associated Principal Validation provider."]},{"entry":[{},"The Principal Validator interface 208"]},{"entry":[{},"defines the methods that custom Principal"]},{"entry":[{},"Validation providers can implement to"]},{"entry":[{},"support principal trust relationships within"]},{"entry":[{},"the context of the WLSS framework."]},{"entry":[{},"In one embodiment, Principal Validation"]},{"entry":[{},"providers can be used with Authentication"]},{"entry":[{},"providers to provide additional security"]},{"entry":[{},"protections for the principals associated"]},{"entry":[{},"with a subject."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In one embodiment, the SecurityProvider and AuthenticationProvider interfaces are implemented by an AuthenticationImp class . In another embodiment, if there were additional SSPI's to implement (i.e., not in the SecurityProvider hierarchy), the AuthenticationImp class could act as a factory for generating these. A factory allows objects to be created dynamically. For example, in one embodiment the AuthenticationProvider  can use a factory to instantiate a LoginModule object  that implements the JAAS LoginModule interface  and thereafter use the object to perform JAAS authentication.","In one embodiment, an MBean class can be implemented to manage the AuthenticationImp class . The ProviderMBean interface  is the base MBean for all security managers and as such includes attributes common to all. All attributes and operations that are specified in an implemented MBean extend up the class hierarchy and are exposed in the ProviderMBean interface. This allows a JMX-compatible administrative tool to access and configure these attributes which in one embodiment are provided to the AuthenticationImp  via the initialize method of the SecurityProviderInterface. In one embodiment, the ProviderMBean has the following methods:",{"@attributes":{"id":"p-0032","num":"0035"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["METHOD","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["getProviderClassName","Returns the name of the Java\u2009\u2122 class used"]},{"entry":[{},"to load the security provider. Each security"]},{"entry":[{},"provider can implement a runtime class"]},{"entry":[{},"which extends a specific interface in WLSS."]},{"entry":[{},"The security provider's MBean can set the"]},{"entry":[{},"default value of this attribute to a fully qualified"]},{"entry":[{},"classname of the security provider's"]},{"entry":[{},"runtime class."]},{"entry":["GetDescription","Returns a string that describes this security"]},{"entry":[{},"provider. Each security provider's MBean can"]},{"entry":[{},"set the default value of this attribute."]},{"entry":["GetVersion","Returns the security provider's version. Each"]},{"entry":[{},"security provider's MBean can set the default"]},{"entry":[{},"value of this read-only attribute to a string that"]},{"entry":[{},"specifies the version of the provider (eg. 7.3.04)."]},{"entry":["getRealm","Returns the RealmMBean that contains"]},{"entry":[{},"this security provider."]},{"entry":[{},"A RealmMBean is an MBean that represents"]},{"entry":[{},"configuration attributes for a security realm."]},{"entry":[{},"A security realm contains a set of security"]},{"entry":[{},"configuration settings, including a set of"]},{"entry":[{},"security providers to use (for example, for"]},{"entry":[{},"authentication and authorization)."]},{"entry":[{},"When a WebLogic\u2009\u00ae Server boots, it"]},{"entry":[{},"locates and uses a default security realm. If"]},{"entry":[{},"an application specifies a different security"]},{"entry":[{},"realm, then that security realm is used instead."]},{"entry":["setRealm","Set the realm that contains this security provider."]},{"entry":"(RealmMBean)"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In one embodiment, the ProviderMBean interface  can be extended by the AuthenticationProviderMBean interface . The AuthenticationProviderMBean is the base MBean for all MBean implementations that manage Authentication providers. In one embodiment, the interface can be a marker, that is, it has no methods other than those it inherits from ProviderMBean. In another embodiment, the AuthenticationProviderMBean can supply methods specific to authentication providers.","In one embodiment, the AuthenticationProviderMBean interface  can be extended by the AuthenticatorMBean interface . The AuthenticatorMBean is the SSPI MBean that an authentication provider with login services can extend. This MBean provides a ControlFlag to determine whether the authentication provider is a required, requisite, sufficient or an optional part of a stacked login sequence. In one embodiment, the interface includes the following methods:",{"@attributes":{"id":"p-0035","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["METHOD","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["GetControlFlag","Returns the control flag associated with this provider."]},{"entry":[{},"The control flag determines how the framework uses"]},{"entry":[{},"the Authentication provider."]},{"entry":[{},"A REQUIRED value requires this Authentication"]},{"entry":[{},"provider to succeed. Regardless of whether it"]},{"entry":[{},"succeeds, in one embodiment an authentication"]},{"entry":[{},"proceeds to other Authentication providers that have"]},{"entry":[{},"been configured as part of the login stack."]},{"entry":[{},"A REQUISITE value requires this Authentication"]},{"entry":[{},"provider to succeed. If it succeeds, authentication"]},{"entry":[{},"proceeds to other Authentication providers. If it fails,"]},{"entry":[{},"control immediately returns to the application"]},{"entry":[{},"(authentication does not proceed)."]},{"entry":[{},"A SUFFICIENT value does not require this"]},{"entry":[{},"Authentication provider to succeed. If it succeeds,"]},{"entry":[{},"control immediately returns to the application"]},{"entry":[{},"(authentication does not proceed to other Authenticaion"]},{"entry":[{},"providers). If it fails, authentication proceeds to other"]},{"entry":[{},"Authentication providers that have been configured as"]},{"entry":[{},"part of the login sequence."]},{"entry":[{},"An OPTIONAL value does not require this"]},{"entry":[{},"Authentication provider to succeed. Regardless of"]},{"entry":[{},"whether it succeeds, in one embodiment authentication"]},{"entry":[{},"proceeds to other Authentication providers that have"]},{"entry":[{},"been configured as part of the login sequence."]},{"entry":["setControlFlag","Determines how the login sequence uses the"]},{"entry":["(integer)","Authentication provider."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"AuthenticatorMBeanImp  implements the AuthenticatorMBean interface. AuthenticationImp  and AuthenticatorMBeanImp  are run-time security provider implementations of their respective interface hierarchies. Together, both the runtime class and its associated MBean form a \u201csecurity provider.\u201d In one embodiment, when a WebLogic\u00ae Server instance starts, the WLSS framework locates the MBean (AuthenticatorMBeanImp ) associated with the security provider (AuthenticationImp ). The framework provides the AuthenticatorMBeanImp  to an instance of the security provider AuthenticationImp , which uses the MBean to obtain its configuration information. In another embodiment, configuration information could be obtained from another source (e.g., a database, file or a process).",{"@attributes":{"id":"p-0037","num":"0040"},"figref":"FIG. 4","b":["400","400","402","404","406","310","408","314","206"]},"Authentication providers also remember, transport, and make identity information available to various components of a system (via subjects) when needed. JAAS utilizes subjects as containers for authentication information, including principals. During the authentication process, a principal validation provider  affords additional security protection for principals associated with a subject by signing and verifying the authenticity of those principals. In one embodiment, the signing algorithm can be based on mechanism for message authentication using a cryptographic or other function to generate a code as a function of the principal and a secret, shared key. A change to the principal can thus be detected if the function is applied again, but the resulting value no longer matches the originally computed code.","In one embodiment, the signing function can be implemented using an HMAC hashing-based algorithm. Assume that H denotes a hash function that takes an input string of any length and produces a hashed output. Let Text denote information about the principal to be signed (e.g., the name of the principal, etc.), and let K denote a secret key. K should not be larger than the size of the hashing block size as determined by H (e.g., 64). If K is shorter than the block size, it should be extended by zeroes until it equals the block size. Let ipad represent the byte 0\u00d736 repeated 64 times, and opad represent the byte 0x5C repeated 64 times. Thus, in one embodiment, the authentication code can be calculated as follows:\n\n(Text)=(pad,(pad, Text)).\n","First, K and ipad are XOR'd (bitwise exclusive-OR) together. H is applied to this result as prepended to Text. The output of H is then appended to the XOR of K and opad. This result is then passed to a second invocation of H to produce the authentication code.","In one embodiment, verification of principal signatures takes place during the WebLogic\u00ae Server's demarshalling of remote method invocation client requests. The authenticity of the subject's principals can also be verified when making authorization decisions, such as when a client is attempting to access a resource.","The PrincipalValidator interface  defines the methods that Principal Validation providers can implement to support principal trust relationships within the context of the WebLogic\u00ae Server environment. In one embodiment, a PrincipalValidator's methods can include:",{"@attributes":{"id":"p-0043","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["METHOD","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["validate (Principal)","Verifies that the principal has not been altered"]},{"entry":[{},"since it was signed. Returns TRUE if the principal"]},{"entry":[{},"has been validated or FALSE if the principal"]},{"entry":[{},"has not been validated."]},{"entry":["sign (String)","Signs the principal to assure trust. Returns TRUE"]},{"entry":[{},"if the principal has been signed, FALSE if the"]},{"entry":[{},"principal has not been signed. The sign method"]},{"entry":[{},"should be a secret algorithm that malicious"]},{"entry":[{},"individuals cannot easily recreate. It can include"]},{"entry":[{},"an algorithm within the sign method itself, have"]},{"entry":[{},"the sign method call out to a server for a token"]},{"entry":[{},"it should use to sign the principal, or implement"]},{"entry":[{},"some other way of signing the principal."]},{"entry":["getPrincipalBaseClass","Gets the base Principal class validated and signed"]},{"entry":[{},"by this Principal Validation provider."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0044","num":"0047"},"figref":["FIG. 5","FIG. 5"],"b":["502","504","510","514","516","512","512","518","504","514","506","508","516","510","518"]},"A JAAS-compliant LoginModule  is a component of a WLSS authentication provider. LoginModules authenticate subjects within a security realm and populate them with principals. In one embodiment, LoginModules can also verify the proof material submitted (e.g., a user's password). If there are multiple authentication providers configured in a security realm, each authentication provider's LoginModule will store principals within the same subject. Therefore, if a principal that represents a WebLogic\u00ae Server user (e.g., an implementation of the WLSUser interface) named \u201cJoe\u201d is added to the subject by one authentication provider's LoginModule, any other authentication provider in the security realm should be referring to the same person when they encounter \u201cJoe\u201d. However, it is acceptable for a another authentication provider's LoginModule to add a principal of a type other than WLSUser with the name \u201cJoe\u201d.","LoginModules can be written to handle a variety of authentication mechanisms, including username\/password combinations, smart cards, biometric devices, and so on. In one embodiment, a LoginModule can implement the javax.security.auth.spi.LoginModule interface, which is based on JAAS and uses a subject as a container for authentication information. The LoginModule interface enables different kinds of authentication technologies for use with a single application, and the WLSS framework is designed to support multiple LoginModule implementations for multipart authentication. In one embodiment, the relationship between LoginModules and Authentication providers is one-to-one. In other words, to have a LoginModule that handles retina scan authentication and a LoginModule that interfaces to a hardware device like a smart card, two Authentication providers are required, each of which includes an implementation of the LoginModule interface.",{"@attributes":{"id":"p-0047","num":"0050"},"figref":"FIG. 6","b":["600","604","608","614","608","610","612","614"]},"Looking at authentication provider , its authentication succeeded as indicated by the \u201cYes\u201d in column . Therefore, a principal p was created as shown in column . The principal p is associated with the subject, as indicated in column . This authentication provider's configuration control flag was set to \u201cRequired\u201d, as indicated in column . The authentication performed by authentication provider  failed, as indicated by the \u201cNo\u201d in column . Thus, p remains in the subject. Since the control flag setting is \u201cOptional\u201d, authentication will nonetheless proceed to the next provider in the stack. If the control flag for authentication provider  had been set to \u201cRequired\u201d, however, the failure would have caused the entire process to fail. Also, if the subject had not been authenticated by the provider  or , the entire authentication process would have failed. If the authentication process had failed in any of these ways, all three LoginModule authentications would have been rolled back and the subject would not contain any principals. Authentication provider  had a successful authentication, and thus principal p is also added to the subject.",{"@attributes":{"id":"p-0049","num":"0052"},"figref":"FIG. 7","b":"3","ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":["1. A client-side application obtains authentication information from a user or process (e.g., user name, password and uniform resource locator). The mechanism by which this occurs can be different for each type of client.","2. The application creates a CallbackHandler containing the authentication information. In one embodiment, there are three types of CallbackHandlers: NameCallback, PasswordCallback, and TextInputCallback, all of which can reside in the javax.security.auth.callback package. The NameCallback and PasswordCallback return the username and password, respectively. TextInputCallback can be used to access the data users enter into any additional fields on a login form (that is, fields other than those for obtaining the username and password).\n    \n    ","3. The WebLogic\u00ae Server remote method invocation (RMI) container calls into the WLSS framework. The client-side CallbackHandler containing authentication information is provided to the WLSS framework.","4. In one embodiment, for each of the configured authentication providers the WLSS framework creates a CallbackHandler containing the username, password, and URL that was passed in. (In one embodiment, these are internal CallbackHandlers created on the server-side by the framework, and are not related to the client's CallbackHandler.)","5. The framework calls the LoginModule associated with the Authentication provider (i.e., the LoginModule that is specifically designed to handle the authentication information). The LoginModule attempts to authenticate the client using the authentication information.","6. If the authentication is successful, the following occurs:\n    \n    "]}},"One embodiment may be implemented using a conventional general purpose or a specialized digital computer or microprocessor(s) programmed according to the teachings of the present disclosure, as will be apparent to those skilled in the computer art. Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure, as will be apparent to those skilled in the software art. The invention may also be implemented by the preparation of integrated circuits or by interconnecting an appropriate network of conventional component circuits, as will be readily apparent to those skilled in the art.","One embodiment includes a computer program product which is a storage medium (media) having instructions stored thereon\/in which can be used to program a computer to perform any of the features presented herein. The storage medium can include, but is not limited to, any type of disk including floppy disks, optical discs, DVD, CD-ROMs, microdrive, and magneto-optical disks, ROMs, RAMs, EPROMs, EEPROMs, DRAMs, VRAMs, flash memory devices, magnetic or optical cards, nanosystems (including molecular memory ICs), or any type of media or device suitable for storing instructions and\/or data.","Stored on any one of the computer readable medium (media), the present invention includes software for controlling both the hardware of the general purpose\/specialized computer or microprocessor, and for enabling the computer or microprocessor to interact with a human user or other mechanism utilizing the results of the present invention. Such software may include, but is not limited to, device drivers, operating systems, execution environments\/containers, and user applications.","The foregoing description of the preferred embodiments of the present invention has been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations will be apparent to the practitioner skilled in the art. Embodiments were chosen and described in order to best describe the principles of the invention and its practical application, thereby enabling others skilled in the art to understand the invention, the various embodiments and with various modifications that are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
