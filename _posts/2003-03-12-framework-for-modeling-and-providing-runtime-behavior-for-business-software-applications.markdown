---
title: Framework for modeling and providing runtime behavior for business software applications
abstract: A business software framework supports business software applications. The framework includes a class library component that has a plurality of class libraries of business components, including business entities and business processes. The framework also includes an application framework that has a programming model, the programming model providing a set of application services for relating the business components to one another, and for providing desired services relative to the business components in order to obtain the business application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07577934&OS=07577934&RS=07577934
owner: Microsoft Corporation
number: 07577934
owner_city: Redmond
owner_country: US
publication_date: 20030312
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS","Computing Environment Overview","High Level Software Environment Overview","Business Framework Overview","Programming Model Subsystem  and Process Execution Subsystem ","Customization of Processes","Context for Customization","Customization of Entities","Metadata Subsystem  and Metadata Customization","Execution Tiers in Deployment Subsystem ","Data Access Subsystem ","Entity  Containment Hierarchy","Entity Keys in Entities ","Class Key","Foundation Services ","Role-based Security Subsystem ","Reporting and Query Services Subsystem ","User Interface Subsystem "],"p":["The present invention relates to business software solutions. More specifically, the present invention relates to a platform that supports authoring and running business software applications.","Integrated business solutions typically include multiple functional products that support business segments and interact with enterprise hub and spoke networks. Such products include software applications that run financial information, human resource management, customer relationship management, professional services automation, distribution, supply chain management, and more.","In the past, achieving such integrated business solutions has been very difficult. Prior business applications have primarily focused on, and been limited to, business process automation of internal and back office functions. While this type of internal efficiency is important, it does not address relationships outside the business with individuals who are customers, suppliers, partners, financiers and employees.","To date, only the largest organizations have extended business process automation outside of their enterprise to these constituents. The cost and complexity of implementing these solutions has simply been prohibitive, particularly for the small and medium sized organizations.","One reason that the cost is so high is that one approach to designing and marketing computer software-related products is to focus on horizontal functionality such that the product is broadly applicable across large industry segments, and across many different countries. Such a system may also desirably promote an after market to meet the unique needs of specific vertical target markets and specific companies. Similarly, the product may desirably promote a customer's ability to change or customize the product to their individual needs. Such needs may be, for example, the requirement that different business products operate in an integrated fashion, even though they are from different vendors. This often requires the applications to be modified or customized so that they are compatible with one another.","If the product cannot be extended to meet the unique needs of a customer, it essentially requires a customer to change its business to match the software which the customer has just purchased. Of course, these types of systems are resisted by customers, since changes to business activities can be costly and time consuming.","There are a number of different techniques which have been conventionally used in order to enable a system to be customized. Such conventional techniques include, for example, source code modification. This technique entails providing customers with copies of the source code for the product. It thus allows a well trained practitioner to change significant amounts of content, and those changes can be made to look as if they are part of the product, because in effect, they are part of the modified source code product.","However, source code modification carries with it significant drawbacks. For example, source code modification costs a significant amount of money prior to using the product, because the user or customer must often hire expensive consultants and developers who have been specifically trained in the nuances of how the product is built. The user must then endure the risk of estimating a problem, which is a very difficult and imprecise task. Even if these problems can be overcome and persevered, the result is modified source code. When the manufacturer of the original source code ships additional software, such as bug fixes, updates, and new versions, the customer is either forced to again hire talented engineers or developers (and hopefully the same ones who made the original modifications), in order to merge those modifications into the new source code shipped by the manufacturer, and to resolve issues, one-by-one, as they arise in the newly modified source code. Alternatively, the user can simply go without the bug fixes and new features that may benefit the user's business.","In addition, source code modification makes it extremely difficult to simply purchase add-on modules \u201coff the shelf\u201d from multiple different vendors, because each of those vendors will likely have to modify the source code as well to accommodate their specific off the shelf modules. Consequently, not only must the manufacturer ship the source code of the base product, but each add-on vendor must ship their source as well. The user must then conduct some sort of adhoc merge process or synthesize a single product out of these random sets of source code. Of course, this results in a brittle set of code that is virtually guaranteed to have problems with upgrades or when any one of the vendors ships a bug fix.","Source code modification also suffers from the problem that only one organization in the world (the specific developers or engineers who modified the source code) knows how the modified source code product was built. Therefore, it is difficult, if not impossible, to achieve economies of scale and product support for any of the products running at the customer site.","The problems with source code modification increase significantly when, even within a single customer, there exists a diverse set of users with a diverse set of needs and preferences. Every time one of those users changes the product through the source code modification strategy in order to accommodate their particular needs, the customer employing those users, in effect, ends up with a new source code base. In other words, the customer does not only have a single custom code base, but it may actually have many custom code bases, depending upon how many specific users or departments within the customer have modified the code base. Again, each time a bug fix is published or a change is made to a customization that applies to all users, the customer must go through some sort of merge process with all other copies of the source which have been made.","This is only a partial list of the many problems associated with source code modification techniques. These problems can result in a great deal of difficulty for the management of the customer, and the employees themselves, in attempting to obtain an integrated business solution.","A business software framework supports business software applications. The framework includes a class library component that has a plurality of class libraries of business components, including business entities and business processes. The framework also includes an application framework that has a programming model, the programming model providing a set of application services for relating the business components to one another, and for providing desired services relative to the business components in order to obtain the business application.","The present invention involves a framework for supporting business applications. However, prior to describing the present invention in greater detail, one exemplary computing environment in which the present invention can exist is described.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 1","b":["100","100","100","100"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in FIG. , provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies.","A user may enter commands and information into the computer  through input devices such as a keyboard , a microphone , and a pointing device , such as a mouse, trackball or touch pad. Other input devices (not shown) may include a joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a hand-held device, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user-input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 2","b":["200","202","204","206","208","202","202","206","204","206","206","204"]},"Each business solution  includes one or more applications. The applications are groups of business components presented through a user interface and individually deployed.","Business framework  is used by developers of business components . The business framework enables business applications in a productive, reliable and consistent fashion.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 3","FIG. 3"],"b":["204","210","212","214","216","218","210","202"]},"Framework , itself, includes a set of business class libraries , a tools subsystem  and a business application framework . Tools subsystem  illustratively include a plurality of design subsystems for designing components, processes, reports and end user interfaces. Tools subsystem  also illustratively includes test services which can be used to test designed components as well as an application packager which is used to package the components into an application or solution.","Business class libraries  include common entities , patterns  and data types .","Two business applications often require a shared understanding of data so that integration can occur. For example, distribution, financials, and customer relations management all work with customer data. Business class libraries  thus provides a number of common entities  that contain the core properties of interest to most business applications. Applications built on framework  can extend these entities with scenario-specific properties and behavior, through customization (which is described below).","Table 1 is an illustrative list of some of the common entities  in business class libraries . Of course, many different or additional common entities can be defined as well.",{"@attributes":{"id":"p-0055","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Common Entity","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Currency and","Provides the foundation for"]},{"entry":[{},"Exchange Rate","multicurrency features."]},{"entry":[{},"Customer, Vendor,","Common constituents tracked by the"]},{"entry":[{},"Employee, etc.","system and used by many applications."]},{"entry":[{},"Constituent and","Facilities for role-based"]},{"entry":[{},"Role","personalization and security."]},{"entry":[{},"Business Unit","Operational or financial units,"]},{"entry":[{},{},"including companies."]},{"entry":[{},"Organization","An operational or financial hierarchy of"]},{"entry":[{},"Structure","business units."]},{"entry":[{},"Products and","Catalog and inventory definitions."]},{"entry":[{},"Items"]},{"entry":[{},"Units of Measure","Qualifiers for amounts, particularly in"]},{"entry":[{},{},"inventory. Includes measures for volume,"]},{"entry":[{},{},"quantity and size."]},{"entry":[{},"Taxes","A globalized tax engine."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"There are also a number of useful data types that can make writing business applications much more efficiently. Unlike an entity , a data type does not have a unique identity. Table 2 lists a number of illustrative data types which can be implemented as data types  in business class libraries .",{"@attributes":{"id":"p-0057","num":"0056"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Data Type","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Money","A decimal plus a currency. All numbers need"]},{"entry":[{},{},"to have a unit to describe them. For money,"]},{"entry":[{},{},"that unit is a currency."]},{"entry":[{},"Quantity","A decimal plus a quantity unit of measure."]},{"entry":[{},"Identifers","A set of data types for implementing"]},{"entry":[{},{},"identifiers, including policy for"]},{"entry":[{},{},"autonumbering numeric identifiers, imposing"]},{"entry":[{},{},"structure on identifiers (e.g. social"]},{"entry":[{},{},"security numbers) and so forth."]},{"entry":[{},"AmountAdjuster","A utility for adjusting an amount by a"]},{"entry":[{},{},"numeric value or percent. This is a common"]},{"entry":[{},{},"idiom in many products."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Common entities only make up a small fraction of the entities in a business application. While the common entities  can avoid specifying rules and processes because they vary by application, many of those rules follow frequently seen business application patterns. Business class libraries  provides support for writing a number of common categories of entities, processes and policies by capturing the structure and behavior of common patterns in a class library  as patterns . Table 3 is one list of a number of exemplary patterns used as patterns  in class libraries .",{"@attributes":{"id":"p-0059","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Pattern","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Account, Ledger,","An account is a definition of"]},{"entry":[{},"Transaction","something for which activity is"]},{"entry":[{},{},"tracked. A ledger tracks activity"]},{"entry":[{},{},"for an account. A transaction is"]},{"entry":[{},{},"a record of activity for an"]},{"entry":[{},{},"account and updates a ledger."]},{"entry":[{},"Order","Work orders, sales orders,"]},{"entry":[{},{},"delivery orders, manufacturing"]},{"entry":[{},{},"order and more all follow a"]},{"entry":[{},{},"similar structure and business"]},{"entry":[{},{},"process flow."]},{"entry":[{},"Apply","An apply process associates or"]},{"entry":[{},{},"matches things such as documents."]},{"entry":[{},{},"Examples include when a payment"]},{"entry":[{},{},"is matched to an invoice or when"]},{"entry":[{},{},"a receipt of goods is matched to"]},{"entry":[{},{},"its source purchase order."]},{"entry":[{},"Schedules","Many schedules (sometimes called"]},{"entry":[{},"(Calendars)","calendars) are used in business"]},{"entry":[{},{},"applications, including for"]},{"entry":[{},{},"delivery, payment, manufacturing"]},{"entry":[{},{},"and employee work hours."]},{"entry":[{},"Structures","There are a lot of graphs and"]},{"entry":[{},{},"trees in business and this"]},{"entry":[{},{},"category of patterns provides"]},{"entry":[{},{},"support for implementing them."]},{"entry":[{},{},"Example structures include a"]},{"entry":[{},{},"budget roll-up hierarchy, bill of"]},{"entry":[{},{},"materials and inventory stock"]},{"entry":[{},{},"hierarchy."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Business application framework  provides a programming model and services for writing applications. In one embodiment, it contains no business logic particular to any product and thus is suitable not only for authoring business applications but also any other application fitting its profile. It provides a set of application services that provide a wide range of support. The application services are implemented in subsystems including reporting and query subsystem , process extraction subsystem , user interface subsystem , component programming model subsystem , role-based securities subsystem , customization subsystem , deployment and management subsystem , data access subsystem , metadata subsystem , business messaging and integration subsystem  and foundation services subsystem .","As mentioned above, a logical view of an application built on business framework  is a set of classes representing its data, processes and rules. During design, these are further refined and grouped into business components . The design is structured according to a number of elements of programming model . The components are made up of three primary kinds of types: Business Entities, Activities and Processes written in terms of them. The components may also, of course, contain other supporting classes such as enumerations and other data types such as value types which is a specific embodiment of a type. The group of loosely coupled components that form a business application is the fundamental building block of the architecture. Components act in various roles, such as user interface management in subsystem , data persistence through subsystem  and  and business process execution through subsystem .","When implemented using application framework , the business components  are self-describing through detailed component metadata. The metadata is stored in metadata subsystem  or with the executable portion of the component. This information is used by application framework  to provide services to the business components  and to consumers of those components. The framework  provides the behavior for the metadata and can add to that behavior without changing the components. Of course, this would not be possible if the functionality were hard coded.","A business entity, as described above, manages data. A component illustratively has one primary entity, which is the focus of the component. Other entities in the component may illustratively be children of the primary entity, though they are not required to be. The data for entities is usually stored in database tables in a relational database. Accessing the data is discussed below with respect to subsystem  and .","A business process is an extensible sequence of business logic steps that usually transform data in some way. They also manage database transactions. A business process can be executed in code, through a work flow or using other means. Examples of business processes include posting, document approvals and price calculation. A business policy is a replaceable set of business rules, and a business rule is a constraint on data (such as the values a property can have or relationships an entity must have with other entities) or an inference (where, for example, if some predicate is true then an action should occur). Rules are part of entities, processes and policies and in fact business logic can be described as a set of business rules.","The interface to a component is the public members of the classes in that component. Part of a component's interface is published if it is accessible through public calls. Any published methods will, illustratively, guarantee to implement secure authorization and authentication.","When application programmers begin building an application, they must first determine the logical units of work needed. Second, they illustratively determine how each of the logical units of work will be orchestrated and finally they determine whether customization is allowed.","The business process model supported by programming component  for process execution subsystem  breaks work to be performed into three areas: Business Processes, Business Activities and Business Operations. A business operation is the smallest unit of functionality that executes in a single physical transaction. It is illustratively ACID (atomic, consistent, isolated, durable), such as a normal relational database transaction. An operation can call other operations and the collective set can share the same physical transaction.","A business activity is a code-driven process that includes some set of business operations that would collectively run in one physical transaction if possible. However, it may not be practical for them to run in a single transaction because concurrency (concurrent operations by multiple users) may suffer or the transaction may time-out. For example, posting a sales order, which logically can be completed in one transaction and thus could be represented by a single business operation may be grouped into activities instead. This is because posting orders locks data in the database so others, who wish to access the same pieces of data, must wait until the lock is released. These locks are held for the duration of a physical transaction, preventing users from accessing the data until the transaction is completed. Thus holding locks while a full order posts reduces throughput of the system and breaking the order into several smaller operations increases system throughput. Similarly, performing a large group of such operations may take longer than a normal time-out period for a transaction. Thus, if an order with thousands of line items was grouped into a single operation, a time-out would likely occur before the operation finished. Therefore, a number of operations (posting operations in this case) can be scoped by an activity. For instance, the posting operation for an order can be subdivided into several operations scoped by a single activity, which will likely not time-out and which will result in increased currency and throughput of the system.","A business process is a data driven process described using metadata and executed by a run-time engine. Therefore, a developer builds the operations which are typically written in imperative code (such as C#). These operations are grouped and scoped by activities, and the business process calls the activities to perform the overall process or work desired.","A process taxonomy is the hierarchical breakdown of units of work for an application developer. Long running (or asynchronous) and short running (or synchronous) transactions and the reuse of these components determine whether a business operation, business activity, or business process should be used. Table 4 illustrates some common categories as they apply to each of the units of work.",{"@attributes":{"id":"p-0071","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},"Process","Activity","Operation"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Stop points:","Yes","Normally no, but it is","No"]},{"entry":["ability to",{},"possible, e.g. - UI"]},{"entry":["suspend, resume,",{},"Interaction"]},{"entry":"and abort the"},{"entry":"component."},{"entry":["Implementation:","Metadata","Imperative code (such as C#)","Imperative"]},{"entry":["metadata or",{},{},"code (such as"]},{"entry":["native code to",{},{},"C#)"]},{"entry":"enforce"},{"entry":"imperative logic."},{"entry":["Transaction:","Long","Long","Short (ACID)"]},{"entry":["Failures:","Forward arc","Checkpoint\/","Rollback and"]},{"entry":["Expected behavior","Based on Exceptions",{},"None"]},{"entry":"or handlers for"},{"entry":"the component"},{"entry":["Isolation:","None","App Locks","DB Locks"]},{"entry":"expected async or"},{"entry":"sync behavior."},{"entry":["Composes: only","Process, Activity,","Operation, Activity","Operation"]},{"entry":["allowable","Operation"]},{"entry":"children"},{"entry":"components."},{"entry":["Invocation:","Execute( )","Execute( )","Not directly"]},{"entry":["method that is",{},{},"callable"]},{"entry":"used to start the"},{"entry":"component"},{"entry":["Customization","Add, remove, re-","Pre\/Post Execute( ) events,","Pre\/Post"]},{"entry":[{},"order activities,","Policy, and activity or","Execute( )"]},{"entry":[{},"process events (on","operation Replacement","events,"]},{"entry":[{},"completion,",{},"Policy"]},{"entry":[{},"suspend, resume,"]},{"entry":[{},"and abort)"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"Table 4 illustrates that stop points are available for processes and activities. This means that the process or activity can have points where they stop in the middle thereof, for further interaction from an external system, such as a user or other system. Operations, however, since they are the smallest unit of work performed, are performed all at once and are not susceptible to stop points.","The table also shows that processes are defined by metadata while activities and operations are defined by imperative code.","The table also indicates that a process and activity are long transactions while an operation is a short (ACID) transaction. A long running transaction is made up of several physical (short running) transactions. Thus, the isolation (from other users) characteristic of an ACID transaction is lost, but the other characteristics are still desired. It also involves a different approach to dealing with failure in the middle of the process, since complete rollback of the transaction is not possible in most cases.","Next, the table indicates what happens when a failure occurs during the unit of work. In a process, exceptions or forward arching techniques can be used. Check pointing can be used in an activity. A check point allows the activity to be restarted from the most recently recorded checkpoint, if a subsequent failure occurs. For example, if part of a batch of orders is posted in an activity, a checkpoint will be set after each posting operation is complete. Therefore, if a subsequent posting operation fails, the activity need not be started from the beginning, but only from the last saved checkpoint.","The table next indicates whether the unit of work is isolated from work performed by other users. The table indicates that during an operation, the database locks the data involved so that others cannot access it. During an activity, the application marks (\u201clocks\u201d) the data involved as \u201cin use\u201d. In this instance, the application will typically set an indication that certain data is being modified so that other processes or activities can view the data, but they will also have an indication that it is currently being changed or accessed and thus will not, by convention, modify the data. This is a convention respected by the application for the benefit of the user and not a physical lock. The table also shows that processes do nothing to isolate other parts of the system from their actions.","The table next indicates which other units of work a given unit of work can call. A process can call another process, another activity, and possibly an operation. An activity can call another activity or an operation and an operation can only call another operation.","The table next indicates how each unit of work can be invoked. The process and activities are invoked by calling an Execute method, for example, while the operation is not directly callable by an external component, but is only callable by an activity or another operation (and possibly a process).","The table next indicates how the units of work are customized. The process can be customized by adding, removing, or reordering activities. It can also be customized by how events are processed (such as on completion, suspension, resumption, or abortion of operations or activities). An activity can be customized based on events posted prior to or after the Execute method is called or completed, based on policy, or the activities can be replaced. An operation can be customized by subscribing to a pre or post Execute event, or by implementing policy.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIG. 4","FIG. 4"]},"The overall process in  is indicated by block . Activities that form the process are shown within block . Those activities include Create Order , Time-Out , Post Order , Picking activity  and Message activity . Process  also shows that another process (Credit Check process ) can be called by process .","In an illustrative embodiment, process  is authored by the author using a process description language (which can be metadata, a text language, etc.) which is interpreted by a work flow run time engine. An advantage to authoring in the process description language is that, even if changes are made, the description need not be recompiled before running the process again. However, if the process were authored in a programming language such as C#, then in order to make a change to the process, the code must be recompiled each time a change or customization is made. Perhaps more importantly, if the process description language is structured properly, upgrade customizations can be made without user intervention. Of course, each of the individual activities or operations can illustratively be authored in the programming language.","In order for the process to begin executing, a user or another system event causes the process to move forward. In the example illustrated in , a user creates a new order, such as by performing data entry through a screen . This initiates the Create Order activity . The Create Order activity is composed, in the illustrated embodiment, of a plurality of business operations .","The post order activity  is itself composed of a number of operations . The operations illustrated in  include obtaining a document number, adding a line to the document and re-saving the document. When this is complete, activity  calls the Time-out activity  which references a timer . Time-out  waits for a time-out event from timer  and then calls the Post Order activity .",{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 4","b":["306","326","306","326","326","328","330","306"]},"Once Post Order activity  is complete, it calls Credit Check subprocess . Credit Check subprocess  is referred to as a subprocess because it is called from within process .  illustrates that subprocess  also includes a stop point in that it waits for a user to manually approve the credit. This can be done, in one embodiment, by entering data through a screen .","Based on the outcome of subprocess , credit will either be approved or rejected. If it is approved, subprocess  calls Picking activity  in which the ordered products are picked for delivery. The Picking activity is shown as being formed of a number of operations . Picking activity  also includes a stop point such as waiting to receive a user indication that the products have been successfully picked, through a data entry screen .","If subprocess  determines that the Credit Check has been rejected, then it calls Message activity  which includes operations that send an electronic mail message to the user that initiated process , indicating that the Credit Check has been rejected.","While  illustrates that a branching point exists after the Credit Check subprocess , it will of course be appreciated that any number of branches can be developed in such processes. It will also be noted that the user or developer can modify or customize the processes simply by inserting or deleting activities or subprocess within process  by customizing the metadata (or other process description language) that describes the process. Similarly, the user or developer can customize the process by subscribing to events already in the process and handling the events with custom code or otherwise, as desired.",{"@attributes":{"id":"p-0090","num":"0089"},"figref":["FIGS. 5-7","FIG. 5"],"b":["350","352"]},"Now assume that, some time later, a vendor, customer, or other developer, wishes to use the same Print Check business activity  as part of a larger business process. Without changing any code in either the user interface  or the business activity , itself, the process description language (e.g., metadata) can be changed to specify that the Print Check business activity  will execute within the context of a business process  shown in . The business process is thus responsible for validating that all prerequisites for the Print Check business activity  have successfully completed. Assume also that an intermediate stage in the form of a Get Approval subprocess  is made part of the same business process  as the Print Check business activity . The Get Approval subprocess  also has a stop point which requires manual intervention from a user interface . In process , anyone attempting to invoke the Print Check business activity  through user interface  will fail unless the necessary prerequisites (Get Approval ) has been completed first.","Later, assume that instead of someone manually starting the process  illustrated in , that a user wishes to customize the process such that it automatically starts at a predetermined schedule (such as the 15and 30day of each month). Assume further that the Get Approval subprocess  can be automated by using business rules such that no manual intervention is needed. A new process  can be created simply by amending the process description language (e.g., the metadata) to include a timer  which starts the now fully automatic Get Approval subprocess . Of course, the metadata is also adjusted so that the output of Get Approval subprocess  is the only prerequisite for initiating the Print Check business activity .","From the above , it can be seen that the business processes described are fully customizable. Stop points can be added at substantially any point either within the process or within activities outside the process. Similarly, developers can subscribe to events generated by operations, activities, or processes, and can insert customized code in response to the events. Further, because the processes are described by a process description language, instead of in imperative code, customizations can be made without recompiling.",{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIG. 8","b":["400","400"]},"Business functionality may desirably exist near to the data it manipulates and near to its user, who must view the results of the functionality being performed on the data. However, in distributed computing environments, the user and the data are often separated by high latency, networks that exhibit low to moderate reliability. For example, in one common scenario, users are clients and data resides on servers.","Business operations in accordance with one embodiment of the present invention, follow an agent-service pattern. A business operation agent is the only part of the process that a client directly interacts with. A client that needs to run the business process creates an instance of a business operation agent and sends it properties to provide its required inputs. In turn, the agent locates a corresponding service class (through a service factory), instantiates it, and calls it to actually perform the work that implements the service.","Through an agent\/service pattern, the programming model avoids location transparency because location of execution can be considered when constructing a distributed application. The agent\/service pattern also provides a great deal of deployment flexibility by providing a programming model abstraction that supports the client\/server scenario and many others.","More specifically,  further illustrates that business activity  is implemented using three business operations, operations , , and . Business operation  has an agent  and a business operation service factory . Business operation  also has an agent  and a service factory . Business operation  also has an agent  and a business operation service factory .","Given some piece of business functionality, the agent runs as near to the user of the functionality as desired and possible, and the service runs as near to the data as desired and possible. The \u201cnearness\u201d may differ with each deployment scenario and each kind of user.","The entity classes and business process classes can be divided into agent and service portions (such as the agents and services illustrated in ). The agent portion is a normal class instance and holds state, while the service portion does not hold state across calls. Where necessary, the agent calls the service to perform data manipulation and to execute business processes. The specifics of how functionality is divided between the agent and service can vary, as desired.","A developer using a business component normally deals with only the agent. The agent provides a rich object oriented programming model where data is held across calls, rather than being limited to talking to services directly with procedural calls that require data to be respecified on each call. When calling the service, the agent can use its internal state to formulate the request rather than requiring the developer to do it. This simplifies the developer experience.","The agent\/service pattern thus provides a single programming model for both client and server. Agents can be used either by the client machine or by the services on the server machine. Internet latency cost is also reduced since state is moved to the client from an entity graph in one round trip (instead of one round trip per property as is traditionally the case). Similarly, the agent provides client-side behavior to avoid round trips. In addition, the agent-to-service interactions are stateless, aiding server scalability and reliability. Finally, the ability to implement several different deployment scenarios with the same components is greatly enhanced.","To customize a process, the agent itself is not replaced. The client (such as a process or activity) always creates and calls the same original business operation agent. This ensures that the client is always able to call the agent because it will have a stable interface. Business operation agents can have extension fields associated with them which can have additional properties added to them. This provides agent extensibility without breaking the original agent interface contract. The agent may locate the correct service to run in a number of different ways.","Business processes can be customized depending on whether the process is a process which is planned for replacement or whether it is a process that is going to be replaced on an adhoc basis. If it is planned for replacement, the calling application (or client) passes a service ID into the agent currently being called. The service ID indicates which service to activate. Thus, if the call passes agent  (shown in ) a specific service ID, agent  identifies through service factory, the business operations service , instantiates it, and calls it to perform the operation. Simply by passing in a different service ID, the service can be changed.","For an operation which is replaced on an adhoc basis, there are two different methods that can illustratively be used in order to override the built-in selection of the business operations service. For example, if the service ID is stored in a metadata structure in store , the customizer can simply customize the portion of metadata which holds the service ID for the business operation to be overridden. This will be handed to the business operation's service factory being used and it will instantiate and call the newly identified business operation service. In another embodiment, the particular service factory being utilized (e.g. factory ) propagates an event. The vendor who wishes to customize a service operation can subscribe to this event and place logic in the associated event handler  to alter the value of the service ID. This method not only allows customization of the business operation, but also allows dynamic selection based upon data contained in the business operation agent.","In accordance with one embodiment of the present invention, software that may need to be customized includes several basic classes of content, which includes user interface content, data and process content. User interface content includes content that a user sees on a screen or report. It may contain such things as layout information, messages, field labels, etc. Data represents information that the system stores. For example, data includes customers, inventory items, orders, etc. Process content includes work flow specifications that route work through a defined set of steps, as well as lower level processing logic that executes well defined actions on a piece of data. An example of process content may include, for example, the work flow and lower level processing logic that posts an order to a ledger or reserves an inventory item. These types of content, as well as other types, can be customized in accordance with various embodiments of the present invention.","Regardless of the type of content to be customized, customizations may desirably be associated with a given context. Context governs when the customization is relevant. That is, the notion of a context allows some customization to only apply to a specific user, whereas other customizations apply to a whole set of users who belong to a specific group, and still other customizations apply to an entire company, without regard to users. These are but three different examples of context, and many others can be used as well.","In order to better illustrate the operation of customization subsystem , the discussion will now proceed with respect to . This Figure better illustrates customization of entities. This is also referred to herein as \u201centity extension\u201d.",{"@attributes":{"id":"p-0109","num":"0108"},"figref":["FIG. 9","FIG. 10","FIG. 9"]},{"@attributes":{"id":"p-0110","num":"0109"},"figref":["FIG. 9","FIG. 9","FIG. 13","FIG. 9"],"b":["480","480","480","480","516","482","480","484","516","486","480"]},"Since the present customization subsystem does not require source code modification in order to customize entities, base extension entity  is also provided to enable the dynamic addition of new entity relationships to the base entity without recompilation of the base entity . A base extension entity  is created for each base entity  that is created. Base extension entity  illustratively includes the name of the base entity  such that, in the present example, base extension entity  is named \u201cCustomerExtension\u201d. Base extension entity  is initially empty but can include a customer extension E-R map  and a customer extension EA map  which will also be empty. Base entity  contains a composition field that identities the base extension entity. For instance, base entity  can include a composition field named \u201cExtension\u201d of the type \u201cCustomerExtension\u201d. Entity association metadata for the Customer entity  reflects a relationship with the CustomerExtension entity . Both entities  and  are illustratively shipped and deployed as DLLs when the product in accordance with the present invention is installed. At that point, a customizer can begin adding extension properties to the Customer entity  through a customizer user interface.",{"@attributes":{"id":"p-0112","num":"0111"},"figref":"FIG. 10","b":["242","242"]},"This causes subsystem  to create a new entity which is referred to as an ExtensionEntity. Two ExtensionEntities  and  are illustrated in . Each ExtensionEntity  and  includes at least one Extension property  and , respectively, that identifies the customized property.  illustrates an embodiment in which customizations have been made by two different customizers, labeled customizer XYZ and customizer ABC. Therefore, ExtensionEntity  is illustratively named XYZ.CustomerExtension and ExtensionEntity  is illustratively named ABC.CustomerExtension.","By way of example, assume that customizer XYZ desired to customize the customer entity  to include an identification of a technician which was preferred by the customer identified by entity . In that case, XYZ.CustomerExtension entity  includes Extension property  referred to as the \u201cpreferred technician property\u201d. Similarly, assume that customizer ABC desired to customize the customer entity  to include a credit limit associated with the customer identified by entity . In that case, ABC.CustomerExtension entity  includes Extension property  which identifies a \u201ccredit limit\u201d associated with the given customer.","Not only does subsystem  create the ExtensionEntities  and , with their corresponding Extension properties  and , but it also illustratively creates E-R maps  and  and E-A maps  and , respectively, corresponding to each of the ExtensionEntities  and . In addition, subsystem  creates a table in relational database  (such as through data accessing system  that corresponds to the ExtensionEntities  and  and the other associated data structures).","Finally, base ExtensionEntity  is recompiled and its E-R map is regenerated to reflect the new relationship with the ExtensionEntities  and . Similarly, E-A metadata is generated to reflect the new relationship with the ExtensionEntities as well.",{"@attributes":{"id":"p-0117","num":"0116"},"figref":["FIG. 10","FIG. 10"],"b":["521","521","480","523","525"]},{"@attributes":{"id":"p-0118","num":"0117"},"figref":["FIG. 11","FIG. 11","FIG. 11","FIG. 11"],"b":["248","500","500","1","1","1","500"]},"In order to customize a metadata structure , the customizer inputs the customization specification through a customizer interface to subsystem .","In an embodiment of the present invention, customization of all types of metadata in data structure  is achieved by using deltas. A delta represents a change in the metadata structure  from its original form. A customization can contain any number, n, of deltas, each delta representing a specific change relative to a known instance of a base target, an addition or a deletion.","As an example of changing a value, in the original data structure , the background color for the field having a name \u201cfoo\u201d is yellow. Assume that a customizer wishes to change the background color to blue. In that instance, the customizer will have made a single customization containing a single delta. The customization is relative to the field \u201cfoo\u201d under Tab  of the Customer_Maintenance_Screen. The customization can be stored in a separate part of the metadata store or in a metadata customization entity  which is mapped to the relational database . A table in relational database  that can form a part of the metadata store is illustrated by table  which contains a metadata ID identifying the background color property of field  under tab  of the fields in the Customer_Maintenance_Screen portion of the Forms. Table  also includes delta information which identifies the delta, that being that the background color of the field is changed to blue. Thus, the delta is not a copy of the source that has been modified. Instead, it is only a specification of which value in structure  should be modified. By only tracking deltas, it is possible for many modifications to be dynamically applied to a target without conflicting.","In order to apply the deltas, a customization-enabled subsystem calls subsystem  which applies customizations in the present context. For instance, assume that customization-enabled subsystem is the Form loading subsystem. Further assume that a user has requested the Customer_Maintenance_Screen to be displayed. Of course, subsystem  then identifies all instances in the relational database that apply to the current context for the form named Customer_Maintenance_Screen. The subsystem , for each instance identified, applies the customizations. It can be seen that the customization to be applied to the metadata requires that the background color of Field  under Tab  of the Customer_Maintenance_Screen be changed to blue. The code in the subsystem  makes this change and the customized portion of structure  is passed back to the customization enabled form loader for use in rendering the screen.","Deployment\/management subsystem  provides for flexible deployment capabilities. The components of an application may be at a single site, hosted on an external site, used off line, used by a single machine or at an installation of multiple servers, or any combination of these.","The execution architecture is layered into three logical tiers: Rendering tier , Workspace tier  and Enterprise tier . All three tiers can run on the same machine, or each may run on a separate machine. One tier may illustratively not be split between machines. This layering allows applications to be deployed in a number of configurations. While, in accordance with one embodiment, an enterprise tier  is required, all other tiers are optional. For example, if there is no user interface, there will be no rendering tier .","Three logical services support these tiers for different scenarios including presentation (or UI) , enterprise proxy  and message receiver scenarios. They are logical services in that there is no one service for all applications or scenarios.","The rendering tier  accepts HTML, or some other rendering format, and produces the screen display for a user on some device. On a client side only implementation, the end user of the product interacts only with this layer. The rendering tier then receives user events and either handles them, or passes them to the presentation service . The presentation service  supports the rendering tier  and thus is only needed when a user interface exists. It can run on the rendering tier , workspace tier  or both. The presentation service  maps interactions with agents into pages to be displayed to the user. This can produce HTML, or may have a different contract with the rendering engine.","The workspace tier  creates and submits a request to the enterprise. This is the execution environment for a consumer system or a single user. In scenarios where the workspace tier  is to operate offline from the enterprise tier , an enterprise proxy  provides several useful services, including a local store. The enterprise proxy  acts as a synchronization engine, and runs on the workspace tier . The enterprise proxy  can hold reference data obtained from the enterprise  for submitting correct requests, such as a product catalog for use in creating a purchase order. The workspace tier  thus makes requests of the enterprise proxy , as if it were the enterprise. The proxy  services the request from its local store, if possible. Similarly, pending requests to create or modify entities may also be stored. Upon reconnection to the actual enterprise tier , the enterprise proxy service  reconciles any pending requests with the enterprise  and refreshes any reference data.","The enterprise tier  holds the business logic that implements the application functionality. The enterprise tier  does not provide direct access to its database  and validates all requests. A message receiver services on the enterprise tier  receives requests from clients to update data. The message receiver service receives those requests and validates the data in those requests in order to protect the integrity of the data  in the server. In cases where the client is fully trusted, the message receiver service is not needed. This service runs on the enterprise tier .",{"@attributes":{"id":"p-0129","num":"0128"},"figref":["FIG. 13","FIG. 13"],"b":["510","510","246","514","516","518","510"]},"As shown in , the data can be organized in terms of entities . Each entity illustratively includes a metadata portion  (stored in a metadata store in metadata subsystem ) and a remaining attributes portion . The metadata portion  describes the entity , while the remaining attributes  define further attributes of entity , such as the data stored therein. Each of the attributes in entity  is mapped to a corresponding entity table  and a specific column  in a given entity table .","Data access subsystem  can receive various forms of requests such as a query  which specifies an entity, or portions of an entity or group of entities, to be retrieved. Query  can illustratively be expressed in terms of objects (\u201centities\u201d) and properties, rather than in terms of tables and columns.","In any case, data access subsystem  receives the query  and accesses class-table mapping . In this way, data access subsystem  can determine the location of the data for the entities identified by query . Data access subsystem  includes a translator  that translates query  into a relational database query  which is suitable for input to relational data store mechanism . In one illustrative embodiment, relational data store mechanism  is a SQL SERVER database server such as that available from the Microsoft Corporation of Redmond, Wash., that accesses a relational database . Therefore, data access subsystem  receives queries  in terms of objects and translates those queries into an appropriate relational database query  that is then provided to the data store mechanism (or server)  which actually accesses the data in relational database .","Relational data store mechanism  retrieves the requested data and returns it in the form of relational database results . The results are returned to data access subsystem  which then formulates the relational database results  into a requested result set . In one illustrative embodiment, result set  is requested in query . Query  may request that the results be output in the form of one or more objects or simply as a data set. In any case, data access subsystem  arranges the relational database results  into the proper format and outputs them as result set .","Data access subsystem  hides the physical data store (mechanism  and database ) from the users and developers enabling them to work in terms of entities rather than requiring them to know both the schema of database  and the syntax of the particular data store mechanism .",{"@attributes":{"id":"p-0135","num":"0134"},"figref":"FIG. 14","b":["600","602","604","606"]},"In the exemplary embodiment, the entities or objects are organized in a parent\/child relationship. Member  includes those entities that constitute an Order for a company. In particular, an Order entity  includes information such a subtotal, tax, freight and total properties. An Address entity  is a child entity of the Order entity  and may include information pertaining to the shipping address for a specific order. Likewise, the Order entity  may include a number of OrderLine entities , while each OrderLine entity  can comprise one or more OrderSerial entities  having further information. It should be noted that the notation \u201cn\u201d in  is used to indicate that the particular entity could comprise a number of identically structured entities. For example, as indicated above, one or more OrderSerial entities  can be a child entity(indicated by the diamond line ) of an OrderLine entity .","In the example illustrated herein, member  generally pertains to Customer information and includes a Customer entity , where each Customer entity  can include one or more Address entities .","The Customer entities  and the Order entities  are each child entities of a Company entity , the set of which comprise child entities of an Enterprise entity . Member  comprising, in this example, one or more currency entities  is also a child of the Enterprise entity .","Besides the parent\/child hierarchy of structure , there also exists, in this example, a uni-directional association between classes of entities. A class is a set of similarly structured entities. As indicated above, all of the Order entities  fall within an Order class. Likewise, the Customer entities  pertain to a Customer class. The association indicated by arrow  denotes that a class may know of another class. In this example, the Order class knows about the Customer class, but does not incorporate or own it such as in the case of a parent\/child relationship.","An entity manages data. The entity preserves its internal data and the integrity of its relationships with other entities. Data of the entity is accessed through properties. Each entity is a form of an abstraction. Characteristics of an entity also include that it has an identity, represented by a subclass of an abstract class \u201cEntityKey\u201d. Within the overall hierarchy, each entity that manages data in structure  is location independent in that it does not know where it is stored or who owns it. However, the EntityKey is used to define its relationship with other entities and can be thought of as being represented by the connections in .","An instance of an entity may be contained within an instance of another entity. The contained entity is called the child, while the container is called the parent. A child instance cannot exist longer than its parent and must have one and only one parent. The set of all such relationships for an application is its containment hierarchy. This sort of hierarchy parallels many business applications. It has been found that supporting this hierarchy makes the system a better fit for developers in constructing business applications.",{"@attributes":{"id":"p-0142","num":"0141"},"figref":"FIG. 14","b":["622","620"]},"It should be noted that the containment hierarchy is not the same as an inheritance hierarchy. Inheritance hierarchy is a classification of relationships in which each item except the top one is a specialized form of the item above it. In the example of , the Order class  and the Customer class  are not specialized forms of the Company class . Rather, the Order class  and the Customer class  are different classes holding different types of information. This is not to say inheritance can not be present in the Containment Hierarchy. In some embodiments, an inheritance hierarchy may be present for any class. Thus, for example there can be variations within a class such as variations of the Customer class .","There are three forms of entities in an application. The forms include the component containers \u201cEnterprise\u201d  and \u201cCompany\u201d , primary entities and supporting entities. The primary or root entity is the focus of a component container of the same name, while supporting entities are either children of the primary entity or its peers. For example, the Order member  consists of the Order root entity , while the Address , OrderLine  and OrderSerial  are supporting entities. The data for entities is usually stored in database tables such as described above with respect to . Components are a unit of logical design and do not interact with the database.","As indicated above, each of the properties in an entity is mapped to a corresponding entity table and a specific column in a given entity table as illustrated in . Each entity table also includes, in addition to columns for the attributes, one or more columns that identify all the parents of a particular entity. Referring to  and using OrderSerial by way of example, the OrderSerial Table  would include columns for identifiers, in particular, \u201cCompany_id\u201d , \u201cOrder_id\u201d , OrderLine_id  and Serial Number , which may comprise one of the attributes, and which may function as its own identifier (id).","In a relational database, interaction with the table would require specifying each of the identifiers in order to identify and work with the data associated with a particular entity, in this example, data associated with a specific OrderSerial entity . However, this information is inferred from its parent in the containment hierarchy. For instance, if one is working with a particular OrderLine entity  and now wants to inquire about, or perform an action upon, a OrderSerial entity , the data access subsystem  can ascertain which OrderSerial entity or entities the user is referring to without needing to re-identify the parents of the entity. In the present invention, the containment hierarchy allows the relationship of the tables (i.e., the identifiers) and hence, the relationship of the entities, be an implicit background piece of information. In other words, the identity of the entity is inferred from the parent\/child relationship so that it does not need to be restated or managed in other ways. In a relational database system, the identifiers found in the tables used to identify the entity are called a primary key, wherein the combination of the identifiers is unique. However, typically, primary keys are just a collection of columns and have no rich behavior attached to them. In addition, user selected identifiers may only be unique within a certain scope (such as a single business unit) and not unique over the entire range of the application. Surrogate keys, which are commonly generated by the application and hidden from the user, may be unique, but they do not describe hierarchies such as who is the parent of the entity referred to by the identifier.","Another aspect of the present invention is an EntityKey that solves these problems, in particular, the EntityKey associated with each entity allows each entity to be unique throughout the containment hierarchy, as well as infer from the position of the entity within the containment hierarchy who the parents are. An entity is an object that is identified by an entity key, or stated differently, the key for an entity. An EntityKey serves the same function as the primary key on a relational table; however, unlike a relational primary key it is universally unique across the application space and is hierarchical, i.e. it is aware of its position in the hierarchy. In the architecture, the EntityKey is a defined class that is distinct from the entities. The EntityKey class can be mapped to a relational database table. Every entity throughout the hierarchy has one and only one EntityKey value. Given the key for an entity, one can retrieve the entity, whether it is on a local server, or located in a wide area network such as the Internet.","Each EntityKey contains, for purposes of this concept, three pieces of information: the type or class of the entity to which it refers, the ID of that entity to which it refers and information as to the EntityKey of the parent to that entity.  is a pictorial representation of an EntityKey (herein, OrderSerial.Key) A for a particular OrderSerial entity A.","An entity in the hierarchy is fully identified by its identifier plus that of its parents. In this manner, the same local identifier can be used in two or more locations of the overall space because different parents would be involved in uniquely identifying the entity. This may be more readily apparent by pictorially representing the Enterprise space of . Referring to , the Enterprise is indicated by circle . The Enterprise  can include a plurality of companies, herein Company A  and Company B . However, each Company  and  can have two Orders, both having the same identifier, herein \u201cOrder \u201d  and \u201cOrder \u201d . Nevertheless, entities within Company A  would still be uniquely identified with respect to entities of Company B  although the identifiers for Order   and Order   have been used within each Company because each of the entities is uniquely identified by its associated key having the parent\/child relationships of the hierarchy.","It should be noted that in many applications, the data for Company A is stored in a completely different database then the data for Company B.","There is also a separate, independent class associated with OrderSerial  herein identified as OrderSerial.Key. In general, the EntityKey is of a separate class than the class it refers to. Entity A is an example of an object of the OrderSerial.Key class. Referring back to , the OrderSerial entity A contains all the attributes  relevant to the Order Serial, which could be any number of attributes. The OrderSerial.Key A contains a subset of one or more attributes of the OrderSerial entity A specifically, the OrderSerial.Key includes identifier attributes . Thus, if OrderSerial entity A includes a thousand attributes, but two of the attributes make each OrderSerial entity unique, those attributes get copied into the OrderSerial.Key to form the identifier back to the entity. Arrow  represents the common identifier attribute or attributes between entity A and entity A.","The attribute or attributes of the OrderSerial.Key that make each entity of OrderSerial unique is the first element of an EntityKey, which thereby allows the key to be associated with a particular entity.","A second element of an EntityKey is the type  of the entity to which it has an identifier. In the present example, the type of the class is OrderSerial.","A third element of an EntityKey is information about the EntityKey of the parent of the entity. In the present embodiment, this information is a reference, indicated by arrow , to the parent key  corresponding to the parent of entity A. In other words, the third element could be a reference to another key. This structure makes EntityKeys recursively defined However, it should be understood that some or all of the parent key information could be stored in the EntityKey directly, if desired. It should be understood that these forms and other similar forms for storing and accessing EntityKey information is intended to be covered herein.","Referring now to , EntityKeys are provided for an entity of Company, an entity of Order, an entity of OrderLine and entity of OrderSerial. In this example, the ID constitutes one field and the type can be ascertained from the name of the key. For example, type OrderSerial is obtained from the name OrderSerial.Key. References to parent keys are illustrated by arrows. Thus, again, the location of an entity in the hierarchy is completely defined by the associated EntityKey.","In the recursive form of storing EntityKeys, it should be noted that although each EntityKey includes type or class information to which it pertains it does not know the type or class of its parent. That information is found by looking at the type information in the parent key that it references. This is a particularly advantageous feature for it allows classes to be reused throughout the containment hierarchy. Referring back to , it is illustrated that the Order class  has a child class of Address . Likewise, the Customer class  also has a child class of Address . The Address classes  and  are actually conceptually the same; but the instances are disjoint since they are under different parents. However, the entities are uniquely defined in each form of Address class, wherein each Address class  and  may be stored in a different database table. In this manner, one can describe a position in the containment hierarchy without forcing a class to forever be in that position.","As explained above, each EntityKey has information such as a reference to its parent key, but it does not know what type of parent it is. The decision of what type of parent is made or defined by the mapping(s) for the complete set of classes and tables.","The set of identifiers  as illustrated in  of an EntityKey corresponds to the primary key columns of a table holding the data for that entity. Referring to , assume that the primary key of the table holding OrderSerial entities is Company_ID , Order_ID , OrderLine_ID , and Serial Number . The identifier attribute  in the OrderSerial.Key A is mapped directly to the last of the primary key columns, while the parent keys of A are mapped to columns , ,  in a similar fashion. This EntityKey to database key correspondence also extends to foreign keys. All simple associations between entities are implemented using keys. For example, in , Order.Key would have a reference of type Customer.Key that implements the association from Order to Customer. This key can easily be mapped to the Customer foreign key in the Order table.","It should also be noted that tables are commonly designed with surrogate rather than intelligent keys. An intelligent primary key is seen and specified by the end user, while a surrogate primary key is generated by the application and hidden from the user. Surrogate keys are often used to allow renaming the user visible identifier of a table without database impact or to save space when the size of the primary key is very large and often referenced in foreign keys. When surrogate keys are used, the table will have the surrogate primary key and an alternate key having the user visible identifier.","Both intelligent and surrogate EntityKeys are supported. In the present embodiment, if a surrogate EntityKey is used its ID properties are private (since they are generated and hold ho meaning to the consumer of the entity); otherwise they are public.","Another related abstraction is the Class Key. Since a given entity can be used in more than one place in the containment hierarchy, there is a mechanism for indicating which node in the hierarchy to process. The Class Key is that mechanism and contains two pieces of information: the type of the entity to which it refers and information as to the Class Key of the parent of the entity. Note the similarity to the definition of the EntityKey. In fact, the EntityKey is a derivative of and inherits from the Class Key, thereby allowing an EntityKey to be supplied anywhere a Class Key is required. Thus the Class Key is also hierarchically defined. The illustration of  of an EntityKey can be changed into an illustration of a Class Key by simply removing the entity identifiers (IDs).","Generally the Class Key can be used to reference a node in the containment hierarchy as it pertains to classes of entities, particularly describing uniquely a name for each class in the hierarchy as well as its position in the hierarchy. In contrast, the EntityKey provides a unique name for each entity in the containment hierarchy and describes its position in the hierarchy.","The EntityKeys and Class Keys are used when performing create, read, update and delete operations on business objects or entities. For example, when reading an entity, a parent key referring to a component container should be provided. This provides a scope for the read and also makes it easier for the developer to specify a complex location in the hierarchy.","Besides EntityKeys and Class Keys, another form of key is a blend between these keys. As discussed above, an EntityKey is a form of a Class Key, but includes further information to a particular entity (i.e., its identifier attributes). By simply using a chain of Class Keys followed by Entity Keys, all the entities under a particular parent can be ascertained.  illustrates an example of a blended key . In this example, EntityKeys have been provided for the Enterprise, Company and Order, which in turn has specified a particular Order entity. However, since the OrderLine.Key and the OrderSerial.Key do not include Ids, they are Class Keys. The blended key  of  could be received by the data access subsystem  to formulate a query for the data store mechanism to retrieve all series for a particular order, irrespective of line.","Creation of types based on the framework (such as entities, factories, keys, processes and services) is accomplished by an activation system within the framework. All other types (such as value types) are created with other operators. Since creation of entities occurs in one place, several features can be implemented. First, the foundation services subsystem  can find the correct version assembly given a request to create an instance of some type. In addition, entity substitution allows developers to add new functionality to a class without impacting existing business logic, by letting them substitute a subclass of any type when an instance of that type is requested. A form of entity substitution can also be used in which a subclass is a proxy automatically generated by activation. The proxy can add a variety of functionality including system call tracking when an instance has changed, and insuring read only access for some classes.","Diagnostics and instrumentation provide logging, tracing, and accounting services within foundation services . An application can be instrumented with calls to diagnostics for it to perform these services. The application framework can use run-time call interception to call diagnostics on behalf of application developers.","Role-based security subsystem  provides basic primitives necessary to build a variety of security schemes. For example, User and Roles are classes of entities provided by security subsystem . The subsystem  can map any number of identities to a single User class, allowing multiple authentication mechanisms to be used. Security subsystem  also provides a framework for applying custom permissions between a User or Role and an entity. For example, certain querying views can apply security to query definitions indicating which Users or Roles can read, update, or execute a query. The permissions feature of subsystem  provides a consistent mechanism for creating custom permissions and also provides much of their implementation.","A task is an entity or activity built using the permissions framework described relative to security subsystem . User and Role classes can then be given permission to execute a task. To use task security or method involves two steps. First, the task must be defined using a custom attribute to specify the task ID, name and description. Next, an imperative or declarative security check must be provided for the task with another attribute. This \u201cTaskPermissionAttribute\u201d throws an exception if the security check fails. The following table 5 illustrates pseudo code for performing these steps.",{"@attributes":{"id":"p-0169","num":"0168"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 5"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class Microsoft.GL.Transaction {"]},{"entry":[{},"\u2003\/\/ ..."]},{"entry":[{},"[Task(\u201cMicrosoft.GL.Transaction.Post\u201d,"]},{"entry":[{},"\u2003\u201cPost\u201d,"]},{"entry":[{},"\u2003\u201cA posting routine for General Ledger\u201d)]"]},{"entry":[{},"[TaskPermission(SecurityAction.Demand,Task=\u201cMicrosoft.GL."]},{"entry":[{},"Transaction.Post\u201d)]"]},{"entry":[{},"\u2003virtual public void Post( ) {"]},{"entry":[{},"\u2003\u2003\/\/ ..."]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003\/\/ ..."]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"It defines a task with a \u201cTaskAttribute\u201d and specifies a declarative security check with \u201cTaskPermissionAttribute\u201d. Should the security check fail, an exception is thrown and the method does not execute.","Data can also be secured using security subsystem . Each application may have different requirements for how data access is restricted, so rather than providing a single solution, security subsystem  provides a data access framework. A basic mechanism intercepts all data access requests to data access subsystem  by providing secure class wrappers that implement each of the interfaces to data access subsystem , and adds the ability to specify a dynamic view to use when accessing the data. Administrators can create the dynamic views to define data access permissions for Users and Roles. A dynamic view combines a security data access policy with a list of properties on the underlying entity that can be seen and updated. User and Roles are then given access to use a particular dynamic view when accessing data. The secure data access policy defines a data access security policy and developers can create custom policies by deriving from it and adding their custom logic.","Three illustrative examples of security schemes include a pass though filter. When a request is made of data access subsystem , this filter adds restrictions to a \u201cwhere\u201d clause of the criteria, restricting the entities returned. Another approach is an entity-by-entity access control approach. A join table lists each entity to which a User or Role has access. Yet another approach is a hierarchical filtering approach. For example, a manager may be able to view a subordinate's information but not vice versa. This is usually implemented by flattening the hierarchy into a new entity and adding a join to that entity in the criteria of the access request made of data accessing subsystem .",{"@attributes":{"id":"p-0173","num":"0172"},"figref":"FIGS. 20A","b":["20","20"]},{"@attributes":{"id":"p-0174","num":"0173"},"figref":["FIG. 20A","FIG. 20A","FIG. 20A"],"b":["262","950","952","954","956","950","958","960","962","958"]},"Focal points  represent certain data in the object model that is marked by the user as being a focal point of analysis. Focal points  can illustratively be specified in an XML specification file.","Object description  is an input which describes the object orientation relationships in a set of metadata corresponding to a set of objects. This can take the form of, for example, a UML class diagram. One example of a UML class diagram for a plurality of business entities (Customer, Order and OrderLine) is illustrated in .","Persistent data store mappings  map the data referred to by the object model to the persistent data store, in one illustrative embodiment the relational database  shown in . These are illustratively created by the user in the form of a map file.","Model services system  receives inputs ,  and  and automatically generates a dimensional model  based on those inputs. In accordance with one embodiment of the present invention, dimensional model  is inferred from the inputs supplied by the user, and there is no requirement for a second set of developers to be involved in recreating the business logic to obtain model . In one embodiment, and as will be discussed in greater detail below, model services system  uses the associations and compositions in the object model specified by the object model description  to infer foreign key relationships in dimensional model . System  also uses the focal points of analysis defined by the user in file  and the persistent data store mappings  to create dimensional model  and access data through model .","However, even a system which automatically generates dimensional model  can be improved. For example, obtaining information through dimensional model  still requires the user to know MDX or some sort of dimensional model querying language. Therefore, in accordance with another embodiment, entity generator  is provided. Entity generator  creates business intelligence entities  in the form of objects, from the cubes and dimensions in dimensional model . This is also described in greater detail below.",{"@attributes":{"id":"p-0180","num":"0179"},"figref":["FIG. 20C","FIG. 20A","FIG. 20C","FIG. 20C"],"b":["954","956","954","964","516","958","958","966","968","970","966"]},{"@attributes":{"id":"p-0181","num":"0180"},"figref":["FIG. 20C","FIG. 20C"],"b":["962","962","970","972","974","972","974","970"]},"By looking at the entities and their relationships in object model description , it can be seen that the dimensional model will require a snowflake-schema, such as that shown in dimensional model representation . It can thus be inferred that two dimensions will be created, Order and Customer. The Order dimension will have two levels, Order and OrderLine. The measures (or numeric values) in the Fact table  will include UnitPrice and Quantity and will come from the OrderLine entities.","Reporting and query services subsystem  also stores information regarding entity relationships to provide linking capabilities to other queries, allowing the user to perform guided navigation of related information. For example,  shows a type of model and how subsystem  uses that information. The model illustrated in  shows that a Customer has zero or more Orders and is the parent of its Addresses (indicated by the filled diamond). The web page at the bottom of  shows a customer list. A context menu is open on one of the customers, allowing navigation to the orders and addresses of that customer. Selecting \u201corders\u201d from that menu, for example, displays that customer's list of orders.","No code is required to perform this function beyond the Customer, Address and Order entities. There is a variety of information associated with, but not directly part of, an entity. That information includes a list of associations to other entities, valid work flow state transitions for an entity, tasks that can be performed against an entity, and hyperlinks for web sites related to the entity. In , the context menu has two associated entities.",{"@attributes":{"id":"p-0185","num":"0184"},"figref":"FIG. 22","b":"232"},"As mentioned above, when developing an application, it is common for a set of objects (such as business objects or entities in a business application) to be defined. Such objects in a business application may include, for example, a \u201cCustomer\u201d object, a \u201cSalesPerson\u201d object and an \u201cOrder\u201d object. These objects (entities) are interrelated through different associations. For instance, an \u201cOrder\u201d has both a \u201cCustomer\u201d and a \u201cSalesPerson\u201d associated with it. Since these associations exist in the problem domain of the application, they are associations that the end user typically understands. Therefore, it may be beneficial to allow the end user to navigate between these associations.","The information that defines these associations is captured in a metamodel (or object model) of the applications as they are being developed. This information is typically stored as metadata. For example,  depicts a relationship between an \u201cOrder\u201d entity and a \u201cCustomer\u201d entity that is modeled during the application development process.","There are known tools which can be run against object models generated during development of an application. Such tools compile the models into association metadata. In accordance with an illustrative embodiment, this is done and the association metadata is stored.",{"@attributes":{"id":"p-0189","num":"0188"},"figref":["FIG. 22","FIG. 22"],"b":["901","901","903","904","908","910","912","901","900","902"]},"The metadata associations developed during the application development process (such as the information shown in  which illustrates an association between an \u201cOrder\u201d entity and a \u201cCustomer\u201d entity) is stored in metadata store .","It is assumed that metadata hypermedia provider  has properly registered with hypermedia service (HMS)  and its link and identification data that identifies it as a link provider resides in provider register . Client  first generates a hypermedia request (or link request) specifying objects that are the source of the links sought by the client, and which categories of links are to be retrieved. This request is received by HMS . HMS  then forwards the request on to the appropriate providers. Providers - simply return the requested links that they are configured to provide. The link request can also be forwarded by HMS  to metadata hypermedia provider . In that case, provider  analyzes association information contained in metadata store . Provider  examines each association in metadata store  which has been requested and determines whether the user has rights to access the associated entities. Provider  can determine whether the user has rights to access the associated entities by accessing a security subsystem, or in any other suitable way. Provider  then creates a link for each association for which the user has access, and places association information in the link. Provider  identifies (using terminology defined, for example, by the Unified Modeling Language (UML)) simple associations and composition associations; these can have a variety of cardinalities, such as 1-1, 1-many or many-many relationships. Provider  also identifies inheritance associations. For each association located by provider , provider  creates a link between the source node and the associated node.","The links are returned from provider  to HMS , and HMS  aggregates all returned links and forwards them on to client . In one embodiment, provider  does not return the associated node, but instead returns a query whose results, if executed, include only the associated node.",{"@attributes":{"id":"p-0193","num":"0192"},"figref":"FIG. 23","b":"232"},{"@attributes":{"id":"p-0194","num":"0193"},"figref":["FIG. 23","FIG. 22","FIG. 13"],"b":["925","232","925","905","907","248","901","911","510","915","905","907","917"]},"In one illustrative embodiment, query web services component  is a set of objects that expose a set of interfaces (such as application programming interfaces\u2014APIs) having methods that can be invoked by client . When the methods are invoked (i.e., when client  writes to the API), client  can employ the functions provided by the systems to which it is connected. Thus, query web services component  wraps the functions of systems , , , ,  and  and provides those functions to client  and allows client  to access those functions through the interfaces on query web services component .","The systems can perform a wide variety of different functions, other than those described with respect to the systems below, or additional functions in addition to those described.","Query builder  can be any system for building queries against a database system, such as system . Therefore, a detailed discussion of builder  is not provided. Suffice it to say that query web services component  provides a number of helpful functions, which can be used by builder  in creating a query based on inputs from client . These functions are discussed below.","Entity folder system  is a system for storing queries or references to queries in a hierarchical storage system (such as a folder system). A number of aspects of query folder system  are discussed in greater detail below.","Query services component  defines a query. Query web services component  interacts with component  to define queries and to perform, create, retrieve, update and delete (CRUD) operations on queries. Component  also interacts with component  to execute queries. Query service component  translates defined queries into a form suitable for data accessing and storage system  (shown in ) and performs the necessary interaction with system  to have the queries executed against the database.","Metadata subsystem  stores metadata about objects in the system. The metadata indicates what objects are available to query, and what properties on those objects are queryable. Both system  and system  access metadata subsystem  during processing.","Component  exposes an interface with a plurality of methods. Some methods are provided for installing and removing query web services component  from a system.","Additional methods can be invoked to load a query from folder system , execute a query in system , perform a process request (such as traversing a hypermedia link at hypermedia retrieval\/traversal system ) and to delete a query stored in query folder system .","It should be noted that in one embodiment, a single method (such as a ProcessRequest method) can be used to perform all query-related operations (such as load, execute, create, save, delete, traverse a hyperlink, move next, move previous, etc . . . ). Still other functions are helper functions that allow a client to more easily perform these operations.","Further, methods can be invoked to perform manipulations in query folder system . For example, the methods can be invoked to list a folder, create a folder, delete a path through the folder system, or copy a path through the folder system.","Further methods can be invoked to retrieve metadata from metadata subsystem  to aid client  in building a query. Pieces of the metadata can be pulled by client  into a new XML element used to define a query (e.g., a QueryDefinition). For example, the methods can be used to obtain basic views in the system and to obtain properties and relationships that can be viewed. The methods dealing with views allow a client to create queries by supplying them with lists of available views which can be used as the basis for their query. Metadata about these views, such as lists of available properties and lists of associated views, can also be retrieved. Clients can use this information to create queries that have multiple, joined views, complex restrictions with system variables and user-supplied parameters, and multiple sorts. Thus, the methods allow expression variables to be retrieved as well.","Another method allows the client  to obtain the location of the schema used to define the format that the output will conform to and that the input must conform to. One embodiment of an object model that defines the classes that are used to define a Query and perform create, retrieve, update and delete (CRUD) operations on the Query, provides methods that only allow a client to build a valid query. For example, if the client is building a Query on a Customer, then these methods only allow the client to select properties on the Customer entity.","The user interface subsystem  provides a user interface or \u201cpresentation\u201d portion of application framework . This subsystem supports the application objectives of automating business processes and the management, visualization and analyses of business data by providing facilities to visualize, manage and analyze data and initiate processes.","A typical deployment of a business application may contain thousands or even millions of business entities. Further, these business entities have a complex web of interrelationships. A given customer will have many orders. A given order will have many line items which are further related to many inventory items. Inventory items are related to vendors which supply the items.","The query services subsystem  provides the ability to find business entities by filtering them and navigating through them. User interface subsystem  facilitates managing the business data by performing create, read, update and delete operations on it. A related set of business entities managed by subsystem  can be referred to as a document. Managing business documents is very different from visualizing them because visualization is a read only action, while management is a modification action within a single document.","Modification brings business logic into play. Business logic is used in many ways to provide a desirable user experience. For example, assume that a user specifies a customer for creation of a sales order, and business logic requires verification that the customer exists. This validation is provided by user interface subsystem  so that a user will not be required to wait to be notified of such a problem until the database has flagged the problem by identifying lack of referential integrity.","In addition, defaulting provides a business application user with an interface that allows the user to create documents with as few keystrokes as possible. For example, after assigning a customer to an order, the order's currency can be defaulted to the customer default currency. Of course, many other properties can be defaulted as well.","Further, document-relative calculations are coordinated. For example, when a line item is added to an order, the subtotal and total of an order must be updated. While this appears simple, it quickly becomes more involved because adding a line item may require the recalculation of taxes which can, in turn, invoke highly complex business logic.","These examples are only illustrative of the uses of business logic on user interface subsystem .","User interface subsystem  also facilities the processing of business documents. As discussed above, the hypermedia subsystem in subsystem  can act as a repository for information that describes what operations (or processes) can be performed on a business document. This list of available operations can be displayed which in turn means that the processes can be initiated either during visualization or management of a business document. Selecting such an operation invokes business process that internally many be short running or long running. The distinction is hidden from the user by user interface subsystem .","Although the present invention has been described with reference to particular embodiments, workers skilled in the art will recognize that changes may be made in form and detail without departing from the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIGS. 5-7"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 14-17"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 20A"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 20B"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 20C"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 23"}]},"DETDESC":[{},{}]}
