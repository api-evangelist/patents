---
title: Concurrent code loading mechanism
abstract: A platform independent binary object (PIBO) operable on disparate computing environments that have a selected hardware architecture without requiring rebuilding or reloading is provided. The PIBO can be parsed to generate source-code stub file. The PIBO can be loaded and linked with a cooperating computing application by an exemplary linker/loader employing the stub file. Also, the PIBO can be used in various contexts, including but not limited to, as a mechanism for dynamically linking shared objects on platforms that do not offer such native facility; in utilizing pre-written code components on platforms that otherwise would be incompatible due to a violation of platform constraints within particular code; as a mechanism for loading non object-oriented code that circumvents restrictions of multiple execution instances and repeat execution inherent in the code; and as mechanism that allows for the use of a binary object to add on functionality on a closed platform.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07444625&OS=07444625&RS=07444625
owner: Picsel (Research) Limited
number: 07444625
owner_city: Glasgow
owner_country: GB
publication_date: 20041012
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE","FIELD OF INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application cross references the following pending U.S. patent application Ser. Nos. 10\/964,272, entitled \u201cMechanism To Circumvent Restrictions Of Pre-Written Code Components,\u201d filed Oct. 12, 2004, Ser. No. 10\/964,315, entitled \u201cMechanism To Extend Functionality In A Restricted Computing Environment,\u201d filed Oct. 12, 2004, Ser. No. 10\/964,232, entitled \u201cDynamic Linking Constrained Environment,\u201d filed Oct. 12, 2004, Ser. No. 10\/965,361, entitled \u201cPlatform Independent Dynamic Linking,\u201d filed Oct. 12, 2004, which are hereby incorporated by reference in their entirety.","The present invention relates to the creation and operation of a binary object and, more particularly, to the creation, operation and distribution of a platform independent binary object operable across disparate computing environments enabling, among other things, various non-native computing environment operations.","Computing environments are capable of executing computer code that contains one or more instructions for the computing environment's hardware components to perform one or more operation. Typically computer code is loaded onto a computing environment for execution. Prior to the physical loading, the computer code can be compiled so that it operates on a particular computing environment (e.g., a computing environment's operating system and\/or a computing environment's platform). The computer code can be linked by the computing environment with other computer code residing on the computing environment to execute one or more operations. Depending on the computing environment handling of given computer code, a binary object can be created for use by the computing environment and\/or other cooperating computer code. The binary object may contain information, functions, and\/or operations desired by one or more cooperating computing programs (computing programs).","One or more functions, in turn, can be aggregated in one or more libraries for use by computing applications, other libraries, or by a computing environment to perform one or more operations. In a general practice, a library is designed and implemented such that it can be utilized by a singular computing environment having a specific hardware architecture. The library can be utilized by a given computing environment on either a static basis or on a dynamic basis. In the static context, the libraries and other components of a given computing application are combined into a single file which can be loaded into memory and executed. Comparatively, with dynamic operations (e.g., dynamic linking of components) functions and components (e.g., objects and libraries) are made available when a computing application is executed. Dynamic components can be shared by several computing applications operating on a computing environment since dynamically linked components, in their design and operation, are not tied to a main part of a computing application.","However, current practices can be cumbersome when creating and executing computer code for operation on disparate computing environments. Since current practices generally require the creation and execution of computer code for a specific computing environment (e.g., through a software development kit\u2014SDK) having a particular computing hardware architecture, it can be difficult to create a single binary object for operation on a number of disparate computing environments (e.g., having various operating systems and\/or computing platforms). When creating code for a particular computing environment, the computer code can be compiled in advance of loading it onto the computing environment and can be linked by the computing environment when executing the computer code. With these constraints, computer code is generally designed and created to operate on a singular computing environment (i.e. operating system and\/or platform).","Additionally, computing environments can impose constraints and rules on the manner in which computer code should be created so that it can properly execute on a given computing environment. For example, a platform and\/or operating system (e.g., SymbianOS running Symbian Quartz) can maintain a number of constraints on computer code being executed on the particular platform and\/or operating system, including but not limited to, the use of writable static and\/or global variables. Stated differently, the platform and\/or operating system can forbid the operation of computer code having writable static, or global variables.","A common practice among computer code developers includes, but is not limited to, developing various code performing the same operations but built for each of a disparate set of operating systems and platforms. For example, a calendaring computing application can be developed using a single high level programming language such as Java, \u201cC++\u201d, or Visual Basic. In an effort to reduce development time and resources, core computing application code can be reused by developers. However, the extent of such reuse is limited since with current practices additional components (e.g., libraries, functions, data structures, etc.) need to be developed and customized to ensure that the computing application is operable on each of a set of disparate computing environments (e.g., operating systems and\/or platforms).","Conventional practices and approaches have other limitations including, but not limited to, an inability of having a single platform independent binary object that can be operable across a plurality of disparate computing environments without requiring rebuilding or recompiling for each of the disparate computing environments. Additionally, current practices and approaches do not offer a mechanism for dynamically linking shared objects on platforms that do not offer such native facility. Also, with current practices, pre-written code components can not be utilized on platforms that otherwise would be incompatible due to a violation of platform constraints within particular code. Further, current practices do not offer a mechanism for loading non object-oriented code that circumvents restrictions of multiple execution instances and repeat execution inherent in the code. Also, current practices and approaches do not offer a mechanism that allows for the dynamic linking and loading of a binary object on a closed platform (e.g., a platform that may restrict the execution of additional programs).","The herein described systems and methods provide for a platform independent binary object (PIBO) operable on disparate computing environments having a selected hardware architecture without requiring recompiling, rebuilding or reloading. In an illustrative implementation, a binary object file is provided having a selected structure (e.g., object file format). The binary object file can be created by compiling source code such that the source code, when created, does not have platform dependencies. In an illustrative implementation, the binary object file comprises binary code and data for a source file. Moreover, in the illustrative implementation, an exemplary parser is provided that operates on the exemplary binary object file to generate a source-code stub file. Additionally, an exemplary linker\/loader is provided that operates as part of an exemplary computing application to link and load the platform independent binary object using the stub file and to allow cooperation with cooperating computing programs on the disparate computing environments. Also, an exemplary interface can be provided that allows cooperating computing applications access to the exemplary PIBO.","In an illustrative operation, the PIBO file can be parsed by the exemplary parser to generate a stub file as source code. The stub file source code is such that it does not maintain platform dependencies. The exemplary linker\/loader and stub file can be compiled, for the one of the disparate computing environments, along with the main source code of the cooperating computing application to generate a binary executable operable on the one of the disparate computing environments (and\/or platforms). In an illustrative implementation, the exemplary linker\/loader can operate to link and load the PIBO with the cooperating computing application during the execution of the cooperating computing application. In the illustrative implementation, the linker\/loader can handle symbol resolution and relocation to bind the cooperating computing application binary executable with the PIBO as a fully runnable process.","In an illustrative implementation, the PIBO can be used in various contexts, including but not limited to, as a mechanism for dynamically linking shared objects on platforms that do not offer such native facility; in utilizing pre-written code components on platforms that otherwise would be incompatible due to a violation of platform constraints within particular code; as a mechanism for loading non object-oriented code that circumvents restrictions of multiple execution instances and repeat execution inherent in the code; and as a mechanism that allows for the use of a platform independent binary object to provide add-on functionality on a closed platform.","Other features of the invention are further described below.","Overview:","Computer code can execute on a central processing unit (CPU) or other computer processor within a computer system or device. Common examples of CPU architectures include but are not limited to, the INTEL\u00ae x86 family, the ARM\u00ae RISC (reduced instruction set code) architecture, SUN\u00ae SPARC, and MOTOROLA\u00ae 68000. Code can be written in a high level language such as \u201cC,\u201d \u201cC++,\u201d or JAVA\u00ae that can be understood by humans, but ultimately the code can be subsequently compiled and assembled by a computing environment into machine instructions that execute on an exemplary computer processor.","The CPU can reside within a software environment generally known as the system platform. The platform can include an operating system, such as MICROSOFT\u00ae WINDOWS\u00ae and Linux for larger form factor computing environments (e.g., desktop, laptop personal computers). For smaller form factor computing environments (e.g., mobile and telecoms devices), there are various operating systems in current use, including but not limited to, Linux, SymbianOS, WindowsCE\u00ae, PalmOS, BREW, REX, and Itron.","The platform often can maintain additional functionality that extends the OS for specific purposes. For example, the WinCE.NET, Smartphone and PocketPC platforms employ the Windows CE operating system, but differ in other aspects such as the user interface\u2014i.e., WinCE.NET can be targeted at industrial devices, PocketPC can be targeted at personal digital assistants (PDAs) with a touch screen, and Smartphone can be targeted at mobile cellular phones operated via a keypad. The platform can also include extended functionality that is tailored to a particular computing application. In the example provided, the PocketPC platform can maintain a range of functionality for personal information management on a PDA, whereas the Smartphone platform can be packaged with communications functionality suitable for a mobile phone.","In conventional systems, creating binary code that can run on a specific platform can be accomplished by compiling and building the code through a tool chain such as a software development kit (SDK) provided for the specific platform (and\/or operating system). Different SDKs can be required to develop code for different platforms operating on a given operating system (e.g., Symbian Quartz can require a different SDK than Symbian Crystal). If an improper SDK is used to develop code for a particular platform, the resulting binary can be inoperable on the desired platform.","At the source code level, some operating systems impose constraints and rules on the way code is written. For example, the SymbianOS requires that code be created to not employ writable static or global variables. As a result of such constraints, legacy code written originally for one OS may not compile on another OS requiring different coding rules. Nevertheless, a common practice is to write a single source code program that may be subsequently built for multiple platforms. When implemented, a common source file can be developed. The common source file can be processed separately through the tool chains of the chosen platforms to create multiple distinct and platform specific binary outputs from the single source file.","Dynamic Linking and Loading:","A computer program can be comprised of a number of components. When the program is run, the components can be brought together to form a complete, functioning system and can be loaded into main memory of a cooperating computing environment executing the program. The process of combining the components of a computer program is known as linking. For the case when program components are combined into one single file, that can be loaded into memory and executed, such process is described as \u201cstatic linking.\u201d Generally, the linker is part of the tool chain that can concatenate the component object files that can act as input to the linker, and can link the object files together to form a single output file. When a program is made up of multiple subprograms, reference of one subprogram to another can be made through symbols (such as variables and function names). Among other functions and operations, the linker can operate to resolve the reference by noting the symbol's (or symbols') location in a cooperating computing environment's memory and patching the object code of the calling subprogram so that the call instruction refers to the noted memory location.","In \u201cstatic linking,\u201d when a program makes a call to a function stored in another component, the code for the required function can be incorporated in the executable by a static linker. In effect the static linker copies the code of all required functions into an output executable file. By contrast, \u201cdynamic linking\u201d can make functions and components available only during the execution of a program. Since dynamically linked components are generally not tied to the main part of the program, they can be shared by several executed programs. The main program can also be significantly smaller than a statically linked counterpart since the actual code does not become part of the program's executable and since the dynamically linked components exist as separate files. \u201cDynamic linking\u201d is prevalent among current computing environments. For example, in MICROSOFT\u00ae WINDOWS\u00ae, the dynamically linked components are called DLLs (dynamic linked libraries) and in Unix\/Linux they are called shared object (.so) files.","In the instance a program makes a call to a function in a dynamically linked library, the compiler and linker can generate relocation tables that contain information which, at run time, can allow a cooperating computing environment to load a library and find the code for the required function. In dynamic linked libraries, symbols are not bound to actual addresses until the program that uses the library starts running (known as \u201cload-time dynamic linking\u201d) or until the program makes the first call (\u201crun-time dynamic linking\u201d).","Dynamic executables can be executed under the control of a dynamic linker\/loader. These applications have dependencies in the form of dynamic libraries (or shared objects), which can be located and bound by the dynamic linker to create a runnable process. Shared objects can also have dependencies on other shared objects, also managed by the dynamic linker. With conventional approaches, the routines for dynamic linking and loading that handle binding, symbol resolution, and code relocation that allow the combined executable and shared objects to run as a complete program are generally part of a computing environment's operating system.","In practice, dynamic libraries can be linked at load time. When the dynamic library is created, a small stub file or import library is generated, which supplies the computing environment with information (such as symbol and relocation tables) that can be used to load the dynamic library and locate the functions it exports. The import library (or stub file) can be linked when the main executable program is generated, so that all the function locations within the shared object library are known to the executable program, even though the actual binary code of the shared object remains separate.","Illustrative Computing Environment",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 1","b":["100","100","180","100","110","100","10","115","110","110","110","115","112","110"]},"It is appreciated that although an illustrative computing environment is shown to comprise a single CPU  such description is merely illustrative as computing environment  may comprise a number of CPUs . Additionally computing environment  may exploit the resources of remote CPUs (not shown) through communications network  or some other data communications means (not shown).","In operation, CPU  fetches, decodes, and executes instructions, and transfers information to and from other resources via the computer's main data-transfer path, system bus . Such a system bus connects the components in computing system  and defines the medium for data exchange. System bus  typically includes data lines for sending data, address lines for sending addresses, and control lines for sending interrupts and for operating the system bus. An example of such a system bus is the PCI (Peripheral Component Interconnect) bus. Some of today's advanced busses provide a function called bus arbitration that regulates access to the bus by extension cards, controllers, and CPU . Devices that attach to these busses and arbitrate to take over the bus are called bus masters. Bus masters support also allows multiprocessor configurations of the busses to be created by the addition of bus master adapters containing a processor and its support chips.","Memory devices coupled to system bus  include random access memory (RAM)  and read only memory (ROM) . Such memories include circuitry that allows information to be stored and retrieved. ROMs  generally contain stored data that cannot be modified. Data stored in RAM  can be read or changed by CPU  or other hardware devices. Access to RAM  and\/or ROM  may be controlled by memory controller . Memory controller  may provide an address translation function that translates virtual addresses into physical addresses as instructions are executed. Memory controller  may also provide a memory protection function that isolates processes within the system and isolates system processes from user processes. Thus, a program running in user mode can normally access only memory mapped by its own process virtual address space. Stated differently, the program cannot access memory within another process's virtual address space unless memory sharing between the processes has been set up.","In addition, computing system  may contain peripherals controller  responsible for communicating instructions from CPU  to peripherals, such as, printer , keyboard , mouse , and data storage drive .","Display , which is controlled by display controller , is used to display visual output generated by computing system . Such visual output may include text, graphics, animated graphics, and video. Display  may be implemented with a CRT-based video display, an LCD-based flat-panel display, gas plasma-based flat-panel display, a touch-panel, or other display forms of various form factors. Display controller  includes electronic components required to generate a video signal that is sent to display .","Further, computing system  may contain network adaptor  which may be used to connect computing system  to an external communication network . Communications network  may provide computer users with means of communicating and transferring software and information electronically. Additionally, communications network  may provide distributed processing, which involves several computers and the sharing of workloads or cooperative efforts in performing a task. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","It is appreciated that exemplary computer system  is merely illustrative of a computing environment in which the herein described systems and methods may operate and does not limit the implementation of the herein described systems and methods in computing environments having differing components and configurations as the inventive concepts described herein may be implemented in various computing environments having various components and configurations.","Illustrative Computer Network Environment:","Computing system , described above, can be deployed as part of a computer network. In general, the above description for computing environments applies to both server computers and client computers deployed in a network environment.  illustrates an exemplary illustrative networked computing environment , with a server  in communication with client computers via a communications network, in which the herein described apparatus and methods may be employed. As shown in  server  may be interconnected via a communications network  (which may be any of, or a combination of a fixed-wire or wireless LAN, WAN, intranet, extranet, peer-to-peer network, the Internet, or other communications network) with a number of client computing environments such as tablet personal computer , mobile telephone , telephone , personal computer , and personal digital assistant . Additionally, the herein described apparatus and methods may cooperate with automotive computing environments (not shown), consumer electronic computing environments (not shown), and building automated control computing environments (not shown) via communications network . In a network environment in which the communications network  is the Internet, for example, server  can be dedicated computing environment servers operable to process and communicate data to and from client computing environments , , , , and  via any of a number of known protocols, such as, hypertext transfer protocol (HTTP), file transfer protocol (FTP), simple object access protocol (SOAP), or wireless application protocol (WAP). Each client computing environment , , , , and  can be equipped with one or more computing programs  such as a web browser (not shown), or a mobile desktop environment (not shown) to gain access to server computing environment .","In operation, a user (not shown) may interact with a computing program running on a client computing environments to obtain desired data and\/or computing programs. The data and\/or computing applications may be stored on server computing environment  and communicated to cooperating users through client computing environments , , , , and , over exemplary communications network . A participating user may request access to specific data and applications housed in whole or in part on server computing environment . Such data communication may be communicated between client computing environments , , , , and  and server computing environments for processing and storage. Server computing environment  may host computing programs, processes and applets for the generation, authentication, encryption, and communication of data and may cooperate with other server computing environments (not shown), third party service providers (not shown), network attached storage (NAS) and storage area networks (SAN) to realize such data transactions.","Thus, the apparatus and methods described herein can be utilized in a computer network environment having client computing environments for accessing and interacting with the network and a server computing environment for interacting with client computing environments. However, the apparatus and methods providing the mobility device platform can be implemented with a variety of network-based architectures, and thus should not be limited to the example shown.","Platform Dependent Linking:","Executable programs are generally platform dependent. Stated differently, a given program when developed is intended to run on a specific platform so that it has to be compiled, linked and built for the specific platform. Also, the resulting binary executable file produced from such a process will generally not run on a different platform. In conventional systems, it can be necessary to build separate dynamic libraries for each individual operating system. In the case where multiple operating systems are to be supported, the library code is to be built into multiple shared objects (dynamic libraries) i.e., one for each operating system, using dedicated tools. If the code does not explicitly reference items that are unique to an individual platform, then it can be sufficient to create the shared object library for a given operating system in question and have it function on several platforms derived from that operating system. In contrast, if the library code has explicit dependencies to platform-unique functions, then the shared object is to be built specifically for a given platform and, generally, will not operate on other platforms that lack the explicit dependency.","In the instance an operating system supports multiple platforms, the set of program components would typically include, but are not limited to the following components: an executable binary, uniquely tied to the platform; and an optional set of shared objects (dynamic libraries) built for the operating system on which the platform is based.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 3","FIG. 3"],"b":["300","350","345","305","310","315","320","315","325","345","325","340"]},"As is shown in , dynamic linker  receives dynamic executable object file  and dynamic library object file  as input to generate a fully linked and bound executable file  (e.g., runnable process). In operation, a computing application (e.g., program source file ) can call one or more functions from a cooperating dynamic linked library. When the function is called or when the program executes (as described above), dynamic linker  operates to dynamically locate the symbols found in memory representative of the function being called by the program application or those required for program execution.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIGS. 4 and 5","FIG. 4","FIG. 4"],"b":["485","1","475","2","480","400","405","415","405","410","485","430","445","430","450"]},"Likewise, program source file  is compiled at block  to create object file for platform A , and is compiled at block  to create object file for platform A . The object files resulting from compilation  are statically linked with stub file  to create the resulting dynamic executable object file Aexec  (e.g., executable on platform A ). Also, as is shown, the object files resulting from compilation  are statically linked with stub file  to create the resulting dynamic executable object file Aexec  (executable on platform A ). Dynamic linker  operates to link the dynamic library  with the dynamic executable object file Aexec  to create a fully linked executable  that is loaded into memory of operating system A  so to generate a runnable process on platform A . Similarly, dynamic linker  operates to link dynamic library  with dynamic executable object file Aexec  to generate fully linked executable  that is loaded into memory of operating system A  so as to generate a runnable process on platform A . In operation, either of the fully linked executables  or , respectively, can call functions or retrieve data from dynamic library .","With reference to ,  shows exemplary dynamic linking architecture  having library source file  and program source file . Library source file  is compiled at block  to create a dynamic library for operating system B . The resulting dynamic library object file  for operating system B  acts as input to import librarian  that processes the dynamic library object file  to produce import library stub file B .","Likewise, program source file  is compiled at block  to create object file for platform B , and is compiled at block  to create object file for platform B . The object files resulting from compilation  are statically linked with stub file  to create resulting dynamic executable object file Bexec  (e.g., executable on platform B ). Also, as is shown, object files resulting from compilation  are statically linked with stub file  to create the resulting dynamic executable object file Bexec  (executable on platform B ). Dynamic linker  operates to link the dynamic library  with the dynamic executable object file Bexec  to create a fully linked executable  that is loaded into memory of operating system B  so to generate a runnable process on platform B . Similarly, dynamic linker  operates to link dynamic library  with dynamic executable object file Bexec  to generate fully linked executable  that is loaded into memory of operating system B  so as to generate a runnable process on platform B . In operation, either of the fully linked executables  or , respectively, can call functions or retrieve data from dynamic library .","As is shown in , there is a common set of source code comprising an application program  and , respectively and a library file,  and , respectively. In an illustrative implementation, the application program can be written to run on four separate platforms, namely platforms A  and A  which are derived from a common operating system A , and platforms B  and B  derived from operating system B . The source code of the application  and  can maintain instructions which are specific to each of the platforms, platform A , platform A , platform B  and platform B , and can be written in a manner that the platform dependencies can be identified when the source code of the application  and  is compiled.","In the implementation provided, the source code for the library  and  generally does not maintain specific platform dependencies. In an illustrative operation, a library can be called by a cooperating application program and can operate as a dynamic library. As is shown in , each of the platforms ( and ) can require its own dynamic executable file Aexec , Aexec , that can be created by compiling the common application source file  through the platform specific compiler tools (e.g., compiler blocks  and ). In the illustrative implementation, a cooperating dynamic library  can be created once and dynamically linked to both executables A exec  or Aexec  to create a runnable process on each platform A  and A , respectively.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 5","b":["1","535","2","540","1","575","2","580","530","1","535","2","540","1","535","2","540","585","1","475","2","480","1","575","2","580","485","585"]},{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 6","FIG. 6"],"b":["600","605","610","615","607","670","605","607","620","615","670","670","610","640","655","665","630","635","645","650","660","605","625"]},"In an illustrative implementation, referencing , there are five platforms operating on three operating systems. Specifically, platform A , platform A  run on operating system A , platforms B  and B  run on operating system B , and platform C  runs on operating system C . With conventional methods, five different versions of each application program (one for each platform) plus three separate dynamic libraries (one for each OS) would be required to be created to ensure proper operation of a computer program. The herein described systems and method aim to ameliorate the shortcomings of the conventional practices by providing a single dynamic library that works across the five platforms and two operating systems. In an illustrative implementation, a single set of binary libraries can be created that are usable on all systems that incorporate a specific CPU architecture, regardless of the OS running on the CPU, thus taking advantage of the commonality at the top  and bottom layers  of .","The herein described systems and methods can be applied to various computing environments. In an illustrative implementation, the herein described systems and methods might be applied to desktop systems, which generally contain a processor from the INTEL\u00ae x86 family. Common operating systems on desktop PCs are MICROSOFT\u00ae WIDOWS\u00ae and Linux, which both have dynamic linking functionality. These operating systems, however, employ incompatible formats for their binary objects so that separate libraries are provided for Linux and WINDOWS\u00ae even though they can run on the same CPU.","In the context of mobile and embedded devices, the proliferation problem can be significantly greater. Specifically, mobile and embedded devices leverage a far greater number of operating systems, including but not limited to, Linux, WINDOWS\u00ae CE, PalmOS\u00ae, SymbianOS\u00ae, BREW\u00ae, Itron. At the CPU level , however, there can be considerable commonality based on a selected computer hardware architecture, such as the ARM RISC architecture. Current practices do not exploit such commonality, instead creating libraries that are tailored according to the OS or platform layer (e.g., ).","In an illustrative implementation, the herein described systems and methods can be applied to a selected computing environment market (e.g., a mobile device market) to distribute a single software library that can run on the computing environments operating on a selected hardware architecture (e.g., devices containing an ARM processor) irrespective of the software platform. Such approach can offer various commercial benefits to both software developers and customers, including but not limited to, reduced cost of developing and maintaining multiple versions of platform-specific libraries. Additionally, code quality can be established more rapidly through the cumulative experience with an identical component across multiple installations. Further, changes to libraries can be more thoroughly and efficiently tested with such approach. Device makers (e.g., cellular phone manufacturers) can employ a common library across their various product ranges if such library is proven on a single product range.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 7","b":["700","700","705","725","730","735","740","765","720","710","715"]},"In an illustrative operation, PIDL source  is compiled into standard object format at block  which creates PIDL object file . The PIDL object file can then be parsed by object parser  to generate source code for PIDL stub file . Similarly, application program interface (API) parser  may operate on API  to generate a PIDL_getSymbol function to allow a cooperating main application  access by the PIDL object file . As is shown in , the main application source , source code for dynamic loader\/linker , source code for PIDL stub file , and if being executed, the PIDL_getSymbol Source function  (e.g., the set of compiling components source code ) are compiled and built for a target platform at step . The resulting dynamic binary executable  leverages main application function , the PIDL_getSymbol function , and dynamic PIDL loader\/linker functions  to call functions and retrieve data from PIDL object file .","It is appreciated that although exemplary platform independent binary object and linking architecture  is shown to have various components in a particular configuration and described to perform specific operations that such description is merely illustrative as the inventive concepts described herein can be applied to any platform independent binary object and linking architecture having various components, configurations, and operations.","In an illustrative implementation, exemplary platform independent binary object and linking architecture  can operate according to the following method. PIDL object file  can be created in a standard object file format whose structure is well defined. Object parser  can operate to parse the standard PIDL object structure to create a stub file . Stub file  is generated as source code. Moreover, the source code for stub file  has no platform dependencies. Dynamic loader\/linker  can be written so that it can be included as part of main application program . Additionally, API , an interface by which PIDL libraries can call a main application, can be specified and converted into a source code function (PIDL_getSymbol)  for compilation with the main application . In the implementation provided, if the target platform is known, the combined source code (e.g., the set of compiling components source code ) can be compiled into a binary executable  for a given platform (not shown). At run time, dynamic loader\/linker  (e.g., compiled loader\/linker) can handle symbol resolution and relocation to bind dynamic binary executable  and PIDL file  as a fully runnable process.","As described, platform independence of the dynamic library can be achieved firstly by compiling the library source  code into a known object file format . In the contemplated implementation, PIDL source  does not contain any dependencies on a specific platform. An object file format (not shown) can typically contain several types of information, including but not limited to, header information such as the size of the code, object code generated by the compiler or assembler, relocation information for use by a linker \u2014when the addresses of object code are juggled by the linker, and symbol tables of symbols to be exported from this module or imported from other modules.  In an illustrative implementation, platform independent binary object and linking architecture  can leverage various object file formats including but not limited to, ELF (Executable and Linking Format), MICROSOFT\u00ae Portable Executable (PE) format, and other object formats (e.g., an object format designed specifically for the herein described systems and methods).","Conventionally, different operating systems and platforms use different object file formats. The linkers and loaders for these platforms expect to receive linkable objects in these pre-defined formats, and will reject other formats. When the platform also provides dynamic linking, the dynamic linker is part of the operating system and can be \u201chard wired\u201d to a unique object format.","The herein described systems and methods ameliorate this shortcoming by providing a generic loader\/linker . In an illustrative implementation, the generic loader\/linker  can be written to process object files in a selected object file format (e.g., ELF, or whatever other object format that is selected). In operation, the generic loader\/linker  operates to locate the symbols, relocation information, and other information within a PIDL object file . As is shown in , the deployment of the loader\/linker  can be accomplished through the creation of source code that is compiled with the source code of a cooperating main application . In this context, the linking and loading control is removed from the operating system and contained in the running executable. The dynamic loader\/linker  also can operate to process non-PIDL libraries. In this context, dynamic loader\/linker  can be designed to ascertain whether a dynamic library is a PIDL or non-PIDL type, and process the PIDL or non-PIDL library accordingly. In an illustrative implementation, when a non-PIDL library is being processed, control of linking and loading can be passed back to an underlying operating system.","In an illustrative implementation, the PIDL object file can be employed across disparate platforms without the need for rebuilding or recompiling. In this implementation, since the main application program is compiled together with the dynamic linker\/loader code for a chosen platform, and since control of the linking is not dependent on the platform and, instead, placed within the executable, the linking of the PIDL at run time can be achieved on disparate platforms without the need to re-compile or re-generate the PIDL object.","As is shown in , stub file  is created as source code. In comparison with conventional practices, with reference to , the conventional approach is to produce a library stub as an object file  that defines both the exported and imported global symbols. In operation, the stub file is generally small, and it allows the linker to resolve symbols in the combined\/assembled program. In operation, the main program can call named functions that exist in the dynamic library, and the dynamic library can also call functions in the main program. For the combination to work correctly, the function calls can be resolved and relocated with the proper addresses once the loader has placed all the object code components into memory of a computing environment.","As is shown in , code for functions or symbols A and B can be located in the main program , and functions C, D can be located in dynamic library . In an illustrative implementation, in order for dynamic library  to call A and B, or main program  to use library functions C or D, the symbols and location of all the functions are resolved in the combined program. In the illustrative implementation, this operation can be performed by an exemplary linker (not shown). With conventional practices, a stub library (e.g.,  of ) can hold the information needed to bind the functions exported (e.g., C and D) from the library and those functions called by it (e.g., A,B). It is appreciated, with reference to , that with conventional practices, architecture  links the library stub  to the pre-compiled object files of the main program in a static linking stage to create binary executable . Later, when the binary executable is loaded for execution, it is able to dynamically link with dynamic library  under control of the dynamic linker . With conventional approaches, the dynamic linker is generally part of an operating system. In such context, since different systems use their own linkers and object formats, what results is a platform dependent library stub file. As such, a single library requires different stub files for different operating systems.","The herein described systems and methods aim to ameliorate the shortcomings of existing practices by providing a stub file as source code files. With reference to , stub library  is created using object parser . Object parser  parses through the PIDL object file  to extract the symbol names and properties, and creates a source file  (e.g., in a high level language including but not limited to, \u201cC\u201d language or equivalent) as the output of the parser. In an illustrative implementation, and as shown in , the generated source code for PIDL stub file  is platform independent and can be subsequently compiled as part of the main application program (along with the dynamic linker code). By including the PIDL stub information at the compile stage, the symbols exported from the PIDL can be declared in a resulting dynamic executable.","It is appreciated that creating the stub file as source code rather than object code, as with conventional approaches, indicates that the library information contained in the stub is to be included at the compilation stage of the build process. By contrast, conventional approaches incorporate the stub at the static linking stage, after the main application has already been compiled. The static linker is under control of the operating system, which requires the linked objects to be in an object format that is specific to the operating system, which format generally is not recognized by the linker of a different operating system. To achieve a platform independent solution, the reliance on the linking stage is required to be removed. With the herein described systems and methods, such goal can be achieved by providing the stub file as source code to be compiled rather than object code to be linked.","It is appreciated that the herein described systems and methods allow a main application access to dynamic libraries deployed as PIDL objects given that the main application is compiled with the dynamic linker and the appropriate PIDL stub files. The herein described systems and methods also account for the instance when the PIDL requires access to functionality in the main application (as described in ). In such context, an API ( of ) (Application Programming Interface) of functionality exposed by the main application to the PIDL libraries can be first specified and published (so that the PIDL can employ the exposed functions). The API ( of ) can then be parsed to generate a source code function PIDL_getSymbol ( of ) which can be compiled as part of the main application (as described in ). In an illustrative implementation, the PIDL_getSymbol function can return the address of a named symbol exposed by the API, and can be used by the dynamic linker during relocation to substitute addresses of the symbols called by the PIDL. As such, when a PIDL calls a function within the main application, linkages and addresses have already been resolved by the dynamic linker ( of ).","Furthermore, the dynamic linker can allow run time linking of the PIDL objects. The main application source files can be compiled for the target platform, as shown in , to produce a binary executable containing the dynamic linker and PIDL_getSymbol functions as well as the main program. The PIDL libraries can be created and are available as object files.","In an illustrative operation of an illustrative implementation, when the main program starts running, it can be placed in memory by a platform loader. As execution begins, the main program determines whether it makes a call to a symbol which is external to itself. Such call can invoke the PIDL linker, which first determines the name and path of the library containing the called function. If the library is a regular platform specific dynamic library like a WINDOWS\u00ae DLL (and not a PIDL), the linker passes control to the regular platform library loader, when one exists. If instead, however, the called function is within a PIDL, it can be identified by symbol name using the PIDL stub file which contains the symbols it exposes and which has been compiled into the main program so the symbol references are defined.","The linker, responsive to the function call, can create a programmed structure to represent the PIDL object. It then can interrogate the object to find the code size (e.g., defined in a field within the object file format so readily available), can allocate a fixed block of memory of the appropriate size, and can load the PIDL file into the allocated memory.","The linker then operates to relocate the symbol addresses in memory. The internal symbols within the PIDL are relocated. In operation, a binary file contains the address of the symbol within the object code, but generally operates under the assumption that there is a base starting address of zero for the library code. The PIDL, however, is loaded at a different address, which can be ascertained since the PIDL is loaded into memory. Relocation by the linker can involve adjustment of the symbol addresses to account for the actual starting address of the memory block.","After relocating the internal PIDL symbols, the linker can then relocate all of the symbols called by the PIDL that are external to it such as functions contained in the main application. For these symbols, the linker can call the PIDL_getSymbol function, with the name of the external symbol to be relocated as the argument. Since this function contains a list of all symbols exposed by the application API, it is able to match the name and return the actual address of the named symbol.","At this stage, the PIDL maintains the correct addresses of the internal and external symbols it exports or imports. After the relocation is complete, the relocated addresses of the symbols that are exported by the PIDL can be passed back to the linker. The main program has access to the relocated symbols such that when a call is made from outside the PIDL to one of the PIDL symbols, the correct symbol address is used.","The herein described systems and methods can be employed with several libraries (e.g., PIDLs) linked to a single application. These libraries can make calls from one to another, using the functions and symbols they export. With multiple libraries in use, the linking mechanism can be applied homogenously\u2014i.e., the dynamic library is saved in a standard object format, a stub is generated in source format, and the main program is compiled with the stubs for the PIDL libraries it uses. The dynamic loader\/linker loads each library at load time or at run time as it is called, and the information to perform relocation and resolve symbols between PIDL libraries and with the main program is handled by the dynamic loader\/linker (e.g.,  of ) compiled into the program.","Platform Independent Dynamic Library:",{"@attributes":{"id":"p-0086","num":"0085"},"figref":["FIG. 9","FIG. 7"],"b":["900","910","915","920","920","925"]},"However, if at block  it is determined that the called function is in a cooperating PIDL, processing proceeds to block  where a programmed structure for the PIDL object is created so that the information in the PIDL object file, with its predetermined file format, can be interrogated. The size of the PIDL object is then determined at block , From there, processing proceeds to block  where a memory block is allocated, and the PIDL object file can be loaded into the allocated block. The internal symbols of the PIDL are then relocated at block  using symbol tables and load addresses extracted from the object file. The external PIDL symbols are then relocated using API (PIDL_getSymbol) function calls at block . From there, the cooperating computer program is informed by the PIDL linker of PIDL symbol addresses at block . From there, linking is deemed complete as the symbols and calls are resolved and relocated at block . Processing then terminates.","Mechanism For Dynamic Linking In Constrained Environment:","Some operating systems do not provide a dynamic linking capability. When libraries are used on these systems, the libraries are statically linked\u2014i.e., the libraries can be bound to executable binaries at link time. The executable can also be static as it can be ready for execution without additional linking and, moreover, may not change after linking is complete. Generally, a static linked library can not change without impacting (e.g., breaking or stopping) the underlying programs to which it is bound. Also, since the addresses of routines and data in the library are bound into the program, changes in these addresses will cause the bound program to malfunction.","The herein described systems and methods ameliorate the shortcomings of existing practices by providing dynamic execution on operating systems that do not natively support dynamic execution. In an illustrative implementation, dynamic linking can be considered the ability to defer linking until run time or load time, or the ability for an executable program to use libraries to which it is not statically linked. Additionally, the herein described systems and methods allow the linking of binary object formats that are not natively supported by a given operating system.","In an illustrative implementation, a large program may be partitioned into a main application plus a set component libraries that provide the supporting functionality. With conventional practices, the program, on the whole, would be provided as a single static executable. As such, if changes to the program are needed, an entire new executable would be built and distributed to replace the unmodified version. In contrast, in an illustrative implementation, the components can be supplied, once, independently of the application that uses them. As such, the application can be of smaller size and if a new or modified application is required, only the application, itself, would be required to be rebuilt without requiring the rebuilding of the associated libraries.","Conversely, in the implementation provided, if the application remains unchanged but one of the components changes, the new component can be substituted in the place of the earlier version without change to other components. Provided the symbol names of the revised version are the same, the new component version can be linked to the original application program and other components at run time. In an illustrative implementation, the dynamic linker takes care of the address relocation. In the case the symbols are at different addresses in the new component version, the addresses can still be resolved and relocated at run time.",{"@attributes":{"id":"p-0092","num":"0091"},"figref":["FIG. 10","FIG. 10"],"b":["1000","1020","1030","1010"]},"All of the functions and\/or operations performed at blocks -, described above, can be performed at build time, that is prior to deployment and execution of the program. In a constrained environment that does not natively support dynamic linking, subsequent co-operation or interaction between the built executable and external libraries is generally not achievable. The illustrative implementation, by contrast, provides additional blocks  to  to provide dynamic operation at run time. The built executable can be instructed to begin execution at block , and can load into memory as normal under control of the native operating system at block . The dynamic linker\/loader, contained within the executable as a result of block , can operate to load and bind the PIDL library with the running application. (See  blocks  to ). The resulting program, fully bound with all library calls resolved can then run at block .","It is appreciated that although the dynamic linking operation in a constrained environment is shown to operate in a manner wherein the libraries are platform independent such description is merely exemplary as the inventive concepts described herein can be applied to libraries having platform dependence.","Code Components Mechanism:","Certain operating systems (OS) used in mobile computers (e.g., such as PalmOS, SymbianOS) enforce constraints on the use of global variables and static writable variables. Such constraint can be present so that the operating system can avoid fully handling code relocation and address management of global variables. Because static variables are held in the same segment of memory as global variables, writable static variables may also be prohibited by the operating system. When computer program code is written with such an operating system in mind, it is of course possible to follow the constraints and produce compatible code. However, when a piece of code such as a library has been written for a different platform without such constraints, the code may contain violations of the rules to the extent that it will even compile or build on the constrained operating system. This creates a restriction on the ability to use third party libraries and pre-written code on some operating systems, thereby reducing their flexibility. It makes for less productive development, because time has to be spent modifying existing code to obey the operating system constraints, or in some cases totally re-writing it from scratch.","The herein described systems and methods allow operating system constraints to be side-stepped. In an illustrative implementation, a library whose source code violates the constraints of an operating system can be compiled and built into a PIDL format. The PIDL library can then be combined with an application program and run on the constrained operating system. The unique dynamic loading and linking mechanism of the herein described systems and methods allocates a memory block for the PIDL. Furthermore, in this implementation, the global variables are not treated as global beyond the memory area of the PIDL.","As such, in this implementation, the global variables defined within the library can be confined within this memory block and are not visible to the operating system as global variables. Static variables can also be confined to the allocated memory block and do not rely on operating system intervention. What results is a side-stepping of an operating system's inability to relocate such global and static variables. In this implementation, a PIDL loader\/linker can perform the relocation of the library variables to render them functional.",{"@attributes":{"id":"p-0098","num":"0097"},"figref":["FIG. 11","FIG. 11"],"b":["1100","1110","1120"]},"In an illustrative implementation, at run time, an instruction to execute the application program can be received at block . The executable can be loaded as normal by the host computing environment at block . The PIDL can be provided for use by the computing environment at block . On identifying the dependence between the application program and the library, the dynamic linker\/loader (built into the program at block ) can allocate a memory block at block  and loads the PIDL into the allocated block. As shown at block , the global and writable static variables defined in the library have their scope restricted to the allocated memory block and are not accessible by name from beyond this memory block. They can be available to all of the library functions because these can also reside within the allocated memory block, so that the library operates correctly within the computing environment even though it violates constraints imposed under conventional operation of the environment. Linking of the PIDL is then completed at block  to produce a fully bound runnable process.","It is appreciated that although the code components feature is shown to operate in a manner wherein the libraries are platform independent that such description is merely exemplary as the inventive concepts described herein can be applied to libraries having platform dependence.","Code Loading Mechanism:","With conventional software development, an object oriented approach can be taken. Rather than call a function to perform a specific task, an object can be created and a method of the object can be called to perform a desired task. Such approach can be beneficial as several such objects can be created, and several tasks can be active simultaneously. There are many situations where it would be beneficial to execute multiple instances of a computational task. For example, the case where a library exists to play and render a movie clip within a document. When such a document contains two such movie clips, it is convenient to play them simultaneously by running two instances of a common code object. In the absence of an object oriented approach, a developer may encounter the situation where an object performs a task successfully, but encounter difficulty in allowing several of the same objects to execute concurrently.","Although a developer can choose to write in an object oriented style, such choice may be nullified when integrating third-party code. In particular this applies to code deployed as a library, where the library manipulates data and contains access functions to this data. In an illustrative example, non object-oriented code can employ global variables, and one time initializations of static variables. In such context, in certain computing environments, this prevents the computing environment from running more than one invocation of a library object within the same process, because a single process may keep only one set of the data employed by the module or library. Specifically, two invocations of the same object could interact badly with each other through their shared use of named global variables. Alternatively, a library may be written in a way that it can be executed once, but even when that execution completes, an attempt to execute a second time will fail because statically initialized variables no longer have the necessary initial values. This is because static variables are initialized at build time, by the compiler, and not at run time, so if an initialized variable is changed during execution, a subsequent execution retains the changed value and starts with a value different from the initialized value needed for proper operation.","The herein described systems and methods aim to ameliorate these shortcomings by providing the PIDL loading mechanism described above. The restriction to use a single set of data within a process is removed, by allowing multiple instances of the PIDL to utilize their own \u201cprivate\u201d copies of the data within a confined memory block, thus circumventing the interactions and conflicts that cause malfunctions in the conventional approach. This method allows multiple instances and repeat execution even within the same process. It also opens the possibility for multiple concurrent execution on an environment that does not allow multiple processes. In an illustrative implementation, the PIDL treats global variables as addresses within a dynamically allocated buffer. A single PIDL can be loaded multiple times, and then each copy will have its own individual and independent copies of global variables, thereby avoiding problematic interactions. Similarly, each time a library is to be executed, a copy is loaded from file hence it contains the correctly initialized value of static variables.",{"@attributes":{"id":"p-0104","num":"0103"},"figref":"FIG. 12","b":["1200","1210","1220"]},"In the illustrative implementation, at run time, an instruction to execute the application program can be received at block . The executable can be loaded by the host computing environment at block . The PIDL can be provided for use by the computing environment at block . On identifying the dependence between the application program and the library, the dynamic linker\/loader (built into the program at block ) can allocate a memory block at block , can load the PIDL into the allocated block and can link the PIDL with the cooperating application. A check can then be performed at block  to determine if a new instance of a PIDL is to be loaded onto the computing environment. If the check at block  indicates that a new instance of the PIDL is to be loaded, processing can then proceed to block  where a new instance of the PIDL can be loaded in a distinct memory block and can be linked to the computer program. However, if at block  it is determined that a new instance of PIDL is not to be loaded, processing reverts to the input of block  and proceeds from there.","It is appreciated that although the code loading feature is shown to operate in a manner wherein the libraries are platform independent that such description is merely exemplary as the inventive concepts described herein can be applied to libraries having platform dependence.","Extensible Run Time Environment for Closed or Constrained Platforms:","Some computing devices operate as a closed computing environment, such that the device may only execute those programs and applications that are resident when the device is shipped from a device manufacturer or supplier. Such devices(e.g., mobile wireless devices) can contain an operating system that hosts the resident programs, but other applications cannot be added without restriction, even when the application is created for the host operating system. An example of such a closed platform is the large category of mobile handsets known as Feature Phones, which are provided with a fixed set of features (such as camera functions) in addition to voice, but these features are fixed and may not be extended by the user. The device is closed to after-market applications due to the inability or restriction of the computing platform to add functionality.","By contrast, an open computing platform enables applications written for the operating system to be added and executed in daily use. The MICROSOFT\u00ae WINDOWS\u00ae platform may be considered as an example of an open platform for personal computers. In the arena of mobile handsets, the equivalent category of open platforms is known as smartphones which provide an environment for adding applications, without restriction, to execute on the device. Examples of smartphone platforms include Microsoft \u00ae SmartPhone, Symbian UIQ and Linux.","A third category of mobile handsets exists, which are Feature Phones equipped with a Run Time Environment (RTE). Examples of such run time environments include the Java J2ME (Java 2 Micro Edition) and BREW (Binary Runtime Environment for Wireless) environments. The RTE allows the handset to add new functionality in the form of applications created for the RTE\u2014Java applets in the case of J2ME, and Brew authenticated applications in the case of the Brew environment. These applications differ from those that run on an open platform, because the applications are built for the RTE (e.g., and in some instance have to be authenticated by the RTE for proper operation) and not for the native OS, as in a smartphone. As such the RTE-enabled feature phone has limitations compared to the smartphone, some of which may be for technical reasons while other restrictions are commercially motivated.","For example, hardware device manufacturers, network operators, or RTE vendors, can enter into exclusive or semi-exclusive arrangements with application providers to provide applications and\/or updates to applications to their specific hardware devices. Generally, the applications that run on a RTE are restricted in their ability to interface with the full device functionality. For example, the API (application programming interface) allowing control of the network stack, or of the storage peripherals on the device may not be accessible from the RTE. This is sometimes described as the RTE operating in its own \u201csandbox\u201d within the native computing environment. Comparatively, in an open platform (e.g., SmartPhone) each executable can run in its own process, and, generally, the operating systems of such open platforms can expose all of the device functionality to each of the running processes. Furthermore, some environments (Brew is one example) allow RTE applications to be added only across a network, and prevent applications being loaded into the device by means of a storage card. This can be problematic when loading large applications, such as large games, which require a lot of bandwidth and time to load across a network.","The herein described systems and methods ameliorate the shortcomings of existing practices by providing a means to add functionality to a closed platform. In an illustrative implementation, added functionality is provided to the hardware device as a PIDL. The closed platform can be created to include a \u201clauncher\u201d program, which comprises the dynamic linker\/loader and PIDL stub file previously described, along with an application that cooperates with the PIDL. The launcher program can be built for and executes on the host operating system within the closed device, and can be resident in the device at the time of shipment. The combination of the launcher application plus the PIDL library serves to allow new functionality to operate on the closed device, even though this functionality is not present when the device ships, as follows. At run time, the PIDL can be made available to the device and the launcher application is started. The dynamic linker\/loader within the launcher application, using information from the stub files, can act to load, link and bind the PIDL to the cooperating launcher program resident on the hardware device and running on the OS of the device. All of the functionality in the PIDL can therefore be exposed to the executing program within the device, thus achieving the desired result of making new functionality available on the closed device. In this context, the PIDL side steps the imposed hardware devices' constraints and operates to perform dynamic execution (as described above).","It will be understood that the \u201clauncher\u201d application may itself provide a set of functionality and does not depend for its operation on the presence of the PIDL. Similarly, the same launcher application may enable very many different types of new functionality, each provided in a separate PIDL library whose stub is compiled with the launcher application. With such an illustrative implementation, it can possible to simulate a kind of run time environment, where varied functions may be added dynamically.","By way of illustrative example, a launcher application may contain a software games console and one or more games. Further games may be added in the form of PIDL libraries, one PIDL for each different game, which are playable through the launcher application when the PIDL is downloaded to the device. Alternatively, the launcher application may provide basic messaging functions such as SMS. Further functions, such as email or multimedia messaging; video and audio players; browsing functions; file viewing; photo albums; PIM (personal information management); and other types of function may be deployed on the device as PIDL libraries which inter-operate with the launcher.","In another illustrative implementation, the closed device may be shipped with two or more \u201clauncher\u201d applications, each of which is built to recognize a specific set of PIDL libraries. In this way, the scope of add-on functionality can be extended and organized in significant ways.","The herein described methods and systems overcome existing practices when employed on a platform that otherwise is a closed platform. The possibility of offering after-market solutions can create greater utility for the device user, and increased revenue opportunities for the device or network provider. Since the method does not involve adding functions as executables (e.g., PIDL libraries can exist as data, not executable programs) the \u201cclosed-ness\u201d of the platform can be controlled since it remains closed to normal applications created as executables for the device operating system. The device provider may determine in advance the range of additional functionality to be offered, since only those functions whose PIDL stub is compiled into the launcher will be operable. What results can be a set of dynamic security and commercial controls.","In an illustrative implementation, the PIDL can be provided to the device in several ways, including by download across a wireless or wired network, by data transfer from a tethered PC, and from a storage card inserted into the device. Another unique aspect of loading functions as PIDL objects rather than executable applications is that the PIDL may be safeguarded by Digital Rights management (DRM) techniques. The PIDL as a data file can be amenable to DRM technology unlike an executable program. This well established security scheme gives flexibility and confidence to both operators and users when adding functionality under a commercial transaction.","When combined with the platform independent nature of the PIDL object and linking scheme, as previously described, a device maker or network provider may offer add-on functionality as a single PIDL object across their entire range of devices, even when those devices employ different host platforms or operating systems. By avoiding the need to customize an application or library for each different platform, and simply offering a platform independent dynamic library (PIDL) that works equally on all platforms, the operator can be positioned to realize efficiencies and economies of scale.","The same methods and systems, described above with reference to a closed platform (such as a Feature Phone) may also be employed in platforms that support a run time environment (e.g., Java or Brew). This arrangement offers two ways for the device to add functionality\u2014the conventional scheme of downloading applets or authenticated applications for consumption by the RTE, and an alternative implementation of loading functionality as PIDL libraries under control of a launcher application resident on the device.","In comparison to each other, the PIDL based scheme can provide added features that may not be present with the conventional run time environment. Stated differently, several pieces of functionality may be run concurrently when they are deployed as separate PIDLs within a single launcher application. In this context, with a PIDL implementation, the PIDL functions can execute under a common launcher process and as such can be available concurrently. Additionally, with the PIDL loading approach, there can be greater flexibility in the means of loading the functionality onto the device, including loading from storage card which is not allowed under certain run time environments (e.g., Brew). In the context of DRM, DRM can be realized when deploying the PIDL data library, a technique that may not be possible when deploying an executable application or applet to a run time environment. Also, if so desired, the device or network provider may also restrict the functions that can be added, to those functions that are recognized by the launcher application which ships with the device.","Unlike the strictly closed environment where the launcher is included at build time, a device having a run time environment (RTE) can take advantage of the ability to download the launcher application as an after-market procedure. When deployed in this way, the above-described dynamic library (DL) based scheme can co-exist with the RTE, whilst offering the above benefits that the RTE on its own fails to provide. In particular, the DL library can access device functions and APIs (such as the storage card) which are not accessible via the RTE. With such a scheme, a launcher application can thus be downloaded across an exemplary communications network to the device RTE, where the launcher acts as a proxy to allow further functionality to be added by other means such as storage card. Similarly, an RTE can often impose a maximum size for applications to run under the RTE. This maximum size can be circumvented to enable larger programs to be deployed to the device, by downloading a launcher application that itself is small and within a selected size limit, but which adds in DL libraries with functional code that exceed the limit. Since the DL libraries are loaded as binary data objects rather than as RTE applications, the RTE size limit does not apply to them.",{"@attributes":{"id":"p-0121","num":"0120"},"figref":["FIG. 13","FIG. 13"],"b":"1300"},"In an illustrative implementation and as shown in , a PIDL library object can be created at block  containing the add-on functionality, and a stub file generated as source code at block . The launcher application is compiled and built at block , containing the as-shipped functions from block , together with the stub file  and a dynamic linker\/loader. As indicated at block , the launcher application can be included on the device at the time the device is shipped for use.","Following shipment of the device, the authorization to employ the add-on functionality can be provided at block . As may be understood, this authorization can be predicated on a commercial transaction, or other criteria according to the circumstances of deploying the device. Following authorization, the PIDL library can be made available to the device at block , by suitable means which may include but are not limited to download to device memory, network transfer, or provision from a storage device or card attached to the device. The launcher application, present on the device, can then be run at block . From there a check can be performed at block , to determine if the PIDL object is available to the device. This check can be performed by the dynamic linker\/loader within the launcher application, using information from the PIDL stub file compiled at block . If the check at block  indicates that the PIDL is not available to the device, processing proceeds to block  where the launcher application continues to execute but with a scope of functionality identical to the functionality of the device as shipped (i.e., excluding the further functionality contained in the PIDL).","However, if at block , the check indicates that the PIDL library is available to the device, processing proceeds to block  where the PIDL is loaded, linked and bound to the launcher application. By this step, the scope of functionality accessible from the launcher application is extended, as shown in block , to include the functions present in the PIDL.",{"@attributes":{"id":"p-0125","num":"0124"},"figref":"FIG. 14"},"As is shown, processing begins at block  where a program is portioned into a launcher application and add-on functionality. From there processing can fork to block  or . At block  a dynamic library (DL) object for add-on functionality is created. At block  the launcher application, linker\/loader, and stub file are compiled and built. From block , processing further splits. From block , processing can proceed to block  where a stub file for the DL is generated as source code. From there, processing proceeds to block  and proceeds from there. Also, from block , processing can proceed to block  where the DL is provided to a cooperating device (e.g., mobile telephone). From block , processing proceeds to block , discussed below.","From block , processing proceeds to block  where the launcher application is downloaded to a device. A check is then performed at block  to determine if the downloaded launcher application is authorized to operate on the device to which it was downloaded. If the check at block  indicates that the launcher application was not authorized, processing terminates at block . However, if at block  it is determined that the launcher application is authorized to operate on the device, processing proceeds to block  where the launcher application is run. A check is then performed at block  to determine if the DL is available to the device via block , discussed above. If the check at block  indicates that the DL is not available to the device, the scope of the launcher application remains as shipped and does not extend to additional functionality provided by a DL. However, if at block , the check indicates that a DL is available to the device, processing proceeds to block  where the linker\/loader loads and binds the DL with a running application. Processing proceeds to block  and continues from there. The scope of the launcher application is then extended to include DL functions at block .","It is appreciated that the processing described in  can be applied to download a single launcher application or to download multiple launchers. Such launchers can operate to add selected functionality according to the library stub files that can be included at the time of the launcher application build.","In sum, the herein described apparatus and methods provide a platform independent binary object operable across disparate computing environments operating various platforms. It is understood, however, that the invention is susceptible to various modifications and alternative constructions. There is no intention to limit the invention to the specific constructions described herein. On the contrary, the invention is intended to cover all modifications, alternative constructions, and equivalents falling within the scope and spirit of the invention.","It should also be noted that the present invention may be implemented in a variety of computer environments (including both non-wireless and wireless computer environments), partial computing environments, and real world environments. The various techniques described herein may be implemented in hardware or software, or a combination of both. Preferably, the techniques are implemented in computing environments maintaining programmable computers that include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. Computing hardware logic cooperating with various instructions sets are applied to data to perform the functions described above and to generate output information. The output information is applied to one or more output devices. Programs used by the exemplary computing hardware may be preferably implemented in various programming languages, including high level procedural or object oriented programming language to communicate with a computer system. Illustratively the herein described apparatus and methods may be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language. Each such computer program is preferably stored on a storage medium or device (e.g., ROM or magnetic disk) that is readable by a general or special purpose programmable computer for configuring and operating the computer when the storage medium or device is read by the computer to perform the procedures described above. The apparatus may also be considered to be implemented as a computer-readable storage medium, configured with a computer program, where the storage medium so configured causes a computer to operate in a specific and predefined manner.","Although an exemplary implementation of the invention has been described in detail above, those skilled in the art will readily appreciate that many additional modifications are possible in the exemplary embodiments without materially departing from the novel teachings and advantages of the invention. Accordingly, these and all such modifications are intended to be included within the scope of this invention. The invention may be better defined by the following exemplary claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The platform independent dynamic object and methods of use are further described with reference to the accompanying drawings in which:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
