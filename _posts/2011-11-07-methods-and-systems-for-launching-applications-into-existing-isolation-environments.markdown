---
title: Methods and systems for launching applications into existing isolation environments
abstract: Methods and systems that can launch applications into existing isolation environments do so by executing a run module on a computing machine to intercept requests to execute an application. A client communicating with the computing machine generates requests to execute an application on the computing machine. A run module identifies a profile associated with the requested application and queries an application delivery service to identify at least one isolation environment that corresponds to the profile. The run module receives from the application delivery service a response that identifies a first isolation environment associated with the application, and issues a command to a launch module to launch the application into the first isolation environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08326943&OS=08326943&RS=08326943
owner: Citrix Systems, Inc.
number: 08326943
owner_city: Fort Lauderdale
owner_country: US
publication_date: 20111107
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This present application claims priority to and is a continuation of U.S. Non-Provisional application Ser. No. 12\/434,629 entitled \u201cMethods and Systems for Launching Applications into Existing Isolation Environments, filed on May 2, 2009 which is incorporated herein by reference in its entirety.","This invention relates generally to remotely executing applications on a computing machine. More specifically, this invention relates to remotely executing applications in isolation environments on a computing machine.","There currently exist methods for isolating applications within isolation environments and according to an application profile, a user session or another parameter that can be used to isolate applications. When an application executes within an isolation environment, typically that application cannot communicate with other applications not executing within the isolation environment. Permitting an isolated application to communicate with an application outside of the isolation environment may require an administrator to package the isolated application and the other application into a larger single isolation image or profile.","Creating an isolation environment requires creating an image of disk data, communicating that image to a kernel mode component and to user mode components. This process can take a great deal of time and require many resources. In particular, creating an image of disk data requires parsing data structures on a disk, a process that becomes increasingly more resource intensive as the number of profiles executing on a disk increases. Thus, creating a larger single isolation image or profile each time an application wishes to communicate with another application that does not reside in the application's isolation environment, can be time and resource intensive. Methods and systems are therefore needed that permit applications executing in different isolation environments to talk with one another without requiring the creation of a separate isolation image or profile.","In its broadest interpretation, this disclosure describes methods and systems for launching an application into an existing isolation environment. Launching applications into an environment where application sociability and compatibility can present problems, often requires executing the application within an isolation environment or within an isolation scope within an isolation environment. Creating an isolation environment can be a time consuming and resource intensive process, therefore systems and methods are needed to decrease the amount of time and resources required to launch an application into an isolation environment. Implementing methods and systems that identify a pre-existing isolation environment associated with an application and launch the application into that pre-existing isolation environment can both reduce the amount of time and the amount of resources needed to launch the application into an isolation environment.","In one aspect, described herein is a method for launching applications into existing isolation environments. The method can be carried out in part by a run module executing on a computing machine in communication with a client computing machine. The run module receives a request to execute an application on the computing machine; the request generated by a user of the client. The run module identifies a profile associated with the requested application and queries an application delivery service executing on the computing machine to identify at least one isolation environment corresponding to the profile. Upon querying the application delivery service, the run module receives from the application delivery service a response that identifies a first isolation environment associated with the application. The run module, upon obtaining information about the first isolation environment, issues a command to a launch module executing on the computing machine to launch the application in the first isolation environment.","In one embodiment, the run module receives an identifier, from the application delivery service, associated with the first isolation environment. The received identifier can in some embodiments be a name of a first isolation environment. In some embodiments, the run module responds to receiving the first isolation environment identifier by querying a runtime object table for an address of the first isolation environment, wherein the run module queries the runtime object table using the first isolation environment identifier.","The first isolation environment, in some embodiments, exposes a communication interface for communicating with components executing on the computing machine, the communication interface generated by an inter-process mechanism. Commanding the launch module to launch the application can further comprise transmitting a location of the application to the exposed communication interface.","In one embodiment, identifying a first isolation environment further comprises identifying an address associated with the first isolation environment. The first isolation environment address can in some embodiments comprise a profile version associated with the first isolation environment and in other embodiments can comprise a user session identifier associated with the first isolation environment.","In one embodiment, the method can comprise failing to identify an isolation environment corresponding to the profile and launching, by the run module responsive to failing to identify an isolation environment, a lunch module in a suspended mode. The run module then issues a command to the application delivery service to isolate the launch module, sends application information to the launch module, and issues a command to the launch module to resume execution.","In one aspect the method can be carried out by a system comprising a computing machine communicating with a client generating a request to execute an application on the computing machine, the application associated with a profile. The system further comprises an application delivery service, launch module and run module executing on the computing machine. The run module receives the client request and queries the application delivery service to identify at least one isolation environment corresponding to the profile. Upon querying the application delivery service, the run module receives from the application delivery service a response identifying a first isolation environment associated with the application, and issues a command to the launch module to launch the application into the first isolation environment.","In other aspects, the methods and systems can be carried out by a computer readable medium having instructions executable by a processor to launch applications into existing isolation environments.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 1A","b":["101","102","102","106","106","104","102","102","106","106","102","10","102","102","106","106","102","106","106","102","102","106"]},"A client machine  within the computing environment may in some embodiments, be referenced by any one of the following terms: client machine(s) ; client(s); client computer(s); client device(s); client computing device(s); local machine; remote machine; client node(s); endpoint(s); endpoint node(s); or a second machine. The server  in some embodiments may be referenced by any one of the following terms: server(s), local machine; remote machine; server farm(s), host computing device(s), or a first machine(s).","The client machine  can in some embodiments execute, operate or otherwise provide an application that can be any one of the following: software; a program; executable instructions; a web browser; a web-based client; a client-server application; a thin-client computing client; an ActiveX control; a Java applet; software related to voice over internet protocol (VoIP) communications like a soft IP telephone; an application for streaming video and\/or audio; an application for facilitating real-time-data communications; a HTTP client; a FTP client; an Oscar client; a Telnet client; or any other type and\/or form of executable instructions capable of executing on client machine . Still other embodiments may include a computing environment  with an application that is any of either server-based or remote-based, and an application that is executed on the server  on behalf of the client machine . Further embodiments of the computing environment  include a server  configured to display output graphical data to a client machine  using a thin-client or remote-display protocol, where the protocol used can be any one of the following protocols: the Independent Computing Architecture (ICA) protocol manufactured by Citrix Systems, Inc. of Ft. Lauderdale, Fla.; or the Remote Desktop Protocol (RDP) manufactured by the Microsoft Corporation of Redmond, Wash.","In one embodiment, the client machine  can be a virtual machine C such as those manufactured by XenSolutions, Citrix Systems, IBM, VMware, or any other virtual machine able to implement the methods and systems described herein.","The computing environment  can, in some embodiments, include more than one server A-N where the servers A-N are: grouped together as a single server  entity, logically-grouped together in a server farm ; geographically dispersed and logically grouped together in a server farm , located proximate to each other and logically grouped together in a server farm . Geographically dispersed servers A-N within a server farm  can, in some embodiments, communicate using a WAN, MAN, or LAN, where different geographic regions can be characterized as: different continents; different regions of a continent; different countries; different states; different cities; different campuses; different rooms; or any combination of the preceding geographical locations. In some embodiments the server farm  may be administered as a single entity or in other embodiments may include multiple server farms . The computing environment  can include more than one server A-N grouped together in a single server farm  where the server farm  is heterogeneous such that one server A-N is configured to operate according to a first type of operating system platform (e.g., WINDOWS NT, manufactured by Microsoft Corp. of Redmond, Wash.), while one or more other servers A-N are configured to operate according to a second type of operating system platform (e.g., Unix or Linux); more than one server A-N is configured to operate according to a first type of operating system platform (e.g., WINDOWS NT), while another server A-N is configured to operate according to a second type of operating system platform (e.g., Unix or Linux); or more than one server A-N is configured to operate according to a first type of operating system platform (e.g., WINDOWS NT) while more than one of the other servers A-N are configured to operate according to a second type of operating system platform (e.g., Unix or Linux).","The computing environment  can in some embodiments include a server  or more than one server  configured to provide the functionality of any one of the following server types: a file server; an application server; a web server; a proxy server; an appliance; a network appliance; a gateway; an application gateway; a gateway server; a virtualization server; a deployment server; a SSL VPN server; a firewall; a web server; an application server or as a master application server; a server  configured to operate as an active direction; a server  configured to operate as application acceleration application that provides firewall functionality, application functionality, or load balancing functionality, or other type of computing machine configured to operate as a server . In some embodiments, a server  may include a remote authentication dial-in user service such that the server  is a RADIUS server. Embodiments of the computing environment  where the server  comprises an appliance, the server  can be an appliance manufactured by any one of the following manufacturers: the Citrix Application Networking Group; Silver Peak Systems, Inc; Riverbed Technology, Inc.; F5 Networks, Inc.; or Juniper Networks, Inc. Some embodiments include a server  with the following functionality: a first server A that receives requests from a client machine , forwards the request to a second server B, and responds to the request generated by the client machine with a response from the second server B; acquires an enumeration of applications available to the client machines  and address information associated with a server  hosting an application identified by the enumeration of applications; presents responses to client requests using a web interface; communicates directly with the client  to provide the client  with access to an identified application; receives output data, such as display data, generated by an execution of an identified application on the server .","The server  can be configured to execute any one of the following applications: an application providing a thin-client computing or a remote display presentation application; any portion of the CITRIX ACCESS SUITE by Citrix Systems, Inc. like the METAFRAME or CITRIX PRESENTATION SERVER; MICROSOFT WINDOWS Terminal Services manufactured by the Microsoft Corporation; or an ICA client, developed by Citrix Systems, Inc. Another embodiment includes a server  configured to execute an application so that the server may function as an application server such as any one of the following application server types: an email server that provides email services such as MICROSOFT EXCHANGE manufactured by the Microsoft Corporation; a web or Internet server; a desktop sharing server; or a collaboration server. Still other embodiments include a server  that executes an application that is any one of the following types of hosted servers applications: GOTOMEETING provided by Citrix Online Division, Inc.; WEBEX provided by WebEx, Inc. of Santa Clara, Calif.; or Microsoft Office LIVE MEETING provided by Microsoft Corporation.","In one embodiment, the server  may be a virtual machine B such as those manufactured by Citrix Systems, IBM, VMware, or any other virtual machine able to implement the methods and systems described herein.","Client machines  may function, in some embodiments, as a client node seeking access to resources provided by a server , or as a server  providing other clients A-N with access to hosted resources. One embodiment of the computing environment  includes a server  that provides the functionality of a master node. Communication between the client machine  and either a server  or servers A-N can be established via any of the following methods: direct communication between a client machine  and a server A-N in a server farm ; a client machine  that uses a program neighborhood application to communicate with a server -in a server farm ; or a client machine  that uses a network  to communicate with a server A-N in a server farm . One embodiment of the computing environment  includes a client machine  that uses a network  to request that applications hosted by a server A-N in a server farm  execute, and uses the network  to receive from the server A-N graphical display output representative of the application execution. In other embodiments, a master node provides the functionality required to identify and provide address information associated with a server  hosting a requested application. Still other embodiments include a master node that can be any one of the following: a server A-N within the server farm ; a remote computing machine connected to the server farm  but not included within the server farm ; a remote computing machine connected to a client  but not included within a group of client machines ; or a client machine .","The network  between the client machine  and the server  is a connection over which data is transferred between the client machine  and the server . Although the illustration in  depicts a network  connecting the client machines  to the servers , other embodiments include a computing environment  with client machines  installed on the same network as the servers . Other embodiments can include a computing environment  with a network  that can be any of the following: a local-area network (LAN); a metropolitan area network (MAN); a wide area network (WAN); a primary network  comprised of multiple sub-networks \u2032 located between the client machines  and the servers ; a primary public network  with a private sub-network \u2032; a primary private network  with a public sub-network \u2032; or a primary private network  with a private sub-network \u2032. Still further embodiments include a network  that can be any of the following network types: a point to point network; a broadcast network; a telecommunications network; a data communication network; a computer network; an ATM (Asynchronous Transfer Mode) network; a SONET (Synchronous Optical Network) network; a SDH (Synchronous Digital Hierarchy) network; a wireless network; a wireline network; a network  that includes a wireless link where the wireless link can be an infrared channel or satellite band; or any other network type able to transfer data from client machines  to servers  and vice versa to accomplish the methods and systems described herein. Network topology may differ within different embodiments, possible network topologies include: a bus network topology; a star network topology; a ring network topology; a repeater-based network topology; a tiered-star network topology; or any other network topology able transfer data from client machines  to servers , and vice versa, to accomplish the methods and systems described herein. Additional embodiments may include a network  of mobile telephone networks that use a protocol to communicate among mobile devices, where the protocol can be any one of the following: AMPS; TDMA; CDMA; GSM; GPRS UMTS; or any other protocol able to transmit data among mobile devices to accomplish the systems and methods described herein.","Illustrated in  is an embodiment of a computing device , where the client machine  and server  illustrated in  can be deployed as and\/or executed on any embodiment of the computing device  illustrated and described herein. Included within the computing device  is a system bus  that communicates with the following components: a central processing unit ; a main memory ; storage memory ; an input\/output (I\/O) controller ; display devices A-N; an installation device ; and a network interface . In one embodiment, the storage memory  includes: an operating system, software routines, and a client agent . The I\/O controller , in some embodiments, is further connected to a key board , and a pointing device . Other embodiments may include an I\/O controller  connected to more than one input\/output device A-N.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 1C","FIG. 1A"],"b":["100","102","106","100","100","150","170","130","170","121","121","130","122","140","121","103"]},"Embodiments of the computing machine  can include a central processing unit  characterized by any one of the following component configurations: logic circuits that respond to and process instructions fetched from the main memory unit ; a microprocessor unit, such as: those manufactured by Intel Corporation; those manufactured by Motorola Corporation; those manufactured by Transmeta Corporation of Santa Clara, Calif.; the RS\/6000 processor such as those manufactured by International Business Machines; a processor such as those manufactured by Advanced Micro Devices; or any other combination of logic circuits capable of executing the systems and methods described herein. Still other embodiments of the central processing unit  may include any combination of the following: a microprocessor, a microcontroller, a central processing unit with a single processing core, a central processing unit with two processing cores, or a central processing unit with more than one processing cores.","One embodiment of the computing machine  includes a central processing unit  that communicates with cache memory  via a secondary bus also known as a backside bus, while another embodiment of the computing machine  includes a central processing unit  that communicates with cache memory via the system bus . The local system bus  can, in some embodiments, also be used by the central processing unit to communicate with more than one type of I\/O devices A-N. In some embodiments, the local system bus  can be any one of the following types of buses: a VESA VL bus; an ISA bus; an EISA bus; a MicroChannel Architecture (MCA) bus; a PCI bus; a PCI-X bus; a PCI-Express bus; or a NuBus. Other embodiments of the computing machine  include an I\/O device A-N that is a video display  that communicates with the central processing unit  via an Advanced Graphics Port (AGP). Still other versions of the computing machine  include a processor  connected to an I\/O device A-N via any one of the following connections: HyperTransport, Rapid I\/O, or InfiniBand. Further embodiments of the computing machine  include a communication connection where the processor  communicates with one I\/O device A using a local interconnect bus and with a second I\/O device B using a direct connection.","Included within some embodiments of the computing device  is each of a main memory unit  and cache memory . The cache memory  will in some embodiments be any one of the following types of memory: SRAM; BSRAM; or EDRAM. Other embodiments include cache memory  and a main memory unit  that can be any one of the following types of memory: Static random access memory (SRAM), Burst SRAM or SynchBurst SRAM (BSRAM), Dynamic random access memory (DRAM), Fast Page Mode DRAM (FPM DRAM), Enhanced DRAM (EDRAM), Extended Data Output RAM (EDO RAM), Extended Data Output DRAM (EDO DRAM), Burst Extended Data Output DRAM (BEDO DRAM), Enhanced DRAM (EDRAM), synchronous DRAM (SDRAM), JEDEC SRAM, PC100 SDRAM, Double Data Rate SDRAM (DDR SDRAM), Enhanced SDRAM (ESDRAM), SyncLink DRAM (SLDRAM), Direct Rambus DRAM (DRDRAM), Ferroelectric RAM (FRAM), or any other type of memory device capable of executing the systems and methods described herein. The main memory unit  and\/or the cache memory  can in some embodiments include one or more memory devices capable of storing data and allowing any storage location to be directly accessed by the central processing unit . Further embodiments include a central processing unit  that can access the main memory  via one of either: a system bus ; a memory port ; or any other connection, bus or port that allows the processor  to access memory .","One embodiment of the computing device  provides support for any one of the following installation devices : a floppy disk drive for receiving floppy disks such as 3.5-inch, 5.25-inch disks or ZIP disks, a CD-ROM drive, a CD-R\/RW drive, a DVD-ROM drive, tape drives of various formats, USB device, a bootable medium, a bootable CD, a bootable CD for GNU\/Linux distribution such as KNOPPIX\u00ae, a hard-drive or any other device suitable for installing applications or software. Applications can in some embodiments include a client agent , or any portion of a client agent . The computing device  may further include a storage device  that can be either one or more hard disk drives, or one or more redundant arrays of independent disks; where the storage device is configured to store an operating system, software, programs applications, or at least a portion of the client agent . A further embodiment of the computing device  includes an installation device  that is used as the storage device .","Furthermore, the computing device  may include a network interface  to interface to a Local Area Network (LAN), Wide Area Network (WAN) or the Internet through a variety of connections including, but not limited to, standard telephone lines, LAN or WAN links (e.g., 802.11, T1, T3, 56 kb, X.25, SNA, DECNET), broadband connections (e.g., ISDN, Frame Relay, ATM, Gigabit Ethernet, Ethernet-over-SONET), wireless connections, or some combination of any or all of the above. Connections can also be established using a variety of communication protocols (e.g., TCP\/IP, IPX, SPX, NetBIOS, Ethernet, ARCNET, SONET, SDH, Fiber Distributed Data Interface (FDDI), RS232, RS485, IEEE 802.11, IEEE 802.11a, IEEE 802.11b, IEEE 802.11g, CDMA, GSM, WiMax and direct asynchronous connections). One version of the computing device  includes a network interface  able to communicate with additional computing devices \u2032 via any type and\/or form of gateway or tunneling protocol such as Secure Socket Layer (SSL) or Transport Layer Security (TLS), or the Citrix Gateway Protocol manufactured by Citrix Systems, Inc. Versions of the network interface  can comprise any one of: a built-in network adapter; a network interface card; a PCMCIA network card; a card bus network adapter; a wireless network adapter; a USB network adapter; a modem; or any other device suitable for interfacing the computing device  to a network capable of communicating and performing the methods and systems described herein.","Embodiments of the computing device  include any one of the following I\/O devices A-N: a keyboard ; a pointing device ; mice; trackpads; an optical pen; trackballs; microphones; drawing tablets; video displays; speakers; inkjet printers; laser printers; and dye-sublimation printers; or any other input\/output device able to perform the methods and systems described herein. An I\/O controller  may in some embodiments connect to mulitple I\/O devices A-N to control the one or more I\/O devices. Some embodiments of the I\/O devices A-N may be configured to provide storage or an installation medium , while others may provide a universal serial bus (USB) interface for receiving USB storage devices such as the USB Flash Drive line of devices manufactured by Twintech Industry, Inc. Still other embodiments of an I\/O device  may be a bridge between the system bus  and an external communication bus, such as: a USB bus; an Apple Desktop Bus; an RS-232 serial connection; a SCSI bus; a FireWire bus; a FireWire  bus; an Ethernet bus; an AppleTalk bus; a Gigabit Ethernet bus; an Asynchronous Transfer Mode bus; a HIPPI bus; a Super HIPPI bus; a SerialPlus bus; a SCI\/LAMP bus; a FibreChannel bus; or a Serial Attached small computer system interface bus.","In some embodiments, the computing machine  can connect to multiple display devices A-N, in other embodiments the computing device  can connect to a single display device , while in still other embodiments the computing device  connects to display devices A-N that are the same type or form of display, or to display devices that are different types or forms. Embodiments of the display devices A-N can be supported and enabled by the following: one or multiple I\/O devices A-N; the I\/O controller ; a combination of I\/O device(s) A-N and the I\/O controller ; any combination of hardware and software able to support a display device A-N; any type and\/or form of video adapter, video card, driver, and\/or library to interface, communicate, connect or otherwise use the display devices -. The computing device  may in some embodiments be configured to use one or multiple display devices A-N, these configurations include: having multiple connectors to interface to multiple display devices -having multiple video adapters, with each video adapter connected to one or more of the display devices A-N; having an operating system configured to support multiple displays A-N; using circuits and software included within the computing device  to connect to and use multiple display devices A-N; and executing software on the main computing device  and multiple secondary computing devices to enable the main computing device  to use a secondary computing device's display as a display device A-N for the main computing device . Still other embodiments of the computing device  may include multiple display devices A-N provided by multiple secondary computing devices and connected to the main computing device  via a network.","In some embodiments of the computing machine , an operating system may be included to control task scheduling and access to system resources. Embodiments of the computing device  can run any one of the following operation systems: versions of the MICROSOFT WINDOWS operating systems such as WINDOWS 3.x; WINDOWS 95; WINDOWS 98; WINDOWS 2000; WINDOWS NT 3.51; WINDOWS NT 4.0; WINDOWS CE; WINDOWS XP; and WINDOWS VISTA; the different releases of the Unix and Linux operating systems; any version of the MAC OS manufactured by Apple Computer; OS\/2, manufactured by International Business Machines; any embedded operating system; any real-time operating system; any open source operating system; any proprietary operating system; any operating systems for mobile computing devices; or any other operating system capable of running on the computing device and performing the operations described herein. One embodiment of the computing machine  has multiple operating systems installed thereon.","The computing machine  can be embodied in any one of the following computing devices: a computing workstation; a desktop computer; a laptop or notebook computer; a server; a handheld computer; a mobile telephone; a portable telecommunication device; a media playing device; a gaming system; a mobile computing device; a device of the IPOD family of devices manufactured by Apple Computer; any one of the PLAYSTATION family of devices manufactured by the Sony Corporation; any one of the Nintendo family of devices manufactured by Nintendo Co; any one of the XBOX family of devices manufactured by the Microsoft Corporation; or any other type and\/or form of computing, telecommunications or media device that is capable of communication and that has sufficient processor power and memory capacity to perform the methods and systems described herein. In other embodiments the computing machine  can be a mobile device such as any one of the following mobile devices: a JAVA-enabled cellular telephone or personal digital assistant (PDA), such as the i55sr, i58sr, i85s, i88s, i90c, i95c1, or the im1100, all of which are manufactured by Motorola Corp; the 6035 or the 7135, manufactured by Kyocera; the i300 or i330, manufactured by Samsung Electronics Co., Ltd; the TREO 180, 270, 600, 650, 680, 700p, 700w, or 750 smart phone manufactured by Palm, Inc; any computing device that has different processors, operating systems, and input devices consistent with the device; or any other mobile computing device capable of performing the methods and systems described herein. Still other embodiments of the computing environment  include a mobile computing device  that can be any one of the following: any one series of Blackberry, or other handheld device manufactured by Research In Motion Limited; the iPhone manufactured by Apple Computer; any handheld or smart phone; a Pocket PC; a Pocket PC Phone; or any other handheld mobile device supporting Microsoft Windows Mobile Software.","Referring now to , together the servers  comprise a farm  or server farm, where each server  can include a network-side interface  and a farm-side interface . The network-side interface  can be in communication with one or more clients  or a network . The network  can be a WAN, LAN, or any other embodiment of a network such those networks described above.","Each server  has a farm-side interface  connected with one or more farm-side interface(s)  of other servers  in the farm . In one embodiment, each farm-side interface  is interconnected to other farm-side interfaces  such that the servers  within the farm  may communicate with one another. On each server , the farm-side interface  communicates with the network-side interface . The farm-side interfaces  can also communicate (designated by arrows ) with a persistent store  and, in some embodiments, with a dynamic store . The combination of servers , the persistent store , and the dynamic store , when provided, are collectively referred to as a farm . In some embodiments, a server  communicates with the persistent store  and other servers \u2032 communicate with the server  to access information stored in the persistent store.","The persistent store  may be physically implemented on a disk, disk farm, a redundant array of independent disks (RAID), writeable compact disc, or any other device that allows data to be read and written and that maintains written data if power is removed from the storage device. A single physical device may provide storage for a plurality of persistent stores, i.e., a single physical device may be used to provide the persistent store  for more than one farm . The persistent store  maintains static data associated with each server  in farm  and global data used by all servers  within the farm . In one embodiment, the persistent store  may maintain the server data in a Lightweight Directory Access Protocol (LDAP) data model. In other embodiments, the persistent store  stores server data in an ODBC-compliant database. For the purposes of this description, the term \u201cstatic data\u201d refers to data that do not change frequently, i.e., data that change only on an hourly, daily, or weekly basis, or data that never change. Each server uses a persistent storage subsystem to read data from and write data to the persistent store .","The data stored by the persistent store  may be replicated for reliability purposes physically or logically. For example, physical redundancy may be provided using a set of redundant, mirrored disks, each providing a copy of the data. In other embodiments, the database itself may be replicated using standard database techniques to provide multiple copies of the database. In further embodiments, both physical and logical replication may be used concurrently.","The dynamic store  (i.e., the collection of all record tables) can be embodied in various ways. In one embodiment, the dynamic store  is centralized; that is, all runtime data are stored in the memory of one server  in the farm . That server operates as a master network node with which all other servers  in the farm  communicate when seeking access to that runtime data. In another embodiment, each server  in the farm  keeps a full copy of the dynamic store . Here, each server  communicates with every other server  to keep its copy of the dynamic store  up to date.","In another embodiment, each server  maintains its own runtime data and communicates with other servers  when seeking to obtain runtime data from them. Thus, for example, a server  attempting to find an application program requested by the client  may communicate directly with every other server  in the farm  to find one or more servers hosting the requested application.","For farms  having a large number of servers , the network traffic produced by these embodiments can become heavy. One embodiment alleviates heavy network traffic by designating a subset of the servers  in a farm , typically two or more, as \u201ccollector points.\u201d Generally, a collector point is a server that collects run-time data. Each collector point stores runtime data collected from certain other servers  in the farm . Each server  in the farm  is capable of operating as, and consequently is capable of being designated as, a collector point. In one embodiment, each collector point stores a copy of the entire dynamic store . In another embodiment, each collector point stores a portion of the dynamic store , i.e., it maintains runtime data of a particular data type. The type of data stored by a server  may be predetermined according to one or more criteria. For example, servers  may store different types of data based on their boot order. Alternatively, the type of data stored by a server  may be configured by an administrator using an administration tool (Not Shown.) In these embodiments, the dynamic store  is distributed amongst two or more servers  in the farm .","Servers  not designated as collector points know the servers  in a farm  that are designated as collector points. A server  not designated as a collector point may communicate with a particular collector point when delivering and requesting runtime data. Consequently, collector points lighten network traffic because each server  in the farm  communicates with a single collector point server , rather than with every other server , when seeking to access the runtime data.","Each server  can operate as a collector point for more than one type of data. For example, server \u2033 can operate as a collector point for licensing information and for loading information. In these embodiments, each collector point may amass a different type of run-time data. For example, to illustrate this case, the server \u2032\u2033 can collect licensing information, while the server \u2033 collects loading information.","In some embodiments, each collector point stores data that is shared between all servers  in a farm . In these embodiments, each collector point of a particular type of data exchanges the data collected by that collector point with every other collector point for that type of data in the farm . Thus, upon completion of the exchange of such data, each collector point \u2033 and  possesses the same data. Also in these embodiments, each collector point  and \u2033 also keeps every other collector point abreast of any updates to the runtime data.","Browsing enables a client  to view farms , servers , and applications in the farms  and to access available information such as sessions throughout the farm . Each server  includes an ICA browsing subsystem  to provide the client  with browsing capability. After the client  establishes a connection with the ICA browser subsystem  of any of the servers , that browser subsystem supports a variety of client requests. Such client requests include: (1) enumerating names of servers in the farm, (2) enumerating names of applications published in the farm, (3) resolving a server name and\/or application name to a server address that is useful the client . The ICA browser subsystem  also supports requests made by clients  running a program neighborhood application that provides the client , upon request, with a view of those applications within the farm  for which the user is authorized. The ICA browser subsystem  forwards all of the above-mentioned client requests to the appropriate subsystem in the server .","In one embodiment, each server  in the farm  that has a program neighborhood subsystem  can provide the user of a client  with a view of applications within the farm . The program neighborhood subsystem  may limit the view to those applications for which the user of the client  has authorization to access. Typically, this program neighborhood service presents the applications to the user as a list or a group of icons.","The functionality provided by the program neighborhood subsystem  can be available to two types of clients, (1) program neighborhood-enabled clients that can access the functionality directly from a client desktop, and (2) non-program neighborhood-enabled clients (e.g., legacy clients) that can access the functionality by running a program neighborhood-enabled desktop on the server.","Communication between a program neighborhood-enabled client and the program neighborhood subsystem  may occur over a dedicated virtual channel that is established on top of an ICA virtual channel. In other embodiments, the communication occurs using an XML service. In one of these embodiments, the program neighborhood-enabled client communicates with an XML subsystem, such as the XML service  described in connection with  below, providing program neighborhood functionality on a server .","In one embodiment, the program neighborhood-enabled client does not have a connection with the server with a program neighborhood subsystem . For this embodiment, the client  sends a request to the ICA browser subsystem  to establish an ICA connection to the server  in order to identify applications available to the client . The client  then runs a client-side dialog that acquires the credentials of a user. The credentials are received by the ICA browser subsystem  and sent to the program neighborhood subsystem . In one embodiment, the program neighborhood subsystem  sends the credentials to a user management subsystem for authentication. The user management subsystem may return a set of distinguished names representing the list of accounts to which the user belongs. Upon authentication, the program neighborhood subsystem  establishes the program neighborhood virtual channel. This channel remains open until the application filtering is complete.","The program neighborhood subsystem  then requests the program neighborhood information from the common application subsystem  associated with those accounts. The common application subsystem  obtains the program neighborhood information from the persistent store . On receiving the program neighborhood information, the program neighborhood subsystem  formats and returns the program neighborhood information to the client over the program neighborhood virtual channel. Then the partial ICA connection is closed.","For another example in which the program neighborhood-enabled client establishes a partial ICA connection with a server, consider the user of the client  who selects a farm . The selection of the farm  sends a request from the client  to the ICA browser subsystem  to establish an ICA connection with one of the servers  in the selected farm . The ICA browser subsystem  sends the request to the program neighborhood subsystem , which selects a server  in the farm . Address information associated with the server  is identified and returned to the client  by way of the ICA browser subsystem . The client  can then subsequently connect to the server  corresponding to the received address information.","In another embodiment, the program neighborhood-enabled client  establishes an ICA connection upon which the program neighborhood-virtual channel is established and remains open for as long as the ICA connection persists. Over this program neighborhood virtual channel, the program neighborhood subsystem  pushes program neighborhood information updates to the client . To obtain updates, the program neighborhood subsystem  subscribes to events from the common application subsystem  to allow the program neighborhood subsystem  to detect changes to published applications.","Referring to , a block diagram depicts another embodiment of a system architecture for providing a plurality of application programs available to the client via publishing of GUIs in a web service directory. The system includes the client , and a plurality of servers . A first server  functions as a content server. A second server \u2032 provides web server functionality, and a third server \u2033 provides functionality for providing access to application files and acts as an application server or a file server. The client  can download content from the content server , the web server \u2032, and the application server \u2033 over the network . In one embodiment, the client  can download content (e.g., an application) from the application server \u2033 over the client-application server communication channel .","In one embodiment, the web browser  on the client  uses Secure Socket Layer (SSL) support for communications to the content server  and\/or the web server \u2032. SSL is a secure protocol developed by Netscape Communication Corporation of Mountain View, Calif., and is now a standard promulgated by the Internet Engineering Task Force (IETF). The web browser  can alternatively connect to the content server  and\/or the web server \u2032 using other security protocols, such as, but not limited to, Secure Hypertext Transfer Protocol (SHTTP) developed by Terisa Systems of Los Altos, Calif., HTTP over SSL (HTTPS), Private Communication Technology (PCT) developed by Microsoft Corporation of Redmond, Wash., and the Transport Level Security (TLS) standard promulgated by the IETF. In other embodiments, the web browser  communicates with the servers  using a communications protocol without encryption, such as the HyperText Transfer Protocol (HTTP).","The client  can additionally include an application client  for establishing and exchanging communications with the application server \u2033 over the client-application server communication channel . In one embodiment, the application client  is a GUI application. In some embodiments, the application client  is an Independent Computing Architecture (ICA) client, developed by Citrix Systems, Inc. of Fort Lauderdale, Fla., and is also referred to below as ICA client . Other embodiments of the application client  include a Remote Display Protocol (RDP) client, developed by Microsoft Corporation of Redmond, Wash., an X-Windows client , a client-side player, interpreter or simulator capable of executing multimedia applications, email, Java, or .NET code. Moreover, in one embodiment the output of an application executing on the application server \u2033 can be displayed at the client  via the ICA client . In some embodiments, the application client  is an application client such as the application streaming client , described in greater detail in connection with .","The client  searches the web service directory  for a web service. In one embodiment, the search is a manual search. Alternatively, the search is an automatic search. The web service directory  may also provide a service based view, such as white and yellow pages, to search for web services in the web service directory. In another embodiment, the web service directory  supports a hierarchical browsing based on a structured service name and service kind for GUI applications. In one embodiment, the web service directory  executes on a server independent of the content server , such as a directory server. In other embodiments, the web service directory  executes on multiple servers.","In some embodiments, the content server  enables the client  to select web services based on additional analysis or information by providing this information or analysis in the web service directory . Examples of service information that the web service directory  can list includes, but is not limited to, the name of the business offering the service, the service type, a textual description of the service, one or more service access points (SAPs), the network type, the path to use (e.g., TCP or HTTPS), and quality of service (QoS) information. Moreover, service information can be client device type or user (e.g., role) specific. Thus, service selection can be based on one or more of the above attributes.","In one embodiment, the service type denotes a programming interface that the client  must use to access the web service. For instance, the service type can state that the service is encoded by an interface description language, such as Web Services Description Language (WSDL).","The service access point, or SAP, is a unique address for an application. The SAPs enable the computer system to support multiple applications at the client  and each server . For example, the application server \u2033 may support an electronic mail (i.e., e-mail) application, a file transfer application, and\/or a GUI application. In one embodiment, these applications would each have a SAP that is unique within the application server \u2033. In one embodiment, the SAP is a web or Internet address (e.g., Domain Name System (DNS) name, IP\/port, or Uniform Resource Locator (URL)). Thus, in one embodiment the SAP identifies the address of the web server \u2032 as part of the address for an application stored on the web server \u2032. In some embodiments, the SAP identifies the address of a publishing server plug-in  as part of the address for an application stored on the web server \u2032, as described below. In one embodiment, the SAP is an \u201caccessPoint\u201d from the UDDI registry.","To prepare an item for publishing in the web service directory , the content server  includes a web publishing tool . In one embodiment, the web publishing tool  is a software module. Alternatively, the web publishing tool  is another server that may be externally located from or internally located in the content server .","In one embodiment, the web server \u2032 delivers web pages to the client . The web server \u2032 can be any server  capable of providing web pages to the client . In another embodiment, the web server \u2032 is an Enterprise Information Portal (e.g., corporate Intranet or secured business-to-business extranet). Enterprise portals are company web sites that aggregate, personalize and serve applications, data and content to users, while offering management tools for organizing and using information more efficiently. In some companies, portals have replaced traditional desktop software with browser-based access to a virtual workplace.","The web server \u2032 can also include a publishing server plug-in  to enable the publishing of graphical user interface (GUI) applications. More specifically, the publishing server plug-in  translates a new web service entry URL into a GUI application service so that the GUI can be accessed via the web service directory . In one embodiment, the publishing server plug-in  is a Common Gateway Interface (CGI) script, which is a program designed to accept and return data that conforms to the CGI specification. The program can be written in any programming language, such as C, Perl, Java, or Visual Basic. In another embodiment, the publishing server plug-in  is a Java Server Page (JSP). Using the publishing server plug-in  to facilitate the publishing of remote GUI applications, the client  can thereby access the web service, not through a programming interface or a web page, but through a full GUI interface, such as with Citrix's ICA or Microsoft's RDP.","The application server \u2033 hosts one or more applications that are available for the client . Examples of such applications include word processing programs such as MICROSOFT WORD and spreadsheet programs such as MICROSOFT EXCEL, both manufactured by Microsoft Corporation of Redmond, Wash., financial reporting programs, customer registration programs, programs providing technical support information, customer database applications, or application set managers.","In some embodiments, one or more communication links  are established over different networks. For example, the client-content server communication channel \u2032 can belong to a first network (e.g., the World Wide Web) and the client-web server communication channel \u2033 can belong to a second network (e.g., a secured extranet or Virtual Private Network (VPN)).","In one embodiment, the web publishing tool  stores information about an application that the web publishing tool  is currently publishing in the web service directory  in a persistent mass storage . In one embodiment the information is a URL for the dynamic publishing server plug-in . The persistent mass storage  may be a magnetic disk or magneto-optical drive. In one embodiment, the persistent mass storage  is a database server, which stores data related to the published application in one or more local service databases. The persistent mass storage  may be a component internally located in or externally located from any or all of the servers .","In other embodiments, the content server  or the web server \u2032 communicate with a server  in the farm  to retrieve the list of applications. In one of these embodiments, the content server  or the web server \u2032 communicate with the farm  instead of with the persistent mass storage .","Referring now to , a flow diagram depicts one embodiment of the steps taken to select a method of execution of an application program. In brief overview, credentials associated with the client or with a user of the client are received, with a request for an enumeration of applications available for execution by the client (step ). An enumeration of a plurality of application programs available to the client is provided, responsive to the received credentials (step ). A request is received to execute an enumerated application (step ). One of a predetermined number of methods for executing the enumerated application is selected, responsive to a policy, the predetermined number of methods including a method for application streaming of the enumerated application (step ).","Credentials associated with the client or with a user of the client are received, with a request for an enumeration of applications available for execution by the client (step ). In one embodiment, the server receives a request for enumeration of available applications from the client  with the credentials. In another embodiment, an XML service on the server  receives the request and the credentials and transmits the request and credentials to a management service on the server .","In some embodiments, a server  functioning as a web server receives communications from the client  and forwards the communications to a server \u2032. In one of these embodiments, the web server forwards the communications to an XML service on the server \u2032. In another of these embodiments, the web server resides on the client. In other embodiments where communications from the client  are routed to a server \u2032 by the web server, the server  may be selected responsive to an Internet Protocol (IP) address of the client .","In some embodiments, a client  requests access to an application residing on a server . In one of these embodiments, the client  requests execution by the server  of the application residing on the server . In another of these embodiments, the client  requests retrieval of a plurality of application files that comprise the application.","In some embodiments, the user provides credentials to the server  via a graphical user interface presented to the client  by the server . In other embodiments, a server \u2032\u2033 having the functionality of a web server provides the graphical user interface to the client . In still other embodiments, a collection agent transmitted to the client  by the server  gathers the credentials from the client . In one embodiment, a credential refers to a username and password. In another embodiment, a credential is not limited to a username and password but includes, without limitation, a machine ID of the client , operating system type, existence of a patch to an operating system, MAC addresses of installed network cards, a digital watermark on the client device, membership in an Active Directory, existence of a virus scanner, existence of a personal firewall, an HTTP header, browser type, device type, network connection information such as internet protocol address or range of addresses, machine ID of the server , date or time of access request including adjustments for varying time zones, and authorization credentials.","In some embodiments, a credential associated with a client is associated with a user of the client. In one of these embodiments, the credential is information possessed by the user. In another of these embodiments, the credential is user authentication information. In other embodiments, a credential associated with a client is associated with a network. In one of these embodiments, the credential is information associated with a network to which the client may connect. In another of these embodiments, the credential is information associated with a network collecting information about the client. In still other embodiments, a credential associated with a client is a characteristic of the client.","An enumeration of a plurality of application programs available to the client is provided, responsive to the received credentials (step ). In one embodiment, a user of a client  may learn of the availability of application programs hosted by the servers  on the network  without knowing where to find such applications and without technical information necessary to link to such applications. These available application programs can comprise the \u201cprogram neighborhood\u201d of the user. A system for determining a program neighborhood for a client may include an application program (hereafter referred to as the \u201cProgram Neighborhood\u201d application), memory for storing components of the application program, and a processor for executing the application program. The Program Neighborhood (PN) application can be installed in the memory of the client  and\/or on a server  as described below.","A server  operating according to the Program Neighborhood application collects application-related information from each of the servers  in a farm . The application-related information for each hosted application can be a variety of information including, for example, an address of the server hosting that application, the application name, the users or groups of users who are authorized to use that application, and the minimum capabilities required of the client  before establishing a connection to run the application. For example, the application may stream video data, and therefore a required minimum capability may be that the client supports video data. Other examples are requirements that the client support audio data or have the capacity to process encrypted data. The application-related information can be stored in a database.","When a client  connects to the network , the user of the client  provides user credentials. User credentials may include the username of a user of the client , the password of the user, and the domain name for which the user is authorized. Alternatively, the user credentials may be obtained from smart cards, time-based tokens, social security numbers, user passwords, personal identification (PIN) numbers, digital certificates based on symmetric key or elliptic curve cryptography, biometric characteristics of the user, or any other means by which the identification of the user of the client  can be obtained and submitted for authentication. The server  responding to the client  can authenticate the user based on the user credentials. The user credentials can be stored wherever the Program Neighborhood application is executing. For embodiments in which the client  executes the Program Neighborhood application, the user credentials may be stored at the client . For embodiments in which a server  executes the Program Neighborhood, the user credentials can be stored at that server .","From the user credentials and the application-related information, the server  can also determine which application programs hosted by servers  are available for use by the user of the client . The server  transmits information representing the available application programs to the client . This process eliminates the need for a user of the client  to establish application connections. Additionally, an administrator of the server  may control access to applications among multiple users of a client .","In some embodiments, the user authentication performed by the server  may suffice to authorize the user of each hosted application program presented to the client , although such applications may reside at another server \u2032. Accordingly, when the client  launches (i.e., initiates execution of) one of the hosted applications, additional input of user credentials by the client  may be unnecessary to authenticate use of that application. Thus, a single entry of the user credentials may serve to determine the available applications and to authorize the launching of such applications without an additional, manual log-on authentication process by the user.","Either a client  or server  can launch the Program Neighborhood application. The results can be displayed on the display screen of the client . In a graphical windows-based implementation, the results can be displayed in a Program Neighborhood graphical window and each authorized application program can be represented by a graphical icon in that window.","In one embodiment, the Program Neighborhood application filters out application programs that the client  is unauthorized to execute and displays only authorized (i.e., available) programs. In other embodiments, the Program Neighborhood application can display authorized and unauthorized applications. When unauthorized applications are not filtered from the display, a notice can be provided indicating that such applications are unavailable. Alternatively, the Program Neighborhood application can report all applications hosted by the servers  to the user of a client  without identifying which applications the client  is authorized or unauthorized to execute. Authorization can be subsequently determined when the client  attempts to run one of those applications.","The client  may request application enumeration from a server . Application enumeration enables a user of the client  to view the names of every published application. In one embodiment, the user of the client  can view the application names regardless of whether the user has the authorization to execute the application. In another embodiment, the user views only those application names that the user is authorized to execute.","Requests for application enumeration pass to the ICA browser subsystem , to the program neighborhood subsystem , or to a common application subsystem , depending upon the particular process being run by the client . For example, when the client  runs the program neighborhood application, the requests for application enumeration are sent to the program neighborhood subsystem  on a server . When the client  submits the enumeration request through a web page, the requests pass to the common access point subsystem . For these embodiments, the common application subsystem  serves as an initial access point for the program neighborhood subsystem , ICA browser subsystem , and common application subsystems when the client  wants to enumerate applications. In some embodiments, when the client  submits the enumeration request through a web page, an intermediate server  hosting a web server receives the request and forwards the request to a server \u2032.","Upon receiving the enumeration requests, a common application subsystem  queries the persistent store  for a list of all applications. For requests received from the program neighborhood subsystem  and common access point (Not Shown) subsystems, this list of applications is filtered according to the credentials of the user of the client  (i.e., the user views only those applications for which the user is authorized).","The client  can also request server enumeration. Server enumeration enables a user of the client  to view a list of servers in the farm . In one embodiment, the list of servers can be filtered according to the type of server, as determined by the specialized server subsystem on that server.","Requests for server enumeration pass to the ICA browser subsystem  or to the common access point subsystem (Not Shown), depending upon the particular process being run by the client . For example, when the client  submits the server enumeration request through a web page, the requests pass to the common access point subsystem (Not Shown). For these embodiments, the common server subsystem  serves as an initial access point for the ICA browser subsystem  and common access point (Not Shown) subsystems. Upon receiving the server enumeration requests, the common server subsystem queries the persistent store  for a list of all servers. Optionally, the list of servers is filtered according to the server type.",{"@attributes":{"id":"p-0116","num":"0115"},"figref":"FIG. 3A","b":["102","102","80"]},"The client , via the web browser , transmits a request  to access a Uniform Resource Locator (URL) address corresponding to an HTML page residing on server . In some embodiments the first HTML page returned  to the client  by the server  is an authentication page that seeks to identify the client .","Still referring to , once the client  is authenticated by the server , the server  prepares and transmits to the client  an HTML page , in response to another Request , that includes a Program Neighborhood window  in which appears graphical icons  representing application programs to which the client  has access. A user of client  invokes execution of an application represented by icon  by clicking that icon .","In some embodiments, the server  executes the Program Neighborhood application on behalf of a user of the client . In one of these embodiments, the server  is an intermediate server residing between the client  and a server \u2032.","Referring to , a flow diagram depicts one embodiment of the steps taken to provide a plurality of application programs available to the client via publishing of GUIs in a web service directory. The web publishing tool  receives a web service description and access information for an application (e.g., GUI application) for publishing (step ). In one embodiment, the web service description includes the service information described above (e.g., the name of the business offering the web service, the service type, a textual description of the service, and a SAP). The access information may include, for example, a published application name, a Transmission Control Protocol (TCP) browsing server farm address, and a MetaFrame server IP address. In some embodiments, the access information specifies the address to use and a ticket to use to traverse network or security gateways or bridge devices.","The web publishing tool  then constructs a service-publishing request to request the publication of the web service (i.e., GUI application) (step ). In one embodiment, the service-publishing request includes a SAP. In some embodiments, the SAP is a URL including the web address of the web server \u2032 and the publishing server plug-in . Further, the web address can be a Uniform Resource Identifier (URI), which is the generic term for the types of names and addresses that refer to objects on the web. A URL is one kind of URI. An example of the URI is the name of the web server \u2032 (e.g., \u201cweb-server\u201d) and the CGI script name (e.g., \u201cdynamic-component\u201d) for the publishing server plug-in .","The web publishing tool  stores a SAP entry associated with the SAP in the persistent mass storage  (step ). In some embodiments, the web publishing tool  also associates published application information (e.g., ICA-published-app-info) with the GUI application. In further embodiments, the web publishing tool  also includes a key in the service-publishing request to identify the SAP entry that the content server  stores in the persistent mass storage . For instance, the key can have the value of \u201c123456677.\u201d An example of a SAP identifying the web server \u2032, the CGI script name of the publishing server plug-in , and the key described above is \u201chttp:\/\/web-server\/dynamic-component\/?app=123456677.\u201d","An example of the SAP entry associated with the SAP described above is \u201ckey=123456677, value=ICA-published-app-info.\u201d The key can be any length (e.g., 56 bit key, 128 bit key). In one embodiment, the key is a cryptographic random number. The key may also provides an access right to the key holder. Although illustrated with a key, any means can be used to provide a form of security to the SAP entry stored in the persistent mass storage .","The web publishing tool  provides the service-publishing request to the content server  for publishing in the web service directory  (step ). Moreover, in one embodiment, the content server  transmits the key of the SAP to the client  requesting the particular web service for subsequent use in locating the SAP entry. In one embodiment, the publishing of the service-publishing request enables users of the client  to access the service. In one embodiment, GUI applications are published on the web service directory  using NFUSE developed by Citrix Systems, Inc. of Fort Lauderdale, Fla. In some embodiments, a publisher of a GUI application customizes the publication of the GUI application on the web service directory  using Application Launching And Embedding (ALE), also developed by Citrix Systems, Inc. ALE enables the launching of a GUI application from or the embedding of the application into an HTML page.","The client  then queries a service name from the web service directory  (step ). The content server  receives the query from the client  (step ) and finds the requested service name in the web service directory . In another embodiment, the user of the client  navigates the web service directory  until locating a particular service name that the user of the client  was attempting to find. Although illustrated with the client , any web service directory client (e.g., UDDI client or LDAP browser) can query or navigate the web service directory  to discover published web services.","Upon location of the SAP associated with the received query, the content server  transmits the SAP to the client  (step ). The client  receives the SAP (step ) and determines the address of the publishing server plug-in  from the SAP. The client  subsequently transmits a request for the GUI application to the web server \u2032 (step ). In some embodiments, the request from the client  is an HTTP request transmitted from the web browser  to the web server \u2032. In other embodiments, an application (e.g., general directory browser or HTML U1) executing on the client  receives the SAP from the content server  and provides the SAP as an argument to the web browser . The web browser  may then automatically transmit an HTTP request (for the GUI application) to the web server \u2032. Following along the lines of the previous examples, a particular example of the application request to the web server \u2032 is http:\/\/web-server\/dynamic-component\/?app=123456677).","The web server \u2032, and, more particularly, the publishing server plug-in , receives the application request associated the SAP (step ) and determines the SAP entry associated with the request (step ). In one embodiment, the publishing server plug-in  receives the request from the client  and retrieves the published application information associated with the request that had been stored (as part of the SAP entry) in the persistent mass storage . In some embodiments, the publishing server plug-in  uses the SAP (or part of the SAP) that the client  received from the content server  as the key to access the proper service entry (e.g., the published application information) stored in the persistent mass storage .","The publishing server plug-in  then constructs a file or document having the published application information (e.g., HTTP address of the application server \u2033) (step ) and transmits this document to the client  (step ). The publishing server plug-in  constructs the file so that the file has a format compatible with the application client . In one embodiment, the document is a Multipurpose Internet Mail Extensions (MIME) or a secure MIME (S\/MIME) document. In another embodiment, the document is an HTML document containing an ICA web client embedded object HTML tag. In still another embodiment, the document is an HTML document containing an application streaming client embedded object HTML tag.","The web browser  subsequently receives the document and attempts to open the document. In one embodiment, if the application client  is not installed on the client , the client  communicates with the application server \u2033 to download and install the application client . Upon installation of the application client  or, alternatively, if the application client  has already been installed on the client , the client  launches the application client  to view the document received from the web server \u2032 (step ).","Once the application client  is installed and executing on the client , the application server \u2033 then executes the application and displays the application on the application client  (step ). In an alternative embodiment, the application server \u2033 transmits a plurality of application files comprising the application to the application client  for execution on the client , as described in further detail below in connection with . In another embodiment, the client  views the document (even before launching the application client ) and uses the information in the document to obtain the GUI application from the application server \u2033. In this embodiment, the display of the GUI application includes the installation and execution of the application client \u2033. Moreover, the viewing of the document may be transparent to the user of the client . For example, the client  may receive the document from the web server \u2032 and interpret the document before automatically requesting the GUI application from the application server \u2033.","Thus, the application client  provides service-based access to published applications, desktops, desktop documents, and any other application that is supported by the application client . Examples of applications that the application client  can provide access to include, but are not limited to, the WINDOWS desktops, WINDOWS documents such as MICROSOFT EXCEL, WORD, and POWERPOINT, all of which were developed by Microsoft Corporation of Redmond, Wash., Unix desktops such as SUN SOLARIS developed by Sun Microsystems of Palo Alto, Calif., and GNU\/Linux distributed by Red Hat, Inc. of Durham, N.C., among others.","In some embodiments, an enumeration of a plurality of application programs available to the client  is provided (step ) responsive to a determination by a policy engine regarding whether and how a client may access an application. The policy engine may collect information about the client prior to making the determination. Referring now to , one embodiment of a computer network is depicted, which includes a client , a collection agent , a policy engine , a policy database , a farm , and an application server \u2032. In one embodiment, the policy engine  is a server . Although only one client , collection agent , policy engine , farm , and application server \u2032 are depicted in the embodiment shown in , it should be understood that the system may provide multiple ones of any or each of those components.","In brief overview, when the client  transmits a request  to the policy engine  for access to an application, the collection agent  communicates with client , retrieving information about the client , and transmits the client information  to the policy engine . The policy engine  makes an access control decision by applying a policy from the policy database  to the received information .","In more detail, the client  transmits a request  for a resource to the policy engine . In one embodiment, the policy engine  resides on an application server \u2032. In another embodiment, the policy engine  is a server . In still another embodiment, an application server \u2032 receives the request  from the client  and transmits the request  to the policy engine . In yet another embodiment, the client transmits a request  for a resource to a server \u2033', which transmits the request  to the policy engine .","In some embodiments, the client  transmits the request  over a network connection. The network can be a local area network (LAN), a metropolitan area network (MAN), or a wide area network (WAN) such as the Internet. The client  and the policy engine  may connect to a network through a variety of connections including standard telephone lines, LAN or WAN links (e.g., T1, T3, 56 kb, X.25), broadband connections (ISDN, Frame Relay, ATM), and wireless connections. Connections between the client  and the policy engine  may use a variety of data-link layer communication protocols (e.g., TCP\/IP, IPX, SPX, NetBIOS, NetBEUI, SMB, Ethernet, ARCNET, Fiber Distributed Data Interface (FDDI), RS232, IEEE 802.11, IEEE 802.11a, IEE 802.11b, IEEE 802.11g and direct asynchronous connections). The connection may also be a communications link  as described above.","Upon receiving the request, the policy engine  initiates information gathering by the collection agent . The collection agent  gathers information regarding the client  and transmits the information  to the policy engine .","In some embodiments, the collection agent  gathers and transmits the information  over a network connection. In some embodiments, the collection agent  comprises bytecode, such as an application written in the bytecode programming language JAVA. In some embodiments, the collection agent  comprises at least one script. In those embodiments, the collection agent  gathers information by running at least one script on the client . In some embodiments, the collection agent comprises an Active X control on the client . An Active X control is a specialized Component Object Model (COM) object that implements a set of interfaces that enable it to look and act like a control.","In one embodiment, the policy engine  transmits the collection agent  to the client . In one embodiment, the policy engine  requires a second execution of the collection agent  after the collection agent  has transmitted information  to the policy engine . In this embodiment, the policy engine  may have insufficient information  to determine whether the client  satisfies a particular condition. In other embodiments, the policy engine  requires a plurality of executions of the collection agent  in response to received information .","In some embodiments, the policy engine  transmits instructions to the collection agent  determining the type of information the collection agent  gathers. In those embodiments, a system administrator may configure the instructions transmitted to the collection agent  from the policy engine . This provides greater control over the type of information collected. This also expands the types of access control decisions that the policy engine  can make, due to the greater control over the type of information collected. The collection agent  gathers information  including, without limitation, machine ID of the client , operating system type, existence of a patch to an operating system, MAC addresses of installed network cards, a digital watermark on the client device, membership in an Active Directory, existence of a virus scanner, existence of a personal firewall, an HTTP header, browser type, device type, network connection information such as internet protocol address or range of addresses, machine ID of the server , date or time of access request including adjustments for varying time zones, and authorization credentials.","In some embodiments, the device type is a personal digital assistant. In other embodiments, the device type is a cellular telephone. In other embodiments, the device type is a laptop computer. In other embodiments, the device type is a desktop computer. In other embodiments, the device type is an Internet kiosk.","In some embodiments, the digital watermark includes data embedding. In some embodiments, the watermark comprises a pattern of data inserted into a file to provide source information about the file. In other embodiments, the watermark comprises data hashing files to provide tamper detection. In other embodiments, the watermark provides copyright information about the file.","In some embodiments, the network connection information pertains to bandwidth capabilities. In other embodiments, the network connection information pertains to Internet Protocol address. In still other embodiments, the network connection information consists of an Internet Protocol address. In one embodiment, the network connection information comprises a network zone identifying the logon agent to which the client provided authentication credentials.","In some embodiments, the authorization credentials include a number of types of authentication information, including without limitation, user names, client names, client addresses, passwords, PINs, voice samples, one-time passcodes, biometric data, digital certificates, tickets, etc. and combinations thereof. After receiving the gathered information , the policy engine  makes an access control decision based on the received information .","Referring now to , a block diagram depicts one embodiment of a policy engine , including a first component  comprising a condition database  and a logon agent , and including a second component  comprising a policy database . The first component  applies a condition from the condition database  to information received about client  and determines whether the received information satisfies the condition.","In some embodiments, a condition may require that the client  execute a particular operating system to satisfy the condition. In other embodiments, a condition may require that the client  execute a particular operating system patch to satisfy the condition. In still other embodiments, a condition may require that the client  provide a MAC address for each installed network card to satisfy the condition. In some embodiments, a condition may require that the client  indicate membership in a particular Active Directory to satisfy the condition. In another embodiment, a condition may require that the client  execute a virus scanner to satisfy the condition. In other embodiments, a condition may require that the client  execute a personal firewall to satisfy the condition. In some embodiments, a condition may require that the client  comprise a particular device type to satisfy the condition. In other embodiments, a condition may require that the client  establish a particular type of network connection to satisfy the condition.","If the received information satisfies a condition, the first component  stores an identifier for that condition in a data set . In one embodiment, the received information satisfies a condition if the information makes the condition true. For example, a condition may require that a particular operating system be installed. If the client  has that operating system, the condition is true and satisfied. In another embodiment, the received information satisfies a condition if the information makes the condition false. For example, a condition may address whether spyware exists on the client . If the client  does not contain spyware, the condition is false and satisfied.","In some embodiments, the logon agent  resides outside of the policy engine . In other embodiments, the logon agent  resides on the policy engine . In one embodiment, the first component  includes a logon agent , which initiates the information gathering about client . In some embodiments, the logon agent  further comprises a data store. In these embodiments, the data store includes the conditions for which the collection agent may gather information. This data store is distinct from the condition database .","In some embodiments, the logon agent  initiates information gathering by executing the collection agent . In other embodiments, the logon agent  initiates information gathering by transmitting the collection agent  to the client  for execution on the client . In still other embodiments, the logon agent  initiates additional information gathering after receiving information . In one embodiment, the logon agent  also receives the information . In this embodiment, the logon agent  generates the data set  based upon the received information . In some embodiments, the logon agent  generates the data set  by applying a condition from the database  to the information received from the collection agent .","In another embodiment, the first component  includes a plurality of logon agents . In this embodiment, at least one of the plurality of logon agents  resides on each network domain from which a client  may transmit a resource request. In this embodiment, the client  transmits the resource request to a particular logon agent . In some embodiments, the logon agent  transmits to the policy engine  the network domain from which the client  accessed the logon agent . In one embodiment, the network domain from which the client  accesses a logon agent  is referred to as the network zone of the client .","The condition database  stores the conditions that the first component  applies to received information. The policy database  stores the policies that the second component  applies to the received data set . In some embodiments, the condition database  and the policy database  store data in an ODBC-compliant database. For example, the condition database  and the policy database  may be provided as an ORACLE database, manufactured by Oracle Corporation of Redwood Shores, Calif. In other embodiments, the condition database  and the policy database  can be a Microsoft ACCESS database or a Microsoft SQL server database, manufactured by Microsoft Corporation of Redmond, Wash.","After the first component  applies the received information to each condition in the condition database , the first component transmits the data set  to second component . In one embodiment, the first component  transmits only the data set  to the second component . Therefore, in this embodiment, the second component  does not receive client information , only identifiers for satisfied conditions. The second component  receives the data set  and makes an access control decision by applying a policy from the policy database  based upon the conditions identified within data set .","In one embodiment, policy database  stores the policies applied to the received information . In one embodiment, the policies stored in the policy database  are specified at least in part by the system administrator. In another embodiment, a user specifies at least some of the policies stored in the policy database . The user-specified policy or policies are stored as preferences. The policy database  can be stored in volatile or non-volatile memory or, for example, distributed through multiple servers.","In one embodiment, a policy allows access to a resource only if one or more conditions are satisfied. In another embodiment, a policy allows access to a resource but prohibits transmission of the resource to the client . Another policy might make connection contingent on the client  that requests access being within a secure network. In some embodiments, the resource is an application program and the client  has requested execution of the application program. In one of these embodiments, a policy may allow execution of the application program on the client . In another of these embodiments, a policy may enable the client  to receive a stream of files comprising the application program. In this embodiment, the stream of files may be stored and executed in an isolation environment. In still another of these embodiments, a policy may allow only execution of the application program on a server, such as an application server, and require the server to transmit application-output data to the client .","Referring now to , a flow diagram depicts one embodiment of the steps taken by the policy engine  to make an access control decision based upon information received about a client . Upon receiving gathered information about the client  (Step ), the policy engine  generates a data set based upon the information (Step ). The data set  contains identifiers for each condition satisfied by the received information . The policy engine  applies a policy to each identified condition within the data set . That application yields an enumeration of resources which the client  may access (Step ). The policy engine  then presents that enumeration to the client . In some embodiments, the policy engine  creates a Hypertext Markup Language (HTML) document used to present the enumeration to the client.","Referring to , and in more detail, one embodiment of a network constructed is depicted, which includes a client , a collection agent , a policy engine , a policy database , a condition database , a client , \u2032, a session server , a stored application database , a first server \u2032, a first database , a second server \u2033, and a second database . In brief overview, when the client  transmits to the access control server  or policy engine, a request  for access to an application program, the collection agent  communicates with client , retrieves information about client , and transmits the client information  to the policy engine . The policy engine  makes an access control decision, as discussed above in  and , and the client  receives an enumeration of available applications associated with the client .","In some embodiments, the session server  establishes a connection between the client  and a plurality of application sessions associated with the client . In other embodiments, the policy engine  determines that the client  has authorization to retrieve a plurality of application files comprising the application and to execute the application program locally. In one of these embodiments, the server \u2032 stores application session data and a plurality of application files comprising the application program. In another of these embodiments, the client  establishes an application streaming session with a server \u2032 storing the application session data and the plurality of application files comprising the application program.","Referring now to , a flow diagram depicts one embodiment of the steps taken by the session server  to provide access for the client  to its associated application sessions. The session server  receives information about the client  from the policy engine  containing access control decision the policy engine  made (step ). The session server  generates an enumeration of associated applications (step ). The session server  may connect the client  to an associated application (step ). In one embodiment, the information also includes the client machine information . In another embodiment, the information includes authorization to execute the application program locally.","The session server  generates an enumeration of associated applications (step ). In some embodiments, the policy engine  identifies a plurality of application sessions already associated with the client . In other embodiments, the session server  identifies stored application sessions associated with the client . In some of these embodiments, the session server  automatically identifies the stored application sessions upon receiving the information from the policy engine . In one embodiment, the stored application database  resides on the session server . In another embodiment, the stored application database  resides on the policy engine .","The stored application database  contains data associated with a plurality of servers in the farm  executing application sessions or providing access to application session data and application files comprising application programs. In some embodiments, identifying the application sessions associated with the client  requires consulting stored data associated with one or more servers or servers. In some of these embodiments, the session store  consults the stored data associated with one or more servers. In others of these embodiments, the policy engine  consults the stored data associated with one or more servers. In some embodiments, a first application session runs on a first server \u2032 and a second application session runs on a second server \u2033. In other embodiments, all application sessions run on a single server  within the farm .","The session server  includes information related to application sessions initiated by users. The session server can be stored in volatile or non-volatile memory or, for example, distributed through multiple servers. Table 1 shows the data included in a portion of an illustrative session server :",{"@attributes":{"id":"p-0161","num":"0160"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Application Session","App Session 1","App Session 2","App Session 3"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["User ID","User 1","User 2","User 1"]},{"entry":["Client ID","First Client",{},"First Client"]},{"entry":["Client Address","172.16.0.50",{},"172.16.0.50"]},{"entry":["Status","Active","Disconnected","Active"]},{"entry":["Applications","Word Processor","Data Base","Spreadsheet"]},{"entry":["Process Number","1","3","2"]},{"entry":["Server","Server A","Server A","Server B"]},{"entry":["Server Address","172.16.2.55","172.16.2.55","172.16.2.56"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"The illustrative session server  in Table  includes data associating each application session with the user that initiated the application session, an identification of the client computer , \u2032, if any, from which the user is currently connected to the server \u2032, and the IP address of that client computer , \u2032. The illustrative session server  also includes the status of each application session. An application session status can be, for example, \u201cactive\u201d (meaning a user is connected to the application session), or \u201cdisconnected\u201d (meaning a user is not connected to the application session). In an alternative embodiment, an application session status can also be set to \u201cexecuting-disconnected\u201d (meaning the user has disconnected from the application session, but the applications in the application session are still executing), or \u201cstalled-disconnected\u201d (meaning the user is disconnected and the applications in the application session are not executing, but their operational state immediately prior to the disconnection has been stored). The session server  further stores information indicating the applications that are executing within each application session and data indicating each application's process on the server. In embodiments in which the server \u2032 is part of the farm , the session server  is at least a part of the dynamic store, and also includes the data in the last two rows of Table 1 that indicate on which server  in the farm  each application is\/was executing, and the IP address of that server . In alternative embodiments, the session server  includes a status indicator for each application in each application session.","For example, in the example of Table 1, three application sessions exist, App Session , App Session , and App Session . App Session  is associated with User , who is currently using terminal . Terminal 's IP address is 152.16.2.50. The status of App Session  is active, and in App Session , a word processing program, is being executed. The word processing program is executing on Server A as process number . Server A's IP address is 152.16.2.55. App Session  in Table 1 is an example of a disconnected application session . App Session  is associated with User , but App Session  is not connected to a client  or . App Session  includes a database program that is executing on Server A, at IP address 152.16.2.55 as process number . App Session  is an example of how a user can interact with application sessions operating on different servers . App Session  is associated with User , as is App Session . App Session  includes a spreadsheet program that is executing on Server B at IP address 152.16.2.56 as process number , whereas the application session included in App Session  is executing on Server A.","In another example, a user may access a first application program through an application session executing on a server \u2032, such as Server A, while communicating across an application streaming session with a second server \u2033, such as Server B, to retrieve a second application program from the second server \u2033 for local execution. The user of the client  may have acquired authorization to execute the second application program locally while failing to satisfy the execution pre-requisites of the first application program.","In one embodiment, the session server  is configured to receive a disconnect request to disconnect the application sessions associated with the client  and disconnects the application sessions in response to the request. The session server  continues to execute an application session after disconnecting the client  from the application session. In this embodiment, the session server  accesses the stored application database  and updates a data record associated with each disconnected application session so that the record indicates that the application session associated with the client  is disconnected.","After receiving authentication information associated with a client connecting to the network, the session server  consults the stored applications database  to identify any active application sessions that are associated with a user of the client, but that are connected to a different client, such as the client \u2032 if the authentication information is associated with client \u2032, for example. In one embodiment, if the session server  identifies any such active application sessions, the session server  automatically disconnects the application session(s) from the client  and connects the application session(s) to the current client \u2032. In some embodiments, the received authentication information will restrict the application sessions to which the client  may reconnect. In other embodiments, the received authentication information authorizes execution of an application program on the client \u2032, where the authorization may have been denied to client . In one of these embodiments, the session server  may provide the client access information for retrieving the application program for local execution.","A request is received to execute an enumerated application (step ). In one embodiment, a user of the client  selects an application for execution from a received enumeration of available applications. In another embodiment, the user selects an application for execution independent of the received enumeration. In some embodiments, the user selects an application for execution by selecting a graphical representation of the application presented on the client  by a client agent. In other embodiments, the user selects an application for execution by selecting a graphical representation of the application presented to the user on a web server or other server \u2032\u2033.","In still other embodiments, the user requests to access a file. In one of these embodiments, execution of an application is required to provide the user with access to the file. In another of these embodiments, the application is automatically selected for execution upon selection of the file for access. In still another of these embodiments, prior to the request for access to the file, the application is associated with a type of file, enabling automatic selection of the application upon identification of a type of file associated with the requested file.","In one embodiment, the enumerated application comprises a plurality of application files. In some embodiments, the plurality of application files reside on the server \u2032. In other embodiments, the plurality of application files reside on a separate file server or server \u2033. In still other embodiments, the plurality of application files may be transmitted to a client . In yet other embodiments, a file in the plurality of application files may be executed prior to transmission of a second file in the plurality of application files to the client .","In some embodiments, the server  retrieves information about the enumerated application from a server \u2032. In one of these embodiments, the server  receives an identification of a server \u2033 hosting a plurality of application files. In another of these embodiments, the server  receives identification of a location of a plurality of application files, the identification conforming to a Universal Naming Convention (UNC). In still another of these embodiments, the identification includes a network location and a socket for an application streaming protocol.","In one embodiment, the server  retrieves a file containing information about the enumerated application. The file may include an identification of a location of a server hosting the enumerated application. The file may include an identification of a plurality of versions of the enumerated application. The file may include an enumeration of a plurality of application files comprising the enumerated application. The file may include an identification of a compressed file comprising a plurality of applications files comprising the enumerated application. The file may include an identification of pre-requisites to be satisfied by a machine executing the enumerated application. The file may include an enumeration of data files associated with the enumerated application. The file may include an enumeration of scripts to be executed on a machine executing the enumerated application. The file may include an enumeration of registry data associated with the enumerated application. The file may include an enumeration of rules for use in an embodiment where the enumerated application executes within an isolation environment. In one embodiment, the file may be referred to as a \u201cmanifest\u201d file.","In some embodiments, the server  applies a policy to an identified characteristic of the client . In one of these embodiments, the server  identifies a version of the enumerated application for execution responsive to the identified characteristic. In another of these embodiments, the server  makes a determination to execute a version of the enumerated application compatible with a characteristic of the client . In still another of these embodiments, the server  makes a determination to execute a version of the enumerated application compatible with an operating system executing on the client . In yet another of these embodiments, the server  makes a determination to execute a version of the enumerated application compatible with a revision level of an operating system on the client . In one of these embodiments, the server  makes a determination to execute a version of the enumerated application compatible with a language specified by an operating system on the client .","One of a predetermined number of methods for executing the enumerated application is selected, responsive to a policy, the predetermined number of methods including a method for application streaming of the enumerated application (step ). In one embodiment, the selection is made responsive to an application of a policy to the received credentials associated with the client . In some embodiments, the selection is made by a policy engine such as the policy engine  described above in ,  and . In other embodiments, the server  receiving the credentials and the request to execute the enumerated application further comprises such a policy engine .","In one embodiment, the predetermined number of methods includes a method for executing the enumerated application on a server \u2032. In another embodiment, the predetermined number of methods includes a method for executing the enumerated application on the client . In still another embodiment, the predetermined number of methods includes a method for executing the enumerated application on a second server \u2032.","In some embodiments, the predetermined number of methods includes a method for providing the enumerated application to the client  across an application streaming session. In one of these embodiments, the client  comprises a streaming service agent capable of initiating a connection with a server \u2032 and receiving from the server \u2032 a stream of transmitted data packets.","The stream of data packets may include application files comprising the enumerated application. In some embodiments, application files include data files associated with an application program. In other embodiments, application files include executable files required for execution of the application program. In still other embodiments, the application files include metadata including information about the files, such as location, compatibility requirements, configuration data, registry data, identification of execution scripts rules for use in isolation environments, or authorization requirements.","In some embodiments, the streamed application executes prior to the transmission of each application file in a plurality of application files comprising the streamed application. In one of these embodiments, execution of the streamed application begins upon receipt by a client  of one application file in the plurality of applications. In another of these embodiments, execution of the streamed application begins upon receipt by a client  of an executable application file in the plurality of application files. In still another of these embodiments, the client  executes a first received application file in a plurality of application files and the first received application file requests access to a second application file in the plurality of application files.","In one embodiment, the streamed application executes on the client  without permanently residing on the client . In this embodiment, the streamed application may execute on the client  and be removed from the client  upon termination of the streamed application. In another embodiment, the streamed application executes on the client  after a pre-deployed copy of each application file is stored on the client . In still another embodiment, the streamed application executes on the client  after a copy of each application file is stored in an isolation environment on the client . In yet another embodiment, the streamed application executes on the client  after a copy of each application file is stored in a cache on the client .","In one embodiment, the method for streaming the application to the client  is selected from the predetermined number of methods responsive to a determination that the client  may receive the streamed application files. In another embodiment, the method for streaming the application to the client  is selected from the predetermined number of methods responsive to a determination that the client  has authority to execute the streamed application files locally at the client .","In other embodiments, the predetermined number of methods include a method for providing application-output data to the client , the application-output data generated from an execution of the enumerated application on a server . In one of these embodiments, the server  is the server  receiving the request for execution of the enumerated application. In another of these embodiments, the server  is a second server \u2032, such as a file server or an application server. In some embodiments, the enumerated application resides on the server \u2032 executing the enumerated application. In other embodiments, the server \u2032 executing the enumerated application first receives the enumerated application from a second server \u2032 across an application streaming session. In one of these embodiments, the server \u2032 comprises a streaming service agent capable of initiating a connection with a second server \u2032 and receiving from the second server \u2032 a stream of transmitted data. In another of these embodiments, the second server \u2032 may be identified using a load balancing technique. In still another of these embodiments, the second server \u2032 may be identified based upon proximity to the server \u2032.","In some embodiments, the server  selects from the predetermined number of methods for executing the enumerated application, a method for streaming the enumerated application to the server , executing the enumerated application on the server , and providing to the client  application-output data generated by the execution of the enumerated application. In one of these embodiments, the server  selects the method responsive to an evaluation of the client . In another of these embodiments the determination is made responsive to an application of a policy to the evaluation of the client . In still another of these embodiments, the determination is made responsive to an evaluation of the received credentials. In one embodiment, the server  receives a plurality of application files comprising the enumerated application. In another embodiment, the server  provides the application-output data via a presentation level protocol, such as an ICA presentation level protocol or a Remote Desktop Windows presentation level protocol or an X-Windows presentation level protocol.","In some embodiments, the server  also provides access information associated with the enumerated application, the access information generated responsive to the selected method. In one of these embodiments, the access information provides an indication to the client  of the selected method for execution of the enumerated application program. In another of these embodiments, the access information includes an identification of a location of the enumerated application, the identification conforming to a Universal Naming Convention (UNC). In still another of these embodiments, the access information includes an identification of a session management server.","In some embodiments, the access information includes a launch ticket comprising authentication information. In one of these embodiments, the client  may use the launch ticket to authenticate the access information received from the server . In another of these embodiments, the client  may use the launch ticket to authenticate itself to a second server  hosting the enumerated application. In still another of these embodiments, the server  includes the launch ticket in the access information responsive to a request from the client  for the launch ticket.","Referring now to , a block diagram depicts an embodiment of the system described herein in which a client  requests execution of an application program and a server  selects a method of executing the application program. In one embodiment, the server  receives credentials from the client . In another embodiment, the server  receives a request for an enumeration of available applications from the client .","In some embodiments, multiple, redundant, servers , \u2032, \u2033, \u2032\u2033, and \u2033\u2033 are provided. In one of these embodiments, there may be, for example, multiple file servers, multiple session management servers, multiple staging machines, multiple web interfaces, or multiple access suite consoles. In another of these embodiments, if a server fails, a redundant server  is selected to provide the functionality of the failed machine. In other embodiments, although the servers , \u2032, \u2033, \u2032\u2033, and \u2033\u2033, and the web interface  and access suite console  are described as separate servers  having the separate functionalities of a management server, a session management server, a staging machine, a file server, a web server, and an access suite console, a single server  may be provided having the functionality of all of these machines. In still other embodiments, a server  may provide the functionality and services of one or more of the other servers.","Referring now to  in greater detail, a block diagram depicts one embodiment of a server  providing access to an application program. In addition to the interfaces and subsystems described above in connection with , the server  may further include a management communication service , an XML service , and a management service . The management service  may comprise an application management subsystem , a server management subsystem , a session management subsystem , and a license management subsystem . The server  may be in communication with an access suite console .","In one embodiment, the management service  further comprises a specialized remote procedure call subsystem, the MetaFrame Remote Procedure Call (MFRPC) subsystem . In some embodiments, the MFRPC subsystem  routes communications between subsystems on the server , such as the XML service , and the management service . In other embodiments, the MFRPC subsystem  provides a remote procedure call (RPC) interface for calling management functions, delivers RPC calls to the management service , and returns the results to the subsystem making the call.","In some embodiments, the server  is in communication with a protocol engine, such as the protocol engine  described above in . In one of these embodiments, the server  is in communication with a protocol engine  residing on a server \u2032. In other embodiments, the server  further comprises a protocol engine .","The server  may be in communication with an access suite console . The access suite console  may host management tools to an administrator of a server  or of a farm . In some embodiments, the server  communicates with the access suite console  using XML. In other embodiments, the server  communicates with the access suite console  using the Simple Object Access Protocol (SOAP).","For embodiments such as those described in  and in  in which the server  comprises a subset of subsystems, the management service  may comprise a plurality of subsystems. In one embodiment, each subsystem is either a single-threaded or a multi-threaded subsystem. A thread is an independent stream of execution running in a multi-tasking environment. A single-threaded subsystem is capable of executing only one thread at a time. A multi-threaded subsystem can support multiple concurrently executing threads, i.e., a multi-threaded subsystem can perform multiple tasks simultaneously.","The application management subsystem  manages information associated with a plurality of applications capable of being streamed. In one embodiment, the application management subsystem  handles requests from other components, such as requests for storing, deleting, updating, enumerating or resolving applications. In another embodiment, the application management subsystem  handles requests sent by components related to an application capable of being streamed. These events can be classified into three types of events: application publishing, application enumeration and application launching, each of which will be described in further detail below. In other embodiments, the application management subsystem  further comprises support for application resolution, application publication and application publishing. In other embodiments, the application management subsystem , uses a data store to store application properties and policies.","The server management subsystem  handles configurations specific to application streaming in server farm configurations. In some embodiments, the server management subsystem  also handles events that require retrieval of information associated with a configuration of a farm . In other embodiments, the server management subsystem  handles events sent by other components related to servers providing access to applications across application streams and properties of those servers. In one embodiment, the server management subsystem  stores server properties and farm properties.","In some embodiments, the server  further comprises one or more common application subsystems  providing services for one or more specialized application subsystems. These servers  may also have one or more common server subsystems providing services for one or more specialized server subsystems. In other embodiments, no common application subsystems  are provided, and each specialized application and server subsystem implements all required functionality.","In one embodiment in which the server  comprises a common application subsystem , the common application subsystem  manages common properties for published applications. In some embodiments, the common application subsystem  handles events that require retrieval of information associated with published applications or with common properties. In other embodiments, the common application subsystem  handles all events sent by other components related to common applications and their properties.","A common application subsystem  can \u201cpublish\u201d applications to the farm , which makes each application available for enumeration and launching by a client . Generally, an application is installed on each server  on which availability of that application is desired. In one embodiment, to publish an application, an administrator runs an administration tool specifying information such as the servers  hosting the application, the name of the executable file on each server, the required capabilities of a client for executing the application (e.g., audio, video, encryption, etc.), and a list of users that can use the application. This specified information is categorized into application-specific information and common information. Examples of application-specific information are: the path name for accessing the application and the name of the executable file for running the application. Common information (i.e., common application data) includes, for example, the user-friendly name of the application (e.g., \u201cMicrosoft WORD 2000\u201d), a unique identification of the application, and the users of the application.","The application-specific information and common information may be sent to a specialized application subsystem controlling the application on each server  hosting the application. The specialized application subsystem may write the application-specific information and the common information into a persistent store .","When provided, a common application subsystem  also provides a facility for managing the published applications in the farm . Through a common application subsystem , an administrator can manage the applications of the farm  using an administration tool such as the access suite console  to configure application groups and produce an application tree hierarchy of those application groups. Each application group may be represented as a folder in the application tree hierarchy. Each application folder in the application tree hierarchy can include one or more other application folders and specific instances of servers. The common application subsystem  provides functions to create, move, rename, delete, and enumerate application folders.","In one embodiment, the common application subsystem  supports the application management subsystem  in handling application enumeration and application resolution requests. In some embodiments, the common application subsystem  provides functionality for identifying an application for execution responsive to a mapping between a type of data file and an application for processing the type of data file. In other embodiments, a second application subsystem provides the functionality for file type association.","In some embodiments, the server  may further comprise a policy subsystem. A policy subsystem includes a policy rule for determining whether an application may be streamed to a client  upon a request by the client  for execution of the application. In some embodiments, the policy subsystem identifies a server access option associated with a streamed application published in the access suite console . In one of these embodiments, the policy subsystem uses the server access option as a policy in place of the policy rule.","The session monitoring subsystem  maintains and updates session status of an application streaming session associated with a client  and enforces license requirements for application streaming sessions. In one embodiment the session management subsystem  monitors sessions and logs events, such as the launching of an application or the termination of an application streaming session. In another embodiment, the session monitoring subsystem  receives communications, such as heartbeat messages, transmitted from the client  to the server . In still another embodiment, the session management subsystem  responds to queries about sessions from management tools, such as tools within the access suite console . In some embodiments, the management service  further comprises a license management subsystem communicating with the session management subsystem to provide and maintain licenses to clients for execution of applications.","In one embodiment, the management service  provides functionality for application enumeration and application resolution. In some embodiments, the management service  also provides functionality for application launching, session monitoring and tracking, application publishing, and license enforcement.","Referring now to , a block diagram depicts one embodiment of a server  comprising a management service providing an application enumeration. The management service  may provide application enumeration through the use of a web interface interacting with an XML service . In one embodiment, XML service  enumerates applications for a user of a client . In another embodiment, the XML service  implements the functionality of the ICA browser subsystem and the program neighborhood subsystem described above. The XML service  may interact with a management communications service . In one embodiment, the XML service  generates an application enumeration request using the management communications service . The application enumeration request may include a client type indicating a method of execution to be used when executing the enumerated application. The application enumeration request is sent to a common application subsystem . In one embodiment, the common application subsystem  returns an enumeration of applications associated with the client type of the application enumeration request. In another embodiment, the common application subsystem  returns an enumeration of applications available to the user of the client , the enumeration selected responsive to an application of a policy to a credential associated with the client . In this embodiment, a policy engine  may apply the policy to credentials gathered by a collection agent , as described in connection with  above. In still another embodiment, the enumeration of applications is returned and an application of a policy to the client  is deferred until an execution of an enumerated application is requested.","The management service  may provide application resolution service for identifying a second server \u2032 hosting an application. In one embodiment, the second server \u2032 is a file server or an application server. In some embodiments, the management service  consults a file including identifiers for a plurality of servers  hosting applications. In one embodiment, the management service  provides the application resolution service responsive to a request from a client  for execution of an application. In another embodiment, the management service  identifies a second server \u2032 capable of implementing a different method of executing the application than a first server . In some embodiments, the management service  identifies a first server \u2032 capable of streaming an application program to a client  and a second server \u2032 capable of executing the application program and providing application-output data generated responsive to the execution of the application program to the client .","In one embodiment, a web interface transmits an application resolution request to the XML service . In another embodiment, the XML service  receives a application resolution request and transmits the request to the MFRPC subsystem .","In one embodiment, the MFRPC subsystem  identifies a client type included with a received application resolution request. In another embodiment, the MFRPC subsystem applies a policy to the client type and determines to \u201cstream\u201d the application to the client . In this embodiment, the MFRPC subsystem  may forward the application resolution request to an application management subsystem . In one embodiment, upon receiving the application resolution request from the MFRPC subsystem , the application management subsystem  may identify a server \u2033\u2033 functioning as a session management server  for the client . In some embodiments, the client transmits a heartbeat message to the session management server . In another embodiment, the application management subsystem  may identify a server \u2032 hosting a plurality of application files comprising the application to be streamed to the client .","In some embodiments, the application management subsystem  uses a file enumerating a plurality of servers hosting the plurality of application files to identify the server \u2032. In other embodiments, the application management subsystem  identifies a server \u2032 having an IP address similar to an IP address of the client . In still other embodiments, the application management subsystem  identifies a server \u2032 having an IP address in a range of IP addresses accessible to the client .","In still another embodiment, the MFRPC subsystem  applies a policy to the client type and determines that the application may be executed on a server \u2032, the server \u2032 transmitting application-output data generated by an execution of the application to the client . In this embodiment, the MFRPC subsystem  may forward the application resolution request to a common application subsystem  to retrieve an identifier of a host address for a server \u2032. In one embodiment, the identified server \u2032 may transmit the application-output data to the client using a presentation level protocol such as ICA or RDP or X Windows. In some embodiments, the server \u2032 receives the application from a second server \u2032 across an application streaming session.","In one embodiment, upon completion of application enumeration and application resolution, access information is transmitted to the client  that includes an identification of a method of execution for an enumerated application and an identifier of a server \u2032 hosting the enumerated application. In one embodiment where the management service  determines that the enumerated application will execute on the client , a web interface creates and transmits to the client  a file containing name-resolved information about the enumerated application. In some embodiments, the file may be identified using a \u201c.rad\u201d extension. The client  may execute the enumerated application responsive to the contents of the received file. Table 2 depicts one embodiment of information contained in the file:",{"@attributes":{"id":"p-0209","num":"0208"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Field","Description","Source"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["UNC path","Points to a Container master manifest","XML service"]},{"entry":[{},"file on the file server"]},{"entry":["Initial program","Program to launch from container","XML service"]},{"entry":["Command line","For launching documents using","XML service"]},{"entry":[{},"FTA"]},{"entry":["Web server URL","For messages from RADE client to","WI config"]},{"entry":[{},"WI"]},{"entry":["Farm ID","The farm the application belongs","WI config"]},{"entry":[{},"to - needed for heartbeat messages"]},{"entry":["LaunchTicket","Application streaming client uses","XML\/IMA"]},{"entry":[{},"LaunchTicket to acquire a license"]},{"entry":[{},"authorizing execution of the"]},{"entry":[{},"program"]},{"entry":["ICA fallback","Embedded ICA file for fallback, if","XML Service"]},{"entry":["launch info","fallback is to be allowed"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The file may also contain a launch ticket for use by the client in executing the application, as shown in Table 2. In some embodiments, the launch ticket expires after a predetermined period of time. In one embodiment, the client provides the launch ticket to a server hosting the enumerated application to be executed. Use of the launch ticket to authorize access to the enumerated application by a user of the client assists in preventing the user from reusing the file or generating an unauthorized version of the file to inappropriately access to applications. In one embodiment, the launch ticket comprises a large, randomly-generated number.","As described above in connection with , a method for selecting a method of execution of an application program begins when credentials associated with the client  or with a user of the client  are received (step ) and an enumeration of a plurality of application programs available to the client  is provided, responsive to the received credentials (step ). A request is received to execute an enumerated application (step ) and one of a predetermined number of methods for executing the enumerated application is selected, responsive to a policy, the predetermined number of methods including a method for application streaming of the enumerated application (step ).","Referring now to , a flow diagram depicts one embodiment of the steps taken to access a plurality of files comprising an application program. A client performs a pre-launch analysis of the client (step ). In one embodiment, the client  performs the pre-launch analysis prior to retrieving and executing a plurality of application files comprising an application program. In another embodiment, the client  performs the pre-launch analysis responsive to a received indication that the pre-launch analysis is a requirement for authorization to access the plurality of application files comprising an application program.","In some embodiments, the client  receives, from a server , access information associated with the plurality of application files. In one of these embodiments, the access information includes an identification of a location of a server \u2032 hosting the plurality of application files. In another of these embodiments, the client  receives an identification of a plurality of applications comprising one or more versions of the application program. In still another of these embodiments, the client  receives an identification of a plurality of application files comprising one or more application programs. In other embodiments, the client  receives an enumeration of application programs available to the client  for retrieval and execution. In one of these embodiments, the enumeration results from an evaluation of the client . In still other embodiments, the client  retrieves the at least one characteristic responsive to the retrieved identification of the plurality of application files comprising an application program.","In some embodiments, the access information includes a launch ticket capable of authorizing the client to access the plurality of application files. In one of these embodiments, the launch ticket is provided to the client  responsive to an evaluation of the client . In another of these embodiments, the launch ticket is provided to the client  subsequent to a pre-launch analysis of the client  by the client .","In other embodiments, the client  retrieves at least one characteristic required for execution of the plurality of application files. In one of these embodiments, the access information includes the at least one characteristic. In another of these embodiments, the access information indicates a location of a file for retrieval by the client , the file enumerating the at least one characteristic. In still another of these embodiments, the file enumerating the at least one characteristic further comprises an enumeration of the plurality of application files and an identification of a server  hosting the plurality of application files.","The client  determines the existence of the at least one characteristic on the client. In one embodiment, the client  makes this determination as part of the pre-launch analysis. In another embodiment, the client  determines whether the client  has the at least one characteristic.","In one embodiment, determining the existence of the at least one characteristic on the client  includes determining whether a device driver is installed on the client. In another embodiment, determining the existence of the at least one characteristic on the client  includes determining whether an operating system is installed on the client . In still another embodiment, determining the existence of the at least one characteristic on the client  includes determining whether a particular operating system is installed on the client . In yet another embodiment, determining the existence of the at least one characteristic on the client  includes determining whether a particular revision level of an operating system is installed on the client .","In some embodiments, determining the existence of the at least one characteristic on the client  includes determining whether the client  has acquired authorization to execute an enumerated application. In one of these embodiments, a determination is made by the client  as to whether the client  has received a license to execute the enumerated application. In another of these embodiments, a determination is made by the client  as to whether the client  has received a license to receive across an application streaming session a plurality of application files comprising the enumerated application. In other embodiments, determining the existence of the at least one characteristic on the client  includes determining whether the client  has sufficient bandwidth available to retrieve and execute an enumerated application.","In some embodiments, determining the existence of the at least one characteristic on the client  includes execution of a script on the client . In other embodiments, determining the existence of the at least one characteristic on the client  includes installation of software on the client . In still other embodiments, determining the existence of the at least one characteristic on the client  includes modification of a registry on the client . In yet other embodiments, determining the existence of the at least one characteristic on the client  includes transmission of a collection agent  to the client  for execution on the client  to gather credentials associated with the client .","The client  requests, from a server , authorization for execution of the plurality of application files, the request including a launch ticket (step ). In some embodiments, the client  makes the request responsive to a determination that at least one characteristic exists on the client . In one of these embodiments, the client  determines that a plurality of characteristics exist on the client , the plurality of characteristics associated with an enumerated application and received responsive to a request to execute the enumerated application. In another of these embodiments, whether the client  receives an indication that authorization for execution of the enumerated application files depends upon existence of the at least one characteristic on the client . In one embodiment, the client  received an enumeration of application programs, requested execution of an enumerated application, and received access information including the at least one characteristic and a launch ticket authorizing the execution of the enumerated application upon the determination of the existence of the at least one characteristic on the client .","In one embodiment, the client  receives from the server  a license authorizing execution of the plurality of application files. In some embodiments, the license authorizes execution for a specified time period. In one of these embodiments, the license requires transmission of a heart beat message to maintain authorization for execution of the plurality of application files.","In another embodiment, the client  receives from the server  the license and an identifier associated with a server  monitoring execution of the plurality of application files. In some embodiments, the server is a session management server , as depicted above in . In one of these embodiments, the session management server  includes a session management subsystem  that monitors the session associated with the client . In other embodiments, a separate server \u2033\u2033 is the session management server .","The client  receives and executes the plurality of application files (step ). In one embodiment, the client  receives the plurality of application files across an application streaming session. In another embodiment, the client  stores the plurality of application files in an isolation environment on the client . In still another embodiment, the client  executes one of the plurality of application files prior to receiving a second of the plurality of application files. In some embodiments, a server transmits the plurality of application files to a plurality of clients, each client in the plurality having established a separate application streaming session with the server.","In some embodiments, the client  stores the plurality of application files in a cache and delays execution of the application files. In one of these embodiments, the client  receives authorization to execute the application files during a pre-defined period of time. In another of these embodiments, the client  receives authorization to execute the application files during the pre-defined period of time when the client  lacks access to a network. In other embodiments, the client stores the plurality of application files in a cache. In one of these embodiments, the application streaming client  establishes an internal application streaming session to retrieve the plurality of application files from the cache. In another of these embodiments, the client  receives authorization to execute the application files during a pre-defined period of time when the client  lacks access to a network.","The client  transmits at least one heartbeat message to a server (step ). In some embodiments, the client  transmits the at least one heartbeat message to retain authorization to execute the plurality of application files comprising the enumerated application. In other embodiments, the client  transmits the at least one heartbeat message to retain authorization retrieve an application file in the plurality of application files. In still other embodiments, the client  receives a license authorizing execution of the plurality of application files during a pre-determined period of time.","In some embodiments, the client  transmits the heartbeat message to a second server \u2033\u2033. In one of these embodiments, the second server \u2033\u2033 may comprise a session management server  monitoring the retrieval and execution of the plurality of application files. In another of these embodiments, the second server \u2033\u2033 may renew a license authorizing execution of the plurality of application files, responsive to the transmitted heartbeat message. In still another of these embodiments, the second server \u2033\u2033 may transmit to the client  a command, responsive to the transmitted heartbeat message.","Referring back to , the client  may include an application streaming client , a streaming service  and an isolation environment .","The application streaming client  may be an executable program. In some embodiments, the application streaming client  may be able to launch another executable program. In other embodiments, the application streaming client  may initiate the streaming service . In one of these embodiments, the application streaming client  may provide the streaming service  with a parameter associated with executing an application program. In another of these embodiments, the application streaming client  may initiate the streaming service  using a remote procedure call.","In one embodiment, the client  requests execution of an application program and receives access information from a server  regarding execution. In another embodiment, the application streaming client  receives the access information. In still another embodiment, the application streaming client  provides the access information to the streaming service . In yet another embodiment, the access information includes an identification of a location of a file associated with a plurality of application files comprising the application program.","In one embodiment, the streaming service  retrieves a file associated with a plurality of application files. In some embodiments, the retrieved file includes an identification of a location of the plurality of application files. In one of these embodiments, the streaming service  retrieves the plurality of application files. In another of these embodiments, the streaming service  executes the retrieved plurality of application files on the client . In other embodiments, the streaming service  transmits heartbeat messages to a server to maintain authorization to retrieve and execute a plurality of application files.","In some embodiments, the retrieved file includes an identification of a location of more than one plurality of application files, each plurality of application files comprising a different application program. In one of these embodiments, the streaming service  retrieves the plurality of application files comprising the application program compatible with the client . In another of these embodiments, the streaming service  receives authorization to retrieve a particular plurality of application files, responsive to an evaluation of the client .","In some embodiments, the plurality of application files are compressed and stored on a file server within an archive file such as a CAB, ZIP, SIT, TAR, JAR or other archive file. In one embodiment, a plurality of application files stored in an archive file comprise an application program. In another embodiment, multiple pluralities of application files stored in an archive file each comprise different versions of an application program. In still another embodiment, multiple pluralities of application files stored in an archive file each comprise different application programs. In some embodiments, an archive file includes metadata associated with each file in the plurality of application files. In one of these embodiments, the streaming service  generates a directory structure responsive to the included metadata. As will be described in greater detail in connection with  below, the metadata may be used to satisfy requests by application programs for directory enumeration.","In one embodiment, the streaming service  decompresses an archive file to acquire the plurality of application files. In another embodiment, the streaming service  determines whether a local copy of a file within the plurality of application files exists in a cache on the client  prior to retrieving the file from the plurality of application files. In still another embodiment, the file system filter driver  determines whether the local copy exists in the cache. In some embodiments, the streaming service  modifies a registry entry prior to retrieving a file within the plurality of application files.","In some embodiments, the streaming service  stores a plurality of application files in a cache on the client . In one of these embodiments, the streaming service  may provide functionality for caching a plurality of application files upon receiving a request to cache the plurality of application files. In another of these embodiments, the streaming service  may provide functionality for securing a cache on the client . In another of these embodiments, the streaming service  may use an algorithm to adjust a size and a location of the cache.","In some embodiments, the streaming service  creates an isolation environment  on the client . In one of these embodiments, the streaming service  uses an isolation environment application programming interface to create the isolation environment . In another of these embodiments, the streaming service  stores the plurality of application files in the isolation environment . In still another of these embodiments, the streaming service  executes a file in the plurality of application files within the isolation environment. In yet another of these embodiments, the streaming service  executes the application program in the isolation environment.","For embodiments in which authorization is received to execute an application on the client , the execution of the application may occur within an isolation environment . In some embodiments, a plurality of application files comprising the application are stored on the client  prior to execution of the application. In other embodiments, a subset of the plurality of application files are stored on the client  prior to execution of the application. In still other embodiments, the plurality of application files do not reside in the isolation environment . In yet other embodiments, a subset of the plurality of applications files do not reside on the client . Regardless of whether a subset of the plurality of application files or each application file in the plurality of application files reside on the client  or in isolation environment , in some embodiments, an application file in the plurality of application files may be executed within an isolation environment .","The isolation environment  may consist of a core system able to provide File System Virtualization, Registry System Virtualization, and Named Object Virtualization to reduce application compatibility issues without requiring any change to the application source code. The isolation environment  may redirect application resource requests using hooking both in the user mode for registry and named object virtualization, and in the kernel using a file system filter driver for file system virtualization. The following is a description of some embodiments of an isolation environment .","Referring now to , one embodiment of a computer running under control of an operating system  that has reduced application compatibility and application sociability problems is shown. The operating system  makes available various native resources to application programs ,  via its system layer . The view of resources embodied by the system layer  will be termed the \u201csystem scope\u201d. In order to avoid conflicting access to native resources , , ,  by the application programs , , an isolation environment  is provided. As shown in , the isolation environment  includes an application isolation layer  and a user isolation layer . Conceptually, the isolation environment  provides, via the application isolation layer , an application program , , with a unique view of native resources, such as the file system , the registry , objects , and window names . Each isolation layer modifies the view of native resources provided to an application. The modified view of native resources provided by a layer will be referred to as that layer's \u201cisolation scope\u201d. As shown in , the application isolation layer includes two application isolation scopes , . Scope  represents the view of native resources provided to application  and scope  represents the view of native resources provided to application . Thus, in the embodiment shown in , APP  is provided with a specific view of the file system \u2032, while APP  is provided with another view of the file system \u2033 which is specific to it. In some embodiments, the application isolation layer  provides a specific view of native resources , , ,  to each individual application program executing on top of the operating system . In other embodiments, application programs ,  may be grouped into sets and, in these embodiments, the application isolation layer  provides a specific view of native resources for each set of application programs. Conflicting application programs may be put into separate groups to enhance the compatibility and sociability of applications. In still further embodiments, the applications belonging to a set may be configured by an administrator. In some embodiments, a \u201cpassthrough\u201d isolation scope can be defined which corresponds exactly to the system scope. In other words, applications executing within a passthrough isolation scope operate directly on the system scope.","In some embodiments, the application isolation scope is further divided into layered sub-scopes. The main sub-scope contains the base application isolation scope, and additional sub-scopes contain various modifications to this scope that may be visible to multiple executing instances of the application. For example, a sub-scope may contain modifications to the scope that embody a change in the patch level of the application or the installation or removal of additional features. In some embodiments, the set of additional sub-scopes that are made visible to an instance of the executing application is configurable. In some embodiments, that set of visible sub-scopes is the same for all instances of the executing application, regardless of the user on behalf of which the application is executing. In others, the set of visible sub-scopes may vary for different users executing the application. In still other embodiments, various sets of sub-scopes may be defined and the user may have a choice as to which set to use. In some embodiments, sub-scopes may be discarded when no longer needed. In some embodiments, the modifications contained in a set of sub-scopes may be merged together to form a single sub-scope.","Referring now to , a multi-user computer having reduced application compatibility and application sociability problems is depicted. The multi-user computer includes native resources , , ,  in the system layer , as well as the isolation environment  discussed immediately above. The application isolation layer  functions as discussed above, providing an application or group of applications with a modified view of native resources. The user isolation layer , conceptually, provides an application program , , with a view of native resources that is further altered based on user identity of the user on whose behalf the application is executed. As shown in , the user isolation layer  may be considered to comprise a number of user isolation scopes \u2032, \u2033, \u2032\u2033, \u2033\u2033, \u2032\u2033\u2033, \u2033\u2033\u2033 (generally ). A user isolation scope  provides a user-specific view of application-specific views of native resources. For example, APP  executing in user session  on behalf of user \u201ca\u201d is provided with a file system view \u2032() that is altered or modified by both the user isolation scope \u2032 and the application isolation scope .","Put another way, the user isolation layer  alters the view of native resources for each individual user by \u201clayering\u201d a user-specific view modification provided by a user isolation scope \u2032 \u201con top of\u201d an application-specific view modification provided by an application isolation scope , which is in turn \u201clayered on top of\u201d the system-wide view of native resources provided by the system layer. For example, when the first instance of APP  accesses an entry in the registry database , the view of the registry database specific to the first user session and the application \u2032() is consulted. If the requested registry key is found in the user-specific view of the registry \u2032(), that registry key is returned to APP . If not, the view of the registry database specific to the application \u2032 is consulted. If the requested registry key is found in the application-specific view of the registry \u2032, that registry key is returned to APP . If not, then the registry key stored in the registry database  in the system layer  (i.e. the native registry key) is returned to APP .","In some embodiments, the user isolation layer  provides an isolation scope for each individual user. In other embodiments, the user isolation layer  provides an isolation scope for a group of users, which may be defined by roles within the organization or may be predetermined by an administrator. In still other embodiments, no user isolation layer  is provided. In these embodiments, the view of native resources seen by an application program is that provided by the application isolation layer . The isolation environment , although described in relation to multi-user computers supporting concurrent execution of application programs by various users, may also be used on single-user computers to address application compatibility and sociability problems resulting from sequential execution of application programs on the same computer system by different users, and those problems resulting from installation and execution of incompatible programs by the same user.","In some embodiments, the user isolation scope is further divided into sub-scopes. The modifications by the user isolation scope to the view presented to an application executing in that scope is the aggregate of the modifications contained within each sub-scope in the scope. Sub-scopes are layered on top of each other, and in the aggregate view modifications to a resource in a higher sub-scope override modifications to the same resource in lower layers.","In some of these embodiments, one or more of these sub-scopes may contain modifications to the view that are specific to the user. In some of these embodiments, one or more sub-scopes may contain modifications to the view that are specific to sets of users, which may be defined by the system administrators or defined as a group of users in the operating system. In some of these embodiments, one of these sub-scopes may contain modifications to the view that are specific to the particular login session, and hence that are discarded when the session ends. In some of these embodiments, changes to native resources by application instances associated with the user isolation scope always affects one of these sub-scopes, and in other embodiments those changes may affect different sub-scopes depending on the particular resource changed.","The conceptual architecture described above allows an application executing on behalf of a user to be presented with an aggregate, or unified, virtualized view of native resources, specific to that combination of application and user. This aggregated view may be referred to as the \u201cvirtual scope\u201d. The application instance executing on behalf of a user is presented with a single view of native resources reflecting all operative virtualized instances of the native resources. Conceptually this aggregated view consists firstly of the set of native resources provided by the operating system in the system scope, overlaid with the modifications embodied in the application isolation scope applicable to the executing application, further overlaid with the modifications embodied in the user isolation scope applicable to the application executing on behalf of the user. The native resources in the system scope are characterized by being common to all users and applications on the system, except where operating system permissions deny access to specific users or applications. The modifications to the resource view embodied in an application isolation scope are characterized as being common to all instances of applications associated with that application isolation scope. The modifications to the resource view embodied in the user isolation scope are characterized as being common to all applications associated with the applicable application isolation scope that are executing on behalf of the user associated with the user isolation scope.","This concept can be extended to sub-scopes; the modifications to the resource view embodied in a user sub-scope are common to all applications associated with the applicable isolation sub-scope executing on behalf of a user, or group of users, associated with a user isolation sub-scope. Throughout this description it should be understood that whenever general reference is made to \u201cscope,\u201d it is intended to also refer to sub-scopes, where those exist.","When an application requests enumeration of a native resource, such as a portion of the file system or registry database, a virtualized enumeration is constructed by first enumerating the \u201csystem-scoped\u201d instance of the native resource, that is, the instance found in the system layer, if any. Next, the \u201capplication-scoped\u201d instance of the requested resource, that is the instance found in the appropriate application isolation scope, if any, is enumerated. Any enumerated resources encountered in the application isolation scope are added to the view. If the enumerated resource already exists in the view (because it was present in the system scope, as well), it is replaced with the instance of the resource encountered in the application isolation scope. Similarly, the \u201cuser-scoped\u201d instance of the requested resource, that is the instance found in the appropriate user isolation scope, if any, is enumerated. Again, any enumerated resources encountered in the user isolation scope are added to the view. If the native resource already exists in the view (because it was present in the system scope or in the appropriate application isolation scope), it is replaced with the instance of the resource encountered in the user isolation scope. In this manner, any enumeration of native resources will properly reflect virtualization of the enumerated native resources. Conceptually the same approach applies to enumerating an isolation scope that comprises multiple sub-scopes. The individual sub-scopes are enumerated, with resources from higher sub-scopes replacing matching instances from lower sub-scopes in the aggregate view.","In other embodiments, enumeration may be performed from the user isolation scope layer down to the system layer, rather than the reverse. In these embodiments, the user isolation scope is enumerated. Then the application isolation scope is enumerated and any resource instances appearing in the application isolation scope that were not enumerated in the user isolation scope are added to the aggregate view that is under construction. A similar process can be repeated for resources appearing only in the system scope.","In still other embodiments, all isolation scopes may be simultaneously enumerated and the respective enumerations combined.","If an application attempts to open an existing instance of a native resource with no intent to modify that resource, the specific instance that is returned to the application is the one that is found in the virtual scope, or equivalently the instance that would appear in the virtualized enumeration of the parent of the requested resource. From the point of view of the isolation environment, the application is said to be requesting to open a \u201cvirtual resource\u201d, and the particular instance of native resource used to satisfy that request is said to be the \u201cliteral resource\u201d corresponding to the requested resource.","If an application executing on behalf of a user attempts to open a resource and indicates that it is doing so with the intent to modify that resource, that application instance is normally given a private copy of that resource to modify, as resources in the application isolation scope and system scope are common to applications executing on behalf-of other users. Typically a user-scoped copy of the resource is made, unless the user-scoped instance already exists. The definition of the aggregate view provided by a virtual scope means that the act of copying an application-scoped or system-scoped resource to a user isolation scope does not change the aggregate view provided by the virtual scope for the user and application in question, nor for any other user, nor for any other application instance. Subsequent modifications to the copied resource by the application instance executing on behalf of the user do not affect the aggregate view of any other application instance that does not share the same user isolation scope. In other words, those modifications do not change the aggregate view of native resources for other users, or for application instances not associated with the same application isolation scope.","Applications may be installed into a particular isolation scope (described below in more detail). Applications that are installed into an isolation scope are always associated with that scope. Alternatively, applications may be launched into a particular isolation scope, or into a number of isolation scopes. In effect, an application is launched and associated with one or more isolation scopes. The associated isolation scope, or scopes, provide the process with a particular view of native resources. Applications may also be launched into the system scope, that is, they may be associated with no isolation scope. This allows for the selective execution of operating system applications such as Internet Explorer, as well as third party applications, within an isolation environment.","This ability to launch applications within an isolation scope regardless of where the application is installed mitigates application compatibility and sociability issues without requiring a separate installation of the application within the isolation scope. The ability to selectively launch installed applications in different isolation scopes provides the ability to have applications which need helper applications (such as Word, Notepad, etc.) to have those helper applications launched with the same rule sets.","Further, the ability to launch an application within multiple isolated environments allows for better integration between isolated applications and common applications.","Referring now to , and in brief overview, a method for associating a process with an isolation scope includes the steps of launching the process in a suspended state (step ). The rules associated with the desired isolation scope are retrieved (step ) and an identifier for the process and the retrieved rules are stored in a memory element (step ) and the suspended process is resumed (step ). Subsequent calls to access native resources made by the process are intercepted or hooked (step ) and the rules associated with the process identifier, if any, are used to virtualize access to the requested resource (step ).","Still referring to , and in more detail, a process is launched in a suspended state (step ). In some embodiments, a custom launcher program is used to accomplish this task. In some of these embodiments, the launcher is specifically designed to launch a process into a selected isolation scope. In other embodiments, the launcher accepts as input a specification of the desired isolation scope, for example, by a command line option.","The rules associated with the desired isolation scope are retrieved (step ). In some embodiments, the rules are retrieved from a persistent storage element, such as a hard disk drive or other solid state memory element. The rules may be stored as a relational database, flat file database, tree-structured database, binary tree structure, or other persistent data structure. In other embodiments, the rules may be stored in a data structure specifically configured to store them.","An identifier for the process, such as a process id (PID), and the retrieved rules are stored in a memory element (step ). In some embodiments, a kernel mode driver is provided that receives operating system messages concerning new process creation. In these embodiments, the PID and the retrieved rules may be stored in the context of the driver. In other embodiments, a file system filter driver, or mini-filter, is provided that intercepts native resource requests. In these embodiments, the PID and the retrieved rules may be stored in the filter. In other embodiments still, all interception is performed by user-mode hooking and no PID is stored at all. The rules are loaded by the user-mode hooking apparatus during the process initialization, and no other component needs to know the rules that apply to the PID because rule association is performed entirely in-process.","The suspended process is resumed (step ) and subsequent calls to access native resources made by the process are intercepted or hooked (step ) and the rules associated with the process identifier, if any, are used to virtualize access to the requested resource (step ). In some embodiments, a file system filter driver, or mini-filter, or file system driver, intercepts requests to access native resources and determines if the process identifier associated with the intercepted request has been associated with a set of rules. If so, the rules associated with the stored process identifier are used to virtualize the request to access native resources. If not, the request to access native resources is passed through unmodified. In other embodiments, a dynamically-linked library is loaded into the newly-created process and the library loads the isolation rules. In still other embodiments, both kernel mode techniques (hooking, filter driver, mini-filter) and user-mode techniques are used to intercept calls to access native resources. For embodiments in which a file system filter driver stores the rules, the library may load the rules from the file system filter driver.","Processes that are \u201cchildren\u201d of processes associated with isolation scopes are associated with the isolation scopes of their \u201cparent\u201d process. In some embodiments, this is accomplished by a kernel mode driver notifying the file system filter driver when a child process is created. In these embodiments, the file system filter driver determines if the process identifier of the parent process is associated with an isolation scope. If so, file system filter driver stores an association between the process identifier for the newly-created child process and the isolation scope of the parent process. In other embodiments, the file system filter driver can be called directly from the system without use of a kernel mode driver. In other embodiments, in processes that are associated with isolation scopes, operating system functions that create new processes are hooked or intercepted. When request to create a new process are received from such a process, the association between the new child process and the isolation scope of the parent is stored.","In some embodiments, a scope or sub-scope may be associated with an individual thread instead of an entire process, allowing isolation to be performed on a per-thread basis. In some embodiments, per-thread isolation may be used for Services and COM+ servers.","In some embodiments, isolation environments are used to provide additional functionality to the application streaming client . In one of these embodiments, an application program is executed within an isolation environment. In another of these embodiments, a retrieved plurality of application files resides within the isolation environment. In still another of these embodiments, changes to a registry on the client  are made within the isolation environment.","In one embodiment, the application streaming client  includes an isolation environment . In some embodiments, the application streaming client  includes a file system filter driver  intercepting application requests for files. In one of these embodiments, the file system filter driver  intercepts an application request to open an existing file and determines that the file does not reside in the isolation environment . In another of these embodiments, the file system filter driver  redirects the request to the streaming service  responsive to a determination that the file does not reside in the isolation environment . The streaming service  may extract the file from the plurality of application files and store the file in the isolation environment . The file system filter driver  may then respond to the request for the file with the stored copy of the file. In some embodiments, the file system filter driver  may redirect the request for the file to a file server , responsive to an indication that the streaming service  has not retrieved the file or the plurality of application files and a determination the file does not reside in the isolation environment .","In some embodiments, the file system filter driver  uses a strict isolation rule to prevent conflicting or inconsistent data from appearing in the isolation environment . In one of these embodiments, the file system filter driver  intercepting a request for a resource in a user isolation environment may redirect the request to an application isolation environment. In another of these embodiments, the file system filter driver  does not redirect the request to a system scope.","In one embodiment, the streaming service  uses IOCTL commands to communicate with the filter driver. In another embodiment, communications to the file server  are received with the Microsoft SMB streaming protocol.","In some embodiments, the packaging mechanism  stores in a manifest file a list of file types published as available applications and makes this information available to application publishing software. In one of these embodiments, the packaging mechanism  receives this information from monitoring an installation of an application program into the isolation environment on the staging machine. In another of these embodiments, a user of the packaging mechanism  provides this information to the packaging mechanism . In other embodiments, application publishing software within the access suite console  consults the manifest file to present to a user of the access suite console  the possible file types that can be associated with the requested application being published. The user selects a file type to associate with a particular published application. The file type is presented to the client  at the time of application enumeration.","The client  may include a client agent . The client agent  provides functionality for associating a file type with an application program and selecting a method of execution of the application program responsive to the association. In one embodiment, the client agent  is a program neighborhood application.","When an application program is selected for execution, the client  makes a determination as to a method of execution associated with a file type of the application program. In one embodiment, the client  determines that the file type is associated with a method of execution requiring an application streaming session for retrieval of the application files and execution within an isolation environment. In this embodiment, the client  may redirect the request to the application streaming client  instead of launching a local version of the application program. In another embodiment, the client agent  makes the determination. In still another embodiment, the client agent  redirects the request to the application streaming client .","In one embodiment, the application streaming client  requests access information associated with the application program from the server . In some embodiments, the application streaming client  receives an executable program containing the access information. In one of these embodiments, the application streaming client  receives an executable program capable of displaying on the client  application-output data generated from an execution of the application program on a server. In another of these embodiments, the application streaming client  receives an executable program capable of retrieving the application program across an application streaming session and executing the application program in an isolation environment on the client . In this embodiment, the application streaming client  may execute the received executable program. In still another of these embodiments, the server  selects an executable program to provide to the client  responsive to performing an application resolution as described above.","Referring now to , a flow diagram depicts one embodiment of steps taken in a method for executing an application. As described above in , regarding step , a client  receives and executes the plurality of application files. In brief overview, the client  receives a file including access information for accessing a plurality of application files and for executing a first client capable of receiving an application stream (step ). The client  retrieves an identification of the plurality of application files, responsive to the file (step ). The client  retrieves at least one characteristic required for execution of the plurality of application files, responsive to the file (step ). The client  determines whether the client  includes the at least one characteristic (step ). The client  executes a second client, the second client requesting execution of the plurality of application files on a server, responsive to a determination that the client  lacks the at least one characteristic (step ).","Referring to , and in greater detail, the client  receives a file including access information for accessing a plurality of application files and for executing a first client capable of receiving an application stream (step ). In one embodiment, the client  receives access information including an identification of a location of a plurality of application files comprising an application program. In another embodiment, the client  receives the file responsive to requesting execution of the application program. In still another embodiment, the access information includes an indication that the plurality of application files reside on a server \u2032 such as an application server or a file server. In yet another embodiment, the access information indicates that the client  may retrieve the plurality of application files from the server  over an application streaming session.","The client  retrieves an identification of the plurality of application files, responsive to the file (step ). In one embodiment, the client  identifies a server on which the plurality of application files reside, responsive to the file including access information. In another embodiment, the client  retrieves from the server  a file identifying the plurality of application files. In some embodiments, the plurality of application files comprise an application program. In other embodiments, the plurality of application files comprise multiple application programs. In still other embodiments, the plurality of application files comprise multiple versions of a single application program.","Referring ahead to , a flow diagram depicts one embodiment of a plurality of application files residing on a server \u2032, such as file server . In , a plurality of application files, referred to as a package, includes application files comprising three different versions of one or more application programs.","In one embodiment, each subset of application files comprising a version of one or more application programs and stored within the package is referred to as a target. Target , for example, includes a version of a word processing application program and of a spreadsheet program, the version compatible with the English language version of the Microsoft Windows 2000 operating system. Target  includes a version of a word processing application program and of a spreadsheet program, the version compatible with the English language version of the Microsoft XP operating system. Target  a version of a word processing application program and of a spreadsheet program, the version compatible with the Japanese language version of the Microsoft Windows 2000 operating system with service pack .","Returning now to , in some embodiments, the file retrieved from the server  hosting the plurality of application files includes a description of the package and the targets included in the plurality of application files. In other embodiments, the file retrieved from the server  identifies the plurality of application files comprising an application program requested for execution by the client .","The client  retrieves at least one characteristic required for execution of the plurality of application files, responsive to the file (step ). In some embodiments, the client  may not execute an application program unless the client includes certain characteristics. In one of these embodiments, different application programs require clients  to include different characteristics from the characteristics required by other application programs. In another of these embodiments, the client  receives an identification of the at least one characteristic required for execution of the plurality of application files comprising the application program requested by the client .","The client determines whether the client  includes the at least one characteristic (step ). In one embodiment, the client  evaluates an operating system on the client  to determine whether the client  includes the at least one characteristic. In another embodiment, the client  identifies a language used by an operating system on the client  to determine whether the client  includes the at least one characteristic. In still another embodiment, the client  identifies a revision level of an operating system on the client  to determine whether the client  includes the at least one characteristic. In yet another embodiment, the client  identifies an application version of an application program residing on the client  to determine whether the client  includes the at least one characteristic. In some embodiments, the client  determines whether the client  includes a device driver to determine whether the client  includes the at least one characteristic. In other embodiments, the client  determines whether the client  includes an operating system to determine whether the client  includes the at least one characteristic. In still other embodiments, the client  determines whether the client  includes a license to execute the plurality of application files to determine whether the client  includes the at least one characteristic.","The client  executes a second client, the second client requesting execution of the plurality of application files on a server , responsive to a determination that the client  lacks the at least one characteristic (step ). In one embodiment, when the client  determines that the client  lacks the at least one characteristic, the client  does not execute the first client capable of receiving an application stream. In another embodiment, a policy prohibits the client  from receiving the plurality of application files over an application stream when the client  lacks the at least one characteristic. In some embodiments, the client  determines that the client  does include the at least one characteristic. In one of these embodiments, the client  executes the first client, the first client receiving an application stream comprising the plurality of application files from a server  for execution on the client.","In some embodiments, the client  executes the second client requesting execution of the plurality of application files on a server upon determining that the client  lacks the at least one characteristic. In one of these embodiments, the second client transmits the request to a server  hosting the plurality of application files. In another of these embodiments, the server  executes the plurality of application files comprising the application program and generates application-output data. In still another of these embodiments, the second client receives application-output data generated by execution of the plurality of application files on the server. In some embodiments, the second client receives the application-output data via an Independent Computing Architecture presentation level protocol or a Remote Desktop Windows presentation level protocol or an X-Windows presentation level protocol. In yet another of these embodiments, the second client displays the application-output on the client .","In some embodiments, the second client transmits the request to a server  that does not host the plurality of application files. In one of these embodiments, the server  may request the plurality of application files from a second server  hosting the plurality of application files. In another of these embodiments, the server  may receive the plurality of application files from the second server  across an application streaming session. In still another of these embodiments, the server  stores the received plurality of application files in an isolation environment and executes the application program within the isolation environment. In yet another of these embodiments, the server transmits the generated application-output data to the second client on the client.","Referring back to , in one embodiment, the first client, capable of receiving the application stream, is an application streaming client . The application streaming client  receiving the file, retrieving an identification of a plurality of application files and at least one characteristic required for execution of the plurality of application files, responsive to the file, and determining whether the client  includes the at least one characteristic. In another embodiment, the second client is a client agent . In some embodiments, the client agent  receives the file from the application streaming client  responsive to a determination, by the application streaming client , that the client  lacks the at least one characteristic.","In some embodiments, an application  executing on the client  enumerates files associated with the application  using the Win FindFirstFile( )) and FindNextFile( ) API calls. In one of these embodiments, a plurality of application files comprise the application . In another of these embodiments, not all files in the plurality of application files reside on the client . In still another of these embodiments, the streaming service  retrieved the plurality of application file in an archived files but extracted only a subset of the plurality of application files. In yet another of these embodiments, the streaming service  and the file system filter driver  provide functionality for satisfying the enumeration request, even when the requested file does not reside on the client .","In one embodiment, the functionality is provided by intercepting the enumeration requests and providing the data as if all files in the plurality of application files reside on the client . In another embodiment, the functionality is provided by intercepting, by the file system filter driver , an enumeration request transmitted as an IOCTL command, such as IRP_MJ_DIRECTORY_CONTROL IOCTL. When the file system filter driver  intercepts the call, the file system filter driver  redirects the request to the streaming service . In one embodiment, the file system filter driver  determines that the requested enumeration resides in an isolation environment on the client  prior to redirecting the request to the streaming service . In another embodiment, the streaming service  fulfills the request using a file in the plurality of application files, the file including an enumeration of a directory structure associated with the plurality of application files. In still another embodiment, the streaming service  provides the response to the request to the file system filter driver  for satisfaction of the enumeration request.",{"@attributes":{"id":"p-0284","num":"0283"},"figref":["FIG. 12","FIG. 12"],"b":["106","38","106","1510","1520","1570","1580","1530","1540","524","1570","1510","106"]},"The license management subsystem  communicates with the group subsystem  over an event bus to form and maintain a logical grouping of licenses (hereafter, \u201clicense groups\u201d) to facilitate license pools, assignments, and groups. A license group includes a collection of license strings, described below, and\/or other license groups. License groups collect licenses of similar features and consequently enable pooling of licenses. A pooled license is a license that is available for use by any server  in the farm . Each license group holds the collective capabilities of the licenses in the license group and the other license subgroups (i.e. other license groups within a license group). Information relating to license pools is, in one embodiment, maintained in the dynamic store . In this embodiment, each license management subsystem  stores locally the total number of licenses and the number of license assigned to a server  in the farm . Upon granting a pooled license, the granting license management subsystem  makes an entry in the dynamic store  indicating that a pooled license is \u201cin use.\u201d Every other license management subsystem  recognizes that such pooled license is unavailable for granting. In one particular embodiment, the dynamic store  store server ID\/client ID pairs associated with each license group to identify pooled licenses that are in use.","The relationship subsystem  maintains associations between licenses and servers  and between license groups and servers . The associations define the number of licenses for each license and license group that only the associated server  may obtain (i.e., \u201clocal licenses\u201d). A local license is a license that is assigned to one server in the farm  and is not shared by other servers . The license management subsystem  communicates with the relationship subsystem  to create, delete, query, and update such associations. The common access point subsystem  provides remote procedure calls (RPCs) for use by software products residing on the server . These RPC interfaces enable such software products to communicate through the common access subsystem  to access licensing information.","Still referring to , the specialized server subsystem  communicates with the license management subsystem  to obtain a feature license for each capability of the specialized server subsystem  for which a license is required. This occurs at initialization of specialized server subsystem  and after any license event. If unable to obtain the feature license, the specialized server subsystem  restricts the functionality that the subsystem would provide with a license. Also, the specialized server subsystem  uses the license management subsystem  to obtain client connection licenses whenever a client session is initiated with the server .","The license management subsystem  communicates with the persistent store system service module  to store feature and connection licenses in a license repository  as license strings formed in accordance with a naming convention. The license repository  resides in the persistent store . Cyclical redundancy checks (CRC) prevent tampering of the licenses while such licenses are stored in the license repository . The license management subsystem  also stores information related to the license strings in the license repository . For example, the information may indicate which licenses are assigned to which servers  of the farm  and, in some embodiments, the activation status of each license. In one embodiment, a connection license table  stores identifiers of those clients that have obtained a connection license.","In one embodiment, the license management subsystem  supports events from subsystems requesting use of a licensed capability, such as a request for an available pooled license. The event includes the UID of the subsystem requesting the license and the UID of the server  upon which that subsystem resides. The event also contains the license type requested (i.e., feature or connection license) in the form of a license group ID. The actual license group ID stored in the persistent store  is arbitrary, but adherence to the naming convention provides flexibility for the future addition of new software products (i.e., subsystems) to the server .","The event sent by a requesting subsystem seeking a license includes () an indication of the license group type, the identity of the client and server requesting the license, and a \u201cforce acquire\u201d flag. An indication of license group type may include identification of a feature license, such as a load management, or a connection type license, such as a software application product. The field identifying the client and server seeking the license may include the unique identifier associated with the server and the client. The force acquire flag may be used, for example, to reacquire connection licenses after a license change event. A license change event indicates that licensing information in the persistent store  has changed; for example, a license has been deleted, added, or assigned. Upon a license change event, each server  attempts to reacquire all connection licenses that it possessed before the license change event because the particular cause of the license change event is unknown to that server. This flag, if set, indicates that a connection license must be acquired even if doing so increases the number of connections to the server  in excess of the predetermined maximum number of allowable connections. No new connection licenses are subsequently granted until the number of connection licenses in use drops below this predetermined maximum number. In this manner, a client connection will not be terminated in mid-session due to a license change event.","Referring now to , a block diagram depicts one embodiment of the components involved in licensing enforcement. A server  includes a server management subsystem  and a license management subsystem . In some embodiments, the server management subsystem  and the license management subsystem  provide the functionality of the license management subsystem  described above. In other embodiments, an application management subsystem  and a session management subsystem  provide the functionality of the license management subsystem  described above. In still other embodiments, other subsystems provide the functionality of the license management subsystem  described above.","In one embodiment, the server management subsystem  may include a licensing component used to request issuance and revocation of licenses. In another embodiment, the license management subsystem  may apply a policy to a request for issuance or revocation of a license received from the server management subsystem . In still another embodiment, the license management subsystem  may transmit the request to a server  providing license enforcement functionality. In some embodiments, the management service  may maintain a connection with a second server  providing license enforcement functionality. In other embodiments, the server  provides the license enforcement functionality.","In some embodiments, a license expires and ceases to be valid upon a failure of the client  to transmit a predetermined number of heartbeat messages to the server. In one of these embodiments, expiration of the license revokes authorization for execution of an application program by the client .","In other embodiments, a session times out upon the expiration of a predetermined period of time. In one embodiment, the management service  maintains session-related data after the expiration of a license until an expiration of a session. In some embodiments, the session-related data may include information such as session name, session id, client id, client name, session start time, server name (UNC Path of File Server), application name (Unique name generated by client, based on browser name), alias name, session state (active\/licensed, active\/unlicensed, reconnected\/unlicensed). In another embodiment, the client  ceases transmission of heartbeat messages and restarts transmission of heartbeat messages at a later point in time. In still another embodiment, the management service  may reissue a license and make the maintained session-related data available to the client  if the client  restarts transmission of heartbeat messages prior to the expiration of the session.","Referring now to , a flow diagram depicts one embodiment of the steps taken to request and maintain a license from a server  for the duration of a session on a client . In brief overview, an application streaming client requests a license (step ). A server  receives the request for the license, verifies a ticket associated with the request, and generates a license (step ). The server  provides the license and information associated with the license to the client  (step ). The client  executes the application as described above in connection to step  in . The client transmits a heartbeat message indicating that the client has executed an application (step ). The server  receives the heartbeat message and verifies identifying information transmitted with the heartbeat message (step ). The server  creates a session associated with the executed application and with the client  (step ). A result of creating the session is transmitted to the client  (step ). The client transmits heartbeat messages throughout the execution of the application, as described above in connection with step  of . The client receives a response to a transmitted heartbeat message (step ). The client transmits a heartbeat message indicating a termination of an execution of the application (step ). The server  receives the heartbeat message and determines whether to remove session related data and whether to release the license associated with the client  and the terminated application (step ). A result of the determination made by the server  is transmitted to the client  (step ).","Referring now to , and in greater detail, an application streaming client on a client  requests a license (step ). In some embodiments, the client  requests the license upon receiving access information associated with an application program. In one of these embodiments, the client requests a license from the server  granting authorization for execution of the application program by the client . In some embodiments, the request for the license includes a launch ticket received from the server  with the access information. In other embodiments, an application streaming client  on the client  transmits the request to a web interface  and the web interface  transmits the request to the server . In still other embodiments, a session management subsystem  on the server receives and processes the request for the license.","A server  receives the request for the license, verifies a ticket associated with the request, and generates a license (step ). In one embodiment, the server  verifies that the client  is authorized to execute the application. In another embodiment, the server  determines whether the client  is already associated with an existing license. In still another embodiment, the server  determines that the client  is associated with an existing license and provides the client  with an identifier for a session management server  managing the existing license. In yet another embodiment, the server  generates and provides to the client  a new license, a session identifier, and an identification of a session management server  managing the new license.","In some embodiments, the server  uses a license management subsystem  to respond to a license request in an embodiment in which. The license management subsystem  receives a license request. The request can be for a feature license or for a connection license. The license management subsystem  determines if the license has already been granted, i.e., the feature has already been started or a connection for a client already exists. If the license is already granted, the license management subsystem  sends a \u201cgrant\u201d event to the license requester. If the license has not been previously granted, the license management subsystem  determines if a local license, i.e., a license that has been permanently assigned to the server , is available. In some embodiments, the license management subsystem  performs this determination by checking local memory. If a local license is available, i.e., the server  has more licenses permanently assigned than currently granted, the license management subsystem  sends a \u201cgrant\u201d event to the license requestor.","The server  provides the license and information associated with the license to the client  (step ). In one embodiment, upon receiving the license, the session identifier, and the identification of the session management server  from the server , the client  executes the application. The client  may execute the application as described above in connection to step  in . The client transmits a heartbeat message indicating that the client has executed an application (step ). In one embodiment, the client transmits the heartbeat message to the server  for transmission of the heartbeat message to a session management server . In another embodiment, the client  transmits a heartbeat message directly to a session management server , responsive to an identifier of the session management server  received from the server .","The server  receives the heartbeat message and verifies identifying information transmitted with the heartbeat message (step ). In one embodiment, a server \u2032 is the session management server . In another embodiment, the session management server  verifies a server identifier provided with the heartbeat message by the client . In still another embodiment, the server identifier is the identifier provided to the client  by a server .","The server  creates a session associated with the executed application and with the client  (step ). In one embodiment, the session management server  creates a new session associated with the executing application upon receiving the heartbeat message. In another embodiment, a third server  creates the new session. In some embodiments, the session management server  stores session-related information upon the creation of the new session.","A result of creating the session is transmitted to the client  (step ). In some embodiments, the result confirms the creation of the session. In other embodiments, the result identifies the application or applications associated with the session. The client transmits heartbeat messages throughout the execution of the application, as described above in connection with step  of . In one embodiment, the client  continues to transmit heartbeat messages at regular intervals to the session management server  at periodic intervals throughout the execution of the application program. The client receives a response to a transmitted heartbeat message (step ). In one embodiment, the client  receives a confirmation of receipt of the heartbeat messages from the session management server . In another embodiment, the client  receives a command for execution from the session management server , responsive to the receipt of a heartbeat message by the session management server .","The client transmits a heartbeat message indicating a termination of an execution of the application (step ). The server  receives the heartbeat message and determines whether to remove session related data and whether to release the license associated with the client  and the terminated application (step ). A result of the determination made by the server  is transmitted to the client  (step ).","Referring now to , a block diagram depicts one embodiment of states that may be associated with a session monitored by a management service . In one embodiment, a session maintenance subsystem  on the management service  monitors a session of a client  and assigns a state to the session. In another embodiment, the session maintenance subsystem  maintains a list of license-related data, which may include an identifier associated with the client, an identifier associated with the session, a session state, and a timestamp indicating the last time the server  received a message from the client . In some embodiments, the session maintenance subsystem  includes a session monitoring thread. In one of these embodiments, the session monitoring thread awakens at a periodic license timeout interval to scan the list of license-related data and update the session status of a session.","A first state that a session may be in is an active and licensed state. In one embodiment, when in this state, the client  has maintained a valid license authorizing execution of an application. In another embodiment, a session management server  maintains session-related data. In some embodiments, the session management server  stores the session-related data on a second server. In one embodiment, when a client  initially executes an application, the session for the client is in the active and licensed state.","A second state that a session may be in is an active and unlicensed state. In one embodiment, a session is in this state when the client  fails to transmit heartbeat messages and a license to the client  has expired. In another embodiment, if a session is in this state then, while the license has expired, insufficient time has elapsed for the session to expire, and the session is considered active. In some embodiments, while a session is in this state, a server  or a session management server  may store session-related data on behalf of the client . In other embodiments, if a client  transmits a heartbeat message prior to the expiration of the session, session-related data is transmitted to the client  with a new license and the session returns to the active and licensed state. In one embodiment, a server  uses session identifiers and identifiers associated with the client to verify that the session has not expired and to provide the client with the appropriate session-related data.","A third state that a session may be in is a disconnected and non-existent state. When a session expires, session-related data is deleted.","A fourth state that a session may be in is a reconnected and unlicensed state. In one embodiment, when a session on a client  expires, session-related data is deleted. In another embodiment, when the client  transmits a new heartbeat message, a new session identifier and client identifier are generated for the client . In some embodiments, the client  re-authenticates to the server , receives a new license, and enters the active and licensed state.","Table 3 summarizes the states that may be associated with a session.",{"@attributes":{"id":"p-0310","num":"0309"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Session Status","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Active\\Licensed","Normal mode of operation"]},{"entry":["Active\\Unlicensed","Duration of missing heartbeats > License"]},{"entry":[{},"Timeout"]},{"entry":[{},"AND"]},{"entry":[{},"Duration of missing heartbeats < Session"]},{"entry":[{},"Timeout"]},{"entry":["Reconnected\\Unlicensed","Duration of missing heartbeats > Session"]},{"entry":[{},"Timeout"]},{"entry":[{},"OR CPS\/RADE hosting the session is down"]},{"entry":[{},"and back online"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In some embodiments, a packaging mechanism enables creation of a plurality of application files associated with an application program. In one of these embodiments, the packaging mechanism enables identification of a plurality of application files. In another of these embodiments, the packaging mechanism enables grouping of individual application files into the plurality of application files. In still another of these embodiments, the packaging mechanism enables hosting of the plurality of application files on a server, such as a file server or application server.","In one embodiment, the packaging mechanism executes on a server described as a \u201cstaging machine.\u201d In another embodiment, the packaging mechanism executes on a \u201cclean machine.\u201d A clean machine may be a server having only an operating system installed on it, without additional software, drivers, registry entries, or other files. In still another embodiment, the packaging machine executes on a server, the server resembling a client on which an application program may execute. In some embodiments, the server on which the packaging mechanism executes includes an isolation environment providing a clean machine environment into which an application may be installed, even where the server is not itself a clean machine.","In one embodiment, the plurality of application files is referred to as a \u201cpackage.\u201d In another embodiment, the package may be an archive file storing the plurality of application files. In still another embodiment, the package may be an archive file storing the plurality of application files and a file including metadata associated with at least one file in the plurality of application files. In some embodiments, a package includes a plurality of application files comprising an application program. In other embodiments, a package includes a plurality of application files comprising a suite of application programs. In yet other embodiments, a package includes a plurality of application files comprising an application program and a prerequisite required for execution of the application program.","In one embodiment, the packaging mechanism initiates execution of an installation program in an isolation environment. In another embodiment, the packaging mechanism monitors a change to the isolation environment generated by the installation program. In still another embodiment, the packaging mechanism monitors a creation by the installation program of a file in the isolation environment. In yet another embodiment, the packaging mechanism monitors a modification by the installation program of a file in the isolation environment. In some embodiments, the plurality of application files includes a file created or modified by the installation program. In other embodiments, the packaging mechanism implements a file system filter driver  to monitor the isolation environment.","In some embodiments, a packaging mechanism may generate multiple pluralities of application files, each comprising a different version of an application program configured for execution in a different target environment. In one of these embodiments, a plurality of application files is configured to execute on a client having a particular operating system, revision level, language configurations and master drive (e.g., one plurality of application files may be configured to execute on a client having the Windows XP Professional operating system with revision level SP and above, using English and having a master Drive C:). In another of these embodiments, more than one plurality of application files may be combined in a single archive file. In still another of these embodiments, each plurality of application files may be referred to as a \u201ctarget.\u201d In yet another of these embodiments, an archive file containing one or more pluralities of application files may be referred to as a \u201cpackage.\u201d","Referring now to , a flow diagram depicts one embodiment of the steps followed to install an application in an application isolation environment . The application isolation environment  provides a virtualized view of the server operating system to the application installer (step ). The APIs on the server relating to system reboots and shutdowns are hooked (step ) to prevent the application installer  from causing a reboot. The application installer  requests file-copying operations to locked files, the request being intercepted and redirected to non-conflicting locations (step ). When the application installer  attempts to reboot by calling a system API, the request is intercepted and the reboot is prevented (step ). The post-install processor module  performs actions that ordinarily occur after reboot (step ) and the application may then be executed in the application isolation environment  without reboot of a server  (step ).","In some embodiments, following installation of the application program into the application isolation environment , a packaging mechanism identifies a plurality of application files created or modified during installation of an application program. In one of these embodiments, the plurality of application files are stored on a server. In another of these embodiments, a client retrieving the plurality of application files may execute the application program.","In some embodiments, the packaging mechanism  executes on a server including an isolation environment  and a file system filter driver  and installs an application program into the isolation environment . In one of these embodiments, the server is referred to as a \u201cclean machine\u201d or a \u201cstaging machine.\u201d In another of these embodiments, the isolation environment  includes an application isolation scope providing a modifiable, virtualized instance of a native resource provided by an operating system on the clean machine. In still another of these embodiments, the isolation environment  includes a system isolation scope providing a read-only view of the native resource. In yet another of these embodiments, the read-only view of the native resource comprises a snapshot of a file system and registry residing on the clean machine.","In one embodiment, a redirector intercepts a request for a change to the native resource. In some embodiments, the redirector is a file system filter driver . In another embodiment, an installer program executed by the packaging mechanism  makes the request for the change. In still another embodiment, the change to the native resource is required to install an application program on to the clean machine. In yet another embodiment, the redirector redirects the request to the isolation environment .","In some embodiments, redirecting requests to change native resources to the isolation environment  results in isolation of changes associated with installation of an application program. In other embodiments, the requests to change native resources are recorded and stored in a storage element. In one of these embodiments, all changes associated with installation of an application program reside in the storage element. In another of these embodiments, a client  retrieving the contents of the storage element and implementing the changes to native resources residing in an isolation environment  on the client  result in installation of the application program on the client .","In some embodiments, a pre-launch analysis of the client  may be required. In one of these embodiments, the client  verifies that at least one characteristic is included in the client . In another of these embodiments, the at least one characteristic is added to the client  after the pre-launch analysis determines that the client  lacks the at least one characteristic. In still another of these embodiments, the at least one characteristic is included in a server hosting an application program and failure of the client to include the at least one characteristic will prevent execution of the application program. In yet another embodiment, the application program requires existence of the at least one characteristic on the client for execution.","In some embodiments, the packaging mechanism enables identification of at least one characteristic for use in a pre-launch analysis on the client. In other embodiments, the packaging mechanism enables association of at least one characteristic with an application program available for execution on the client. In still other embodiments, the packaging mechanism enables association of an executable script with an application program, the client executing the executable script to complete the pre-launch analysis. In yet other embodiments, the at least one characteristic is required to exist on the client after the execution of the application program.","The packaging mechanism may provide functionality for signing a plurality of application files. In one embodiment, signing the plurality of application files enables a client to verify integrity of the plurality of application files. In another embodiment, signing the plurality of application files prevents a client from executing a corrupted application program. In some embodiments, a cryptographic checksum, such as an MD4 hash, an MD5 hash, or a SHA-1 hash, of a file in the plurality of application files is computed.","In other embodiments, a cryptographic checksum of every file in the plurality of application files is computed. In one of these embodiments, the cryptographic checksum is stored in a second file. In another of these embodiments, the second file is associated with the plurality of application files. In some embodiments, the second file is added to the plurality of application files. In other embodiments, the second file is signed using a certificate, such as an X.509 certificate. In still other embodiments, a client retrieving the plurality of application files verifies the signature using a public portion of the certificate. In yet other embodiments, the client receives the public portion of the certificate and an identification of a certificate trust list for verification of the signature. In one of these embodiments, client receives a registry key containing the identification of a certificate trust list.","In one embodiment, the packaging mechanism provides functionality for customizing an isolation environment. In another embodiment, the packaging mechanism provides functionality for generating a file storing a definition of an isolation environment. In still another embodiment, the packaging mechanism includes the file with the plurality of application files comprising an application program. In yet another embodiment, a client receives the file with access information from a server.","In some embodiments, a plurality of application files are stored in an archive file. In one of these embodiments, the archive file is in a CAB file format. In another of these embodiments, the archive file format does not provide support for specification by an application program of a short file names of a file. In still another of these embodiments, an operating system, such as WINDOWS 2000 may not provide support for specification by an application program of a short file names of a file. In other embodiments, an operating system, such as WINDOWS XP, provides support for specification by an application program of a short file name of a file. In one of these embodiments, a request to execute the file must include the correct short file name of the file.","In one embodiment, a mapping may be generated to associate a long file name of a file in the plurality of application files with a short name of the file. In another embodiment, the mapping is stored in a file in the plurality of application files. In still another embodiment, a file has a short file name only if the long file name of the file is longer than twelve characters. In some embodiments, the short file name is a virtual file name associated with the file. In one of these embodiments, the file is transmitted to a client  for execution where it is stored with a long file name. In another of these embodiments, an application file on the client  requests execution of the file using the short file name. In still another of these embodiments, the mapping enables execution of the file although the request for execution of the file did not use the name of the file on the client (the long file name).","In some embodiments, the packager mechanism  generates the mapping. In one of these embodiments, the packager mechanism  selects a short file name for a file having a long file name. In another of these embodiments, an operating system on the server \u2032 on which the packager mechanism  is executing selects a short file name for a file having a long file name. In still another of these embodiments, a unique short file name is selected that does not conflict with a second short file name on the server \u2032. In yet another of these embodiments, the installer program executed by the packager mechanism  generates a file including a mapping between a long file name with a short file name. In other embodiments, the mapping is transmitted to a client  retrieving the file. In one of these embodiments, the client  refers to the file when executing the file.","Illustrated in  is an embodiment of a system able to launch applications into existing isolation environments. Clients , \u2032 executing either a first or second user session, communicate with a server  hosting the first user session  and the second user session , where the first user session  corresponds to the user session hosted by the first client  and the second user session  corresponds to the user session hosted by the second client \u2032. A runtime object table  on the server  tracks each runtime object on the server  and communicates with a first run module  executing in the first user session  and a second run module  executing in the second user session . The run modules ,  each communicate with an application delivery service  executing on the server  and launch modules , ,  executing within isolation environments, within a user session and on the server . Executing within the first user session  is isolation environment A  and isolation environment B . Launch module A , a first application  and a second application  execute within isolation environment A  which executes within the first user session  and on the server . Launch module B  and a third application  execute within isolation environment B  which executes within the first user session  and on the server . Launch module C  and a fourth application  execute within isolation environment C  which executes within the second user session  and on the server . Each run module can communicate with the application delivery service , and each launch module can communicate with the run module(s).","Further referring to , and in more detail, in one embodiment the system includes clients , \u2032 able to communicate with the server . The clients , \u2032 can be any client computing machine described herein. Further, the clients , \u2032 can in some embodiments communicate with the server  using any of the communication methods described herein. In one embodiment, the clients , \u2032 can communicate with the server  over a communication channel and via a network . In other embodiments, the clients , \u2032 can communicate with the server  using a presentation layer protocol such as the Citrix ICA protocol. While two clients , \u2032 are depicted, any number of client computing machines may communicate with the server . A user of the client , \u2032 can, in some embodiments, communicate with the server  through a user session. Such embodiments include clients , \u2032 hosting a communication client able to establish the user session with a client or module executing on the server .","The server  can in many embodiments comprise any of the computing elements described herein. Further, the server  can be any of the servers  described herein. While a single server  is depicted, the user sessions ,  or any of the modules executing on the server  can be executed on any number of servers  within a farm .","In one embodiment, the server  includes a runtime object table  that stores information about the runtime objects on the server . While a runtime object table  is depicted, alternative embodiments can include a runtime object list, a runtime object group, a runtime object database, or any other listing or storage method able to record information about the runtime objects on the server . In one embodiment, the runtime object table  stores information about the runtime objects, and in one particular embodiment, the runtime object table  stores information about the isolation environments , ,  or the launch modules , , . When the application delivery service , the run module ,  or any other process or application instantiates or otherwise causes a launch module or an instance of a launch module to execute within an isolation environment, that launch module can register in the runtime object table . During registration, a dynamically generated identifier associated with the launch module is inserted into the runtime object table . This identifier is representative in part of the location of the launch module and can be used by other objects, applications or processes executing on the server  to locate and access the launch module. In some embodiments, the run module ,  generates an instance of a launch module within a created isolation environment, and sends requests to the launch module to execute applications. The runtime object table , in some embodiments, can be searched by objects, applications or processes executing on the server . In response to query requests by the objects, applications or processes, the runtime object table  can return: information about an object, process or application executing on the server ; location information about an object, process or application executing on the server ; configuration information about an object, process or application executing on the server ; or any other runtime information or other information associated with objects, processes or applications executing on the server . Thus in many embodiments, each of the applications, objects or processes on the server  can communicate with the runtime object table  and can receive responses and data from the runtime object table .","The runtime object table  can in most embodiments communicate with the application delivery service  executing on the server . While the application delivery service  is depicted as executing on the same machine as the user sessions , , in some embodiments the application delivery service  may execute on a second server  located remotely from the first server , and in communication with the first server  via a network  or other communication link. The application delivery service  can comprise any of the application delivery methods and systems described herein. In some embodiments, the application delivery service  can be included within the management service , while in other embodiments the application delivery service  can be included within the application management subsystem . In other embodiments, the application delivery service  can execute on the content server , on an application server \u2033, or within the policy engine . The application delivery service  can in some embodiments expose remote procedure call interfaces of isolation environments so that the isolation environments can return an identifier when the name of the isolation environment is known. Exposing a remote procedure call interface can be accomplished during the creation of an isolation environment. In one embodiment, the application delivery service  can generate isolation environments and assign them an identifier or a process identifier. Once the isolation environment is generated, the isolation environment can register with the operating system of the computing machine on which the isolation environment executes, as a server. Thus, substantially immediately after generating the isolation environment, a server begins executing within the isolation environment such that the server can expose a communication interface. The application delivery service  can in some embodiments store a list, table or other enumeration of isolation environments executing or active on the server . In some embodiments this enumeration can include the names of the active, inactive or suspended isolation environments, in other embodiments this enumeration can include the names of the active inactive or suspended isolation environments as well as an identifier associated with each environment. In still other embodiments, the enumeration can include the location of each isolation environment, or can include a path associated with each isolation environment. In some embodiments the application delivery service  can be referred to as the RADE service, while in other embodiments the application delivery service  can be referred to as a rapid application delivery service.","In one embodiment, the application delivery service  communicates with run module ,  such that the application delivery service  receives requests for information regarding an application profile. Once a request is received, the application delivery service  can query a table, list or database to identify isolation environments associated with the profile request. Upon identifying the isolation environments, the application delivery service  can transmit a response to the run module ,  that includes an enumeration of isolation environments associated with the profile. In embodiments where a single isolation environment is associated with the requested profile, the application delivery service  can return a response that includes the name of the isolation environment associated with the requested profile. When the request is made while the server  is not connected to a network or cannot access a network, the application delivery service  can facilitate the identification of the profile and by proxy the applications by determining whether the requested profile was previously downloaded. If the profile exists, then the application delivery service  can make an entry into the server's  registry indicating that the applications associated with the profile are offline or otherwise unavailable to the run module or user. When no isolation environment exists for a particular profile, the application delivery service  can facilitate the creation of an isolation environment by responding to isolation requests by creating an isolation environment encompassing the requested application.","Both the runtime object table  and the application delivery service  can communicate with one or more, or a plurality of run modules , . In one embodiment, each run module is an instance of a run module that executes within a user session , . The run module can be referred as a RADE run module, a run client, a run component, a run object, or a run application. The run modules , , in most embodiments can communicate with any one of: a launch module , , ; an application , , , ; an application delivery service ; or a runtime object table . Each time a user via a client computing machine  requests execution of an application, the run module associated with that user launches and intercepts the request. For example, a user inputs commands into client  which translates to a request for an application. The request is transmitted to the server  where it is intercepted by the run module executing in that user's user session. Once a run module ,  intercepts the application execution request, the run module ,  queries the application delivery service  to determine whether an isolation environment exists that corresponds to a profile associated with the requested application. The run module ,  then uses the application delivery service's  response to determine whether to instruct the application to launch into a pre-existing isolation environment or to create a new isolation environment for the requested application.","In embodiments where the run module ,  determines that an existing isolation environment exists for a particular profile, the run module ,  identifies the isolation environment by obtaining the path or address of the isolation environment and makes a call to the launch module inside the isolation environment. This call can in some embodiments include a request to launch or execute an application requested by the user. In other embodiments, the call can include a request to generate an additional instance of an application already executing within the isolation environment. Still other embodiments include a request to launch or execute the application that includes an address or virtual path of the application such that the launch module can use the address or path to access and launch or execute the application. In most embodiments, the run module ,  can access only those launch modules , ,  within their user session. For example, a first run module  executes within a first user session , therefore the first run module  can only access the launch modules ,  within the first user session . In other embodiments, the run module can access any launch module on the server .","In embodiments where the run module ,  determines that no isolation environment exists for a particular profile, the run module ,  launches a launch module in a suspended mode and then issues a call to the application delivery service . This call can include a request to isolate the suspended launch module by creating an isolation environment for the launch module and for the requested application. In one embodiment, the resulting isolation environment is associated with the profile further associated with the requested application. Once the isolation environment is created, the run module can in some embodiments insert a hook dynamic link library into the launch module and then permit the launch module to become active such that the launch module or launch module instance executes on the server . The hook dynamic link library can in some embodiments hook any calls made to the launch module or can intercept any requests made to the launch module and any responses issued by the launch module.","Within each isolation environment, instances of a launch module or launch modules , ,  can exist. Each launch module can interact with the applications executing in an isolation environment and can respond to requests or calls issued or generated by a run module executing within the same user session within which the launch module(s) executes. The launch modules , ,  can be referred to as launchers, launching applications, launch clients, launch module instances or by any other label descriptive of the launch modules , ,  functionality. When an isolation environment is created, a launch module or launch module instance can be created within that isolation environment. Following creation of the isolation environment, the launch module can register with the runtime object table  as a runtime object and can register with a dynamic GUID or identifier that comprises an identifier associated with the isolation environment within which the launch module executes. In some embodiments, the dynamic identifier used by the launch module to register with the runtime object table  can include an identifier that comprises a unique combination of the isolation environment identifier, an identifier associated with the launch module and an identifier associated with the user session. When a run module or other object or process requests a launch module to execute an application or application instance, that run module or object can identify the launch module instance within the runtime object table , and use the dynamic identifier associated with the launch module to transmit a request to the launch module instance to launch or execute a particular application(s). In other embodiments, the launch module includes a communication interface that can receive application paths, addresses or other application location data, and uses the location data to execute the application's executable file. In some embodiments, one isolation environment may be able to execute an application in another isolation environment by issuing an execution request to a communication interface on a launch module. The isolation environments in this embodiments can either be within the same user session or can be in a first and second user session.","In addition to exposing a communication interface through which application execution requests can be serviced, the launch modules , ,  can in some embodiments execute pre-launch and post-exit scripts. These pre-launch and post-exit scripts may be executed within or outside of an isolation environment. In some embodiments, a pre-launch script may be any application or set of instructions executing on a communication machine prior to the launch of an application, while a post-exit script can be any application or set of instructions executing on a communication machine after an application exits. In one embodiment, a pre-launch script can be any script used to map to a remote share, or to install software components unable to be isolated (e.g. PDF soft printer.) Post-exit scripts, in some embodiments, can be used to cleanup tasks executed by the pre-launch scripts.","In some embodiments the launch modules , ,  may execute a post-exit once the launch module , ,  detects or determines that the number of processes executing within the isolation environment has dropped to one process. The launch modules , ,  in other embodiments register with an isolation environment monitoring module that tracks the number of processes running within an isolation environment. When the isolation environment monitoring module informs the launch module , ,  that there is only one process running within the isolation environment, the launch module responsively executes an post-exit scripts associated with either the isolation environment, a profile associated with the isolation environment, the launch module or the run module. The launch module , , , in some embodiments, may wait a predetermined period of time after detecting that the number of processes has dropped to one before executing the post-exit script(s). Other embodiments include launch modules , ,  that wait a predetermined period of time after executing a post-exit script or after determining that the number of processes within an isolation environment dropped to one, before deconstructing, destroying or otherwise causing the isolation environment to die. Should the launch module(s) , ,  receive a request to launch an application after the execution of post-exit scripts but before the destruction of the isolation environment, the launch module(s) , ,  can execute any pre-launch scripts and launch the requested application. In this embodiment, the isolation environment remains alive and intact and does not die or otherwise deconstruct.","In one embodiment, the launch module(s) , ,  can function substantially similar to a server such that each launch module can expose a communication interface able to receive application launch requests. Thus, in one example a launch module can receive a request or command issued by a run module, where the request or command can in some embodiments be a command to launch an application. Exposing a communication interface can in some embodiments be facilitated by inter-process mechanisms executing on the server . In one embodiment, the inter-process mechanisms can be any mechanism that uses remote procedure calls or that creates communication interfaces that can receive and transmit information via remote procedure calls. The inter-process mechanisms can in some embodiments be inter-process mechanisms associated with an operating system executing on the computing machine. Inter-process mechanisms can in some embodiments create communication interfaces by generating a communication interface within the launch module such that the launch module can receive remote procedure calls from other objects executing on the server . In one embodiment, the launch module shares the address of the isolation environment within which the launch module executes such that objects can communicate with the launch module using the isolation environment address. For example, if a run module wishes to transmit a command to a launch module to launch an application at a particular address, the run module can transmit the application's address along with a launch command to an address of an isolation environment within which the launch module executes.","In one embodiment, the applications , , ,  can be any application described herein or any application able to execute within an isolation environment.","The user sessions ,  can be any user session described herein. In one embodiment a user session ,  is created when a user of a client , \u2032 establishes a connection with a server . The user may access a profile associated with that user. The user session ,  can in some embodiments describe the period of time during which a user connects the server . In other embodiments, the user session ,  can be defined by the period of time during which a client computer , \u2032 accesses a user profile. User sessions ,  can in some embodiments encompass, comprise or include isolation environments or run modules. In other embodiments, user sessions ,  can include isolation environments and communicate with run modules located outside of the user session.","In one embodiment, isolation environments , ,  are included within user sessions. In other embodiments isolation environments , ,  can exist outside of user sessions. The isolation environments , ,  can be any of the isolation environments described herein. In one embodiment launching or launch modules , ,  execute within the isolation environments , , ; while in other embodiments applications execute within the isolation environments , ,  such that the applications are isolated. In some embodiments, a simplified label of the isolation environments , ,  can comprise sandbox.","Illustrated in  is a detailed view of the system described in . A user session  on a server  includes two isolation environments ,  and a run module . Isolation environment A can include an instance of a first application  and a second application  and a launch module instance . Isolation environment B can include an instance of a third application  and a launch module instance . In one embodiment, a runtime object table  and an application delivery service  communicate with the run module .","Further referring to , and in more detail, in one embodiment the user session  can comprise any of the user session components or functionalities described herein. In another embodiment, the launch modules ,  can be any of the launch modules described herein and can comprise any of the launch module components or functionalities described herein.","Executing within the user session  is isolation environment A  that can encompass or isolate a first application  and a second application . Isolation environment A  can in some embodiments be associated with a particular profile or a particular identifier. For example,  depicts isolation environment A  associated with the MICROSOFT OFFICE profile and having the identifier \u201c.\u201d While isolation environment A  is depicted as having the above-mentioned profile and identifier, isolation environment A  can be associated with any profile or identifier according to the methods and systems described herein. Similar to isolation environment A , isolation environment B  can be associated with the ADOBE profile and can have the identifier \u201c.\u201d A profile can include any set of native resources, services, files or other configuration or environmental settings required for an application, a group of applications or an application suite. For example, the MICROSOFT OFFICE profile may include the native resources, files, settings or other configuration or application information specific to a MICROSOFT OFFICE application. Similarly, the ADOBE profile may include the native resources, files, settings or other configuration or application information specific to an ADOBE application. While  depicts isolation environments associated with a MICROSOFT OFFICE or ADOBE profile, isolation environments may be associated with any number of different profiles.","In one embodiment, an isolation environment ,  can be associated with an identifier. This identifier can be in any number of embodiments: an ID; a tag; identifying metadata; an identifying file; or any other identification means by which an application, system or service can identify the isolation environment , . In some embodiments the identifier can be numeric while in other embodiments the identifier can be alphabetic or alpha-numeric. The identifier can also comprise a series of symbols, hieroglyphs, markings, pictures, numeric combinations or any other identifying mark able to identify an isolation environment. In one embodiment the identifier is stored in a registry setting associated with the isolation environment, while in another embodiment the identifier is stored in the runtime object table  or application delivery service  and associated with a particular memory address. In some embodiments, the identifier associated with an isolation environment ,  can comprise any combination of an identifier associated with the isolation environment ,  and an identifier associated with the user session . The identifier can comprise, in other embodiments, any combination of the following: an identifier associated with the server ; an identifier associated with the user of the client ; and identifier associated with the applications executing within the isolation environment; an identifier associated with the run module; or any other identifier able to uniquely distinguish one isolation environment from another. In other embodiments, the identifier associated with the isolation environment can be a path indicating the location of the isolation environment. In still other embodiments, each isolation environment can be uniquely named using any of the following: a randomly generated name; a name comprising the isolation environment ID; a name comprising a name of a profile associated with the isolation environment; a name comprising the location of the isolation environment; a name comprising an identifier or name associated with the user session within which the isolation environment executes or is located; or a name comprising identifying information associated with the server .","The runtime object table  can be any runtime object table  described herein. In one embodiment the runtime object table  stores identifying information about the isolation environments on a computer. This identifying information can include an identifier associated with the isolation environments, the isolation environment location, a path of where the isolation environment can be found, a profile associated with the isolation environment, or any other information that can be used to characterize the contents of an isolation environment or the location of an isolation environment. In some embodiments, when a launch module ,  initially executes within an isolation environment, that launch module ,  can register with the runtime object table  and either insert an entry into the runtime object table  or cause the runtime object table  to generate an entry that includes identification information associated with the isolation environment and that includes information about the profile associated with the isolation environment. The runtime object table  can store isolation environment information in a repository, a list, a table, a database or in any other storage mechanism able to be searched and sorted. When queried, the runtime object table  can return information about a profile, an isolation environment or about any information stored in the runtime object table .","In some embodiments, the application delivery service  can be any application delivery service  described herein. Like the runtime object table , the application delivery service  can also store information about isolation environments. In one embodiment, the application delivery service  tracks the name of each active isolation environment. In another embodiment, the application delivery service  or an isolation environment management module or manager (Not Shown) tracks the name of each active, suspended, inactive or dead isolation environment. The application delivery service  or the isolation environment management module can track an identifier or location of each isolation environment. In still other embodiments, the application delivery service  or the isolation environment management module can track a profile associated with each isolation environment. For example, the application delivery service  can in one embodiment contain a table, list or other tracking mechanism that lists the profiles active in each user session. Thus, searching for the profiles active in a particular user session can produce a listing of the profiles and therefore the isolation environments active within a particular user session. The information returned by the application delivery service  can be any identifier associated with either the profile or the isolation environment and can be used to determine the location of the isolation environment.","In one embodiment, the run module  can be any run module  described herein. The run module  can respond to user requests for applications by querying the application delivery service  to determine if a profile associated with the requested application exists or is active within the requesting user's session. The application delivery service  returns to the run module  information regarding the name of the isolation environment encompassing or isolating the profile associated with the requested application. The run module  can use this information to query the runtime object table  to determine the location or the path of the isolation environment isolating the profile associated with the requested application. In one embodiment, the run module  can further communicate with the launch modules ,  to return to the appropriate launch module ,  a request to launch the application requested by the user. For example, if the user were to request to launch MICROSOFT ACCESS, an application that is part of the MICROSOFT OFFICE profile, the run module  would query the application delivery service  to determine if a MICROSOFT OFFICE profile exists in the first user session . The application delivery service  would process the request and return to the run module  information associated with isolation environment A . The run module  would then use the information transmitted by the application delivery service  to query the runtime object table  for information regarding the location of isolation environment A , and in some embodiments for information regarding launch module A . The runtime object table  can in some embodiments return the location of isolation environment A , and in some embodiments can return information regarding launch module A . The run module  can use the information returned by the runtime object table  to send a request to launch module A  to launch MICROSOFT ACCESS into isolation environment A .","The applications executing within the isolation environments ,  can belong to a profile such that the isolation environments ,  are associated with that particular profile. In one embodiment the first application  is MICROSOFT EXCEL, while the second application  is MICROSOFT WORD. This embodiment is merely illustrative of how two MICROSOFT OFFICE applications can be isolated within an isolation environment  associated with a MICROSOFT OFFICE profile. Similarly, a third application  can be ADOBE READER which illustrates how an ADOBE application can be isolated within an isolation environment  associated with an ADOBE profile.","Illustrated in  is one embodiment of a method  for launching applications into existing isolation environments. In one embodiment, a run module or other module or component intercepts a request to launch an application (Step ). The run module identifies a profile associated with the requested application (Step ) and determines whether an application delivery service has profile information associated with the identified profile (Step ). If it is determined that the application delivery service has profile information associated with the identified profile (Step ) then the application delivery service returns information associated with the isolation environment further associated with the profile (Step ). Once the run module receives the isolation environment information, the run module queries the runtime object table to determine the address of the identified isolation environment (Step ). If the runtime object table has address information associated with the identified isolation environment, then the runtime object table returns the address information to the run module which uses the address information to instruct a launch module to launch the application into the identified isolation environment (Step ). When it is determined that the application delivery service does not have profile information for the determined profile (Step ), the run module may then implement the method  described in  (Step ). Similarly, when it is determined that the runtime object table does not contain an address for the isolation environment (Step ), the run module may then implement the method  described in  (Step ).","Referring to  and in more detail, in one embodiment the method  is carried out by a run module ,  executing on a computing machine. In another embodiment, the method  is carried out by an isolation environment manager executing on a computing machine. The run module ,  can in one embodiment carry out the method  within a user session and in another embodiment can carry out the method  outside of the user session. In some embodiments, the run module ,  and the user session may execute on a first computing machine, while in other embodiments the run module ,  may execute on a second computing machine remotely located from the first computing machine on which the user session executes.","The run module, in some embodiments, intercepts requests generated by a client  to launch a first application (Step ). In one embodiment, the run module can intercept any number of client  generated requests to launch any number of different or substantially similar applications. Thus, in one embodiment the run module can intercept a request to launch or execute a first application and can intercept a second request to launch or execute a second application; while in another embodiment, the run module can intercept a first request to launch or execute a first application and a second request to launch or execute the first application. In an embodiment where more than one request to execute the same application is intercepted, the run module can either instantiate multiple instances of the application or can ignore subsequent requests to execute the same application. In some embodiments another client or module executing within the user session can intercept client generated requests to launch applications and further forward these intercepted requests to the run module. The client generated requests can, in most embodiments, be generated by the client  responsive to input from a user of the client. This input can indicate a command to execute a selected application.","Once the run module intercepts and\/or receives the request to execute an application, the run module can use information about the application to identify a profile associated with the application (Step ). In one embodiment, the run module can use the application name to lookup in a table the name or identifier of a profile associated with the requested application. In another embodiment, the client request can include metadata identifying a profile associated with the requested application. Still other embodiments can include identifying a profile having the same name as the application, while in another embodiment identifying the profile can include querying an application delivery service  to determine the name of a profile associated with the requested application. In some embodiments, the run module may forward the application executing request to another client or module or to the application delivery service  and request that the module, client or service return to the run module the name of a profile associated with the requested application.","The run module can, in most embodiments, use the name of the profile associated with the requested application to query the application delivery service for profile information. In one embodiment the run module can request an enumeration of all the active profiles within a particular user session, while in another embodiment the run module can request an enumeration of all the active profiles within a particular user session and compatible with the requested application. The run module can in some embodiments request the application delivery service to return the name of an isolation environment within the user session and associated with the identified profile. In such an embodiment, the application delivery service can query an internal list, table or database using the identified profile and user session information contained in the run module's request, and can in some embodiments return to the run module a name of a profile associated with the requested application.","The application delivery service can receive a query from the run module to determine whether an active profile associated with the requested application exists within the user session (Step ). In one embodiment, the application delivery service makes a determination as to whether a profile or profile information exists by further querying an internal list of active profiles as described above. Other embodiments include an application delivery service that determines whether an active profile exists within the user session by enumerating a list of each active profile within the user session, and searching through the enumeration to identify a profile matching the description of the profile included in the run module's request or query. When it is determined that an active profile exists in the user session or that the application delivery service has information pertaining to a profile associated with the requested application, the application delivery service can return isolation environment information (Step ). However, when it is determined that an active profile does not exist or that the application delivery service does not have information pertaining to a profile associated with the requested application, the application delivery service can then call up method  described in  (Step ).","When it is determined that the profile exists, the application delivery service can in some embodiments return to the run module isolation environment information (Step ). In one embodiment, the isolation environment information returned to the run module relates to an active profile associated with the requested application such that the isolation environment isolates applications belonging to that active profile. Thus, the isolation environment information relates to an isolation environment that isolates applications substantially similar to the requested application. The application delivery service can in some embodiments return the name of the isolation environment, while in other embodiments the application delivery service can return an address or path associated with the isolation environment. In other embodiments, the application delivery service can return the name of the profile or the location of the profile rather than return the name or address of the isolation environment. In still other embodiments, the application delivery service can return information about launch modules within the isolation environment.","Once the run module receives the information regarding the isolation environment, the run module can then query the runtime object table to determine whether the runtime object table has an address associated with the identified isolation environment (Step ). In one embodiment, the method  may not include this step as the application delivery service may provide the run module with information regarding the location of the isolation environment. In embodiments where the run module seeks information from the runtime object table, the run module may construct a query including the name of the isolation environment identified by the application delivery service and may issue this query to the runtime object table. In response, the runtime object table may locate an address or path associated with the isolation environment and forward this information to the run module. In other embodiments, the runtime object table may respond to a query for isolation environment location information with information regarding an executable or function within a launch module executing within the isolation environment. The run module may then use this path information to pass an argument to the executable or function indicating the path of the requested application. The launch module may then use the application path information to launch the requested application within the isolation environment.","Once the run module receives the address or path information for either the isolation environment or for a launch module within the isolation environment, the run module then issues a command to the launch module to launch the requested application in the isolation environment (Step ). In response the launch module identifies an executable associated with the requested application and executes the application within the isolation environment.","When either the profile information cannot be found within the application delivery service, or the isolation environment location information cannot be found within the runtime object table, the run module may then call the method  illustrated in . This method  describes a process for creating an isolation environment and can be used by the run module to create an isolation environment with it appears that no isolation environment exists for a particular profile. In other embodiments, the run module may either return an error message or otherwise stop executing whether it is determined that either the runtime object table does not include location information associated with the profile or the application delivery service cannot identify a profile associated with the requested application.","Illustrated in  is an embodiment of a method  for generating an isolation environment. In response to a determination that an isolation environment should be created for a particular profile or application, a run module launches a launch module associated with the particular profile or application in a suspended mode (Step ). The run module can then request an application delivery service to isolate the launch module (Step ) and once the launch module is isolated, the run module can pass the application information to the launch module (Step ). Once the launch module is isolated and has the application information, the run module can permit the launch module to resume execution (Step ).","Further referring to , and in more detail, in one embodiment the run module launches the launch module in a suspended mode (Step ). In some embodiments, the run module can launch and instance of a launch module in a suspended mode. The launch module instance can in some embodiments have characteristics or attributes associated with a particular profile or application. Launching the launch module in a suspended mode can comprise creating an instance of a launch module and directing the launch module instance to execute a timer mechanism that prevents all processes from executing until a particular command is received or state is achieved. In other embodiments, launching a launch module instance in a suspended mode could comprise designing a launch module instance but failing to execute the launch module instance.","The run module can then request that an application delivery service isolate the launch module (Step ). Isolating a launch module can comprise generating one or more isolation scopes having a set of native resources directed towards a particular profile. For instance, a particular profile may require a particular set of dynamic link library (dll) files. In such a situation, isolating the launch module may include generating an isolation scope that comprises a set of native resources including the required set of dll files. In other embodiments, isolating the launch module may include generating an application and user isolation layer having attributes specific to a particular user and a particular profile or application. Generating the application and user isolation layer can further include generating a user isolation scope and an application isolation scope having native resources that are specifically used by the particular user and the particular profile or application. In still other embodiments, isolating the launch module can include creating an isolation environment within which the launch module can execute.","Once the launch module is isolated by the application delivery service, the run module can then pass application information to the launch module (Step ). In one embodiment, passing application information to the launch module can comprise passing one of either an application executable file path, an application executable file network address, application executable file stub, application executable file or other application information able to be used by the launch module to launch the application. In still other embodiments, the run module may pass the launch module a memory address storing the path or location of an application. In still other embodiments, the run module may pass the launch module an argument having a path, location or address of the application.","In one embodiment, the run module permits the launch module to resume execution once the run module has passed the application information to the launch module (Step ). Permitting the launch module to resume execution can comprise sending a command to the launch module to execute. In other embodiments, permitting the launch module to resume execution can comprise sending a command to the launch module to cease executing delay modules within the launch module and resume ordinary execution of the launch module functions.","The methods and systems described herein may be provided as one or more computer-readable programs embodied on or in one or more articles of manufacture. The article of manufacture may be a floppy disk, a hard disk, a compact disc, a digital versatile disc, a flash memory card, a PROM, a RAM, a ROM, or a magnetic tape. In general, the computer-readable programs may be implemented in any programming language. Some examples of languages that can be used include C, C++, C#, or JAVA. The software programs may be stored on or in one or more articles of manufacture as object code.","While the present disclosure has described multiple embodiments of systems and methods for launching an application into an existing isolation environment, it should be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention as defined by the following claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The following figures depict certain illustrative embodiments of methods and systems for launching applications into existing isolation environments, where like reference numerals refer to like elements. Each depicted embodiment is illustrative of these methods and systems and not limiting.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIGS. 1B and 1C"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1D"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1E"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 4C"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 4D"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 4E"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 8B"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 8C"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 20"}]},"DETDESC":[{},{}]}
