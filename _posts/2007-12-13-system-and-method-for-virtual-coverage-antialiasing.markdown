---
title: System and method for virtual coverage anti-aliasing
abstract: A graphics system has a mode of operation in which real samples and virtual samples are generated for anti-aliasing pixels. Each virtual sample identifies a set of real samples associated with a common primitive that covers a virtual sample location within a pixel. The virtual samples provide additional coverage information that may be used to adjust the weights of real samples.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07573485&OS=07573485&RS=07573485
owner: NVIDIA Corporation
number: 07573485
owner_city: Santa Clara
owner_country: US
publication_date: 20071213
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application is a continuation of U.S. application Ser. No. 10\/980,078 filed Nov. 2, 2004 now U.S. Pat. No. 7,333,119 and is incorporated herein by reference in its entirety.","The present invention is generally related to anti-aliasing of graphics applications. More particularly, the present invention is directed towards reducing the storage, bandwidth, and computational requirements for achieving high quality anti-aliasing that conventionally requires a substantial number of samples per pixel.","Computer graphics systems represent graphical primitives as pixel elements of a display. Aliasing refers to the visual artifacts, such as stair-stepping of surface edges (sometimes known as \u201cjaggies\u201d), that occur when an image is sampled at a spatial sample frequency that is too low.","A variety of anti-aliasing techniques exist to reduce visual artifacts. One example is supersampling, in which an image is sampled more than once per pixel grid cell and the samples are filtered. For example, in supersampling the contribution of each sample in a pixel may be weighted to determine attributes of the pixel, such as the pixel color. Another example of an anti-aliasing technique is multisampling. As objects are rendered in a multisampling system, a single color is typically computed per primitive and used for all subpixel samples covered by the primitive. Additional background information on anti-aliasing techniques used in graphics processing units (GPUs) may be found in several patents issued to the Nvidia Corporation of Santa Clara, Calif. such as U.S. Pat. No. 6,452,595, \u201cIntegrated graphics processing unit with anti-aliasing,\u201d U.S. Pat. No. 6,720,975, \u201cSupersampling and multi-sampling system and method for anti-aliasing,\u201d and U.S. Pat. No. 6,469,707, \u201cMethod for efficiently rendering color information for a pixel in a computer system,\u201d the contents of each of which are hereby incorporated by reference.","In both supersampling and multisampling the quality of the anti-aliasing tends to improve as the number of samples per partially covered pixel increases. For example, increasing the number of samples per pixel from four samples (\u201c4\u00d7\u201d sampling) to sixteen (\u201c16\u00d7\u201d sampling) would be expected to reduce visual artifacts. However, as the number of samples per pixel increases more sample data must be generated, stored, transported, and processed. Consequently, the required memory resources, computing resources, and memory bandwidth may increase as the number of samples per pixel is increased. As a result, the cost and complexity of a graphics system tends to increase as the number of samples used for anti-aliasing increases.","Therefore, what is desired is an improved apparatus, system, and method for anti-aliasing that achieves many of the same benefits associated with an increase in the number of samples per pixel but without the corresponding increase in cost and complexity associated with conventional anti-aliasing techniques.","A graphics system has a mode of operation in which it determines coverage of primitives at virtual sample locations and real sample locations within a pixel. Information on virtual sample coverage is used to adjust the weights of real samples for a down-filtering process. In one embodiment, a real sample has color component data whereas a virtual sample has no color component data.","In one embodiment, weighted samples for anti-aliasing a pixel are generated by determining coverage of primitives over virtual sample locations and real sample locations and utilizing virtual sample coverage information to adjust the weights of real samples.","One embodiment of a method of generating weighted samples for anti-aliasing pixels includes: generating a sequence of graphical primitives for a scene; detecting coverage of at least one virtual sample location by the primitives; for each covered virtual sample location, forming a virtual sample by identifying a set of real samples that are also covered by a common visible primitive; and utilizing the at least one virtual sample to adjust the weight of at least one real sample.","One embodiment of a method of generating weighted samples for anti-aliasing a pixel includes: determining coverage of a sequence of primitives generated for a scene on real sample locations and virtual sample locations; for each real sample location, generating a real sample having at least color component information; for each virtual sample location, identifying a set of real samples which are covered by a common primitive; and utilizing coverage information for at least one of the virtual sample locations to adjust the weight of at least one of the real samples.","Like reference numerals refer to corresponding parts throughout the several views of the drawings.","The present invention generally comprises an apparatus, system, and method for utilizing both real samples and virtual samples for anti-aliasing (AA) graphical primitives, such as polygons and lines. An exemplary application of virtual sample module  is in a multisampling system, although it will be understood throughout the following discussion that virtual samples of the present invention may be utilized in other types of anti-aliasing systems, such as supersampling systems.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1","b":["100","110","110","115","120","125","130","135","145","150","150","155"]},"In one embodiment, graphics system  includes a coverage update module  to calculate the fractional coverage of primitives across partially covered pixels for virtual sample locations. In one embodiment coverage update module  utilizes a comparatively low precision test to determine which real and virtual samples are covered on individual pixels in order to reduce the bandwidth of information required from the rasterizer . In one embodiment, a virtual sample module  generates virtual samples that provide information on the coverage of primitives across pixels. For a particular pixel, virtual samples are updated in response to a change in the coverage of primitives across the pixel. The virtual samples that are generated may be stored in one or more locations, such as in a frame buffer, color buffer, z buffer, or other memory location. Coverage update module  and virtual sample module  are illustrated at a particular location within graphics pipeline , although it will be understood that they may be located in other locations, such as in ROP .","Virtual sample module  may, in some embodiments, be configured to generate and utilize virtual samples in anti-aliasing calculations for specific operational conditions. In some embodiments, virtual samples are utilized for anti-aliasing calculations only for edge pixels (i.e., only for partially covered pixels). In some embodiments, coverage updates used to generate virtual samples are disabled if a z depth test operation is disabled, a z depth write operation is disabled, or alpha blending is enabled. In some embodiments, an Application Programming Interface (API) provides commands for enabling, disabling, and configuring the use of virtual samples to update coverage information during execution of a graphics program by the CPU (not shown). In one embodiment, heuristics are used to determine when coverage should be updated using virtual samples. For example, the heuristics may be chosen so that rendering modes that correspond to scene geometry get high-quality coverage information using virtual samples, but rendering which corresponds to special effects or lighting (e.g., particles or multi-pass geometry) do not.","When a new primitive crosses one or more real samples, changes to the status of virtual samples are updated. Any virtual sample locations that are covered by the primitive are updated. Additionally, the status of virtual samples that used to refer to the covered real samples, but which are now not covered, are updated. In one embodiment a virtual sample is a pointer that maps a correspondence of a virtual sample location within a pixel to the set of real samples that are covered by a visible (e.g., currently the topmost with respect to an eyepoint) primitive that also covers the virtual sample location. A virtual sample is \u201cowned\u201d by a real sample if it is determined that a visible (topmost) primitive covers both the real sample and the virtual sample. A virtual sample is assumed to have the same color component value as the real samples that own it, since they are all covered by the same primitive. For example, if a real sample of a primitive has a green color, then a virtual sample covered by the same primitive can be assumed to have the same green color. Table 1 illustrates an exemplary mapping for three virtual sample locations within a pixel.",{"@attributes":{"id":"p-0031","num":"0030"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Table of Exemplary Virtual Sample Data."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Virtual Sample Location No. 1","Set Of Real Samples That Are Covered"]},{"entry":[{},"By The Same Visible Primitive That"]},{"entry":[{},"Covers Virtual Sample Location No. 1"]},{"entry":["Virtual Sample Location No. 2","Set Of Real Samples That Are Covered"]},{"entry":[{},"By The Same Visible Primitive That"]},{"entry":[{},"Covers Virtual Sample Location No. 2"]},{"entry":["Virtual Sample Location No. 3","Set Of Real Samples That Are Covered"]},{"entry":[{},"By The Same Visible Primitive That"]},{"entry":[{},"Covers Virtual Sample Location No. 3"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIGS. 2 and 3","FIG. 2"],"b":["200","1","2","3","4","200","205","210","205","1","2","4","210","3","3","210","200","200"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 3","FIG. 2"],"b":["1","2","1","2","3","210","1","2","3"]},"The identity of virtual samples that are owned by a real sample provides additional information that can be used to adjust the weight given to R in a blending process in light of the additional coverage information provided by the virtual samples. For example, if virtual sample locations are distributed within a pixel then the number of virtual samples owned by a real sample will approximately scale with the primitive coverage. Thus, for example, in the case illustrated in  the number of virtual samples owned by real sample R may be used to assign a weight to real sample R that more closely corresponds to the actual coverage percentage of second primitive  within pixel . However, since each virtual sample need only contain a pointer to a real sample, the memory and bandwidth requirements for virtual samples is much lower than if additional conventional real samples were taken in the interior of pixel .",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 4","b":["405","408","410","415","420"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 5","b":"500"},"Pixel  is divided into a 16\u00d716 uniform grid corresponding to 16\u00d7 sampling with the number of real and virtual samples selected to total up to sixteen. A pre-selected number of real sample locations, such as real samples , , , and , are arranged on the 16\u00d716 grid. For each real sample location a conventional real sampling technique may be used to calculate a full set of conventional sample attributes, such as color component values, z depth values, or other sample attributes. In one embodiment there are twelve virtual samples, A, B, C, D, E, F, G H, I, J, K, and L arranged on the same 16\u00d716 uniform grid as real sample locations , , , and . In the example illustrated in , the real samples are located near the borders of the 16\u00d716 uniform grid, since this maximizes virtual sample coverage.","Since each virtual sample is a pointer, it requires much less data than a conventional real sample. As an illustrative example, in one embodiment each real sample is at least 32 bits, and may contain, for example, a 32 bit z depth or stencil value, and a 32 to 128 bit color component value. Each virtual sample requires only sufficient bits to point to all the real samples in a pixel that own it, which, as described below, in some embodiments requires only 1 bit per real sample (e.g., four bits, assuming 4 real samples). Thus, the memory storage and bandwidth requirements for virtual samples are only a small fraction of that of real sample.","In one embodiment a bitcode is used to assign ownership of a virtual sample to one or more real samples. For example, in an embodiment in which there are 12 virtual samples and 4 real samples, each real sample may have a preselected bit code (e.g., bit codes 0001, 0010, 0100, and 1000). Thus, a virtual sample owned by a single real sample may be assigned the same bit code as the real sample.","Virtual samples owned by more than one real sample are indicated by a bit code indicating the set of real samples that own the virtual sample. For example, the virtual sample bit code may have one bit location in the bit code to represent each real sample that owns the virtual sample. For example, a four-bit bitcode has one bit position for each of four real samples. The set of real samples that own a virtual sample can thus be identified by bit positions having a value of \u201c1\u201d (e.g., a bit code of 0001 indicates that the virtual sample is owned by a real sample assigned the first bit position but is not owned by any of the other real samples whereas a bit code of 1001 indicates that the virtual sample is owned by both the real sample assigned the first bit position and by the real sample assigned the fourth bit position).","In one embodiment, a logical OR operation is performed on the bit code of each real sample that owns a virtual sample to generate a bitcode that identifies the set of real samples that owns the virtual sample. For example, a virtual sample that is covered by the same primitive which covers real samples 0001 and 1000 would have, after a logical OR operation on 0001 and 1000, a bitcode of 1001.","The set of bitcodes for all of the virtual samples of one or more pixels forms a virtual coverage buffer. As a new primitive is received the virtual coverage buffer is updated to reflect any changes in ownership of the virtual samples. The virtual coverage buffer may, for example, be stored in a portion of AA buffer  or other memory location.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIGS. 6-11"},"In the example of , it is assumed that one primitive covers the entire pixel grid of pixel , as indicated by the uniform shading of the entire 16\u00d716 grid. For this case, all of the virtual pixels are assigned a default value (e.g., 1111), as indicated in Table 2, indicating that each virtual sample is owned by all four real samples. In one embodiment, the default 1111 value is also assigned to all virtual samples at the beginning of each scene as part of a clear step, such as a z depth buffer clear step performed prior to a new scene.",{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary virtual sample bit codes for the case that one primitive"},{"entry":"covers virtual samples A to L."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"A","1111"]},{"entry":[{},"B","1111"]},{"entry":[{},"C","1111"]},{"entry":[{},"D","1111"]},{"entry":[{},"E","1111"]},{"entry":[{},"F","1111"]},{"entry":[{},"G","1111"]},{"entry":[{},"H","1111"]},{"entry":[{},"I","1111"]},{"entry":[{},"J","1111"]},{"entry":[{},"K","1111"]},{"entry":[{},"L","1111"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 7","b":["705","500","705","710","500","705","710","710","0","2","705","1","3","0","1","2","3","1","3","0","2","0","2","710","1","3","705"]},{"@attributes":{"id":"p-0047","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary virtual sample bit codes for the example of FIG. 7."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"A","0101"]},{"entry":[{},"B","1010"]},{"entry":[{},"C","0101"]},{"entry":[{},"D","0101"]},{"entry":[{},"E","1010"]},{"entry":[{},"F","0101"]},{"entry":[{},"G","0101"]},{"entry":[{},"H","0101"]},{"entry":[{},"I","1010"]},{"entry":[{},"J","0101"]},{"entry":[{},"K","1010"]},{"entry":[{},"L","0101"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 8","b":["805","805","805","710","705","805","805"]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 9","b":["905","705","710","905","705","710","1","3","0","2"]},{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary virtual sample bit codes for the example of FIG. 9."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"A","0101"]},{"entry":[{},"B","0010"]},{"entry":[{},"C","0101"]},{"entry":[{},"D","0101"]},{"entry":[{},"E","0010"]},{"entry":[{},"F","0101"]},{"entry":[{},"G","0101"]},{"entry":[{},"H","1000"]},{"entry":[{},"I","1000"]},{"entry":[{},"J","1000"]},{"entry":[{},"K","0010"]},{"entry":[{},"L","1000"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"As new primitives are rendered, the situation may arise that a new primitive is drawn on top of a real sample such that virtual samples which previously were owned by a visible real sample become orphaned. This case is illustrated in . In the example of , a new triangle  is on top of a previously received triangle . As a result new triangle covers real sample  and also covers virtual sample L. Virtual samples I, H, and J associated with triangle  are now orphaned in that they are not owned by any visible real samples.","A rule is required to deal with orphaned virtual samples. For example, while the virtual sample bit code could be set to zero (to indicate no coverage) for orphaned samples, this might result in a later anti-aliasing operation overweighting one or more of the real samples. In one embodiment, each orphaned virtual sampled has its virtual sample bit code set to be that of the closest real sample within the pixel. For example, orphaned virtual sample H is closest to real sample . Consequently, orphaned virtual sample H may be assigned the bit code of real sample . Conversely, orphaned real samples I and J are closest to real sample  and are assigned the bit code of real sample . Table 5 summarizes the bit codes for the virtual samples after the orphaned samples are assigned to the closest real samples.",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary virtual sample bit codes after orphaned sample reassignment."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"A","0101"]},{"entry":[{},"B","0010"]},{"entry":[{},"C","0101"]},{"entry":[{},"D","0101"]},{"entry":[{},"E","0010"]},{"entry":[{},"F","0101"]},{"entry":[{},"G","0101"]},{"entry":[{},"H","0100"]},{"entry":[{},"I","1000"]},{"entry":[{},"J","1000"]},{"entry":[{},"K","0010"]},{"entry":[{},"L","1000"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 11","FIG. 10","FIG. 11"],"b":["705","710","1005","705","710","1005","1005"]},"As can be understood from the previous discussion of sliver triangles and orphaned virtual samples, the anti-aliasing quality tends to scale with the number of real samples used per pixel. The anti-aliasing quality also depends upon the types of graphical objects being rendered with, for example, lines being likely to require more real samples than polygons to achieve comparable AA quality. In one embodiment, graphics system  has a plurality of modes that tradeoff memory space and bandwidth for anti-aliasing quality. It is contemplated that the modes could be set either statically (e.g., for an entire graphics program) or dynamically, using an API, depending upon the desired level of AA quality and the type of graphics scenes to be rendered. For example, in a 16\u00d7 anti-aliasing system, the number of real samples could be selected to be 2, 3, 4, 5, 6, 7 or 8 real samples with the rest of the 16 samples being virtual samples. For example, in one embodiment, the quality settings for 16\u00d7AA vary from 2, 4, 6 or 8 real samples, and 14, 12, 10 and 8 virtual samples respectively. For 16\u00d7 coverage quality, the equation for bytes of bandwidth and storage is:\n\n64(16\u2212)80,\n\nwhere R is the number of real samples per pixel.  illustrates a plot of the corresponding tradeoff between aliased bandwidth and real sample count.\n","In one embodiment, data storage requirements for virtual samples are reduced by including an algorithm to make certain ownership bit patterns invalid. Quality loss can be avoided by carefully choosing these invalid patterns such that the probability of any pattern occurring is minimized. Conceptually, this is performed by drawing a circle of influence around every real sample. If a virtual sample is located within a real sample's circle, then the real sample is a legal owner of that virtual sample. If not, then the real sample is not a valid owner, and its ownership mask is always considered to be 0. When writing data to the coverage buffer these forced zeros are skipped; when reading, they are added. This allows a 4+12 virtual coverage AA mode to be stored in 32-bits, rather than the typical 48. The rules applied to limit virtual coverage bit patterns will depend upon the number of real samples and their distribution in a pixel. For 4+12 \u201cX\u201d virtual coverage anti-aliasing the convex hull of the 4 real samples is a quadrilateral with vertices at the real samples. In one implementation the 4 virtual samples near the pixel center are allowed to reference all 4 real samples, while the 8 remaining virtual samples may only reference 2 real samples. These specifics are different for alternate sample patterns (for example, 4+12 \u201cY\u201d modes, where the convex hull is a triangle, with the fourth real sample located at approximately the centroid).","As previously described, the virtual samples provide additional information on pixel coverage and may be used to adjust a weight given to real samples in anti-aliasing. For example, since a virtual sample is assumed to have the same color as the real samples that own it, in one embodiment the number of sample counts for a particular color can be increased by the number of corresponding virtual sample counts and then be scaled by the total number of real and virtual samples. However, more generally, an arbitrary weighting function may be used for weighting real samples as a function of the virtual samples that they own.","It is desirable to reduce the computational effort required to calculate real sample weights during a down-sampling process to resolve an anti-aliasing buffer. Since a virtual sample can point to more than one real sample it is desirable to utilize a weighting algorithm that avoids unnecessary renormalization calculations. In one embodiment a virtual sample contributes to the weighting only of the closest real sample to which it points (e.g., the closest real sample with a 1 in a bitmask). An exemplary weighting algorithm for determining weights from the coverage buffer bitmask during a down-sampling process is as follows:\n\n","The final pixel color is calculated during anti-aliasing using the weights calculated for the real samples. An exemplary algorithm for computing the final pixel color as a weighted average of the real sample colors (color[r]) is as follows:\n\n","In one embodiment, graphics system  automatically falls back into a conventional anti-aliasing mode utilizing only the real samples when the coverage information alone for the virtual samples is insufficient. This guarantees a minimum AA quality, for any type of rendering. By way of comparison, some A-buffer and fragment AA techniques have failure modes that introduce artifacts which aren't present in normal multisampling (e.g., bleed-through A-buffer merge artifacts), or drop AA quality to effectively zero, such as during stencil buffer rendering. By gracefully dropping back to 4\u00d7 rotated multisampling (or, more accurately, the number of real samples) in cases where coverage information alone is insufficient (stencil rendering is the most notable example), the algorithm of the present inventing provides a graceful failure mode.","In one embodiment, during a down-sampling process to resolve the AA buffer , each virtual sample's weight is summed up by finding the highest priority bit set where priority is defined by proximity to the real samples. Searching the bits in priority order facilitates a graceful fallback to 4\u00d7 rotated AA, in cases where the virtual coverage buffer may not contain enough information (e.g., stencil-only rendering, alpha blending).","An exemplary pseudocode algorithm to update virtual samples while rendering is the following;\n\n","Note that the check for valid owners (the assertion in the last line) can be performed either during an update or during a downfilter. The two operations are equivalent, and the results identical.","The present invention provides a number of benefits. As previously described, each virtual sample requires less data than a real sample. Consequently, high quality AA may be achieved for a particular number of real and virtual samples with reduced data storage and bandwidth requirements compared with sampling with the same total number of real samples. Additionally, it is highly scalable, order independent, compatible with a low-cost hardware implementation, does not suffer from bleed-through, is compatible with different color and depth buffer formats, and has a graceful failure mode in which it falls back to a minimum AA quality.","While one embodiment of the present invention includes a plurality of real samples and virtual samples locations within each individual pixel, it will be understood that other arrangements are also contemplated. For example, in an alternate embodiment there is one real sample per pixel and one virtual sample. For example, each pixel may share one virtual sample with each of its four neighbors. Thus in this embodiment a pixel has one real sample and four virtual samples arranged along its four edges. In this example the downfiltering would be a weighting of the one real sample and the real samples of neighboring pixels.","The foregoing description, for purposes of explanation, used specific nomenclature to provide a thorough understanding of the invention. However, it will be apparent to one skilled in the art that specific details are not required in order to practice the invention. Thus, the foregoing descriptions of specific embodiments of the invention are presented for purposes of illustration and description. They are not intended to be exhaustive or to limit the invention to the precise forms disclosed; obviously, many modifications and variations are possible in view of the above teachings. The embodiments were chosen and described in order to best explain the principles of the invention and its practical applications, they thereby enable others skilled in the art to best utilize the invention and various embodiments with various modifications as are suited to the particular use contemplated. It is intended that the following claims and their equivalents define the scope of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":["The invention is more fully appreciated in connection with the following detailed description taken in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 8","FIG. 7"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 9","FIG. 7"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 11","FIG. 10"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
