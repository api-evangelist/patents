---
title: Floating point buffer system and method for use during programmable fragment processing in a graphics pipeline
abstract: A system, method and computer program product are provided for buffering data in a computer graphics pipeline. Initially, graphics floating point data is read from a buffer in a graphics pipeline. Next, the graphics floating point data is operated upon in the graphics pipeline. Further, the graphics floating point data is stored to the buffer in the graphics pipeline.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07009615&OS=07009615&RS=07009615
owner: NVIDIA Corporation
number: 07009615
owner_city: Santa Clara
owner_country: US
publication_date: 20011130
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","DISCLOSURE OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["The present invention relates to computer graphics, and more particularly to fragment processing in a graphics pipeline.","Conventional fragment processing for three-dimensional (3-D) graphics programming application program interfaces (APIs) such as Open Graphics Library (OpenGL\u00ae) and Direct3D\u2122 provide support for per-fragment operations. The computations provided by such conventional fragment processing are routinely implemented by 3-D graphics hardware that greatly accelerates these operations.","Unextended OpenGL mandates a certain set of configurable per-fragment computations defining texture lookup, texture environment, color sum, and fog operations. Each of these areas provides a useful but limited set of fixed operations. For example, unextended OpenGL 1.2.1 provides only four texture environment modes, color sum, and three fog modes.","One drawback associated with the current state of the art graphics APIs is that most computations dealing with color or depth buffers are typically constrained to operate on values in the range [0,1]. Computational results are also typically clamped to the range [0,1]. Color, texture, and depth buffers themselves also hold values mapped to the range [0, 1]. Unfortunately, these constraints and the limited precision of typical computations can result in reduced accuracy during graphics processing.","Further, some  quantities that users of programmable graphics APIs would like to compute do not necessarily correspond in number or in range to conventional attributes such as RGBA colors or depth values. Because of the range and precision constraints imposed by conventional fixed-point color buffers, it may be difficult (if not impossible) to use them to implement certain multi-pass algorithms where the intermediate results need to be stored in the frame buffer.","There is thus a need for an application program interface that provides a frame buffer and texture format that allows fragment programs and other applications to read and write unconstrained floating point data.","A system, method and computer program product are provided for buffering data in a computer graphics pipeline. Graphics floating point data is produced in a graphics pipeline. The graphics floating point data are operated upon in the graphics pipeline. Further, the graphics floating point data is stored to the buffer in the graphics pipeline.","In one embodiment, the graphics floating point data may be read and stored in an unclamped format for increasing a precision and\/or range thereof. Further, the precision of the graphics floating point data so processed may be only may be only constrained by an underlying data type.","As an option, the graphics floating point data may include fragment data, color data, depth data, etc. Such fragment data may be received from a rasterizer.","In another embodiment, the buffer may serve as a texture map. Optionally, the graphics floating point data may be packed and\/or unpacked, whereby a technique is provided for encoding and decoding multiple low-precision data items stored in a single higher-precision data format.","Another system, method and computer program product are provided for buffering data during multi-pass rendering in a computer graphics pipeline. Initially, graphics floating point data are operated on during a rendering pass in a graphics pipeline. During this operation, graphics floating point data may be read from a buffer. Further, the graphics floating point results produced by the rendering pass are stored to the buffer. During use, the foregoing operations may be repeated during additional rendering passes.","As an option, the operating step may include deferred shading, where computationally expensive fragment operations may be deferred until it is known that the fragment will be visible in the final rendered scene.","These and other advantages of the present invention may become apparent upon reading the following detailed description and studying the various figures of the drawings.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1","b":["50","52","54","56","57"]},"As an option, each of the foregoing modules may be situated on a single semiconductor platform. In the present description, the single semiconductor platform may refer to a sole unitary semiconductor-based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi-chip modules with increased connectivity which simulate on-chip operation, and make substantial improvements over utilizing a conventional CPU and bus implementation. Of course, the present invention may also be implemented on multiple semiconductor platforms and\/or utilizing a conventional CPU and bus implementation.","During operation, the VAB  is included for gathering and maintaining a plurality of vertex attribute states such as position, normal, colors, texture coordinates, etc. Completed vertices are processed by the transform module  and then sent to the lighting module . The transform module  generates vectors for the lighting module  to light. The output of the lighting module  is screen space data suitable for the set-up module  which, in turn, sets up primitives. Thereafter, rasterization module  carries out rasterization of the primitives.","An interface may be used in conjunction with the various components set forth in . In one embodiment, such interface may include at least in part the Open Graphics Library (OpenGL\u00ae), Direct3D\u2122 application program interfaces (APIs), a proprietary application program interface, or the like. OpenGL\u00ae is the computer industry's standard application program interface (API) for defining 2-D and 3-D graphic images. With OpenGL\u00ae, an application can create the same effects in any operating system using any OpenGL-adhering graphics adapter. OpenGL\u00ae specifies a set of commands or immediately executed functions. Each command directs a drawing action or causes special effects. OpenGL\u00ae and Direct3D\u2122 APIs are commonly known to those of ordinary skill, and more information on the same may be found by reference to the OpenGL\u00ae Specification Version 1.3 which is incorporated herein by reference in its entirety.","As is well known, OpenGL\u00ae mandates a certain set of configurable per-fragment computations defining texture lookup, texture environment, color sum, and fog operations. Several extensions have been developed to provide further per-fragment computations to OpenGL\u00ae.","Each of such extensions adds a small set of relatively inflexible per-fragment computations. As mentioned earlier, this inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, digital signal processors (DSPs), or central processor units (CPUs)) that are traditionally used to implement OpenGL's per-fragment computations.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 2","FIG. 1"],"b":["200","201"]},"As an option, the fragment data may include constant registers associated with a fragment, attributes associated with a fragment, color values, etc. Further, the attributes may include texture coordinates. It should be noted that the fragment data may include any type of data associated with fragments. In the context of the present description, a fragment includes any entity generated by rasterization of primitives.","Next, in decision , it is determined whether the graphics pipeline is operating in a programmable mode. This may be accomplished via any type of signal or command. Just by way of example, a command associated with an application program interface may indicate whether the graphics pipeline is operating in the programmable mode. Such command may optionally be called by a program which governs operation of the graphics pipeline via the application program interface.","If it is determined that the graphics pipeline is operating in the programmable mode, programmable operations are performed on the fragment data in order to generate output. See operation .","In one embodiment, the programmable operations may include retrieving texture data. In particular, such texture data may be retrieved utilizing arbitrary texture coordinates. In such embodiment, the fragment program execution environment may access textures via arbitrarily computed texture coordinates. As such, there is no necessary correspondence between the texture coordinates and texture maps previously lumped into a single \u201ctexture unit\u201d. This technique enables implementations where the number of texture coordinate sets and texture image units may differ, providing methods for querying the number of each supported by the implementation.","In another embodiment, the programmable operations may include mathematical computations. Further, the programmable operations may include a kill operation, a partial derivative operation, a texture mapping operation, among others. As an option, a packing operation (i.e. PK, PK, etc.) and\/or an unpacking operation (i.e. UP, UP, etc.) may be employed.","The PK\/PK\/UP\/UP instructions may allow one to store more than four (4) quantities in a single buffer in a single pass, assuming it is acceptable to store them at lower precision. The PK\/PK\/UP\/UP instructions may be useful for packing multiple attribute sets into a \u201cwide\u201d frame buffer. For example, a 128-bit \u201cRGBA\u201d frame buffer could pack 16 8-bit quantities or 8 16-bit quantities, all of which could be used in later rasterization passes.","PK: Pack Two 16-bit Floats","The PK instruction converts the \u201cx\u201d and \u201cy\u201d components of the single operand into 16-bit floating-point format, packs the bit representation of these two floats into a 32-bit value, and replicates that value to all four components of the result vector. The PK instruction can be reversed by the UP instruction mentioned below. See Table #1A.",{"@attributes":{"id":"p-0035","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE #1A"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tmp0 = VectorLoad(op0);"]},{"entry":[{},"\/* result obtained by combining raw bits of tmp0.x, tmp0.y *\/"]},{"entry":[{},"result.x = RawBits(tmp0.x) | (RawBits(tmp0.y) << 16);"]},{"entry":[{},"result.y = RawBits(tmp0.x) | (RawBits(tmp0.y) << 16);"]},{"entry":[{},"result.z = RawBits(tmp0.x) | (RawBits(tmp0.y) << 16);"]},{"entry":[{},"result.w = RawBits(tmp0.x) | (RawBits(tmp0.y) << 16);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":"4"},"The PK instruction converts the four components of the single operand into 8-bit signed quantities. The signed quantities are represented in a bit pattern where all \u20180\u2019 bits corresponds to \u2212128\/127 and all \u20181\u2019 bits corresponds to +127\/127. The bit representation of the four converted components are packed into a 32-bit value, and that value is replicated to all four components of the result vector. The PK instruction can be reversed by the UP instruction below. See Table #1B.",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE #1B"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tmp0 = VectorLoad(op0);"]},{"entry":[{},"if (tmp0.y < \u2212128\/127) tmp0.y = \u2212128\/127;"]},{"entry":[{},"if (tmp0.z < \u2212128\/127) tmp0.z = \u2212128\/127;"]},{"entry":[{},"if (tmp0.w < \u2212128\/127) tmp0.w = \u2212128\/127;"]},{"entry":[{},"if (tmp0.x > +127\/127) tmp0.x = +127\/127;"]},{"entry":[{},"if (tmp0.y > +127\/127) tmp0.y = +127\/127;"]},{"entry":[{},"if (tmp0.z > +127\/127) tmp0.z = +127\/127;"]},{"entry":[{},"if (tmp0.w > +127\/127) tmp0.w = +127\/127;"]},{"entry":[{},"ub.x = round(127.0 * tmp0.x + 128.0); \/* ub is a ubyte vector *\/"]},{"entry":[{},"ub.y = round(127.0 * tmp0.y + 128.0);"]},{"entry":[{},"ub.z = round(127.0 * tmp0.z + 128.0);"]},{"entry":[{},"ub.w = round(127.0 * tmp0.w + 128.0);"]},{"entry":[{},"\/* result obtained by combining raw bits of ub. *\/"]},{"entry":[{},"result.x = ((ub.x) | (ub.y << 8) | (ub.z << 16) | (ub.w << 24));"]},{"entry":[{},"result.y = ((ub.x) | (ub.y << 8) | (ub.z << 16) | (ub.w << 24));"]},{"entry":[{},"result.z = ((ub.x) | (ub.y << 8) | (ub.z << 16) | (ub.w << 24));"]},{"entry":[{},"result.w = ((ub.x) | (ub.y << 8) | (ub.z << 16) | (ub.w << 24));"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"UP: Unpack Two 16-Bit Floats","The UP instruction unpacks two 16-bit floats stored together in a 32-bit scalar operand. The first 16-bit float (stored in the 16 least significant bits) is written into the \u201cx\u201d and \u201cz\u201d components of the result vector; the second is written into the \u201cy\u201d and \u201cw\u201d components of the result vector.","This operation undoes the type conversion and packing performed by the PK instruction. See Table #1C.",{"@attributes":{"id":"p-0041","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE #1C"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tmp = ScalarLoad(op0);"]},{"entry":[{},"result.x = (fp16) (RawBits(tmp) & 0xFFFF);"]},{"entry":[{},"result.y = (fp16) ((RawBits(tmp) >> 16) & 0xFFFF);"]},{"entry":[{},"result.z = (fp16) (RawBits(tmp) & 0xFFFF);"]},{"entry":[{},"result.w = (fp16) ((RawBits(tmp) >> 16) & 0xFFFF);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The scalar operand may be loaded from a 32-bit temporary register. A fragment program may fail to load if any other register type is specified.","UP: Unpack Four Signed 8-Bit Values","The UP instruction unpacks four 8-bit signed values packed together in a 32-bit scalar operand. The signed quantities are encoded where a bit pattern of all \u20180\u2019 bits corresponds to \u2212128\/127 and a pattern of all \u20181\u2019 bits corresponds to +127\/127. The \u201cx\u201d component of the result vector is the converted value corresponding to the 8 least significant bits of the operand; the \u201cw\u201d component corresponds to the 8 most significant bits.","This operation undoes the type conversion and packing performed by the PK instruction. See Table #1D.",{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE #1D"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tmp = ScalarLoad(op0);"]},{"entry":[{},"result.x = (((RawBits(tmp) >> 0) & 0xFF) \u2212 128) \/ 127.0;"]},{"entry":[{},"result.y = (((RawBits(tmp) >> 8) & 0xFF) \u2212 128) \/ 127.0;"]},{"entry":[{},"result.z = (((RawBits(tmp) >> 16) & 0xFF) \u2212 128) \/ 127.0;"]},{"entry":[{},"result.w = (((RawBits(tmp) >> 24) & 0xFF) \u2212 128) \/ 127.0;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The scalar operand may be loaded from a 32-bit temporary register. A fragment program may fail to load if any other register type is specified.","More information on various programmable operations will be set forth hereinafter in greater detail.","It should be noted that the output of the programmable operations may include any desired values that may be used for graphics processing. For example, the output of the programmable operations may include color values associated with a fragment. Such output of the programmable operations may also include depth values associated with a fragment.","As another option, the fragment data may be operated upon in a form which includes four-component vectors in a floating point representation for reasons that will soon become apparent. In particular, the present technique may define a programming model including a 4-component vector instruction set, 16- and 32-bit floating-point data types, and a relatively large set of temporary registers.","In still yet another embodiment, the programmable operations may be performed utilizing register combiners (i.e., NV_register_combiners extension) and\/or in the context of multi-texturing (i.e. ARB_multitexture extension).","An exemplary method in which operation  is executed will be set forth in greater detail during reference to .","If, on the other hand, it is determined in decision  that the graphics pipeline is not operating in the programmable mode, standard graphics application program interface (API) operations are performed on the fragment data in order to generate output. Note operation .","As an option, the standard graphics application program interface may include OpenGL\u00aeor any other desired graphics application program interface. Further, the standard graphics application program interface operations may be selected from the group consisting of texturing operations, color sum operations, fog operations, among others.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 3","FIG. 2","FIG. 2"],"b":["300","204","300","200"]},"As shown, fragment data is received which is selected from the group consisting of constant registers, color values and texture coordinates associated with a fragment. Note operation . Next, a current instruction of a fragment program is identified in operation . This may be accomplished utilizing a pointer or the like.","Subsequently, it is determined in decision  as to whether the identified instruction is a texture instruction. If so, texture data is retrieved utilizing texture coordinates in accordance with the fragment program. See operation . Thereafter, a condition code is evaluated, as will be set forth in greater detail during reference to operation .","In a similar manner, it is determined in decision  as to whether the identified instruction is a mathematical instruction. If so, mathematical computations are performed involving the fragment data in accordance with the fragment program, as indicated in operation . Thereafter, a condition code is evaluated, as will be set forth in greater detail during reference to operation .","Similarly, it is, determined in decision  as to whether the identified instruction is a packing or unpacking instruction. If so, a packing or unpacking operation is performed involving the fragment data in accordance with the fragment program, as indicated in operation . Thereafter, a condition code is evaluated, as will be set forth in greater detail during reference to operation .","Next, it is determined in decision  as to whether the identified instruction is a kill instruction. If so, a condition code is evaluated in operation . More information regarding such condition code will be set forth hereinafter in greater detail. If the condition code is evaluated to be TRUE, the fragment is killed and the program is terminated. Note operation . If, however, the condition code is evaluated to be FALSE, other \u201cspecial\u201d instruction types are searched and executed. Note operation .","It is then determined in decision  as to whether the current instruction is the last instruction of the fragment program. If not, the various operations are repeated using the next instruction. If so, however, at least one of color values and depth values are outputted based on the texture data, the mathematical computations, etc. Note operation . It should be noted that the floating-point color values outputted may actually have nothing to do with color, per-se. They could be, for example, normals (for future lighting operations), distances, or any other number of quantities.","The present technique may, in one embodiment, take the form of an extension that provides a mechanism for defining fragment program instruction sequences for application-defined fragment programs. When in a fragment program mode, a fragment program may be executed each time a fragment is produced by rasterization. The inputs for the program may be a set of constant registers and the attributes (e.g. colors, texture coordinates) associated with the fragment. Further, a fragment program may perform texture lookups using arbitrary texture coordinates and mathematical computations. The results of a fragment program are new color and depth values for the fragment. Again, it should be noted that the floating-point color values outputted may actually have nothing to do with color, per-se. They could be, for example, normals (for future lighting operations), distances, or any other number of quantities.","The present fragment program execution environment may be designed for efficient hardware implementation and to support a wide variety of programs. By design, the existing operations defined by existing OpenGL\u00ae per-fragment computation extensions can be implemented using the present model.","More information regarding programmable fragment processing may be found by reference to a co-pending application entitled \u201cSYSTEM, METHOD AND COMPUTER PROGRAM PRODUCT FOR PROGRAMMABLE FRAGMENT PROCESSING IN A GRAPHICS PIPELINE\u201d filed concurrently herewith by the same inventors under application Ser. No. 10\/000,996, and which is incorporated herein by reference in its entirety.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 4","FIG. 1"],"b":["400","400"]},"Further, the present embodiment may optionally build upon the foregoing fragment programmability to provide a framebuffer and texture format that allows fragment programs to read and write unconstrained floating point data. Of course, it should be noted that the present embodiment may be employed in any desired environmental context. For example, this technique may be carried out in any desired graphics sub-system.","Initially, in operation , graphics floating point data are operated upon in a graphics pipeline. Such operations may include texturing operations, color sum operations, fog operations, or any other operation that contributes to or facilitates graphics processing. Such operations may or may not be associated with the aforementioned fragment program.","During such operation , graphics floating point data may be produced. This may be accomplished by reading the same from a buffer (e.g. texture maps) in a graphics pipeline, generating the same with a rasterizer, or any other desired method. It should be noted that an order of operations  and  may be interchangeable, as with the remaining operations.","As an option, the graphics floating point data may include fragment data, color data, depth data, etc. Such fragment data may be received from a rasterizer or any other desired source. Of course, the graphics floating point data may include any data in the graphics pipeline that is in a floating point form. Further, some of such data may be fixed-point data that is optionally converted to floating-point. For example, interpolated RGBA colors (e.g., f[COL0] in fragment programs) may be initially generated as fixed-point data.","Next, the graphics floating point data is stored to the buffer in the graphics pipeline. See operation .","In one embodiment, the graphics floating point data may be read and stored in an unclamped format for increasing a parameter selected from the group consisting of a precision and a range of the graphics floating point data. Further, the graphics floating point data may be only constrained by an underlying data type.","In another embodiment, the buffer may serve as a texture map. More details regarding such use will be set forth hereinafter in greater detail.","As an option, the method  may be used in the context of multi-pass rendering in a computer graphics pipeline. See decision . During use, the foregoing operations \u2013 may be repeated during additional rendering passes per the desires of the user. More information on such embodiment will be set forth hereinafter in greater detail.","For more information on multi-pass rendering, reference may be made to a patent application entitled \u201cSYSTEM, METHOD AND ARTICLE OF MANUFACTURE FOR SHADOW MAPPING\u201d which was filed Dec. 5, 2000 under Ser. No. 09\/730,639, and which is incorporated herein by reference.","As an option, the operating may include deferred shading. More information on such embodiment will be set forth hereinafter in greater detail.","The present embodiment may thus provide a general computational model that supports floating-point numbers constrained only by the precision of the underlying data types.","To enhance the extended range and precision available through fragment programs, the present embodiment provides floating-point RGBA color buffers to replace conventional fixed-point RGBA color buffers. It should be noted that the floating-point RGBA color buffers can (and often will) be used to store non-color data. A floating-point RGBA color buffer consists of one to four floating-point components stored in the 16- or 32-bit floating-point formats (fp or fp) which may be defined by a fragment program such as NV_fragment_program. Of course, formats other than 16- and 32-bit floating point are clearly possible.","A floating-point color buffer can replace the conventional fixed-point color buffer. In this case, the results of fragment programs, written to the \u201cx\u201d, \u201cy\u201d, \u201cz\u201d, and \u201cw\u201d components of COLR\/COLH output registers, may written directly to the color buffer without any scaling, clamping, or other modification. Certain per-fragment operations may be bypassed when rendering to floating-point color buffers.","A floating-point color buffer can also be used as a texture map, either by using conventional TexImage calls or by using previous rendering results via an extension such as the ARB_render_texture extension.","The present embodiment has many uses. Some exemplary possible uses will now be set forth.","(1) Multi-pass algorithms with arbitrary intermediate results that don't have to be artificially forced to the range [0,1]. In addition, intermediate results can be accumulated without having to worry about [0,1] clamping.","(2) Deferred shading algorithms where an expensive fragment program is executed only after depth testing is fully complete. Instead, a simple program is executed, which stores the parameters necessary to produce a final result. After the entire scene is rendered, a second pass is executed over the entire frame buffer to execute the complex fragment program using the results written to the floating-point color buffer in the first pass. This may save the cost of executing complex fragment programs on fragments that may not necessarily appear in the final image.","(3) Use of texture maps to evaluate functions with arbitrary ranges. Arbitrary continuous functions with a bounded domain could be approximated using a texture map holding sample results and piecewise linear interpolation.","More information will now be set forth regarding an exemplary embodiment of the foregoing technique. The following description should be reviewed for illustrative purposes only, and should not be construed as limiting in any manner. The foregoing principles may be applied in any desired extension and in any desired context.","The following description is set forth in the context of OpenGL\u00ae which is commonly known to those of ordinary skill. More particularly, the following information is set forth in the context of the OpenGL\u00ae Specification Version 1.3, which is incorporated herein by reference in its entirety. It should be noted that, in the present description, OpenGL\u00ae API commands and tokens are prefixed by \u201cgl\u201d and \u201cGL_,\u201d respectively. Also, OpenGL\u00ae extension commands and tokens for extensions provided by NVIDIA\u00ae Corporation are, by convention, suffixed by \u201cNV\u201d or \u201c_NV,\u201d respectively. When the context is clear, such prefixes and suffices are dropped for brevity and clarity.","Various exemplary tokens associated with the present embodiment will now be set forth in Table #1E.",{"@attributes":{"id":"p-0086","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE #1E"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Accepted by the <internalformat> parameter of TexImage3D,"},{"entry":"TexImage2D,"},{"entry":"\u2003TexImage1D, CopyTexImage2D, and CopyTexImage1D:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003FLOAT_R_NV","0x8880"]},{"entry":["\u2003\u2003FLOAT_RG_NV","0x8881"]},{"entry":["\u2003\u2003FLOAT_RGB_NV","0x8882"]},{"entry":["\u2003\u2003FLOAT_RGBA_NV","0x8883"]},{"entry":["\u2003\u2003FLOAT_R16_NV","0x8884"]},{"entry":["\u2003\u2003FLOAT_R32_NV","0x8885"]},{"entry":["\u2003\u2003FLOAT_RG16_NV","0x8886"]},{"entry":["\u2003\u2003FLOAT_RG32_NV","0x8887"]},{"entry":["\u2003\u2003FLOAT_RGB16_NV","0x8888"]},{"entry":["\u2003\u2003FLOAT_RGB32_NV","0x8889"]},{"entry":["\u2003\u2003FLOAT_RGBA16_NV","0x888A"]},{"entry":["\u2003\u2003FLOAT_RGBA32_NV","0x888B"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003Accepted by the <pname> parameter of GetBooleanv,"},{"entry":"GetIntegerv, GetFloatv,"},{"entry":"\u2003and GetDoublev:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003TEXTURE_FLOAT_COMPONENTS_NV","0x888C"]},{"entry":["\u2003\u2003FLOAT_CLEAR_COLOR_VALUE_NV","0x888D"]},{"entry":["\u2003\u2003FLOAT_RGBA_MODE_NV","0x888E"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003Accepted in the <piAttributes> array of"},{"entry":"wglGetPixelFormatAttribivARB and"},{"entry":"\u2003wglGetPixelFormatAttribfvARB and in the <piAttribIList>"},{"entry":"and"},{"entry":"\u2003<pfAttribFList> arrays of wglChoosePixelFormatARB:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003WGL_FLOAT_COMPONENTS_NV","0x63F0"]},{"entry":["\u2003\u2003WGL_BIND_TO_TEXTURE_RECTANGLE","0x63F1"]},{"entry":"\u2003\u2003FLOAT_R_NV"},{"entry":["\u2003\u2003WGL_BIND_TO_TEXTURE_RECTANGLE","0x63F2"]},{"entry":"\u2003\u2003FLOAT_RG_NV"},{"entry":["\u2003\u2003WGL_BIND_TO_TEXTURE_RECTANGLE","0x63F3"]},{"entry":"\u2003\u2003FLOAT_RGB_NV"},{"entry":["\u2003\u2003WGL_BIND_TO_TEXTURE_RECTANGLE","0x63F4"]},{"entry":"\u2003\u2003FLOAT_RGBA_NV"},{"entry":["\u2003\u2003WGL_TEXTURE_FLOAT_R_NV","0x63F5"]},{"entry":["\u2003\u2003WGL_TEXTURE_FLOAT_RG_NV","0x63F6"]},{"entry":["\u2003\u2003WGL_TEXTURE_FLOAT_RGB_NV","0x63F7"]},{"entry":["\u2003\u2003WGL_TEXTURE_FLOAT_RGBA_NV","0x63F8"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"For RGBA components, if the destination of the operation is a fixed-point color buffer, each element is clamped to [0,1] and the resulting values are converted to fixed-point in a well known manner. Otherwise, elements are not necessarily modified. More information on this topic, as it pertains to fixed-point color buffers, that is well known to those of ordinary skill may be found in section 3.6.4 of the OpenGL 1.3 Specification.","Texture Image Specification","The selected groups are processed exactly as for DrawPixels stopping just before final conversion. For textures with fixed-point RGBA internal formats, each R, G, B, A component is clamped to [0,1].","Components are selected from the resulting pixel groups to obtain a texture with the base internal format specified by (or derived from) <internalformat>. Table #2 summarizes the mapping of pixel group values to texture components.","Specifying a value of <format> incompatible with <internalformat> produces the error INVALID_OPERATION. A pixel format and texture internal format are compatible if the pixel format can generate a pixel group of the type listed in the \u201cPixel Group Type\u201d column of Table #2 in the row corresponding to the base internal format.","Textures with a base internal format of FLOAT_R_NV, FLOAT_RG_NV, FLOAT_RGB_NV, and FLOAT_RGBA_NV are known as floating-point textures. Such textures take the form of RGBA floating-point data, but the data contained may not have anything to do with color. In one embodiment, floating point textures may be supported only for the TEXTURE_RECTANGLE_NV target. Specifying an floating-point texture with any other target may produce an INVALID_OPERATION error.",{"@attributes":{"id":"p-0092","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},"Pixel",{},{}]},{"entry":["Base Internal","Group","Component","Internal"]},{"entry":["Format","Type","Values","Components"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ALPHA","RGBA","A","A"]},{"entry":["LUMINANCE","RGBA","R","L"]},{"entry":["LUMINANCE_ALPHA","RGBA","R,A","L,A"]},{"entry":["INTENSITY","RGBA","R","I"]},{"entry":["RGB","RGBA","R,G,B","R,G,B"]},{"entry":["RGBA","RGBA","R,G,B,A","R,G,B,A"]},{"entry":["*COLOR_INDEX","CI","CI","CI"]},{"entry":["*DEPTH_COMPONENT","DEPTH","DEPTH","DEPTH"]},{"entry":["*HILO_NV","HILO","HI,LO","HI,LO"]},{"entry":["*DSDT_NV","TEXOFF","DS,DT","DS,DT"]},{"entry":["*DSDT_MAG_NV","TEXOFF","DS,DT,MAG","DS,DT,MAG"]},{"entry":["*DSDT_MAG","TEXOFF","DS,DT,","DS,DT,MAG,I"]},{"entry":["INTENSITY_NV","or RGBA","MAG,VIB"]},{"entry":["FLOAT_R_NV","RGBA","R","R (float)"]},{"entry":["FLOAT_RG_NV","RGBA","R,G","R,G (float)"]},{"entry":["FLOAT_RGB_NV","RGBA","R,G,B","R,G,B (float)"]},{"entry":["FLOAT_RGBA_NV","RGBA","R,G,B,A","R,G,B,A (float)"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":"Conversion from pixel groups to internal texture components. \u201cPixel Group Type\u201d defines the type of pixel group required for the specified internal format. All internal components are stored as unsigned-fixed point numbers, except for DS\/DT (signed fixed-point numbers) and floating-point R,G,B,A (signed floating-point numbers). Texture components \u2192 R, G, B, A, L, and I. Texture components \u2192 HI, LO, DS, DT, and MAG."},{"entry":"*indicates formats found in other extension specs: COLOR_INDEX in EXT_paletted texture; DEPTH_COMPONENT in SGIX_depth_texture; and HILO_NV, DSDT_NV, DSDT_MAG_NV, DSDT_MAG_INTENSITY_NV in NV_texture_shader."}]}}}}},"It should be noted that this table may be respecfied with any extensions relevant to texture formats supported by a particular environment. For example, four base internal formats may be added.","The internal component resolution is the number of bits allocated to each component in a texture image. If internal format is specified as a base internal format (as listed in Table #2), the GL stores the resulting texture with internal component resolutions of its own choosing. If a sized internal format is specified, the memory allocation per texture component is assigned by the GL to match the allocations listed in Table #3 as closely as possible.",{"@attributes":{"id":"p-0095","num":"0094"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},{},"Component"]},{"entry":["Sized","Base","Name\/"]},{"entry":["Int. Format","Int. Format","Type-Size"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ALPHA4","ALPHA","A\/U4"]},{"entry":["ALPHA8","ALPHA","A\/U8"]},{"entry":["ALPHA12","ALPHA","A\/U12"]},{"entry":["ALPHA16","ALPHA","A\/U16"]},{"entry":["LUMINANCE4","LUMINANCE","L\/U4"]},{"entry":["LUMINANCE8","LUMINANCE","L\/U8"]},{"entry":["LUMINANCE12","LUMINANCE","L\/U12"]},{"entry":["LUMINANCE16","LUMINANCE","L\/U16"]},{"entry":["LUMINANCE4_ALPHA4","LUMINANCE","A\/U4 L\/U4"]},{"entry":[{},"ALPHA"]},{"entry":["LUMINANCE6_ALPHA2","LUMINANCE","A\/U2 L\/U6"]},{"entry":[{},"ALPHA"]},{"entry":["LUMINANCE8_ALPHA8","LUMINANCE","A\/U8 L\/U8"]},{"entry":[{},"ALPHA"]},{"entry":["LUMINANCE12_ALPHA4","LUMINANCE","A\/U4 L\/U12"]},{"entry":[{},"ALPHA"]},{"entry":["LUMINANCE12_ALPHA12","LUMINANCE","A\/U12"]},{"entry":[{},"ALPHA","L\/U12"]},{"entry":["LUMINANCE16_ALPHA16","LUMINANCE","A\/U16"]},{"entry":[{},"ALPHA","L\/U16"]},{"entry":["INTENSITY4","INTENSITY","I\/U4"]},{"entry":["INTENSITY8","INTENSITY","I\/U8"]},{"entry":["INTENSITY12","INTENSITY","I\/U12"]},{"entry":["INTENSITY16","INTENSITY","1\/U16"]},{"entry":["R3_G3_B2","RGB","R\/U3 G\/U3"]},{"entry":[{},{},"B\/U2"]},{"entry":["RGB4","RGB","R\/U4 G\/U4"]},{"entry":[{},{},"B\/U4"]},{"entry":["RGB5","RGB","R\/U5 G\/U5"]},{"entry":[{},{},"B\/U5"]},{"entry":["RGB8","RGB","R\/U8 G\/U8"]},{"entry":[{},{},"B\/U8"]},{"entry":["RGB10","RGB","R\/U10 G\/"]},{"entry":[{},{},"U10 B\/10"]},{"entry":["RGB12","RGB","R\/U12 G\/"]},{"entry":[{},{},"U12 B\/U12"]},{"entry":["RGB16","RGB","R\/U16 G\/"]},{"entry":[{},{},"U16 B\/U16"]},{"entry":["RGBA2","RGBA","R\/U2 G\/U2"]},{"entry":[{},{},"B\/U2 A\/U2"]},{"entry":["RGBA4","RGBA","R\/U4 G\/U4"]},{"entry":[{},{},"B\/U4 A\/U4"]},{"entry":["RGB5_A1","RGBA","R\/U5 G\/U5"]},{"entry":[{},{},"B\/U5 A\/U1"]},{"entry":["RGBA8","RGBA","R\/U8 G\/U8"]},{"entry":[{},{},"B\/U8 A\/U8"]},{"entry":["RGB10_A2","RGBA","R\/U10 G\/"]},{"entry":[{},{},"U10 B\/U10"]},{"entry":[{},{},"A\/U2"]},{"entry":["RGBA12","RGBA","R\/U12 G\/"]},{"entry":[{},{},"U12 B\/U12"]},{"entry":[{},{},"A\/U12"]},{"entry":["RGBA16","RGBA","R\/U16 G\/"]},{"entry":[{},{},"U16 B\/U16"]},{"entry":[{},{},"A\/U16"]},{"entry":["*COLOR_INDEX1_EXT","COLOR_INDEX","CI\/U1"]},{"entry":["*COLOR_INDEX2_EXT","COLOR_INDEX","CI\/U2"]},{"entry":["*COLOR_INDEX4_EXT","COLOR_INDEX","CI\/U4"]},{"entry":["*COLOR_INDEX8_EXT","COLOR_INDEX","CI\/U8"]},{"entry":["*COLOR_INDEX16_EXT","COLOR_INDEX","CI\/U16"]},{"entry":["*DEPTH_COMPONENT16","DEPTH","Z\/U16"]},{"entry":["SGIX","COMPONENT"]},{"entry":["*DEPTH_COMPONENT24","DEPTH","Z\/U24"]},{"entry":["SGIX","COMPONENT"]},{"entry":["*DEPTH_COMPONENT32","DEPTH","Z\/U32"]},{"entry":["SGIX","COMPONENT"]},{"entry":["*HILO16_NV","HILO","HI\/U16"]},{"entry":[{},{},"LO\/U16"]},{"entry":["*SIGNED_HILO16_NV","HILO","HI\/S16"]},{"entry":[{},{},"LO\/S16"]},{"entry":["*SIGNED_RGBA8_NV","RGBA","R\/S8 G\/S8"]},{"entry":[{},{},"B\/S8 A\/S8"]},{"entry":"*SIGNED_RGB8_"},{"entry":["UNSIGNED_ALPHA8_NV","RGBA","R\/S8 G\/S8"]},{"entry":[{},{},"B\/S8 A\/U8"]},{"entry":["*SIGNED_RGB8_NV","RGB","R\/S8 G\/S8"]},{"entry":[{},{},"B\/S8"]},{"entry":["*SIGNED_LUMINANCE8_NV","LUMINANCE","L\/S8"]},{"entry":"*SIGNED_LUMINANCE8_"},{"entry":["ALPHA8_NV","LUMINANCE","L\/S8 A\/S8"]},{"entry":[{},"ALPHA"]},{"entry":["*SIGNED_ALPHA8_NV","ALPHA","A\/S8"]},{"entry":["*SIGNED_INTENSITY8_NV","INTENSITY","I\/S8"]},{"entry":["*DSDT8_NV","DSDT_NV","DS\/S8"]},{"entry":[{},{},"DT\/S8"]},{"entry":["*DSDT8_MAG8_NV","DSDT_MAG_NV","DS\/S8 DT\/"]},{"entry":[{},{},"S8 MAG\/U8"]},{"entry":["*DSDT8_MAG8_","DSDT_MAG_","DS\/S8 DT\/"]},{"entry":["INTENSITY8_NV","INTENSITY_NV","S8 MAG\/U8"]},{"entry":[{},{},"I\/U8"]},{"entry":["FLOAT_R16_NV","FLOAT_R_NV","R\/F16"]},{"entry":["FLOAT_R32_NV","FLOAT_R_NV","R\/F32"]},{"entry":["FLOAT_RG16_NV","FLOAT_RG_NV","R\/F16 G\/F16"]},{"entry":["FLOAT_RG32_NV","FLOAT_RG_NV","R\/F32 G\/F32"]},{"entry":["FLOAT_RGB16_NV","FLOAT_RGB_NV","R\/F16 G\/"]},{"entry":[{},{},"F16 B\/F16"]},{"entry":["FLOAT_RGB32_NV","FLOAT_RGB_NV","R\/F32 G\/"]},{"entry":[{},{},"F32 B\/F32"]},{"entry":["FLOAT_RGBA16_NV","FLOAT_RGBA_NV","R\/F16 G\/"]},{"entry":[{},{},"F16 B\/F16"]},{"entry":[{},{},"A\/F16"]},{"entry":["FLOAT_RGBA32_NV","FLOAT_RGBA_NV","R\/F32 G\/"]},{"entry":[{},{},"F32 B\/F32"]},{"entry":[{},{},"A\/F32"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":"Sized Internal Formats. Describes the correspondence of sized internal formats to base internal formats, and desired component resolutions. Component resolution descriptions are of the form \u201c<NAME>\/<TYPE><SIZE>\u201d, where NAME specifies the component name in Table #2, TYPE is \u201cU\u201d for unsigned fixed-point, \u201cS\u201d for signed fixed-point, and \u201cF\u201d for unsigned floating-point. <SIZE> is the number of requested bits per component."},{"entry":"*indicates formats found in other extension specs: COLOR_INDEX in EXT_paletted texture; DEPTH_COMPONENT in SGIX_depth_texture; and HILO_NV, DSDT_NV, DSDT_MAG_NV, DSDT_MAG_INTENSITY_NV in NV_texture_shader."}]}}}}},"It should be noted that this table may be respecfied with any extensions relevant to sized texture internal formats supported by a particular environment. For example, eight sized internal formats may be added. More information on this topic that is well known to those of ordinary skill may be found in section 3.8.1 of the OpenGL 1.3 Specification and the extension specifications for the extensions listed above.","Texture Minification","Floating-point textures (those with a base internal format of FLOAT_R_NV, FLOAT_RG_NV, FLOAT_RGB_NV, or FLOAT_RGBA_NV) do not necessarily support texture filters other than NEAREST. For such textures, NEAREST filtering is applied regardless of the setting of TEXTURE_MIN_FILTER. More information on this topic that is well known to those of ordinary skill may be found in section 3.8.7 of the OpenGL 1.3 Specification.","Texture Magnification","Floating-point textures (those with a base internal format of FLOAT_R_NV, FLOAT_RG_NV, FLOAT_RGB_NV, or FLOAT_RGBA_NV) do not necessarily support texture filters other than NEAREST. For such textures, NEAREST filtering is applied regardless of the setting of TEXTURE_MAG_FILTER. More information on this topic that is well known to those of ordinary skill may be found in section 3.8.8 of the OpenGL 1.3 Specification.","Texture Environments and Texture Functions","If the base internal format is HILO_NV, DSDT_NV, DSDT_MAG_NV, DSDT_MAG_INTENSITY_NV, FLOAT_R_NV, FLOAT_RG_NV, FLOAT_RGB_NV, or FLOAT_RGBA_NV, means to combine texture lookup results with the current fragment color are not necessarily supported using conventional OpenGL texture functions. In one embodiment where such textures are unsupported, the corresponding texture function is NONE (Cv=Cf, Av=Af), and it is as though texture mapping were disabled for that texture unit. It may even be possible to define useful conventional behavior. More information on this topic that is well known to those of ordinary skill may be found in section 3.8.13 of the OpenGL 1.3 Specification.","Antialiasing Application","If antialiasing is enabled for the primitive from which a rasterized fragment was produced, then the computed coverage value may be applied to the fragment. In RGBA mode with fixed-point frame buffers, the value is multiplied by the fragment's alpha (A) value to yield a final alpha value. In RGBA mode with floating-point frame buffers, the coverage value may simply be discarded in some embodiments. In color index mode, the value is used to set the low order bits of the color index value. More information on this topic that is well known to those of ordinary skill may be found in section 3.11 of the OpenGL 1.3 Specification.","Per-Fragment Operations and the Frame Buffer","The GL provides three types of color buffers: color index, fixed-point RGBA, or floating-point RGBA. Color index buffers consist of unsigned integer color indices. Fixed-point RGBA buffers consist of R, G, B, and optionally, A unsigned integer values. Floating-point RGBA buffers consist of R, and optionally, G, B, and A floating-point component values, which may correspond to the X, Y, Z, and W outputs, respectively, of a fragment program. The number of bitplanes in each of the color buffers, the depth buffer, the stencil buffer, and the accumulation buffer is fixed and window dependent. If an accumulation buffer is provided, it may have at least as many bitplanes per R, G, and B color component as do the color buffers. More information on this topic that is well known to those of ordinary skill may be found in Chapter 4 of the OpenGL 1.3 Specification.","Multisample Fragment Operations","Optionally, this step applies only for fixed-point RGBA color buffers. Otherwise, proceed to the next step. More information on this topic that is well known to those of ordinary skill may be found in section 4.1.3 of the OpenGL 1.3 Specification. Of course, the present step may optionally be applied to floating-point RGBA color buffers.","Alpha Test","This step applies only for fixed-point RGBA color buffers. Otherwise, proceed to the next step. More information on this topic that is well known to those of ordinary skill may be found in section 4.1.4 of the OpenGL 1.3 Specification. Of course, the present step may optionally be applied to floating-point RGBA color buffers.","Blending","Blending combines the incoming fragment's R, G, B, and A values with the R, G, B, and A values stored in the framebuffer at the incoming fragment's (xw; yw) location. This blending is dependent on the incoming fragment's alpha value and that of the corresponding currently stored pixel. Blending applies only for fixed-point RGBA color buffers; otherwise, it is bypassed. More information on this topic that is well known to those of ordinary skill may be found in section 4.1.7 of the OpenGL 1.3 Specification. Of course, the present step may optionally be applied to floating-point RGBA color buffers.","Dithering","Dithering selects between two color values or indices. Dithering does not necessarily apply to floating-point RGBA color buffers. More information on this topic that is well known to those of ordinary skill may be found in section 4.1.8 of the OpenGL 1.3 Specification.","Logical Operation","A logical operation is applied between the incoming fragment's color or index values and the color or index values stored at the corresponding location in the frame buffer. Logical operations do not necessarily apply to floating-point color buffers. More information on this topic that is well known to those of ordinary skill may be found in section 4.1.9 of the OpenGL 1.3 Specification.","Additional Multisample Fragment Operations","For fixed-point RGBA color buffers, after all operations have been completed on the multisample buffer. For floating-point RGBA color buffers, the color buffer is not necessarily modified. More information on this topic that is well known to those of ordinary skill may be found in section 4.1.10 of the OpenGL 1.3 Specification.","Clearing the Buffers","The GL provides a means for setting portions of every pixel in a particular buffer to the same value. The argument to\n\n","If there is no accumulation buffer, or if color buffer is not fixed-point RGBA, Accum may generate the error INVALID_OPERATION. More information on this topic that is well known to those of ordinary skill may be found in section 4.2.4 of the OpenGL 1.3 Specification.","Reading Pixels\/Conversion of RGBA Values","This step applies only if the GL is in RGBA mode, and then only if format is neither STENCIL INDEX nor DEPTH COMPONENT. The R, G, B, and A values form a group of elements. If the color buffer has fixed-point format, each element is taken to be a fixed-point value in [0,1] with m bits, where m is the number of bits in the corresponding color component of the selected buffer. More information on this topic that is well known to those of ordinary skill may be found in section 4.3.2 of the OpenGL 1.3 Specification.","Final Conversion of ReadPixels Data","For an RGBA color, components are clamped depending on the data type of the buffer being read. For fixed-point buffers, each component is clamped to [0.1]. For floating-point buffers, if <type> is not FLOAT or HALF_FLOAT_NV, each component is clamped to [0,1] if <type> is unsigned or [\u22121,1] if <type> is signed and then converted. More information on this topic that is well known to those of ordinary skill may be found in section 4.3.2 of the OpenGL 1.3 Specification.","Texture Queries","Table #4 illustrates texture, table, and filter return values. Ri, Gi, Bi, Ai, Li, and Ii are components of the internal format that are assigned to pixel values R, G, B, and A. If a requested pixel value is not present in the internal format, the specified constant value is used. More information on this topic that is well known to those of ordinary skill may be found in section 6.1.4 of the OpenGL 1.3 Specification.",{"@attributes":{"id":"p-0113","num":"0113"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE #4"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]},{"entry":[{},"Base Internal Format","R","G","B","A"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FLOAT_R_NV","R","0","0","0"]},{"entry":[{},"FLOAT_RG_NV","R","G","0","0"]},{"entry":[{},"FLOAT_RGB_NV","R","G","B","0"]},{"entry":[{},"FLOAT_RGBA_NV","R","G","B","A"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Table #5 illustrates possible modifications to WGL (OpenGL on Microsoft Windows\u00ae) subsystem, as extended by the ARB_pixel_format and ARB_render_texture extensions, to accommodate the present invention.",{"@attributes":{"id":"p-0115","num":"0115"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"343pt","align":"left"}},"thead":{"row":[{"entry":"TABLE #5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003Modify\/add to the description of <piAttributes> in"},{"entry":"wglGetPixelFormatAttribivARB and <pfAttributes> in wglGetPixelFormatAttribfvARB:"},{"entry":"\u2003WGL_FLOAT_COMPONENTS_NV"},{"entry":"\u2003\u2003True if the R, G, B, and A components of each color buffer are"},{"entry":"\u2003\u2003represented as (unclamped) floating-point numbers."},{"entry":"\u2003WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_R_NV"},{"entry":"\u2003WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RG_NV"},{"entry":"\u2003WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGB_NV"},{"entry":"\u2003WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGBA_NV"},{"entry":"\u2003\u2003True if the pixel format describes a floating-point color that can be"},{"entry":"\u2003\u2003bound to a texture rectangle with internal formats of FLOAT_R_NV,"},{"entry":"\u2003\u2003FLOAT_RG_NV, FLOAT_RGB_NV, or FLOAT_RGBA_NV, respectively. Currently"},{"entry":"\u2003\u2003only pbuffers can be bound as textures so this attribute may only be"},{"entry":"\u2003\u2003TRUE if WGL_DRAW_TO_PBUFFER is also TRUE. Additionally,"},{"entry":"\u2003\u2003floating-point color buffers can not necessarily be bound to texture targets"},{"entry":"\u2003\u2003other than TEXTURE_RECTANGLE_NV."},{"entry":"Add new table entries for pixel format attribute matching in"},{"entry":"wglChoosePixelFormatARB."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Attribute","Type","Match Criteria"]},{"entry":["WGL_FLOAT_COMPONENTS_NV","boolean","exact"]},{"entry":["WGL_BIND_TO_TEXTURE","boolean","exact"]},{"entry":"\u2003RECTANGLE_FLOAT_R_NV"},{"entry":["WGL_BIND_TO_TEXTURE","boolean","exact"]},{"entry":"\u2003RECTANGLE_FLOAT_RG_NV"},{"entry":["WGL_BIND_TO_TEXTURE","boolean","exact"]},{"entry":"\u2003RECTANGLE_FLOAT_RGB_NV"},{"entry":["WGL_BIND_TO_TEXTURE","boolean","exact"]},{"entry":"\u2003RECTANGLE_FLOAT_RGBA_NV"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"343pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(In the wglCreatePbufferARB section, modify the attribute list)"},{"entry":"\u2003WGL_TEXTURE_FORMAT_ARB"},{"entry":"\u2003This attribute indicates the base internal format of the texture that will be"},{"entry":"\u2003created when a color buffer of a pbuffer is bound to a texture map. It can"},{"entry":"\u2003be set to WGL_TEXTURE_RGB_ARB (indicating an internal format of RGB),"},{"entry":"\u2003WGL_TEXTURE_RGBA_ARB (indicating a base internal format of RGBA),"},{"entry":"\u2003WGL_TEXTURE_FLOAT_R_NV (indicating a base internal format of FLOAT_R_NV),"},{"entry":"\u2003WGL_TEXTURE_FLOAT_RG_NV (indicating a base internal format of FLOAT_RG_NV),"},{"entry":"\u2003WGL_TEXTURE_FLOAT_RGB_NV (indicating a base internal format of FLOAT_RGB_NV),"},{"entry":"\u2003WGL_TEXTURE_FLOAT_RGBA_NV (indicating a base internal format of"},{"entry":"\u2003FLOAT_RGBA_NV), orWGL_NO_TEXTURE_ARB. The default value is"},{"entry":"\u2003WGL_NO_TEXTURE_ARB."},{"entry":"(In the wglCreatePbufferARB section, modify the discussion of what happens"},{"entry":"to the depth\/stencil\/accum buffers when switching between mipmap levels or"},{"entry":"cube map faces.)"},{"entry":"\u2003For pbuffers with a texture format of WGL_TEXTURE_RGB_ARB,"},{"entry":"\u2003WGL_TEXTURE_RGBA_ARB, WGL_TEXTURE_FLOAT_R_NV, WGL_TEXTURE_FLOAT_RG_NV,"},{"entry":"\u2003WGL_TEXTURE_FLOAT_RGB_NV, or WGL_TEXTURE_FLOAT_RGBA_NV, there will be a"},{"entry":"\u2003separate set of color buffers for each mipmap level and cube map face in the"},{"entry":"\u2003pbuffer. Otherwise, the WGL implementation is free to share a single set of"},{"entry":"\u2003color, auxillary, and accumulation buffers between levels or faces."},{"entry":"For pbuffers with a texture format of"},{"entry":"WGL_TEXTURE_DEPTH_COMPONENT_NV,"},{"entry":"there may be a separate depth buffer for each mipmap level and cube map"},{"entry":"face. However, any stencil, accumulation, and color buffers may be shared"},{"entry":"between levels or faces. Therefore, the contents of the stencil,"},{"entry":"accumulation, and color buffers are undefined after switching between"},{"entry":"mipmap levels or cube map faces."},{"entry":"(In the wglCreatePbufferARB section, modify the error list)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"252pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ERROR_INVALID_DATA","WGL_TEXTURE_FORMAT_ARB is"]},{"entry":[{},"WGL_TEXTURE_FLOAT_R_NV,"]},{"entry":[{},"WGL_TEXTURE_FLOAT_RG_NV,"]},{"entry":[{},"WGL_TEXTURE_FLOAT_RGB_NV, or"]},{"entry":[{},"WGL_TEXTURE_FLOAT_RGBA_NV, and"]},{"entry":[{},"WGL_TEXTURE_TARGET_ARB is not"]},{"entry":[{},"WGL_TEXTURE_RECTANGLE_NV."]},{"entry":["ERROR_INVALID_DATA","WGL_TEXTURE_FORMAT_ARB is"]},{"entry":[{},"WGL_TEXTURE_FLOAT_R_NV,"]},{"entry":[{},"WGL_TEXTURE_TARGET_ARB is"]},{"entry":[{},"WGL_TEXTURE_RECTANGLE_NV, and the"]},{"entry":[{},"WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_R_NV"]},{"entry":[{},"attribute is not necessarily set in the pixel format."]},{"entry":["ERROR_INVALID_DATA","WGL_TEXTURE_FORMAT_ARB is"]},{"entry":[{},"WGL_TEXTURE_FLOAT_RG_NV,"]},{"entry":[{},"WGL_TEXTURE_TARGET_ARB is"]},{"entry":[{},"WGL_TEXTURE_RECTANGLE_NV, and the"]},{"entry":[{},"WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RG_NV"]},{"entry":[{},"attribute is not necessarily set in the pixel format."]},{"entry":["ERROR_INVALID_DATA","WGL_TEXTURE_FORMAT_ARB is"]},{"entry":[{},"WGL_TEXTURE_FLOAT_RGB_NV,"]},{"entry":[{},"WGL_TEXTURE_TARGET_ARB is"]},{"entry":[{},"WGL_TEXTURE_RECTANGLE_NV, and the"]},{"entry":[{},"WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGB_NV"]},{"entry":[{},"attribute is not necessarily set in the pixel format."]},{"entry":["ERROR_INVALID_DATA","WGL_TEXTURE_FORMAT_ARB is"]},{"entry":[{},"WGL_TEXTURE_FLOAT_RGBA_NV,"]},{"entry":[{},"WGL_TEXTURE_TARGET_ARB is"]},{"entry":[{},"WGL_TEXTURE_RECTANGLE_NV, and the"]},{"entry":[{},"WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGBA_NV"]},{"entry":[{},"attribute is not necessarily set in the pixel format."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"343pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Modify wglBindTexImageARB:"},{"entry":"\u2003The pbuffer attribute WGL_TEXTURE_FORMAT_ARB determines the base"},{"entry":"\u2003internal format of the texture. The format-specific component sizes"},{"entry":"\u2003are also determined by pbuffer attributes as shown in the table below."},{"entry":"The component sizes are dependent on the format of the texture."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Component","Size","Format"]},{"entry":["R","WGL_RED_BITS_ARB","RGB, RGBA, FLOAT_R, FLOAT_RG,"]},{"entry":[{},{},"FLOAT_RGB, FLOAT_RGBA"]},{"entry":["G","WGL_GREEN_BITS_ARB","RGB, RGBA, FLOAT_R, FLOAT_RG,"]},{"entry":[{},{},"FLOAT_RGB, FLOAT_RGBA"]},{"entry":["B","WGL_BLUE_BITS_ARB","RGB, RGBA, FLOAT_R, FLOAT_RG,"]},{"entry":[{},{},"FLOAT_RGB, FLOAT_RGBA"]},{"entry":["A","WGL_ALPHA_BITS_ARB","RGB, RGBA, FLOAT_R, FLOAT_RG,"]},{"entry":[{},{},"FLOAT_RGB, FLOAT_RGBA"]},{"entry":["D","WGL_DEPTH_BITS_ARB","DEPTH_COMPONENT"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Table #6 illustrates a plurality of errors that may be relevant in the context of the present embodiment.",{"@attributes":{"id":"p-0117","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE #6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003INVALID_OPERATION may be generated by Begin, DrawPixels,"},{"entry":"Bitmap, CopyPixels, or a command that performs an explicit Begin if"},{"entry":"the color buffer has a floating-point RGBA format and"},{"entry":"FRAGMENT_PROGRAM_NV is disabled."},{"entry":"\u2003INVALID_OPERATION is generated by TexImage3D, TexImage2D,"},{"entry":"TexImage1D, TexSubImage3D, TexSubImage2D, or TexSubImage1D if"},{"entry":"the pixel group type corresponding to <format> is not compatible with"},{"entry":"the base internal format of the texture."},{"entry":"\u2003INVALID_OPERATION may be generated by TexImage3D, Tex-"},{"entry":"Image1D, or CopyTexImage1D if the base internal format corresponding"},{"entry":"to <internalformat> is FLOAT_R_NV,"},{"entry":"FLOAT_RG_NV, FLOAT_RGB_NV, or FLOAT_RGBA_NV."},{"entry":"\u2003INVALID_OPERATION may be generated by TexImage2D or"},{"entry":"CopyTexImage2D if the base internal format corresponding to"},{"entry":"<internalformat> is FLOAT_R_NV, FLOAT_RG_NV,"},{"entry":"FLOAT_RGB_NV, or FLOAT_RGBA_NV and <target> is not"},{"entry":"TEXTURE_RECTANGLE_NV."},{"entry":"\u2003INVALID_OPERATION may be generated by Accum if the color"},{"entry":"buffer has a color index or floating-point RGBA format;"},{"entry":"\u2003ERROR_INVALID_DATA may be generated by"},{"entry":"wglCreatePbufferARB if WGL_TEXTURE_FORMAT_ARB is"},{"entry":"WGL_TEXTURE_FLOAT_R_NV,"},{"entry":"GL_TEXTURE_FLOAT_RG_NV,"},{"entry":"WGL_TEXTURE_FLOAT_RGB_NV, or"},{"entry":"WGL_TEXTURE_FLOAT_RGBA_NV, and"},{"entry":"WGL_TEXTURE_TARGET_ARB is not"},{"entry":"WGL_TEXTURE_RECTANGLE_NV."},{"entry":"\u2003ERROR_INVALID_DATA is generated by wglCreatePbufferARB if"},{"entry":"WGL_TEXTURE_FORMAT_ARB is"},{"entry":"WGL_TEXTURE_FLOAT_R_NV,"},{"entry":"WGL_TEXTURE_TARGET_ARB is"},{"entry":"WGL_TEXTURE_RECTANGLE_NV, and the"},{"entry":"WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_R_NV"},{"entry":"attribute is not set in the pixel format."},{"entry":"\u2003ERROR_INVALID_DATA is generated by wglCreatePbufferARB if"},{"entry":"WGL_TEXTURE_FORMAT_ARB is"},{"entry":"WGL_TEXTURE_FLOAT_RG_NV,"},{"entry":"WGL_TEXTURE_TARGET_ARB is"},{"entry":"WGL_TEXTURE_RECTANGLE_NV, and the"},{"entry":"WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RG_NV"},{"entry":"attribute is not set in the pixel format."},{"entry":"\u2003ERROR_INVALID_DATA is generated by wglCreatePbufferARB if"},{"entry":"WGL_TEXTURE_FORMAT_ARB is"},{"entry":"WGL_TEXTURE_FLOAT_RGB_NV,"},{"entry":"GL_TEXTURE_TARGET_ARB is"},{"entry":"WGL_TEXTURE_RECTANGLE_NV, and the"},{"entry":"WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGB_NV"},{"entry":"attribute is not set in the pixel format."},{"entry":"\u2003ERROR_INVALID_DATA is generated by wglCreatePbufferARB if"},{"entry":"WGL_TEXTURE_FORMAT_ARB is"},{"entry":"WGL_TEXTURE_FLOAT_RGBA_NV,"},{"entry":"WGL_TEXTURE_TARGET_ARB is"},{"entry":"WGL_TEXTURE_RECTANGLE_NV, and the"},{"entry":"WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGBA_NV"},{"entry":"attribute is not set in the pixel format."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0118","num":"0118"},"figref":"FIG. 5","b":"500"},"Options and Issues","The extension could create a separate non-RGBA pixel formats or simply extend existing RGBA formats. Since fragment programs generally build on RGBA semantics, it's cleaner to avoid creating a separate \u201cXYZW\u201d mode. There are several special semantics that may be added: clear color state is now not clamped, and ReadPixels may clamp to [0,1] only if the source data comes from fixed-point color buffers.","It should be noted that fragment programs can be written that store data completely unrelated to color into a floating-point \u201cRGBA\u201d color buffer.","Floating-point color buffers may or may not be displayed. In one embodiment, floating-point color buffers can only be used as pbuffers (i.e. off-screen windows), to avoid the expense of building floating-point display engine logic.","Various things may happen when rendering to a floating-point color buffer if fragment program mode is disabled, or when fragment program mode is enabled, but no program is loaded. Fragment programs may be required to use floating-point color buffers. An INVALID_OPERATION error may be generated by any GL command that generates fragments if a fragment program extension such as FRAGMENT_PROGRAM_NV is disabled. The same behavior already exists in some embodiments for conventional frame buffers if FRAGMENT_PROGRAM_NV is enabled but the bound fragment program is invalid.","Alpha test may or may not be supported with floating-point color buffers. If not, it is trivial to implement an alpha test in a fragment program using a KIL instruction, which requires no dedicated frame buffer logic.","Blending may or may not be supported with floating-point color buffers. While blending would clearly be useful, full-precision floating-point blenders are expensive. In addition, a computational model more general than traditional blending (with its 1-x operations and clamping) is desirable. The traditional OpenGL blending model would not necessarily be the most suitable computational model for blend-enabled floating-point color buffers.","An alternative to conventional blending (operating at a coarser granularity) is to (1) render a pass into the color buffer, (2) bind the color buffer as a texture rectangle using this extension and ARB_render_texture, (3) perform texture lookups in a fragment program using the TEX instruction with f[WPOS].xy as a 2D texture coordinate, and (4) perform the necessary blending between the passes using the same fragment program.","Accumulation buffers may or may not be provided for pixel formats with floating-point color buffers. If not, accumulation operations can be achieved by using multiple color buffers with fragment programs to perform the accumulation, which requires no dedicated frame buffer logic.","Fragment program color results may or may not be converted to match the format of the frame buffer. Further, an error may or may not result. A situation of interest arises when one writes to o[COLR] but has a 16-bit floating-point frame buffer. Conversions can be performed simply in hardware, so no error semantics are required. This mechanism also allows the same programs to be shared between contexts with different pixel formats.","Applications may be aware that PK\/PK results are preserved only if written to an appropriate-sized frame buffer.","Floating-point color buffers may interact with multisampling in any desired manner. For normal color buffers, the multiple samples for each pixel may be required to be filtered down to a single color. Similar filtering on floating-point color buffers does not necessarily make sense. Further, there may or may not be a normal color buffer in this case. Floating-point buffers are specified to work with multisampling just like normal color buffers, except that no automatic resolution is performed. Still, this has its problems. For example, what would ReadPixels return? One option may be for an application to supersample (i.e., allocate a larger buffer) instead of multisample, but that has performance disadvantages. A second option may be to eat the memory and do a downsample if and only if necessary. A third option may be to specify \u201cmultisample-only\u201d behavior.","Conventional RGBA antialiasing multiplies coverage by the alpha component of the fragment's color, with the assumption that alpha blending will be performed. Antialiasing may work with floating-point color buffers in various ways. It should be noted, however, that conventional antialiasing requires alpha blending, which may or may not work for floating-point color buffers.","The semantics for DrawPixels may vary when using an floating-point color buffer. DrawPixels generates fragments like any other primitive. For floating-point color buffers, the components of the associated color are not necessarily clamped to [0, 1], as with conventional frame buffers. This ensures that one can save and restore floating-point color buffers using ReadPixels\/DrawPixels.","The semantics for ReadPixels may vary when using an floating-point color buffer. ReadPixels from a floating-point color buffer works like any other RGBA read, except that the final results are not necessarily clamped to the range [0, 1]. This ensures that one can save and restore floating-point color buffers using ReadPixels\/DrawPixels.","The semantics for CopyPixels may vary when using an floating-point color buffer. CopyPixels requires no special semantics, as it is equivalent to a slightly abbreviated ReadPixels followed by a DrawPixels.","The semantics for Bitmap may also vary when using an floating-point color buffer. Bitmap generates fragments using the current raster attributes, which are then passed to fragment programs like any other fragments.","Still yet, the semantics for Clear may vary when using an floating-point color buffer. Clears work as normal, except for clamping. The core spec is modified so that clear color values are not necessarily clamped to [0, 1]. For fixed-point color buffers, clear colors are clamped to [0,1] at clear time.","For compatibility with conventional OpenGL, queries of CLEAR_COLOR_VALUE may clamp components to [0,1]. A separate FLOAT_CLEAR_COLOR NV query should be added to query unclamped color clear values.","Floating-point textures may or may not support filtering. Texture filtering may be achieved in various ways. Extended OpenGL texture filtering (including mipmapping and support for anisotropic filters) is very computationally expensive. Even simple linear filtering for floating-point textures with large components is expensive.","Linear filters can be implemented in fragment programs by doing multiple lookups into the same texture. Since fragment programs allow the use of arbitrary coordinates into arbitrary texture maps, this type of operation can be easily done.","A 1D linear filter can be implemented using an n\u00d71 texture rectangle with the following (untested) fragment program, assuming the 1D coordinate is in f[TEX0].x. Note Table #7.",{"@attributes":{"id":"p-0140","num":"0140"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE #7"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ADDR H2.xy, f[TEX0].x, {0.0, 1.0};"]},{"entry":[{},"FRCH H3.x, R1.x; # compute the blend factor"]},{"entry":[{},"TEX H0, H2.x, TEX0, RECT; \u2003# lookup 1st sample"]},{"entry":[{},"TEX H1, H2.y, TEX0, RECT; \u2003# lookup 2nd sample"]},{"entry":[{},"LRPH H0, H3.x, H1, H0; \u2003\u2003\u2003# blend"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"A 2D linear filter can be implemented similarly, assuming the 2D coordinate is in f[TEX0].xy. Note Table #8.",{"@attributes":{"id":"p-0142","num":"0142"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE #8"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ADDH H2, f[TEX0].xyxy, {0.0, 0.0, 1.0, 1.0};",{}]},{"entry":["FRCH H3.xy, H2.xyxy;","# base weights"]},{"entry":["ADDH H3.zw, 1.0, \u2212H3.xyxy;","# 1-base weights"]},{"entry":["MULH H3, H3.xzxz, H3.yyww;","# bilinear filter weights"]},{"entry":["TEX H1, R2.xyxy, TEX0, RECT;","# lookup 1st sample"]},{"entry":["MULH H0, H1, H3.x;","# blend"]},{"entry":["TEX H1, R2.zyzy, TEX0, RECT;","# lookup 2nd sample"]},{"entry":["MADH H0, H1, H3.y, H0;","# blend"]},{"entry":["TEX H0, R2.xwxw, TEX0, RECT;","# lookup 3rd sample"]},{"entry":["MADH H0, H1, H3.z, H0;","# blend"]},{"entry":["TEX H1, R2.zwzw, TEX0, RECT;","# lookup 4th sample"]},{"entry":["MADH H0, H1, H3.w, H0;","# blend"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In some embodiments, an extension such as NV_texture_rectangle may be required in order to use floating-point texture maps. On many graphics hardware platforms, texture maps are stored using a special memory encodings designed to optimize rendering performance. In current hardware, conventional texture maps usually top out at 32 bits per texel. The logic required to encode and decode 128-bit texels (and frame buffer pixels) optimally is substantially more complex. A simpler texture mapping model, such as that in NV_texture_rectangle would not necessarily require such logic.","If one tries to use an floating-point texture without a fragment program, various things may happen. There is nothing preventing one from doing this, other than the driver. It is as though the texture were disabled.","The present embodiment may interact with the OpenGL 1.2 imaging subset in various ways. The imaging subset as specified should work properly with floating-point color buffers. However, there may be places where one may extend the functionality of the imaging subset to deal with the fact that the color buffer data may extend beyond the \u201cnormal\u201d [0,1] range.","The present embodiment may interact with SGIS_generate_mipmap in various ways. Since the present embodiment supports only texture rectangles (which have no mipmaps), this issue may be moot. In the general case, mipmaps may be generated using a 2\u00d72 box filter (or something fancier) where components are averaged. Components should not necessarily be clamped during any such mipmap generation.","There are several things that may be considered with the use of floating-point color buffers. First, floating-point color buffers may or may not support frame buffer blending. Second, floating-point texture maps may or may not support mipmapping or any texture filtering other than NEAREST. Third, floating-point texture maps may be D, D or D, and may use the NV_texture_rectangle extension.","It should be noted that if extensions such as EXT_paletted texture, SGIX_depth texture, and NV_texture_shader are not supported, the rows in Tables #2 and #3 corresponding to texture formats defined by the unsupported extension may be removed.","While various embodiments have been described above, it may be understood that they have been presented by way of example only, and not limitation. Thus, the breadth and scope of a preferred embodiment may not be limited by any of the above described exemplary embodiments, but may be defined only in accordance with the following claims and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing and other aspects and advantages are better understood from the following detailed description of a preferred embodiment of the invention with reference to the drawings, in which:",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 3","FIG. 2"],"b":"204"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
