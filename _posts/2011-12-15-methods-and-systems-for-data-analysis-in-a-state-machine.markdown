---
title: Methods and systems for data analysis in a state machine
abstract: A state machine engine may be configured to recognize (e.g., detect) a great number of patterns in a data stream. This may be accomplished via detection cells of state machine elements that output a respective result of an analysis performed by the respective state machine elements, for example, a match in an analyzed data stream from a single state machine element, which may be utilized in conjunction with results from other state machine elements, for example, to search for a pattern in a data stream. These matches may be provided to a match element, which may operate to output a selected result generated from a row of state machine elements for a given data stream search or a portion of a data stream search.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09443156&OS=09443156&RS=09443156
owner: Micron Technology, Inc.
number: 09443156
owner_city: Boise
owner_country: US
publication_date: 20111215
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"p":["1. Field of Invention","Embodiments of the invention relate generally to electronic devices and, more specifically, in certain embodiments, to electronic devices with parallel finite state machines for pattern-recognition.","2. Description of Related Art","Complex pattern recognition can be inefficient to perform on a conventional von Neumann based computer. A biological brain, in particular a human brain, however, is adept at performing pattern recognition. Current research suggests that a human brain performs pattern recognition using a series of hierarchically organized neuron layers in the neocortex. Neurons in the lower layers of the hierarchy analyze \u201craw signals\u201d from, for example, sensory organs, while neurons in higher layers analyze signal outputs from neurons in the lower levels. This hierarchical system in the neocortex, possibly in combination with other areas of the brain, accomplishes the complex pattern recognition that enables humans to perform high level functions such as spatial reasoning, conscious thought, and complex language.","In the field of computing, pattern recognition tasks are increasingly challenging. Ever larger volumes of data are transmitted between computers, and the number of patterns that users wish to identify is increasing. For example, spam or malware are often detected by searching for patterns in a data stream, e.g., particular phrases or pieces of code. The number of patterns increases with the variety of spam and malware, as new patterns may be implemented to search for new variants. Searching a data stream for each of these patterns can form a computing bottleneck. Often, as the data stream is received, it is searched for each pattern, one at a time. The delay before the system is ready to search the next portion of the data stream increases with the number of patterns. Thus, pattern recognition may slow the receipt of data.","Hardware has been designed to search a data stream for patterns, but this hardware often is unable to process adequate amounts of data in an amount of time given. Some devices configured to search a data stream do so by distributing the data stream among a plurality of circuits. The circuits each determine whether the data stream matches a portion of a pattern. Often, a large number of circuits operate in parallel, each searching the data stream at generally the same time. However, there has not been a system that effectively allows for performing pattern recognition in a manner more comparable to that of a biological brain. Development of such a system is desirable.","Turning now to the figures,  illustrates an embodiment of a processor-based system, generally designated by reference numeral . The system  may be any of a variety of types such as a desktop computer, laptop computer, pager, cellular phone, personal organizer, portable audio player, control circuit, camera, etc. The system  may also be a network node, such as a router, a server, or a client (e.g., one of the previously-described types of computers). The system  may be some other sort of electronic device, such as a copier, a scanner, a printer, a game console, a television, a set-top video distribution or recording system, a cable box, a personal digital media player, a factory automation system, an automotive computer system, or a medical device. (The terms used to describe these various examples of systems, like many of the other terms used herein, may share some referents and, as such, should not be construed narrowly in virtue of the other items listed.)","In a typical processor-based device, such as the system , a processor , such as a microprocessor, controls the processing of system functions and requests in the system . Further, the processor  may comprise a plurality of processors that share system control. The processor  may be coupled directly or indirectly to each of the elements in the system , such that the processor  controls the system  by executing instructions that may be stored within the system  or external to the system .","In accordance with the embodiments described herein, the system  includes a state machine engine , which may operate under control of the processor . The state machine engine  may employ any one of a number of state machine architectures, including, but not limited to Mealy architectures, Moore architectures, Finite State Machines (FSMs), Deterministic FSMs (DFSMs), Bit-Parallel State Machines (BPSMs), etc. Though a variety of architectures may be used, for discussion purposes, the application refers to FSMs. However, those skilled in the art will appreciate that the described techniques may be employed using any one of a variety of state machine architectures.","As discussed further below, the state machine engine  may include a number of (e.g., one or more) finite state machine (FSM) lattices. Each FSM lattice may include multiple FSMs that each receive and analyze the same data in parallel. Further, the FSM lattices may be arranged in groups (e.g., clusters), such that clusters of FSM lattices may analyze the same input data in parallel. Further, clusters of FSM lattices of the state machine engine  may be arranged in a hierarchical structure wherein outputs from state machine lattices on a lower level of the hierarchical structure may be used as inputs to state machine lattices on a higher level. By cascading clusters of parallel FSM lattices of the state machine engine  in series through the hierarchical structure, increasingly complex patterns may be analyzed (e.g., evaluated, searched, etc.).","Further, based on the hierarchical parallel configuration of the state machine engine , the state machine engine  can be employed for pattern recognition in systems that utilize high processing speeds. For instance, embodiments described herein may be incorporated in systems with processing speeds of 1 GByte\/sec. Accordingly, utilizing the state machine engine , data from high speed memory devices or other external devices may be rapidly analyzed for various patterns. The state machine engine  may analyze a data stream according to several criteria, and their respective search terms, at about the same time, e.g., during a single device cycle. Each of the FSM lattices within a cluster of FSMs on a level of the state machine engine  may each receive the same search term from the data stream at about the same time, and each of the parallel FSM lattices may determine whether the term advances the state machine engine  to the next state in the processing criterion. The state machine engine  may analyze terms according to a relatively large number of criteria, e.g., more than 100, more than 110, or more than 10,000. Because they operate in parallel, they may apply the criteria to a data stream having a relatively high bandwidth, e.g., a data stream of greater than or generally equal to 1 GByte\/sec, without slowing the data stream.","In one embodiment, the state machine engine  may be configured to recognize (e.g., detect) a great number of patterns in a data stream. For instance, the state machine engine  may be utilized to detect a pattern in one or more of a variety of types of data streams that a user or other entity might wish to analyze. For example, the state machine engine  may be configured to analyze a stream of data received over a network, such as packets received over the Internet or voice or data received over a cellular network. In one example, the state machine engine  may be configured to analyze a data stream for spam or malware. The data stream may be received as a serial data stream, in which the data is received in an order that has meaning, such as in a temporally, lexically, or semantically significant order. Alternatively, the data stream may be received in parallel or out of order and, then, converted into a serial data stream, e.g., by reordering packets received over the Internet. In some embodiments, the data stream may present terms serially, but the bits expressing each of the terms may be received in parallel. The data stream may be received from a source external to the system , or may be formed by interrogating a memory device, such as the memory , and forming the data stream from data stored in the memory . In other examples, the state machine engine  may be configured to recognize a sequence of characters that spell a certain word, a sequence of genetic base pairs that specify a gene, a sequence of bits in a picture or video file that form a portion of an image, a sequence of bits in an executable file that form a part of a program, or a sequence of bits in an audio file that form a part of a song or a spoken phrase. The stream of data to be analyzed may include multiple bits of data in a binary format or other formats, e.g., base ten, ASCII, etc. The stream may encode the data with a single digit or multiple digits, e.g., several binary digits.","As will be appreciated, the system  may include memory . The memory  may include volatile memory, such as Dynamic Random Access Memory (DRAM), Static Random Access Memory (SRAM), Synchronous DRAM (SDRAM), Double Data Rate DRAM (DDR SDRAM), DDR2 SDRAM, DDR3 SDRAM, etc. The memory  may also include non-volatile memory, such as read-only memory (ROM), PC-RAM, silicon-oxide-nitride-oxide-silicon (SONOS) memory, metal-oxide-nitride-oxide-silicon (MONOS) memory, polysilicon floating gate based memory, and\/or other types of flash memory of various architectures (e.g., NAND memory, NOR memory, etc.) to be used in conjunction with the volatile memory. The memory  may include one or more memory devices, such as DRAM devices, that may provide data to be analyzed by the state machine engine . Such devices may be referred to as or include solid state drives (SSD's), MultimediaMediaCards (MMC's), SecureDigital (SD) cards, CompactFlash (CF) cards, or any other suitable device. Further, it should be appreciated that such devices may couple to the system  via any suitable interface, such as Universal Serial Bus (USB), Peripheral Component Interconnect (PCI), PCI Express (PCI-E), Small Computer System Interface (SCSI), IEEE 1394 (Firewire), or any other suitable interface. To facilitate operation of the memory , such as the flash memory devices, the system  may include a memory controller (not illustrated). As will be appreciated, the memory controller may be an independent device or it may be integral with the processor . Additionally, the system  may include an external storage , such as a magnetic storage device. The external storage may also provide input data to the state machine engine .","The system  may include a number of additional elements. For instance, a complier  may be used to program the state machine engine , as described in more detail with regard to . An input device  may also be coupled to the processor  to allow a user to input data into the system . For instance, an input device  may be used to input data into the memory  for later analysis by the state machine engine . The input device  may include buttons, switching elements, a keyboard, a light pen, a stylus, a mouse, and\/or a voice recognition system, for instance. An output device , such as a display may also be coupled to the processor . The display  may include an LCD, a CRT, LEDs, and\/or an audio display, for example. They system may also include a network interface device , such as a Network Interface Card (NIC), for interfacing with a network, such as the Internet. As will be appreciated, the system  may include many other components, depending on the application of the system .",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 2-5","b":["30","30","32","32"]},"The programmable elements can be programmed to implement many different functions. For instance, the programmable elements may include state machine elements (SMEs) ,  (shown in ) that are hierarchically organized into rows  (shown in ) and blocks  (shown in ). To route signals between the hierarchically organized SMEs , , a hierarchy of programmable switching elements can be used, including inter-block switching elements  (shown in ), intra-block switching elements  (shown in ) and intra-row switching elements  (shown in ).","As described below, the switching elements may include routing structures and buffers. A SME ,  can correspond to a state of a FSM implemented by the FSM lattice . The SMEs ,  can be coupled together by using the programmable switching elements as described below. Accordingly, a FSM can be implemented on the FSM lattice  by programming the SMEs ,  to correspond to the functions of states and by selectively coupling together the SMEs ,  to correspond to the transitions between states in the FSM.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2","b":["30","30","32","40","40","46","48","50","48","50","40","48","32","50","40","32","52","32","32","54","32","30","30","56","30","34","36","34","36","52","34","36","52"]},"In an example, the input block , the output block , and\/or the programming interface  can be implemented as registers such that writing to or reading from the registers provides data to or from the respective elements. Accordingly, bits from the image stored in the registers corresponding to the programming interface  can be loaded on the SMEs , . Although  illustrates a certain number of conductors (e.g., wire, trace) between a block , input block , output block , and an inter-block switching element , it should be understood that in other examples, fewer or more conductors may be used.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 3","b":["32","32","38","42","38","38","32","40","38","34","36","60","32","38"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 4","FIG. 5"],"b":["38","60","60","58","38","44","60","60","38","42","60","32","40","60","62","64","66","62","34","60","62","34","60"]},"In an example, the row  includes a first and second plurality of row interconnection conductors , . In an example, an input ,  of a GOT  can be coupled to one or more row interconnection conductors , , and an output  can be coupled to one row interconnection conductor , . In an example, a first plurality of the row interconnection conductors  can be coupled to each SME ,  of each GOT  within the row . A second plurality of the row interconnection conductors  can be coupled to only one SME ,  of each GOT  within the row , but cannot be coupled to the other SME , of the GOT . In an example, a first half of the second plurality of row interconnection conductors  can couple to first half of the SMEs ,  within a row  (one SME  from each GOT ) and a second half of the second plurality of row interconnection conductors  can couple to a second half of the SMEs , within a row  (the other SME , from each GOT ), as will be better illustrated with respect to . The limited connectivity between the second plurality of row interconnection conductors  and the SMEs ,  is referred to herein as \u201cparity\u201d. In an example, the row  can also include a special purpose element  such as a counter, a programmable Boolean logic element, look-up table, RAM, a field programmable gate array (FPGA), an application specific integrated circuit (ASIC), a programmable processor (e.g., a microprocessor), or other element for performing a special purpose function.","In an example, the special purpose element  comprises a counter (also referred to herein as counter ). In an example, the counter  comprises a 12-bit programmable down counter. The 12-bit programmable counter  has a counting input, a reset input, and zero-count output. The counting input, when asserted, decrements the value of the counter  by one. The reset input, when asserted, causes the counter  to load an initial value from an associated register. For the 12-bit counter , up to a 12-bit number can be loaded in as the initial value. When the value of the counter  is decremented to zero (0), the zero-count output is asserted. The counter  also has at least two modes, pulse and hold. When the counter  is set to pulse mode, the zero-count output is asserted during the clock cycle when the counter  decrements to zero, and at the next clock cycle the zero-count output is no longer asserted. When the counter  is set to hold mode the zero-count output is asserted during the clock cycle when the counter  decrements to zero, and stays asserted until the counter  is reset by the reset input being asserted.","In another example, the special purpose element  comprises Boolean logic. In some examples, this Boolean logic can be used to extract information from terminal state SMEs (corresponding to terminal nodes of a FSM, as discussed later herein) in FSM lattice . The information extracted can be used to transfer state information to other FSM lattices  and\/or to transfer programming information used to reprogram FSM lattice , or to reprogram another FSM lattice .",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 5","b":["60","60","34","36","62","64","72","74","76","78","78","66","60","34","36","76","76","72","74","66","60","34","36","62","34","68","64","36","70","34","36","60","79","34","36","72","74","34","36","62","64","34","36","34","36","72","74","62","64","72","34","62","34","64","36"]},"In an example, a state machine element ,  comprises a plurality of memory cells , such as those often used in dynamic random access memory (DRAM), coupled in parallel to a detect line . One such memory cell  comprises a memory cell that can be set to a data state, such as one that corresponds to either a high or a low value (e.g., a 1 or 0). The output of the memory cell  is coupled to the detect line  and the input to the memory cell  receives signals based on data on the data stream line . In an example, an input on the data stream line  is decoded to select one of the memory cells . The selected memory cell  provides its stored data state as an output onto the detect line . For example, the data received at the input block  can be provided to a decoder (not shown) and the decoder can select one of the data stream lines . In an example, the decoder can convert an 8-bit ACSII character to the corresponding 1 of 256 data stream lines .","A memory cell , therefore, outputs a high signal to the detect line  when the memory cell  is set to a high value and the data on the data stream line  corresponds to the memory cell . When the data on the data stream line  corresponds to the memory cell  and the memory cell  is set to a low value, the memory cell  outputs a low signal to the detect line . The outputs from the memory cells  on the detect line  are sensed by a detection cell .","In an example, the signal on an input line ,  sets the respective detection cell  to either an active or inactive state. When set to the inactive state, the detection cell  outputs a low signal on the respective output ,  regardless of the signal on the respective detect line . When set to an active state, the detection cell  outputs a high signal on the respective output line ,  when a high signal is detected from one of the memory cells  of the respective SME , . When in the active state, the detection cell  outputs a low signal on the respective output line ,  when the signals from all of the memory cells  of the respective SME ,  are low.","In an example, an SME ,  includes 256 memory cells  and each memory cell  is coupled to a different data stream line . Thus, an SME ,  can be programmed to output a high signal when a selected one or more of the data stream lines  have a high signal thereon. For example, the SME  can have a first memory cell  (e.g., bit ) set high and all other memory cells  (e.g., bits -) set low. When the respective detection cell  is in the active state, the SME  outputs a high signal on the output  when the data stream line  corresponding to bit  has a high signal thereon. In other examples, the SME  can be set to output a high signal when one of multiple data stream lines  have a high signal thereon by setting the appropriate memory cells  to a high value.","In an example, a memory cell  can be set to a high or low value by reading bits from an associated register. Accordingly, the SMEs  can be programmed by storing an image created by the compiler  into the registers and loading the bits in the registers into associated memory cells . In an example, the image created by the compiler  includes a binary image of high and low (e.g., 1 and 0) bits. The image can program the FSM lattice  to operate as a FSM by cascading the SMEs , . For example, a first SME  can be set to an active state by setting the detection cell  to the active state. The first SME  can be set to output a high signal when the data stream line  corresponding to bit  has a high signal thereon. The second SME  can be initially set to an inactive state, but can be set to, when active, output a high signal when the data stream line  corresponding to bit  has a high signal thereon. The first SME  and the second SME  can be cascaded by setting the output  of the first SME  to couple to the input  of the second SME . Thus, when a high signal is sensed on the data stream line  corresponding to bit , the first SME  outputs a high signal on the output  and sets the detection cell  of the second SME  to an active state. When a high signal is sensed on the data stream line  corresponding to bit , the second SME  outputs a high signal on the output  to activate another SME  or for output from the FSM lattice .","In an example, a single FSM lattice  is implemented on a single physical device, however, in other examples two or more FSM lattices  can be implemented on a single physical device (e.g., physical chip). In an example, each FSM lattice  can include a distinct data input block , a distinct output block , a distinct programming interface , and a distinct set of programmable elements. Moreover, each set of programmable elements can react (e.g., output a high or low signal) to data at their corresponding data input block . For example, a first set of programmable elements corresponding to a first FSM lattice  can react to the data at a first data input block  corresponding to the first FSM lattice . A second set of programmable elements corresponding to a second FSM lattice  can react to a second data input block  corresponding to the second FSM lattice . Accordingly, each FSM lattice  includes a set of programmable elements, wherein different sets of programmable elements can react to different input data. Similarly, each FSM lattice , and each corresponding set of programmable elements can provide a distinct output. In some examples, an output block  from a first FSM lattice  can be coupled to an input block  of a second FSM lattice , such that input data for the second FSM lattice  can include the output data from the first FSM lattice  in a hierarchical arrangement of a series of FSM lattices .","In an example, an image for loading onto the FSM lattice  comprises a plurality of bits of information for configuring the programmable elements, the programmable switching elements, and the special purpose elements within the FSM lattice . In an example, the image can be loaded onto the FSM lattice  to program the FSM lattice  to provide a desired output based on certain inputs. The output block  can provide outputs from the FSM lattice  based on the reaction of the programmable elements to data at the data input block . An output from the output block  can include a single bit indicating a match of a given pattern, a word comprising a plurality of bits indicating matches and non-matches to a plurality of patterns, and a state vector corresponding to the state of all or certain programmable elements at a given moment. As described, a number of FSM lattices  may be included in a state machine engine, such as state machine engine , to perform data analysis, such as pattern-recognition (e.g., speech recognition, image recognition, etc.) signal processing, imaging, computer vision, cryptography, and others.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 6","b":["30","30","90","92","92","94","96","92","94","98","92","94","96","98"]},"Each of the nodes , ,  can be in either an active or an inactive state. When in the inactive state, a node , ,  does not react (e.g., respond) to input data. When in an active state, a node , ,  can react to input data. An upstream node ,  can react to the input data by activating a node ,  that is downstream from the node when the input data matches criteria specified by an edge  between the upstream node ,  and the downstream node , . For example, a first node  that specifies the character \u2018b\u2019 will activate a second node  connected to the first node  by an edge  when the first node  is active and the character \u2018b\u2019 is received as input data. As used herein, \u201cupstream\u201d refers to a relationship between one or more nodes, where a first node that is upstream of one or more other nodes (or upstream of itself in the case of a loop or feedback configuration) refers to the situation in which the first node can activate the one or more other nodes (or can activate itself in the case of a loop). Similarly, \u201cdownstream\u201d refers to a relationship where a first node that is downstream of one or more other nodes (or downstream of itself in the case of a loop) can be activated by the one or more other nodes (or can be activated by itself in the case of a loop). Accordingly, the terms \u201cupstream\u201d and \u201cdownstream\u201d are used herein to refer to relationships between one or more nodes, but these terms do not preclude the use of loops or other non-linear paths among the nodes.","In the diagram , the root node  can be initially activated and can activate downstream nodes  when the input data matches an edge  from the root node . Nodes  can activate nodes  when the input data matches an edge  from the node . Nodes ,  throughout the diagram  can be activated in this manner as the input data is received. A terminal node  corresponds to a match of a sequence of interest by the input data. Accordingly, activation of a terminal node  indicates that a sequence of interest has been received as the input data. In the context of the FSM lattice  implementing a pattern recognition function, arriving at a terminal node  can indicate that a specific pattern of interest has been detected in the input data.","In an example, each root node , standard node , and terminal node  can correspond to a programmable element in the FSM lattice . Each edge  can correspond to connections between the programmable elements. Thus, a standard node  that transitions to (e.g., has an edge  connecting to) another standard node  or a terminal node  corresponds to a programmable element that transitions to (e.g., provides an output to) another programmable element. In some examples, the root node  does not have a corresponding programmable element.","When the FSM lattice  is programmed, each of the programmable elements can also be in either an active or inactive state. A given programmable element, when inactive, does not react to the input data at a corresponding data input block . An active programmable element can react to the input data at the data input block , and can activate a downstream programmable element when the input data matches the setting of the programmable element. When a programmable element corresponds to a terminal node , the programmable element can be coupled to the output block  to provide an indication of a match to an external device.","An image loaded onto the FSM lattice  via the programming interface  can configure the programmable elements and special purpose elements, as well as the connections between the programmable elements and special purpose elements, such that a desired FSM is implemented through the sequential activation of nodes based on reactions to the data at the data input block . In an example, a programmable element remains active for a single data cycle (e.g., a single character, a set of characters, a single clock cycle) and then becomes inactive unless re-activated by an upstream programmable element.","A terminal node  can be considered to store a compressed history of past events. For example, the one or more patterns of input data required to reach a terminal node  can be represented by the activation of that terminal node . In an example, the output provided by a terminal node  is binary, that is, the output indicates whether the pattern of interest has been matched or not. The ratio of terminal nodes  to standard nodes  in a diagram  may be quite small. In other words, although there may be a high complexity in the FSM, the output of the FSM may be small by comparison.","In an example, the output of the FSM lattice  can comprise a state vector. The state vector comprises the state (e.g., activated or not activated) of programmable elements of the FSM lattice . In an example, the state vector includes the states for the programmable elements corresponding to terminal nodes . Thus, the output can include a collection of the indications provided by all terminal nodes  of a diagram . The state vector can be represented as a word, where the binary indication provided by each terminal node  comprises one bit of the word. This encoding of the terminal nodes  can provide an effective indication of the detection state (e.g., whether and what sequences of interest have been detected) for the FSM lattice . In another example, the state vector can include the state of all or a subset of the programmable elements whether or not the programmable elements corresponds to a terminal node .","As mentioned above, the FSM lattice  can be programmed to implement a pattern recognition function. For example, the FSM lattice  can be configured to recognize one or more data sequences (e.g., signatures, patterns) in the input data. When a data sequence of interest is recognized by the FSM lattice , an indication of that recognition can be provided at the output block . In an example, the pattern recognition can recognize a string of symbols (e.g., ASCII characters) to; for example, identify malware or other information in network data.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 7","b":["100","30","100","30","30","30","52","56","54"]},"The first FSM lattice A is configured to receive input data, for example, raw data at a data input block. The first FSM lattice A reacts to the input data as described above and provides an output at an output block. The output from the first FSM lattice A is sent to a data input block of the second FSM lattice B. The second FSM lattice B can then react based on the output provided by the first FSM lattice A and provide a corresponding output signal  of the hierarchical structure . This hierarchical coupling of two FSM lattices A and B in series provides a means to transfer information regarding past events in a compressed word from a first FSM lattice A to a second FSM lattice B. The information transferred can effectively be a summary of complex events (e.g., sequences of interest) that were recorded by the first FSM lattice A.","The two-level hierarchy  of FSM lattices A, B shown in  allows two independent programs to operate based on the same data stream. The two-stage hierarchy can be similar to visual recognition in a biological brain which is modeled as different regions. Under this model, the regions are effectively different pattern recognition engines, each performing a similar computational function (pattern matching) but using different programs (signatures). By connecting multiple FSM lattices A, B together, increased knowledge about the data stream input may be obtained.","The first level of the hierarchy (implemented by the first FSM lattice A) can, for example, perform processing directly on a raw data stream. That is, a raw data stream can be received at an input block  of the first FSM lattice A and the programmable elements of the first FSM lattice A can react to the raw data stream. The second level (implemented by the second FSM lattice B) of the hierarchy can process the output from the first level. That is, the second FSM lattice B receives the output from an output block  of the first FSM lattice A at an input block  of the second FSM lattice B and the programmable elements of the second FSM lattice B can react to the output of the first FSM lattice A. Accordingly, in this example, the second FSM lattice B does not receive the raw data stream as an input, but rather receives the indications of patterns of interest that are matched by the raw data stream as determined by the first FSM lattice A. The second FSM lattice B can implement a FSM that recognizes patterns in the output data stream from the first FSM lattice A.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 8","b":["110","30","110","112","114","116","118","120","122","124"]},"In an example, the compiler  includes an application programming interface (API) that allows software developers to create images for implementing FSMs on the FSM lattice . The compiler  provides methods to convert an input set of regular expressions in the source code into an image that is configured to program the FSM lattice . The compiler  can be implemented by instructions for a computer having a von Neumann architecture. These instructions can cause a processor  on the computer to implement the functions of the compiler . For example, the instructions, when executed by the processor , can cause the processor  to perform actions as described in blocks , , , , , , and  on source code that is accessible to the processor .","In an example, the source code describes search strings for identifying patterns of symbols within a group of symbols. To describe the search strings, the source code can include a plurality of regular expressions (regexs). A regex can be a string for describing a symbol search pattern. Regexes are widely used in various computer domains, such as programming languages, text editors, network security, and others. In an example, the regular expressions supported by the compiler include criteria for the analysis of unstructured data. Unstructured data can include data that is free form and has no indexing applied to words within the data. Words can include any combination of bytes, printable and non-printable, within the data. In an example, the compiler can support multiple different source code languages for implementing regexes including Perl, (e.g., Perl compatible regular expressions (PCRE)), PHP, Java, and .NET languages.","At block  the compiler  can parse the source code to form an arrangement of relationally connected operators, where different types of operators correspond to different functions implemented by the source code (e.g., different functions implemented by regexes in the source code). Parsing source code can create a generic representation of the source code. In an example, the generic representation comprises an encoded representation of the regexs in the source code in the form of a tree graph known as a syntax tree. The examples described herein refer to the arrangement as a syntax tree (also known as an \u201cabstract syntax tree\u201d) in other examples, however, a concrete syntax tree or other arrangement can be used.","Since, as mentioned above, the compiler  can support multiple languages of source code, parsing converts the source code, regardless of the language, into a non-language specific representation, e.g., a syntax tree. Thus, further processing (blocks , , , ) by the compiler  can work from a common input structure regardless of the language of the source code.","As noted above, the syntax tree includes a plurality of operators that are relationally connected. A syntax tree can include multiple different types of operators. That is, different operators can correspond to different functions implemented by the regexes in the source code.","At block , the syntax tree is converted into an automaton. An automaton comprises a software model of a FSM and can accordingly be classified as deterministic or non-deterministic. A deterministic automaton has a single path of execution at a given time, while a non-deterministic automaton has multiple concurrent paths of execution. The automaton comprises a plurality of states. In order to convert the syntax tree into an automaton, the operators and relationships between the operators in the syntax tree are converted into states with transitions between the states. In an example, the automaton can be converted based partly on the hardware of the FSM lattice .","In an example, input symbols for the automaton include the symbols of the alphabet, the numerals 0-9, and other printable characters. In an example, the input symbols are represented by the byte values 0 through 255 inclusive. In an example, an automaton can be represented as a directed graph where the nodes of the graph correspond to the set of states. In an example, a transition from state p to state q on an input symbol \u03b1, i.e. \u03b4(p,\u03b1), is shown by a directed connection from node p to node q. In an example, a reversal of an automaton produces a new automaton where each transition p\u2192q on some symbol \u03b1 is reversed q\u2192p on the same symbol. In a reversal, start state becomes a final state and the final states become start states. In an example, the language recognized (e.g., matched) by an automaton is the set of all possible character strings which when input sequentially into the automaton will reach a final state. Each string in the language recognized by the automaton traces a path from the start state to one or more final states.","At block , after the automaton is constructed, the automaton is optimized to, among other things, reduce its complexity and size. The automaton can be optimized by combining redundant states.","At block , the optimized automaton is converted into a netlist. Converting the automaton into a netlist maps each state of the automaton to a hardware element (e.g., SMEs , , other elements) on the FSM lattice , and determines the connections between the hardware elements.","At block , the netlist is placed to select a specific hardware element of the target device (e.g., SMEs , , special purpose elements ) corresponding to each node of the netlist. In an example, placing selects each specific hardware element based on general input and output constraints for of the FSM lattice .","At block , the placed netlist is routed to determine the settings for the programmable switching elements (e.g., inter-block switching elements , intra-block switching elements , and intra-row switching elements ) in order to couple the selected hardware elements together to achieve the connections describe by the netlist. In an example, the settings for the programmable switching elements are determined by determining specific conductors of the FSM lattice  that will be used to connect the selected hardware elements, and the settings for the programmable switching elements. Routing can take into account more specific limitations of the connections between the hardware elements that placement at block . Accordingly, routing may adjust the location of some of the hardware elements as determined by the global placement in order to make appropriate connections given the actual limitations of the conductors on the FSM lattice .","Once the netlist is placed and routed, the placed and routed netlist can be converted into a plurality of bits for programming of a FSM lattice . The plurality of bits are referred to herein as an image.","At block , an image is published by the compiler . The image comprises a plurality of bits for programming specific hardware elements of the FSM lattice . In embodiments where the image comprises a plurality of bits (e.g., 0 and 1), the image can be referred to as a binary image. The bits can be loaded onto the FSM lattice  to program the state of SMEs , , the special purpose elements , and the programmable switching elements such that the programmed FSM lattice  implements a FSM having the functionality described by the source code. Placement (block ) and routing (block ) can map specific hardware elements at specific locations in the FSM lattice  to specific states in the automaton. Accordingly, the bits in the image can program the specific hardware elements to implement the desired function(s). In an example, the image can be published by saving the machine code to a computer readable medium. In another example, the image can be published by displaying the image on a display device. In still another example, the image can be published by sending the image to another device, such as a programming device for loading the image onto the FSM lattice . In yet another example, the image can be published by loading the image onto a FSM lattice (e.g., the FSM lattice ).","In an example, an image can be loaded onto the FSM lattice  by either directly loading the bit values from the image to the SMEs ,  and other hardware elements or by loading the image into one or more registers and then writing the bit values from the registers to the SMEs ,  and other hardware elements. In an example, the hardware elements (e.g., SMEs , , special purpose elements , programmable switching elements , , ) of the FSM lattice  are memory mapped such that a programming device and\/or computer can load the image onto the FSM lattice  by writing the image to one or more memory addresses.","Method examples described herein can be machine or computer-implemented at least in part. Some examples can include a computer-readable medium or machine-readable medium encoded with instructions operable to configure an electronic device to perform methods as described in the above examples. An implementation of such methods can include code, such as microcode, assembly language code, a higher-level language code, or the like. Such code can include computer readable instructions for performing various methods. The code may form portions of computer program products. Further, the code may be tangibly stored on one or more volatile or non-volatile computer-readable media during execution or at other times. These computer-readable media may include, but are not limited to, hard disks, removable magnetic disks, removable optical disks (e.g., compact disks and digital video disks), magnetic cassettes, memory cards or sticks, random access memories (RAMs), read only memories (ROMs), and the like.","Referring now to , an embodiment of the state machine engine  is illustrated. As previously described, the state machine engine  is configured to receive data from a source, such as the memory  over a data bus. In the illustrated embodiment, data may be sent to the state machine engine  through a bus interface, such as a DDR3 bus interface . The DDR3 bus interface  may be capable of exchanging data at a rate greater than or equal to 1 GByte\/sec. As will be appreciated, depending on the source of the data to be analyzed, the bus interface  may be any suitable bus interface for exchanging data to and from a data source to the state machine engine , such as a NAND Flash interface, PCI interface, etc. As previously described, the state machine engine  includes one or more FSM lattices  configured to analyze data. Each FSM lattice  may be divided into two half-lattices. In the illustrated embodiment, each half lattice may include 24K SMEs (e.g., SMEs , ), such that the lattice  includes 48K SMEs. The lattice  may comprise any desirable number of SMEs, arranged as previously described with regard to . Further, while only one FSM lattice  is illustrated, the state machine engine  may include multiple FSM lattices , as previously described.","Data to be analyzed may be received at the bus interface  and transmitted to the FSM lattice  through a number of buffers and buffer interfaces. In the illustrated embodiment, the data path includes data buffers , process buffers  and an inter-rank (IR) bus and process buffer interface . The data buffers  are configured to receive and temporarily store data to be analyzed. In one embodiment, there are two data buffers  (data buffer A and data buffer B). Data may be stored in one of the two data buffers , while data is being emptied from the other data buffer , for analysis by the FSM lattice . In the illustrated embodiment, the data buffers  may be 32 KBytes each. The IR bus and process buffer interface  may facilitate the transfer of data to the process buffer . The IR bus and process buffer  ensures that data is processed by the FSM lattice  in order. The IR bus and process buffer  may coordinate the exchange of data, timing information, packing instructions, etc. such that data is received and analyzed in the correct order. Generally, the IR bus and process buffer  allows the analyzing of multiple data sets in parallel through logical ranks of FSM lattices .","In the illustrated embodiment, the state machine engine  also includes a de-compressor  and a compressor  to aid in the transfer of the large amounts of data through the state machine engine . The compressor  and de-compressor  work in conjunction such that data can be compressed to minimize the data transfer times. By compressing the data to be analyzed, the bus utilization time may be minimized. Based on information provided by the compiler , a mask may be provided to the state machine engine  to provide information on which state machines are likely to be unused. The compressor  and de-compressor  can also be configured to handle data of varying burst lengths. By padding compressed data and including an indicator as to when each compressed region ends, the compressor  may improve the overall processing speed through the state machine engine . The compressor  and de-compressor  may also be used to compress and decompress match results data after analysis by the FSM lattice .","As previously described, the output of the FSM lattice  can comprise a state vector. The state vector comprises the state (e.g., activated or not activated) of programmable elements of the FSM lattice . Each state vector may be temporarily stored in the state vector cache memory  for further hierarchical processing and analysis. That is, the state of each state machine may be stored, such that the final state may be used in further analysis, while freeing the state machines for reprogramming and\/or further analysis of a new data set. Like a typical cache, the state vector cache memory allows storage of information, here state vectors, for quick retrieval and use, here by the FSM lattice , for instance. Additional buffers, such as the state vector memory buffer, state vector intermediate input buffer  and state vector intermediate output buffer , may be utilized in conjunction with the state vector cache memory  to accommodate rapid analysis and storage of state vectors, while adhering to packet transmission protocol through the state machine engine .","Once a result of interest is produced by the FSM lattice , match results may be stored in a match results memory . That is, a \u201cmatch vector\u201d indicating a match (e.g., detection of a pattern of interest) may be stored in the match results memory . The match result can then be sent to a match buffer  for transmission over the bus interface  to the processor , for example. As previously described, the match results may be compressed.","Additional registers and buffers may be provided in the state machine engine , as well. For instance, the state machine engine  may include control and status registers . In addition, restore and program buffers  may be provided for using in programming the FSM lattice  initially, or restoring the state of the machines in the FSM lattice  during analysis. Similarly, save and repair map buffers  may also be provided for storage of save and repair maps for setup and usage.",{"@attributes":{"id":"p-0081","num":"0080"},"figref":["FIG. 10","FIG. 4"],"b":["38","38","44","68","70"]},"Row  of  may include eight GOTS , a special purpose element , inputs , inputs , outputs , a match element , a plurality of row routing lines , , , , , , , , , , , , , , , and  (collectively referred to hereafter as \u201crow routing lines -\u201d), a special purpose element routing line , and a plurality of junction points .","Furthermore, in addition to being coupled to the illustrated SMEs ,  in , the local routing matrix  may be coupled to all pairs of SMEs ,  for the GOTs  in a particular row . Accordingly, the local routing matrix  may include programmable intra-row switching elements  and row interconnection\/interconnect conductors ,  (which can also be referred to as \u201crow routing lines\u201d, as described below).","The GOTS  and the special purpose element  illustrated in  are substantially similar to the GOTS  and the special purpose element  previously discussed with respect to . Accordingly, each GOT  receives an input , which may be a unified enable input, to operate as an enable signal for a detection cell  of a SME . Likewise, each GOT  also receives an input , which may also be a unified enable input, to operate as an enable signal for a detection cell  of a SME . These unified enable inputs ,  may activate the detection cells  of the SMEs ,  to output a respective result of an analysis performed by the respective SME, for example, a match in an analyzed data stream from a single SME , which may be utilized in conjunction with results from other SMEs ,  to, for example, search for a pattern in a data stream. For example, unified enable input  and unified enable input  allow for selective activation of the SMEs ,  so that results generated by each of the active SMEs ,  may be utilized as part of an overall broader analysis of a data stream.","The result generated by an SME ,  of a GOT  may be selectively provided from the GOT on output . In one embodiment, the possible outputs of the GOT  may include no output, an output of the first SME , i.e., output , an output of the second SME , i.e., output , or the output of the first SME  or the output of the second SME , i.e., output  or output . Thus, a GOT  may be programmed to output a selected result from a GOT . This programming may be accomplished, for example, based on a loaded image performed during an initial programming stage of the FSM lattice . Results from the GOTs  may be provided to a match element , which may operate to output a selected result generated from the row  for a given data stream search or a portion of a data stream search.","Additionally, row  may include row routing lines - (which may also be referred to as row interconnection\/interconnect conductors). In the present embodiment, there are sixteen row lines - that are selectively coupleable to eight GOTS  and to the special purpose element . However, it should be appreciated that fewer or more row routing lines may be utilized in conjunction with the row .","Each of the row routing lines - may be utilized to provide enable signals for any of the SMEs ,  of one or more GOTS  along inputs , . Accordingly, through use of these row routing lines -, any particular detection cell  for any particular SME (e.g., SME ) may be activated. This may be accomplished by selectively coupling (e.g., in accordance with a loaded image) the row routing lines - to unified enable inputs ,  of the SMEs , . Moreover, to provide further flexibility in providing enable signals to the SMEs , , the row routing lines - may be divided up amongst two SMEs ,  of a given GOT . For example, row routing lines , , , , , , , and , may be utilized to activate any of the SMEs ,  in the row . For example, a GOT  may transmit an output  to the row routing line coupled thereto, for example, row routing line . This signal may be transmitted into the intra-block switch, where it may be routed, for example, on row routing line  to an additional GOT  in the row . Additionally, row routing lines , , , and  may activate SMEs  in row , for example, by receiving signals from intra-block switch , while row routing lines , , , and  may activate SMEs  in row  via, for example, signals received from the intra-block witch . In this manner, the overall number of row routing lines - may be reduced, while still allowing for overall flexibility and the ability to activate any detection cell  of any of the SMEs ,  in a row .","As illustrated in , each of the row routing lines - includes a plurality of junction points . These junction points  may, for example, include the intra-row switching elements  of , since the junction points  may be utilized to selectively couple any GOT  to any other GOT , or any GOT  to any other element (e.g., a special purpose element ) within the row  (or, for that matter, within another row and\/or another block). However, these connections may be limited by available junction points . For example, each of row routing lines , , , , , , , and , may be utilized to activate any of the SMEs ,  in the row . However, each of row routing lines , , , , , , , and  also are selectively coupleable to the output of a respective different one of the GOTs . For example, an output from any one of the GOTs  may only be provided from that GOT  on a respective one of the row routing lines , , , , , , , and  coupleable thereto. Thus, in one embodiment, because row routing lines , , , , , , , and  are coupleable to the outputs  of the GOTs , the row routing lines , , , , , , , and  may provide (e.g., drive-out) signals to the intra-block switch . In contrast, in one embodiment, row routing lines , , , , , , , and  may receive (e.g. be driven by) signals from the intra-block switch  that may be received from, for example, other rows  or blocks .","In addition to row routing lines -, the row  may include a special purpose element routing line  coupled to a special purpose element . Similar to row routing lines , , , , , , , and , the special purpose routing line  may provide (e.g., drive-out) signals to the intra-block switch . In one embodiment, the special purpose element routing line  may also be coupleable to the match element . For example, if the special purpose element  comprises a counter, an output of the counter may be provided along the special purpose routing line . Similarly, if the special purpose element  includes a Boolean logic element, such as a Boolean cell, an output of the Boolean logic element may be provided along the special purpose routing line . Through the use of these special purpose elements, repetitive searches (e.g., find an element ten times) or cascaded searches (e.g., find elements x, y, and z) may be simplified into a single output that can be provided along the special purpose routing line  to either or both of the intra-block switch  and the match element .","A more detailed illustration of the match element  is presented in . As illustrated, the match element  may include four data inputs , , , and , two outputs, and six control inputs , , , , , and . Moreover, the match element may include two 2-to-1 multiplexers , . While 2-to-1 multiplexers ,  are illustrated, it should be noted that other configurations such as a 3-to-1 multiplexer, a 4-to-1 multiplexer, or other elements may be utilized in place of the 2-to-1 multiplexers ,  as desired, for example, to allow for flexibility in routing\/output configurations or as silicon space allows.","In one embodiment, data input  of the match element  is coupled to row routing line , data input  is coupled to row routing line , data input  is coupled to special purpose routing line , and data input  is coupled to row routing line . Selection of these particular lines is illustrative only, and has been chosen to demonstrate flexibility in receiving output signals from the row . By choosing row routing line  and row routing line  as connecting to the match element , parity between the GOTs  can be established. For example, a result of a first analysis performed on at least a portion of a data stream by one GOT  in a first half of all the GOTs  (GOTs  zero through three) can be provided on routing line  to the match element  while a result of a second analysis performed on at least a portion of the data stream by another GOT  in a second half of all the GOTs  (GOTs  four through seven) can be provided on routing line  to the match element . Splitting the inputs ,  this way can allow for reduced paths to provide results to the match element . Additionally, by receiving a result from the special purpose element  along special purpose routing line  at the match element , results of cascaded searches may be provided once to the match element . Finally, selection of row routing line  adds flexibility to the overall system of the row . However, as noted, these selections are merely illustrative.","As illustrated, the data inputs ,  of the match element  may be provided to the 2-to-1 multiplexer , while the data inputs ,  of the match element  may be provided to the 2-to-1 multiplexer . The 2-to-1 multiplexers ,  may each also receive control signals from control inputs , , , , , and , which may, for example, be programmed based on a loaded image performed during an initial programming stage of the FSM lattice . In one embodiment, the 2-to-1 multiplexer  may receive a select signal S from control input , a select signal S from control input , and an output enable signal from control input . Similarly, the 2-to-1 multiplexer  may receive a select signal S from control input , a select signal S from control input , and an output enable signal from control input . The select signals S, S may be utilized to select which of the data inputs are to be provided to output  and , respectively for transmitting results of a data search to, for example, output block . Furthermore, use of multiple select lines carrying the select signals S, S may allow for each of the 2-to-1 multiplexers ,  to be built without an inverter, thus reducing the area required to implement the 2-to-1 multiplexers , . However, in one embodiment, a single select line carrying a single select signal, e.g., S, may be utilized.","Additionally, the output enable signal from control input  may be a clocking signal or other enable signal that allows for outputs  and  to be provided only when the signals on data inputs , , , and  are stable.  illustrates a truth table  that sets forth an example of how the select signal S from control input , a select signal S from control input  may programmably select the output  of the 2-to-1 multiplexer .","As shown in , a truth table  corresponding to the output  of the match element  is illustrated. It should be noted that the output  represented in the truth table  assumes that the output enable signal from control input  has been received at the 2-to-1 multiplexer . As illustrated in the truth table , when both the select signal S from control input  and the select signal S from control input  are low (i.e., 0), the output  of the 2-to-1 multiplexer  will be low. For example, no result from the row  will be provided from the match element . When the select signal S from control input  is high (i.e., 1) and the select signal S from control input  is low, the output  of the 2-to-1 multiplexer  will be the result on the row routing line . Conversely, when the select signal S from control input  is low and the select signal S from control input  is high, the output  of the 2-to-1 multiplexer  will be the result on the special purpose routing line . Finally, the condition whereby both the select signal S from control input  and the select signal S from control input  are high is forbidden. Accordingly, such a state is avoided during the programming of the match element . In this manner, match element  may programmably select no output, an output from a first data input  (the result on the row routing line ) or an output from a second data input  (the result on the special purpose routing line ). Furthermore, it should be noted that match element may operate in other programmable configurations not limited to the specific embodiment illustrated in .","While the invention may be susceptible to various modifications and alternative forms, specific embodiments have been shown by way of example in the drawings and have been described in detail herein. However, it should be understood that the invention is not intended to be limited to the particular forms disclosed. Rather, the invention is to cover all modifications, equivalents, and alternatives falling within the spirit and scope of the invention as defined by the following appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 8","FIG. 2"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 10","FIG. 3"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 11","FIG. 10"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 12","FIG. 11"]}]},"DETDESC":[{},{}]}
