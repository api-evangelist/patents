---
title: Audio wave data playback in an audio generation system
abstract: An audio generation system includes MIDI track components that generate event instructions for MIDI audio data received from a MIDI audio data source, and includes audio wave track components that generate playback instructions for audio wave data maintained in an audio wave data source. A segment component plays one or more of the MIDI track components to generate the event instructions, and plays one or more of the audio wave track components to generate the playback instructions. An audio processing component, such as a synthesizer component, receives the event instructions and the playback instructions, and generates an audio rendition corresponding to the MIDI audio data and/or the audio wave data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07126051&OS=07126051&RS=07126051
owner: Microsoft Corporation
number: 07126051
owner_city: Redmond
owner_country: US
publication_date: 20020305
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATION","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION"],"p":["This application claims the benefit of U.S. Provisional Application No. 60\/273,593, filed Mar. 5, 2001, entitled \u201cWave Playback Track in the DirectMusic Performance Architecture\u201d, to Todor Fay et al., which is incorporated by reference herein.","This invention relates to audio processing and, in particular, to audio wave data playback in an audio generation system.","Multimedia programs present content to a user through both audio and video events while a user interacts with a program via a keyboard, joystick, or other interactive input device. A user associates elements and occurrences of a video presentation with the associated audio representation. A common implementation is to associate audio with movement of characters or objects in a video game. When a new character or object appears, the audio associated with that entity is incorporated into the overall presentation for a more dynamic representation of the video presentation.","Audio representation is an essential component of electronic and multimedia products such as computer based and stand-alone video games, computer-based slide show presentations, computer animation, and other similar products and applications. As a result, audio generating devices and components are integrated into electronic and multimedia products for composing and providing graphically associated audio representations. These audio representations can be dynamically generated and varied in response to various input parameters, real-time events, and conditions. Thus, a user can experience the sensation of live audio or musical accompaniment with a multimedia experience.","Conventionally, computer audio is produced in one of two fundamentally different ways. One way is to reproduce an audio waveform from a digital sample of an audio source which is typically stored in a wave file (i.e., a .wav file). A digital sample can reproduce any sound, and the output is very similar on all sound cards, or similar computer audio rendering devices. However, a file of digital samples consumes a substantial amount of memory and resources when streaming the audio content. As a result, the variety of audio samples that can be provided using this approach is limited. Another disadvantage of this approach is that the stored digital samples cannot be easily varied.","Another way to produce computer audio is to synthesize musical instrument sounds, typically in response to instructions in a Musical Instrument Digital Interface (MIDI) file, to generate audio sound waves. MIDI is a protocol for recording and playing back music and audio on digital synthesizers incorporated with computer sound cards. Rather than representing musical sound directly, MIDI transmits information and instructions about how music is produced. The MIDI command set includes note-on, note-off, key velocity, pitch bend, and other commands to control a synthesizer.","The audio sound waves produced with a synthesizer are those already stored in a wavetable in the receiving instrument or sound card. A wavetable is a table of stored sound waves that are digitized samples of actual recorded sound. A wavetable can be stored in read-only memory (ROM) on a sound card chip, or provided with software. Prestoring sound waveforms in a lookup table improves rendered audio quality and throughput. An advantage of MIDI files is that they are compact and require few audio streaming resources, but the output is limited to the number of instruments available in the designated General MIDI set and in the synthesizer, and may sound very different on different computer systems.","MIDI instructions sent from one device to another indicate actions to be taken by the controlled device, such as identifying a musical instrument (e.g., piano, flute, drums, etc.) for music generation, turning on a note, and\/or altering a parameter in order to generate or control a sound. In this way, MIDI instructions control the generation of sound by remote instruments without the MIDI control instructions themselves carrying sound or digitized information. A MIDI sequencer stores, edits, and coordinates the MIDI information and instructions. A synthesizer connected to a sequencer generates audio based on the MIDI information and instructions received from the sequencer. Many sounds and sound effects are a combination of multiple simple sounds generated in response to the MIDI instructions.","A MIDI system allows audio and music to be represented with only a few digital samples rather than converting an analog signal to many digital samples. The MIDI standard supports different channels that can each simultaneously provide an output of audio sound wave data. There are sixteen defined MIDI channels, meaning that no more than sixteen instruments can be playing at one time. Typically, the command input for each MIDI channel represents the notes corresponding to an instrument. However, MIDI instructions can program a channel to be a particular instrument. Once programmed, the note instructions for a channel will be played or recorded as the instrument for which the channel has been programmed. During a particular piece of music, a channel can be dynamically reprogrammed to be a different instrument.","A Downloadable Sounds (DLS) standard published by the MIDI Manufacturers Association allows wavetable synthesis to be based on digital samples of audio content provided at run-time rather than stored in memory. The data describing an instrument can be downloaded to a synthesizer and then played like any other MIDI instrument. Because DLS data can be distributed as part of an application, developers can be assured that the audio content will be delivered uniformly on all computer systems. Moreover, developers are not limited in their choice of instruments.","A DLS instrument is created from one or more digital samples, typically representing single pitches, which are then modified by a synthesizer to create other pitches. Multiple samples are used to make an instrument sound realistic over a wide range of pitches. DLS instruments respond to MIDI instructions and commands just like other MIDI instruments. However, a DLS instrument does not have to belong to the General MIDI set or represent a musical instrument at all. Any sound, such as a fragment of speech or a fully composed measure of music, can be associated with a DLS instrument.","Conventional Audio and Music System",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1","b":["100","102","104","106","102","108","102","110","108","112","110","106"]},"MIDI inputs to synthesizer  are in the form of individual instructions, each of which designates the MIDI channel to which it applies. Within synthesizer , instructions associated with different channels  are processed in different ways, depending on the programming for the various channels. A MIDI input is typically a serial data stream that is parsed in synthesizer  into MIDI instructions and synthesizer control information. A MIDI command or instruction is represented as a data structure containing information about the sound effect or music piece such as the pitch, relative volume, duration, and the like.","A MIDI instruction, such as a \u201cnote-on\u201d, directs synthesizer  to play a particular note, or notes, on a synthesizer channel  having a designated instrument. The General MIDI standard defines standard sounds that can be combined and mapped into the sixteen separate instrument and sound channels. A MIDI event on a synthesizer channel  corresponds to a particular sound and can represent a keyboard key stroke, for example. The \u201cnote-on\u201d MIDI instruction can be generated with a keyboard when a key is pressed and the \u201cnote-on\u201d instruction is sent to synthesizer . When the key on the keyboard is released, a corresponding \u201cnote-off\u201d instruction is sent to stop the generation of the sound corresponding to the keyboard key.","The audio representation for a video game involving a car, from the perspective of a person in the car, can be presented for an interactive video and audio presentation. The sound effects input source  has audio data that represents various sounds that a driver in a car might hear. A MIDI formatted music piece  represents the audio of the car's stereo. Input source  also has digital audio sample inputs that are sound effects representing the car's horn , the car's tires , and the car's engine .","The MIDI formatted input  has sound effect instructions (\u2013) to generate musical instrument sounds. Instruction () designates that a guitar sound be generated on MIDI channel one () in synthesizer , instruction () designates that a bass sound be generated on MIDI channel two (), and instruction () designates that drums be generated on MIDI channel ten (). The MIDI channel assignments are designated when MIDI input  is authored, or created.","A conventional software synthesizer that translates MIDI instructions into audio signals does not support distinctly separate sets of MIDI channels. The number of sounds that can be played simultaneously is limited by the number of channels and resources available in the synthesizer. In the event that there are more MIDI inputs than there are available channels and resources, one or more inputs are suppressed by the synthesizer.","The buffers component  of audio system  includes multiple buffers (\u2013). Typically, a buffer is an allocated area of memory that temporarily holds sequential samples of audio sound wave data that will be subsequently communicated to a sound card or similar audio rendering device to produce audible sound. The output  of synthesizer mixing component  is input to buffer () in buffers component . Similarly, each of the other digital sample sources are input to a buffer  in buffers component . The car horn sound effect  is input to buffer (), the tires sound effect  is input to buffer (), and the engine sound effect  is input to buffer ().","Another problem with conventional audio generation systems is the extent to which system resources have to be allocated to support an audio representation for a video presentation. In the above example, each buffer  requires separate hardware channels, such as in a soundcard, to render the audio sound effects from input source . Further, in an audio system that supports both music and sound effects, a single stereo output pair that is input to one buffer is a limitation to creating and enhancing the music and sound effects.","Similarly, other three-dimensional (3-D) audio spatialization effects are difficult to create and require an allocation of system resources that may not be available when processing a video game that requires an extensive audio presentation. For example, to represent more than one car from a perspective of standing near a road in a video game, a pre-authored car engine sound effect  has to be stored in memory once for each car that will be represented. Additionally, a separate buffer  and separate hardware channels will need to be allocated for each representation of a car. If a computer that is processing the video game does not have the resources available to generate the audio representation that accompanies the video presentation, the quality of the presentation will be deficient.","An audio generation system includes MIDI track components that generate event instructions for MIDI audio data received from a MIDI audio data source, and includes audio wave track components that generate playback instructions for audio wave data maintained in an audio wave data source. A segment component plays one or more of the MIDI track components to generate the event instructions, and plays one or more of the audio wave track components to generate the playback instructions. An audio processing component, such as a synthesizer component, receives the event instructions and the playback instructions, and generates an audio rendition corresponding to the MIDI audio data and\/or the audio wave data.","The audio generation system can also include one or more segment states that include programming references to the MIDI track components and to the audio wave track components. A segment state initiates the segment component to play the MIDI track components and the audio track components to generate the event instructions and the playback instructions. For each of the segment states, the audio processing component generates an audio rendition corresponding to the MIDI audio data and\/or to the audio wave data.","In one embodiment, the segment component is implemented as a programming object having an interface that is callable by a performance manager to initiate that the segment component play the MIDI track components and the audio wave track components. Further, the MIDI track components and the audio wave track components are programming objects each having an interface that is callable by the segment component to initiate that the MIDI track components generate the event instructions, and to initiate that the audio wave track components generate the playback instructions.","The following describes systems and methods for audio wave data playback in an audio generation system that supports numerous computing systems' audio technologies, including technologies that are designed and implemented after a multimedia application program has been authored. An application program instantiates the components of an audio generation system to produce, or otherwise generate, audio data that can be rendered with an audio rendering device to produce audible sound.","Multiple segment tracks are implemented as needed in an audio generation system to play both audio wave data and MIDI audio data. It is preferable to implement some multimedia applications with streaming audio wave data rather than with a MIDI implementation, such as for human vocals. The dynamic playback capabilities of the audio generation systems described herein support playback integration of MIDI audio data and audio wave data. The audio generation systems utilize streaming audio wave data with MIDI based technologies.","An audio generation system includes an audio rendition manager (also referred to herein as an \u201cAudioPath\u201d) that is implemented to provide various audio data processing components that process audio data into audible sound. The audio generation system described herein simplifies the process of creating audio representations for interactive applications such as video games and Web sites. The audio rendition manager manages the audio creation process and integrates both digital audio samples and streaming audio.","Additionally, an audio rendition manager provides real-time, interactive control over the audio data processing for audio representations of video presentations. An audio rendition manager also enables 3-D audio spatialization processing for an individual audio representation of an entity's video presentation. Multiple audio renditions representing multiple video entities can be accomplished with multiple audio rendition managers, each representing a video entity, or audio renditions for multiple entities can be combined in a single audio rendition manager.","Real-time control of audio data processing components in an audio generation system is useful, for example, to control an audio representation of a video game presentation when parameters that are influenced by interactivity with the video game change, such as a video entity's 3-D positioning in response to a change in a video game scene. Other examples include adjusting audio environment reverb in response to a change in a video game scene, or adjusting music transpose in response to a change in the emotional intensity of a video game scene.","Exemplary Audio Generation System",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 2","b":["200","200"]},"Audio generation system  includes an application program , a performance manager component , and an audio rendition manager . Application program  is one of a variety of different types of applications, such as a video game program, some other type of entertainment program, or any other application that incorporates an audio representation with a video presentation.","The performance manager  and the audio rendition manager  can be instantiated, or provided, as programming objects. The application program  interfaces with the performance manager , the audio rendition manager , and the other components of the audio generation system  via application programming interfaces (APIs). For example, application program  can interface with the performance manager  via API  and with the audio rendition manager  via API .","The various components described herein, such as the performance manager  and the audio rendition manager , can be implemented using standard programming techniques, including the use of OLE (object linking and embedding) and COM (component object model) interfaces. COM objects are implemented in a system memory of a computing device, each object having one or more interfaces, and each interface having one or more methods. The interfaces and interface methods can be called by application programs and by other objects. The interface methods of the objects are executed by a processing unit of the computing device. Familiarity with object-based programming, and with COM objects in particular, is assumed throughout this disclosure. However, those skilled in the art will recognize that the audio generation systems and the various components described herein are not limited to a COM and\/or OLE implementation, or to any other specific programming technique.","The audio generation system  includes audio sources  that provide digital samples of audio data such as from a wave file (i.e., a .wav file), message-based data such as from a MIDI file or a pre-authored segment file, or an audio sample such as a Downloadable Sound (DLS). Audio sources can be also be stored as a resource component file of an application rather than in a separate file.","Application program  can initiate that an audio source  provide audio content input to performance manager . The performance manager  receives the audio content from audio sources  and produces audio instructions for input to the audio rendition manager . The audio rendition manager  receives the audio instructions and generates audio sound wave data. The audio generation system  includes audio rendering components  which are hardware and\/or software components, such as a speaker or soundcard, that renders audio from the audio sound wave data received from the audio rendition manager .",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 3","b":["204","206","300","302"]},"The audio source  has a MIDI formatted music piece  that represents the audio of a car stereo. The MIDI input  has sound effect instructions (\u2013) to generate musical instrument sounds. Instruction () designates that a guitar sound be generated on MIDI channel one () in a synthesizer component, instruction () designates that a bass sound be generated on MIDI channel two (), and instruction () designates that drums be generated on MIDI channel ten (). Input audio source  also has digital audio sample inputs that represent a car horn sound effect , a tires sound effect , and an engine sound effect .","The performance manager  can receive audio content from a wave file (i.e., .wav file), a MIDI file, or a segment file authored with an audio production application, such as DirectMusic\u00ae Producer, for example. DirectMusic\u00ae Producer is an authoring tool for creating interactive audio content and is available from Microsoft Corporation of Redmond, Washington. Additionally, performance manager  can receive audio content that is composed at run-time from different audio content components.","Performance manager  receives audio content input from input audio source  and produces audio instructions for input to the audio rendition manager . Performance manager  includes a segment component , an instruction processors component , and an output processor . The segment component  represents the audio content input from audio source . Although performance manager  is shown having only one segment , the performance manager can have a primary segment and any number of secondary segments. Multiple segments can be arranged concurrently and\/or sequentially with the performance manager .","Segment component  can be instantiated as a programming object having one or more interfaces  and associated interface methods. In the described embodiment, segment object  is an instantiation of a COM object class and represents an audio or musical piece. An audio segment represents a linear interval of audio data or a music piece and is derived from the inputs of an audio source which can be digital audio data, such as the engine sound effect  in audio source , or event-based data, such as the MIDI formatted input .","Segment component  has track components () through (N), and an instruction processors component . Segment  can have any number of track components  and can combine different types of audio data in the segment with different track components. Each type of audio data corresponding to a particular segment is contained in a track component  in the segment, and an audio segment is generated from a combination of the tracks in the segment. Thus, segment  has a track  for each of the audio inputs from audio source .","Each segment object contains references to one or a plurality of track objects. Track components () through (N) can be instantiated as programming objects having one or more interfaces  and associated interface methods. The track objects  are played together to render the audio and\/or musical piece represented by segment object  which is part of a larger overall performance. When first instantiated, a track object does not contain actual music or audio performance data, such as a MIDI instruction sequence. However, each track object has a stream input\/output (I\/O) interface method through which audio data is specified.","The track objects () through (N) generate event instructions for audio and music generation components when performance manager  plays the segment . Audio data is routed through the components in the performance manager  in the form of event instructions which contain information about the timing and routing of the audio data. The event instructions are routed between and through the components in performance manager  on designated performance channels. The performance channels are allocated as needed to accommodate any number of audio input sources and to route event instructions.","To play a particular audio or musical piece, performance manager  calls segment object  and specifies a time interval or duration within the musical segment. The segment object in turn calls the track play methods of each of its track objects , specifying the same time interval. The track objects  respond by independently rendering event instructions at the specified interval. This is repeated, designating subsequent intervals, until the segment has finished its playback over the specified duration.","The event instructions generated by a track  in segment  are input to the instruction processors component  in the segment. The instruction processors component  can be instantiated as a programming object having one or more interfaces  and associated interface methods. The instruction processors component  has any number of individual event instruction processors (not shown) and represents the concept of a \u201cgraph\u201d that specifies the logical relationship of an individual event instruction processor to another in the instruction processors component. An instruction processor can modify an event instruction and pass it on, delete it, or send a new instruction.","The instruction processors component  in performance manager  also processes, or modifies, the event instructions. The instruction processors component  can be instantiated as a programming object having one or more interfaces  and associated interface methods. The event instructions are routed from the performance manager instruction processors component  to the output processor  which converts the event instructions to MIDI formatted audio instructions. The audio instructions are then routed to audio rendition manager .","The audio rendition manager  processes audio data to produce one or more instances of a rendition corresponding to an audio source, or audio sources. That is, audio content from multiple sources can be processed and played on a single audio rendition manager  simultaneously. Rather than allocating buffer and hardware audio channels for each sound, an audio rendition manager  can be instantiated, or otherwise defined, to process multiple sounds from multiple sources.","For example, a rendition of the sound effects in audio source  can be processed with a single audio rendition manager  to produce an audio representation from a spatialization perspective of inside a car. Additionally, the audio rendition manager  dynamically allocates hardware channels (e.g., audio buffers to stream the audio wave data) as needed and can render more than one sound through a single hardware channel because multiple audio events are pre-mixed before being rendered via a hardware channel.","The audio rendition manager  has an instruction processors component  that receives event instructions from the output of the instruction processors component  in segment  in the performance manager . The instruction processors component  in audio rendition manager  is also a graph of individual event instruction modifiers that process event instructions. Although not shown, the instruction processors component  can receive event instructions from any number of segment outputs. Additionally, the instruction processors component  can be instantiated as a programming object having one or more interfaces  and associated interface methods.","The audio rendition manager  also includes several component objects that are logically related to process the audio instructions received from output processor  of performance manager . The audio rendition manager  has a mapping component , a synthesizer component , a multi-bus component , and an audio buffers component .","Mapping component  can be instantiated as a programming object having one or more interfaces  and associated interface methods. The mapping component  maps the audio instructions received from output processor  in the performance manager  to synthesizer component . Although not shown, an audio rendition manager can have more than one synthesizer component. The mapping component  communicates audio instructions from multiple sources (e.g., multiple performance channel outputs from output processor ) for input to one or more synthesizer components  in the audio rendition manager .","The synthesizer component  can be instantiated as a programming object having one or more interfaces  and associated interface methods. Synthesizer component  receives the audio instructions from output processor  via the mapping component . Synthesizer component  generates audio sound wave data from stored wavetable data in accordance with the received MIDI formatted audio instructions. Audio instructions received by the audio rendition manager  that are already in the form of audio wave data are mapped through to the synthesizer component , but are not synthesized.","A segment component that corresponds to audio content from a wave file is played by the performance manager  like any other segment. The audio data from a wave file is routed through the components of the performance manager on designated performance channels and is routed to the audio rendition manager  along with the MIDI formatted audio instructions. Although the audio content from a wave file is not synthesized, it is routed through the synthesizer component  and can be processed by MIDI controllers in the synthesizer.","The multi-bus component  can be instantiated as a programming object having one or more interfaces  and associated interface methods. The multi-bus component  routes the audio wave data from the synthesizer component  to the audio buffers component . The multi-bus component  is implemented to represent actual studio audio mixing. In a studio, various audio sources such as instruments, vocals, and the like (which can also be outputs of a synthesizer) are input to a multi-channel mixing board that then routes the audio through various effects (e.g., audio processors), and then mixes the audio into the two channels that are a stereo signal.","The audio buffers component  is an audio data buffers manager that can be instantiated or otherwise provided as a programming object or objects having one or more interfaces  and associated interface methods. The audio buffers component  receives the audio wave data from synthesizer component  via the multi-bus component . Individual audio buffers, such as a hardware audio channel or a software representation of an audio channel, in the audio buffers component  receive the audio wave data and stream the audio wave data in real-time to an audio rendering device, such as a sound card, that produces an audio rendition represented by the audio rendition manager  as audible sound.","The various component configurations described herein support COM interfaces for reading and loading the configuration data from a file. To instantiate the components, an application program or a script file instantiates a component using a COM function. The components of the audio generation systems described herein are implemented with COM technology and each component corresponds to an object class and has a corresponding object type identifier or CLSID (class identifier). A component object is an instance of a class and the instance is created from a CLSID using a COM function called CoCreateInstance. However, those skilled in the art will recognize that the audio generation systems and the various components described herein are not limited to a COM implementation, or to any other specific programming technique.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":["FIG. 4","FIG. 3"],"b":["400","402","404","400","206","338","346","206","338","300"]},"Audio generation system  includes a segment file component  that maintains MIDI formatted audio data, and\/or references to audio wave files maintained in a memory component of the audio generation system. An audio wave data source  includes the car horn sound effect  and the engine sound effect , both of which are audio wave files. The segment file component  includes multiple audio track components () through (N). Audio track component () is an example of a MIDI audio track component that maintains MIDI formatted audio data, and audio track component () is an example of an audio wave track component that maintains one or more programming references to audio wave files, such as reference  to the tire sound audio wave file .","Audio wave data is downloaded to synthesizer component  similar to DLS (Downloadable Sounds ) instruments in response to a download interface method call on a segment component. The audio wave data  and  is downloaded to synthesizer component  so that it is available when the synthesizer receives a playback instruction to generate an audio rendition corresponding to the audio wave data. When the audio wave data is downloaded, the audio wave data and associated instruments are routed from audio wave data source  to synthesizer component  so that the audio wave data and articulation data to render the associated sound is available. Synthesizer component  plays the audio waves in a manner similar to playing MIDI notes, and can implement the standard volume, pan, filter, reverb send, and\/or other controllers to modulate audio wave data playback.","Segment component  is a memory component that represents and instantiation of segment file component . The segment component  includes multiple audio track components () through (N) that are implemented to manage audio wave data, MIDI audio data, and any number of other audio media types that are played to generate an audio rendition in the audio generation system. Audio wave track components manage audio wave data and maintain a list of programming references (e.g., software pointers) to audio wave data maintained in an audio wave data source. Audio wave track components implement each audio wave as an event which can be created, sent, manipulated, played, and invalidated, just as notes and other performance messages in the audio generation system.","Audio track component () is implemented as a MIDI track component to manage MIDI audio data from MIDI audio track () in the segment file component . MIDI track component () generates event instructions that are routed to synthesizer component  to generate an audio rendition corresponding to the MIDI audio data. Audio track component () is implemented as an audio wave track component to manage audio wave data maintained in an audio wave data memory source , such as engine sound . Audio track component () references engine sound  with a programming reference . Audio wave track component () generates playback instructions that are routed to synthesizer component  to generate an audio rendition corresponding to the audio wave data.","Audio wave track components, such as audio wave track component (), manages audio wave data with programming references to audio wave data sources that maintain the audio wave data. This allows the audio wave data to be referenced and repeated in multiple segment components to generate multiple audio renditions corresponding to the audio wave data. For example, an audio wave track component can reference a set of audio wave data files that maintain spoken word waves which can be assembled into sentences using shared and repeated words. Multiple references can also be utilized to manage multiple music waves. With audio wave track components, a composer or sound designer can control the playback of sound effects by creating an elaborate sequence of reference calls to play various sounds.","Performance manager  includes a first segment state  and a second segment state . A segment state represents a playing instance of the performance, and manages initiating segment component  to play the audio track components . Segment state  has audio track components () through (N) with programming references  (e.g., software pointers) to each of the audio track components  in segment component . Similarly, segment state  has audio track components () through (N) with programming references  to each of the audio track components  in segment component .","Performance manager  illustrates an example of implementing multiple segment states  and  corresponding to one segment component . The audio track components  generate playback instructions and\/or event instructions for each segment state which are communicated to synthesizer component . The synthesizer component generates multiple audio renditions corresponding to the multiple segment states. For example, multiple audio renditions of the MIDI audio data in segment file component  and\/or of the audio wave data in audio wave data source  can represent two different cars in a multimedia application or video game program.","The playback instructions (also referred to herein as \u201cwave performance messages\u201d) that are generated by audio wave track components, such as audio wave track component () in segment component , include the start time to render the audio and additional playback information. The playback instructions are generated by the audio wave track components and routed to synthesizer component  to play the sound that has been downloaded from audio wave data source .","The playback instructions include one or more of the following: one or more programming references to the audio wave data maintained in the audio wave data source ; a start time to initiate the audio rendition being generated by the audio processing component (e.g., synthesizer component ); a volume parameter that is a decibel gain applied to the audio wave data; a pitch parameter that identifies an amount that the audio wave data is to be transposed; a variation parameter that identifies whether the audio wave data corresponding to a particular audio track component is to be played; a duration parameter that identifies how long audio wave data corresponding to a particular audio track component will be played; and\/or a stop play parameter that stops the audio rendition from being generated.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 5","FIG. 4"],"b":["404","400","404","414","2","500","500","408","404","408"]},"The data structure  also includes the following: one or more programming references  that identify and reference audio wave data in an audio wave data source; a start time  that identifies when the audio wave track component is played relative to other audio track components in segment component ; a volume parameter  that is a decibel gain applied to the audio wave data when the audio rendition corresponding to the audio wave data is generated by synthesizer component ; a pitch parameter  that identifies an amount that the audio wave data is to be transposed; a variation parameter  that identifies whether the audio wave data corresponding to a particular audio wave track component is to be played; a duration parameter  that identifies how long audio wave data corresponding to a particular audio track component will be played; a logical time parameter  that indicates a logical start time for the audio wave data; a loop start time  that indicates the start time for looping audio wave data; a loop stop time  that indicates the stop time for looping audio wave data; one or more flag identifiers  that indicate various properties of the wave, such as whether the wave can be invalidated; and a random variation number generator  to randomly select a variation number.","When an audio wave track component is initiated to generate playback instructions for audio wave data, the audio wave track component can randomly select a variation number that corresponds to one or more variations of the audio wave data. The segment component plays the one or more audio wave track components that manage audio wave data associated with the selected variation number. With audio wave data variations, different combinations of audio wave data can be selected and\/or sequenced so that each performance of the audio wave track can be different. Thus, each time that a segment plays, a different performance is generated. In one implementation, the audio wave track components implement thirty-two () variations that are represented by a thirty-two () bit field. Each wave reference identifies which variations it belongs to by which of the variation flags are set.","Exemplary Audio Rendition Components",{"@attributes":{"id":"p-0082","num":"0081"},"figref":["FIG. 6","FIG. 3"],"b":["206","336","338","340","342"]},"Synthesizer component  has two channel sets () and (), each having sixteen MIDI channels (\u2013) and (\u2013), respectively. Those skilled in the art will recognize that a group of sixteen MIDI channels can be identified as channels zero through fifteen (\u2013). For consistency and explanation clarity, groups of sixteen MIDI channels described herein are designated in logical groups of one through sixteen (\u2013). A synthesizer channel is a communications path in synthesizer component  represented by a channel object. A channel object has APIs and associated interface methods to receive and process MIDI formatted audio instructions to generate audio wave data that is output by the synthesizer channels.","To support the MIDI standard, and at the same time make more MIDI channels available in a synthesizer to receive MIDI inputs, channel sets are dynamically created as needed. As many as 65,536 channel sets, each containing sixteen channels, can be created and can exist at any one time for a total of over million available channels in a synthesizer component. The MIDI channels are also dynamically allocated in one or more synthesizers to receive multiple audio instruction inputs. The multiple inputs can then be processed at the same time without channel overlapping and without channel clashing. For example, two MIDI input sources can have MIDI channel designations that designate the same MIDI channel, or channels. When audio instructions from one or more sources designate the same MIDI channel, or channels, the audio instructions are routed to a synthesizer channel  or  in different channel sets () or (), respectively.","Mapping component  has two channel blocks () and (), each having sixteen mapping channels to receive audio instructions from output processor  in the performance manager . The first channel block () has sixteen mapping channels (\u2013) and the second channel block () has sixteen mapping channels (\u2013). The channel blocks  are dynamically created as needed to receive the audio instructions. The channel blocks  each have sixteen channels to support the MIDI standard and the mapping channels are identified sequentially. For example, the first channel block () has mapping channels one through sixteen (\u2013) and the second channel block () has mapping channels seventeen through thirty-two (\u2013). A subsequent third channel block would have sixteen channels thirty-three through forty-eight (\u2013).","Each channel block  corresponds to a synthesizer channel set , and each mapping channel in a channel block maps directly to a synthesizer channel in a synthesizer channel set. For example, the first channel block () corresponds to the first channel set () in synthesizer component . Each mapping channel (\u2013) in the first channel block () corresponds to each of the sixteen synthesizer channels (\u2013) in channel set (). Additionally, channel block () corresponds to the second channel set () in synthesizer component . A third channel block can be created in mapping component  to correspond to a first channel set in a second synthesizer component (not shown).","Mapping component  allows multiple audio instruction sources to share available synthesizer channels, and dynamically allocating synthesizer channels allows multiple source inputs at any one time. Mapping component  receives the audio instructions from output processor  in the performance manager  so as to conserve system resources such that synthesizer channel sets are allocated only as needed. For example, mapping component  can receive a first set of audio instructions on mapping channels  in the first channel block  that designate MIDI channels one (), two (), and four () which are then routed to synthesizer channels (), (), and (), respectively, in the first channel set ().","When mapping component  receives a second set of audio instructions that designate MIDI channels one (), two (), three (), and ten (), the mapping component routes the audio instructions to synthesizer channels  in the first channel set () that are not currently in use, and then to synthesizer channels  in the second channel set (). For example, the audio instruction that designates MIDI channel one () is routed to synthesizer channel () in the second channel set () because the first MIDI channel () in the first channel set () already has an input from the first set of audio instructions. Similarly, the audio instruction that designates MIDI channel two () is routed to synthesizer channel () in the second channel set () because the second MIDI channel () in the first channel set () already has an input. The mapping component  routes the audio instruction that designates MIDI channel three () to synthesizer channel () in the first channel set () because the channel is available and not currently in use. Similarly, the audio instruction that designates MIDI channel ten () is routed to synthesizer channel () in the first channel set ().","When particular synthesizer channels are no longer needed to receive MIDI inputs, the resources allocated to create the synthesizer channels are released as well as the resources allocated to create the channel set containing the synthesizer channels. Similarly, when unused synthesizer channels are released, the resources allocated to create the channel block corresponding to the synthesizer channel set are released to conserve resources.","Multi-bus component  has multiple logical buses (\u2013). A logical bus  is a logic connection or data communication path for audio wave data received from synthesizer component . The logical buses  receive audio wave data from the synthesizer channels  and  and route the audio wave data to the audio buffers component . Although the multi-bus component  is shown having only four logical buses (\u2013), it is to be appreciated that the logical buses are dynamically allocated as needed, and released when no longer needed. Thus, the multi-bus component  can support any number of logical buses at any one time as needed to route audio wave data from synthesizer component  to the audio buffers component .","The audio buffers component  includes three buffers (\u2013) that receive the audio wave data output by synthesizer component . The buffers  receive the audio wave data via the logical buses  in the multi-bus component . An audio buffer  receives an input of audio wave data from one or more logical buses , and streams the audio wave data in real-time to a sound card or similar audio rendering device. An audio buffer  can also process the audio wave data input with various effects-processing (i.e., audio data processing) components before sending the data to be further processed and\/or rendered as audible sound. The effects processing components are created as part of a buffer  and a buffer can have one or more effects processing components that perform functions such as control pan, volume, 3-D spatialization, reverberation, echo, and the like.","The audio buffers component  includes three types of buffers. The input buffers  receive the audio wave data output by the synthesizer component . A mix-in buffer  receives data from any of the other buffers, can apply effects processing, and mix the resulting wave forms. For example, mix-in buffer  receives an input from input buffer (). Mix-in buffer , or mix-in buffers, can be used to apply global effects processing to one or more outputs from the input buffers . The outputs of the input buffers  and the output of the mix-in buffer  are input to a primary buffer (not shown) that performs a final mixing of all of the buffer outputs before sending the audio wave data to an audio rendering device.","The audio buffers component  includes a two channel stereo buffer () that receives audio wave data input from logic buses () and (), a single channel mono buffer () that receives audio wave data input from logic bus (), and a single channel reverb stereo buffer () that receives audio wave data input from logic bus (). Each logical bus  has a corresponding bus function identifier that indicates the designated effects-processing function of the particular buffer  that receives the audio wave data output from the logical bus. For example, a bus function identifier can indicate that the audio wave data output of a corresponding logical bus will be to a buffer  that functions as a left audio channel such as from bus (), a right audio channel such as from bus (), a mono channel such as from bus (), or a reverb channel such as from bus (). Additionally, a logical bus can output audio wave data to a buffer that functions as a three-dimensional (3-D) audio channel, or output audio wave data to other types of effects-processing buffers.","A logical bus  can have more than one input, from more than one synthesizer, synthesizer channel, and\/or audio source. Synthesizer component  can mix audio wave data by routing one output from a synthesizer channel  and  to any number of logical buses  in the multi-bus component . For example, bus () has multiple inputs from the first synthesizer channels () and () in each of the channel sets () and (), respectively. Each logical bus  outputs audio wave data to one associated buffer , but a particular buffer can have more than one input from different logical buses. For example, buses () and () output audio wave data to one designated buffer. The designated buffer (), however, receives the audio wave data output from both buses.","Although the audio buffers component  is shown having only three input buffers (\u2013) and one mix-in buffer , it is to be appreciated that there can be any number of audio buffers dynamically allocated as needed to receive audio wave data at any one time. Furthermore, although the multi-bus component  is shown as an independent component, it can be integrated with the synthesizer component , or with the audio buffers component .","File Format and Component Instantiation","Audio sources and audio generation systems can be pre-authored which makes it easy to develop complicated audio representations and generate music and sound effects without having to create and incorporate specific programming code for each instance of an audio rendition of a particular audio source. For example, audio rendition manager  () and the associated audio data processing components can be instantiated from an audio rendition manager configuration data file (not shown).","A segment data file can also contain audio rendition manager configuration data within its file format representation to instantiate audio rendition manager . When a segment , for example, is loaded from a segment data file, the audio rendition manager  is created. Upon playback, the audio rendition manager  defined by the configuration data is automatically created and assigned to segment . When the audio corresponding to segment  is rendered, it releases the system resources allocated to instantiate audio rendition manager  and the associated components.","Configuration information for an audio rendition manager object, and the associated component objects for an audio generation system, is stored in a file format such as the Resource Interchange File Format (RIFF). A RIFF file includes a file header that contains data describing the object followed by what are known as \u201cchunks.\u201d Each of the chunks following a file header corresponds to a data item that describes the object, and each chunk consists of a chunk header followed by actual chunk data. A chunk header specifies an object class identifier (CLSID) that can be used for creating an instance of the object. Chunk data consists of the data to define the corresponding data item. Those skilled in the art will recognize that an extensible markup language (XML) or other hierarchical file format can be used to implement the component objects and the audio generation systems described herein.","A RIFF file for an audio wave track component has a wave track chunk that includes a volume parameter to define gain characteristics for the audio wave track component, and various general flag identifiers that identify audio wave track component configuration. A wave part file chunk includes a volume parameter to define gain characteristics for the wave part, a variations parameter to define a variation mask which indicates audio wave track components and\/or individual audio wave objects that are played together, performance channel identifiers, and flag identifiers that include general information about the wave part, including specifics for managing how variations are chosen.","The RIFF file for an audio wave track component also has a list of individual wave items and includes a wave item chunk for each individual wave item. A wave item chunk includes configuration information about a particular audio wave as well as a reference to the audio wave data. The configuration information includes a volume parameter to define a gain characteristic for the particular audio wave object, a pitch parameter, a variations bit mask to indicate which of the variations the particular audio wave object belongs, a start reference time, a start offset time, a duration parameter, a logical time parameter, loop start and loop end times, and general flag identifiers that indicate whether the particular audio wave object streams audio wave data, and whether the particular audio wave object can be invalidated.","A RIFF file for a mapping component and a synthesizer component has configuration information that includes identifying the synthesizer technology designated by source input audio instructions. An audio source can be designed to play on more than one synthesis technology. For example, a hardware synthesizer can be designated by some audio instructions from a particular source, for performing certain musical instruments for example, while a wavetable synthesizer in software can be designated by the remaining audio instructions for the source.","The configuration information defines the synthesizer channels and includes both a synthesizer channel-to-buffer assignment list and a buffer configuration list stored in the synthesizer configuration data. The synthesizer channel-to-buffer assignment list defines the synthesizer channel sets and the buffers that are designated as the destination for audio wave data output from the synthesizer channels in the channel group. The assignment list associates buffers according to buffer global unique identifiers (GUIDs) which are defined in the buffer configuration list.","The instruction processors, mapping, synthesizer, multi-bus, and audio buffers component configurations support COM interfaces for reading and loading the configuration data from a file. To instantiate the components, an application program and\/or a script file instantiates a component using a COM function. The components of the audio generation systems described herein can be implemented with COM technology and each component corresponds to an object class and has a corresponding object type identifier or CLSID (class identifier). A component object is an instance of a class and the instance is created from a CLSID using a COM function called CoCreateInstance. However, those skilled in the art will recognize that the audio generation systems and the various components described herein are not limited to a COM implementation, or to any other specific programming technique.","To create the component objects of an audio generation system, the application program calls a load method for an object and specifies a RIFF file stream. The object parses the RIFF file stream and extracts header information. When it reads individual chunks, it creates the object components, such as synthesizer channel group objects and corresponding synthesizer channel objects, and mapping channel blocks and corresponding mapping channel objects, based on the chunk header information.","Methods for Audio Wave Data Playback","Although the audio generation systems have been described above primarily in terms of their components and their characteristics, the systems also include methods performed by a computer or similar device to implement the features described above.",{"@attributes":{"id":"p-0108","num":"0107"},"figref":"FIG. 7","b":"700"},"At block , audio wave data is routed to an audio processing component from one or more audio wave data sources. For example, synthesizer component  receives audio wave data from audio wave data source .","At block , a segment state is instantiated that initiates a segment component to play audio tracks. For example, segment state  is instantiated in performance manager  to initiate segment component  playing the audio tracks . Further, multiple segment states can be instantiated at the same time. For example, segment state  is also instantiated in performance manager  to initiate segment component  playing the audio tracks .","At block , a segment component is initiated to play one or more audio wave track components and\/or one or more MIDI track components. For example, segment component  is initiated by segment state  to play MIDI track component () and audio wave track component ().","At block , a variation number corresponding to one or more variations of the audio wave data is selected. For example, audio wave track component () () includes a random variation number generator  to randomly select a variation number (e.g., one to thirty-two of a thirty-two bit field). At block , one or more audio wave track components corresponding to audio wave data associated with the variation number are played.","At block , playback instructions for the audio wave data are generated with the one or more audio wave track components. For example, audio track component () of segment component  is an audio wave track component that generates playback instructions for audio wave data associated with the audio wave track component (). For multiple segment states, such as segment states  and  in performance manager , playback instructions and event instructions are generated for each segment state.","At block , event instructions for MIDI audio data are generated with the one or more MIDI track components. For example, audio track component () of segment component  is a MIDI track component that generates event instructions for MIDI audio data associated with the MIDI track component ().","At block , the playback instructions and the event instructions are communicated to the audio processing component that generates an audio rendition corresponding to the audio wave data and\/or the MIDI audio data. For example, synthesizer component  receives the playback instructions generated by audio wave track component () in segment component . Synthesizer component  also receives the event instructions generated by MIDI track component () in segment component .","For multiple segment states, such as segment states  and  in performance manager , playback instructions and\/or event instructions for each segment state are communicated to synthesizer component  such that the synthesizer component generates multiple audio renditions corresponding to the multiple segment states. Further, the audio generation system can include multiple audio processing components that each receive the playback instructions and\/or the event instructions, and each audio processing component generates an audio rendition corresponding to the audio wave data and\/or the MIDI audio data.","Audio Generation System Component Interfaces and Methods","Embodiments of the invention are described herein with emphasis on the functionality and interaction of the various components and objects. The following sections describe specific interfaces and interface methods that are supported by the various objects.","A Loader interface (IDirectMusicLoader) is an object that gets other objects and loads audio rendition manager configuration information. It is generally one of the first objects created in a DirectX\u00ae audio application. DirectX\u00ae is an API available from Microsoft Corporation, Redmond Wash. The loader interface supports a LoadObjectFromFile method that is called to load all audio content, including DirectMusic\u00ae segment files, DLS (downloadable sounds) collections, MIDI files, and both mono and stereo wave files. It can also load data stored in resources. Component objects are loaded from a file or resource and incorporated into a performance. The Loader interface is used to manage the enumeration and loading of the objects, as well as to cache them so that they are not loaded more than once.","Audio Rendition Manager Interface and Methods","An AudioPath interface (IDirectMusicAudioPath) represents the routing of audio data from a performance component to the various component objects that comprise an audio rendition manager. The AudioPath interface includes the following methods:","An Activate method is called to specify whether to activate or deactivate an audio rendition manager. The method accepts Boolean parameters that specify \u201cTRUE\u201d to activate, or \u201cFALSE\u201d to deactivate.","A ConvertPChannel method translates between an audio data channel in a segment component and the equivalent performance channel allocated in a performance manager for an audio rendition manager. The method accepts a value that specifies the audio data channel in the segment component, and an address of a variable that receives a designation of the performance channel.","A SetVolume method is called to set the audio volume on an audio rendition manager. The method accepts parameters that specify the attenuation level and a time over which the volume change takes place.","A GetObjectInPath method allows an application program to retrieve an interface for a component object in an audio rendition manager. The method accepts parameters that specify a performance channel to search, a representative location for the requested object in the logical path of the audio rendition manager, a CLSID (object class identifier), an index of the requested object within a list of matching objects, an identifier that specifies the requested interface of the object, and the address of a variable that receives a pointer to the requested interface.","The GetObjectInPath method is supported by various component objects of the audio generation system. The audio rendition manager, segment component, and audio buffers in the audio buffers component, for example, each support the getObject interface method that allows an application program to access and control the audio data processing component objects. The application program can get a pointer, or programming reference, to any interface (API) on any component object in the audio rendition manager while the audio data is being processed.","Real-time control of audio data processing components is needed, for example, to control an audio representation of a video game presentation when parameters that are influenced by interactivity with the video game change, such as a video entity's 3-D positioning in response to a change in a video game scene. Other examples include adjusting audio environment reverb in response to a change in a video game scene, or adjusting music transpose in response to a change in the emotional intensity of a video game scene.","Performance Manager Interface and Methods","A Performance interface (IDirectMusicPerformance) represents a performance manager and the overall management of audio and music playback. The interface is used to add and remove synthesizers, map performance channels to synthesizers, play segments, dispatch event instructions and route them through event instructions, set audio parameters, and the like. The Performance interface includes the following methods:","A CreateAudioPath method is called to create an audio rendition manager object. The method accepts parameters that specify an address of an interface that represents the audio rendition manager configuration data, a Boolean value that specifies whether to activate the audio rendition manager when instantiated, and the address of a variable that receives an interface pointer for the audio rendition manager.","A CreateStandardAudioPath method allows an application program to instantiate predefined audio rendition managers rather than one defined in a source file. The method accepts parameters that specify the type of audio rendition manager to instantiate, the number of performance channels for audio data, a Boolean value that specifies whether to activate the audio rendition manager when instantiated, and the address of a variable that receives an interface pointer for the audio rendition manager.","A PlaySegmentEx method is called to play an instance of a segment on an audio rendition manager. The method accepts parameters that specify a particular segment to play, various flags, and an indication of when the segment instance should start playing. The flags indicate details about how the segment should relate to other segments and whether the segment should start immediately after the specified time or only on a specified type of time boundary. The method returns a memory pointer to the state object that is subsequently instantiated as a result of calling PlaySegmentEx.","A StopEx method is called to stop the playback of audio on an component object in an audio generation system, such as a segment or an audio rendition manager. The method accepts parameters that specify a pointer to an interface of the object to stop, a time at which to stop the object, and various flags that indicate whether the segment should be stopped on a specified type of time boundary.","Segment Component Interface and Methods","A Segment interface (IDirectMusicSegment) represents a segment in a performance manager which is comprised of multiple tracks. The Segment interface includes the following methods:","A Download method to download audio data to a performance manager or to an audio rendition manager. The term \u201cdownload\u201d indicates reading audio data from a source into memory. The method accepts a parameter that specifies a pointer to an interface of the performance manager or audio rendition manager that receives the audio data.","An Unload method to unload audio data from a performance manager or an audio rendition manager. The term \u201cunload\u201d indicates releasing audio data memory back to the system resources. The method accepts a parameter that specifies a pointer to an interface of the performance manager or audio rendition manager.","A GetAudioPathConfig method retrieves an object that represents audio rendition manager configuration data embedded in a segment. The object retrieved can be passed to the CreateAudioPath method described above. The method accepts a parameter that specifies the address of a variable that receives a pointer to the interface of the audio rendition manager configuration object.","Segment Component Interface and Methods","A Track interface (IDirectMusicTrack) represents an audio data track component in a segment component. The Track interface includes the following methods:","An Initialize method is called by the segment object to initialize a track object after creating it. This method does not load music performance data. Rather, music performance data is loaded through the IPersistStream interface. The group and index assignments of the new track object are specified as arguments to this method.","An InitPlay method is called prior to beginning the playback of a track. This allows the track object to open and initialize internal state variables and data structures used during playback. Some track objects can use this to trigger specific operations. For example, a track that manages the downloading of configuration information can download the information in response to its InitPlay method being called.","An EndPlay method is called by a segment object upon finishing the playback of a track. This allows the track object to close any internal state variables and data structures used during playback. A track that manages the downloading of configuration information can unload the information in response to its EndPlay method being called.","A Play method accepts arguments corresponding to a start time, an end time, and an offset within the music performance data. When this method is called, the track object renders the music defined by the start and end times. For example, a note sequence track would render stored notes, a lyric track would display words, and an algorithmic music track would generate a range of notes. The offset indicates the position in the overall performance relative to which the start and end times are to be interpreted.","A Clone method causes the track object to make an identical copy of itself. The method accepts start and end times so that a specified piece of the track can be duplicated.","Exemplary Computing System and Environment",{"@attributes":{"id":"p-0147","num":"0146"},"figref":"FIG. 8","b":["800","800","800","800"]},"The computer and network architectures can be implemented with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use include, but are not limited to, personal computers, server computers, thin clients, thick clients, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, gaming consoles, distributed computing environments that include any of the above systems or devices, and the like.","Audio generation may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Audio generation may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","The computing environment  includes a general-purpose computing system in the form of a computer . The components of computer  can include, by are not limited to, one or more processors or processing units , a system memory , and a system bus  that couples various system components including the processor  to the system memory .","The system bus  represents one or more of any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. By way of example, such architectures can include an Industry Standard Architecture (ISA) bus, a Micro Channel Architecture (MCA) bus, an Enhanced ISA (EISA) bus, a Video Electronics Standards Association (VESA) local bus, and a Peripheral Component Interconnects (PCI) bus also known as a Mezzanine bus.","Computer system  typically includes a variety of computer readable media. Such media can be any available media that is accessible by computer  and includes both volatile and non-volatile media, removable and non-removable media. The system memory  includes computer readable media in the form of volatile memory, such as random access memory (RAM) , and\/or non-volatile memory, such as read only memory (ROM) . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within computer , such as during start-up, is stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently operated on by the processing unit .","Computer  can also include other removable\/non-removable, volatile\/non-volatile computer storage media. By way of example,  illustrates a hard disk drive  for reading from and writing to a non-removable, non-volatile magnetic media (not shown), a magnetic disk drive  for reading from and writing to a removable, non-volatile magnetic disk  (e.g., a \u201cfloppy disk\u201d), and an optical disk drive  for reading from and\/or writing to a removable, non-volatile optical disk  such as a CD-ROM, DVD-ROM, or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are each connected to the system bus  by one or more data media interfaces . Alternatively, the hard disk drive , magnetic disk drive , and optical disk drive  can be connected to the system bus  by a SCSI interface (not shown).","The disk drives and their associated computer-readable media provide non-volatile storage of computer readable instructions, data structures, program modules, and other data for computer . Although the example illustrates a hard disk , a removable magnetic disk , and a removable optical disk , it is to be appreciated that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes or other magnetic storage devices, flash memory cards, CD-ROM, digital versatile disks (DVD) or other optical storage, random access memories (RAM), read only memories (ROM), electrically erasable programmable read-only memory (EEPROM), and the like, can also be utilized to implement the exemplary computing system and environment.","Any number of program modules can be stored on the hard disk , magnetic disk , optical disk , ROM , and\/or RAM , including by way of example, an operating system , one or more application programs , other program modules , and program data . Each of such operating system , one or more application programs , other program modules , and program data  (or some combination thereof) may include an embodiment of an audio generation system.","Computer system  can include a variety of computer readable media identified as communication media. Communication media typically embodies computer readable instructions, data structures, program modules, or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared, and other wireless media. Combinations of any of the above are also included within the scope of computer readable media.","A user can enter commands and information into computer system  via input devices such as a keyboard  and a pointing device  (e.g., a \u201cmouse\u201d). Other input devices  (not shown specifically) may include a microphone, joystick, game pad, satellite dish, serial port, scanner, and\/or the like. These and other input devices are connected to the processing unit  via input\/output interfaces  that are coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port, or a universal serial bus (USB).","A monitor  or other type of display device can also be connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , other output peripheral devices can include components such as speakers (not shown) and a printer  which can be connected to computer  via the input\/output interfaces .","Computer  can operate in a networked environment using logical connections to one or more remote computers, such as a remote computing device . By way of example, the remote computing device  can be a personal computer, portable computer, a server, a router, a network computer, a peer device or other common network node, and the like. The remote computing device  is illustrated as a portable computer that can include many or all of the elements and features described herein relative to computer system .","Logical connections between computer  and the remote computer  are depicted as a local area network (LAN)  and a general wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet. When implemented in a LAN networking environment, the computer  is connected to a local network  via a network interface or adapter . When implemented in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the wide network . The modem , which can be internal or external to computer , can be connected to the system bus  via the input\/output interfaces  or other appropriate mechanisms. It is to be appreciated that the illustrated network connections are exemplary and that other means of establishing communication link(s) between the computers  and  can be employed.","In a networked environment, such as that illustrated with computing environment , program modules depicted relative to the computer , or portions thereof, may be stored in a remote memory storage device. By way of example, remote application programs  reside on a memory device of remote computer . For purposes of illustration, application programs and other executable program components, such as the operating system, are illustrated herein as discrete blocks, although it is recognized that such programs and components reside at various times in different storage components of the computer system , and are executed by the data processor(s) of the computer.","Although the systems and methods have been described in language specific to structural features and\/or procedures, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or procedures described. Rather, the specific features and procedures are disclosed as preferred forms of implementing the claimed invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The same numbers are used throughout the drawings to reference like features and components.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 4","FIGS. 2 and 3"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 6","FIG. 2"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
