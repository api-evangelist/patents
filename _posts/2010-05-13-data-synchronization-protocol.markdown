---
title: Data synchronization protocol
abstract: Among other things, techniques and systems are disclosed for syncing data between a client device and a server. Synchronizing data includes initiating a sync session by negotiating a sync mode between a client device and a server for each of one or more dataclasses. A status code is generated based on a result of the negotiating. Based on the generated status code, the client device and the server exchanges one or more data items to be updated for the one or more dataclasses using the negotiated sync mode for each dataclass. The exchanged one or more data items are updated at the client device or the server The updated one or more data items are committed at the client or the server.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08046498&OS=08046498&RS=08046498
owner: Apple Inc.
number: 08046498
owner_city: Cupertino
owner_country: US
publication_date: 20100513
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application is a continuation (and claims the benefit of priority under 35 USC 120) of U.S. application Ser. No. 12\/042,283, filed Mar. 4, 2008 now U.S. Pat. No. 7,747,784. The disclosure of the prior application is considered part of (and is incorporated by reference in) the disclosure of this application.","This application relates to protocols for data synchronization.","Data synchronizing between a client and a server can be performed using synchronization protocols such as Open Mobile Alliance\u2014Data Synchronization protocol OMA DS\/SyncML (formerly known as the SyncML protocol). The OMS DA\/SyncML is a sync protocol that enables serial synchronization of dataclasses and can require 5 or more roundtrips per dataclass.","Among other things, techniques and systems are disclosed for syncing data between a client device and a server.","In one aspect, synchronizing data includes receiving a request to initiate a sync session. The request includes a proposed sync mode for each of one or more dataclasses, and one or more changes to the one or more dataclasses. One or more status codes are generated to indicate whether the proposed sync mode for each dataclass is accepted. Based on the generated status code, the accepted sync mode is used for each dataclass to selectively update one or more data items associated with the one or more changes to the one or more dataclasses. The updated one or more data items are selectively committed at the server.","Implementations can optionally include one or more of the following features. Generating one or more status codes can include accessing information saved from a previous sync session to determine whether to use the proposed sync mode to synchronize the one or more data items. Receiving the request can include receiving the proposed sync mode for two or more dataclasses in parallel. Also, receiving the request can include receiving the proposed sync mode that includes a fast sync mode, a slow sync mode or a reset sync mode. Further, receiving the request can include receiving a fast sync mode that enables exchange of data items to be updated only. The sync session can be completed in one round trip that includes two messages. When the sync session is interrupted, a fast sync can be reaccepted. The proposed sync mode and the one or more changes to the one or more dataclasses can be received in a single message from a client device. The updated one or more data items can be selectively committed at the server when the client device sends a command to commit the updated one or more data items. In addition, the proposed sync mode can be rejected and the received request can be responded to with a different sync mode.","In another aspect, a computer program product, embodied on a computer readable medium, is operable to cause a data processing apparatus to perform various operations. The computer program product is operable to cause a data processing apparatus to receive a request to initiate a sync session. The request includes a proposed sync mode for each of one or more dataclasses and one or more changes to the one or more dataclasses. The computer program product is operable to cause a data processing apparatus to generate a status code indicative of whether the proposed sync mode for each dataclass is accepted. The computer program product is operable to cause a data processing apparatus to based on the generated status code, use the accepted sync mode for each dataclass is used to selectively update one or more data items associated with the one or more changes to the one or more dataclasses. In addition, the computer program product is configured to cause a data processing apparatus to selectively commit the updated one or more data items at a server.","Implementations can optionally include one or more of the following features. The computer program product can cause a data processing apparatus to generate the one or more status codes based on information saved from a previous sync session. The computer program product can cause a data processing apparatus to receive the proposed sync mode for two or more dataclasses in parallel. The computer program product can cause a data processing apparatus to receive the proposed sync mode that includes a fast sync mode, a slow sync mode or a reset sync mode. The computer program product can cause a data processing apparatus to receive a fast sync mode that enables exchange of data items to be updated only. Update operations on a data item may (1) create a new item (add), (2) modify properties of an existing item (modify) or (3) delete an existing item (delete). The computer program product can cause a data processing apparatus to complete the sync session in one round trip that includes two messages. The computer program product can cause a data processing apparatus to reaccept a fast sync mode when the sync session is interrupted. The computer program product can cause a data processing apparatus to receive the proposed sync mode and the one or more changes to the one or more dataclasses in a single message. The computer program product can cause a data processing apparatus to selectively commit the updated one or more data items at the server when the client device sends a command to commit the updated one or more data items. In addition, the computer program product can case a data processing apparatus to reject the proposed sync mode and respond to the received request with a different sync mode.","In another aspect, a server for syncing data includes a processor configured to operate a transport protocol that enables opening of one or more connections to one or more client devices. The processor is also configured to operate a sync protocol that enables data synchronization between the server and the one or more client devices over the opened one or more connections. The sync protocol enables the server to receive a request to initiate a sync session. The request includes a proposed sync mode fore each of one or more dataclasses and one or more changes to the one or more dataclasses. The sync server also enables the server to generate one or more status codes to indicate whether the proposed sync mode for each dataclass is accepted. The sync protocol also enables the server to, based on the generated status code, use the accepted sync mode for each dataclass to selectively update one or more data items associated with the one or more changes to the one or more dataclasses. The sync protocol further enables the updated one or more data items to be selectively committed at the server.","Implementations can optionally include one or more of the following features. The processor can be configured to access a data repository to update one or more data items based on the received one or more changes. The processor can be configured to operate the sync protocol to accept or reject the proposed sync mode for each dataclass based on information saved from a previous sync session. The processor can be configured to operate the sync protocol to received the proposed sync mode for two or more dataclasses in parallel. Also, the processor can be configured to operate the sync protocol to receive the proposed sync mode that includes a fast sync mode, a slow sync mode or a reset sync mode. The processor can be configured to operate the sync protocol to receive the proposed sync mode that includes a fast sync mode that enables the one or more client devices to send data items to be updated only. The processor can be configured to operate the sync protocol to receive request to reinitiate a fast sync when the sync session is interrupted. The processor can be configured to operate the sync protocol to complete the sync session in one round trip that includes two messages. The processor can be configured to operate the sync protocol to receive the proposed sync mode and the one or more changes to the one or more dataclasses in a single message from at least one of the one or more client devices. The processor can be configured to operate the sync protocol to selectively commit the updated one or more data items at the server when one of the one or more client devices sends a command to commit the updated one or more data items. Further, the processor can be configured to operate the sync protocol to rejecting the proposed sync mode and responding to the request with a different sync mode.","In another aspect, synchronizing data includes sending a request to a server to initiate a sync session. The request includes a proposed sync mode for each of one or more dataclasses, and one or more changes to the one or more dataclasses. One or more status codes are received to indicate whether the proposed sync mode for each dataclass has been accepted by the server. Based on the received status code, the accepted sync mode for each dataclass is used to receive from the server additional changes to the one or more dataclasses. Further, at a client device, the additional changes received from the server are committed.","Implementations can optionally include one or more of the following features. The one or more status codes can indicate that the proposed sync mode for at least one of the one or more data classes has been rejected by the server. Another request that includes a different sync mode than the rejected sync mode can be sent to the server. Also, the proposed sync mode and the one or more changes can be sent in a single message to the server. The proposed sync mode for two or more dataclasses can be sent in parallel. In addition, a different proposed sync mode can be sent for each of the two or more dataclasses in parallel. For example, a proposed fast sync mode can be sent for one of the dataclasses and a proposed slow sync mode for another of the dataclasses. After the sync session is interrupted, the sync session can be reinitiated using the accepted sync protocol.","In another aspect, a computer program product, embodied on a computer-readable medium, is operable to cause a data processing apparatus to perform one or more operations. The computer program product is operable to cause a data processing apparatus to send a request to a server to initiate a sync session. The request includes a proposed sync mode for each of one or more dataclasses and one or more changes to the one or more dataclasses. The computer program product is operable to cause a data processing apparatus to receive one or more status codes that are indicative of whether the proposed sync mode for each dataclass has been accepted by the server. Based on the received status code, the computer program product is operable to use the accepted sync mode to receive from the server additional changes to the one or more dataclasses and commit at a client device the additional changes received from the server.","Implementations can optionally include one or more of the following features. The computer program product can be operable to cause a data processing apparatus to perform operations that includes receiving the one or more status codes that indicate that the proposed sync mode for at least one of the one or more data classes has been rejected by the server; and sending another request that includes a different sync mode than the rejected sync mode. The computer program product can be operable to cause a data processing apparatus to send the proposed sync mode and the one or more changes in a single message to the server. The computer program product can be operable to cause the data processing apparatus to send the proposed sync mode for two or more dataclasses in parallel. The computer program product can be operable to cause the data processing apparatus to send a different proposed sync mode for each of the two or more dataclasses in parallel. The computer program product can be operable to cause the data processing apparatus to send a proposed fast sync mode for one of the dataclasses and a proposed slow sync mode for another of the dataclasses. The computer program product can be operable to cause the data processing apparatus to reinitiate the sync session using the accepted sync protocol after the sync session is interrupted.","In another aspect, a client device includes a processor configured to operate a transport protocol that enables opening of one or more connections to a server and a sync protocol that enables data synchronization between the client device and the server over the opened one or more connections. The sync protocol enables the client device to send a request to a server to initiate a sync session. The request includes a proposed sync mode for each of one or more dataclasses and one or more changes to the one or more dataclasses. The sync protocol also enables the client device to receive one or more status codes indicative of whether the proposed sync mode for each dataclass has been accepted by the server. Based on the received status code, the sync protocol enables the client device to use the accepted sync mode to receive from the server additional changes to the one or more dataclasses. Further, the sync protocol enables the client device to commit at a client device the additional changes received from the server.","Implementations can optionally include one or more of the following features. The processor can be configured to operate the sync protocol to receive the one or more status codes that indicate that the proposed sync mode for at least one of the one or more data classes has been rejected by the server; and send another request that includes a different sync mode than the rejected sync mode. The processor can be configured to operate the sync protocol to send the proposed sync mode and the one or more changes in a single message to the server. The processor can be configured to operate the sync protocol to send the proposed sync mode for two or more dataclasses in parallel. The processor can be configured to operate the sync protocol to send the proposed sync mode for two or more dataclasses in parallel comprising sending a different proposed sync mode for each of the two or more dataclasses in parallel. The processor can be configured to operate the sync protocol to send a proposed fast sync mode for one of the dataclasses and a proposed slow sync mode for another of the dataclasses. The processor can be configured to operate the sync protocol to reinitiate the sync session using the accepted sync protocol after the sync session is interrupted.","Techniques and systems according to the present specification can be implemented to potentially provide various advantages. The sync protocol as described in this specification can reduce the number of round trips (the number of back and forth messages exchanged) to complete a sync session. The sync protocol as described in this specification can complete a sync session in one round trip, for example. The sync protocol as described in this specification enables sync mode negotiation for each of multiple dataclasses in parallel. Thus, a request for sync mode negotiation can be sent for multiple dataclasses in one message. Further, the sync protocol as described in this specification enables field level differencing and record level differencing.","The synchronization protocol as described in this specification is simpler than conventional protocols, such as SyncML. The set of commands available for the synchronization protocol is simple and yet extensible. Unlike SyncML, the synchronization protocol as described in this specification represents each message as a text or binary property list files (plist). In addition, the synchronization protocol as described in this specification is efficient and robust. For example, a sophisticated anchor logic is provided on the server. Further, the synchronization protocol is tolerant of unreliable network. Even when the network connection is interrupted, the anchor logic ensures efficient synchronization once reconnected. Further, the synchronization protocol can maintain relatively small message size.","The synchronization protocol as described in this specification is rich. For example, the synchronization protocol enables exchange of device information between the client device and the server. Also, the synchronization protocol provides convenient yet rich data representation.","Like reference symbols and designations in the various drawings indicate like elements.","Techniques and systems are disclosed for enabling over-the-air (OTA) synchronization between a client device and a server. In particular, a wireless structured data synchronization protocol can enable a client device to interface with a server to synchronize various data. Such protocol can be used to synchronize Mac\u00ae Operating System X (OS X) SyncServices data between a handheld device such as the iPhone\u00ae and a server such as the .Mac\u00ae server, for example.","The OTA synchronization protocol as described in this specification relies upon the underlying network transport to perform authentication and\/or authorization and message security\/encryption using transport layer security (TLS), for example. The synchronization protocol can enable these data transport using hypertext transfer protocol (HTTP) transport protocol or other similar transport protocols which are capable of exchanging synchronization protocol messages between the device and server.","The synchronization protocol can enable exchange of protocol messages over the transport, such as HTTP transport. The each message exchanged over the transport includes a header element and a body element. The body element can include a sequence of command and\/or command response elements. The synchronization protocol assigns a unique label to each message, command and command response to ensure proper ordering and loss detection. For example, the label can include a sequence of numbers for ordering the messages, commands and command responses. Using the label, the synchronization protocol, instead of the transport (e.g., HTTP) ensures proper ordering and loss detection even when the network protocol does not enforce message ordering.","The synchronization protocol is simpler than conventional protocols, such as Synchronization Markup Language (SyncML). The set of commands available for the synchronization protocol is simple and yet extensible. For example, three flexible primitive commands are available for manipulating resources. In addition, four \u201csync\u201d family commands are available for data synchronization. Further, commands may be split across message boundaries. Unlike SyncML, the synchronization protocol as described in this specification represents each message as a text or binary property list files (plist). In the Mac OS X Cocoa, NeXTSTEP, and GNUstep programming frameworks, plists are files that store serialized objects. The plists are often used to store a user's settings, similar to the function of the Windows registry on Microsoft Windows\u00ae. Property list files are also used to store information about bundles and applications. A plist is easy to generate and parse using standard operating system (OS) features, such as NSPropertyListSerialization class. Also, the synchronization protocol as described in this specification uses simple sync state machine.","The synchronization protocol as described in this specification is efficient and robust. For example, a sophisticated anchor logic is provided on the server. An anchor is a tag or label used to keep track of the synchronization state. Also, the synchronization protocol can sync multiple dataclasses in parallel. The synchronization protocol is tolerant of unreliable network. Even when the network connection is interrupted, the anchor logic ensures efficient synchronization once reconnected with minimal retransmission of data. Further, the synchronization protocol can maintain relatively small message size.","The synchronization protocol as described in this specification is rich. For example, the synchronization protocol enables exchange of device information between the client device and the server. Also, the synchronization protocol provides convenient yet rich data representation.",{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 1","i":"a ","b":["100","100","110","120","150","110","112","114","116","112"]},"The client device  interfaces with the server  using a transport protocol such as HTTP transport protocol to complete a secure data connection. Through the transport protocol, a synchronization protocol  enables data synchronization between the connected client device  and the server. Synchronized data can include various data classes such as contacts (e.g., addresses and phone numbers), calendar, etc. Data synchronization can be performed over the network  that includes various wired and wireless networks such as local area network (LAN), wide area network (WAN), Ethernet, Internet, etc.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 1","i":"b ","b":["120","120","160","170","160","170"]},"The processor  can operate the transport protocol  to open transport connections to one or more client devices . The processor  can operate the sync protocol  over the opened transport connections to enable data synchronization between the server  and the client devices . The transport protocol  and the sync protocol  can be loaded and running on the memory  to be executed or operated by the processor . For example, as described with respect to below, the processor  can operate the sync protocol  to receive a request from the client devices  to initiate a sync session.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 1","i":"c ","b":["110","110","180","190","180","190"]},"The processor  can operate the transport protocol  to open transport connections to one or more servers . The processor  can operate the sync protocol  over the opened transport connections to enable data synchronization between the client devices  and the server . The transport protocol  and the sync protocol  can be loaded and running on the memory  to be executed or operated by the processor . For example, as described with respect to below, the processor  can operate the sync protocol  to send a request to the server  to initiate a sync session.","Synchronization is a process of maintaining consistency between two distinct datastores by periodically comparing the changes which have occurred to each since the last time the datastores were known to be consistent. The datastores can include a client device  on one side and a server  on the other side. To synchronize with each other, the datastores are configured with various capabilities. For example, each datastore is configured to supply all data when requested. In addition, each datastore is configured to identify and supply changes since the time of the last synchronization. Each datastore is configured to agree on the schema to be kept in sync. Each datastore is configured to agree on the supported data representations. Each datastore is configured to agree on the semantics of synchronization primitives (i.e. add, update, delete). Further, each datastore is configured to rollback to a previous state should a problem occur during a sync to avoid corrupting the datastores.","The synchronized data follows the relational model (E-R) and is divided into \u201cschemas\u201d or \u201cdataclasses\u201d which group definitions of structured data types (\u201centities\u201d) Entities within a given dataclass may refer to one another via \u201crelationships\u201d. Relationships between entities in discrete dataclasses is forbidden, and thus each dataclass is wholly independent of other dataclasses. From a user's perspective, dataclasses may appear to be managed from separate dedicated applications. For example, the \u201ccontacts\u201d dataclass can be managed primarily by an address book application, while the \u201ccalendars\u201d dataclass can be managed by a calendar application.","The synchronization protocol  enables various synchronization modes including slow, reset and fast. The first time a client device and a server sync, all data for a dataclass are exchanged to \u201cmatch\u201d existing data items that are considered identical. To optimize syncing and network bandwidth usage for subsequent sync operations, the client device and server should exchange only the data which has changed since the last time the pair synchronized. Thus, each entity (i.e., client device or server) should be capable of determining what local changes should be sent to the other entity. In addition, each entity should be able to detect whether a situation has occurred which require exchanging more data before \u201cfast\u201d syncing can be resumed.","The slow sync mode may be required when the client device  and server  sync for the first time to establish a common baseline for subsequent difference-only data exchange. During a slow sync, the client device  sends all data for a dataclass to the server . The server attempts to match these data items with those that are already known to the server . Failure to perform proper \u201cidentity matching\u201d can result in duplicated data. The server  then responds with data items missing at the client device .","The reset sync mode is used to reset all data for the dataclass on the client device with the server's data. This can occur when the data structure has been pushed to the device , or if the server  or device  determine that the device's local data is corrupt. The device  sends no data, and the server responds with the complete data structure for the dataclass.","The fast sync mode is the most efficient mode, especially when using a limited bandwidth connection. The client device  sends only those data that have changed since the last sync with the server . The server  responds with only those data that have changed external to the client device .","A synchronization session can follow a distinct set of phases including negotiation, pull, mingle, push, and commit. The terms, \u201cpull\u201d and \u201cpush\u201d can be defined relative to the server process. The client device  sends its local changes to the server  during the pull phase, and receives updates during the server's push phase.","During the negotiation phase, both sides (client device  and server ) can exchange information from the previous sync session to determine what sync mode they agree to use for the current session. To help identify and organize the sync sessions, a \u201csync anchor\u201d is assigned to each sync session. If the client device  has previously synced with the server , the client device  likely expects a specific sync mode. The client device  may believe that it can fast sync with the server , but the server  may desire to reset the device. When the requested sync mode is accepted by both sides, synchronization can proceed to the pull phase.","During the pull phase, the client device  sends its changed records (or if the sync mode is \u201cslow\u201d, all records) to the server . Invalid changes may be rejected by the server .","Once all changes have been received, the server  enters the mingle phase and merges any pending updates in its database with the changes from the client device . The result of mingling is a set of conflicting changes and a set of updates which should be pushed to the client device . The server  can automatically resolve all conflicts using a heuristic algorithm. In some implementations, it may be desirable for the client device  to resolve certain conflicts. The synchronization protocol  can be designed to allow for conflicts to be represented and transmitted from the server  to the client device . The synchronization protocol  can be designed to enable conflicts to be resolved on the client device by the user to be transmitted to the sync server .","During the push phase, updates from the server  are sent to the client device . When all updates have been received by the client device , the commit phase is entered. Both sides (client device  and server ) may agree that the sync was successful, persist their current sync anchors, and commit the exchanged data to their respective data stores.","At any point during a sync, either side may decide to cancel the sync and rollback any changes to the local datastore. Cancellation may occur explicitly in response to one or more of the following events: when unexpected or invalid data is sent; when the expected transitions in the sync state machine are not followed; when communications between the client device  and server  are interrupted; or when some other problems occur.","The difference in data can be synced in various granularities. When exchanging synchronization data, the client device  and the server  may send the complete data for each changed record for a record-level differencing (RLD). Alternatively, just the changed fields of each changed record can be sent for a field-level differencing (FLD). FLD may be preferred over RLD, especially when data records include many fields, or contain large amounts of data, such as the images in the contact dataclass.","The server  can dynamically support both RLD and FLD representations of data received from the client device . The data representation for the changes indicates whether the client device  is using RLD or FLD for a given dataclass. This provides client device datastore implementation with maximum flexibility when the complexity of maintaining meta information to support FLD is unreasonable.","When receiving RLD changes, the server  internally converts the changes to FLD for processing, storage and communication efficiency. The server  expects an RLD client device  to send complete records. Data fields that are supported by the client device  and are missing from the client device's data record are assumed to have been cleared\/deleted by the client device . However, a mechanism can be provided to enable the client device  to indicate that certain data field exceptional values are unchanged without sending the values.","Identification (ID) mapping is another basic synchronization concept. Every synced datum has an universal unique record ID or UUID. For efficiency sake, the server  can use the UUIDs of the SyncService on Mac OS X. Alternatively, an application on the client device  can use its local unique IDs (LUIDs) for data to promote local datastore efficiency, for example.","The server  enables the client device  datastores to use their own LUID to refer to data items as needed. In this case, the server  maintains a LUID to UUID mapping to enable the client device  to transparently reference global records by using its own local IDs. The server  reestablishes new mappings when a \u201cslow\u201d or \u201creset\u201d sync mode is accepted for the dataclass.","The synchronization protocol  includes a sequence of messages exchanged between the server  and the device  using a transport protocol , such as HTTP. The synchronization protocol  includes the messages exchanged on the transport protocol . The roles of the client device  and server  in the synchronization protocol are distinct from their roles in the communications\/transport protocol. For example, for the HTTP transport , the device  is always a client with respect to the transport , and thus the device  makes requests only. However, in the message protocol of the synchronization protocol , both the client device  and server  may issue message commands to each other.","Transport","The transport protocol  manages the exchange of messages between the server  and client device . The transport protocol  can include HTTP transport or other suitable transports, such as Extensible Messaging and Presence Protocol (XMPP). The transport protocol  layer handles authentication, and thus the synchronization protocol  does not need to handle security\/authentication processing. This enables the synchronization protocol  to function more efficiently and require few number of roundtrips. For example, Transport Layer Security (TLS) may be used to ensure security of the transmitted data, if desired. Also, the transport protocol  may perform message chunking. The transport protocol  need not guarantee delivery or message ordering, as the synchronization protocol  has the necessary information to do so and to detect message loss.","The HTTP defines eight methods or \u201cverbs\u201d that indicate actions to be performed on a resource. The HTTP methods includes: HEAD, GET, POST, PUT, DELETE, TRACE, OPTIONS and CONNECT. When using HTTP as the transport protocol , the POST method is to be used. The POST method submits data to be processed, such as data from an HTML form, to the identified resource. The data is included in the body of the request. The result of the POST method may result in the creation of a new resource or the updates of existing resources or both.","For example, the server  can provide the OTA sync service on a URL, such as \u201chttp:\/\/sync.mac.com\/ota\u201d. When using text plist representation, the \u201cContent-Type\u201d header should be \u201ctext\/xml\u201d. When using binary plist representation, the \u201cContent-Type\u201d header must be present and must be \u201capplication\/octet-stream\u201d. The \u201cContent-Length\u201d header must indicate the size of the message. The User-Agent string is used to identify the client protocol implementation. The User-Agent string should be of the form: \u201cMobile\/A\u201d. Alternatively, DeviceInfo method can be used to determine the device implementation version.","The OTA Protocol Structure","A session consists of an exchange of a number of protocol messages between the client device  and the server . The HTTP transport implementation can use cookies to maintain a session with the server . Either the client device  or the server  may indicate that the session is complete by setting a flag in a message header. Each message contains a series of commands that can be processed by the recipient. The client device  may be designated as the party that initiates the connection to the server .","The messages exchanged using the synchronization protocol  is represented as UTF-8 encoded OS X property lists (i.e. a dictionary.) This representation facilitates creation, serialization and parsing on both the client device  and the server . The synchronization protocol  can support both Extensible Markup Language (XML) and binary representations of plists. Binary plists can be 60% to 80% more compact than XML plists. When using XML plist representation, any binary data transmitted are serialized as base-64 encoded NSData objects and the text data are XML-escaped according to RFC 3076. Each protocol message consists of two root elements: the header and the body.",{"@attributes":{"id":"p-0105","num":"0104"},"figref":["FIG. 2","FIG. 2","FIG. 2"],"b":["210","210","210","220","210","230","240"]},"The header element  can identify the entity (e.g., client device  or server ) sending the message, and can contain certain session control information. The header element  is a required element of the message, and the value of the header element is a dictionary. Elements  in the header can indicate the source entity (\u201cdeviceid\u201d) and target service (\u201cservice\u201d), target account (\u201cuserid\u201d), and message sequence number (\u201csequence\u201d), for example. Also, the \u201cversion\u201d element can indicate the synchronization protocol version being used. For example,  shows in the description  column that the current version is \u201c1.0\u201d. These elements  should all be present in the message.",{"@attributes":{"id":"p-0107","num":"0106"},"figref":"FIG. 2","b":"210"},"The value of the service element is a string that identifies the name of the target service, such as the sync server. The value for userid element is a string that indicates the target account for the message. The userid element can identify the principal that authenticated with the server  on the transport layer . The deviceid for the client device  is a string that uniquely identifies the device hardware. For iPhone\u00ae and iPod\u00ae touch devices, the deviceid element can be the Integrated Circuit Card (ICCID) value. Client devices  with a GSM radio may also send the msisdn element to indicate the phone number of the currently installed\/active Security Information Management (SIM) card. The msisdn value may change from one session to the next, for example when the user replaces the SIM card, without affecting synchronization behavior.","The final element is present in the header when the sender (e.g., the client device ) considers its side of the session to be complete. The final element is a Boolean with a value being TRUE. When final element flag is present, the session is considered complete. The sender may then free any session related resources, and the recipient is not required to send another message. The recipient may send another message to return outstanding command responses. However, the recipient should not send any further command requests. The values for the userid and service elements should be constant for all messages in a given session. The values for the deviceid element should remain constant for the sending entity. In other words, while the server  and the client device  may have different values, those values may not change.","The result element may be present in the header of a message to indicate the overall status for a message. For protocol brevity, an S_OK status is implied for any message without a header status. When detected that a message was not accepted, the result element is present in the header. The message may not be accepted when the data is malformed, or when the recipient encounters a session fatal condition. A non-OK status value indicates that the preceding message body was not processed, none of the message's commands were performed, and the session should be terminated. For example, a header status value of E_BadRequest () indicates that the previous message was malformed. A header status value of E_LimitExceeded () indicates that the previous message size exceeded the recipient's capability. Also, header status values of E_ServiceBusy (), E_ServiceUnavailable (), and E_RetryLater () indicate that the server  is experiencing difficulties in processing the request.",{"@attributes":{"id":"p-0111","num":"0110"},"figref":"FIG. 3","b":["300","300","310","320","310","312","314","316","318","319","312","300","300"]},"The body of the message includes an array of command requests and\/or command responses to be processed by the recipient. The body element is a required element of the message, and the value of the body is represented as an array of command or command response dictionaries. The body element may be empty when the sender has no commands to send. Commands in the body are processed in command sequence order.","Both the device  and the server  may send command requests and responses within the same message. This may depend on the state of the current session.","The commands in the synchronization protocol can fall into two general categories: (1) commands that affect the state of the sender, the recipient and the processing of other commands in the message or the session; and (2) commands that do not. Whether a given stateless command successfully executes may not implicitly affect other commands in the message. Stateful commands begin with a \u201ccommand family\u201d prefix (e.g. \u201csync-\u201d for all data synchronization commands). The command family prefix also provides a useful command namespace mechanism that allows the server  to support an arbitrary set of services for different client devices . In a given message, the commands in a given \u201ccommand family\u201d are processed in series, and if any command returns a nonsuccess status, subsequent commands in that family may not be processed at all. For example, a command response with a status code that indicates that the command has not been processed (e.g., E_CommandNotProcessed) can be returned in this case.","The recipient of a non-final message includes one or more command responses for each command in the session's next message. The recipient of a final message includes one or more command responses for each command when the final message was sent on a transport layer request (i.e. a transport response is expected.) The recipient of a final message may include one or more command responses for each command when the final message was sent on a transport layer response.","Three stateless primitive commands can be defined: \u201cget\u201d, \u201cput\u201d and \u201cdelete\u201d. These stateless commands may be used to implement arbitrary object exchange or Representational State Transfer (RESTful) semantics within the synchronization protocol . This can be used, for example, to perform management actions, to transfer device settings or capabilities, or to reference binary large objects or other meta data without requiring the server  to perform data synchronization operations.","When detected that the data for a given command or command response is a priori too large, the sender may split it into multiple fragments which are sent in consecutive messages. A given command may be split for various reasons and\/or constraints including memory constraints, transport constraints, etc.",{"@attributes":{"id":"p-0118","num":"0117"},"figref":"FIG. 4","b":["410","410","420","420","430","440"]},"Similar to the messages, the commands can assign an integral value to the sequence element that monotonically increases for each session. For example, the integral value can start at \u201c1\u201d and monotonically increase for each session. Based on the detected value of the sequence element, the recipient processes the commands in the sequence order.","The name element is a required element that indicates the command's name. The value of the name element is a string.","Command requests use the params element to pass the parameters for the command to the recipient. The params element is a required element having a value that includes a dictionary. Specific parameter elements and values may vary depending on the specific command as shown in .","The more element is required to be in the command when the sender needs to indicate that the command is split into fragments. Each fragment reuses the original command's \u201csequence\u201d value. When present, the value of the more element is the Boolean value \u201cTRUE\u201d.",{"@attributes":{"id":"p-0123","num":"0122"},"figref":"FIG. 5","b":"520"},"The third column  of the table shows whether the command response elements are required. In addition, for each command response, a short description  is presented in the fourth column of the table. For example, the name element describes the name of the command, such as \u201cget.\u201d Also, the sequence element for a command response corresponding to a command request should have an identical sequence value as the parent command request. Similar to the command, the params element is used by the command response to pass the parameters for the command response to the recipient. The params element is a required element having a value that includes a dictionary. Specific parameter elements and values may vary depending on the specific command response as shown in . In addition, the command responses use the same parameter values as their associated command requests.","The response element indicates that a message body item is a command response. Absence of the response element indicates that the body is a command request. The value of the response element is a Boolean with the value \u201cTRUE\u201d.","Command responses use the sequence element assigned with integral values. As described above, the values assigned to the sequence element correspond to a command sequence previously sent by the recipient. The recipient processes the command responses in sequence order based on the sequence values. Normally, the sender sends exactly one command response per command received in a given message. However, if the status for the command response is S_NotCompleted (indicating that processing of the command has not yet completed), the sender may send another command response for the command in a subsequent message. Alternatively one command response can be sent per command fragment if the command was split into various fragments.","The result element is a required element included in the command responses. The value of the result element is an array of one or more status items indicating the results of the command request. When a command could not be completed in a timely manner, for example before the client's transport request times out, the recipient may return a status, such as S_NotCompleted () to indicate that the command was not completed. This status does not indicate success or failure of the command, but instead informs the sender of the command that results will be available later in the session. When the session terminates before a final status is received, a failure status, such as E_Failed staus is assumed. Unknown command requests result in an unknown status value, such as E_UnknownCommand (). Also, unexpected commands for stateful commands result in a state error value, such as E_StateError ().","When the recipient encounters an error while processing a stateful command, subsequent stateful commands for the same command family in the message may not be processed at all. In this case, the status, such as E_CommandNotProcessed () is returned for these commands to indicate that the commands were not processed. Depending on the situation, the sender may reattempt those commands.","Command Definitions",{"@attributes":{"id":"p-0130","num":"0129"},"figref":"FIGS. 6","b":["7","8","9","10","11","12","13","14","15","16","17","18","19","140"]},"Primitive Commands","The commands listed in , , , ,  and  are stateless commands that can modify an arbitrary resource on the recipient. The available stateless commands include \u201cget\u201d, \u201cput\u201d and \u201cdelete\u201d. These stateless commands can implement object exchange or RESTful semantics within the synchronization protocol . Each command can include one or more parameters, such as \u201curi\u201d, \u201cvalue\u201d, \u201citem-type\u201d, \u201citems\u201d, \u201cidmap\u201d, \u201cuserid\u201d, \u201cauthtype\u201d, \u201cauth\u201d, \u201cversion\u201d, \u201canchors\u201d, etc. Some of these parameters are required, while others are optional.","For example, the \u201curi\u201d parameter is a required parameter with a string value assigned. The \u201curi\u201d parameter can specify the desired resource to access. The synchronization protocol  does not specify whether the \u201curi\u201d parameter represents an actual resource on the client device  or server , for example a file system path or a virtual resource. The type of the \u201cvalue\u201d parameter is determined by the client device  and the server . In addition, the type of the \u201cvalue\u201d parameter is not specified by the synchronization protocol . The logical type of the \u201cvalue\u201d parameter may be explicitly specified using the \u201citem-type\u201d parameter. Regardless, the representation of the \u201cvalue\u201d parameter must be a valid property list type.","The recipient may use the message's \u201cuserid\u201d as the authorized principal for the purposes of limiting access to the indicated URI. If the session authorization is insufficient, the \u201cuserid\u201d, \u201cauthtype\u201d and \u201cauth\u201d elements may optionally be included in the command.",{"@attributes":{"id":"p-0135","num":"0134"},"figref":"FIG. 6","b":["610","620","630","640"]},{"@attributes":{"id":"p-0136","num":"0135"},"figref":"FIG. 7","b":["710","720","730","740"]},{"@attributes":{"id":"p-0137","num":"0136"},"figref":"FIG. 8","b":["810","810","820","830","840","810"]},{"@attributes":{"id":"p-0138","num":"0137"},"figref":"FIG. 9","b":["910","930","920","940"]},{"@attributes":{"id":"p-0139","num":"0138"},"figref":"FIG. 10","b":["1010","1020","1030","1040","1010"]},{"@attributes":{"id":"p-0140","num":"0139"},"figref":"FIG. 11","b":["1110","1120","1130","1140"]},"The commands listed in , , , , , ,  and  are stateful commands. The synchronization protocol  also provides stateful sync-family commands and command responses. The stateful command includes sync-start, sync-changes, sync-commit and sync-cancel. These stateful commands enable structured data synchronization between the protocol client device  and server . Each of the stateful commands and command responses include the \u201curi\u201d parameter to identify a dataclass state machine to be affected by a given command.",{"@attributes":{"id":"p-0142","num":"0141"},"figref":"FIG. 12","b":["1210","1210","1220","1220","1230"]},"The table also includes a description  for each parameter. For example, the uri parameter indicates the dataclass names, such as the string \u201ccom.apple.Contacts\u201d for contacts or the string \u201ccom.apple.Calendars\u201d for calendars. When detected that the recipient does not support the dataclass, the status E_NotSupported () is returned. When detected that the dataclass is not enabled, the status E_NotAllowed () returned. In both these cases, the status \u201cparam-name\u201d element should be present and should have the value \u201curi\u201d to indicate that the uri parameter was the cause of the returned status. The anchors parameter contain information used during the sync negotiation phase. The information can include the requested sync mode (\u201cmode\u201d); the datastore versions (\u201cdevice_version\u201d,\u201cserverversion\u201d); and sync anchors (\u201clast_device_anchor\u201d,\u201cnext_device_anchor\u201d,\u201clast_server_anchor\u201d,\u201cnext_serveranchor\u201d). The \u201cdevice_version\u201d parameter for the anchor element describes the version of the client device . The \u201cserver_version\u201d parameter for the anchor element describes the version of the server process . The anchors parameter can include device, server, filter and reset anchors. The anchors can be used to request a sync mode. The default sync mode is the fast sync mode. The anchors can be used to specify a sync direction. The default sync direction is \u201ctwoway\u201d, which indicates that changes will be sent from the client device  to the server process  as well as from the server process  to the client device .",{"@attributes":{"id":"p-0144","num":"0143"},"figref":"FIG. 13","b":["1310","1320","1330","1340","110","120"]},"When the recipient is willing to sync using the submitted information, the recipient returns a OK status S_OK () with the sync-start command response. When the recipient is willing to sync with adjusted parameters (e.g. using a different sync mode than the client requested), the recipient returns a failed-negotiation status, such as E_NegotiationFailed (). When the recipient does not support the supplied sender's version (e.g. \u201cdevice_version\u201d) the recipient returns a status, such as the E_VersionNotSupported () status to indicate that the version is not supported. When the recipient does not support the desired sync direction (e.g. \u201cdirection\u201d), the recipient returns a status, such as the E_NotSupported () to indicate that desired sync direction is not supported. In all these cases, the status includes the \u201cparam-name\u201d parameter with the value \u201canchors\u201d indicating that elements in the \u201canchors\u201d parameter of the command were the cause of the unsuccessful status. In addition, the recipient can indicate the desired sync mode and anchors in the command response's \u201cparams\u201d dictionary.","When the client device  wishes to sync multiple dataclasses in parallel, the client device  sends a separate \u201csync-start\u201d command request for each dataclass as shown in  below. These commands are included in the same message to enable the server  to process the commands within the same sync job. When the server  accepts the \u201csync-start\u201d command received from the client device , the client device  begins sending \u201csync-changes\u201d commands. Sending the \u201csync-start\u201d command during a session which has already started syncing results in a state error status such as E_StateError () status.","When syncing multiple dataclasses in a single session, commands for each dataclass operate on distinct state machines. Usually, the server  waits until all dataclasses have completed the pull phase or cancelled before mingling the changed data.",{"@attributes":{"id":"p-0148","num":"0147"},"figref":"FIG. 14","b":["1410","1420","1430","1440"]},"The sync-changes command enables the client device  to send changes to the server . Alternatively, the server  can send updates to the client device . The uri parameter indicates the dataclass of the data items to be updated or changed. The type of data item being sent is indicated by the itemtype parameter. The itemtype parameter can indicate that the item parameter represents either full records (\u201crecords\u201d) or field-level changes (\u201cchanges\u201d). When detected that the client device  requires id mapping, data items are keyed by the device LUID in the items parameter. The format of the dictionaries for the items parameter depends on the item-type. The values of the items parameter are of homogeneous item-type. The items parameter can be an empty array to indicate that no more items need to be sent. For example, the empty array can indicate that there are no changes, or there are no records.","When detected that there are no device changes or the sync mode is \u201creset\u201d, the client device  sends a \u201csync-changes\u201d command with an empty array for the \u201citems\u201d parameter. The \u201cmore\u201d Boolean flag element is also included if all appropriate data items for the dataclass are not included in the command params. The \u201cmore\u201d Boolean flag element can be used to break up large amounts of synchronization data into smaller chunks. This is useful when the size of the data to be exchanged is larger than the capability of the recipient. For example, the recipient may have message size limitations. Alternatively, the \u201cmore\u201d Boolean flag element can enable exchange of multiple item-types for a given dataclass in a single session. When the server  has received the last \u201csync-changes\u201d chunk for all dataclasses from the client device , the server  synchronizes all supplied data with the central database. Then the client-server roles within the protocol session become reversed.","At this point, the client device  begins processing commands from the server . The client device  can also return command responses to the server . Any synchronization data updates from the server are then sent in \u201csync-changes\u201d commands. When no updates are needed, the server  sends a \u201csync-changes\u201d command with an empty array for the \u201citems\u201d parameter. While processing \u201csync-changes\u201d command requests from the server , the client device  responds to these commands, and includes any required mapping information for add transactions in the command response's \u201cparams\u201d using the \u201cidmap\u201d parameter. The \u201cidmap\u201d parameter is sent in a \u201csync-changes\u201d command from the client device to update existing mappings. For example, id mappings may be updated independent of the server  changing the data entities. Sending the \u201csync-changes\u201d command during a session before the \u201csync-start\u201d or after the \u201csync-commit\u201d or the \u201csync-cancel\u201d results in an error status, such as the E_StateError () status. The device  may omit sending \u201csync-changes\u201d command response and defer sending the \u201cidmap\u201d parameter until the \u201csync-changes\u201d command of the subsequent sync session. This may be done in order to reduce the number of transport roundtrips necessary to complete the sync session.",{"@attributes":{"id":"p-0152","num":"0151"},"figref":"FIG. 15","b":["1510","1520","1530","1540"]},{"@attributes":{"id":"p-0153","num":"0152"},"figref":"FIG. 16","b":["1610","1630"]},"The table also shows the parameter type  for the parameters. The uri parameter is a string type, and the anchors parameter is a dictionary. The table also shows the descriptions  of the parameters. The uri parameter indicates the dataclass to commit the sync changes. The anchors parameter is used by the client device  to send \u201cnext_device_anchor\u201d for the server  to store. In response, the server  sends the \u201cnext_server_anchor\u201d to the device  in the sync-commit command. In addition, the sync mode to use in the next sync is indicated and returned in the sync-commit command. Sending the \u201csync-commit\u201d command during a session before the final \u201csync-changes\u201d or after \u201csync-commit\u201d or \u201csync-cancel\u201d results in an error status, such as E_StateError () error status.",{"@attributes":{"id":"p-0155","num":"0154"},"figref":"FIG. 17","b":["1710","1720","1730","1740","110","120"]},{"@attributes":{"id":"p-0156","num":"0155"},"figref":"FIG. 18","b":["1810","1820","1830","1840","610","110","120"]},{"@attributes":{"id":"p-0157","num":"0156"},"figref":"FIG. 19","b":["1910","1920","1930","1940"]},"Status",{"@attributes":{"id":"p-0159","num":"0158"},"figref":"FIG. 20","b":["2010","2020","2030","2040"]},"The status resulting from the processing of a given command or message is represented by the \u201cstatus\u201d element. A single status element may appear in the message header. When the message was not processed, the corresponding status element is included in the message header. An array of \u201cstatus\u201d elements is included in the \u201cresults\u201d parameter of command responses.","Status elements indicate the results of a command request. A status item is a Dictionary. The dictionary may contain the \u201cstatus\u201d element and contain the \u201ccode\u201d elements to indicate the result status of the corresponding command request. The value for the \u201cstatus\u201d element is a string. The value for the \u201ccode\u201d element includes an integer string or an integer. The \u201cdescription\u201d element is an optional element that may be present in the command. The value of the \u201cdescription\u201d element is a string. The \u201cdescription\u201d element is purely informational and has no effect on the processing of the command.","The \u201cparam-name\u201d, \u201cparam-key\u201d and \u201cparam-index\u201d elements MAY be present. They are used to provide multi-status responses for certain commands. The \u201cparam-name\u201d value MUST be a String and indicates to which parameter in the command request this Status item corresponds. The \u201cparam-index\u201d value MUST be either a String or an Integer. It MUST be present if the \u201cparam-name\u201d element is present and it's value in the command request was an Array. The value of the \u201cparam-index\u201d indicates the index of the \u201cparam-name\u201d item in the command request to which this Status item corresponds. Index values are zero-based. The \u201cparam-key\u201d value MUST be a String. It MUST be present if the \u201cparam-name\u201d element is present and it's value in the command request was a Dictionary. The value of the \u201cparam-key\u201d indicates the value of the key of the \u201cparam-name\u201d item in the command request to which this Status item corresponds.","The \u201cparam-name\u201d \u201cparam-key\u201d and \u201cparam-index\u201d elements may also be present. They are not required elements and can be used to provide multi-status responses for certain commands. The value of the \u201cparam-name\u201d status element is a string that indicates to which parameter in the command request this status element corresponds. The value of the \u201cparam-index\u201d element can be either a string or an integer. The \u201cparam-index\u201d status element is included in the status dictionary when the \u201cparam-name\u201d status element is present and the value of the parameter matching the value of the \u201cparam-name\u201d status element in the command request was an array. The value of the \u201cparam-index\u201d status element indicates the index in the array parameter item for the parameter whose name corresponds to the value of the \u201cparam-name\u201d status element in the command request to which the status element corresponds. The value of the index status element is zero-based. The value of the \u201cparam-key\u201d element is a string that indicates to which parameter in the command request this status element corresponds. The value of the \u201cparam-key\u201d status element is a string. The \u201cparam-key\u201d status element is included in the status dictionary when the \u201cparam-name\u201d status element is present and the value of the parameter matching the value of the \u201cparam-name\u201d status element in the command request was a dictionary. The value of the \u201cparam-index\u201d status element indicates the key in the dictionary parameter item for the parameter whose name corresponds to the value of the \u201cparam-name\u201d status element in the command request to which the status element corresponds.","The indices in a status refer to the index of the param which resulted in the status, if the original param was an Array. Indices start counting from a zero-basis. This zero-basis mechanism enables the a sparse array of statuses to be returned. For example, consider a command (named \u201cexamplecommand\u201d) shown below that has a parameter \u201citems\u201d which is an array. Suppose that all but two of the items in the command are well formed with the second and fifth items having values (\u201cbad\u201d).",{"@attributes":{"id":"p-0165","num":"0164"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<dict>"]},{"entry":[{},"<key>name<\/key>"]},{"entry":[{},"<string>examplecommand<\/string>"]},{"entry":[{},"<key>sequence<\/key> <string>3<\/string>"]},{"entry":[{},"<key>params<\/key>"]},{"entry":[{},"<dict>"]},{"entry":[{},"<key>items<\/key>"]},{"entry":[{},"<array>"]},{"entry":[{},"<string>good<\/string>"]},{"entry":[{},"<string>bad<\/string>"]},{"entry":[{},"<string>good<\/string>"]},{"entry":[{},"<string>good<\/string>"]},{"entry":[{},"<string>bad<\/string>"]},{"entry":[{},"<string>good<\/string>"]},{"entry":[{},"<string>good<\/string>"]},{"entry":[{},"<\/array>"]},{"entry":[{},"<\/dict>"]},{"entry":[{},"<\/dict>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The command response to the above \u201cexamplecommand\u201d may be presented as follows:",{"@attributes":{"id":"p-0167","num":"0166"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<dict>"]},{"entry":[{},"<key>name<\/key>"]},{"entry":[{},"<string>examplecommand<\/string>"]},{"entry":[{},"<key>sequence<\/key> <string>3<\/string>"]},{"entry":[{},"<key>response<\/key> <true\/>"]},{"entry":[{},"<key>result<\/key>"]},{"entry":[{},"<array>"]},{"entry":[{},"<dict>"]},{"entry":[{},"<key>code<\/key>"]},{"entry":[{},"<string>602<\/string>"]},{"entry":[{},"<key>status<\/key>"]},{"entry":[{},"<string>S_Ok<\/string>"]},{"entry":[{},"<\/dict>"]},{"entry":[{},"<dict>"]},{"entry":[{},"<key>code<\/key>"]},{"entry":[{},"<string>607<\/string>"]},{"entry":[{},"<key>param-name<\/key>"]},{"entry":[{},"<string>items<\/string>"]},{"entry":[{},"<key>param-index<\/key>"]},{"entry":[{},"<string>1<\/string>"]},{"entry":[{},"<\/dict>"]},{"entry":[{},"<dict>"]},{"entry":[{},"<key>code<\/key>"]},{"entry":[{},"<string>607<\/string>"]},{"entry":[{},"<key>param-name<\/key>"]},{"entry":[{},"<string>items<\/string>"]},{"entry":[{},"<key>param-index<\/key>"]},{"entry":[{},"<string>4<\/string>"]},{"entry":[{},"<\/dict>"]},{"entry":[{},"<\/array>"]},{"entry":[{},"<\/dict>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This shows that there are multiple statuses to be returned for the command with all but the ones indicated being successful. However, the value supplied for the param \u201citems\u201d at index 1 (counting from zero, so, the second item in the command list) was a bad value (status code ). The same case for the 5th item (index ). This mechanism enables non-reporting of statuses for every other item that succeeded. This mechanism can significantly decrease the bandwidth usage requirement when numerous items are sent to the server and only a few fail.","When multiple statuses need to be returned in a single command response, a sparse array of statuses may be represented by including a status, such as S_MultiStatus () as the first element of the status array. Subsequent status elements may then indicate the parameter index value and a distinct status for any failed parameter elements for which the parameter type was an array. Alternatively, subsequent status elements may indicate the parameter key value and distinct status for any failed parameter elements for which the parameter type was a dictionary.","Status codes in a certain range, such as the status code range - can be reserved for general statuses. Status codes in another range, such as the range -, can be reserved for errors returned by the server and generally lead to termination of the current session.",{"@attributes":{"id":"p-0171","num":"0170"},"figref":"FIG. 21","b":["2110","2120","2130","2140"]},"The table describes success statuses and error statuses. In the example shown in , the \u201cS_OK\u201d status is assigned the code  to indicate a success. The parent element may be a message header or command response. The other success status is the \u201cS-MultiStatus\u201d status assigned to code  to indicate a success with multi-valued statuses. The parent element is a command response.","The error statuses include the \u201cE-NotCompleted\u201d status assigned to code  to indicate that command processing for the command has not yet completed. The parent element is a command response. The \u201cE_NotFound\u201d error status is assigned to code  to indicate that the indicated data object or URI was not found. The parent element is a command response. The \u201cE_NotAllowed\u201d error status is assigned to code  to indicate that the operation is not permitted that may be due to insufficient access rights, for example. The parent element is a command response. The \u201cE_MissingParam\u201d error status is assigned to code  to indicate that the command was missing a required parameter. The \u201cE_ParamError\u201d error status is assigned to code  to indicate that a supplied parameter was incorrect. The parent element is a command response. The \u201cE_BadValue\u201d error status is assigned to code  to indicate that a bad value was supplied. The parent element is a message header or command response. The \u201cE_UnknownCommand\u201d is assigned to code  to indicate that an unknown command was issued and ignored. The parent element is a command response. The \u201cE_CommandNotProcessed\u201d error status is assigned to code  to indicate that a command was not processed due to errors processing a previous command. The parent element is a command response. The \u201cE_StateError\u201d is an error status assigned to code  to indicate that an unexpected command was received based on the command family's current state machine. The parent element is a command response. The \u201cE_LimitExceeded\u201d error status is assigned to code  to indicate that too many items were supplied. The parent element is a command response. The \u201cE_VersionNotSupported\u201d error status is assigned to code  to indicate that the protocol or command version is not supported. The parent element is a message header or command response. The \u201cE_NegotiationFailed\u201d error status is assigned to code  to indicate that the sync mode negotiation failed. The parent element is a command response. The \u201cE_NotSupported\u201d error status is assigned to code  to indicate that an unsupported or unimplemented operation was attempted. The parent element is a message header or command response. The \u201cE_Failed\u201d error status is assigned to code  to indicate a generic failure. The parent element is a message header or command response. The \u201cE_Canceled\u201d error status is assigned to code  to indicate that the current state machine has been cancelled. The parent element is a command response. The \u201cE_ServiceBusy\u201d error status is assigned to code  to indicate that the server  is too busy and could not process the message. This status code also indicates that the device  should retry the command again soon. The parent code is a message header. The \u201cE_ServiceUnavailable\u201d error status is assigned to code  to indicate that the serve  is unavailable and could not process the message. This status code also indicates that the device  should retry again soon. The parent element is a message header. The \u201cE_ServiceError\u201d error status is assigned to code  to indicate that the server  had an internal error. The parent element is a message header or command response. The \u201cE_BadRequest\u201d error status is assigned to code  to indicate that the server  could not understand the message. The parent element is a message header. The \u201cE_RetryLater\u201d error status is assigned to code  to indicate that the server  needs the client device  to retry at a later time. The parent element is a message header.",{"@attributes":{"id":"p-0174","num":"0173"},"figref":"FIG. 22"},"The effect of receiving the \u201cE_NotFound\u201d error status is a failure for the get, put and delete commands. For the sync-start, sync-changes, sync-cancel and sync-commit commands, the dataclass state machine is terminated. The effect of receiving the \u201cE_NotAllowed\u201d error status is a failure for the get, put and delete commands. For the sync-start, sync-changes, sync-cancel and sync-commit commands, the dataclass state machine is terminated. The effect of receiving the \u201cE_MissingParam\u201d error status is a failure for the get, put and delete commands. For the sync-start, sync-changes, sync-cancel and sync-commit commands, the dataclass state machine is terminated. In addition, the message is not processed. The effect of receiving the \u201cE_ParamError\u201d error status is a failure for the get, put and delete commands. For the sync-start, sync-changes, sync-cancel and sync-commit commands, the dataclass state machine is terminated. The effect of receiving the \u201cE_BadValue\u201d error status is a failure for the get, put and delete commands. For the sync-start, sync-changes, sync-cancel and sync-commit commands, the dataclass state machine is terminated. In addition, the message is not processed. The effect of receiving the \u201cE_UnknownCommand\u201d is a failure for the get, put and delete commands. For the sync-start, sync-changes, sync-cancel and sync-commit commands, the dataclass state machine is terminated. The effect of receiving the \u201cE_CommandNotProcessed\u201d error status is a failure for the get, put and delete, sync-start, sync-changes, sync-cancel and sync-commit commands. The effect of receiving the \u201cE_StateError\u201d error status is that for the sync-start, sync-changes, sync-cancel and sync-commit commands, the dataclass state machine is terminated. The effect of receiving the \u201cE_LimitExceeded\u201d error status is a failure for the get, put and delete commands. For the sync-start, sync-changes, sync-cancel and sync-commit commands, the dataclass state machine is terminated. In addition, the message is not processed. The effect of receiving the \u201cE_VersionNotSupported\u201d error status is a failure for the get, put and delete commands. For the sync-start, sync-changes, sync-cancel and sync-commit commands, the dataclass state machine is terminated. In addition, the session will terminate. The effect of receiving the \u201cE_NegotiationFailed\u201d error status is a failure for the sync-start command. The effect of receiving the \u201cE_NotSupported\u201d error status is a failure for the get, put and delete commands. For the sync-start, sync-changes, sync-cancel and sync-commit commands, the dataclass state machine is terminated. The effect of receiving the \u201cE_Failed\u201d error status is a failure for the get, put and delete commands. For the sync-start, sync-changes, sync-cancel and sync-commit commands, the dataclass state machine is terminated. In addition, the session will terminate. The effect of receiving the \u201cE_Canceled\u201d error status is that the dataclass state machine is terminated for the sync-start, sync-changes, sync-cancel and sync-commit commands. The effect of receiving the \u201cE_ServiceBusy\u201d error status is that the session will be terminated. The effect of receiving the \u201cE_ServiceUnavailable\u201d error status is that the session will be terminated. The effect of receiving the \u201cE_ServiceError\u201d error status is that the session will be terminated for all commands. The effect of receiving the \u201cE_BadRequest\u201d error status is that the session will be terminated. The effect of receiving the \u201cE_RetryLater\u201d error status is that the session will be terminated.","Anchors","Synchronization state information such as the sync mode, sync direction, agent versions, and sync anchors are exchanged between the device and server at various times. The \u201canchors\u201d element included in the commands and command responses, as shown in , is used to bundle this information. The \u201canchors\u201d element is implemented as a Dictionary.",{"@attributes":{"id":"p-0178","num":"0177"},"figref":"FIG. 23","b":["2310","2320","2330"]},"The \u201cdirection\u201d key represents the desired or negotiated sync direction. The value of the direction key can optionally be present in the anchors element. When present, the value of the direction key is implemented as a String, and the string value can include \u201cto_server\u201d, \u201cto_device\u201d, or \u201ctwoway\u201d. Thus, these values indicate the sync direction as syncing from the device  to the server , syncing from the server  to the device  or both. When the value of the direction key is not present, the receiver infers the value as \u201ctwoway\u201d.","The \u201cdevice_version\u201d key is sent by the device  and represents the device datasource agent version. When present, the value of the device_version key is implemented as a String. This information can be used by the server  to infer behaviors or capabilities specific to a given version of the device software. The server  can determine that synchronization is not permitted with a given device agent version, for example.","The \u201cserver_version\u201d key is sent by the server  and represents the server's datasource agent version. When present, the value of the server_version key is implemented as a String. This information can be used by the device  to infer behaviors or capabilities specific to a given version of the server software. The device  can determine that synchronization is not permitted with a given server agent version, for example.","The actual anchors are exchanged using the keys \u201clast_device_anchor\u201d, \u201cnext_device_anchor\u201d, \u201clastserveranchor\u201d and \u201cnext_serveranchor\u201d. The value for each of these keys can be present in the \u201canchors\u201d dictionary. When present, the value for each of these keys is implemented as a String. When not present, the recipient infers the last known value for the keys.","The values of the keys for the anchors element are considered opaque, and an entity should not attempt to decode or infer meaning from another entity's anchor keys. For example, a client device should not make any assumptions regarding the \u201cnext_server_anchor\u201d or the \u201clast_server_anchor\u201d.","Synchronization Protocol Features","When the client device  sends the differences (i.e., the changed, deleted or new data) to the server , the client device  indicates whether \u201crecord level differences\u201d (RLD) or \u201cfield level differences\u201d (FLD) is used via the \u201citem-type\u201d parameter of the \u201csync-changes\u201d command. The value \u201cchange\u201d in the \u201citem-type\u201d parameter indicates FLD, while the value \u201crecord\u201d indicates RLD. Devices that support RLD send the entire data set for a given changed record for a particular dataclass. In contrast, devices that support FLD send only the changed properties for changed records in the data set for the dataclass.","An optimization is supported for RLD, which enables the client device  to send a special value, such as \u201c+**no-change**+\u201d indicating that a given property has not changed, and has not been deleted. This helps to avoid sending large data items, such as contacts images that have not changed.","Id Mapping","When detecting that the datastore, in the client device  for example, for a dataclass wishes to use id mapping, the \u201cidmap\u201d parameter can be included in the command or the command response for a \u201csync-changes\u201d command from the server . The value of the \u201cidmap\u201d parameter is a dictionary that maps server universal unique identifications (UUIDs) to client device  local unique identifications (LUIDs). Thereafter, the server  refers to the mapped entity using the client device  LUID.","Optimizations","Broken sessions can cause message\/packet loss for wireless communications. The synchronization protocol  enables recovery from broken sessions without falling out of \u201cfast\u201d sync. By maintaining \u201cfast\u201d sync even in the event of a broken session, the number of communication round trips are reduced. The reduced number of roundtrips can reduce or minimize message\/packet loss.","The synchronization protocol  is designed to minimize the number of transport messages (HTTP request\/response roundtrips) in normal circumstances. The ability to remain in \u201cfast\u201d sync mode can minimize the bandwidth usage and effort for each sync process by exchanging smaller amounts of data. Moreover, frequent fast syncs mean the device \/server  pair never drift much from one another. In other words, the device  and the server  remain more in sync than possible without fast sync. Also, this wireless \u201ctrickle syncing\u201d can yield a better user experience.","Certain events can cause a fast syncing pair (e.g., client device  and server  pair) to resort to a less efficient sync mode (e.g., slow sync mode). These events can include device data corruption, interrupted sync sessions, failure to agree on consistent sync anchors, data structure reset (e.g., when a user pushed an entirely new data set for the dataclass from another machine). The synchronization protocol  can avoid being pessimistic and minimize ore eliminate the need to fall back to slow sync whenever a problem occurs.","The synchronization protocol  implements various techniques to optimize data sync between the client device  and the server . For example, optimization techniques include sync phase compression that enables optimistic negotiation and commit; implementing multiple dataclass state machines in parallel; using sync anchor checkpoints; and enable session robustness.",{"@attributes":{"id":"p-0194","num":"0193"},"figref":["FIG. 24","FIG. 24"],"b":["110","120","2410","2420","2430","2440","2450","2460","1","2410","110","120","1","2410","1","2310","2","2420","1","2410","2","2420","2450","2460"]},{"@attributes":{"id":"p-0195","num":"0194"},"figref":["FIG. 25","FIG. 25"],"b":["110","120","110","110","110","2510","120","120","110","2510","120","2520","120","2520","2530","110","120"]},{"@attributes":{"id":"p-0196","num":"0195"},"figref":["FIG. 26","FIG. 26"],"b":["110","120","110","2610","120"]},"In the example shown in , the sync server  compresses the push and commit phases by sending its \u201csync-changes\u201d and \u201csync-commit\u201d commands for a given dataclass in the same message. In response to sync-start and sync-change commands, the server  replies with a sync-start command response (OK, dataclass, anchors) and sync-change command response (OK, dataclass) in the second message . In addition, the server  can include a sync-changes command (dataclass, changes) and a sync-commit command (dataclass anchors) in the second message  to complete one round trip. Thus, the optimistic approach can complete data synchronization in a single HTTP roundtrip.","A data sync can be completed in two roundtrips when the client device  responds to the server's  \u201csync-changes\u201d command in the second message  with an optional message for id mapping in the second round trip . The client device  can also send a sync-commit response in the optional message.","In some implementations, the client device  may defer sending id mappings to the server  until a subsequent session and may omit sending the sync-commit response, since the server  can infer that the commands were received and processed by comparing the sync anchors sent in the subsequent session.  shows an example data synchronization between a client and a server, where the device omits sending the command response to \u201csync-changes\u201d or \u201csync-commit\u201d when the server's previous message was final. In that case, any pending id mappings (if necessary) is sent to the server  in the subsequent sync session.","In the first message , the client device  compresses the negotiation and pull phases as described with respect to . In response, the server  sends a second message  with the push and commit phases compressed as described with respect to . The first session is completed in one round trip.","A second sync session is initiated by the client device  with the pull and negotiation phases compressed in the third message . In addition, the pending id mappings leftover from the first session is sent to the server . The server  responds in the fourth message  with sync-changes and sync-commit commands.",{"@attributes":{"id":"p-0202","num":"0201"},"figref":"FIG. 28","b":["110","110","2810","120","120"]},"In this slow sync mode, the client device  sends a sync-start command with the dataclass, anchors and the slow sync mode identified in the first message . The server  responds in the second message  with a sync-start response. In the third message  (second round trip), the client device  sends a sync-changes command for a dataclass. The server  responds in the next message  by including a sync-changes response (OK, dataclass), sync-changes command (dataclass) and sync-commit command (dataclass, anchors). In the third round trip , the client device  sends a sync-changes response (OK, dataclass, idmap) and a sync-commit response (OK).",{"@attributes":{"id":"p-0204","num":"0203"},"figref":"FIG. 29"},"In the example shown in , multiple dataclasses, such as contacts, calendars and bookmarks are synced in parallel. In the first message , the client device  sends sync-start commands for these dataclasses in parallel. In the same message , the client device  also sends sync-changes command for the multiple dataclasses. The server  sends a response  with sync-start responses and sync-changes responses for the multiple dataclasses. For example, the sync-start response from the server  states that the calendars dataclass is reset on the server  due to a failed negotiation. In addition, the sync-changes response for the calendars states that the changes have not been processed for the calendars dataclass. The sync-start commands for contacts and bookmarks are successful as shown by the OK status of the sync-start response. The sync-changes commands for contacts and bookmarks have not completed, as shown by the S_NotCompleted status of the sync-changes responses.","In the next message , the client device  sends another sync-start command requesting a reset sync (the sync mode requested by the server in the previous calendars sync-start command response) and sync-changes command for the calendar dataclass with an empty items parameter. The server  responds in the next message  with a sync-start response and a sync-changes response for the contacts, calendars and bookmarks dataclasses; a sync-changes response for the contacts and bookmarks; sync changes command for calendars indicating that more changes are pending; and sync-commit command for contacts and bookmarks. These two message  and  make up the second round trip.","The third round trip begins with a message  from the client device with sync-changes response for contacts, calendars and bookmarks. The message  includes sync-commit responses for the contacts and bookmarks. To complete the third round trip, the server  sends a sync-changes command for dataclasses and sync-commit commands to the client device  in the next message . Thus, in just three transport protocol roundtrips, multiple dataclasses syncing, sync mode renegotiation (calendars were reset on the server), and split sync-changes (calendar changes from the server were sent in message  and message ) can be completed.","An optional fourth roundtrip  can be implemented to enable the client device  to send a sync-changes response for the calendars with idmap and a sync-commit response to the server .","The server  does not perform the mingle phase until all dataclasses have completed the pull phase (i.e. upon receipt of the third message). This enables the server  to perform all work in a single sync job. The server sends S_NotCompleted for the dataclasses other dataclasses until all the client  changes for all dataclasses has been received by the server .","Sync Anchor Checkpoints","The synchronization protocol uses the \u201csync anchors\u201d parameter in the commands and command responses to organize and maintain trackable sync sessions. The server  can manage the anchors in the commands and the command responses vis-\u00e0-vis its internal versioning methods.","Sync anchors are opaque data that the client device  and the server  exchange during the sync process. The anchors can be exchanged during the negotiation phase to determine the sync session's sync mode. Then, during the commit phase, a new set of anchors can be exchanged and persisted for use during the following sync sessions. By comparison, other sync protocols use the anchors at the beginning of the sync session, and the anchors are updated only when the sync session completes successfully, or are rolled back if the session is cancelled or terminates unexpectedly.","Any discrepancy between expected and actual anchors during negotiation (known as anchor mismatch) can result in a slow sync, or at the very least, retransmission of all data from the failed sync session. On an unreliable data-network, this can lead to a situation where no progress can be made and synchronization with the server is effectively blocked from successfully completing a sync until external conditions change. Unexpected session failures can also lead to anchor mismatches on the next sync session.","The OTA synchronization protocol  enables the server  to optionally return updated anchors at various checkpoints during a sync session. The \u201canchor\u201d parameter may be present in any sync family command or command response. A checkpoint anchor contains the \u201cnext_server anchor\u201d element and may contain the \u201cmode\u201d element. This enables fine-grained updating of sync anchors to reduce the likelihood and impact of anchor mismatches. Each server anchor is encoded with information that provides the server  with precise information regarding the internal server state at the time the anchor was generated. For example, the server anchor can be encoded with information on whether the changes requested from the client device  have been mingled with the central database. The server anchor can also be encoded with information on which updates have been accepted by the client device . Further, the server anchor can be encoded with information on whether the sync session was completed normally. Other internal server states can be encoded in the server anchor.","Example anchor checkpoints can include the \u201cend of server mingle phase\u201d in response to the client device's final \u201csync-changes\u201d command. The anchor checkpoints can also include the point during a split \u201csync-changes\u201d and the commit phase among others.","The server  can intelligently decide the time and location to add the checkpoint anchors. When the checkpoint anchors are placed in a \u201csync-changes\u201d command, the checkpoint anchors guarantee that the received data set enforces the data integrity requirements of the dataclass's schema. For example, the data integrity requirements can include having no references to unknown entities in a check pointed data set. After the pull phase is complete, the most recent checkpoint anchors may be saved by the client device , even if the sync session is cancelled.","The sync server  will expire the checkpoint anchors when they are no longer needed, or when the server needs to release associated server-side resources used to maintain the checkpoint state. When the client device  supplies an unknown or expired checkpoint anchor, the sync session will still fall into slow sync mode.","During the next sync session's negotiation phase, the \u201csync-start\u201d command, the client device  sends its last saved anchors to the server . The server  uses the information encoded in these anchors to start a sync session from the most recent saved checkpoint, even if the previous sync session terminated unexpectedly or a \u201csync-commit\u201d command response was not explicitly returned to the server . When the client device  receives such anchors during a sync session, the client device  retains the most recent anchor from the server, and save its value to send in the \u201csync-start\u201d command for the next sync session.",{"@attributes":{"id":"p-0219","num":"0218"},"figref":"FIG. 30","b":["110","3010","110","0","3010","0","110","120","3020","3030","3040","3050","3060","120","1","2","3","3020","3030","3040","3050","3060"]},"Upon receiving and processing each message containing an \u201canchors\u201d element from the sync server , the client device  updates its anchor. When the sync session become interrupted or a message lost, the client device supplies the last anchor it successfully processed in the \u201csync-start\u201d command of the next session. Depending on which anchor value is received, the sync server  can infer which actions must be taken to complete the previous sync as necessary. Thus, incremental synchronization progress can be made even on extremely fragile wireless networks or when large data sets need to be sent.",{"@attributes":{"id":"p-0221","num":"0220"},"figref":"FIG. 31","b":["3110","3120","3130","0","1","120","110","120","1","110","2","110","2","110","3"]},"Device Settings","The synchronization protocol  provides a mechanism for the server  to dynamically request device settings and capabilities. The \u201cget\u201d and \u201cput\u201d commands may be used to exchange information. At anytime, the server  may send a \u201cget\u201d command with the \u201curi\u201d parameter having the value \u201cdeviceinfo\u201d to request device settings and capabilities, for example. Alternatively, the client device  may send a \u201cput\u201d command with the same \u201curi\u201d parameter to the server . The value of the \u201curi\u201d parameter is a dictionary containing various key-value pairs. When present, the value for \u201cuserid\u201d represents the authenticating principle and is implemented as a String. When present, the value for \u201cauthtype\u201d represents the authentication scheme and is implemented as a String. When present, the value for \u201cauth\u201d represents the authentication credential and is represented as a String. When the recipient is willing to perform the operation, the recipient returns a success status, such as status S_OK (). When the requested URI is unknown, the recipient returns a status, such as the status E_NotFound () to indicate the URI was not found and is unknown. When the requested operation is not permitted, for example the authorized principle is not allowed to delete the URI, the recipient returns a status, such as the status E_NotAllowed () to indicate that the requested operation is not permitted. When the requested operation could not be performed because the supplied data was incorrect, the recipient returns a status, such as the status E_BadValue () to indicate that the requested operation could not be performed. When the requested operation could not be performed because the supplied \u201citemtype\u201d was incorrect, the recipient returns a status, such as the status E_NotSupported () to indicate that the requested operation is not supported.",{"@attributes":{"id":"p-0224","num":"0223"},"figref":"FIG. 32","b":["3210","3220","3220","3230","110"]},"When the client device  first syncs with the server , the server  requests for device information by sending a \u201cget\u201d command. Thereafter, when the device information changes, the client device  sends the changed device information to the server  by sending a \u201cput\u201d command.","Filtering","Filtering is the ability to constrain a set of data items synchronized with the client device  based on the values in the data items. For example, a user may want to sync only the contacts contained within a certain set of groups, or the calendar events within a certain time window surrounding the current date.","In a data sharing\/managing application, such as iTunes\u00ae filter settings are enforced by the computer during cable syncing to constrain or filter the set of data items sent to the client device , such as iPhone\u00ae. The synchronization protocol  provides similar filtering functionality in a wireless sync solution. The same filter settings from iTunes\u00ae is enforced by the server  without requiring any user action. Thus, the filtering can be performed automatically. Alternatively, a user interface (UI) on the client device  can be presented to the user to enable the user to display and edit the filter settings to be enforced.","The synchronization protocol  enables the filter settings to be exchanged between the client device  and the server  using primitive commands. The filter information is specified using a \u201curi\u201d parameter of the form \u201cdataclass\/<dataclassname>\/filter\u201d. The value of the filter information is a dictionary.",{"@attributes":{"id":"p-0230","num":"0229"},"figref":"FIG. 33","b":["3310","3320","120","120","120"]},"The default_container key describes the identification (LUID) of the container entity, such as the group ID for contacts and calendar ID for events. The constrain_containers key describes the set of LUIDs of container entities to include, such as the set of Groups to include. The discard_after_days key describes the number of days after which events older than the described number of days should be deleted.",{"@attributes":{"id":"p-0232","num":"0231"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0233","num":"0232"},"figref":["FIG. 35","FIG. 35","FIG. 35"],"b":["110","3510","120"]},"In the second message , the server  responds by sending a sync-start command response with the status \u201cS_OK\u201d to indicate a successful negotiation for the contacts dataclass. In addition, anchors are used to indicate the checkpoint. Also, the server  sends a sync-changes command for the contacts dataclass with the \u201cmore\u201d Boolean flag indicate that not all appropriate data items for the dataclass are included in the command params. Further, the second message  can be include a put command response with a \u201cS_OK\u201d status indicating a successful put.","In the third message , the client device  includes a sync-changes command response with the \u201cS_OK\u201d status for the contacts dataclass indicated by the uri parameter. Also, idmap is included to provide GUID-LUID mapping, for example. In the fourth message , the server  sends a sync changes command with the uri parameter indicating the contacts dataclass. Also, the \u201cmore\u201d Boolean is included to indicate that more data will follow. In the fifth message , the client device  sends a sync-changes command response with a status \u201cS_OK\u201d to indicate a successful update for the contacts dataclass. In the sixth message , the server  sends a sync-changes command and a sync-commit command for the contacts dataclass. The client device  responds in the seventh message  with a sync-changes command response indicating a successful update. The client device  also includes a sync-commit response (OK) to indicate the client device has committed the changes. The last message  has an empty message body to indicate a sync session's final message.",{"@attributes":{"id":"p-0236","num":"0235"},"figref":["FIGS. 36","FIG. 36","FIGS. 37"],"b":["37","37","38","38","38","38","39","39","39","40","40","37","110","120"],"i":["a","b","a","b","c","d","a","b","c","a ","b ","a ","b "]},{"@attributes":{"id":"p-0237","num":"0236"},"figref":"FIGS. 38","i":["a","b","c ","d "],"b":["38","38","38","120","110","120","120","120","110"]},{"@attributes":{"id":"p-0238","num":"0237"},"figref":"FIGS. 39","i":["a","b ","c "],"b":["39","39","110","110","120"]},{"@attributes":{"id":"p-0239","num":"0238"},"figref":"FIGS. 40","i":["a ","b "],"b":["40","120","120","120"]},{"@attributes":{"id":"p-0240","num":"0239"},"figref":["FIGS. 41","FIG. 41","FIGS. 42"],"b":["42","42","43","43","43","110","120","42","110"],"i":["a","b","a","b ","c ","a ","b "]},{"@attributes":{"id":"p-0241","num":"0240"},"figref":"FIGS. 43","i":["a","b ","c "],"b":["43","43","120","110","110","120","120","120","120","110"]},{"@attributes":{"id":"p-0242","num":"0241"},"figref":"FIGS. 44","i":["a ","b "],"b":["44","110","120","4402","110","120","4402"]},"The server  responds  to the negotiation phase by sending a message to the client device  with a sync-start command response. A determination  is made on whether the negotiation is a success. The dataclass indicated by the uri parameter is detected and analyzed to determine whether the server  supports and enables  the dataclass. When detected that the dataclass is not supported, an error status such as \u201cE_NotSupported ()\u201d is generated . The generated error status can be included in the sync-start command response to indicate that the dataclass is not supported. When detected that the server  does not enable the dataclass, an error status such as \u201cE_NotAllowed ()\u201d is generated . The generated status is included in the sync-start command response to indicate that the dataclass is not enabled. When detected that the dataclass is supported and enabled, a success status such as \u201cS_OK\u201d is generated . The generated status is included in the sync-start command response to indicate that the server  supports and enables the dataclass.","When the anchors parameter of the sync-start command includes a requested sync mode, the requested sync mode is analyzed to determine whether the server  accepts  the sync mode. When the sync mode is not accepted by the server , an error status such as \u201cE_NegotiationFailed ()\u201d is generated . The generated status is included in the sync-start command response to indicate that the requested sync mode is not accepted. The server  may decide  whether to suggest a different sync mode to use. When the server  is willing to sync in a different mode, the suggested different mode is included  in the anchors parameter in the sync-start command response.","When the requested sync mode is accepted, a success status such as \u201cS_OK\u201d is generated . The generated success status is included in the sync-start command response.","When detected that the negotiation is successful, as indicated by the \u201cS_OK\u201d status, the sync session proceeds  to a pull phase. When the sync mode is fast, the client device  sends the changed records to the server . When the sync mode is \u201cslow\u201d, all records are sent to the server . The changes are sent using the sync-changes stateful commands. The server  responds to the sync-changes command with the corresponding sync-changes command response to indicate whether the changes have been accepted. The success status \u201cS_OK\u201d indicates that the changes have been accepted.","When all changes have been received, the server  proceeds  to the mingle phase. When syncing multiple dataclasses in a single session, the sync-changes commands for each dataclass will have distinct state machines. However, the server  waits until all dataclasses have completed the pull phase or cancelled before proceeding to the mingling phase. Any detected invalid changes may be rejected by the server .","During the mingle phase, the server decides  whether any conflicts exists for the dataclass. When detected that conflicts exist, the server  decides  whether to resolve the conflicts itself or whether to let the user or client device  resolve the conflicts. When the server  resolves the conflicts, the server  can rely on heuristics to resolve the conflicts. For example, the client device  initiating the most recent sync may be selected as the winner.","For some instances such as the dataclass and\/or data item, the user\/client device  may be selected as the one to resolve the conflicts. Then the detected conflicts are sent to the client device  to enable the client device  to resolve the conflicts. Also, the detected conflicts can be presented to the user by displaying the conflicts on a display unit on the client device , for example. The user can resolve the conflict manually. The result of the conflict resolution may then be sent from the device  to the server  during the next sync session.","The changes from the server  (recipient) can be sent to the client device  during the push phase . The server  can send a message to the client device with sync-changes commands to push the changes to the client device .","Finally, once all updates have been received, the commit phase is entered 4416. Both sides agree that the sync was successful, persist their current sync anchors, and commit the exchanged data to their respective data stores. In the commit phase, messages are sent with sync-commit commands and command responses.","Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer program products, i.e., one or more modules of computer program instructions encoded on a tangible program carrier for execution by, or to control the operation of, data processing apparatus. The tangible program carrier can be a propagated signal or a computer readable medium. The propagated signal is an artificially generated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a computer. The computer readable medium can be a machine-readable storage device, a machine-readable storage substrate, a memory device, a composition of matter effecting a machine-readable propagated signal, or a combination of one or more of them.","The term \u201cdata processing apparatus\u201d encompasses all apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers. The apparatus can include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.","A computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, or declarative or procedural languages, and it can be deployed in any form, including as a stand alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.","The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit).","Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for performing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device.","Computer readable media suitable for storing computer program instructions and data include all forms of non volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and CD ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.","To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, input from the user can be received in any form, including acoustic, speech, or tactile input.","Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described is this specification, or any combination of one or more such back end, middleware, or front end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (\u201cLAN\u201d) and a wide area network (\u201cWAN\u201d), e.g., the Internet.","The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.","While this specification contains many specifics, these should not be construed as limitations on the scope of any invention or of what may be claimed, but rather as descriptions of features that may be specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.","Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.","Only a few implementations and examples are described and other implementations, enhancements and variations can be made based on what is described and illustrated in this application."],"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1C"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 27","b":["1","2"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIGS. 37","i":["a ","b "],"b":"37"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIGS. 38","i":["a","b","c ","d "],"b":["38","38","38"]},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIGS. 39","i":["a","b ","c "],"b":["39","39"]},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIGS. 40","i":["a ","b "],"b":"40"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 41"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIGS. 42","i":["a ","b "],"b":"42"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIGS. 43","i":["a","b ","c "],"b":["43","43"]},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIGS. 44","i":["a ","b "],"b":"44"}]},"DETDESC":[{},{}]}
