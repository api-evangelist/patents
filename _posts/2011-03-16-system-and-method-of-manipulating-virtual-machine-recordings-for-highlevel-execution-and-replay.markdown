---
title: System and method of manipulating virtual machine recordings for high-level execution and replay
abstract: Execution behavior for processes within a virtual machine is recorded for subsequent replay. The execution behavior comprises a detailed, low-level recording of state changes for processes within the virtual machine. The low-level recording is processed via replay to produce a sliced recording that conforms to time, abstraction, and security requirements for a specific replay scenario. Multiple stages of replay may be arbitrarily stacked to generate different crosscut versions of a common low-level recording.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09063766&OS=09063766&RS=09063766
owner: VMware, Inc.
number: 09063766
owner_city: Palo Alto
owner_country: US
publication_date: 20110316
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","A. Virtualization Platform Architecture","B. Recording and Replay","C. Slicing a Recording Log","D. Additional Embodiments"],"p":["Some virtual machine platforms provide a capability of generating a recording of the execution behavior of an instantiated virtual machine for replay at a later time. The recording is generated by taking an initial snapshot of the complete state of the virtual machine at a certain point in time and recording certain subsequent state changes. The complete state of the virtual machine includes its entire memory, which can comprise multiple gigabytes of data, and its entire device state, including associated mass storage, which can comprise hundreds of gigabytes of data.","One usage model for recording and replay is to facilitate debugging. A session comprises a specific instance of execution for a software application. Replaying a recorded session or sessions replicates any errors that arose during the original execution of the application or applications. Recording and replay enables an application end user to provide to the application vendor a recording that includes errors encountered during the application's execution by the end user. The application vendor can, in turn, replay the application to reproduce identical errors to debug the application.","An abstraction level is commonly selected prior to recording a session. When choosing a conventional record-replay solution, a system administrator must choose, prior to execution, how comprehensively to record each session and at what abstraction level to record. Unfortunately, such choices frequently do not match well with how a recording is ultimately used. A recording may contain too little information to support an end use of replay, or the recording may contain confidential information that should not be released, for example, to a third party software vendor. Security and privacy issues relating to potentially confidential data stored in a snapshot limit the usefulness of conventional recordings. Availability of an appropriately selected abstraction level for a given recording further limits overall usefulness of conventional record-replay techniques.","A method for generating a replay file for a computer system, according to an embodiment of the invention, includes the steps of reading a unit of replay data from a log file that includes state information, configuring a machine based on the state information included in the unit of replay data, replaying in the machine a segment of executable instructions associated with the unit of replay data to generate output data, determining that the unit of replay data satisfies a selection rule, and recording the output data in the replay file.","A method for generating a replay file for a computer system, according to another embodiment of the invention, includes the steps of reading a unit of replay data from a log file that includes state information, generating from the unit of replay data output data that includes a data structure of a tainted data object, determining that a data object is tainted, redacting contents of the tainted data object from the output data, and recording the output data in the replay file.","Further embodiments of the present invention include, without limitation, a non-transitory computer-readable storage medium that includes instructions that enable a processing unit to implement one or more aspects of the above methods as well as a computer system configured to implement one or more aspects of the above methods.","In some embodiments of the present invention replay log files may be culled using arbitrary filtering techniques without burdening a recording phase of the replay log file, thereby yielding more realistic results from a performance perspective. Furthermore, in some embodiments, private data may be redacted from resulting log files without loss of log file accuracy during a replay or debugging phase.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1","b":["100","102","102","104","106","108","110","112","102","120","112","102","104","106","108","110","120","124","126","128","130","122","132","120","122","138","112","120","112"]},"In an alternative embodiment, a host operating system  is installed on hardware platform . In such an embodiment, the virtualization layer  operates above an abstraction level provided by the host operating system . The virtualization layer  performs similar functions to a hypervisor except that communication from the virtualization layer  to the hardware platform  is via the host operating system  rather than via a direct path to the hardware platform . An example of software implementing virtualization layer  in this context for a desktop or laptop hardware platform  is VMware Workstation\u2122 6, which is also available from VMware. It should be recognized that the various terms, layers and categorizations used to describe the virtualization components in  may be referred to differently without departing from their functionality or the spirit or scope of the invention.","Guest operating system  provides a system abstraction level known as an application space . The application space  typically provides execution (process), memory, communication, and storage abstractions. An arbitrary application , a runtime engine  configured to execute a script , or any other application may execute within the application space . Runtime engine  may comprise a Perl language interpreter, configured to read a Perl script and perform corresponding Perl commands within the Perl script. Runtime engine  may also comprise a Java language interpreter, configured to read and execute a Java language script, Java virtual machine instructions, or precompiled native machine instructions. In general, a runtime engine may execute language source code, translated byte codes, intermediate codes, compiled codes, or any other technically feasible instruction codes. When an application, such as application  is launched in VM , guest operating system  communicates with virtual CPU  to allocate a virtual address space to application  and loads the instructions (i.e., code) that execute application  into a portion of a virtual address space. This instance of application  is known as a \u201cprocess\u201d of application , which operates within the virtual address space. A page table maps the virtual address space into a portion of virtual RAM  that is controlled by guest operating system . The page table may contain an entry for each mapping of a page of the virtual address space to a page in virtual RAM .","The virtual CPU , virtual RAM , virtual NIC , and virtual mass storage  are emulated by the virtualization layer . Operations performed by the virtualization layer  may be monitored and used to create a comprehensive recording log file  comprising an initial snapshot of state associated with the VM  and a record of each nondeterministic input event. In one embodiment, the initial snapshot of state may include, without limitation, state for the virtual CPU , virtual RAM , virtual NIC , and virtual mass storage . Data associated with a given nondeterministic input event is stored in the comprehensive recording log file  along with an arrival time for the event. The nondeterministic input event may be received as a result of an arbitrary asynchronous input event, such as a network data packet arrival. In the case of a network data packet arrival, the contents of the network data packet are stored within the comprehensive recording log file . Segments of code are executed by the virtualization layer  between points in execution delineated by nondeterministic input events. Persons skilled in the art will recognize that the techniques disclosed herein may apply to virtual as well as physically implemented computing systems.","A recording log, such as comprehensive recording log file , comprises information required to fully and uniquely recreate executing state of the VM  and virtual hardware platform .","During replay, a replay module reads the recording log and re-executes portions of the executable code. The replay module instantiates a virtual machine and configures machine state based on an initial state for the virtual machine. The replay module then re-executes segments of code corresponding to originally executed segments of code. Whenever input is required, the input is read from the recording log. The input may come from any technically feasible source. For example, the input may come from an asynchronously written segment of data in memory. The segment of memory may comprise, for example, a shared memory segment or a destination location for data associated with the input. Because the recording log keeps a precise chronology of input events and corresponding data and state changes, the replay module is able to faithfully reproduce an original session.","In one embodiment of the present invention, a recording module  is configured to generate the comprehensive recording log file , comprising an initial snapshot and a recording of all inputs, such as non-deterministic inputs. Each input includes at least a data value and an arrival time. The recording module  may reside in the virtualization layer , the virtual machine monitor , or in any technically feasible location within the system architecture of the computer system . In one usage model, the recording module  generates the comprehensive recording log file  on mass storage device . Persons skilled in the art will understand that a comprehensive recording log may be generated efficiently and without substantially impacting overall system performance. Other types of log file generation techniques that filter, process, or manipulate event log data can introduce performance burdens during recording and can therefore be less efficient to generate than a comprehensive log file that records all available event log data.","Application level details may be parsed from portions of a replay runtime state for a particular application, based on knowledge of the application. For example, detailed script-level information for runtime engine  may be parsed from replay runtime state for the runtime engine , given sufficient application knowledge within the replay module. However, building sufficient application knowledge into the replay module to parse application level activity for all possible applications may not be practical or efficient in many scenarios.","One technique for more efficiently recording application level detail is to put the application  into a debug or event logging mode, where log data, such as detailed debug data, is transmitted to an API call configured to receive the log data and either save the log data to a designated log file or to discard the log data. In an enabled operating mode, the API call writes the log data to the designated log file. In certain scenarios, generating the designated log file or plural different such log files may significantly degrade performance of the application . In a disabled operating mode, the API does not generate the log file, and the log data is discarded, without significant performance degradation of the application . During a recording phase, the application  may be configured to operate in a debug or event logging mode, but the API call may be configured to operate in a disabled mode for higher execution performance. During replay, the API call may be configured to operate in an enabled mode to trigger actual recording of the designated file (or files). The log file may include any arbitrary application data, including debug data. This technique causes the application  to execute code segments that delineate high-level activity and create the potential for logging the high-level activity, but without significant additional processing burden from actually logging the high-level activity to a separate log file. During replay, log output data from the application is used to generate an application level log file, which may include an arbitrarily detailed reconstruction of application level execution.","A more general technique for efficiently recording application level activity for replay involves enabling an application to mark certain functions that are optional to the correct operation of the application and disabling the optional functions during a recording phase to reduce performance and storage burdens associated with the optional functions. The disabled commands may then be enabled during a replay phase. In one embodiment, an application programming interface (API) is exposed to applications within the application space . The API implements a mechanism for marking commands within an application to be disabled during a recording phase. Commands marked via the API as disabled for recording may be skipped during the recording phase, but may be later executed during a replay phase. In this way, certain functions that are optional to the correct operation of a given application may be disabled during recording and subsequently enabled during replay to reproduce a complete representation of application behavior, but without associated performance burdens during recording. One example of an optional function is generating and storing an application level debug log file. By marking functions related to generating the debug log file as disabled for recording, no debug log file is generated during recording. However, the related functions may be enabled during replay to generate the debug log file. Other optional functions may include data consistency checking and many forms of caching that are frequently irrelevant to debugging an application. This technique for selective execution enables applications to run at more realistic performance levels during a recording phase, without losing debug information during replay.","In one embodiment, the API calls related to marking functions to be disabled during recording are implemented as backdoor calls to the virtualization layer . For example, one API call may mark a function to be disabled during recording, indicating that the function call should only be performed during replay. The virtualization layer  responds by either executing or ignoring the marked command, depending on whether the application is executing in a recording phase or a playback phase. Commands may be marked using a source code assert construct that facilitates a backdoor call to the virtualization layer . Persons skilled in the art will recognize that different techniques may be used to implement such a backdoor pathway, and that any such technique is within the scope and spirit of the present invention.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2","b":["250","232","232","152","152","220","230","220","230","220","230"]},"The recording module , residing in the virtualization layer  of , generates the comprehensive recording log file . Time slice transform module  replays the comprehensive recording log file  to generate a time sliced log file , comprising a snapshot for the start of a specified time window, and substantially all previously recorded replay information to be performed within the time window. Replay information occurring outside the time window is culled. Process slice transform module  replays the time sliced log file  to generate crosscut log file , comprising a snapshot at the start of the specified time window, and replay information to be performed within the specified process scope. Process scope is illustrated below in . Replay information occurring outside the time window and specified process scope is culled. A common log file format may be implemented among the comprehensive recording log file , time sliced log file , and crosscut log file . With the common log file format defining both the input and output of each transform, an arbitrary chain of transforms may be developed for processing a given log file. Alternatively, each transform module may generate an arbitrary log file format that may be parsed for replay by another transform module within an arbitrary chain of transform modules. In one embodiment, certain replay data, such as results from specific system calls, may be derived during replay.","In certain scenarios, a log file needs to be replayed by a third party who should not have access to all machine state represented in the log file. For example, a log file may include confidential passwords, encryption\/decryption keys, and potentially other forms of confidential information that should be redacted from the log file destined to the third party. Data redaction involves culling certain data from a generated log file. Either or both transform modules ,  may perform data redaction. Alternatively, redaction may be performed by a separate transform module (not shown). Any technically feasible redaction techniques may be applied within the framework of the multi-stage post-processing pipeline , however two exemplary redaction techniques are described herein. The first redaction technique involves removing specified strings, such as literally defined strings, regular expressions, or any other technically feasible means for specifying a pattern when generating an output log file from an input log file. The specified strings may include passwords or other confidential data that should be redacted. When a specified string is encountered during replay, the specified string is sliced from a replay output log file. In one embodiment, redaction of the specified string is performed by slicing a time span, corresponding to when the specified string exists in replay state, from the replay output log file. Slicing the time span from the replay output log file is analogous to a general time slice operation. Related code may also be sliced. Only the results of processing the specified string need to be saved as part of a snapshot, but the redacted string need not be saved.","A second redaction technique involves tagging confidential information at the application level. In one embodiment, data objects are tagged (tainted) via an API call, which is configured to identify a data object as containing confidential information. The API call may be implemented as a backdoor call to the virtualization layer . An assert construct may be implemented to tag (taint) a data object for redaction. The assert construct facilitates a backdoor call to the virtualization layer . When a tainted item of data is encountered during execution, the span of time where the tainted item of data is handled in execution state is sliced from the replay output log file. Similarly, when a copy of the tainted item of data, or an item of data derived from the tainted item of data is encountered during execution, the span of time where the copy or derived item of data is handled in execution state is sliced from the replay output log file. The slice operation is analogous to a general time slice operation.","Either redaction technique may be applied initially when the comprehensive recording log file  is generated, or at any transform stage within the multi-stage post-processing pipeline . Persons skilled in the art will recognize that different techniques may be used to implement such a backdoor pathway, and that any such technique is within the scope and spirit of the present invention. Furthermore, any technically suitable replay module  may be employed to replay crosscut log file , which may contain only replay information conforming to an intersection of slice transforms performed by the time slice transform module  and process slice transform module .",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 3A","b":["120","122","310","320","330","330","330","120","332","334","336"]},"An application layer  represents tasks performed by applications within the process layer . As shown, Java applet  and Perl script  execute within the application layer . In this example, Perl script  can be seen as executing lines of Perl script associated with the application layer . However, the Perl interpreter  is actually executing CPU instructions  within a process abstraction level above operating system . While a lot of computational activity is required at many levels to execute lines of Perl script , a Perl developer is typically only interested in their Perl script  and related Perl state, not the underlying CPU instructions needed to execute the Perl script . In a practical scenario, the Perl script  may interact asynchronously with other processes within the VM , or via a network connection to processes executing on another virtual or physical machine. In a replay scenario, any underlying computation of other processes interacting with the Perl script  may or may not be important to replaying the Perl script . However, any asynchronous input received during a recording phase needs to arrive at a chronologically precise point in any subsequent replays of the Perl script. Therefore, each log file includes at least timing information, although the log file may not necessarily include anything else about other processes.","In the above example, a time window  is used to slice a comprehensive recording log file, such as comprehensive recording log file . A time sliced log file, such as time sliced log file  is generated from comprehensive recording log file . Additionally, a process scope window  is used to slice the time sliced log file to generate a crosscut log file, such as crosscut log file . The crosscut file includes a crosscut extent  of the original comprehensive recording log file. The crosscut extent  may be substantially smaller than the original comprehensive recording log file. As described previously, the crosscut extent  can also be redacted of confidential or sensitive information.","The above examples illustrate the concept of multi-stage processing of a recording log file. Time slicing and process slicing are examples of different types of slicing techniques, however, persons skilled in the art will understand that further and additional slicing techniques may be implemented without departing from the scope and spirit of the present invention.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 3B","FIG. 1","FIG. 2"],"b":["372","378","120","152","150","120","152","370","372","378","370","250","372","378","360"]},"Log file  includes instruction level detail, but may be, for example, time sliced. Furthermore, comprehensive recording log file  may include tainted data objects, or tainted strings and any related data may be redacted from log file . Therefore, while log file  includes detailed machine level information, no tainted data is represented. Log file  includes instruction level detail for one or more processes within application space . Log file  may be sliced to include a specific one process or set of processes, a certain span or spans of time, or according to any other technically feasible slicing transform.","Log file  may include a debug trace file generated by application . As described previously, the application  may be configured to operate in a debug mode, but not actually generate log file  during a recording phase. Similarly, log file  may include a debug trace file generated by runtime engine . Data from tainted data objects or strings may be redacted from log files - using either technique described previously, or using any technically feasible technique.","One or more of the log files - may be generated by the crosscut operation . One or more of the log files - may be read and replayed by a replay module, such as replay module  of .",{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 3C","FIG. 1","FIG. 1"],"b":["388","382","380","100","134","382","152","150","112","382","382","250","384","388","380","388","388","382","384","388"]},"The crosscut log file  is transmitted to a vendor computer . The replay module  reads the crosscut log file  to create a replay instance  of application . The replay instance  includes ordinary data  from application , but does not contain private data  from application .",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 4","FIGS. 1-3C"],"b":"400"},"The method begins in step , where the transform module, such as time slice transform module  or process slice transform module , opens a replay log file. The replay log file may reside in any data storage media, including volatile and non-volatile storage media. In step , the transform module reads a unit of the replay log file, which may comprise snapshot data and nondeterministic input data. Snapshot data is used to establish replay machine state at a particular elapsed execution time. Nondeterministic input data represents asynchronously arriving input data, such as a network data packet arriving at an arbitrary time, or a user mouse click event. In one embodiment, the transform module reads an entire semantically complete unit of the replay log file, parses the unit, and analyzes the unit for scope in time, abstraction level, and process identity. The transform module may further analyze the unit of the replay log file using any other technically feasible techniques for determining slice requirements.","In step , the replay module configures machine state for replay. The machine state may be a previous machine state or an initial snapshot of machine state from the replay log file. The snapshot may be used to establish initial machine state. In step , the replay module executes a code segment associated with the previously read unit of the replay log file. The code segment advances machine state for the virtual machine until an interruption is required, such as receiving input data.","If, in step , the executed unit of the replay log file meets a specified slice requirement, then the method proceeds to step . The specified slice may comprise a time window, abstraction level, process scope, data scope, or any other technically feasible criteria for slicing, or any combination thereof. Data that is tainted (marked for redaction) does not meet the slice requirement. A tainted data object may remain in place within a memory image of processor state, however the contents of the tainted data object need to be redacted. In one embodiment, a tainted data object is redacted by performing a time slice for a span of time corresponding to when contents of the tainted data object reside in playback state. In an alternative embodiment, data residing within the tainted data object is written with at least a portion of a predetermined string, such as a sequence of zeros. In certain embodiments, multiple different slice requirements may be specified and determined in step . A timestamp within the unit of the replay log file may be compared against the time window to determine whether the executed unit of replay log file meets a certain specified slice requirement. A process identifier within the unit of the replay log file may be compared against a process scope specification to determine whether the executed unit of replay log file meets a corresponding slice requirement. Other attributes, such as abstraction level, may be similarly tested with respect to the executed unit of replay log file to determine whether a given specified slice requirement is satisfied.","In step , the replay module records machine state in a sliced replay log file. In one mode of operation, tainted data (marked for redaction) is not written to the sliced replay log file.","If, in step , there is more replay information in the replay log file, then the method proceeds back to step . Otherwise, the method terminates in step , where the replay module closes the replay log file and the sliced replay log file.","Returning to step , if the executed unit of the replay log file does not meet a specified slice requirement, then the method proceeds to step .","In sum, a technique is disclosed for generating a specifically targeted crosscut log file of arbitrarily narrow scope from a broader, general recording log file generated to include comprehensive machine state. A multi-stage post-processing pipeline may be implemented for generating the crosscut log file having a specifically targeted extent. At each stage, a transform module within the multi-stage post-processing pipeline performs a replay operation on a previous recording log file and performs a slicing transform to narrow the overall extent for a resulting sliced log file. A final crosscut transform generates the crosscut log file, which may be used to replay targeted aspects of the original general recording file.","The various embodiments described herein may employ various computer-implemented operations involving data stored in computer systems. For example, these operations may require physical manipulation of physical quantities usually, though not necessarily, these quantities may take the form of electrical or magnetic signals where they, or representations of them, are capable of being stored, transferred, combined, compared, or otherwise manipulated. Further, such manipulations are often referred to in terms, such as producing, identifying, determining, or comparing. Any operations described herein that form part of one or more embodiments of the invention may be useful machine operations. In addition, one or more embodiments of the invention also relate to a device or an apparatus for performing these operations. The apparatus may be specially constructed for specific required purposes, or it may be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular, various general purpose machines may be used with computer programs written in accordance with the teachings herein, or it may be more convenient to construct a more specialized apparatus to perform the required operations.","The various embodiments described herein may be practiced with other computer system configurations including hand-held devices, microprocessor systems, microprocessor-based or programmable consumer electronics, minicomputers, mainframe computers, and the like.","One or more embodiments of the present invention may be implemented as one or more computer programs or as one or more computer program modules embodied in one or more computer readable media. The term computer readable medium refers to any data storage device that can store data which can thereafter be input to a computer system. Computer readable media may be based on any existing or subsequently developed technology for embodying computer programs in a manner that enables them to be read by a computer. Examples of a computer readable medium include a hard drive, network attached storage (NAS), read-only memory, random-access memory (e.g., a flash memory device), a CD (Compact Discs) CD-ROM, a CD-R, or a CD-RW, a DVD (Digital Versatile Disc), a magnetic tape, and other optical and non-optical data storage devices. The computer readable medium can also be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.","Although one or more embodiments of the present invention have been described in some detail for clarity of understanding, it will be apparent that certain changes and modifications may be made within the scope of the claims. Accordingly, the described embodiments are to be considered as illustrative and not restrictive, and the scope of the claims is not to be limited to details given herein, but may be modified within the scope and equivalents of the claims. In the claims, elements and\/or steps do not imply any particular order of operation, unless explicitly stated in the claims.","In addition, while described virtualization methods have generally assumed that virtual machines present interfaces consistent with a particular hardware system, persons of ordinary skill in the art will recognize that the methods described may be used in conjunction with virtualizations that do not correspond directly to any particular hardware system. Virtualization systems in accordance with the various embodiments, implemented as hosted embodiments, non-hosted embodiments, or as embodiments that tend to blur distinctions between the two, are all envisioned. Furthermore, various virtualization operations may be wholly or partially implemented in hardware. For example, a hardware implementation may employ a look-up table for modification of storage access requests to secure non-disk data.","Many variations, modifications, additions, and improvements are possible, regardless of the degree of virtualization. The virtualization software can therefore include components of a host, console, or guest operating system that performs virtualization functions. Plural instances may be provided for components, operations or structures described herein as a single instance. Finally, boundaries between various components, operations and data stores are somewhat arbitrary, and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the invention(s). In general, structures and functionality presented as separate components in exemplary configurations may be implemented as a combined structure or component. Similarly, structures and functionality presented as a single component may be implemented as separate components. These and other variations, modifications, additions, and improvements may fall within the scope of the appended claims(s)."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3C"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
