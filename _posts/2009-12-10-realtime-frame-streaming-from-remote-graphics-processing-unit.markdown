---
title: Real-time frame streaming from remote graphics processing unit
abstract: A client computing device transmits commands and/or data to a software application executing on a server computing device. The server computing device includes one or more graphics processing units (GPUs) that render frames of graphic data associated with the software application. For each frame, the one or more GPUs copy the frame to memory. A server engine also executing on the server computing device divides the frame into subframes, compresses each subframe, and transmits compressed subframes to the client computing device. The client computing device decompresses and reassembles the frame for display to an end-user of the client computing device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08984167&OS=08984167&RS=08984167
owner: NVIDIA Corporation
number: 08984167
owner_city: Santa Clara
owner_country: US
publication_date: 20091210
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","Embodiments of the present invention relate generally to displaying video content, and, more specifically, to real-time frame streaming from a remote graphics processing unit.","2. Description of the Related Art","Some computer systems operate according to a \u201cclient-server\u201d computing model, whereby a client computing device interacts with a server computing device across a network. The client computing device may transmit commands and\/or data to the server computing device for processing. The server computing device processes the received commands\/data, and then transmits processed data back to the client computing device. By implementing this computing model, the client computing device offloads processing operations onto the server computing device.","For example, the client computing device could transmit commands to the server computing device that cause the server computing device to decode and render frames of video data associated with a digital video disc (DVD). The server computing device could then transmit a sequence of rendered frames to the client computing device. The client computing device could display these frames to an end-user via a display device. In this fashion, the processing operations associated with playing the DVD are offloaded onto the server computing device, thereby reducing the processing power required by the client computing device to play the DVD.","A conventional client-server computing model is implemented by software and\/or hardware that coordinates data communication between the client device and the server device.  illustrates a prior art client-server computer system  configured to coordinate client-server data communication.","As shown,  includes a client computing device  in data communication with a server computing device  via a network . The client computing device  includes a central processing unit , one or more input\/output (I\/O) devices , and a memory . The memory  includes a client application  that, when executed by the CPU , communicates with the server computing device  via the network .","The server computing device  is coupled to a display device  and includes a graphics processing unit (GPU) , a frame buffer , a CPU , a frame capture engine , one or more I\/O devices , and a memory . The memory  includes an operating system , one or more applications , and a GPU driver . The CPU  may execute the O\/S  and the applications . The applications  may include, for example, a DVD player application. The CPU  is configured to execute the GPU driver  in order to cause the GPU  to render frames of graphic data, or \u201cframes,\u201d for display on the display device . The frames may be, e.g., frames of a DVD associated with a DVD player application. The GPU  renders each new frame to the frame buffer . When the display device  refreshes, a display driver (not shown) drives a newly-rendered frame from the frame buffer  to the display device .","The frame capture engine  is a hardware unit configured to capture frames rendered by the GPU  for transmission to the client computing device . When the GPU  renders a new frame to the frame buffer, the frame capture engine  copies the newly-rendered frame from the frame buffer  and transmits that frame to the client computing device . Through this technique, the frame capture engine  may stream frames of graphic data to the client computing device  for display, storage, etc. This technique works well when the GPU  can render each new frame to the frame buffer  sufficiently in advance of the time when the display device  requires the newly rendered frame to be displayed.","However, in certain situations, the GPU  requires almost all of the time between refreshes of the display device  to render each frame. In these situations, the frame capture engine  does not have sufficient time to copy newly-rendered frames before the display device  requires those frames. The frame capture engine  may thus be unable to capture every frame rendered by the GPU , thereby reducing the number of frames that are transmitted to the client computing device . Consequently, the frame rate of the frames displayed by the client computing device  is reduced.","Another prior art client-server computer system  is illustrated in . As shown, client-server computer system  includes some of the same components as client-server computer system . In addition, client-server computer system  also includes a virtual network computing (VNC) application  within the memory  of the server computing device . The VNC application  is a third-party application that communicates with the O\/S  via application programming interfaces (APIs), e.g., OpenGL APIs, that allow the VNC application  to request newly-rendered frames from the GPU  via the O\/S . When the VNC application  requests a newly-rendered frame, the O\/S  causes the GPU driver  to insert a \u201ccopy\u201d command into a command buffer associated with the GPU . When the GPU  receives the copy command, the GPU  copies a newly-rendered frame from the frame buffer  to the memory . The VNC application  may then transmit the frame from the memory  to the client computing device .","One drawback of inserting the copy command into the command buffer, as described, is that the GPU  must execute all of the commands already included in the command buffer before executing the copy command. In situations where the GPU command buffer includes a sequence of commands associated with a sequence of frames, the VNC application  must wait for those commands to be executed before a frame can be copied to the memory . Consequently, frames streamed by the VNC application  to the client computing device  may be delayed as a result of pre-existing commands in the command buffer. When those frames are associated with an interactive application, such as, e.g., a video game or a virtual desktop application, interaction with that application may be difficult or impossible.","As the foregoing illustrates, what is needed in the art is an improved technique for streaming frames of video content to a client computing device.","Embodiments of the invention provide a method for streaming frames of graphics data from a server computing device to a client computing device. The method includes causing a discrete graphics processing unit (dGPU) included within the server computing device to render a frame of graphics data associated with a software application executing on the server computing device; causing a copy engine within the dGPU to copy the frame of graphics data to a memory associated with the server computing device; generating a set of compressed subframes based on the frame of graphics data; and transmitting each compressed subframe in the set of compressed subframes to the client computing device across a different data connection between the server computing device and the client computing device.","Advantageously, the GPU driver causes the dGPU to copy every frame that is rendered by the dGPU to memory, thereby avoiding latencies involved with separate (i.e., third-party) software and hardware frame capture techniques. Accordingly, frames of graphic data can be streamed to a client computing device without decreasing the frame rate of that graphic data and without incurring significant delays.","In the following description, numerous specific details are set forth to provide a more thorough understanding of the invention. However, it will be apparent to one of skill in the art that the invention may be practiced without one or more of these specific details. In other instances, well-known features have not been described in order to avoid obscuring the invention.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3","b":["300","300","302","302","314","314","314","340","340","302","302","340"]},"As shown, the computer system  includes the client computing device  coupled to the server computing device  via a network . The network  may be any type of network that allows data to be transferred between the client computing device  and the server computing device , including a local area network (LAN), a wide-area network (WAN), a wireless (WiFi) network, an Ethernet network, a cellular network, and so forth.","The client computing device  may be a laptop computing device, a desktop computing device, a mobile computing device, or any other type of computing device. The client computing device  is configured to transmit commands and\/or data to the server computing device  via the network  and to receive data from the server computing device  via the network . The client computing device  includes a central processing unit (CPU) , one or more input\/output (I\/O) devices , and a memory .","The I\/O devices  include input devices, such as a keyboard, a mouse, or a joystick, among others, as well as output devices, such as a display device or a speaker, among others. The I\/O devices  may also include devices configured to receive input and transmit output, such as an Ethernet port, a wireless card, or a touchscreen, among others devices. In one embodiment, the I\/O devices  provide a data connection between the client computing device  and the server computing device . The I\/O devices  may also transmit data to and receive data from the memory  and\/or the CPU .","The CPU  may be an application-specific integrated circuit (ASIC), a field-programmable gate array (FPGA), a graphics processing unit (GPU), or any other type of processing unit. The CPU  is configured to execute software applications corresponding to a particular instruction set architecture (ISA) associated with the CPU . The software applications may be received from the I\/O devices  and\/or retrieved from the memory , among other places.","The memory  may be any type of memory unit, including a random-access memory (RAM) unit, a read-only memory (ROM) unit, a flash memory unit, and so forth. As described in greater detail in conjunction with , the memory  includes a \u201cremote access application\u201d that, when executed by the CPU , receives commands from an end-user via the I\/O devices  and transmits those commands to a \u201cserver engine\u201d within the server computing device . The commands may be used to interact with a software program executing on the server computing device . The server engine routes the commands to the software program, which may then cause frames of graphic data to be generated based on the received commands. The frames of graphic data could be associated with, for example, a digital video disk (DVD), a video game application, or a graphical user interface (GUI), among others. The server engine streams the frames of graphic data to the client computing device  as compressed subframes .","The server computing device  may be a laptop computing device, a desktop computing device, a mobile computing device, or any other type of computing device. The server computing device  includes a discrete graphics processing unit (dGPU) , a frame buffer , an integrated GPU (iGPU) , a CPU , one or more I\/O devices , and a memory . The I\/O devices  may include substantially similar input and\/or output devices as those included in the I\/O devices . The I\/O devices  are configured to transmit data to and receive data from the memory , the CPU , the dGPU , and\/or the iGPU .","The dGPU  and the iGPU  are co-processors configured to cooperate to perform graphics processing operations. In one embodiment, the dGPU  performs graphics-intensive graphics processing operations, while the iGPU  performs nominally-intensive graphics processing operations. Either the dGPU  or the iGPU  may render frames of graphic data (referred to hereinafter as \u201cframes\u201d) to the frame buffer  for display on the display device . The frame buffer  may include two or more separate buffers between which the dGPU  alternates when rendering frames. As described in greater detail in conjunction with , the dGPU  may render frames to the frame buffer  and then (i) perform further processing operations on those frames or (ii) copy the frames to the iGPU  for further processing. The CPU  may also perform processing operations with frames rendered by the dGPU .","The CPU  may be an ASIC, an FPGA, a GPU, or any other type of processing unit. In one embodiment, the CPU  is a multi-core processing unit. The CPU  is configured to execute one or more drivers associated with the dGPU  and\/or the iGPU  in order to coordinate the operations of the dGPU  and\/or the iGPU , respectively. The CPU  is also configured to execute software applications corresponding to a particular ISA associated with the CPU . The software applications may be stored in the memory , among other places.","The memory  may be any type of memory unit, including a RAM unit, a ROM unit, a flash memory unit, and so forth. A software program stored in the memory  may be executed by the CPU  to establish one or more transmission control protocol\/internet protocol (TCP\/IP) connections with client computing device . The TCP\/IP connections are established across the network . The software program may also be executed by the CPU  to divide frames rendered by the dGPU  into subframes, compresses those subframes into compressed subframes , and then transmit the compressed subframes  to the client computing device  via the TCP\/IP connections, as described in greater detail below in conjunction with .",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 4","FIG. 3","FIG. 3"],"b":["300","300","308","302","310","336","324","314"]},"When executed by the CPU , the remote access application  transmits an initialization packet to the server engine . The initialization packet includes data specifying an application  to be executed on the server computing device .","In response to receiving the initialization packet, the server engine  transmits a configuration packet to the remote access application  that includes metadata specifying a compression algorithm used to generate the compressed subframes  as well as a number of subframes per frame. As discussed in conjunction with , the server engine  also establishes one or more TCP\/IP connections with the client computing device  across which the compressed subframes  are to be transmitted. The server engine  establishes a number of TCP\/IP connections that is equal to the number of subframes per frame.","In addition to the server engine , the server computing device  shown in  also includes an operating system (O\/S) , the application(s) , a GPU driver , reserved memory , a semaphore value , a server engine memory , and the compressed subframes  within the memory . The O\/S  is a software program that can be executed by the CPU  to coordinate the operations of other software applications executed by the CPU . The O\/S  may be any type of operating system, including Windows\u00ae or Mac OSX\u00ae operating system, among others.","The applications  are software programs that can be executed by CPU  to perform a wide variety of processing and\/or input\/output tasks. For example, the applications  may include video game applications, video player applications, computer-aided design (CAD) applications, simulation applications, or integrated development environment (IDE) applications, or other graphics-oriented applications. The applications  may offload graphics processing tasks to the dGPU  and\/or the iGPU  in order to expedite the performance of these operations. For example, one of the applications  could be a video game application that offloads rendering tasks to the dGPU . The dGPU  could render each frame and then cause the display device  to display the rendered frame. The applications  offload graphics processing operations to the dGPU  and to the iGPU  by transmitting those operations to the GPU driver  via the O\/S .","The GPU driver  is a software program that, when executed by the CPU , transmits hardware (HW) commands to the dGPU  and\/or the iGPU . In response to graphics processing operations received from the applications , the dGPU  and\/or the iGPU  may perform a wide variety of operations, including graphics-related processing operations, general processing operations, and power regulation operations, among others.","In some situations, one of the applications  causes the dGPU  to render frames for display on the display device , as described in the above example. In these situations, the GPU driver  transmits HW commands to the dGPU  on behalf of the application . The HW commands cause the dGPU  to (i) render frames to the frame buffer  and (ii) copy rendered frames to the reserved memory  within memory . In one embodiment, the dGPU  converts rendered frames from red-green-blue (RGB) format to YUV format and\/or scale the converted frames based on a screen resolution associated with client computing device .","The dGPU  includes a copy engine  configured to copy the rendered frames from the frame buffer  to the reserved memory . The reserved memory  resides in kernel space and may be cache-coherent. The reserved memory  is initialized by the GPU driver  and reserved for storing frames copied from the frame buffer . For each frame copied to the reserved memory , the dGPU  increments the semaphore value .","In one embodiment, copy engine  copies rendered frames to local memory within the iGPU . The iGPU  then converts the received frames from RGB format to YUV format and stores the YUV frames in the reserved memory . In a further embodiment, the iGPU  scales the converted frames based on a screen resolution associated with the client computing device .","The server engine  monitors the semaphore value . When the semaphore value  changes (e.g., increments), the server engine  copies a frame stored in the reserved memory  to the server engine memory . When the reserved memory  is cache coherent, upon copying the frame to the server engine memory , the server engine  invalidates a cache line associated with the frame.","The server engine  then divides the frame into a number of subframes. The number of subframes may be equal to the number of independent processing cores included within the CPU . The server engine  executes a compression program on each available processing core of CPU  in order to compress each subframe. In one embodiment, the server engine  executes on a first processing core of CPU  while causing a compression program to execute on each remaining processing core. Each compression program compresses a different subframe. In an exemplary configuration, the CPU  includes four processing cores. The server engine  executes on a first processing core. When the server engine  retrieves a frame from the server engine memory , the server engine  divides the frame into three subframes and executes a compression program on each of the three available processing cores with a different subframe. In this fashion, the server engine  generates the compressed subframes . The server engine  then transmits each compressed subframe  to the remote access application  via a different TCP\/IP connection.","The remote access application  receives the compressed subframes  from the server engine  and then decompresses each of the compressed subframes . The remote access application  then merges the decompressed subframes to generate a frame. The frame can be displayed on a display device (e.g., included within the I\/O devices ) and\/or stored in the memory . The client computing device  may then receive additional data and\/or commands from the end-user for transmission to the server engine .","In this manner, the end-user of the client computing device  may interact with one of the applications  that execute on the server computing device . The end-user may input commands to the client computing device , which then receives frames of graphic data generated by the application  in response to those commands. Since the GPU driver  causes the copy engine  to copy each rendered frame of data to the memory , latencies involved with separate hardware units, as described in , and latencies involved with third-party applications, as described in , can be avoided.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 5","FIGS. 3-4"],"b":["500","310","310","304"]},"As shown, the method  begins at step , where the remote access application  transmits an initialization packet to the server engine . The initialization packet includes data specifying a particular application  to be executed on the server computing device . At step , the remote access application  receives a configuration packet from the server engine . The configuration packet includes data specifying a compression algorithm used to generate compressed subframes  and the number of subframes per frame. At step , the remote access application  configures the client computing device  based on the received configuration packet. The remote access application  may use data included in the configuration packet when establishing data communication with the server engine  and\/or when decompressing and reassembling a frame from the compressed subframes .","At step , the remote access application  receives one or more compressed subframes  from the server engine . Each compressed subframe  represents a different portion of a single frame. Additionally, each compressed subframe is transmitted across a different TCP\/IP connection between the server computing device  and the client computing device .","At step , the remote access application  decompresses the compressed subframes  and merges the decompressed subframes into a single frame. At step , the remote access application  displays the frame on a display device associated with the client computing device . The remote access application  may also store the frame in the memory . At step , the remote access application  receives input entered by the end-user of the client computing device  via the I\/O devices . The input could be, for example, commands issued to a video game executing on the server computing device . At step , the remote access application  transmits the user input to the server engine . The method then returns to step  and proceeds as described above.","The method  thus outlines a technique through which an end-user of the client computing device can issue commands to a software application executing on the server computing device  and receive frames of graphic data generated based on those commands.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 6","FIGS. 3-4"],"b":["600","330","330","320"]},"As shown, the method  begins at step , where the GPU driver  allocates the reserved memory  within the memory . In one embodiment, the GPU driver  allocates 16 MB of cache-coherent memory in kernel space for use as the reserved memory . In another embodiment, the O\/S  allocates the reserved memory . At step , the GPU driver  initializes the semaphore value  to zero. At step , the GPU driver  causes the dGPU  to render a frame of graphic data to the frame buffer . The frame buffer  may include two or more separate buffers. When the frame buffer  includes separate buffers, the dGPU  alternates between rendering frames to each of the separate buffers. At step , the GPU driver  causes the dGPU  to convert the frame from RGB format to YUV format. In one embodiment, the GPU driver  causes the iGPU  to perform step .","At step , the GPU driver  causes the copy engine  within the dGPU  to copy the converted frame to the reserved memory . In embodiments where the iGPU  converts the frame to YUV format, the GPU driver  causes the iGPU  to perform step . At step , the GPU driver  increments the semaphore value . At step , the GPU driver  causes the dGPU  to drive the newly rendered frame within frame buffer  to the display device  for display. The method  then returns to step  and proceeds as described above.","The method  thus outlines the technique through which the GPU driver  causes the dGPU  to copy a newly-rendered frame of graphic data to the memory .",{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 7","FIGS. 3-4"],"b":["700","336","336","320"]},"As shown, the method  begins at step , where the server engine  receives an initialization packet from the remote access application . The initialization packet includes data specifying a particular application  to be executed on the server computing device . At step , the server engine  determines the number of available processing cores included in the CPU . At step , the server engine  initializes a number of TCP\/IP connections with the remote access application  based on the number of available processing cores of the CPU . At step , the server engine  transmits a configuration packet to the remote access application  within the client computing device . The configuration packet specifies a compression algorithm used to compress the compressed subframes  as well as the number of subframes associated with each frame.","At step , the server engine  determines whether the semaphore value  has changed (e.g., incremented). The server engine  waits until the semaphore value  has changed, and then the method  proceeds to step . At step , the server engine  copies a frame of graphic data from the reserved memory  to the server engine memory . At step , the server engine  updates a cache associated with the CPU . The server engine  may write the frame to the cache and\/or invalidate a cache line within the cache. At step , the server engine  splits the frame into a number of subframes. In some embodiments, the number of subframes is equal to the number of availability processing cores on the CPU . At step , the server engine  causes the CPU  to compress the subframes into the compressed subframes . In one embodiment, the server engine  executes on one core of the CPU , and the server engine causes each of the remaining cores to execute a compression algorithm with a different subframe to generate compressed subframes . At step , the server engine  transmits the compressed subframes  to the client computing device  across the TCP\/IP connections. The method  then returns to step  and proceeds as described above.","The method  thus describes a technique through which frames of graphic data associated with the application  can be captured and transmitted to the client computing device .","In sum, a graphics processing unit (GPU) driver executing on a server computing device causes a discrete GPU (dGPU) to render frames associated with a software application. The dGPU or an iGPU then processes the rendered frames and copies those frames to memory within the server computing device. For each frame, a server engine divides the frame into subframes. The server engine compresses each subframe and then transmits the subframes to a client computing device. The client computing device executes a remote access application that decompresses the compressed subframes and merges the subframes to re-create the frame. The remote access application then causes the frame to be displayed on a display device associated with the client computing device. The client computing device may then receive commands and\/or data from an end-user and transmit the commands and\/or data to the software application within the server computing device.","Advantageously, the GPU driver causes the dGPU to copy every frame that is rendered by the dGPU to memory, thereby avoiding latencies involved with separate (i.e., third-party) software and hardware frame capture techniques. Accordingly, frames of graphic data can be streamed to a client computing device without decreasing the frame rate of that graphic data and without incurring significant delays.","One embodiment of the invention may be implemented as a program product for use with a computer system. The program(s) of the program product define functions of the embodiments (including the methods described herein) and can be contained on a variety of computer-readable storage media. Illustrative computer-readable storage media include, but are not limited to: (i) non-writable storage media (e.g., read-only memory devices within a computer such as CD-ROM disks readable by a CD-ROM drive, flash memory, ROM chips or any type of solid-state non-volatile semiconductor memory) on which information is permanently stored; and (ii) writable storage media (e.g., floppy disks within a diskette drive or hard-disk drive or any type of solid-state random-access semiconductor memory) on which alterable information is stored.","The invention has been described above with reference to specific embodiments. Persons skilled in the art, however, will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features of the invention can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to embodiments, some of which are illustrated in the appended drawings. It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
