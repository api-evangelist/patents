---
title: Data parallel query analysis
abstract: A method of analyzing a data parallel query includes receiving a user-specified data parallel query that includes a plurality of query operators. An operator type for each of the query operators is identified based on a type of parallel input data structure the operator operates on and a type of parallel output data structure the operator outputs. It is determined whether the query is a prohibited query based on the identified operator types.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08266172&OS=08266172&RS=08266172
owner: Microsoft Corporation
number: 08266172
owner_city: Redmond
owner_country: US
publication_date: 20090403
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","PSEUDO CODE EXAMPLE I","PSEUDO CODE EXAMPLE II","PSEUDO CODE EXAMPLE III","PSEUDO CODE EXAMPLE IV","PSEUDO CODE EXAMPLE V","PSEUDO CODE EXAMPLE VI"],"p":["Software programs have been written to run sequentially since the beginning days of software development. Steadily over time, computers have become much more powerful, with more processing power and memory to handle advanced operations. This trend has recently shifted away from ever-increasing single-processor clock rates towards an increase in the number of processors available in a single computer resulting in a corresponding shift away from sequential execution toward parallel execution. Software developers want to take advantage of improvements in computer processing power to enable their software programs to run faster as new hardware is adopted. With parallel hardware, software developers arrange for one or more tasks of a particular software program to be executed in parallel (also referred to as concurrently), so that, for example, the same logical operation can utilize many processors at one time to thereby deliver better performance as more processors are added to the computers on which such software runs.","This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","Data parallelism is a programming pattern where an operation is applied to input data, and the work is distributed across multiple computational cores by assigning different input elements to be processed by different cores. As a result of spreading the computation across multiple computational cores, the time to complete the computation is reduced. Since a motivation for parallelism is improved performance, one embodiment identifies queries that will not be executed efficiently in parallel, and prevents them from being compiled.","One embodiment provides a method of analyzing a data parallel query, which includes receiving a user-specified data parallel query that includes a plurality of query operators. An operator type for each of the query operators is identified based on a type of parallel input data structure the operator operates on and a type of parallel output data structure the operator outputs. It is determined whether the query is a prohibited query based on the identified operator types.","In the following Detailed Description, reference is made to the accompanying drawings, which form a part hereof, and in which is shown by way of illustration specific embodiments in which the invention may be practiced. It is to be understood that other embodiments may be utilized and structural or logical changes may be made without departing from the scope of the present invention. The following detailed description, therefore, is not to be taken in a limiting sense, and the scope of the present invention is defined by the appended claims.","One embodiment provides a data parallel query analysis application, but the technologies and techniques described herein also serve other purposes in addition to these. In one implementation, one or more of the techniques described herein can be implemented as features within a framework program such as Microsoft\u00ae .NET Framework, or within any other type of program or service.","A query may be constructed by a developer using a predefined query language. The developer then typically uses a compiler tool to translate the query into code that calls appropriate library functions to execute the query. One type of query is a language integrated query. In one embodiment, the queries analyzed by the data parallel query analysis application are language integrated queries. A language integrated query according to one embodiment is a query that is an integrated feature of a developer's primary programming language (e.g., C#, Visual Basic). Language integrated queries according to one embodiment allow query expressions to benefit from rich metadata, compile-time syntax checking, and static typing that was previously available only to program code written in a statically type-checked language, and specifically not queries that are customarily embedded into such programs as untyped strings. As an example, Microsoft\u00ae supports the LINQ (Language Integrated Query) programming model, which is a set of patterns and technologies that allow the user to describe a query that will execute on a variety of different execution engines. LINQ provides .NET developers with the ability to query and transform data sequences using any of a variety of .NET programming languages.","In one embodiment, a developer describes a query using a convenient query syntax that consists of a variety of query operators such as projections, filters, aggregations, and so forth. The operators themselves may contain one or more expressions or expression parameters. For example, a \u201cWhere\u201d operator will contain a filter expression that will determine which elements should pass the filter. An expression according to one embodiment is a combination of letters, numbers, and symbols used to represent a computation that produces a value. The operators together with the expressions provide a complete description of the query.","In one embodiment, the queries analyzed by the data parallel query analysis application are data parallel language integrated queries that are configured to be executed in a parallel manner. Data parallelism is a programming pattern where an operation is applied to input data, and the work is distributed across multiple computational cores by assigning different input elements to be processed by different cores. As a result of spreading the computation across multiple computational cores, the time to complete the computation is reduced.","Writing data-parallel programs from scratch is a non-trivial programming problem, and can be simplified by building the solution on top of an existing data-parallel library. The library will provide various operators (e.g., projections, filters, joins, reductions, etc.) that the developer can combine to build data-parallel queries. Parallel LINQ (PLINQ) from Microsoft\u00ae is one such library. PLINQ accepts language integrated queries and automatically uses multiple processors or cores for execution when they are available. The following Pseudo Code Example I gives an example of a PLINQ query that negates the elements from the array, arr, takes the first 1,000 of them, keeps only those that are divisible by 3, and dumps the results into an array:",{"@attributes":{"id":"p-0019","num":"0018"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int[ ] arr = ..."]},{"entry":[{},"arr.AsParallel( )"]},{"entry":[{},"\u2003.Select(x => \u2212x)"]},{"entry":[{},"\u2003.Take(1000)"]},{"entry":[{},"\u2003.Where(x => x%3 == 0)"]},{"entry":[{},"\u2003.ToArray( );"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Since a motivation for parallelism is improved performance, one embodiment identifies queries that will not be executed efficiently in parallel, and prevents them from being compiled. Some operator sequences may be efficient, but other sequences may not. One embodiment defines two kinds of parallel computations: parallel arrays and parallel sequences. In one embodiment, some operators can be applied to parallel arrays, but not parallel sequences. That way, more operators can be supported than a system based solely on parallel arrays or parallel sequences, and queries are limited in one embodiment to those that can be executed efficiently. One embodiment provides data parallel array and data parallel sequence application programming interfaces (APIs) with static enforcement of usage patterns. In one embodiment, the APIs use types (e.g., query operator types) to statically enforce efficient usage patterns. One embodiment provides a parallel query API based on a combination of parallel sequences and parallel arrays. In one embodiment, the parallel query API allows queries that are determined to be efficient, does not allow queries that are determined to be inefficient, and supports a large number of operators.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1","b":["100","100","102","104","104"]},"Computing device  may also have additional features\/functionality. For example, computing device  may also include additional storage (removable and\/or non-removable) including, but not limited to, magnetic or optical disks or tape. Such additional storage is illustrated in  by removable storage  and non-removable storage . Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any suitable method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Memory , removable storage  and non-removable storage  are all examples of computer storage media (e.g., computer-readable storage media storing computer-executable instructions for performing a method). Computer storage media includes, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other tangible medium that can be used to store the desired information and that can be accessed by computing device . Any such computer storage media may be part of computing device .","Computing device  includes one or more communication connections  that allow computing device  to communicate with other computers\/applications . Computing device  may also include input device(s) , such as keyboard, pointing device (e.g., mouse), pen, voice input device, touch input device, etc. Computing device  may also include output device(s) , such as a display, speakers, printer, etc.","In one embodiment, computing device  includes a data parallel query analysis application . Data parallel query analysis application  is described in further detail below with reference to .",{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 2","FIG. 1","FIG. 1"],"b":["200","100","200","100","200","200","104","115"]},"Data parallel query analysis application  includes program logic , which is responsible for carrying out some or all of the techniques described herein. Program logic  includes logic  for receiving a data parallel query that includes a plurality of operators; logic  for identifying an operator type for each of the query operators based on a type of parallel input data structure the operator operates on and a type of parallel output data structure the operator outputs; logic  for providing query verification data that indicates allowed operations on a parallel array type data structure and a parallel sequence type data structure; logic  for determining whether the query is a prohibited query based on the identified operator types and the query verification data; logic  for preventing the query from being compiled if it is determined that the query is a prohibited query, and for compiling the query if it is determined that the query is not a prohibited query; and other logic  for operating the application.","Turning now to , techniques for implementing one or more embodiments of data parallel query analysis application  are described in further detail. In some implementations, the techniques illustrated in  are at least partially implemented in the operating logic of computing device .",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 3","FIG. 3","FIG. 4"],"b":["308","310","1","310","3","310","312","302","312","308","302","304","306","302","302","312","308","308","312","308","312","308","314","312","308","312","316","308","308"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 4","FIG. 3","FIG. 4","FIG. 3"],"b":["400","308","400","302","312","308","400","402","1","402","4","402","404","1","404","8","404","402","402","306","402","402","1","402","2","402","3","402","4","402","1","402","2","402","3","402","4"]},"In one embodiment, transitions  represent allowed transitions between nodes , and the absence of a transition  indicates that such a transition is not allowed. As indicated by transition (), a parallel array () can be converted to an array () by using a ToArray( ) method. As indicated by transition (), an array () can be converted to a parallel array () by using an AsParallel( ) method. As indicated by transition (), a parallel sequence () can be converted to an array () by using the ToArray( ) method. As indicated by transition (), an enumerable () can be converted to a parallel sequence () by using the AsParallel method. As indicated by transition (), a parallel array () can be converted to a parallel sequence () by performing a partitioning operation. As indicated by transition (), an \u201cAA\u201d type operator receives a parallel array () as an input and generates a parallel array () as an output. As indicated by transition (), an \u201cAB\u201d type operator receives a parallel array () as an input and generates a parallel sequence () as an output. As indicated by transition (), a \u201cBB\u201d type operator receives a parallel sequence () as an input and generates a parallel sequence () as an output. In the illustrated embodiment, the operator transitions ()-() correspond to the operator type data  ().","As shown in , the state diagram  includes two parallel data structures: a parallel array () and a parallel sequence (). These data structures will now be described in further detail, beginning with parallel sequences. One way to implement a parallel sequence () is with a set of enumerators. An enumerator is used to sequentially \u201cwalk\u201d through a sequence. In one embodiment, each enumerator for a parallel sequence () is an object that supports two methods: GetCurrent( ) and MoveNext( ). GetCurrent( ) returns the element that the enumerator is currently positioned at, and MoveNext( ) moves the enumerator to the next element in the sequence, returning false if the end of the sequence is reached. Advancing each enumerator computes one output element. Different enumerators for a given parallel sequence () can be advanced by different computational threads, thus distributing the work onto multiple computational cores.","In one embodiment, a parallel sequence () is implemented as a class that implements an IParallelSequence<T> interface, as shown in the following Pseudo Code Example II:",{"@attributes":{"id":"p-0033","num":"0032"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public interface IParallelSequence<T>"]},{"entry":[{},"{"]},{"entry":[{},"\u2003IEnumerator<T>[ ] GetPartitions( );"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"To execute a parallel computation on a parallel sequence (), the method GetPartitions( ) in Example II is called to obtain a plurality of partitions, and then each partition is processed by a separate enumerator on a separate thread. Additional operations can also be applied to the output of this data parallel computation. This can be done by wrapping each enumerator with another enumerator that applies some operation to the partition. In this manner, another parallel sequence () is generated, to which further parallel operations can be applied.","For an example, consider the PLINQ query given in the following Pseudo Code Example III:",{"@attributes":{"id":"p-0036","num":"0035"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IEnumerable<int> src = ..."]},{"entry":[{},"int[ ] result = src.AsParallel( )"]},{"entry":[{},"\u2003.Where(x => x%2 == 0)"]},{"entry":[{},"\u2003.Select(x => Foo(x))"]},{"entry":[{},"\u2003.ToArray( )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The code in Example III according to one embodiment behaves as follows. AsParallel( ) converts the source array, src, to a parallel sequence (), which includes a number of partitions (e.g., equal to the number of computational cores available). The Where( ) operator wraps each partition with an enumerator that filters out odd integers, and returns a parallel sequence () that contains the wrapped partitions. The Select( ) operator wraps each partition returned by the Where( ) operator with an enumerator that computes Foo(x) for each element, and also returns a parallel sequence (). The ToArray( ) operator takes the parallel sequence () returned by the Select( ) operator, and walks over each partition on a different thread. Walking each enumerator performs the computation, so by walking over different partitions with different threads, the computation is parallelized.","In contrast to the parallel sequence (), a parallel array () according to one embodiment has two properties: (1) it is known ahead of time how many elements the output will contain; and (2) any particular output element can be computed without having to compute all elements that come before it. For example, the fifth element of the output can be computed without computing the first four elements. These two properties may rule out some operations, such as filtering using a user-provided predicate. When filtering, it may not be known how many elements there will be in the output until the predicate is applied to each of the input elements. Similarly, before being able to compute the i-th element of the output, the first i elements that pass the filter will first be found.","In one embodiment, a parallel array () is implemented as a class that implements the IParallelArray<T> interface, as shown in the following Pseudo Code Example IV:",{"@attributes":{"id":"p-0040","num":"0039"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public interface IParallelArray<T>"]},{"entry":[{},"{"]},{"entry":[{},"\u2003int GetResultCount( );"]},{"entry":[{},"\u2003T GetResult(int index);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Calling GetResult(i) will trigger a computation to compute the i-th element of the output. Thus, by calling GetResult( ) for different indices from different threads, the computation can be distributed among multiple computational cores.","In one embodiment, query operators, such as query operators  (), are classified into three types or categories (e.g., AA, AB, and BB), depending on whether they accept and return parallel sequences () or parallel arrays (). An operator  of the AA type according to one embodiment accepts a parallel array () as input and returns a parallel array () as output; an operator  of the AB type according to one embodiment accepts a parallel array () as input and returns a parallel sequence () as output; and an operator  of the BB type according to one embodiment accepts a parallel sequence () as input and also returns a parallel sequence () as output.","The following Table I provides examples of AA type query operators :",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE I"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Select","Projects each element by applying a user-specified"]},{"entry":[{},"projection function to each element. For example,"]},{"entry":[{},"parArray.Select(x => \u2212x) represents a parallel array"]},{"entry":[{},"with each element equal to the corresponding"]},{"entry":[{},"element in parArray, but negated."]},{"entry":["Take(N)","Takes the first N elements of a parallel array. For"]},{"entry":[{},"example, parArray.Take(10) represents a parallel"]},{"entry":[{},"array where each element is equal to the"]},{"entry":[{},"corresponding element in parArray, but the"]},{"entry":[{},"length of the array is limited to 10."]},{"entry":["Reverse","Reverses a parallel array."]},{"entry":["Concat(ParallelList)","Concatenates two parallel arrays."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The following Table II provides an example of an AB type query operator :",{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE II"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["PositionalWhere","PositionalWhere only keeps element whose position in"]},{"entry":[{},"the input matches a particular predicate. For example,"]},{"entry":[{},"src.PositionalWhere(i => i%2 == 0) represents a"]},{"entry":[{},"sequence based on src where elements in odd positions"]},{"entry":[{},"have been filtered out."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The following Table III provides examples of BB type query operators :",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE III"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Select","Projects each element by applying a user-specified"]},{"entry":[{},"projection function to each element. For example,"]},{"entry":[{},"src.Select(x => \u2212x) represents a sequence"]},{"entry":[{},"with each element equal to the corresponding element"]},{"entry":[{},"in src, but negated. Note: Select according to one"]},{"entry":[{},"embodiment is both an AA and a BB type operator."]},{"entry":["Where","Where only keeps elements that match a particular"]},{"entry":[{},"predicate. For example, src.Where(x => x%2==0)"]},{"entry":[{},"represents a sequence based on src where odd"]},{"entry":[{},"elements were filtered out."]},{"entry":["SelectMany","SelectMany is a generalization of a Select. Select"]},{"entry":[{},"converts each element to exactly one element."]},{"entry":[{},"SelectMany converts each element in the input"]},{"entry":[{},"into zero or more elements. SelectMany according"]},{"entry":[{},"to one embodiment performs a one-to-many projection on"]},{"entry":[{},"sequence elements"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"It will be understood that additional or different operators than those listed in Tables I-III may be used, and that Tables I-III are not meant to be limiting.","State diagram  will now be described in further detail with reference to a couple of example queries. As a first example, consider the PLINQ query given in the following Pseudo Code Example V:",{"@attributes":{"id":"p-0051","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int[ ] arr = ...;"]},{"entry":[{},"int[ ] result = arr.AsParallel( )"]},{"entry":[{},".Select(x => Foo(x))"]},{"entry":[{},".Take(1000)"]},{"entry":[{},".Where(x => x%3 == 0)"]},{"entry":[{},".ToArray( );"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The query given in Example V is allowed by the state diagram . This can be confirmed by tracing the query through the state diagram . On the first line of Example V, an array (), arr, is defined. On the second line, AsParallel( ) is applied to the array (), thereby converting the array () to a parallel array (), which is allowed as indicated by transition (). On the third and fourth lines, AA type operators  are used, so the result will be a parallel array (), which is allowed as indicated by transition (). On the fifth line, a BB type operator  is used, so partitioning will happen (transition ()) to generate a parallel sequence (), and the output result will be a parallel sequence () (transition ()). On the sixth line, ToArray( ) is called to execute the query and generate a regular array () as the output of the query.","As a second example, consider the PLINQ query given in the following Pseudo Code Example VI:",{"@attributes":{"id":"p-0054","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int[ ] arr = ...;"]},{"entry":[{},"int[ ] result ="]},{"entry":[{},"arr.AsParallel( )"]},{"entry":[{},"\u2003.Where(x => x%3 == 0)"]},{"entry":[{},"\u2003.Take(1000)"]},{"entry":[{},"\u2003.ToArray( );"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The query given in Example VI is not allowed by the state diagram , because the output of the BB type Where( ) operator is a parallel sequence (), but the Take( ) operator is an AA type operator , which is applied to parallel arrays (), and there is no transition  from a parallel sequence () to a parallel array (). In one embodiment, the compiler  () would throw an error or generate a prohibited query indication  if the user wrote this query. The indication  according to one embodiment indicates that the query would not be efficiently executed in parallel.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 5","b":["500","308","502","500","308","310","308"]},"At , an operator type for each of the query operators  is identified based on a type of parallel input data structure the operator  operates on and a type of parallel output data structure the operator  outputs. In one embodiment, the type of parallel input data structure and the type of parallel output data structure for each operator  are each one of a parallel array () type of data structure and a parallel sequence () type of data structure. In one embodiment, the parallel array () type of data structure comprises an interface including a first method for providing indexed access to elements in the data structure, and a second method for obtaining a count value representing a total number of elements in the data structure. The parallel sequence () type of data structure according to one embodiment comprises an interface including a method for partitioning the data structure into a plurality of partitions and enumerating through the plurality of partitions with a plurality of enumerators.","The parallel array () type of data structure and the parallel sequence () type of data structure according to one embodiment are each \u201clazy\u201d data structures. A \u201clazy\u201d data structure according to one embodiment is a structure in which the elements are computed on-demand (as opposed to \u201ceagerly\u201d). For example, in one embodiment, when an element of a lazy data structure is first accessed, the element is computed at that time; and if the element is accessed again later, the element is recomputed at that time. In one embodiment, elements that have already been computed may be stored in memory to avoid re-computing these elements.","At  in method , it is determined whether the query  is a prohibited query  based on the identified operator types. In one embodiment, the operator types include a first operator type configured to operate on the parallel array () type of data structure and output the parallel array () type of data structure. Operators  of the first operator type according to one embodiment include at least one of a Select operator configured to perform a projection on array elements, a Take operator configured to take a user-specified number of array elements, a Reverse operator configured to reverse positions of array elements, and a Concatenate operator configured to concatenate two parallel arrays. In one embodiment, the operator types further include a second operator type configured to operate on the parallel sequence () type of data structure and output the parallel sequence () type of data structure. Operators  of the second operator type according to one embodiment include at least one of a Select operator configured to perform a projection on sequence elements, a Where operator configured to keep sequence elements that match a user-specified predicate, and a SelectMany operator configured to perform a one-to-many projection on sequence elements. In one embodiment, the operator types further include a third operator type configured to operate on the parallel array () type of data structure and output the parallel sequence () type of data structure. Operators  of the third operator type according to one embodiment include a PositionalWhere operator configured to keep array elements whose position matches a user-specified predicate.","At  in method , the query  is prevented from being compiled if it is determined at  that the query  is a prohibited query , and the query  is compiled if it is determined at  that the query  is not a prohibited query .",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 6","b":["600","308","602","308","310","308","402","3","402","4","310","402","3","402","4","604","302","402","3","402","4","606","308","316","310","302"]},"Although specific embodiments have been illustrated and described herein, it will be appreciated by those of ordinary skill in the art that a variety of alternate and\/or equivalent implementations may be substituted for the specific embodiments shown and described without departing from the scope of the present invention. This application is intended to cover any adaptations or variations of the specific embodiments discussed herein. Therefore, it is intended that this invention be limited only by the claims and the equivalents thereof."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings are included to provide a further understanding of embodiments and are incorporated in and constitute a part of this specification. The drawings illustrate embodiments and together with the description serve to explain principles of embodiments. Other embodiments and many of the intended advantages of embodiments will be readily appreciated, as they become better understood by reference to the following detailed description. The elements of the drawings are not necessarily to scale relative to each other. Like reference numerals designate corresponding similar parts.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
