---
title: Compile-time dispatch of operations on type-safe heterogeneous containers
abstract: Implementing a type-safe heterogeneous containers in a memory arrangement of a computing system. In one embodiment, a main object of a class is specified in program source code. The class has a variant type, and the variant type provides at least two different data types, at least one of which is a linear array of objects of one of the data types. The class includes methods for putting and getting a variant object of the variant type in and from the main object. An application of a visitor method, which includes a respective operator for each of the different data types, is specified in the program source code for each method for getting a variant object from the main object. Compilation of the source code results in code that executes the one of the operators corresponding to the data type of a referenced variant object of the main object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07669191&OS=07669191&RS=07669191
owner: Xilinx, Inc.
number: 07669191
owner_city: San Jose
owner_country: US
publication_date: 20050614
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["COPYRIGHT NOTICE","FIELD OF THE INVENTION","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","EXAMPLE 1","EXAMPLE 2","EXAMPLE 3","EXAMPLE 4"],"p":["A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","The present invention generally relates to resolving at compile time operations on type-safe heterogeneous containers.","Methods and data structures that are parameterized by type are commonly used in implementing software solutions in object-oriented programming languages, including, for example, C++. Typesafe homogeneous containers are implemented in the Standard C++ Library (SL) using the language-provided template mechanism. A homogeneous container has constituent objects of the same data type. A heterogeneous container has objects of different types. For example, a C++ structure is a heterogeneous container. The size and composition of a structure, are determined at compile time, which limits flexibility.","A commonly used approach by which heterogeneous containers are implemented in C++ is via polymorphism and the run-time type identification (RTTI) facility of C++. Classes that derive from a common base class can be stored in a container via base class pointer and then down cast to the dynamic type upon extraction from the container.","This approach has a number of disadvantages. The polymorphism requires that types supported by the container inherit from a common base class, which may be invasive or restrict implementation flexibility. Furthermore, use of the RTTI facility may introduce substantial overhead since the resolution of data types occurs at runtime. In addition the use of RTTI may increase coding complexity, along with costs of testing and maintaining the program.","The present invention may address one or more of the above issues.","The various embodiments of the invention provide various approaches for implementing a type-safe heterogeneous containers in a memory arrangement of a computing system. In one embodiment, a main object of a class is specified in program source code. The class has a variant type, and the variant type provides at least two different data types, at least one of which is a linear array of objects of one of the data types. In another embodiment, a dictionary data type is one of the variant types. The class includes methods for putting and getting a variant object of the variant type in and from the main object. An application of a visitor method, which includes a respective operator for each of the different data types, is specified in the program source code for each method for getting a variant object from the main object. Invocations of the methods for putting objects in and getting objects from the main object are specified in the program source code. Compilation of the source code results in code that executes the one of the operators corresponding to the data type of a referenced variant object of the main object.","In another embodiment, an apparatus is provided for implementing a data object in a memory arrangement of a computing system. The apparatus includes means for specifying in program source code, a main object of a class, the class having a variant type and the variant type providing at least two different data types, wherein at least one of the data types is a linear array of objects of one of the data types, the class including a first method for putting a variant object of the variant type in the main object and a second method for getting a variant object of the variant type from the main object; means for specifying in the program source code for each method for getting a variant object from the main object, application of a visitor method, the visitor method including a respective operator for each of the different data types; means for specifying in the program source code at least one invocation of the first method for putting at least two variant objects of different variant types into the main object and invocations of the second method for getting variant objects from the main object; and means for compiling the program source code, wherein for each invocation of the second method executable code is generated that executes the one of the operators corresponding to the data type of a referenced variant object of the main object.","It will be appreciated that various other embodiments are set forth in the Detailed Description and claims which follow.","The various embodiments of the invention provide an approach for making a typesafe heterogeneous container with type-dependent operator resolution performed at compile time rather than at runtime. Further embodiments provide conversion to and from an external data format that is suitable for persistent storage.","In one embodiment, a class, named XTable in this description, is defined for use as a typesafe container (the objects stored in the container are unambiguously typed) for objects of different data types. The application programming interface (API) provided by the XTable class provides a mechanism for compile time dispatched typesafe access to stored objects. The XTable class is also serializable, which supports conversion of the object data in the container to and from an external data format suitable for persistent storage. In a program that uses the XTable container, the code that gets called when invoking the XTable API is identified at compile time, which eliminates the need for runtime resolution of data types used in operations with the container.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1","b":["102","104","106","102","108","110"]},"The compiler  compiles program code  into executable code (not shown) that is stored in a memory . The possible types of XTable objects that may be specified by the program code and created by the compiler and instantiated when the program is executed are shown collectively as objects .","An XTable object may have a single element of type bool, int, double, or string. Alternatively, an XTable object may have a sequence or a dictionary. A sequence is an ordered set of objects of the same variant type, and a dictionary is a set of key-value pairs with each value being indexed by the key and being of the same variant type. Sequence objects and dictionary objects may be recursively nested as illustrated in . The possible types of XTable objects are shown as blocks in memory .","Block  illustrates a Null XTable object. A Null XTable object has no data and may be used in a sequence XTable object to indicate the end of the sequence, for example. Block  illustrates a bool XTable object which contains a Boolean value. Block  is an int XTable object for storing an integer value, and block  is a double XTable object for storing a double precision floating point value. The string Xtable object is shown as block  and stores a character string.","Block  shows a sequence XTable object. A sequence XTable object includes multiple XTable objects which may be of different variant types. A dictionary Xtable object is shown by block . A dictionary XTable object may have multiple XTable objects (possibly of different variant types) that are indexed by respective keys. Key  and XTable  show an example key-XTable pair in a dictionary. Sequence XTable objects and dictionary XTable objects may be recursively defined or \u201cnested.\u201d",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2","b":["202","202","204","204","206"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3","b":["302","302","304","304","304","306"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 4","FIG. 4"],"b":"402"},"The example XTable class may be used to create and use type-safe sequences and dictionaries of heterogeneous objects with compile-time resolution of references to member methods based on data types of referenced objects. Following the description of the XTable class, example test code is presented in the Appendices to illustrate use of the access methods and serialization methods of an XTable object. The examples described herein are in the C++ programming language. Those skilled in the art will recognize that the invention could be implemented in alternative object-oriented programming languages.","The following description of the XTable class presents syntactically correct type definitions and accompanying comments set off by \u201c\/\/\u201d. The public data types include the following:\n\n","Included in the class definition is a variant type definition (step ). In one embodiment, the variant type may be implemented using a variant library, which is part of the Boost component library (http:\/\/www.boost.org\/index.htm). In addition to the basic data types of NULL, bool, int, double, and string, the sequence and dictionary data types are added to the variant typeset. Compile time dispatching of variant operations (such as serialization) is provided by the visitor pattern supported by the variant.","Objects that support the visitor pattern enable compile time dispatch of operations by implementing a visitable interface. A simplified version of such an interface and an example of an object that implements the interface are shown in the example code that follows.","class Visitable: public XKey {","public:\n\n","};","class Block: public Visitable {\n\n","}","The Visitor interface, as shown in the example code below, provides apply methods for a variety of concrete types that implement the visitable interface.","class Visitor {","public:\n\n","}","The Visitor interface is implemented and the implementation is passed to the accept method of the object that implements the Visitable interface. The below example of a concrete visitor simple extracts the name of the Block object.","struct PrintName: public Visitor {\n\n","};","One of the features of this pattern is that a heterogeneous collection of objects that implement the Visitable may be held via base class pointer and operations may be performed on the objects (such as serialization) by applying the appropriate visitor. The dispatching of the appropriate method for the concrete implementation of the Visitable interface is handled at compile time via the virtual function mechanism and function overloading features of the core language.","Returning now to the XTable class, from the public type definitions it may be observed that an element of an XTable::Sequence or the value type of an XTable::Dictionary may itself be an XTable, which shows that the underlying variant supports recursive definition. The recursive definitions may be used to construct a nested heterogeneous tree of objects. For example, a sequence may contain an object that is a dictionary, which may contain an object that is a sequence and so on.","The XTable class also includes methods for creating an XTable object and for inserting objects, reading, and removing objects from an XTable object. The public member methods of the XTable class include:\n\n","The access methods are generally referred to as put methods and get methods. The get and put methods apply to all variant types and example declarations are listed below.\n\n","It will be appreciated that in the family of put methods the required template parameter is inferred by the compiler from the data types of the arguments provided in the calls to the put methods. Thus, to add an object to an XTable object, a put method in the program includes an object reference from which the compiler may determine the type (step ). The containers themselves (in this case std::deque & std::map) keep track the size of sequence and dictionary XTable objects. The begin( ) and end( ) methods of the respective containers return iterators to the beginning and one beyond the end of the container contents.","Calls to the XTable get methods in the program require disambiguation of the variant types. The disambiguation may be accomplished in one of two ways (steps  and ). In one use, a call to a get method may explicitly specify the type (step ). Alternatively, the get methods may be implemented without RTTI using a generic visitor that handles all variant types (step ). The compiler dispatches the correct overloaded function for both the use case having an explicit specification of the variant type and the use case involving the generic visitor (step ).","The code in Example 1 below shows an implementation of an example get method. This get method may be called with an explicit specification of one of the variant types. The generic visitor, table_const_ptr_extractor( ) (shown in the code of Example 2) supports compile-time dispatch of the proper operation according to the variant data type referenced by the get operation.","template<typename REQUEST_TYPE>REQUEST_TYPE* XTable::get( )","{\n\n","}","The get method applies the visitor object using as an input parameter a REQUEST_TYPE provided in the call to the get method. The compiler selects the correct overloaded operator( ) based upon whether the variant type of the referenced object matches the input REQUEST_TYPE. Example 2 below shows program code that implements a visitor routine for extracting a const pointer from a variant data type.","\/\/Visitor for extracting const pointer from variant","\/\/","template <typename REQUEST_TYPE>","struct table_const_ptr_extractor\n\n","{\n\n","};","The appropriate overloaded operators to call is determined at compile time by the compiler via the variant visitor mechanism. If the variant type in the XTable passed to operator( ) matches the REQUEST_TYPE specified by the call to the get method (as determined by the compiler), the appropriate XTable element is returned by pointer (\u201creturn &operand\u201d in the example code) otherwise the null pointer is returned. The get method takes a type template parameter, for example, table.get<int>( ). If the XTable variant type is an int, the get method returns a pointer to the int; if the variant is not an int, then the returned pointer is null.","A generic visitor may also be used in disambiguating the variant types of an XTable object for serialize and deserialize operations. In processing an entire XTable object with support from a generic visitor, the compiler dispatches the correct overloaded function according to the variant type of each object in the XTable object. The serialize and deserialize operations may be used for purposes of saving and restoring XTable data.","The general approach to process a sequence is to get the sequence itself from the top-level XTable object and then iterate over the objects in the sequence using the std::deque or std::map interfaces to access container contents for a sequence. A similar approach may be followed to access a dictionary. The code of Example 3 below illustrates getting objects from a sequence.","\/\/Get the sequence from the top level table","\/\/Iterate over the sequence using std::deque interface methods","\/\/Access the XTable sequence element","XTable::Sequence* seq=table.get<XTable::Sequence>( );","for(XTable::Sequence::iterator iter=seq->begin( );\n\n","{\n\n","}","The XTable class includes serialize, deserialize, and print public methods for outputting, inputting and printing data for an XTable object. For example, the data in an XTable object may be converted from the different variant data types to an ASCII character string representation for saving in retentive storage. The reverse conversion may be performed for restoring the data to an XTable object. These methods are referred to as serialization methods and include:\n\n","The XSerialize class set forth below provides the private implementation of the serialize and deserialize methods. The XSerialize class implements the visitor pattern referred to earlier.","class XSerialize<XTable>","class XSerialize<XTable>::binary_serialize","class XSerialize<XTable>::ascii_serialize","The code in Example 4 below implements an example XSerialize::encode method that applies either the ascii_serialize or the binary_serialize visitor to execute serialization. The \u201cbinary_serialize serializer(os)\u201d is the construction of the serializer object, with its construction argument a binary stream (os). The constructed serializer instance is passed to the apply_visitor method.","static void encode(std::ostream& os, TABLE& table,\n\n","{\n\n","} else {\n\n","}","Following the description of the remaining members of the XTable class, further examples are provided to describe use of the generic visitor.","The XTable class also includes additional public methods that may be used in combination with the methods for inserting and removing objects from an XTable. These additional public methods of the XTable class include:","template<typename REQUSET_TYPE>bool is_a const","\/\/Returns true if top-level variant is of the specified data type.","bool empty ( ) const","\/\/XTable non initialized.","std::string type ( ) const","\/\/Returns a string representation of the data of a variant type.","A set of public methods are included in the XTable class for inserting and removing dictionary objects from an XTable object. The dictionary_insert and dictionary_retrieve methods are provided to access multiply nested dictionaries. The dictionary access methods include:\n\n","Appendix A sets forth an example test program that uses the XTable class. The xtable_accessors( ) routine tests put and get methods on sequence-type and dictionary-type XTable objects. The xtable_serialize( ) routine tests the serialization methods on the sequence-type and dictionary-type XTable objects.","Appendix B shows the text output from the test program of Appendix A.","Appendix C shows an example implementation of a binary_serialize method. Each of the overloaded operator( )'s is for one of the variant types. It will be appreciated that the operator( ) for a sequence iterates over the number of XTable objects in the sequence. Similarly, the operator( ) for a dictionary iterates over the key-value pairs in the dictionary. Both the sequence operator( ) and the dictionary operator( ) are recursive to iterate over recursive sequences and dictionaries.","Those skilled in the art will appreciate that various alternative computing arrangements, including one or more processors and a memory arrangement configured with program code, would be suitable for hosting the processes and data structures of the different embodiments of the present invention. Various tools for composing and compiling a program may be adapted in accordance with the various embodiments of the invention. In addition, the processes may be provided via a variety of computer-readable media or delivery channels such as magnetic or optical disks or tapes, electronic storage devices, or as application services over a network.","The present invention is thought to be applicable to a variety of systems for implementing type-safe heterogeneous containers. Other aspects and embodiments of the present invention will be apparent to those skilled in the art from consideration of the specification and practice of the invention disclosed herein. It is intended that the specification and illustrated embodiments be considered as examples only, with a true scope and spirit of the invention being indicated by the following claims.",{"@attributes":{"id":"p-0093","num":"0198"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"APPENDIX A"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/*"},{"entry":"* Copyright (c) 2005, Xilinx, Inc. All rights reserved."},{"entry":"\u2003*"},{"entry":"* Description: Test routines for XTable."},{"entry":"\u2003*"},{"entry":"*\/"},{"entry":"\/\/ Boost"},{"entry":"\/\/ \u2003- c.f. http:\/\/www.boost.org\/libs\/test"},{"entry":"#include <boost\/test\/unit_test_suite.hpp>"},{"entry":"#include <boost\/test\/test_tools.hpp>"},{"entry":"#include <boost\/random\/linear_congruential.hpp>"},{"entry":"#include <boost\/random\/uniform_int.hpp>"},{"entry":"#include <boost\/random\/uniform_real.hpp>"},{"entry":"#include <boost\/random\/variate_generator.hpp>"},{"entry":"#include <sstream>"},{"entry":"\/\/ Using"},{"entry":"using boost::unit_test::test_suite;"},{"entry":"using std::stringstream;"},{"entry":"static"},{"entry":"void"},{"entry":"xtable_accessors( )"},{"entry":"{"},{"entry":"\u2003XUtility::print(\u201cTesting Scalar XTable\u201d);"},{"entry":"\u2003\/\/ Simple XTable - top level scaler (bool, int or double)"},{"entry":"\u2003XTable table0;"},{"entry":"\u2003\/\/ put method -- variant type is inferred"},{"entry":"\u2003table0.put(3.1415);"},{"entry":"\u2003\/\/ get method must specify type"},{"entry":"\u2003double* dbl_ptr = table0.get<double>( );"},{"entry":"\u2003std::cout << \u201cshould be double - \u201d << *dbl_ptr << std::endl;"},{"entry":"\u2003\/\/ int_ptr will be null"},{"entry":"\u2003int* int_ptr = table0.get<int>( );"},{"entry":"\u2003std::cout << \u201cshould be null - \u201d << int_ptr << std::endl;"},{"entry":"\u2003XUtility::print(\u201c**\u201d);"},{"entry":"\u2003XUtility::print(\u201cTesting Sequence XTable\u201d);"},{"entry":"\u2003\/\/ XTable with top level sequence"},{"entry":"\u2003XTable table1;"},{"entry":"\u2003\/\/ A Sequence is a linear array of XTables (std::deque)"},{"entry":"\u2003XTable::Sequence& seq = table1.put<XTable::Sequence>( );"},{"entry":"\u2003\/\/ XTable::Sequence inherits from std::deque which provides the"},{"entry":"\u2003\/\/ push_back method. An XTable object is pushed to the end of"},{"entry":"\u2003\/\/ a sequence."},{"entry":"\u2003seq.push_back(1.002); \u2003\/\/ double"},{"entry":"\u2003seq.push_back(\u201cfoo\u201d); \u2003\/\/ string"},{"entry":"\u2003seq.push_back(12311); \u2003\/\/integer"},{"entry":"\u2003\/\/ The std::deque also provides the get access methods and has an"},{"entry":"\u2003\/\/ iterator interface with support for referencing objects by array"},{"entry":"\u2003\/\/ indexing (\u201coperator[ ]\u201d)."},{"entry":"\u2003\/\/ The print method calls the get access methods."},{"entry":"\u2003table1.print( );"},{"entry":"\u2003XUtility::print(\u201c**\u201d);"},{"entry":"\u2003XUtility::print(\u201cTesting Dictionary XTable\u201d);"},{"entry":"\u2003\/\/ XTable with top level dictionary"},{"entry":"\u2003\u2003XTable table2;"},{"entry":"\u2003\/\/ A Dictionary is a mapping from string to XTable (std::map)"},{"entry":"\u2003XTable::Dictionary& dict1 = table2.put<XTable::Dictionary>( );"},{"entry":"\u2003dict1.insert(\u201ckey1\u201d, 1.0);"},{"entry":"\u2003dict1.insert(\u201ckey2\u201d, 1);"},{"entry":"\u2003dict1.insert(\u201ckey3\u201d, \u201cfoo\u201d);"},{"entry":"\u2003\/\/ Another dictionary to embed in the top level XTable"},{"entry":"\u2003\u2003XTable sub_table2;"},{"entry":"\u2003XTable::Dictionary& dict2 = sub_table2.put<XTable::Dictionary>( );"},{"entry":"\u2003dict2.insert(\u201cskey1\u201d, 1.0);"},{"entry":"\u2003dict2.insert(\u201cskey2\u201d, 2.0);"},{"entry":"\u2003dict2.insert(\u201cskey3\u201d, 3.0);"},{"entry":"\u2003\/\/ Embed the sub table into the top table"},{"entry":"\u2003dict1.insert(\u201ckey4\u201d, sub_table2);"},{"entry":"\u2003table2.print( );"},{"entry":"\u2003XUtility::print(\u201c**\u201d);"},{"entry":"}"},{"entry":"static"},{"entry":"void xtable_serialize( )"},{"entry":"{"},{"entry":"\u2003\/\/ string stream"},{"entry":"\u2003std::stringstream inout_stream;"},{"entry":"\u2003\/\/ ASCII representation of an xtable"},{"entry":"\u2003std::string sample(\u201c{\\n\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201c \u2018mydouble\u2019=>3.1415,\\n\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201c \u2018myseq\u2019=>[1, 2.78, \u2018foo\u2019, \u2018bar\u2019]\\n\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201c \u2018myhash\u2019=>{\\n\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201c\u2003\u2018sourceFile\u2019=>\u2018hdl_71\/synth_addsub.vhd\u2019,\\n\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201c\u2003\u2018templateKeyValues\u2019=>{\\n\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201c"},{"entry":"\u2018core_name0\u2019=>\u2018adder_subtracter_virtex2_7_0_77239f4f28af6e47\u2019,\\n\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201c\u2003\u2003\u2018foo_int\u2019=>42,\\n\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201c\u2003\u2003\u2018foo_double\u2019=>[72.42, 92, \u2018hello world\u2019]\\n\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201c\u2003\u2003\u2018foo_bool\u2019=>false,\\n\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201c\u2003}\\n\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201c },\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201c \u2018sub\u2019=>\u2018SgDeliverFile::saveCollaborationInfo\u2019\\n\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201c}\\n\u201d);"},{"entry":"\u2003\/\/ Write the above stringofied sample XTable to a bidirectional"},{"entry":"\u2003stringstream inout_stream << sample;"},{"entry":"\u2003\/\/ ASCII deserialize the xtable"},{"entry":"\u2003XTable table1;"},{"entry":"\u2003table1.deserialize(inout_stream);"},{"entry":"\u2003\/\/ Binary serialize the table"},{"entry":"\u2003std::stringstream inout_stream2;"},{"entry":"\u2003table1.serialize(inout_stream2, std::ios::binary);"},{"entry":"\u2003\/\/ Binary deserialize the table"},{"entry":"\u2003XTable table2;"},{"entry":"\u2003table2.deserialize(inout_stream2, std::ios::binary);"},{"entry":"\u2003\/\/ Tables should be identical"},{"entry":"\u2003XUtility::print(\u201ctable1\u201d);"},{"entry":"\u2003table1.print( );"},{"entry":"\u2003XUtility::print(\u201ctable2\u201d);"},{"entry":"\u2003table2.print( );"},{"entry":"\u2003XUtility::print(\u201c**\u201d);"},{"entry":"}"},{"entry":"namespace Sysgen {"},{"entry":"\u2003namespace Test {"},{"entry":"\u2003\u2003test_suite*"},{"entry":"\u2003\u2003xtable_test( )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003test_suite* ts = BOOST_TEST_SUITE (\u201cXTable\u201d);"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003ts->add( BOOST_TEST_CASE( &xtable_accessors ) );"},{"entry":"\u2003\u2003\u2003\u2003ts->add( BOOST_TEST_CASE( &xtable_serialize ) );"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003return ts;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}; \/\/ ending namespace Test"},{"entry":"}; \/\/ ending namespace Sysgen"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0094","num":"0199"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"APPENDIX B"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"--------------------------------------------------"},{"entry":"Entering test suite \u201cXTable\u201d"},{"entry":"---------------------------- Testing Scalar XTable ----------------------------"},{"entry":"should be double - 3.1415"},{"entry":"should be null - 00000000"},{"entry":"-------------------------------------- ** --------------------------------------"},{"entry":"---------------------------- Testing Sequence XTable ----------------------------"},{"entry":"["},{"entry":"\u20031.0020000000000000,"},{"entry":"\u2003\u2018foo\u2019,"},{"entry":"\u200312311"},{"entry":"]"},{"entry":"-------------------------------------- ** --------------------------------------"},{"entry":"---------------------------- Testing Dictionary XTable ---------------------------- "},{"entry":"{"},{"entry":"\u2003\u2018key1\u2019=>1.0000000000000000,"},{"entry":"\u2003\u2018key2\u2019=>1,"},{"entry":"\u2003\u2018key3\u2019=>\u2018foo\u2019,"},{"entry":"\u2003\u2018key4\u2019=>{"},{"entry":"\u2003\u2003\u2018skey1\u2019=>1.0000000000000000,"},{"entry":"\u2003\u2003\u2018skey2\u2019=>2.0000000000000000,"},{"entry":"\u2003\u2003\u2018skey3\u2019=>3.0000000000000000"},{"entry":"\u2003}"},{"entry":"}"},{"entry":"-------------------------------------- ** --------------------------------------"},{"entry":"---------------------------- Testing Serialization ---- ------------------------"},{"entry":"------------------------------------ table1 ------------------------------------"},{"entry":"{"},{"entry":"\u2003\u2018mydouble\u2019=>3.1415000000000002,"},{"entry":"\u2003\u2018myhash\u2019=>{"},{"entry":"\u2003\u2003\u2018sourceFile\u2019=>\u2018hdl_71\/synth_addsub.vhd\u2019,"},{"entry":"\u2003\u2003\u2018templateKeyValues\u2019=>{"},{"entry":"\u2003\u2003\u2003\u2018core_name0\u2019=>\u2018adder_subtracter_virtex2_7_0_77239f4f28af6e47\u2019,"},{"entry":"\u2003\u2003\u2003\u2018foo_bool\u2019=>false,"},{"entry":"\u2003\u2003\u2003\u2018foo_double\u2019=>["},{"entry":"\u2003\u2003\u2003\u200372.420000000000002,"},{"entry":"\u2003\u2003\u2003\u200392,"},{"entry":"\u2003\u2003\u2003\u2003\u2018hello world\u2019"},{"entry":"\u2003\u2003\u2003],"},{"entry":"\u2003\u2003\u2003\u2018foo_int\u2019=>42"},{"entry":"\u2003\u2003}"},{"entry":"\u2003},"},{"entry":"\u2003\u2018myseq\u2019=>["},{"entry":"\u2003\u20031,"},{"entry":"\u2003\u20032.7799999999999998,"},{"entry":"\u2003\u2003\u2018foo\u2019,"},{"entry":"\u2003\u2003\u2018bar\u2019"},{"entry":"\u2003],"},{"entry":"\u2003\u2018sub\u2019=>\u2018SgDeliverFile::saveCollaborationInfo\u2019"},{"entry":"}"},{"entry":"------------------------------------ table2 ------------------------------------"},{"entry":"{"},{"entry":"\u2003\u2018mydouble\u2019=>3.1415000000000002,"},{"entry":"\u2003\u2018myhash\u2019=>{"},{"entry":"\u2003\u2003\u2018sourceFile\u2019=>\u2018hdl_71\/synth_addsub.vhd\u2019,"},{"entry":"\u2003\u2003\u2018templateKeyValues\u2019=>{"},{"entry":"\u2003\u2003\u2003\u2018core_name0\u2019=>\u2018adder_subtracter_virtex2_7_0_77239f4f28af6e47\u2019,"},{"entry":"\u2003\u2003\u2003\u2018foo_bool\u2019=>false,"},{"entry":"\u2003\u2003\u2003\u2018foo_double\u2019=>["},{"entry":"\u2003\u2003\u2003\u200372.420000000000002,"},{"entry":"\u2003\u2003\u2003\u200392,"},{"entry":"\u2003\u2003\u2003\u2003\u2018hello world\u2019"},{"entry":"\u2003\u2003\u2003],"},{"entry":"\u2003\u2003\u2003\u2018foo_int\u2019=>42"},{"entry":"\u2003\u2003}"},{"entry":"\u2003},"},{"entry":"\u2003\u2018myseq\u2019=>["},{"entry":"\u2003\u20031,"},{"entry":"\u2003\u20032.7799999999999998,"},{"entry":"\u2003\u2003\u2018foo\u2019,"},{"entry":"\u2003\u2003\u2018bar\u2019"},{"entry":"\u2003],"},{"entry":"\u2003\u2018sub\u2019=>\u2018SgDeliverFile::saveCollaborationInfo\u2019"},{"entry":"}"},{"entry":"-------------------------------------- ** --------------------------------------"},{"entry":"-------------------------------------- ** --------------------------------------"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0095","num":"0200"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"APPENDIX C"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/*"},{"entry":"* Copyright (c) 2005, Xilinx, Inc. All rights reserved."},{"entry":"\u2003*"},{"entry":"* Description: Test routines for XTable."},{"entry":"\u2003*"},{"entry":"*\/"},{"entry":"\u2003\/\/ Serialization helper"},{"entry":"\u2003\/\/"},{"entry":"\u2003class binary_serialize : public boost::static_visitor<void>"},{"entry":"\u2003{"},{"entry":"\u2003public:"},{"entry":"\u2003\u2003binary_serialize(std::ostream& os) :"},{"entry":"\u2003\u2003\u2003_os(os)"},{"entry":"\u2003\u2003\u2003{;}"},{"entry":"\u2003\u2003\u2003\/\/ Each of the overloaded operator( )'s is for one of the variant"},{"entry":"\u2003\u2003\u2003\/\/ types"},{"entry":"\u2003\u2003\u2003\/\/ The tags that are written by the different operators indicate the"},{"entry":"\u2003\u2003\u2003\/\/ data type of the bits that follow. The tags are read first during"},{"entry":"\u2003\u2003\u2003\/\/ deserialization and then the following bytes are interpreted"},{"entry":"\u2003\u2003\u2003\/\/ appropriately."},{"entry":"\u2003\u2003\/\/Serialize null"},{"entry":"\u2003\u2003void operator( )(const typename TABLE::Null& operand)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Write tag"},{"entry":"\u2003\u2003\u2003\u2003_os.write((char*)&TABLE_NULL_TAG, TAG_LENGTH);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\/\/ Serialize bool"},{"entry":"\u2003\u2003void operator( )(const bool& operand)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Write tag"},{"entry":"\u2003\u2003\u2003\u2003_os.write((char*)&BOOL_TAG, TAG_LENGTH);"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Write byte"},{"entry":"\u2003\u2003\u2003\u2003_os.put(operand);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\/\/serialize int"},{"entry":"\u2003\u2003void operator( )(const int& operand)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Write tag"},{"entry":"\u2003\u2003\u2003\u2003_os.write((char*)&INT_TAG, TAG_LENGTH);"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Write 4 bytes for int (big endian)"},{"entry":"\u2003\u2003\u2003\u2003write_int(operand);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\/\/ Serialize double"},{"entry":"\u2003\u2003void operator( )(const double& operand)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Write tag"},{"entry":"\u2003\u2003\u2003\u2003_os.write((char*)&DOUBLE_TAG, TAG_LENGTH);"},{"entry":"\u2003\u2003\u2003\u2003union DoubleBytes { double d; char c[8]; };"},{"entry":"\u2003\u2003\u2003\u2003DoubleBytes double_bytes;"},{"entry":"\u2003\u2003\u2003\u2003double_bytes.d = operand;"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Write bytes in big-endian ordering."},{"entry":"\u2003\u2003\u2003\u2003for (int i = 7; i >= 0 ; --i)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003_os.write( reinterpret_cast<char"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003*>(&double_bytes.c[i]) , 1);"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\/\/ Serialize string"},{"entry":"\u2003\u2003void operator( )(const std::string& operand)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Write tag"},{"entry":"\u2003\u2003\u2003\u2003_os.write((char*)&STRING_TAG, TAG_LENGTH);"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Write size"},{"entry":"\u2003\u2003\u2003\u2003write_int(operand.size( ));"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Write chars"},{"entry":"\u2003\u2003\u2003\u2003for(size_t i=0; i<operand.size( ); ++i) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003_os.put(operand[i]);"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\/\/ Serialize Sequence"},{"entry":"\u2003\u2003void operator( )(const typename TABLE::Sequence& operand)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Write tag"},{"entry":"\u2003\u2003\u2003\u2003_os.write((char*) &TABLE_SEQUENCE_TAG,"},{"entry":"\u2003\u2003\u2003\u2003TAG_LENGTH);"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Write size"},{"entry":"\u2003\u2003\u2003\u2003write_int(operand.size( ));"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Write elements"},{"entry":"\u2003\u2003\u2003\u2003\/\/ The \u201coperand[i]._mask allows a user to selectively mask of"},{"entry":"\u2003\u2003\u2003\u2003\/\/ portions of the XTable object such that when serialization"},{"entry":"\u2003\u2003\u2003\u2003\/\/ occurs that portion of the table is not written."},{"entry":"\u2003\u2003\u2003\u2003for(size_t i=0; i<operand.size( ); ++i){"},{"entry":"\u2003\u2003\u2003\u2003\u2003if(operand[i]._mask) continue;"},{"entry":"\u2003\u2003\u2003\u2003\u2003binary_serialize serializer(_os);"},{"entry":"\u2003\u2003\u2003\u2003\u2003boost::apply_visitor(serializer, operand[i]._element);"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\/\/ Serialize Dictionary"},{"entry":"\u2003\u2003void operator( )(const typename TABLE::Dictionary& operand) {"},{"entry":"\u2003\u2003\u2003\/\/ Write tag"},{"entry":"\u2003\u2003\u2003_os.write((char*) &TABLE_HASH_TAG, TAG_LENGTH);"},{"entry":"\u2003\u2003\u2003\/\/ Write size"},{"entry":"\u2003\u2003\u2003write_int(operand.size( ));"},{"entry":"\u2003\u2003\u2003\/\/ Write elements"},{"entry":"\u2003\u2003\u2003TABLE::Dictionary::const_iterator iter = operand.begin( );"},{"entry":"\u2003\u2003\u2003for(; iter!=operand.end( ); ++iter){"},{"entry":"\u2003\u2003\u2003\u2003if(iter->second._mask) continue;"},{"entry":"\u2003\u2003\u2003\u2003std::string foo = iter->first;"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Write the key"},{"entry":"\u2003\u2003\u2003\u2003operator( )(iter->first);"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Write the value"},{"entry":"\u2003\u2003\u2003\u2003binary_serialize serializer(_os);"},{"entry":"\u2003\u2003\u2003\u2003boost::apply_visitor(serializer, iter->second._element);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"private:"},{"entry":"\u2003\u2003void write_int(size_t a){"},{"entry":"\u2003\u2003\u2003\/\/write 4 bytes in big-endian ordering."},{"entry":"\u2003\u2003\u2003char b1 = (a >> 24) & 0xff ;"},{"entry":"\u2003\u2003\u2003char b2 = (a >> 16) & 0xff ;"},{"entry":"\u2003\u2003\u2003char b3 = (a >> 8) & 0xff ;"},{"entry":"\u2003\u2003\u2003char b4 = (a \u2003\u2003) & 0xff ;"},{"entry":"\u2003\u2003\u2003\/\/write most significant byte"},{"entry":"\u2003\u2003\u2003\u2003_os.write( reinterpret_cast<char*>(&b1), 1);"},{"entry":"\u2003\u2003\u2003\u2003_os.write( reinterpret_cast<char*>(&b2), 1);"},{"entry":"\u2003\u2003\u2003\u2003_os.write( reinterpret_cast<char*>(&b3), 1);"},{"entry":"\u2003\u2003\u2003\/\/write least significant byte"},{"entry":"\u2003\u2003\u2003\u2003_os.write( reinterpret_cast<char*>(&b4), 1);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003std::ostream& _os;"},{"entry":"};\/\/binary_serialize"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Various aspects and advantages of the invention will become apparent upon review of the following detailed description and upon reference to the drawings in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
