---
title: Responsive user interface to manage a non-responsive application
abstract: A method and system are provided for managing application programs with non-responsive user interfaces, possibly due to a bottleneck in handling events/messages. The method and system make an apparently frozen application user interface responsive so as to permit alternative tasks be executed or close the hung application. This is enabled by implementing routines to (a) detect if an application is hung, (b) replace the user interface for the hung application with a ghost interface, implemented by a separate thread, that permits system functionality such as sizing, minimization and closing of the application, and (c) destroying the ghost interface if the hung application becomes responsive again along with restoring the application's user interface along with updated event queues. Furthermore, creation of the ghost user interface is accompanied by placing a high priority special event in the hung application's queue to detect renewed responsiveness without requiring explicit monitoring.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06850257&OS=06850257&RS=06850257
owner: Microsoft Corporation
number: 06850257
owner_city: Redmond
owner_country: US
publication_date: 20000406
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This invention relates generally to development of computer operating systems for executing software applications and more particularly to the development of user interface capabilities provided to application programs by an operating system.","There is an increasing appreciation for the need for aesthetics and ease of use in the design of user interfaces (\u201cUI\u201d) to encourage use of computer applications and reduce frustration. To term the new user interfaces design strategies in cutting edge software as being \u201cergonomic\u201d is not an overstatement. Such interfaces are a combination of functionality coded in the application and supported by the underlying platform, which may be an operating system (\u201cOS\u201d). Thus, the OS provides significant support for realizing an effective UI, and such support is an important factor in the competition between different OS available in the market.","Application programs are typically written for execution on a particular platform. Such a platform may be defined by a virtual machine offering a relatively invariant context regardless of the underlying hardware or an OS that is tied down to a particular hardware platform or even an application providing an execution context for another application, e.g., a plug-in module. The platform includes a plurality of services and appropriate management strategies to allow different applications access to system resources. These services provide many of the functions that applications are expected to use and thus free the application writer from worrying about the more mundane implementation details such as security, reading and writing data, managing memory resources, and I\/O functions. Not surprisingly, this is an effective strategy since the services provided by the OS are used repeatedly. Having a single coherent implementation reduces complexity and enhances design of stable computing systems capable of executing different applications.","OS for computers, and for personal computers in particular, have undergone many changes. These changes not only improve the range of services available to applications, typically through an Application Programming Interface (API), but also provide new architectures that reduce the likelihood of crashing the entire computer system due to errors including those ascribable to applications or users. An important advance in designing stable computing systems has been the development of multithreaded systems, which are described further below.","Traditional OSs for personal computers used a single threaded architecture in which programming code was executed in a serial fashion. Any step or sequence of steps could result in a fatal bottleneck. A user is often hard-pressed to distinguish delays from a system failure. An improvement was a computing environment where if a busy application, as opposed to a non-functional application, could indicate that it was busy to the user, or preferably relinquish control to the OS to allow other applications and tasks to execute before being granted control again. Such computing environments were at the mercy of a well-behaved and cooperative application.","In contrast, in a multithreaded architecture the OS exercises greater control over the execution of different tasks. The OS schedules slices of time on the processor for identified units termed threads. A thread is a path of execution within a process that is recognized and provided time on the processor by the OS. Each application usually has at least one thread and, thus, is assigned time in accordance with its relative priority. Additionally, often an application executes in its own address space, particularly if it is treated as a process by the OS. This results in isolation of different processes from each other and contributes to greater system stability and robustness even when executing faulty applications.","It should be understood that the term thread refers to code that is provided execution time slices by an external entity, e.g., the OS. This does not foreclose a developer of an application to define a path of execution within the application such that the application directly controls the time allocated to a particular path while the OS may be unaware of its existence. For clarity, such developer defined execution paths are referred to as \u201cfibers\u201d as opposed to threads. The benefit in using threads is that, even if an application is defective it cannot hold up rest of the computing system, since it never has exclusive control of the computing environment. However, this statement should not be interpreted to imply that rogue applications designed to subvert the OS are not possible in a multithreaded computing environment. Accordingly, for conceptual convenience, threads may be generalized to scheduled code paths.","At least one of the threads assigned to an application is termed its main thread and typically implements the UI for the application. Modern UIs are usually graphical interfaces formed by a plurality of elements termed window elements or just windows. These window elements, controlled by the threads in a system, are displayed to a user. The display space available on the desktop is referred to as \u201creal estate.\u201d The desktop is typically implemented with the help of routines such as paint( ) to continually update it to reflect the current state and order of the windows displayed on it. A desktop thread, which is a system thread, manages painting of the desktop windows and also handles miscellaneous system events. Some windows that are fully or partially occluded by other windows may not be displayed in their entirety. The window in the foreground commands the attention of the user and has focus. Usually, the focus shifts as other windows are selected to be in the foreground.","Since window elements are not only output symbols but also aid in the input of events, each thread managing a window element is required to have a message loop. This loop allows messages to be sent for handling by the window element on the desktop. Similarly, messaging allows processing of input events by the OS, the application program or even the user by presenting them in an orderly fashion.","In addition, user input to the computer system is received from the hardware devices via a thread termed the raw input thread (RIT). The OS sorts the input events such as keystrokes, mouse movements, mouse clicks and the like in the RIT queue and forwards them to the appropriate application input thread queues or OS routines for handling. Input events are usually posted to an application owning the window element in focus. Furthermore, not all events are handled with the same priority. Some events, e.g., key combinations such as Alt-Tab keys shift focus from one window to another and are handled out of turn. Since each application has its own input queue, the failure of an application to handle its own queue entries is not fatal. In other words, it does not \u201chang\u201d the entire system by making it unresponsive to further inputs.","The OS also provides implementation code for a variety of graphical objects and windows for use by application programs. This not only saves creators of applications the complex task of writing graphical code, but also promotes standardization of the UI. An example of such an interface is the familiar window interface in the \u201cWINDOWS\u00ae\u201d OSs manufactured by the \u201cMICROSOFT\u00ae\u201d Corporation of Redmond, Washington. The interface includes an enclosing rectangle, system buttons for closing, maximizing or restoring the window element, and an enclosed area that is available to the application\/user to display arbitrary graphical or text symbols. The enclosing rectangle edges and corners are also usable for resizing the rectangle with the use of a pointing device such as the familiar mouse. Other designs for UIs are also possible along with modifications to the familiar designs, e.g., by varying color schemes\/designs, transparency and other properties.","As described previously, the desktop displays window elements in accordance with an ordering termed Z-ordering. Z-ordering identifies the window in the foreground and the various other windows on a tree structure. This tree structure is suitably manipulated when a different window is moved to the foreground, possibly due to a change in focus due to a user clicking on another window and consequently transferring focus. Such transfer of focus can also results in another application or thread getting the input events from the RIT.","It is possible for an application to hang, and at the very least give the user the impression of being non-responsive, if an application fails to process its input queue. For instance, ordinarily the main thread of an application manages its windows. Thus, if the main thread of the application is occupied by a task then the entire application may appear to hang, i.e. be non-responsive. The area on the desktop, i.e., the real estate, occupied by window elements controlled by its main thread appears to be frozen. A user may find it difficult to close or manage such an application and may, indeed, lose significant control over the apparently frozen system. Even a mere delay may result in a drastic action being taken by many a user such as rebooting the system leading to possible loss of data and even damage to the file structure and the hardware.","In view of the foregoing, the present invention provides a method and system for executing software application programs that provide a UI for replacing an apparently frozen application's UI. The replacement UI is responsive enough to permit moving, sizing, minimization, or closing of the hung window. Furthermore, the frozen or hung application may be closed by a user without risking rebooting the entire system resulting in possible data loss or damage to the hardware. This is enabled by implementing, preferably as part of the OS, routines to (a) detect if an application is hung, (b) replace the UI for the hung application with a ghost UI that permits limited functionality such as moving, sizing, minimization and closing of the application, and (c) destroying the ghost UI if the hung application becomes responsive. The destruction of the ghost window is followed by restoring the application's UI along with updated queue entries.","Hung applications are preferably detected by the duration for which they fail to handle entries queued on their respective input threads. In response to the detection of a hung application a ghost user interface is created. The ghost UI is preferably provided by a separate thread dedicated to managing ghost interfaces for hung applications. Creation of a ghost UT is accompanied by placing a high priority special entry in the queue for the application. This results in detection of the responsiveness of the application by its handling of the high priority special entry ahead of other queue entries. This, in turn, triggers the restoration of the application's UI and destruction of the associated ghost UI if the application becomes responsive again. To the user the effect is of watching a user interface change in some respects while retaining functionality related to managing the window and closing the frozen application using the familiar commands. Furthermore, the facility for caching input for the application makes the transformation smooth with few discontinuities since there are few \u201clost\u201d commands while the ghost user interface is operative. The extent and nature of caching is implementation specific and affects the smoothness of the transition to a ghost user interface and back again to the application's interface.","As is apparent, the method is generally useful in employing at least one dedicated thread for providing replacement user interfaces for a plurality of threads or applications in response to an appropriate signal and restore the original user interface in response to another signal. Furthermore, the threads may be replaced by independently scheduled code segments that may be executing on different machines or processors without any loss of generality. Of course, the dedicated thread may perform other activities that do not detract from its primary task of providing a replacement interface.","Additional features and advantages of the invention will be made apparent from the following detailed description of illustrative embodiments, which proceeds with reference to the accompanying figures.","In the description that follows, the invention will be described with reference to acts and symbolic representations of operations that are performed by one or more computer, unless indicated otherwise. As such, it will be understood that such acts and operations, which are at times referred to as being computer-executed, include the manipulation by the processing unit of the computer of electrical signals representing data in a structured form. This manipulation transforms the data or maintains it at locations in the memory system of the computer, which reconfigures or otherwise alters the operation of the computer in a manner understood by those possessing ordinary skill in the art. The data structures where data is maintained are physical locations of the memory that have particular properties defined by the format of the data. However, while the invention is being described in the foregoing context, it is not meant to be limiting as those of skill in the art will appreciate that various of the acts and operation described hereinafter may also be implemented in hardware.","Turning to the drawings, wherein like reference numerals refer to like elements, the invention is illustrated as being implemented in a suitable computing environment. Although not required, the invention will be described in the general context of computer-executable instructions, such as program modules, being executed by a personal computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations, including hand-held devices, multi-processor systems, microprocessor based or programmable consumer electronics, network PCs, minicomputers, mainframe computers, and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a conventional personal computer , including a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. The system memory includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within the personal computer  such as during start-up, is stored in ROM . The personal computer  may further include a hard disk drive  for reading from and writing to a hard disk , a magnetic disk drive  for reading from or writing to a removable magnetic disk , and an optical disk drive  for reading from or writing to a removable optical disk  such as a CD ROM or other optical media.","The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical disk drive interface , respectively. The drives and their associated computer-readable media provide nonvolatile storage of computer readable instructions, data structures, program modules and other data for the personal computer . Although the exemplary environment described herein employs a hard disk , a removable magnetic disk , and a removable optical disk , it will be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, random access memories, read only memories, and the like may also be used in the exemplary operating environment.","A number of program modules may be stored on the hard disk , magnetic disk , optical disk , ROM  or RAM , including an OS , one or more applications programs , other program modules , and program data . A user may enter commands and information into the personal computer  through input devices such as a keyboard  and a pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus. Increasingly, such devices are being connected by the next generation of interfaces, such as a universal serial bus (USB)  with a root hub\/Host , and to which other hubs and devices may be connected. Other interfaces that may be used include parallel ports, game ports, and the IEEE  specification available at","http:\/\/www.standards.ieee.org\/catalog\/bus.html#1394-1995. A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor, personal computers typically include other peripheral output devices.","The USB connections illustrate its utility. A keyboard , a pointing device  and another hub, hub-, are connected to the root hub\/Host . Hub- is further connected to another hub, hub-, , scanner , monitor , camera-, and modem . It should be understood that additional cameras and devices may be directly connected to the computer instead of a USB. Thus, the system depicted is capable of communicating with a network and sending\/receiving audio, video and data","The personal computer  may operate in a networked environment using logical connections to one or more remote computers. The types of connections between networked devices include dial up modems, e.g. modem  may be directly used to connect to another modem, ISDN, xDSL, cable modems, wireless and include connections spanning users connected to the Internet. The remote computer may be another personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the personal computer  in FIG. . The logical connections depicted in",{"@attributes":{"id":"P-00038","num":"00038"},"figref":"FIG. 1","b":["55","56"]},"When used in a LAN networking environment, the personal computer  is connected to the local network  through a network interface or adapter . When used in a WAN networking environment, the personal computer  typically includes a modem  or other means for establishing communications over the WAN . The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the personal computer  or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used. In particular, distributed computing based on dynamic networks that can reconfigure themselves with a device providing functionality, such as a video display, to another device is intended to be included.","In the description that follows, the invention will be described with reference to acts and symbolic representations of operations that are performed by one or more computers, unless indicated otherwise. As such, it will be understood that such acts and operations, which are at times referred to as being computer-executed, include the manipulation by the processing unit of the computer of electrical signals representing data in a structured form. This manipulation transforms the data or maintains it at locations in the memory system of the computer, which reconfigures or otherwise alters the operation of the computer in a manner well understood by those skilled in the art. The data structures where data is maintained are physical locations of the memory that have particular properties defined by the format of the data. However, while the invention is being described in the foregoing context, it is not meant to be limiting as those of skill in the art will appreciate that various of the acts and operation described hereinafter may also be implemented in hardware.","Table 1 presents a sampling of graphical elements or windows used as UI elements in addition to the familiar window interface. This list is not intended to be exhaustive, and instead, is only illustrative of the some of the behaviors made possible by different graphical UI elements. Different OSs and applications include additional icons, bitmaps and graphical shapes that also function as UL elements. Often the UI elements facilitate in the generation of events that are subsequently handled by the application or the OS or even plug-in routines. It is to be noted that additional graphical controls, including those with audio and video properties are being developed and being continually released. Thus, \u201cgraphical controls\u201d and other similar terms should be understood to include audio\/video capable elements.",{"@attributes":{"id":"P-d0e1391","num":"00002"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Description","Options","Notifications"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Status bar: displays","Simple-mode - one","May generate events"]},{"entry":["information defined by","section; and Multi-","corresponding to"]},{"entry":["an application.","mode - displaying","mouseovers or mouse"]},{"entry":[{},"more than one type","clicks over a"]},{"entry":[{},"of information in their","particular section."]},{"entry":[{},"respective sections."]},{"entry":["Button: a bitmap dis-","Can associate text or","May generate events"]},{"entry":["playing selected text.","selected bitmaps to","corresponding to"]},{"entry":[{},"modify its appearance.","mouseovers or mouse"]},{"entry":[{},{},"clicks over a"]},{"entry":[{},{},"particular section."]},{"entry":["Message box: displays a","Can associate selected","May generate events"]},{"entry":["text message.","text.","corresponding to"]},{"entry":[{},{},"mouseovers or mouse"]},{"entry":[{},{},"clicks over a"]},{"entry":[{},{},"particular section."]},{"entry":["Tool bar: displays a","Can associate selected","May generate events"]},{"entry":["collection of buttons in a","text or pictures.","corresponding to"]},{"entry":["bar.",{},"mouseovers or mouse"]},{"entry":[{},{},"clicks over a"]},{"entry":[{},{},"particular section."]},{"entry":["Tool tip: displays text","Can associate selected","May generate events"]},{"entry":["explaining the tool","text.","corresponding to"]},{"entry":["function.",{},"mouseovers over a"]},{"entry":[{},{},"particular button or"]},{"entry":[{},{},"another graphic."]},{"entry":["Trackbar: displays a","Can associate text and","May generate events"]},{"entry":["scrolling control with a","numbers with the","corresponding to"]},{"entry":["slider and a set of","scale.","mouse-dragging"]},{"entry":["notches.",{},"events."]},{"entry":["Spin box: displays","Can specify location","May generate events"]},{"entry":["arrows in an","and size.","corresponding to"]},{"entry":["updown control.",{},"mouse-clicks over a"]},{"entry":[{},{},"particular section."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"P-00042","num":"00042"},"figref":"FIG. 2","b":["60","60","62","64","66","68","70","62","60","72","60","74","60"]},{"@attributes":{"id":"P-00043","num":"00043"},"figref":"FIG. 3","b":["80","80","82","84","86","88","90","80","92","94","96"]},"In order to understand the relationship between the displayed window elements, and the organization of the computing environment, it is useful to understand the thread-based computing environment discussed previously. In graphical user interfaces (GULs) there are many different tasks that generate information to be displayed to the user. Similarly there is a constant stream of inputs from a variety of sources such as the keyboard, the pointing devices and the like. All of these need to be organized in order to allow programs to receive input and send output in a consistent manner without losing or misinterpreting data.",{"@attributes":{"id":"P-00045","num":"00045"},"figref":"FIG. 4"},"In one of the embodiments schematically described in , if the user shifts the focus to another window, the system adjusts the Z-order tree accordingly and generates a signal to the relevant applications to request a repaint( ) operation so that the changes to the desktop can be implemented. Such requests can advantageously placed in the virtual queue for a given application. This arrangement results in the applications tracking the details of the graphical output.","Step  in  shows a change in the Z-ordering made by one of the system threads in concert with the window manager, which tracks the different windows. The window manager identifies the windows affected by the change (step ) along with the threads or applications that own the windows. In order to update the desktop, a request to repaint( ) is made to the owners of the various window elements (step ). This request is preferably tagged with the time at which the request is made. The repaint request is handled by providing the necessary graphical information by calling relevant APIs (step ). The application or thread then calls repaint( ) and thus supplies the result to the system by calling graphics APIs (step ) while noting the time at which the request to repaint was handled (step ). These time stamps allow an estimate to be made of the promptness with which the application handles the requests queued in its message or event queue for handling. Finally, particularly in systems using \u201c\u03b1\u201d in addition to the customary colors, an appropriate system thread composites the final image (step ). It should be noted that the last step need not be found in many implementations, and instead the application may supply the repainted input with no need to composite it with other images.","In some implementations, layered windows are implemented so that the repainting operation may include compositing. In a nutshell, the layered window feature is implemented by maintaining an image of the an area of the screen occupied by the layered window that contains all the bits not belonging to the layered window. When either a layered window repaints or there are drawing operations in the specified area of the screen, the recompositing operation occurs in the context of the of the thread causing the changes. In any event, the precise details for implementing compositing to allow use of one or more transparency parameters, such as a, in course of repainting are implementation details particular to some of the many embodiments enabled by the invention described here. Such details are intended to be within the scope of the claimed invention.","The input to the computing system is handled by the RIT, as is illustrated in FIG. . RIT receives (step ) and determines which application, if any, is the intended target for the input (step ). It accordingly forwards the input to the relevant applications (step ) by placing it in their respective virtual input queue. A helpful rule is to send the input to the application in focus for receiving input. This arrangement dissociates the processing of the input from the actual receipt of the input by implementing a virtual input queue at the application and removes the potential for system-wide bottlenecks due to a single task's failure to handle the input. Preferably, in an embodiment, each entry in this queue is marked with a time stamp indicating the time when it was placed in the virtual input queue for a particular application by RIT. The queue also has a time stamp to indicate when a queued entry was last handled by the application (step ).","Suppose that an application has stopped processing messages in its input queue while waiting for a network call or some computationally expensive operation to complete. This scenario may make the system appear to be hung since all of the input is sent to the application's virtual input queue and elicits no response from the busy application while the foreground window makes a shift in the focus difficult by obscuring other windows behind it.","Furthermore, even if another window is selected to be in the foreground, it is difficult to regenerate the desktop if an application window occupying a significant of the desktop real estate is non-responsive to requests to repaint( ). This may result in an imperfectly painted desktop that looks strange and appears to be, at least partially, non-responsive.","In light of these considerations,  illustrates a high level illustration of a possible embodiment in accordance with the invention for making the system appear more responsive, and in particular making the user interface responsive enough to generate a desktop that is not frozen. This task is advantageously accomplished using a three-step procedure. The first step is detection of a hung application (step ). There are many methods that are suitable for determining if an application is hung. While the user notices a non-responsive system, the inability of an application to handle input queued in its virtual input queue is often the real reason behind the non-responsive user interface. A system thread, e.g., a desktop thread or RIT, can detect a hung application by noting if the queued entries are being handled within a set threshold period of time. Alternatively, different types of entries can have their own thresholds or the number of entries in the queue and other factors like the application or thread priority could also be considered in deciding if an application was actually hung. Different methods of determining whether an application is hung, including the user having the option of inputting a suitable signal, are intended to be included in step .","If an application is hung then the system thread determines if a ghost thread exists (step ). The desktop thread, for instance, may make such a determination if a request to repaint is queued for too long. Similarly, the RIT or even another thread may be charged to make such a determination. If there is no ghost thread, then a ghost thread is created (step ). It should be noted that although in this embodiment a ghost thread is used to control the creation and destruction of all ghost windows, this is not intended to be a limitation. The task of managing ghost windows could be handled by another thread or more than one thread in different embodiments in accordance with the invention. If a ghost thread exists then it is asked to create a ghost window (step ) using the location and properties of the frozen window belonging to the hung application. These properties are advantageously obtained from the system threads managing the display.","The ghost window preferably covers the frozen window belonging to the hung application while the hung window itself is hidden from the end-user's view. Now, the desktop thread does not need to use the input from the hung application to update the display and instead uses the ghost window by directing a repaint request to the ghost thread instead. The ghost thread calls the APIs to create the ghost window and then calls repaint( ) (step ). This permits a complete update of the display (step ) and handling of the input that otherwise would have to be handled by the now hung application. Similarly, mouse movements and mouse-clicks corresponding to the area occupied by the frozen window are handled by the ghost thread. In part, the system buttons come back to life at least as far as the user is concerned. The ghost window, corresponding to the previously frozen window, can be minimized, maximized, resized, moved and even closed. Each of these actions has different consequences to complete the simulation of the application window element. The close system button preferably terminates, i.e., results in the hung application exiting although other actions are possible. Additional or fewer functions may be implemented in the ghost UI. In effect, the ghost UI is a place saver for the application's UI.","In an embodiment in accordance with the invention, the events and messages for the ghost window are preferably divided into two sets depending on whether they should be handled by the ghost thread in lieu of the application or cached for later handling by the application. This is advantageously implemented by treating input with the ghost window in focus as being intended for the application except for some input events that may be handled by the ghost thread. The remaining input events are cached for subsequent forwarding to the hung application. Furthermore, inputs such as moving the ghost window are also forwarded to the application to restore the application window in the position occupied by the ghost window if and when the application ceases to be non-responsive.","A system thread detects if the hung application starts handling its queued entries (step ). Advantageously the renewed responsiveness of an application may be detected without requiring extensive monitoring by placing a high priority special entry in the queue for the application. Thus, when the hung application completes its task and is able to handle queue entries, it first responds to the high priority entries. The high priority special entry merely requires it to send a message, directly or indirectly, to a thread, e.g., the ghost thread in order to initiate replacement of the place saver ghost window by the real application window. The ghost thread detects that the application is no longer non-responsive, i.e., hung, (step ) and destroys the ghost window, initiates restoration of the application window by placing appropriate requests to repaint and forwarding cached input to the application queue (step ).",{"@attributes":{"id":"P-00057","num":"00057"},"figref":"FIG. 7","b":["150","152","154","156","158"]},"If the application is hung then it is determined whether a ghost thread exists (step ). If there is no ghost thread then one is created by a system management thread (step ). Else, the ghost thread is requested to generate another instance of a window to replace the window corresponding to the hung application (step ) followed by placing a high priority special entry in the application's queue (step ). In this scheme the system thread could be the desktop thread, RIT or another thread. Furthermore, the system managing thread could be the desktop thread as well in some embodiments.",{"@attributes":{"id":"P-00059","num":"00059"},"figref":"FIG. 8","b":["170","172","176","178","180"]},"Since there is no reason to keep the ghost thread if there are no ghost windows, at least in many embodiments, a check is made to determine if there are any more ghost windows remaining (step ). If there are no more ghost windows then the ghost thread exits, else it continues to manage its other ghost windows.",{"@attributes":{"id":"P-00061","num":"00061"},"figref":"FIG. 9","b":["190","192","194","196","198","200","202"]},{"@attributes":{"id":"P-00062","num":"00062"},"figref":["FIG. 10","FIG. 10"],"b":["210","212","214","216","212","218","218","220","212","220","220","222","224","214","216","214","222","220","226","218","222","228","224","228"]},"It should be noted that the procedure described is quite general and can be advantageously implemented in contexts that do not require an application to become non-responsive. Thus, a first window element, controlled by a scheduled code segment, e.g., a thread, providing replacement window elements, may be invoked to replace a second window element in response to a flip-window signal. Another flop-window signal can result in replacing the first window with the second window. Events associated with the windows can be handled analogously to that described herein for hung applications. In the case of embodiments replacing hung windows, the flip-windows signal corresponds to detection of a hung application or thread and the flop-window signal, then, corresponds to detection of the hung application or the hung-thread becoming responsive again. Furthermore, in a networked computing environment it may be possible to use applications or code executing on different processors or even machines to provide the independently scheduled functionality of threads to provide ghost or replacement user interface elements for a variety of applications. Thus, a scheduled code segment is a more general concept than the more familiar thread.","While much of the description of embodiments in accordance with the invention are in the \u201cWINDOWS\u00ae\u201d OS environment, this description is not intended to exclude other OSs such as the \u201cMACINTOSH\u00ae\u201d \u201cSOLARIS\u00ae\u201d and other UNIX based platforms along with distributed computing.","All of the references cited herein, including patenOts, patent applications, and publications, are hereby incorporated in their entireties by reference.","In view of the many possible embodiments to which the principles of this invention may be applied, it should be recognized that the embodiment described herein with respect to the drawing figures is meant to be illustrative only and should not be taken as limiting the scope of invention. For example, those of skill in the art will recognize that the elements of the illustrated embodiment shown in software may be implemented in hardware and vice versa or that the illustrated embodiment can be modified in arrangement and detail without departing from the spirit of the invention. Therefore, the invention as described herein contemplates all such embodiments as may come within the scope of the following claims and equivalents thereof."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["While the appended claims set forth the features of the present invention with particularity, the invention, together with its objects and advantages, may best be understood from the following detailed description taken in conjunction with the accompanying drawings of which:",{"@attributes":{"id":"P-00020","num":"00020"},"figref":"FIG. 1"},{"@attributes":{"id":"P-00021","num":"00021"},"figref":"FIG. 2"},{"@attributes":{"id":"P-00022","num":"00022"},"figref":"FIG. 3"},{"@attributes":{"id":"P-00023","num":"00023"},"figref":"FIG. 4"},{"@attributes":{"id":"P-00024","num":"00024"},"figref":"FIG. 5"},{"@attributes":{"id":"P-00025","num":"00025"},"figref":"FIG. 6"},{"@attributes":{"id":"P-00026","num":"00026"},"figref":"FIG. 7"},{"@attributes":{"id":"P-00027","num":"00027"},"figref":"FIG. 8"},{"@attributes":{"id":"P-00028","num":"00028"},"figref":"FIG. 9"},{"@attributes":{"id":"P-00029","num":"00029"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
