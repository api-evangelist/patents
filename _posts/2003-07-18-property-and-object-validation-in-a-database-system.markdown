---
title: Property and object validation in a database system
abstract: Property and object validation is provided in a framework for authoring database systems. The framework treats a property as an object and provides a mechanism to allow constraints to be enforced on the values entered in the properties. Some objects of an application have properties that have dependencies on other properties for setting. The framework of the present invention also allows easy enforcement of such dependency constraints.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07426521&OS=07426521&RS=07426521
owner: Microsoft Corporation
number: 07426521
owner_city: Redmond
owner_country: US
publication_date: 20030718
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS OVERVIEW","Criteria Object Model","Property Validation","Appendix","Containment Hierarchy","Entity Key","Class Key"],"p":["The present application is based on and claims the benefit of U.S. provisional patent application Ser. No. 60\/397,288, filed Jul. 19, 2002, the content of which is hereby incorporated by reference in its entirety.","The present invention relates to database systems.","In conventional relational databases, all data are stored in named tables. The tables are described by their features. In other words, the rows of each table contain items of identical type, and the definitions of the columns of the table (i.e., the column names and the data types stored in the column) describe the attributes of each of the instances of the object. By identifying its name, its column names and the data types of the column contents, a table is completely described. Queries to a relational data base are formulated in a query language. One such language is SQL (Structure Query Language) which is widely used in commercial relational data base systems. The data types offered by SQL can be classified as character arrays (names), numbers, and data types related to date and time. Tables can be modified or combined by several operations of relational algebra such as the application of Boolean operators, projection (i.e. selection of columns) or the Cartesian product.","Relational databases offer several advantages. Data base queries are based on a comparison of the table contents. Thus, no pointers are required in relational databases, and all relations are treated uniformly. Further, the tables are independent (they are not related by pointers), so it is easier to maintain dynamic data sets. The tables are easily expandable by simply adding new columns. Also, it is relatively easy to create user-specific views from relational databases.","There are, however, a number of disadvantages associated with relational databases as well. For example, access to data by reference to properties is not optimal in the classical relational data model. This can make such databases cumbersome in many applications.","Another recent technology for database systems is referred to as object oriented data base systems. These systems offer more complex data types in order to overcome the restrictions of conventional relational databases. In the context of object oriented data base models, an \u201cobject\u201d includes both data and the functions (or methods) which can be applied to the object. Each object is a concrete instance of an object class defining the attributes and methods of all its instances. Each instance has its unique identifier by which it can be referred to in the database.","Object oriented databases operate under a number of principles. One such principle is referred to as inheritance. Inheritance means that new object classes can be derived from another class. The new classes inherit the attributes and methods of the other class (the super-class) and offer additional attributes and operations. An instance of the derived class is also an instance of the super-class. Therefore, the relation between a derived class and its super-class is referred to as the \u201cisA\u201d relation.","A second principle related to object oriented databases is referred to as \u201caggregation.\u201d Aggregation means that composite objects may be constructed as consisting of a set of elementary objects. A \u201ccontainer object\u201d can communicate with the objects contained therein by their methods of the contained objects. The relation between the container object and its components is called a \u201cpartOf\u201d relation because a component is a part of the container object.","Yet another principle related to object oriented databases is referred to as encapsulation. According to encapsulation, an application can only communicate with an object through messages. The operations provided by an object define the set of messages which can be understood by the object. No other operations can be applied to the object.","Another principle related to object oriented databases is referred to as polymorphism. Polymorphism means that derived classes may re-define methods of their super-classes.","Objects present a variety of advantages. For example, operations are an important part of objects. Because the implementations of the operations are hidden to an application, objects can be more easily used by application programs. Further, an object class can be provided as an abstract description for a wide variety of actual objects, and new classes can be derived from the base class. Thus, if an application knows the abstract description and using only the methods provided by, the application can still accommodate objects of the derived classes, because the objects in the derived classes inherit these methods. However, object oriented databases are not yet as widely used in commercial products as relational databases.","Yet another database technology attempts to combine the advantages of the wide acceptance of relational data bases and the benefits of the object oriented paradigm. This technology is referred to as object-relational database systems. These databases employ a data model that attempts to add object oriented characteristics to tables. All persistent (database) information is still in tables, but some of the tabular entries can have richer data structure. These data structures are referred to as abstract data types (ADTs). An ADT is a data type that is constructed by combining basic alphanumeric data types. The support for abstract data types presents certain advantages. For example, the methods associated with the new data type can be used to index, store, and retrieve records based on the content of the new data type.","Some conventional object-relational databases support an extended form of SQL, sometimes referred to as ObjectSQL. The extensions are provided to support the object model (e.g., queries involving object attributes). However, these object-relational databases are still relational because the data is stored in tables of rows and columns, and SQL, with some extensions, is the language for data definition, manipulation, and query. Both the target of a query and the result of a query are still tables. The extended SQL language is often still the primary interface to the database. Therefore, there is no direct support of host object languages and their objects. This forces programmers to continue to translate between objects and tables.","The aforementioned database systems provide means for storing complex information in financial and business applications to name a few. By way of example, a business application may include objects that relate to customers, which in turn are related to various locations that they may have operating plants, types of products that each of these plants may order, the cost of such products, shipping dates, etc. The data for such information can be stored as properties of objects. However, some or all of the values that can be entered in the properties must be within acceptable ranges to avoid run-time errors, or worse, errors that do not necessarily cause a runtime error, but would corrupt the reliability of the application to maintain such data. For instance, many business objects are complex and part of that complexity is related to property dependency. For example, for a line item on a sales order object, the line items inventory identifier property may need to be set before the line items unit price property. If a consumer or user of the application is allowed to set the unit price property before the inventory identifier property, and then the consumer or user sets the inventory identifier property, the unit price property may be incorrect if there is an association between the item identified by the inventory identifier property and its unit price. An author designing such application will add code or instructions to handle this situation. However, in view of the complexity of the application this code may have to be duplicated for every property that needs to be set, and adjusted as necessary given the property that is being set. A heavy burden is thus placed upon the application author to maintain accuracy and consistency in order that the application executes correctly.","A method and\/or system that can simplify the validation of properties would be highly beneficial.","Property and object validation is provided in a framework for authoring database systems. The framework treats a property as an object and provides a mechanism to allow constraints to be enforced on the values entered in the properties. Some objects of an application have properties that have dependencies on other properties for setting. The framework of the present invention also allows easy enforcement of such dependency constraints.","It should be noted that the inventive features of the invention can be applied to O-R databases or relational databases, because the invention bridges the capabilities of both types of databases as well as the capabilities of object oriented programming languages. The result is an O-R database system that provides significant advantages over prior database technology. It will be described herein in terms of applying to an O-R database, for the sake of illustration only, as it is equally beneficial for relational databases.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 1","FIG. 1"],"b":["10","10","12","14","16","18","10"]},"As shown in , the data can be organized in terms of entities  (which is used interchangeably herein with the term objects). Each entity illustratively includes a metadata portion  and a remaining attributes or properties portion . The metadata portion  describes the entity , while the remaining attributes  define further attributes of entity , such as the data stored therein. Each of the attributes in entity  is mapped to a corresponding entity table  and a specific column  in a given entity table .","Data access system  can receive various forms of requests such as a query  which specifies an entity, or portions of an entity or group of entities, to be retrieved. Query  can illustratively be expressed in terms of objects (\u201centities\u201d) and properties, rather than in terms of tables and columns. The particular manner in which queries are expressed is not relevant to the present invention.","In any case, data access system  receives the query  and accesses class-table mapping . In this way, data access system  can determine the location of the data for the entities identified by query . Data access system  includes a translator  that translates query  into a relational database query  which is suitable for input to relational data store mechanism . In one illustrative embodiment, relational data store mechanism  is a SQL SERVER database server such as that available from the Microsoft Corporation of Redmond, Wash., that accesses a relational database . Therefore, data access system  receives queries  in terms of objects and translates those queries into an appropriate relational database query  that is then provided to the data store mechanism (or server)  which actually accesses the data in relational database .","Relational data store mechanism  retrieves the requested data and returns it in the form of relational database results . The results are returned to data access system  which then formulates the relational database results  into a requested result set . In one illustrative embodiment, result set  is requested in query . Query  may request that the results be output in the form of one or more objects or simply as a data set. In any case, data access system  arranges the relational database results  into the proper format and outputs them as result set .","Data access system  hides the physical data store (mechanism  and database ) from the users and developers enabling them to work in terms of entities rather than requiring them to know both the schema of database  and the syntax of the particular data store mechanism . Before describing the invention in greater detail,  shows one embodiment of an environment in which the present invention can be used.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 2","b":["100","100","100","100"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier WAV or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, FR, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way o example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in , provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies.","A user may enter commands and information into the computer  through input devices such as a keyboard , a microphone , and a pointing device , such as a mouse, trackball or touch pad. Other input devices (not shown) may include a joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a hand-held device, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user-input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","It should be noted that the present invention can be carried out on a computer system such as that described with respect to . However, the present invention can be carried out on a server, a computer devoted to message handling, or on a distributed system in which different portions of the present invention are carried out on different parts of the distributed computing system.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 3","FIG. 3","FIG. 3"],"b":["12","200","200"]},"Object model  includes the following classes: Criteria , EntityCriteria , CriteriaWithOrderBy , CollectionCriteria , AdHocQueryCriteria , EntitySetUpdateCriteria , EntityAliasList , JoinList  WhereExpression , OrderByList , SelectList , EntityCollectionType  and PropertyAssignmentList .","In the diagram shown in , the hollow arrows define an \u201cIS A\u201d relationship. For example, EntityCriteria is a Criteria, and EntitySetUpdateCriteria is also a Criteria. The connectors having a diamond at one end and an open arrow at the other end illustrate that the class which is pointed to by the diamond holds a reference to the class that is pointed to by the open arrow. Thus, the Criteria class holds a reference to the EntityAliasList class. The numerals adjacent the open arrows indicate the number of references which are held. Therefore, each Criteria class  holds a reference to an EntityAliasList  and can hold a reference for up to one JoinList  and WhereExpression .","Criteria class  is the abstract base class for which each of the concrete criteria classes (EntityCriteria , CollectionCriteria , AdHocQueryCriteria , and EntitySetUpdateCriteria ) are derived either directly or indirectly. Criteria class  holds references to instances of EntityAliasList , JoinList  and WhereExpression  which are exposed through public properties with the same names.","Criteria class  also defines a large set of static methods that are used to create Criteria instances and the components that are stored in them. The constructors of all public Criteria classes are internal. This means that all users of Criteria  must use the static methods of the abstract Criteria class for instance creation. Criteria  cannot be instantiated since it is abstract.","EntityCriteria  is used to specify a single entity for retrieval. It is derived directly from the abstract Criteria , and thus inherits the EntityAliasList  referenced by Criteria  as well as the JoinList  and WhereExpression  properties referenced by Criteria . An instance of EntityCriteria  can be created by creating an EntityKey from which an EntityAliasList  and a WhereExpression  are internally generated, or by providing the instance of EntityAliasList  and WhereExpression  directly.","CriteriaWithOrderBy  is derived from the abstract Criteria class  and thus inherits the properties referred to by Criteria . CriteriaWithOrderBy  holds a reference to an instance of OrderByList  which is exposed by a public property. CriteriaWithOrderBy , as with Criteria , cannot be instantiated since it is abstract.","CollectionCriteria  is used for the retrieval of a collection of entities. It is derived from CriteriaWithOrderBy , inheriting the EntityAliasList , JoinList , WhereExpression  and OrderByList  properties of CriteriaWithOrderBy  and Criteria . CollectionCriteria  adds an EntityCollectionType  which is exposed as a public property as well.","AdHocQueryCriteria  is used for the retrieval of entity data. It allows the user to combine the data of multiple entities of different types into a single result row with only the properties of interest included. The results of an AdHocQueryCriteria  query are returned in the form of a tabular result (or data) set, such as, for example, a Microsoft ADO.NET DataSet. The AdHocQueryCriteria  is derived from the abstract CriteriaWithOrderBy  class inheriting the properties EntityAliasList , JoinList , WhereExpression , and OrderByList . AdHocQueryCriteria  adds a SelectList  which is exposed as a public property.","EntityAliasList  is used to contain a list of entity aliases (parent key, entity type pairings) that are used with instances of Criteria . The entity alias list associated with an instance of Criteria  enables data access system  to determine which server and database to work with, and which maps  to use for mapping entity properties to the database tables and columns. It also allows specifying the same entity with different names (\u201caliases\u201d) so that things such as self-joins can be performed. For EntityCriteria , the EntityType indicates the type of entity to instantiate. For CollectionCriteria , it indicates the type of entities to instantiate and put in a collection. Also, the entity type can be a base type. Therefore, the instances that are put into the collection may actually be descendents of an indicated entity type. For all types of Criteria  multiple entity aliases can be passed to the EntityAliases clause upon creation of Criteria . This allows all types of Criteria  to make explicit joins to arbitrary entities.","JoinList  is used to contain a list of explicit joins for an instance of Criteria . Each join includes a join type (such as inner, left, or right), a left alias name, a right alias name, and a Boolean expression that defines the relationship between the entities involved in the join.","Where Expression  is used to specify the entity of interest. For CollectionCriteria , it is used to specify a set of entities. For AdHocQueryCriteria  it specifies the data rows to retrieve.","OrderByList  is used to define the sort order of the collection retrieved for a CollectionCriteria , or the sort order of the returned tabular result (or data) set rows for an AdHocQueryCriteria . The list contained in OrderByList  includes a list of properties or select list aliases. Each of these can be followed by an optional sort type indicator, such as ascending or descending.","SelectList  is used in the AdHocQueryCriteria  to define the columns that will appear in the resulting data set. A SelectList  can contain properties or expressions and each of these can be followed by an optional alias. An alias acts as an alternate name for the property or expression that follows. The aliases can also be used in the OrderByList .","EntityCollectionType  is used to define the container type of a collection of an instance of CollectionCriteria . In other words, it defines the system type of the collection in which the retrieved entities are to be placed.","EntitySetUpdateCriteria  is used to update a set of entities. It allows the user to modify one or more properties of similarly constructed entities. The operation is similar to modification of data in one or more columns with respect to a set of rows, and in effect, EntitySetUpdateCriteria  accomplishes that purpose in the database. However, instead of referencing in the modification request based on columns of the database, referencing is provided by entity properties.","EntitySetUpdateCriteria  is derived from the abstract Criteria  inheriting the properties EntityAliasList , JoinList  and WhereExpression . EntitySetUpdateCriteria  adds a PropertyAssignmentList , which is exposed as a public property.","One aspect of the present invention pertains to updating or changing values and properties of objects, and in particular, providing a framework for the application author that allows the application author to provide value constraints and\/or property update ordering (dependency) constraints for objects that can be implemented easily. This aspect obviates or at least substantially reduces the need for the application author to manually code such property constraints of objects in the application. This reduces code duplication, the time to code the application as well as inconsistencies that can inhibit performance and delay implementation of the application. The framework maintains the constraints and at run time enforces the constraints when property data is entered by a consumer, i.e., one entering in data.","At this point, it should be noted that data for a property can be entered by a user or a consumer through a suitable user interface or from entering of data from other means, such as, but not limited to, importing data through files or messages where the property values are contained within the files or messages. Thus, it should be understood that aspects of the present invention may not be limited to only receiving data directly from a user or consumer of the application, but rather aspects of the present invention can be used anywhere in the application as desired by the application author as well as across the system implementing the application, for example, where portions of the application for entering in data are executed across a distributed network.","Briefly, as one aspect of the present invention, a method or system (framework) treats a property of an object or entity as an object (herein referred to as PropertyObject) in order to provide validation and enforce constraints.  illustrates elements of the PropertyObject. The constraints are implemented by a PropertyValidator, which is illustrated in . A PropertyObject has a reference to a PropertyValidator, which is a class used to determine if a given property is valid. In the illustration of , specific types of property validators are denoted as StringValidator, ShortValidator, IntValidator, LongValidator, Data Validator and EntityKeyValidator. The specific validators other than the EntityKeyValidator apply constraints such as maximum and minimum values, and whether such constraints can be overridden that are specified as metadata at design time by the application author when validation is desired upon a property. The EntityKeyValidator however pertains to maintaining parent and child relationships of objects. The Appendix below describes a Containment Hierarchy that the EntityKey supports as well as the EntityKey itself. To facilitate the validation of new or evolving property types, it is easy to author a new property validator that the PropertyObject uses.","As illustrated in , constraints can include, but are not limited, to a minimum and\/or maximum value of an integer, the minimum or maximum length of a string and whether or not a time entry or value is considered valid just to name a few. In a further embodiment, the metadata can include constraints related to the proper order in which properties of an object or entity need to be set (as specified in PropertyValidator). Such objects having dependency are also referred to as \u201cmodal objects\u201d. An aspect of the present invention is able to determine if a property of an object has met its dependencies for setting. If a property has not met its dependencies for setting, the property is said to be \u201cread-only\u201d, which inhibits the user or consumer or other mechanism from setting the property.","An example of a modal object may be helpful. Consider a sales order object having an InventoryItemID property, as well as UnitPrice property. In this example, it is desirable to ensure that the InventoryItemID property is set before the corresponding UnitPrice property is set. In this example, it is assumed that a corresponding value for the UnitPrice property exists for each InventoryItemID. If a consumer were allowed to set the UnitPrice property before the InventoryItemID property, then when the InventoryItemID is finally set, a non-intuitive decision will need to be made or resolved. In particular, is it proper to leave the UnitPrice property unchanged, or is it proper to overwrite the UnitPrice property as if the user consumer had not set the UnitPrice property already, or is it proper to ask the consumer what to do.","Having a decision like this is best avoided by forcing a consumer to set the InventoryItemID property before the UnitPrice property.  generally illustrates steps in a method  involved for obtaining metadata and performing validation. Step  is optional and indicates that an existing property value, if any, can be obtained from the object under consideration as currently stored in the system. Commonly, such functions are referred to as \u201cproperty getters\u201d, the syntax which may vary from programming language to programming language. At step , the property is instantiated as an object (herein referred to as PropertyObject).","Corresponding metadata specifying the constraints for validation is obtained at step , while the new value for the property is obtained as step . If at step  the new value for the property corresponds to the existing value, the method of property validation can exit at this point since there is no need to perform validation on a value that the property already has. As appreciated by those skilled in the art, the order of steps , ,  and  should not be considered limiting in that the order may be changed without effecting the functionality of performing validation. At step , the constraints are applied to the new value for the property where upon if the constraints are met, the property value is set to the new value, whereas if the constraints are not met, an exception or error is issued.","In yet a further embodiment, an event can be issued to indicate the processing of validation of properties. For instance, an event can be issued indicating that a property may be changing based upon on its current value and the value under consideration. This event may be useful in order to provide an extensibility mechanism to cancel the event (i.e. canceling the validation procedure if the property value will not be changed), or to provide additional validation not performed by the PropertyValidator. Other events that can be issued include issuing an event indicating that the property has changed or its status has changed from or to read-only, or its status has changed from or to being valid.","As will be explained further below, but as mentioned above, some properties may be dependent upon the setting or status of another property. As indicated above, each property of an object is instantiated as a PropertyObject, which in turn, can listen for the notification or events issued during the setting process. In this manner, the application author can allow the application to change the status of properties from \u201cread-only\u201d to a status that can be set. For instance, for a user interface that allows the consumer or user to enter data associated with various properties of an object through text boxes or other suitable fields, some of the fields may not be active, thus inhibiting the user from entering data therein. However, as data is entered into fields associated with properties that can be entered, depending upon the desired application logic of the application author, other fields can be \u201cturned-on\u201d, thereby allowing the consumer to enter data therein. In other words, each of the instances of PropertyObject for the various properties can listen and respond according to the events issued by other instances of PropertyObjects.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 7","FIG. 7"],"b":["701","702","703","705"]},"The type of validator to be used is indicated at . As illustrated in , validators operate on a particular type of data type for a property. Thus, if an appropriate validator exists, it is specified at this location. However, it should be noted that in a further embodiment if no validator is specified, a default validator for the property type can be applied. In the example provided in , this would be StringValidator, wherein default values for attributes of the validator would then be used. In the example illustrated, StringValidator is explicitly specified along with specific attributes at .","Section  and  of the code comprise syntax for performing the setting function both before and after assignment of the new property value, which is indicated at . In section , events can be issued indicating that the property value is changing, while in section  an event can be issued indicating that the value has changed. Code  illustrates that property validation can cease if in the event the new value obtained corresponds to the existing value for the property.","It should also be noted that custom validators can be derived from the PropertyValidator illustrated in , if necessary. Generally, creation of a new validator includes creating a new class and deriving it from the PropertyValidator. An AttributeUsage attribute to the class definition can be added to indicate that the attribute may be used only on a property and is single-use. An abstract virtual OnIsValid base method is provided. Attribute properties needed to support the custom validator, such as a minimum length, a maximum length, a set of allowable characters, etc. are determined. New private fields are added to support the properties are also added. OnIsValid is implemented to perform validation on the input parameter and return a pass or fail result. If the custom validator is being added because of a new data type, a TypeValidatorAttribute is added to the date type specifying the new validator class. This causes the new validator to be used as the default validator for any property of the data type if there is not a validator specified on the property. (Similar to use of the StringValidator on any string property, even if the StringValidator is not specified on the property\u2014a default string validator could prevent setting a property to a value of \u2018null\u2019, which is a common validation scenario for a string property)","As indicated above, one form of constraint that can be applied to the setting of properties can control when a property is made available to the user consumer for setting, e.g. its status of read-only is changed. In other words, as described above, in some circumstances it may be desirable to have the property available for setting only after another property has been previously set. PropertyObject has an IsReadOnly property that reflects whether the property can be set, and whether it has met all its dependencies. The IsReadOnly property is governed by the corresponding validator's IsReadOnlyMode property which can either be set to a manual mode, where the IsReadOnly value can be changed manually at run-time or one of several automatic modes which include the following:","False (this is the default). IsReadOnly is always false.","True. IsReadOnly is true, unless the object is read only or there is no property setter.","IsNew. IsReadOnly is true if the object is new, false otherwise. (It should be noted that an object is new if it has not been persisted yet. In other words, stored through entity persistence  of .)","IsNotNew. IsReadOnly is true if the object is not new, false otherwise.","PropertyIsReadOnly. Depends upon another property's IsReadOnly status.","PropertyIsNotReadOnly. Depends upon another property's IsReadOnly status.","PropertyIsValid. Depends upon another property's or the current property's IsValid status.","PropertyIsNotValid. Depends upon another property's or this property's IsValid status. In the example illustrated in , the read only status is true when the corresponding object is new, i.e. it has not yet been persisted. The metadata providing read-only status is indicated at .","As stated above, the modes PropertyIsReadOnly, PropertyIsNotReadOnly, PropertyIsValid and PropertyIsNotValid can be determined based upon another property's IsReadOnly or IsValid status. A validation attribute IsReadOnlyPropertyLink provides a mechanism to name the associated property. In the illustrated in , the readonlyness for the property is determined by the readonlyness of another property, which is indicated at  in . It should be noted that if the parameter setting for the IsReadOnlyMode is either. PropertyIsReadOnly or PropertyIsNotReadOnly then the parameter IsReadOnlyPropertyLink must also be specified and cannot be the same property. Whereas if the parameter IsReadOnlyMode is either PropertyIsValid or PropertyIsNotValid, then if the parameter IsReadOnlyPropertyLink is specified, the readonlyness of the current property is determined by the property specified by IsReadOnlyPropertyLink. Otherwise, if the parameter IsReadOnlyPropertyLink is not specified, then the current property is assumed to be controlling. In other words, the current property is read only depending upon whether or not the associated property value is valid.","At this point, it should be noted that the order in which properties are set can be achieved in two different ways, depending upon if any PropertyValidator has a parameter IsReadOnlyMode of the \u201cmanual\u201d mode. If any such property does, then property ordering will have to be calculated through a dynamic approach. In the dynamic approach, all the properties are examined where those properties with IsReadOnly equal to \u201cfalse\u201d are then set. All the properties are then examined again, skipping the properties that have already been set, but in this instance the approach looks for and sets those properties that just had there IsReadOnly parameter changed from true to false. This process continues until no more properties have had there IsReadOnly value change from true to false. If desired, this information, or some of it, may be possible to cache, but for reliability reasons, this process needs to be repeated for every instance and for every type.","If however, no properties have the parameter IsReadOnlyMode of the \u201cmanual\u201d mode, then property ordering can be determined through a static approach. In the static approach, all the properties are examined and a graph is built based on dependencies to each other as specified. The resulting graph is sorted and traversed breadth-first, where the first property being set has IsReadOnly value equal to false. Likewise, any other such properties having IsReadOnly value of false are also set. At this point, the graph is traversed based on the dependencies provided therein. As appreciated by those skilled in the art, the graph can be cached if desired based on the object's type. The static approach may be particularly advantageous during importation of data where a graph can be established for the properties. Upon receipt of the data for the properties, the properties can be set based on the stored dependencies. In contrast, for data entered through a user interface, the dynamic approach probably will most likely be implemented.","The foregoing discussion provides property validation for entities or objects. In a further embodiment, property validation can be performed at two different levels in the database system. In a first level, property validation is performed upon or is performed with entering of data directly by consumer or through importing data as discussed above. This level of validation can be performed prior to permanent storage of the data in the database system through entity persistence  of . Thus, an application author can provide instructions executable on one or more input machines to provide property validation as data is inputted.","In the alternative or in addition, property validation can also be provided at a \u201cservice\u201d level where property validation code resides with or is associated with entity persistence . This level of property validation operates substantially similar to that described above and serves to recheck the property values prior to final entity persistence, or to validate properties that should or can only be validated at the service level. This level of property validation can be particularly advantageous in database systems where one or more consumers operating at the \u201cagent\u201d level are not considered trusted, or if the validation has to occur within a database transaction, such as what would need to happen if performing referential integrity validation. Validation at the service level is typically running under the context of a database transaction. Property validation at the \u201cservice\u201d level can be invoked upon receipt of an entity for persistence, which usually entails that the entity has obtained \u201cvalid\u201d status as it pertains to the agent.","In addition to performing property validation at a \u201cproperty\u201d level, each entity or object as a whole can be validated, which entails confirming the validation of each property contained therein. Referring to , at the \u201cagent\u201d level, the entity is checked for validation before sending the entity to the server for persistence or other operation that would not be able to complete successfully unless the entity is valid. In other words, entity validation comprises validating each of the properties forming the entity, and upon successful validation thereof, changing the status of the entity to be \u201cvalid\u201d. A method IsValid is provided for performing validation, while a cancelable event identifying that validation is occurring can be issued. As with property validation, entity validation can also be rechecked or further validated at the \u201cservice\u201d level before the entity or object is persisted. Again, a method IsValid is provided for performing validation, while a cancelable event identifying that validation is occurring can be issued. Thus, validation can be performed at a property, agent and\/or service level. For example, if validation is only desired at the service level, DelayIsValidUntilService of IPropertyValidator can be used. As appreciated by those skilled in the art, other mechanisms for selecting where to perform validation can also be used.","When validation is used on an object or entity, an exception or error can be raised upon the occurrence of the first error and subsequently with each other error encountered. In a further embodiment, all validation can occur for the entire object and the integers can be collected and returned as a set, if desired. Warnings or other information can be provided if desired as well.","Validation on an object or entity also issues validation events, similar to the validation events on the property. This extensibility mechanism allows further validation for the type.","In a further embodiment, PropertyBindingManager as illustrated in  provides a mechanism such that if a list of objects and\/or agents of the same type are being accessed for example, through a user interface, one does not have to subscribe to property events and agent events for each agent, but rather once for the whole list. PropertyBindingManager maintains the active agent and the event subscriptions for the property and agent events. For instance, in a list of agents, one agent may be active at any one time and having to clear out the old PropertyObject event subscriptions associated with the previous agent and interact with the new PropertyObject event subscriptions with respect to the new agent can hamper performance. Thus, reference to the agent (CurrentAgent) is obtained from the PropertyBindingManager's current agent. As stated above, PropertyBindingManager allows a one-time subscription to a list of agent and property events since the agents are of the same type and provides a mechanism to keep track of the active agent and associated event subscriptions.","The following description is provided for the purpose of explaining the use of an EntityKey in the exemplary embodiment described above. Discussion will first begin with an overall view of a concept herein referred to as Containment Hierarchy which the EntityKey supports. A brief discussion of other keys is also provided for the sake of completeness.",{"@attributes":{"id":"p-0099","num":"0098"},"figref":"FIG. 10","b":["1000","1002","1004","1006"]},"In the exemplary embodiment, the entities or objects are organized in a parent\/child relationship. Component  includes those entities that constitute an Order for a company. In particular, an Order entity  includes information such a subtotal, tax, freight and total properties. An Address entity  is a child entity of the Order entity  and may include information pertaining to the shipping address for a specific order. Likewise, the Order entity  may include a number of OrderLine entities , while each OrderLine entity  can comprise one or more OrderSerial entities  having further information. It should be noted that the notation \u201cn\u201d in  is used to indicate that the particular entity could comprise a number of identically structured entities. For example, as indicated above, one or more OrderSerial entities  can be a child entity (indicated by the diamond line) of an OrderLine entity .","In the example herein illustrated, component  generally pertains to Customer information and includes a Customer entity , where each Customer entity  can include one or more Address entities .","The Customer entities  and the Order entities  are each child entities of a Company entity , the set of which comprise child entities of an Enterprise entity . Component  comprising, in this example, one or more currency entities  is also a child of the Enterprise entity .","Besides the parent\/child hierarchy of structure , there also exists, in this example, a uni-directional association between classes of entities. A class is a set of similarly structured entities. As indicated above, all of the Order entities  fall within an Order class. Likewise, the Customer entities  pertain to a Customer class. The association indicated by arrow  denotes that a class may know of another class. In this example, the Order class knows about the Customer class, but does not incorporate or own it such as in the case of a parent\/child relationship.","An entity manages data. The entity preserves its internal data and the integrity of its relationships with other entities. Data of the entity is accessed through properties. Each entity is a form of an abstraction. Characteristics of an entity also include that it has an identity, represented by a subclass of an abstract class \u201cEntityKey\u201d. Within the overall hierarchy, each entity that manages data in structure  is location independent in that it does not know where it is stored or who owns it. However, the EntityKey is used to define its relationship with other entities and can be thought of as being represented by the connections in .","An instance of an entity may be contained within an instance of another entity. The contained entity is called the child, while the container is called the parent. A child instance cannot exist longer than its parent and must have one and only one parent. The set of all such relationships for an application is its containment hierarchy. This sort of hierarchy parallels many business applications. It has been found that supporting this hierarchy makes the system a better fit for developers in constructing business applications.",{"@attributes":{"id":"p-0106","num":"0105"},"figref":"FIG. 10","b":["1022","1020"]},"It should be noted that the containment hierarchy is not the same as an inheritance hierarchy. Inheritance hierarchy is a classification of relationships in which each item except the top one is a specialized form of the item above it. In the example of , the Order class  and the Customer class  are not specialized forms of the Company class . Rather, the Order class  and the Customer class  are different classes holding different types of information. This is not to say inheritance can not be present in the Containment Hierarchy. In some embodiments, an inheritance hierarchy may be present for any class. Thus, for example there can be variations within a class such as variations of the Customer class ","There are three forms of entities in an application. The forms include the component containers \u201cEnterprise\u201d  and \u201cCompany\u201d , primary entities and supporting entities. The primary or root entity is the focus of a component container of the same name, while supporting entities are either children of the primary entity or its peers. For example, the Order component  consists of the Order root entity , while the Address , OrderLine  and OrderSerial  are supporting entities. The data for entities is usually stored in database tables such as described above with respect to . Components are a unit of logical design and do not interact with the database.","As indicated above, each of the properties in an entity  is mapped to a corresponding entity table  and a specific column  in a given entity table  as illustrated in . Each entity table also includes, in addition to columns for the attributes, one or more columns that identify all the parents of a particular entity. Referring to  and using OrderSerial by way of example, the OrderSerial Table  would include columns for identifiers, in particular, \u201cCompany_id\u201d , \u201cOrder_id\u201d , OrderLine_id  and Serial Number , which may comprise one of the attributes, and which may function as its own identifier (id).","In a relational database, interaction with the table would require specifying each of the identifiers in order to identify and work with the data associated with a particular entity, in this example, data associated with a specific OrderSerial entity . However, this information is inferred from its parent in the containment hierarchy. For instance, if one is working with a particular OrderLine entity  and now wants to inquire about, or perform an action upon, a OrderSerial entity , the data access system  can ascertain which OrderSerial entity or entities the user is referring to without needing to reidentify the parents of the entity. In the present invention, the containment hierarchy allows the relationship of the tables (i.e., the identifiers such as illustrated in ), and hence, the relationship of the entities, be an implicit background piece of information. In other words, the identity of the entity is inferred from parent\/child relationship so that it doesn't need to be restated or managed in other ways. In a relational database system, the identifiers found in the tables used to identify the entity are called a primary key, wherein the combination of the identifiers is unique. However, typically, primary keys are just a collection of columns and have no rich behavior attached to them. In addition, user selected identifiers may only be unique within a certain scope (such as a single business unit) and not unique over the entire range of the application. Surrogate keys, which are commonly generated by the application and hidden from the user, may be unique, but they do not describe hierarchies such as who is the parent of the entity referred to by the identifier.","Another aspect of the present invention is an EntityKey that solves these problems, in particular, the EntityKey associated with each entity allows each entity to be unique throughout the containment hierarchy, as well as infer from the position of the entity within the containment hierarchy who the parents are. An entity is an object that is identified by an entity key, or stated differently, the key for an entity. An EntityKey serves the same function as the primary key on a relational table; however, unlike a relational primary key it is universally unique across the application space and is hierarchical, i.e. it is aware of its position in the hierarchy. In the architecture, the EntityKey is a defined class that is distinct from the entities. The EntityKey class can be mapped to a relational database table in a manner similar to entity , class-table mapping  and entity table . Every entity throughout the hierarchy has one and only one EntityKey value. Given the key for an entity, one can retrieve the entity, whether it is on a local server, or located in a wide area network such as the Internet.","Each EntityKey contains, for purposes of this concept, three pieces of information: the type or class of the entity to which it refers, the ID of that entity to which it refers and information as to the EntityKey of the parent to that entity.  is a pictorial representation of an EntityKey (herein, OrderSerial.Key) A for a particular OrderSerial entity A.","An entity in the hierarchy is fully identified by its identifier plus that of its parents. In this manner, the same local identifier can be used in two or more locations of the overall space because different parents would be involved in uniquely identifying the entity. This may be more readily apparent by pictorially representing the Enterprise space of . Referring to , the Enterprise is indicated by circle . The Enterprise  can include a plurality of companies, herein Company A  and Company B . However, each Company  and  can have two Orders, both having the same identifier, herein \u201cOrder 1\u201d  and \u201cOrder 2\u201d . Nevertheless, entities within Company A  would still be uniquely identified with respect to entities of Company B  although the identifiers for Order 1  and Order 2  have been used within each Company because each of the entities is uniquely identified by its associated key having the parent\/child relationships of the hierarchy.","It should be noted that in many applications, the data for Company A is stored in a completely different database then the data for Company B.","There is also a separate, independent class associated with OrderSerial  herein identified as OrderSerial.Key. In general, the EntityKey is of a separate class than the class it refers to. Entity A is an example of an object of the OrderSerial.Key class. Referring back to , the OrderSerial entity A contains all the attributes  relevant to the Order Serial, which could be any number of attributes. The OrderSerial.Key A contains a subset of one or more attributes of the OrderSerial entity A specifically, the OrderSerial.Key includes identifier attributes . Thus, if OrderSerial entity A includes a thousand attributes, but two of the attributes make each OrderSerial entity unique, those attributes get copied into the OrderSerial.Key to form the identifier back to the entity. Arrow  represents the common identifier attribute or attributes between entity A and entity A.","The attribute or attributes of the OrderSerial.Key that make each entity of OrderSerial unique is the first element of an EntityKey, which thereby allows the key to be associated with a particular entity.","A second element of an EntityKey is the type  of the entity to which it has an identifier. In the present example, the type of the class is OrderSerial.","A third element of an EntityKey is information about the EntityKey of the parent of the entity. In the present embodiment, this information is a reference, indicated by arrow , to the parent key  corresponding to the parent of entity A. In other words, the third element could be a reference to another key. This structure makes EntityKeys recursively defined However, it should be understood that some or all of the parent key information could be stored in the EntityKey directly, if desired. It should be understood that these forms and other similar forms for storing and accessing EntityKey information is intended to be covered herein.","Referring now to , EntityKeys are provided for an entity of Company, an entity of Order, an entity of OrderLine and entity of OrderSerial. In this example, the ID constitutes one field and the type can be ascertained from the name of the key. For example, type OrderSerial is obtained from the name OrderSerial.Key. References to parent keys are illustrated by arrows. Thus, again, the location of an entity in the hierarchy is completely defined by the associated EntityKey.","In the recursive form of storing EntityKeys, it should be noted that although each EntityKey includes type or class information to which it pertains it does not know the type or class of its parent. That information is found by looking at the type information in the parent key that it references. This is a particularly advantageous feature for it allows classes to be reused throughout the containment hierarchy. Referring back to , it is illustrated that the Order class  has a child class of Address . Likewise, the Customer class  also has a child class of Address . The Address classes  and  are actually conceptually the same; but the instances are disjoint since they are under different parents. However, the entities are uniquely defined in each form of Address class, wherein each Address class  and  may be stored in a different database table. In this manner, one can describe a position in the containment hierarchy without forcing a class to forever be in that position.","As explained above, each EntityKey has information such as a reference to its parent key, but it does not know what type of parent it is. The decision of what type of parent is made or defined by the mapping(s)  illustrated in  for the complete set of classes and tables.","The set of identifiers  as illustrated in  of an EntityKey corresponds to the primary key columns of a table holding the data for that entity. Referring to , assume that the primary key of the table holding OrderSerial entities is Company_ID , Order_ID , OrderLine_ID , and Serial Number . The identifier attribute  in the OrderSerial.Key A is mapped directly to the last of the primary key columns, while the parent keys of A are mapped to columns , ,  in a similar fashion. This EntityKey to database key correspondence also extends to foreign keys. All simple associations between entities are implemented using keys. For example, in , Order.Key would have a reference of type Customer.Key that implements the association from Order to Customer. This key can easily be mapped to the Customer foreign key in the Order table.","It should also be noted that tables are commonly designed with surrogate rather than intelligent keys. An intelligent primary key is seen and specified by the end user, while a surrogate primary key is generated by the application and hidden from the user. Surrogate keys are often used to allow renaming the user visible identifier of a table without database impact or to save space when the size of the primary key is very large and often referenced in foreign keys. When surrogate keys are used, the table will have the surrogate primary key and an alternate key having the user visible identifier.","Both intelligent and surrogate EntityKeys are supported. In the present embodiment, if a surrogate EntityKey is used its ID properties are private (since they are generated and hold ho meaning to the consumer of the entity); otherwise they are public.","A second related abstraction is the Class Key. Since a given entity can be used in more than one place in the containment hierarchy, there is a mechanism for indicating which node in the hierarchy to process. The Class Key is that mechanism and contains two pieces of information: the type of the entity to which it refers and information as to the Class Key of the parent of the entity. Note the similarity to the definition of the EntityKey. In fact, the EntityKey is a derivative of and inherits from the Class Key, thereby allowing an EntityKey to be supplied anywhere a Class Key is required. Thus the Class Key is also hierarchically defined. The illustration of  of an EntityKey can be changed into an illustration of a Class Key by simply removing the entity identifiers (IDs).","Generally the Class Key can be used to reference a node in the containment hierarchy as it pertains to classes of entities, particularly describing uniquely a name for each class in the hierarchy as well as its position in the hierarchy. In contrast, the EntityKey provides a unique name for each entity in the containment hierarchy and describes its position in the hierarchy.","The EntityKeys and Class Keys are used when performing create, read, update and delete operations on business objects or entities. For example, when reading an entity, a parent key referring to a component container should be provided. This provides a scope for the read and also makes it easier for the developer to specify a complex location in the hierarchy.","Besides EntityKeys and Class Keys, another form of key is a blend between these keys. As discussed above, an EntityKey is a form of a Class Key, but includes further information to a particular entity (i.e., its identifier attributes). By simply using a chain of Class Keys followed by Entity Keys, all the entities under a particular parent can be ascertained.  illustrates an example of a blended key . In this example, EntityKeys have been provided for the Enterprise, Company and Order, which in turn has specified a particular Order entity. However, since the OrderLine.Key and the OrderSerial.Key do not include Ids, they are Class Keys. The blended key  of  could be received by the data access system  to formulate a query for data store mechanism  to retrieve all series for a particular order, irrespective of line.","Although the present invention has been described with reference to particular embodiments, workers skilled in the art will recognize that changes may be made in form and detail without departing from the spirit and scope of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIGS. 7","b":["8","9"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 15"}]},"DETDESC":[{},{}]}
