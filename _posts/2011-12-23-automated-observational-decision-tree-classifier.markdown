---
title: Automated observational decision tree classifier
abstract: Various embodiments of systems and methods for automatic classification of objects in a computer system are described herein. A class decision is received, where the class decision is a classification of an object from a number of objects to a class from a number of classes. The class decision is classification of the object by a role model. An exploration tree is expanded based on the class decision. A decision tree is constructed based on the exploration tree. Objects are classified based on said decision tree.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08788443&OS=08788443&RS=08788443
owner: SAP AG
number: 08788443
owner_city: Walldorf
owner_country: DE
publication_date: 20111223
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Embodiments of the invention generally relate to the software arts. More specifically, to machine learning.","Learning in humans is a complex process composed of various aspects. One aspect is memorization of data such as faces, facts, letters, sounds, formulae, etc. Another aspect is ability comprehend, to recognize and to generalize notions from various sources such as books, lectures, television, Internet, etc. Finally, humans learn from accumulated knowledge and, by reasoning, arrive at conclusions about new, e.g., unseen information. In general, humans also use intuition, experience, creativity and other subjective criteria to perform intelligent tasks. Machine learning aims at automating intelligent tasks in computer systems using reasoning, to infer new information from old. Common goal is to replicate humans' pattern recognition and classification skills in computer systems.","A typical task addressed in the field of machine learning is classification. This is the process of assigning an input object to one class from a set of classes, for example, to determine whether a given email is \u201cspam\u201d or \u201cnon-spam\u201d. Usually, classification of objects in computer systems is based on training data as input data. Training data contains samples or instances of objects assigned the correct classification. For example, a number of exemplary mails classified as \u201cspam\u201d. Information about the objects is also entered into the computer system. For example, objects may be formally represented by features, which constitute properties or characteristics of the objects. The set of features used to describe the objects is referred to as the feature space. Classified sample objects and their features are analyzed to learn decision criteria based on which the sample objects are put into certain classes. Example features that may be used to classify mails may be \u201csender\u201d, \u201ccontent\u201d such as terms occurring in the mail, etc.","The complexity of the feature space imposes limitations on the performance of automatic classification. For example, selecting from the feature space those features that are important and have discriminative potential cannot readily be done. Reducing the feature space while also choosing the important and informative set of features for the classification can be a challenging and computationally expensive task.","Various embodiments of systems and methods for automatic classification of objects in a computer system are described herein. In one aspect, a class decision is received, where the class decision is a classification of an object from a number of objects to a class from a number of classes. In a further aspect, the class decision is classification of the object by a role model. Furthermore, an exploration tree is expanded based on the class decision. The exploration tree represents a number of view sequences of the role model. In one aspect, the classified object is assessed in a view sequence from the number of view sequences by the role model. The exploration tree is expanded by merging the view sequence to the exploration tree. Nodes of the exploration tree represent a number of views and a view represents features of the objects. Leaves of the exploration tree represent the classes. A decision tree is constructed based on the exploration tree. In one aspect, the exploration tree is pruned to optimize the decision tree. Objects are classified based on said decision tree. In one aspect, to build the decision tree, a number of miniature decision trees for nodes of the exploration tree are constructed and connected in the decision tree.","These and other benefits and features of embodiments of the invention will be apparent upon consideration of the following detailed description of preferred embodiments thereof, presented in connection with the following drawings.","Embodiments of techniques for automated observational decision tree classifier are described herein. In the following description, numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize, however, that the invention can be practiced without one or more of the specific details, or with other methods, components, materials, etc. In other instances, well-known structures, materials, or operations are not shown or described in detail to avoid obscuring aspects of the invention.","Reference throughout this specification to \u201cone embodiment\u201d, \u201cthis embodiment\u201d and similar phrases, means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus, the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be combined in any suitable manner in one or more embodiments.","In one embodiment, an automated classifier of data objects based on a decision tree is implemented. The automated classifier reproduces a human user classification process performed in a computer system. The human user's interaction with the system to classify the objects is tracked, observed and analyzed to be replicated automatically in the computer system. The automated classifier enables automatic classification of new and unclassified objects. In one embodiment, the automated decision tree classifier is based on observing a human user performing classifications. In yet another embodiment, the automated decision tree classifier may be built based on observing a computer system classifying objects.","Data objects are stored in a computer system to be classified. A data object may be any entity physical or abstract that may be classified. For example, objects may represent physical items on a conveyor belt, people, animals or abstract entities such as corporations. A data object is assigned an object identifier (ID) to be identified in a computer system. In an embodiment, data objects are described by features. Features of an object may be represented as a feature vector. A feature may be any characteristic, property or attribute of a data object. For example, height or weight of a physical item, number of occurrences of a term in a text, physical features of humans such as hair color, skin color, eyes, scars, or physical attributes of animals such as number of legs or if the animal lays eggs, etc. Classification of objects is based on features of the objects. Classes may be any category suitable to describe the data objects. For example, animals may be classified as birds, mammals, amphibians, reptiles, etc. A class is assigned a class identifier (ID) to be identified in a computer system. In an embodiment, data objects are represented as data records in one or more tables. Data records of a table contain data about the data objects that is represented by fields. In an embodiment, features may be fields in the data records or derived from one or more such fields. For example, a feature may be computationally derived from fields such as the age of a person may be derived from the person's date of birth. In one embodiment, data about objects may be kept in a permanent data store.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 1","b":["100","110","120","120","120","120","110","110","140","110","150","160","140","110","150","160","150","160","140","155","165","2","155","150","160","155","110","110","130","120","140","110","120","110"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2","b":["200","220","210","210","220","210","295","270","280","290","210","210","270","1","3","4","240","210","280","1","4","5","290","1","5","6","270","290","255","265","250","260","270","290","210","295","270","290","210","220","270","280","290","220","240","210","295","220","210","230","220"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 3","FIG. 4"],"b":["300","310","150","160","320"]},"At , a check is performed whether a view record associated with the requested view is found. If a view record associated with the requested view is not found in the permanent data store, at , such record is created. For example, the requested view is assigned an identifier and the requested features of that view are associated with that view ID in a view record. At , a sequence record is created based on the requested view of the object. A sequence record is an association between an object and a requested view of that object and also includes the order in which the view is requested. The order in which the view is requested may be defined according to temporal succession. In one embodiment, a sequence record may be a data record that includes a field containing an object identifier of a target object, a field containing a view ID of a requested view of that object, and a field containing order of request of that view for that object. Table 1 below illustrates exemplary sequence records.",{"@attributes":{"id":"p-0034","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Sequence Records"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Object ID","Order","View ID"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["4711","1","7"]},{"entry":["4711","2","1"]},{"entry":["4711","3","23"]},{"entry":[". . .",". . .",". . ."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Table 1 illustrates sequence records of exemplary target object. Field \u201cObject ID\u201d contains the object ID of the target object and the field \u201cView ID\u201d contains the view ID of the requested view of the target object. Field \u201cOrder\u201d represents the order of sequence records associated with the same object ID according to the temporal succession. For example, target object with an object ID \u201c\u201d is assessed in views with view IDs \u201c\u201d, \u201c\u201d, and \u201c\u201d, where the views are requested and assessed in the respective order. The sequence order may be represented as convenient, for example, as a timestamp or as a sequential integer as illustrates in Table 1. Sequence records of a target object may be represented as a view sequence.","At , a check is performed if another request to assess the object in a view is received. If another request to assess a view of the object is received, the process repeats at . In one embodiment, if the requested view of the object matches with the view requested last according to the order, a sequence record at  is not created. For example, two successive identical queries result in one sequence record. If another request to assess a view of the object is not received, at , a check is performed to determine whether a class decision is received. A class decision represents assigning an object to a class. If a class decision is received, at  a training record based on the class decision is created. In one embodiment, a training record is created in the permanent data store. Table 2 below illustrates exemplary training records of target objects.",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Training Records"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Object ID","Class ID"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"4711","A"]},{"entry":[{},"4712","B"]},{"entry":[{},"4715","C"]},{"entry":[{},". . .",". . ."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"A training record is a data record that includes a field containing an object ID of an object and a field containing a class ID of the class to which the object is assigned. In table 2, field \u201cObject ID\u201d contains object IDs of target objects and field \u201cClass ID\u201d contains class IDs corresponding to classes assigned to the target objects. In an embodiment, if a class decision is not received, at , requested views are ignored. For example, a view sequence based on the requested views is not generated. In an embodiment, a class that indicates that a class decision is not made may be included. For example, a role model after assessing a target object in a view sequence, may decide not to make a class decision and, as result, putting the object in category \u201cunclassified\u201d. In an embodiment, the computer system may automatically categorize objects as \u201cunclassified\u201d if a role model interrupts the process of assessing the object without submitting a class decision.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 4","b":["410","410","420","430","410","415","440","440","450","460","440","445","410","440","415","1","1","2","3","445","1"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 5","b":["500","500","510","540","550","550","510","565","7","520","565","1","530","560","23","540","23","530"]},"In one embodiment, nodes of an exploration tree may represent the same view record. Such nodes have a different parent node and are part of separate sub-trees. Example of such nodes in exploration tree  is node  and node . Leaves - represent classes. A leaf in an exploration tree is represented by a class ID. For example, leaf  represents class with class ID \u201cA\u201d; leaf  represents class with class ID \u201cB\u201d; leaf  represents class with class ID \u201cA\u201d; leaf  represents class with class ID \u201cC\u201d; and leaf  represents class with class ID \u201cB\u201d. A leaf in an exploration tree represents a set of training records with matching class ID and is identified by the respective matching ID. For example, leaf  represents a training record from training records  with object ID \u201c\u201d; leaf  represents a training record from training records  with object ID \u201c\u201d; leaf  represents a training record from training records  with object ID \u201c\u201d; leaf  represents a training record from training records  with object ID \u201c\u201d; and leaf  represents training records from training records  with object ID \u201c\u201d and \u201c\u201d. Nodes - represent views and associated features of the views and leaves - represent classes of objects classified by a role model. Branches of exploration tree  represent view sequences of assessed object according to the order of assessing the objects in views represented by nodes -.","Exploration tree  may be implemented as a tree data structure. In one embodiment, the tree structure may be a directed acyclic connected graph. Nodes may have any number of child nodes. Exploration tree  may have one root node such as node  and nodes may be reached by a single path from the root node. In one embodiment, the computer system keeps an exploration tree in its permanent data store. A decision tree is constructed based on the exploration tree. The exploration tree is based on observing the role model performing classifications. Role model's class decisions and view sequences are represented by the exploration tree. In one embodiment, an exploration tree is built while a role model assesses objects' features and makes class decisions. Alternatively, the exploration tree's construction may be delayed to improve the computer system's performance","Equivalent nodes represent matching views and equivalent leaves represent matching classes. For example equivalent nodes of exploration tree  are node  and node ; leaf  and leaf  are also equivalent; and leaf  and leaf . Nodes may be equivalent, even though they are part of separate sub-trees. Similarly, sets of nodes are equivalent if their nodes are equivalent to each other. Branches are equivalent if the nodes they connect are equivalent. Sub-trees are equivalent if their nodes and branches are equivalent. In one embodiment, from mathematical perspective, branches, sub-tress, or other sets of nodes are equivalent if they are in a bijection. Identical nodes are equivalent nodes and with the same position in the tree, i.e., if they are the same nodes. In one embodiment, equivalent portions of an exploration tree may be removed, consolidated or ignored to simplify the complexity of the exploration tree.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 6","b":["600","610","620","630","640","650","660","670","680"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 7","b":["700","710","710","720","4717","730","730","4717","730","730","7","23","1","700","740","750","7","23","760","1","700","700","760","750","770","760","700","700","780","760","750","710","770","7","1","23","740","750","760","750","760","770","780"]},"Thus, the subsets of features of the object that the role model assesses and the order in which these subsets are assessed are represented in the exploration tree. Further, the object's classification based on the assessed features is also represented in the exploration tree. The feature space is reduced to features assessed by the role model. The features assessed by the role model are features with informative, importance and discriminative potential. Further, the order in which the role model assesses subsets of features is tracked and represented in the exploration tree. Role model's decision to choose or select next important features, based on currently inspected features of an object is replicated in the exploration tree. In one embodiment, training data such as feature records, sequence records, and training records may be retrieved from any data source. For example, training data such as classified data objects may be populated to the permanent data store. In an embodiment, the resulted expanded exploration tree  is stored in the permanent data store. The exploration tree  is a possible representation of feature records, sequence records and training records that are kept in the permanent data store. In an embodiment, based on these stored records the exploration tree  may be built by starting from an empty tree data structure.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 8","b":["800","810","820","830","840","850","860","820"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 9","b":["900","910","900","121","920","910","930","48","73","48","121","7","910","1","920","73","23","930","910","920","48","920","121","910","940","23","950","975","10","14","24","21","8","44","980","930"]},"In one embodiment, an exploration tree may be optimized based on traversal probability of nodes. The exploration tree may be pruned to optimize a decision tree constructed based on the pruned exploration tree. Pruning is a technique in machine learning that reduces the size of a decision tree by removing sections of the tree that provide little power to classify instances. For example, branches of the exploration tree with low traversal probability may be removed from the exploration tree or may be ignored in a decision tree based on the exploration tree.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 10","b":"1000"},"Process  starts at  with traversing a node from an exploration tree. The traversed node is the current node. Nodes of the exploration tree are traversed in descending order of their depth. A depth of a node may be defined as the number of nodes in the path from the root node to the node. For example, the exploration tree's root node has depth \u2018\u2019, its child nodes have depth \u2018\u2019, and so on. At  a check is performed, if the current node's parent node has one child node. If the current node's parent node has more than one child node, then a non-decision sub-tree is not identified and the process continues at  with traversing next node in the exploration tree according to the descending order of depth. If the current node's parent node has one child node, a non-decision is identified and, at , a view record that includes all features represented by the current node and its parent is created. The created view record is assigned a view ID. Subsets of features of views represented by the current node and its parent are combined. At , the current node is merged with its parent node in one new node. At , the new node is associated with the view ID of the created view record. The new node represents the created view record. At , child nodes of the current node are appended to the new node. Appended child nodes become child nodes of the new node. At , a check is performed to determine if all nodes are traversed. If all nodes are not traversed, the process continues at , with traversing the next node according to descending order of depth. If all nodes are traversed, the process ends. The exploration tree is pruned from non-decisions. By pruning non-decisions, the exploration tree's complexity may be reduced. Distinguishing between reasons of the role model's actions that that yield to non-decisions in the exploration tree, is unlikely. Therefore, subsets of features inspected in views that are part of non-decisions are retained in the feature space.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 11","FIG. 10"],"b":["1100","1150","1100","1100","1000","1120","1130","1100","1160","1120","1130","1160","1160","1110","1160","1160","1110","1140","1140","3","1","1","3","6","2","3","4","6","8","3","1","3","4","6","8","1140","3","1120","1130","1140","1140","1150","1100"]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 12","b":["1200","1205","1200","1205","1220","1260","2","3","4","6","8","1230","1240","1","1","3","6","1245","1265","1250","1270","1200","1205","1200","1205","1210"]},"As sub-tree  and sub-tree  are non-decisions that may be pruned according to process  described in relation to . As a result of pruning non-decision sub-tree , node  is merged with its parent node  in new node . Node  is assigned view ID \u2018\u2019. Subset of features F and F are combined in a set of features F that includes features \u2018{, , , , }\u2019 and are associated with the view represented by the new node  with view ID \u2018\u2019. Leaf  and leaf  are appended to the new node  and become child nodes of node . Sub-tree  is pruned non-decision sub-tree . As a result of pruning non-decision sub-tree , node  is merged with its parent node  in new node . Similarly, leaf  and leaf  are appended to the new node  and become child nodes of node . Sub-tree  is pruned non-decision sub-tree . Sub-tree  and sub-tree  are pruned as non-decisions. After pruning, resulting sub-tree  and sub-tree  are permutations. Permutations may be pruned by removing one of the duplicate or equivalent sub-trees. For example, sub-tree  that is permutation of sub-tree  may be removed to prune permutations. Various techniques may be applied to identify permutations in an exploration tree, including but not limited to, recursive and iterative tree traversal and string search algorithms. In various embodiments, combination of pruning non-decisions and permutations may be applied to optimize the exploration tree.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 13","b":["1300","1310","1320","1330","1340","1350","1360","1365","1370","1375","1385","1380","1390","1365","1395","1310"]},{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 14","FIG. 13","FIG. 15"],"b":["1400","1410","1420","1300","1430","1440","1460","1410"]},{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 15A","FIG. 14"],"b":["1520","1510","1500","1400","1520","1510","1530","1540","1550","1520","1530","1530","1540","1550","1540","1550","1545","1555"]},{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 15B","FIG. 14","FIG. 15A"],"b":["1570","1520","1595","1400","1570","1560","1400","1545","1520","1580","1570","1570","1520","1580","1590","1570","1595","1530","1540","1550","1580","1590","1555","1575","1585","1595"]},"Some embodiments of the invention may include the above-described methods being written as one or more software components. These components, and the functionality associated with each, may be used by client, server, distributed, or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as, functional, declarative, procedural, object-oriented, lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively, the components maybe implemented in server and client applications. Further, these components may be linked together via various distributed programming protocols. Some example embodiments of the invention may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example, a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level (e.g., a graphical user interface). These first and second computer systems can be configured in a server-client, peer-to-peer, or some other configuration. The clients can vary in complexity from mobile and handheld devices, to thin clients and on to thick clients or even other servers.","The above-illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term \u201ccomputer readable storage medium\u201d should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term \u201ccomputer readable storage medium\u201d should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store, encode, or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described, represented, or illustrated herein. Examples of computer readable storage media include, but are not limited to: magnetic media, such as hard disks, floppy disks, and magnetic tape; optical media such as CD-ROMs, DVDs and holographic devices; magneto-optical media; and hardware devices that are specially configured to store and execute, such as application-specific integrated circuits (\u201cASICs\u201d), programmable logic devices (\u201cPLDs\u201d) and ROM and RAM devices. Examples of computer readable instructions include machine code, such as produced by a compiler, and files containing higher-level code that are executed by a computer using an interpreter. For example, an embodiment of the invention may be implemented using Java, C++, or other object-oriented programming language and development tools. Another embodiment of the invention may be implemented in hard-wired circuitry in place of, or in combination with machine readable software instructions.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 16","b":["1600","1600","1605","1655","1600","1640","1655","1610","1615","1610","1615","1605","1615","1600","1625","1630","1600","1625","1630","1600","1635","1600","1650","1650","1600","1645","1600","1620","1660","1660","1660","1650","1660"]},"A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases, such as, relational, transactional, hierarchical, multi-dimensional (e.g., OLAP), object oriented databases, and the like. Further data sources include tabular data (e.g., spreadsheets, delimited text files), data tagged with a markup language (e.g., XML data), transactional data, unstructured data (e.g., text files, screen scrapings), hierarchical data (e.g., data in a file system, XML data), files, a plurality of reports, and any other data source accessible through an established protocol, such as, Open DataBase Connectivity (ODBC), produced by an underlying software system (e.g., ERP system), and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams, broadcast data, and the like. These data sources can include associated data foundations, semantic layers, management systems, security systems and so on.","In the above description, numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize, however that the invention can be practiced without one or more of the specific details or with other methods, components, techniques, etc. In other instances, well-known operations or structures are not shown or described in details to avoid obscuring aspects of the invention.","Although the processes illustrated and described herein include series of steps, it will be appreciated that the different embodiments of the present invention are not limited by the illustrated ordering of steps, as some steps may occur in different orders, some concurrently with other steps apart from that shown and described herein. In addition, not all illustrated steps may be required to implement a methodology in accordance with the present invention. Moreover, it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.","The above descriptions and illustrations of embodiments of the invention, including what is described in the Abstract, is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of, and examples for, the invention are described herein for illustrative purposes, various equivalent modifications are possible within the scope of the invention, as those skilled in the relevant art will recognize. These modifications can be made to the invention in light of the above detailed description. Rather, the scope of the invention is to be determined by the following claims, which are to be interpreted in accordance with established doctrines of claim construction."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The claims set forth the embodiments of the invention with particularity. The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. The embodiments of the invention, together with its advantages, may be best understood from the following detailed description taken in conjunction with the accompanying drawings.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 15A"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 15B"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
