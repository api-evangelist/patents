---
title: Collection command applicator
abstract: Collection command applicators improve the productivity of human knowledge workers by enabling them to automatically process of large numbers of collections of arbitrary computer files. In operation, collection command applicators dynamically recognize interesting collections, calculate an optimal execution dependency visit order, determine an optimal parallel execution order, and apply arbitrary computer commands to the recognized collections in accordance with the calculated execution orderings. Collection command applicators thereby make it possible to process large numbers of collections in automated, scalable ways that were not previously possible.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06917947&OS=06917947&RS=06917947
owner: 
number: 06917947
owner_city: 
owner_country: 
publication_date: 20010621
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCES TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","Objects and Advantages","LIST OF DRAWING REFERENCE NUMBERS","DETAILED DESCRIPTION","Conclusion","Ramifications","Scope"],"p":["The present invention uses inventions from the following patent applications, that are filed contemporaneously herewith, and which are incorporated herein by reference:","USPTO Ser. No. 09\/885078, Collection Information Manager; Kevin Jameson.","USPTO Ser. No. 09\/885080, Collection Recognizer; Kevin Jameson.","This invention relates to automated software systems for processing collections of computer files in arbitrary ways, thereby improving the productivity of software developers, web media developers, and other humans and computer systems that work with collections of computer files.","The general problem addressed by this invention is the low productivity of human knowledge workers who use labor-intensive manual processes to work with collections of computer files. One promising solution strategy for this software productivity problem is to build automated systems to replace manual human effort.","Unfortunately, replacing arbitrary manual processes performed on arbitrary computer files with automated systems is a difficult thing to do. Many challenging subproblems must be solved before competent automated systems can be constructed. As a consequence, the general software productivity problem has not been solved yet, despite large industry investments of time and money over several decades.","The present invention provides one piece of the overall functionality required to implement automated systems for processing collections of computer files. In particular, the current invention has a practical application in the technological arts because it provides both humans and automated systems with a convenient, precise, scalable, and fully automated means for applying computer commands to collections of computer files.","Problems to be Solved","The Collection Command Applicator problem is one important problem that must be solved to enable the construction of automated collection processing systems. It is the problem of how to efficiently apply computer commands to large numbers of selected collections, in accordance with processing interdependencies that may exist among the collections.","Interesting characteristics of the collection command applicator problem include at least these: an arbitrary number of arbitrary collections in arbitrary filesystem locations may be involved; collections can have arbitrary per-instance data, size, content, data type, and internal structure; only a few interesting collections might require selection from a large pool of collections; collection recognition criteria may be based on complex combinations of collection type, collection per-instance data, collection content or external filesystem attributes; arbitrary processing commands can be applied; selected collections must be processed in proper dependency order; and parallel command execution may be required for performance reasons.","Solving the collection command applicator problem is useful because a good solution would deliver a clear N-fold productivity increase for the collection command application problem domain. Specifically, a good solution would enable human workers to issue 1 computer command to process N collections. In contrast, at least N low-level commands, one per collection, are theoretically required, and in current practice more than 2N commands are often required. Typically, current practices also generate additional costs for various adhoc scripts that are manually constructed to manage current command application processes.","The Collection Visit Order Problem is another important problem to solve. It is the problem of how to determine and enforce a valid execution visit ordering when applying commands to collections that have processing interdependencies among themselves.","Some interesting aspects of the collection visit order problem include: arbitrary numbers of arbitrary collections may be involved in an execution visit ordering calculation; numeric visit order rankings are awkward to work with when large numbers of collections are involved; visit order rankings can change frequently; visit order default rankings must sometimes be overridden for particular collection instances; and visit orders can change depending upon the specific commands that are being applied.","The Parallel Collection Command Execution Problem is another important problem to solve. It is the problem of how to optimally harness available parallel processing power during command application, while still maintaining proper execution visit order among collections.","Some interesting aspects of the parallel collection command execution problem include these: there is an inherent limit to the amount of parallelism that can be achieved within each set of collections to be processed; there is a physical limit to the amount of parallel processing power available in each computational environment; and there is a policy limit to the amount of parallelism that can be used by command applicators in each administrative environment. Ideally, the inherent parallelism limit should be less than the physical parallelism limit, and the physical parallelism limit should be less than the administrative parallelism limit.","The Nearby Execution Directory Problem is another important problem to solve. It is the problem of how to execute commands in particular nearby execution directories that are located around collections, both inside and outside of collections.","Some interesting aspects of the nearby execution directory problem include: some commands must be executed inside collections; some commands outside collections; some commands in specific parent or child directories; some commands in all immediate child directories; some commands in all peer directories; and some commands must even be executed in all instances of a particular directory within a subtree, without the benefit of using collections as a starting anchors or reference points for directory calculations.","General Shortcomings of the Prior Art","A professional prior art search for the present invention was performed, but produced no meaningful, relevant works of prior art. Therefore the following discussion is general in nature, and highlights the significant conceptual differences between file-oriented mechanisms in the prior art and the novel collection-oriented mechanisms represented by the present invention.","Prior art approaches lack support for collections. This is the largest limitation of all because it prevents the use of high-level collection abstractions that can significantly improve productivity.","Prior art approaches lack collection recognition means that use collection content, collection data type, and collection per-instance data in collection recognition activities.","Prior art approaches lack execution visit ordering means to control the order in which commands are applied to particular collections within a set of collections, thereby ensuring the orderly processing of interdependencies among processed collections.","Prior art approaches lack parallel execution means for optimally processing collections in parallel, especially when execution visit ordering must be maintained within a parallel execution environment.","Prior art approaches lack indirect command execution means such as script files, thereby preventing the creation and use of persistent, reusable visit orderings and parallel execution orderings for processing collections.","As can be seen from the above description, prior art mechanisms in general have several important disadvantages. Notably, general prior art mechanisms do not support collections, and do not support visit ordering. These are the two most important limitations of all.","In contrast, the present invention has none of these limitations, as the following disclosure will show.","A collection command applicator program applies arbitrary computer commands to large numbers of dynamically selected collections, using proper execution dependency ordering and parallel execution methods. A collection command applicator can thus significantly improve the productivity of human knowledge workers in the information industry.","In operation, a collection command applicator dynamically recognizes and selects interesting collections, calculates an optimal execution dependency visit order among collections, calculates an optimal parallel execution order for commands, and then applies arbitrary computer commands to the recognized collections in accordance with the calculated orderings. In addition, a collection command applicator can generate reusable script files to store command application calculations in persistent form.","Thus the present collection command applicator invention enables both human workers and software programs to easily process large numbers of collections in automated, scalable ways that were not previously possible.","The present collection command applicator invention solves all of the general prior art limitations described previously. Specifically, it supports collections, collection recognition means, visit order means, parallel command execution means, and indirect command execution means including script files.","The main object of collection command applicator systems is to efficiently apply arbitrary computer commands to large numbers of dynamically recognized collections, using proper visit orders and parallel command execution means, thereby providing a solution to the general collection command application problem.","Another object is to provide a generalized, scalable, and automated collection command applicator means, thereby enabling the construction of generalized, scalable, automated collection processing systems.","Another object is to use a collection recognizer means capable of selecting collections using selection criteria based on collection content, collection data type, and collection instance data, thereby allowing commands to be applied to precisely-selected, particular sets of collections within large pools of collections.","Another object is to provide a collection command applicator that is capable of directly executing commands, in either sequential or parallel order, thereby enabling immediate application of commands to collections during a single program invocation.","Another object is to provide indirect execution of commands by generating script files, thereby creating a reusable and persistent way of applying commands to sets of collections.","Another object is to determine and use a proper execution visit order during command application, thereby ensuring that commands are applied in order according to interdependencies that may exist among processed collections, and thereby providing a solution to the collection visit order problem.","Another object is to determine and use an optimal parallel execution order during command application, thereby using parallel processing power to optimally process collections in a minimum amount of time, and thereby providing a solution to the parallel collection command execution problem.","Another object is to provide command application in nearby execution directories that are located in and around collections that are being processed, thereby enabling commands to be conveniently applied in frequently used nearby collection directories without requiring special efforts from human knowledge workers.","As can be seen from the objects above, collection command applicator systems provide a general, scalable, and automated means of applying arbitrary commands to arbitrary sets of precisely selected collections. Collection command applicator programs thus enable both humans and programs to conveniently apply arbitrary computer commands to arbitrary sets of collections in scalable, automated ways that were not previously possible.","Further advantages of the present invention will become apparent from the drawings and disclosure below.",{"@attributes":{"id":"p-0090","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":[{"@attributes":{"id":"ul0001-0001","num":"0089"},"b":"100"},{"@attributes":{"id":"ul0001-0002","num":"0090"},"b":"101"},{"@attributes":{"id":"ul0001-0003","num":"0091"},"b":"102"},{"@attributes":{"id":"ul0001-0004","num":"0092"},"b":"103"},{"@attributes":{"id":"ul0001-0005","num":"0093"},"b":"104"},{"@attributes":{"id":"ul0001-0006","num":"0094"},"b":"105"},{"@attributes":{"id":"ul0001-0007","num":"0095"},"b":"106"},{"@attributes":{"id":"ul0001-0008","num":"0096"},"b":"110"},{"@attributes":{"id":"ul0001-0009","num":"0097"},"b":"111"},{"@attributes":{"id":"ul0001-0010","num":"0098"},"b":"112"},{"@attributes":{"id":"ul0001-0011","num":"0099"},"b":"113"},{"@attributes":{"id":"ul0001-0012","num":"0100"},"b":"114"},{"@attributes":{"id":"ul0001-0013","num":"0101"},"b":"115"},{"@attributes":{"id":"ul0001-0014","num":"0102"},"b":"116"},{"@attributes":{"id":"ul0001-0015","num":"0103"},"b":"117"},{"@attributes":{"id":"ul0001-0016","num":"0104"},"b":"120"},{"@attributes":{"id":"ul0001-0017","num":"0105"},"b":"121"},{"@attributes":{"id":"ul0001-0018","num":"0106"},"b":"140"},{"@attributes":{"id":"ul0001-0019","num":"0107"},"b":"141"},{"@attributes":{"id":"ul0001-0020","num":"0108"},"b":"142"},{"@attributes":{"id":"ul0001-0021","num":"0109"},"b":"143"},{"@attributes":{"id":"ul0001-0022","num":"0110"},"b":"144"},{"@attributes":{"id":"ul0001-0023","num":"0111"},"b":"150"},{"@attributes":{"id":"ul0001-0024","num":"0112"},"b":"151"},{"@attributes":{"id":"ul0001-0025","num":"0113"},"b":"152"},{"@attributes":{"id":"ul0001-0026","num":"0114"},"b":"153"},{"@attributes":{"id":"ul0001-0027","num":"0115"},"b":"160"},{"@attributes":{"id":"ul0001-0028","num":"0116"},"b":"161"},{"@attributes":{"id":"ul0001-0029","num":"0117"},"b":"162"},{"@attributes":{"id":"ul0001-0030","num":"0118"},"b":"170"},{"@attributes":{"id":"ul0001-0031","num":"0119"},"b":"171"},{"@attributes":{"id":"ul0001-0032","num":"0120"},"b":"172"},{"@attributes":{"id":"ul0001-0033","num":"0121"},"b":"173"},{"@attributes":{"id":"ul0001-0034","num":"0122"},"b":"180"},{"@attributes":{"id":"ul0001-0035","num":"0123"},"b":"181"},{"@attributes":{"id":"ul0001-0036","num":"0124"},"b":"182"},{"@attributes":{"id":"ul0001-0037","num":"0125"},"b":"183"},{"@attributes":{"id":"ul0001-0038","num":"0126"},"b":"200"},{"@attributes":{"id":"ul0001-0039","num":"0127"},"b":"201"},{"@attributes":{"id":"ul0001-0040","num":"0128"},"b":"202"},{"@attributes":{"id":"ul0001-0041","num":"0129"},"b":"203"},{"@attributes":{"id":"ul0001-0042","num":"0130"},"b":"204"},{"@attributes":{"id":"ul0001-0043","num":"0131"},"b":"210"},{"@attributes":{"id":"ul0001-0044","num":"0132"},"b":"212"},{"@attributes":{"id":"ul0001-0045","num":"0133"},"b":"213"},{"@attributes":{"id":"ul0001-0046","num":"0134"},"b":"214"}]}},"Overview of Collections","This section introduces collections and some related terminology.","Collections are sets of computer files that can be manipulated as a set, rather than as individual files. Collection are comprised of three major parts: (1) a collection specifier that contains information about a collection instance, (2) a collection type definition that contains information about how to process all collections of a particular type, and (3) optional collection content in the form of arbitrary computer files that belong to a collection.","Collection specifiers contain information about a collection instance. For example, collection specifiers may define such things as the collection type, a text summary description of the collection, collection content members, derivable output products, collection processing information such as process parallelism limits, special collection processing steps, and program option overrides for programs that manipulate collections. Collection specifiers are typically implemented as simple key-value pairs in text files or database tables.","Collection type definitions are user-defined sets of attributes that can be shared among multiple collections. In practice, collection specifiers contain collection type indicators that reference detailed collection type definitions that are externally stored and shared among all collections of a particular type. Collection type definitions typically define such things as collection types, product types, file types, action types, administrative policy preferences, and other information that is useful to application programs for understanding and processing collections.","Collection content is the set of all files and directories that are members of the collection. By convention, all files and directories recursively located within an identified set of subtrees are usually considered to be collection members. In addition, collection specifiers can contain collection content directives that add further files to the collection membership. Collection content is also called collection membership.","Collection is a term that refers to the union of a collection specifier and a set of collection content.","Collection information is a term that refers to the union of collection specifier information, collection type definition information, and collection content information.","Collection membership information describes collection content.","Collection information managers are software modules that obtain and organize collection information from collection information stores into information-rich collection data structures that are used by application programs.","Collection Physical Representations\u2014Main Embodiment",{"@attributes":{"id":"p-0100","num":"0144"},"figref":"FIGS. 1-3"},{"@attributes":{"id":"p-0101","num":"0145"},"figref":["FIG. 1","FIG. 2"],"b":["100","102","5","101","103"]},{"@attributes":{"id":"p-0102","num":"0146"},"figref":["FIG. 2","FIG. 1","FIG. 2"],"b":["100","5","103","100"]},"First is a policy to specify that the root directory of a collection is a directory that contains a collection specifier file. In this example, the root directory of a collection  is a directory named \u201cc-myhomepage\u201d  Line , which in turn contains a collection specifier file  named \u201ccspec\u201d  Line .","Second is a policy to specify that all files and directories in and below the root directory of a collection are part of the collection content. Therefore directory \u201cs\u201d  Line , file \u201chomepage.html\u201d  Line , and file \u201cmyphoto.jpg\u201d  Line  are part of collection content  for said collection .",{"@attributes":{"id":"p-0105","num":"0149"},"figref":["FIG. 3","FIG. 2"],"b":["102","5"]},"Collection Information Types",{"@attributes":{"id":"p-0106","num":"0150"},"figref":"FIGS. 4-5"},{"@attributes":{"id":"p-0107","num":"0151"},"figref":"FIG. 4","b":["101","102","103","100","102","103"]},{"@attributes":{"id":"p-0108","num":"0152"},"figref":["FIG. 5","FIG. 4","FIG. 5","FIG. 4","FIG. 5","FIG. 5"],"b":["4","101","103","101","103","103","102","104","105","106","104","106","102"]},"Suppose that an application program means  knows (a) how to obtain collection processing information , (b) how to obtain collection content information , and (c) how to relate the two with per-collection-instance information . It follows that application program means  would have sufficient knowledge to use collection processing information  to process said collection content  in useful ways.","Collection specifiers  are useful because they enable all per-instance, non-collection-content information to be stored in one physical location. Collection content  is not included in collection specifiers because collection content  is often large and dispersed among many files.","All per-collection-instance information, including both collection specifier  and collection content , can be grouped into a single logical collection  for illustrative purposes.","Collection Application Architectures",{"@attributes":{"id":"p-0112","num":"0156"},"figref":"FIGS. 6-7"},{"@attributes":{"id":"p-0113","num":"0157"},"figref":"FIG. 6","b":["111","110","107","101","103","101","103","107","111","110","101","103"]},{"@attributes":{"id":"p-0114","num":"0158"},"figref":"FIG. 7","b":["110","111","112","114","115","117"]},"Collection type definition API means  provides access to collection type information available from collection type definition server means . Collection specifier API means  provides access to collection specifier information available from collection specifier server means . Collection content API means  provides access to collection content available from collection content server means .","API means -, although shown here as separate software components for conceptual clarity, may optionally be implemented wholly or in part within a collection information manager means , or within said server means -, without loss of functionality.","API means - may be implemented by any functional communication mechanism known to the art, including but not limited to command line program invocations, subroutine calls, interrupts, network protocols, or file passing techniques.","Server means - may be implemented by any functional server mechanism known to the art, including but not limited to database servers, local or network file servers, HTTP web servers, FTP servers, NFS servers, or servers that use other communication protocols such as TCP\/IP, etc.","Server means - may use data storage means that may be implemented by any functional storage mechanism known to the art, including but not limited to magnetic or optical disk storage, digital memory such as RAM or flash memory, network storage devices, or other computer memory devices.","Collection information manager means , API means -, and server means - may each or all optionally reside on a separate computer to form a distributed implementation. Alternatively, if a distributed implementation is not desired, all components may be implemented on the same computer.","Collection Data Structures",{"@attributes":{"id":"p-0121","num":"0165"},"figref":"FIGS. 8-10"},{"@attributes":{"id":"p-0122","num":"0166"},"figref":"FIG. 8"},"In particular, preferred implementations would use collection datastructures to manage collection information for collections being processed. The specific information content of a collection datastructure is determined by implementation policy. However, a collection specifier typically contains at least a collection type indicator  Line  to link a collection instance to a collection type definition.",{"@attributes":{"id":"p-0124","num":"0168"},"figref":["FIG. 9","FIGS. 9-10"]},{"@attributes":{"id":"p-0125","num":"0169"},"figref":["FIG. 10","FIG. 10"],"b":"9"},"Collection Command Applicator Means",{"@attributes":{"id":"p-0126","num":"0170"},"figref":"FIG. 11","b":"112"},"Module Get Runtime Info  obtains input arguments from the invocation command line, obtains runtime option values and configuration values from the execution environment, and otherwise prepares initial data for the command application process.","Module Collection List Producing Means  oversees the process of obtaining a list of target collections to which commands will be applied. Several different methods of obtaining the list are described below. The obtained list typically contains the identities of target collections, filesystem locations of target collections, and other useful collection information about the target collections.","Module Command Execution Means  oversees the process of applying commands to the list of target collections. Module Command Execution Sequential Means  applies commands to collections in sequential order, such that a command application to one collection is completed before another command application to another collection begins. In contrast, Module Command Execution Parallel Means  applies commands to collections in parallel, such that a single command can be applied to many collections in parallel. Parallel application of commands is useful because it reduces the time required to perform an entire command application to a set of target collections.","Operation","In operation, CCA Manager  proceeds according to the simplified algorithm shown in FIG. .","First, CCA Manager  calls Get Runtime Info  to obtain runtime information and load it into a data structure \u201cruntime-info\u201d such as shown in FIG. . In particular, Get Runtime Info  is responsible for ensuring that commands that are to be applied  Line  are present within the data structure for later use by Command Execution Means .","Next, CCA Manager  calls Collection List Producing Means  to obtain a list of target collections and associated collection information for subsequent command application.","Finally, CCA Manager  calls Command Execution Means  to apply commands obtained by Get Runtime Info  to each collection in the list of target collections, thereby completing the command application function of the CCA program.","Now that overall program structure and operation have been described, more detailed explanations can be usefully provided below.","Collection List Producing Means",{"@attributes":{"id":"p-0135","num":"0179"},"figref":"FIG. 14","b":["140","11"]},"First, Get Collection List  is responsible for obtaining a list of target collections for command application. Several different methods of calculating a list are possible, including the methods represented by modules -.","Get Collection List Explicit  obtains an explicit collection list from information provided to the CCA program invocation via Get Runtime Info .  shows an example of explicit collection pathname information for the collection tree of FIG. .","Collection Recognizer Means  obtains a list of target collections by dynamically recognizing selected collections located within a collection search space, according to match criteria provided to the CCA program invocation. Collection Recognizers are disclosed in a related patent application. See the \u201cCross-References To Related Applications\u201d section of this document for more information.","Get Collection List Other Means  architecturally represents the idea that other means of obtaining collection lists are also possible. For example, such as by calling external programs to produce collection lists, by retrieving collection lists from databases, by algorithmically calculating collection lists, and so on.","Second, Sort Collection List  is responsible for sorting the list of collections obtained from Get Collection List  into a useful sort order, if a sort is required. Note that sorts are not always desirable; unsorted collection lists are useful for many common computational purposes, and are used frequently.","Sort Collection List Alphabetical  orders collections on the list according to alphabetic sorting criteria, usually by collection name. In general, this method is most useful for improving the readability of output processing information.","Sort Collection List Visit Order  orders collections on the list according to relative execution order dependencies among the collections, for example to ensure successful software builds. This is one of the most important collection list ordering mechanisms.","Sort Collection List Other Means  architecturally represents the idea that other means of sorting collection lists for other purposes are also possible. For example, sorting by collection size, processing time, administrative priority, resources required, and so on. Collection lists can be sorted as needs require.","Operation","In operation, Collection List Producing Means  proceeds according to the simplified algorithm shown in FIG. . Generally speaking, Collection List Producing Means  calls Get Collection List  to obtain a list of target collections, and then calls Sort Collection List  to sort the list of collections.","First, the algorithm builds data structures  to support the pending computation.","To construct a list of target collections Lines -, Get Collection List  calls one or more of its subordinate modules - to obtain collection lists, in accordance with command line control arguments provided to the invocation. In a simple preferred embodiment, Get Collection Explicit  could be called to produce a list, and could use a simple text file  to explicitly list collection pathnames within a particular collection tree FIG. . In this simple preferred embodiment, the text file  could be provided as a command line argument to the CCA program invocation. Alternative means - of constructing a list are also possible, such as by using a Collection Recognizer Means . But since Collection Recognizer Means  is a more complex (but preferred) method of building a collection list, it is described later in this document as an enhanced embodiment.","The obtained collection list is stored in a data structure \u201ctarget-coll-list\u201d FIG. . This data structure is essentially a list of smaller individual collection data structures  collection data structure , when fully populated, contains essentially all there is to know about a collection, with the exception that actual collection content is not stored within the data structure.","Once a list of collections has been obtained, data structure \u201ctarget-coll-list\u201d  is returned by Get Collection List  to the calling module Collection List Producing Means  for subsequent sorting of the collection list.","To sort the obtained list of target collections, Sort Collection List  calls one or more of its subordinate modules - to perform the sorting work. In one preferred embodiment, no sorting is required, so the original unordered collection list is returned unmodified. In a second preferred embodiment, simple alphabetic sorts are required, so Sort Collection List Alphabetic  is called. In a third preferred embodiment, execution visit order sorting is required. However, since visit order sorting performed by Sort Collection List Visit Order  is a more complex (but preferred) method of sorting, it is described later in this document as an enhanced embodiment.","The sorted collection list is stored in a data structure \u201csorted-colls\u201d FIG. . This data structure holds sorting information for one possible sort of a collection list. In particular, the example data structure contains a sort type indicator  Line  and a set of sorted collections in sort order  Lines -.","Multiple different sortings of one input collection list are possible in theory, for example if the commands to be applied require different sortings. In such a case, multiple sorted-colls structures would be required to hold multiple sortings of a collection list. Typical simple embodiments do not require multiple sorts, however.","Once sorted collection lists have been obtained, they are returned by Sort Collection List Means  to the calling module Collection List Producing Means .","Collection List Producing Means  further organizes all collection list production information into a data structure \u201ccoll-list-prod-info\u201d FIG. . This data structure contains comprehensive information about the collection list production process and output results. In particular, the data structure  includes a list of target collections Line , a list of corresponding collection type definitions Line  for the target collections, a list of various sort orderings Line  for the target collections, a list of collection recognizer information Line , and other information of interest to the CCA program.","Finally, data structure \u201ccoll-list-prod-info\u201d  is returned by Collection List Producing Means  to the calling module CCA Manager , for eventual use in command application.","Command Execute Sequential Means",{"@attributes":{"id":"p-0155","num":"0199"},"figref":"FIG. 21","b":["161","11"]},"In direct execution mode, applied commands are executed by a CCA program in real time, such that all command applications are completed before the CCA program invocation is completed.","In contrast, an indirect command execution approach does not use real time execution. Instead, a CCA program using an indirect command execution approach generates an output script file  that can be reused many times to apply commands to target collections. Script files contain a specific list of all target collections identified at the time the file was created, but typically do not contain any commands to apply. Rather, script files contain internal argument placeholders for receiving commands to apply from the command line. This approach enables script files to be reused many times, each time with differing commands provided on the script invocation command line.","In practice, indirect command application is very useful because it saves the repetitive cost of recalculating the same target collection set each time a new command must be applied to a stable working set of collections. Moreover, generated script files are tangible files that can be moved, copied, stored, reused, and otherwise treated like normal files. In contrast, direct mode executions must recalculate the target set for each command application, and have no convenient tangible form to move, copy, store, or reuse.","Command Execute Sequential Direct Means","Command Execute Sequential Direct Means  is generally responsible for directly and sequentially executing commands on the list of target collections. Subordinate modules - perform most of the execution work involved, and represent various technical ways of spawning subprocesses to perform the required command applications.","Execute Sequential Fork Means  uses process \u201cforks\u201d to execute provided commands in child or peer computational processes. Forking techniques have been known to the art for many decades, are well-described in the literature, are taught in computer science schools, and can be seen in source code form in many freeware programs on the net.","Execute Sequential Thread Means  uses process \u201cthreads\u201d to execute provided commands in peer thread processes. Threading techniques have been known to the art for well over one decade, are well-described in the literature, are taught in computer science schools, and can be seen in source code form in freeware programs on the net.","Execute Sequential Other Means  architecturally represents the idea that other means of sequentially executing commands are also possible and known to the art, including by remote procedure calls, by interrupt routines, by coroutines, and so on.","Operation","In operation, Command Execute Sequential Direct Means  proceeds according to the simplified algorithm shown in FIG. .","First, the algorithm builds data structures to support the computation.",{"@attributes":{"id":"p-0165","num":"0209"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0166","num":"0210"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0167","num":"0211"},"figref":"FIG. 25"},"As part of building the data structures, Command Execute Sequential Direct Means  derives a command application execution directory pathname for each target collection, and stores the directory into the datastructures listed above. The execution directory is the filesystem working directory in which commands are applied.  Lines  and  show examples of how the execution directory is used during indirect command execution.  Line  shows how calculated execution directories are used in direct command execution.","Typically, execution directory pathnames are derived from a collection root directory pathname  by appending an execution platform name to the collection root directory. Platform names are derived from operating system names, such as platform \u201cgnulinux.plt\u201d for the freeware GNU\/Linux operating system, or \u201cwin98.plt\u201d for the Windows 98 operating system. Specific platform names are generally determined by implementation policy.","Next, Command Execute Sequential Direct Means  traverses the list of target collections stored in the data structure \u201call-coll-cmd-exe\u201d FIG. . List traversal begins at  Line .","For each collection in the list of target collections, a subordinate module - is called to perform a command application using a desired execution method. The particular type of execution method (fork, thread, . . . ) is specified by runtime information such as command line arguments or CCA program configuration options.","Command execution status information is collected and stored into \u201ccmd-exe-status\u201d  data structures as algorithm  proceeds. Implementation policies control behavior if a command application fails. That is, execution may continue to the next target collection in the list, or may be aborted for the whole CCA program invocation, as policies dictate.","Once command application is complete, data structure \u201call-coll-cmd-exe\u201d  is returned by Command Execute Sequential Direct  to Command Execute Sequential Means  and eventually to Command Execute Means  and CCA Manager .","Command execution results are extracted from data structures and communicated to CCA users. The type and quantity of results information returned is determined by implementation policy. Typically, normal execution results are printed or displayed in real time as commands are executed, and a final program status code is returned to the operating system when the CCA program completes.","Command Execute Sequential Indirect Means","Command Execute Sequential Indirect Means  is generally responsible for indirectly and sequentially executing commands on the list of target collections.","Subordinate modules - perform the real work involved, and represent various technical ways of creating executable process descriptions in the form of script files or compilable programs.","Generate Sequential Script File  creates a reusable script file in a typical scripting language for the host operating system. The generated script file visits and applies a command to all collections in the list of target collections.","Generate Sequential Program File  creates source code in a typical programming language for a program that will visit, and apply a command to, all collections in the list of target collections. The main benefit offered by this approach is that programming languages enable the generation of more complex indirect command application scripts. The main disadvantage is that the program file must usually be compiled before it can be executed, possibly imposing a significant cost overhead.","Execute Sequential Indirect Other Means  architecturally represents the idea that other means of indirectly and sequentially executing commands are also possible and known to the art, including calling external job control systems to perform the requested jobs.","Operation","In operation, Command Execute Sequential Indirect Means  proceeds according to the simplified algorithm shown in FIG. . The algorithm builds required data structures, then traverses the list of target collections, emitting script file commands to apply provided commands to target collections in the list. All technical operations required to generate script files are simple, are well described in the literature, and are well known to the art.",{"@attributes":{"id":"p-0181","num":"0225"},"figref":["FIG. 26","FIG. 19"],"b":"20"},{"@attributes":{"id":"p-0182","num":"0226"},"figref":["FIG. 27","FIG. 26"],"b":"1"},{"@attributes":{"id":"p-0183","num":"0227"},"figref":["FIG. 27","FIG. 27"],"b":["2","3","4"]},"This concludes presentation of the simplest preferred embodiments of the present collection command applicator invention, using explicit input collection lists, and direct and indirect command application methods. In what follows, several enhanced preferred embodiments will be described.","Collection Recognizer Means","One important enhanced embodiment is concerned with the problem of obtaining lists of target collections for command application. Two main ways of obtaining lists are through manual or automated means.","The manual method of using explicit collection lists  provided on a command line  Line  was described previously. The main advantage of this method is that it can be used to specify target collection sets that are difficult or impossible to automatically calculate.","However, the automated method of using a Collection Recognizer Means  to dynamically identify target collections is preferable in most cases.","The main function of collection recognizers is to identify interesting collections within a search space using collection matching criteria. Dynamic matching enables programs to dynamically form large lists of interesting collections by simply by specifying search space and collection selection criteria.","Collection command applicator programs that use collection recognizers become very powerful, useful tools. Specifically, collection recognizers can dynamically create large lists of target collections, and CCA programs can apply arbitrary commands to the target collections. This combination provides humans with a very convenient, efficient, and scalable means of automatically applying commands to large sets of automatically-identified collections.","Collection Recognizers are disclosed in a related patent application. See the \u201cCross-References To Related Applications\u201d section of this document for more information. Only a summary discussion is provided below.","Collection recognizers search for collections within collection search spaces. In preferred filesystem embodiments, collection search spaces are subtrees within typical hierarchical filesystems.","In particular, one important collection search space is the subtree below the current working directory. The main advantage of using this subtree as a search space is that it is a natural hierarchical place for human users to work from when working with multiple collections. For example, the \u201ccollections\u201d directory in  Line  is a directory in the filesystem that contains all the collections within the tree. It follows that if all collections within the tree of  were of interest, the \u201ccollections\u201d directory would be a natural place from which to start searching downward for collections.","Operation","In the context of supporting collection command application operations, a collection recognizer begins by receiving search space and collection match criteria from its calling program.","Search space criteria are provided to the collection recognizer invocation by the calling CCA program. The most common search space is usually the subtree rooted at the current working directory, but other search space directories may also be provided as explicit pathnames to the recognizer invocation.","Collection match criteria are also provided to the collection recognizer invocation by the calling CCA program. The most common collection match criteria specify that all collections are interesting, thereby enabling the calling program to process all collections within the search space subtree.","Once search space and match criteria have been obtained, collection recognizers search downward through the search space for matching collections. Two major functions are performed during downward tree searches: collection detection and collection selection.","Downward tree searches are typically implemented using tree traversal algorithms well-known to the art, including depth first and breadth first searches. In practice there is no significant performance difference between depth-first and breadth-first for small sets of small collections. For large sets of collections organized into shallow trees, breadth-first searches would probably offer higher performance because collection root directories would be discovered sooner.","Collection detection proceeds by examining each directory in the search space for the presence of a collection. Collections are detected by their collection signatures, which are sets of filesystem attributes that mark the existence of a collection. Various types and combinations of filesystem attributes for defining collection signatures are possible, including the use of specific file and directory names, suffixes, owners, timestamps, or other such filesystem information. The particular structure of collection signatures is defined by implementation policy.","Collection selection proceeds by comparing each detected collection with provided selection criteria. Selection criteria can be complex, and may be based on collection instance data (within the collection specifier), collection type data (within the collection type definition), or collection content information (within files that belong to the collection). Typical collection selections are based on collection specifier information. More complex searches are possible, and would use collection type information or collection content information. The combined process of detection and selection is called collection recognition.","Information obtained from a recognition process is stored into a \u201crec-coll\u201d data structure  as recognition proceeds. The main element of the recognized collections data structure is a list of recognized collections  Line , heavily augmented with additional information  Lines - about each collection in the list.","Once recognition has completed, a recognized collections data structure  representing the search is returned by Collection Recognizer Means  to Get Collection List , and eventually to Collection List Producing Means  and CCA Manager , for subsequent use in command application.","Collection Recognizers play a very important, very practical role in enabling the construction of scalable, automated command application systems.","Collection Visit Ordering Means","A second important enhanced embodiment is concerned with solving the collection visit order problem. That is, the problem of applying commands to collections in accordance with execution-order interdependencies among the target collections. For example, CCA invocations that implement software builds must calculate and use a valid visit order to ensure that collections are processed in proper build order.",{"@attributes":{"id":"p-0204","num":"0248"},"figref":"FIG. 14","b":["152","150","140"]},{"@attributes":{"id":"p-0205","num":"0249"},"figref":["FIG. 30","FIG. 19"],"b":"10"},{"@attributes":{"id":"p-0206","num":"0250"},"figref":["FIG. 31","FIG. 3"],"b":["1","2","2","1"]},{"@attributes":{"id":"p-0207","num":"0251"},"figref":"FIG. 32","b":["4","31"]},{"@attributes":{"id":"p-0208","num":"0252"},"figref":["FIG. 33","FIG. 30"],"b":["141","2","2","1"]},"Operation","In operation, Sort Collection List Visit Order Means  proceeds according to the simplified algorithm shown in FIG. . The collection tree of FIG.  and the input file of explicit collection pathnames  will be used to further illustrate the discussion.","First, Visit Order Means  receives an unsorted list of target collections as input, usually provided in the form of data structures such as those shown in \u201ccollection-info\u201d , \u201ccollection-type-definition-info\u201d , and especially \u201ccoll-list-prod-info\u201d FIG. .","Each collection on the unsorted list of target collections is processed in turn. For each current target collection, Visit Order Means  obtains a corresponding collection type indicator  Line ,  Line . The collection type indicator is used as a lookup key into a visit order table  Column  to obtain a corresponding numeric visit order value  Column . The retrieved numeric visit order value is finally stored with other collection information in the list of target collection data structures, for later use in sorting.","For example, using the collection specifier file of , a collection type indicator value of \u201ccf-web-page\u201d Line  would: be retrieved from the collection specifier file; be stored in a target collection data structure; be retrieved from the data structure by Visit Order Means ; be looked up in the visit order table of  Column  Line ; and would eventually resolve to a numeric visit order lookup value of 100,  Column  Line .","Sorting collections into proper visit proceeds in two operational phases. The first phase converts collection type indicators into numeric visit order values, and stores the numeric values into data structures for later use. The first phase was described above.","The second phase uses stored numeric visit order values to sort target collections properly according to build order dependencies. Sorting can be done using any sorting algorithm. Many good ones are easily available and are well-known to the art, including shell sorts, tree sorts, insertion sorts, and quicksorts. The particular choice of sorting algorithm is determined by implementation policy.","After determining a numeric visit order value for each target collection on the unsorted list, Visit Order Means  sorts the unsorted collections by numeric visit order using a chosen sorting algorithm. Sort results for each sort are stored in a data structure \u201csorted-colls\u201d  list of \u201csorted-colls\u201d  data structures is stored in a \u201ccoll-list-prod-info\u201d  Line  data structure, which could support multiple sortings if such were desired. In typical practice, however, only one visit order sort is used.","Once sorting is complete, a \u201ccoll-list-prod-info\u201d  data structure containing a list of target collections sorted by execution visit order is returned by Collection List Producing Means Manager  to the calling module CCA Manager , for eventual use in applying commands.","Continuing, the sorted list of collections  is passed into Command Execution Means  for use in either direct or indirect command applications.","For direct command applications, Command Execute Sequential Direct Means  would visit collections according to the visit orderings stored in the sorted lists of collections  Line . By way of example,  shows an example unsorted visit order sequence for the collection tree of FIG. . In contrast,  shows the same collections sorted into correct execution visit order sequence, using the visit order sorting techniques described above.","For indirect command applications, Command Execute Sequential Indirect Means  would use a sorted list of collections to emit properly ordered command sequences into a script file. By way of example,  shows a script file that uses proper execution visit ordering to visit collections in the collection tree of FIG. . Note that the script file visits collections in proper execution visit order, the same order as shown in the sorted visit order of FIG. . In contrast,  shows a script file using an unordered visit order sequence.","Named Visit Order Sets","Named visit orders extend the visit order concept by allowing individual collections to participate in multiple different visit orderings.","The problem to be solved is that a set of collections may contain different interdependencies among collections for different computational processes. For example, collection A might depend on collection B for software builds, but collection B might depend on collection A for documentation builds or for exporting data files.","A typical way to model these kinds of relationships is to separate out into separate collections the troublesome collection content that gives rise to the complex dependencies. Then the new fragmented collections can usually be organized into a single visit order scheme.","However, this approach is non-optimal because it may force the partitioning of content that should not be partitioned, and it always results in having to maintain more collections than before.","Named visit order sets are a mechanism for supporting multiple visit orderings in one collection.",{"@attributes":{"id":"p-0225","num":"0269"},"figref":"FIG. 37","b":"1"},{"@attributes":{"id":"p-0226","num":"0270"},"figref":["FIG. 38","FIG. 37"],"b":["1","2","38"]},{"@attributes":{"id":"p-0227","num":"0271"},"figref":["FIG. 39","FIG. 37"],"b":["2","2","39"]},{"@attributes":{"id":"p-0228","num":"0272"},"figref":["FIG. 40","FIG. 32"]},"Operation","In operation, named visit order sets are generally used in exactly the same way as is the unnamed visit order set that was first described above.","The main difference between named and unnamed visit order sets is that more information is used to specify a visit order ranking. That is, to represent a visit order ranking software programs must now carry two datums (a visit order set name and a visit order numeric value) whereas before only one datum (the numeric visit order value) was required.","A second minor difference is that program invocations must somehow be told which visit order set name to use. This would normally be implemented using one of the common mechanisms known to the art, such as command line arguments or program configuration options.","For example, consider the collection specifier shown in FIG. . The two named visit order set specifications Lines - are for software build visit orders and for documentation build visit orders. The main idea represented by the dual visit order specifications Lines - is that the host collection participates in two valid, but different, visit orderings.","For software build operations, a Sort Collection List Visit Order Means  would use the \u201cvo-software\u201d  Line  visit order name, corresponding to the visit order table of FIG. . In this case, the host collection would be sorted using an explicit visit order value of 49.","In contrast, for documentation build operations, a Sort Collection List Visit Order Means  would use the \u201cvo-doc\u201d  Line  visit order set, corresponding to the documentation visit order set of FIG. . In this case, the host collection would be sorted using an explicit visit order value of 10.","Named visit order sets give automated collection processing systems precise control over visit orders used during various processing operations.","Command Execute Parallel Means","Generally speaking, the parallel execution modes described below are identical to the sequential modes described above, with the added benefit of parallelism.","Limits to Parallelism","Three main factors limit the amount of parallelism that can be used in command application: (a) the inherent or problem parallelism within the set of target collections, (b) the physical parallelism available within the computational environment, and (c) administrative limits on the amount of parallelism that can be used.","Problem parallelism is inherently determined by processing interdependencies among the set of target collections. That is, only some collections can be processed in parallel. The maximum number of collections that can be processed in parallel determines the maximum problem parallelism.","Physical parallelism is determined by the physical limits of the computational environment. For example, operating systems usually limit the number of parallel processes that can be created, and computers always limit the number of physical CPU chips that are available for use.","Administrative parallelism is determined by administrative policy. This is because system administrators may want to limit the computational resources that can be accessed by any one parallel computation. For example, parallel calculations can generate significant amounts of computer load, so system administrators may want to protect other system users from big parallel calculations that hog scarce computational resources.","Useful parallelism is the maximum amount of parallelism that can usefully be applied to a particular computation under particular parallelism limits. Suppose that administrative parallelism limits are set high enough to be ignored. Then useful parallelism would be calculated as the minimum of problem parallelism and physical parallelism.","One goal of a parallel computation system is to maximize the amount of useful parallelism applied to a computation. More particularly, the overall goal of CCA parallelism mechanisms is to maximize useful parallelism while preserving execution visit order constraints. This goal is achieved by the mechanisms described below.","Calculation of Parallel Ordering","The first step required for successful parallel execution is the construction of a parallel execution ordering among target collections. Once calculated, the parallel execution ordering can be implemented by various parallel execution means.","For optimum results, a specific parallel ordering should be calculated for each command application (problem parallelism) executed using a particular parallel execution mechanism (physical parallelism). This is because different execution mechanisms may have different parallelism limits.","In practice, however, all available parallel execution mechanisms tend to run on the same computer hardware, so physical parallelism limits tend to remain fairly constant across execution method. Therefore it can sometimes be expedient to use the same parallel ordering calculation for all execution mechanisms. This approximation is particularly true in cases where problem parallelism is low, because physical parallelism becomes even less of an issue.",{"@attributes":{"id":"p-0246","num":"0290"},"figref":["FIG. 42","FIG. 11"],"b":"162"},{"@attributes":{"id":"p-0247","num":"0291"},"figref":"FIG. 41"},"First, algorithm  determines three important parallelism limits. Physical and administrative limits are normally obtained from program configuration parameters, but could also be obtained in the form of command line arguments. In both cases, Get Runtime Info  is responsible for loading the information into data structures accessible to Calculate Parallel Execution Groups . Physical and administrative parallelism limits are calculated by Lines -.","A problem parallelism limit is calculated by using an existing visit order previously calculated by Sort Collection List Visit Order . The main principle at work in both visit and parallel orderings is that all collections within the same visit order grouping can normally be executed in parallel. Therefore algorithm  calculates a problem parallelism limit by setting it equal to the number of collections in the largest existing visit order group. A problem parallelism limit is calculated by Lines -.","Next, the algorithm calculates a useful parallelism limit by taking the minimum of the problem, physical, and administrative parallelism limits Lines -. The useful parallelism limit determines the largest practical number of parallel command applications that can be executed in the current computational situation.","Finally, the algorithm calculates a list of parallel execution groups that contain target collections that can be processed in parallel Lines -.","In the case where the problem parallelism limit is lower than both the physical and administrative limits, the problem parallelism limit effectively determines the useful parallelism limit. It follows that the resulting parallel execution ordering will be exactly identical to the original execution visit ordering, because the computational environment can accommodate all the parallelism that is available in the problem set of target collections.","However, in the case where the problem parallelism exceeds the useful parallelism limit, the original visit order groups must be broken down into smaller parallel execution groups that conform to the useful parallelism limit. This reduction in group size is required in order to generate the proper number of parallel applications in each parallel execution group in indirect script files. In these cases, the computational environment cannot accomodate all the parallelism that is available in the problem set of target collections.","Accordingly, the algorithm proceeds by constructing parallel execution groups that are direct copies of the original visit order groups. For each constructed parallel group, the algorithm compares the new group size against the useful parallelism limit. If the new group size exceeds the useful parallelism limit, the algorithm breaks the large group down into smaller groups until no parallel group size exceeds the useful parallelism limit.","Once all target collections have been organized into parallel execution groups with sizes no greater than the useful parallelism limit, the algorithm returns the results to the caller.","Command Execute Parallel Direct Means",{"@attributes":{"id":"p-0256","num":"0300"},"figref":"FIG. 42","b":["162","11"]},"Command Execute Parallel Direct Means  is generally responsible for directly executing commands, in parallel, on a list of target collections. Calculate Parallel Execution Groups  calculates a set of parallel execution groups to satisfy useful parallelism limits, as described above.","Subordinate modules - perform most of the execution work involved, and represent various technical ways of spawning parallel subprocesses to perform the required command applications.","Execute Parallel Fork Means  uses process \u201cforks\u201d to execute provided commands in child or peer computational processes. Forking techniques have been known to the art for many decades, are well-described in the literature, are taught in computer science schools, and can be seen in source code form in many freeware programs on the net.","Execute Parallel Thread Means  uses process \u201cthreads\u201d to execute provided commands in parallel peer thread processes. For example, one popular threading technique is to start up a pool of threads, and then repeatedly assign and recover pool threads to parallel computations. This method avoids the cost of starting and reaping threads each time a thread is required for a computation. Threading techniques have been known to the art for over one decade, are well described in the literature, are taught in computer science schools, and can be seen in source code form in freeware programs on the net.","Execute Parallel Other Means  architecturally represents the idea that other means of executing commands in parallel are also possible and known to the art, including by parallel asyncronous remote procedure calls, by parallel coroutines, by using remote hardware and job servers, and so on.","Operation","In operation, Command Execute Parallel Direct Means  proceeds according to the simplified algorithm shown in FIG. .","First, the algorithm builds data structures to support the computation. This algorithmic function is shown by  Line .",{"@attributes":{"id":"p-0264","num":"0308"},"figref":"FIG. 44"},{"@attributes":{"id":"p-0265","num":"0309"},"figref":"FIG. 45"},"Command Execute Parallel Direct Means  calls Calculate Parallel Execution Groups  to generate a list of parallel execution groups, using the existing visit ordering for the incoming list of target collections as a guide. This algorithmic function is shown by Lines -. Once the list of parallel execution groups has been calculated and made available in data structure \u201ccmd-exe-parallel\u201d , direct parallel execution can begin.","To perform parallel command application, Command Execute Parallel Direct Means  traverses the ordered list of parallel execution groups, in proper parallel execution order. This looping behavior is shown by Lines -.","For each parallel execution group in the list, Command Execute Parallel Direct Means  spawns a separate computational subprocess for each collection in the current parallel execution group, using one of the subordinate parallel execution mechanisms -. Each parallel computational subprocess so spawned is responsible for performing command applications on one collection, thereby implementing a 1-to-1 correspondence between target collections within a parallel execution group and parallel subprocesses. The algorithm waits until all parallel subprocesses are completed, and then continues with the next parallel execution group in the list. These algorithmic functions are shown by Lines -.","Finally, after all parallel execution groups have been treated, Command Execute Parallel Direct Means  returns overall execution status information to the calling module, Command Execute Parallel Means .","A Parallel Execution Group Example",{"@attributes":{"id":"p-0270","num":"0314"},"figref":"FIG. 46","b":"30"},"Normal execution visit order constraints require that the first two collections  Lines - be in separate visit order groups in order to ensure a correct software build. Specifically, the first collection has a visit order value of 10, and the second a visit order value of 49. This same constraint also forces the first two collections into separate parallel execution groups.","As a consequence, no useful parallelism can be achieved while processing the first two collections on Lines -. Collection  Line  must be processed at time , and collection  Line  must be processed at some future time , after processing of collection  has completed.","In contrast, the second two collections Lines - can be processed in parallel. Parallel processing is allowed because both collections have the same visit order value of 50. It follows that collections  and  can be processed in parallel at a future time , where time  occurs after all subprocesses started at time  have completed.","Finally, the last 4 collections Lines - can be processed in parallel because they all have the same visit order value of 100. Thus collections - can be processed in parallel at a future time , where time  occurs after all subprocesses started at time  have completed.","The maximum useful parallelism in this example is 4, which corresponds to the largest parallel execution group size. Conveniently, we have ignored possible physical and administrative parallelism limits for this example. Therefore the inherent problem parallelism determined by software build visit order was the limiting factor in determination of a useful parallelism limit.","However, if either physical or administrative parallel limits were lower than 4, the useful parallelism limit would be correspondingly smaller. This would require that the large parallel execution group Lines - be broken up into smaller groups that satisfied the reduced useful parallelism limit. Where such breaking down of large parallel execution groups is performed, it does not matter which subgroup is executed first, since all collections in all the smaller subgroups have the same original visit order value.","Command Execute Parallel Indirect Means","Command Execute Parallel Indirect Means  is generally responsible for indirectly executing commands, in parallel, on the list of target collections. Calculate Parallel Execution Groups  calculates a set of parallel execution groups to satisfy useful parallelism limits, as described above.","Subordinate modules - perform most of the execution work involved, and represent various technical ways of creating executable parallel process descriptions in the form of script files or compilable programs.","Generate Parallel Script File  creates a reusable script file in a typical scripting language for the host operating system. The generated script file visits and applies a commands to all collections in the list of target collections, using parallel command execution mechanisms.","Generate Parallel Program File  creates a reusable Program file written in a programming language. The generated program file visits and applies commands to all collections in the list of target collections. The main advantage of using a programming language over a scripting language is that programming languages are much more powerful than typical scripting languages. Thus using a programming language enables the generation of more powerful indirect command application files. The main disadvantage of using a programming language is higher overhead costs, because resulting program files must usually be compiled before they can be used.","Execute Parallel Indirect Other Means  architecturally represents the idea that other means of indirect parallel command execution are also possible and known to the art, including calling external job control systems that are capable of executing jobs in parallel.","Operation","In operation, Command Execute Parallel Indirect Means  proceeds according to the simplified algorithm of FIG. .","The algorithm for indirect execution is essentially the same as the algorithm direct execution, with the main exception that the indirect algorithm emits script file syntax for executing a command, rather than executing the command directly. In all other respects, the direct and indirect algorithms are conceptually similar.",{"@attributes":{"id":"p-0284","num":"0328"},"figref":"FIG. 48","b":["212","46"]},{"@attributes":{"id":"p-0285","num":"0329"},"figref":"FIG. 48","b":["1","2","7"]},"Lines - apply the provided commands to the first parallel execution group, which contains only one collection. The \u201c$@\u201d symbol on Line  represents the command to be applied. Line  represents the application of commands to the second parallel execution group. The second execution group has been omitted to save space, since its structure is identical to the structure of the first execution group Lines -.","Lines - show a parallel command application to two collections. The \u201c&\u201d (ampersand) symbol Line  effectively tells the interpreter to execute the command in parallel, and to immediately continue script execution with subsequent script lines. Line  shows a \u201cwait\u201d command that tells the script interpreter to stop execution, and to wait for all parallel commands to complete execution. Once all outstanding parallel commands Lines  complete, the interpreter continues script execution once again.","Lines - show a second parallel command application, but this time involving the 4 collections in the last parallel execution group of FIG. . When this group of parallel commands completes, the script exits at Line .","Nearby Execution Directories",{"@attributes":{"id":"p-0289","num":"0333"},"figref":["FIG. 49","FIG. 19"]},{"@attributes":{"id":"p-0290","num":"0334"},"figref":"FIG. 50","b":"5"},"As described previously, and as shown by the script files in FIG.  and , commands are applied to target collections by changing into a working directory within a target collection, executing a command, and then changing back to a working directory outside of the collection.","Execution directory pathnames such as shown in  Line  are typically created by appending a platform name such as \u201cwin98.plt\u201d to a collection root directory pathname such as shown in  Line . Formulating platform execution directories this way is practical because many commonly applied commands require execution from a platform subdirectory within a collection.","However, not all applied commands can be effectively applied from within a platform directory. Instead, some commands must be executed within a source directory  Line  within a collection, or from a parent directory above several collections  Lines , , . For convenience, such directories are called nearby execution directories.","The general problem to be solved is called the nearby execution directory problem. That is, various applied commands must be executed in various nearby execution directories, including platform directories, source directories, parent directories, platform child directories, immediate child directories of parent directories, and so on.","The mechanism described here is a general solution to the nearby execution directory problem.","Operation","In operation, a Get Runtime Information  module would obtain nearby directory specifications for the invocation, in the form of command line arguments such as \u201c\u2212parentdirs\u201d or in the form of invocation or configuration options. Regardless of the information source, Get Runtime Information  would make nearby execution directory information available to other modules within a CCA program FIG. .","Continuing, Command Execution Means  and its subordinate modules would eventually use nearby execution directory information to calculate nearby execution directories, in accordance with the control information obtained and passed on by Get Runtime Information . Nearby directories are calculated by modifying the original collection root pathname, by adding, removing, or replacing pathname components.","No specific software module is responsible for providing nearby directory calculation services. This is because modifying pathnames by adding, removing, or replacing pathname components is a trivial, low level software operation that is unworthy of a separate software module description in this disclosure. In practice, modifications are usually made by the currently executing software module, perhaps by using typical software library subroutines designed for the purpose.","Ultimately, Command Execution Means  and its subordinate modules use the calculated nearby execution directories as actual execution directories for command applications, thereby enabling CCA programs to apply commands in a broader number of directories and computational situations, and thereby providing a solution to the nearby execution directory problem.","The present collection command applicator invention provides practical solutions to four important problems faced by builders of automated collection processing systems. The four problems are: (1) the general collection command application problem, (2) the collection visit order problem, (3) the parallel collection command execution problem, and (4) the nearby execution directory problem.","In particular, the present collection command applicator invention provides both humans and software programs with a practical, efficient, and scalable means for applying computer commands to large numbers of precisely-determined collections. Importantly, the present invention uses dynamically calculated visit orderings to accommodate dependencies among collections, and uses parallel execution techniques to improve scalable execution performance.","Collection command applicators thus enable both humans and software programs to practically and easily perform automated computations that were not previously possible.","Although the foregoing descriptions are specific, they should be considered as sample embodiments of the invention, and not as limitations. Those skilled in the art will understand that many other possible ramifications can be imagined without departing from the spirit and scope of the present invention.","General Software Ramifications","The foregoing disclosure has recited particular combinations of program architecture, data structures, and algorithms to describe preferred embodiments. However, those of ordinary skill in the software art can appreciate that many other equivalent software embodiments are possible within the teachings of the present invention.","As one example, data structures have been described here as coherent single data structures for convenience of presentation. But information could also be could be spread across a different set of coherent data structures, or could be split into a plurality of smaller data structures for implementation convenience, without loss of purpose or functionality.","As a second example, particular software architectures have been presented here to more strongly associate primary algorithmic functions with primary modules in the software architectures. However, because software is so flexible, many different associations of algorithmic functionality and module architecture are also possible, without loss of purpose or technical capability. At the under-modularized extreme, all algorithmic functionality could be contained in one software module. At the over-modularized extreme, each tiny algorithmic function could be contained in a separate software module.","As a third example, particular simplified algorithms have been presented here to generally describe the primary algorithmic functions and operations of the invention.","However, those skilled in the software art know that other equivalent algorithms are also easily possible. For example, if independent data items are being processed, the algorithmic order of nested loops can be changed, the order of functionally treating items can be changed, and so on.","Those skilled in the software art can appreciate that architectural, algorithmic, and resource tradeoffs are ubiquitous in the software art, and are typically resolved by particular implementation choices made for particular reasons that are important for each implementation at the time of its construction. The architectures, algorithms, and data structures presented above comprise one such conceptual implementation, which was chosen to emphasize conceptual clarity.","It follows that there are many possible equivalent implementations of the present invention. Better guides to algorithmic and functional equivalence are the essential inputs, outputs, information associations, and information uses that characterize an algorithm. These characteristics are much more fundamental to a software invention than flexible architectures, simplified algorithms, and particular organizations of data structures.","Practical Applications","Collection command applicators can be used in various practical applications.","One application is to improve the productivity of human computer programmers by providing them with an automated means of applying arbitrary commands to dynamically determined sets of interesting collections.","Another application is to enable the construction of automated collection processing systems that are capable of dynamically applying commands to large numbers of collections that are presented to the automated system.","Another application is perform bulk upgrade modifications to particular sets of interesting collections that are part of a larger set of collections, thereby reducing software maintenance costs.","Another application is to perform bulk software build operations on large software systems composed of many interdependent collections.","Other applications can also be imagined by those skilled in the art.","Functional Enhancements","One possible functional enhancement is to provide a graphical user interface for a collection command applicator, and to collect real-time status information from command applications for display on the GUI. This would allow human users to specify collection selection criteria, to specify command application information, to initiate command application, and to monitor ongoing status results during execution.","Collection List Producing Means","The foregoing disclosure described both explict and collection recognizer means for obtaining lists of collections to visit. However, many other methods of obtaining target collection lists are also possible.","For example, collections could be specified by interactive keyboard or mouse selection means, by providing collection names on invocation command lines, by obtaining collection names from a network collection name server, by retrieving collection names from a database means, or by algorithmically calculating a set of collection names.","Collection Vs. Directory Recognition","In one important alternative embodiment, a list of collection names is not used by a CCA program to determine a set of execution directories. Instead, a Collection List Producing Means  uses simple explicit filename or directory names in search expressions, to identify matching directories or files within a search subtree. For example, a collection list producing means could directly search for all directories named \u201cwin98.plt\u201d within a specified set of subtrees.","Having obtained a list of such file or directory pathnames, a CCA program could use the pathnames in two ways. First, pathnames could be used as anchor reference pathnames for use in nearby directory calculations. Or second, the pathnames could be used as the ultimate execution directories themselves.","Using pathnames as reference anchors for nearby directory calculations or for ultimate execution directories allows collection command applicators to function independently of collections, since no collection information is used during such command application operations.","Collection Visit Ordering Means","The foregoing disclosure described collection list sorting means that were based on alphabetic names or numeric visit order values. However, other methods of determining visit order are also possible.","For example, dynamic visit orders could be calculated using collection size, collection content, depth within a subtree, or filesystem attributes such as last modified timestamps. Furthermore, explicit visit orders could be entered as command line invocation options, or as configuration options.","In principle, visit orders can be determined using any interesting attribute of the collections being sorted.","Command Execution Means","The foregoing disclosure described direct command execution primarily in terms of process forks and threads. However, other means of initiating and managing computational processes are also possible.","For example, remote procedure calls, interrupts, signals, coroutines, remote method servers, applets, network servers, and distributed network job management systems are all methods well known to the art. Specific choices of execution methods are determined by implementation policy.","For indirect command execution, other ramifications are also possible. In one possible embodiment, a CCA program could execute a script or program file immediately after it was generated. This approach would combine the advantages of immediate execution from direct execution with the benefit of persistent, reusable scripts or program files from indirect execution.","Alternative Implementations","Each software component identified above may optionally reside on a separate computer to form a distributed implementation. Distributed implementations would be necessarily more complex, and would require the use of normal network protocols to carry information among distributed components. However, if distributed implementations are not desired, all components may reside on the same computer.","Data structures have been described here as coherent single structures for presentation clarity. However, other implementations are also possible. For example, information could be split into a plurality of smaller data structures for implementation or communication convenience, without loss of functionality.","As can be seen by one of ordinary skill in the art, many other ramifications are also possible within the teachings of this disclosure.","The present invention is not limited to any particular computer architecture, operating system, filesystem, database, or other software implementation.","Therefore the full scope of the present invention should be determined by the accompanying claims and their legal equivalents, rather than from the examples given in the specification."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 2","FIG. 1","FIG. 2"],"b":["100","102","5"]},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 3","b":"102"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 4","b":["101","102","103","100"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 6","b":["111","110","107","101","103"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 7","b":["110","111","112","114","115","117"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 14","b":"11"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 15","b":"140"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 18","b":"140"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 20","FIG. 19"]},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 21","b":"161"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 22","b":"170"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 26","b":["181","180"]},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 27","b":"26"},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 28","b":["180","181"]},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 29","b":"143"},{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 30","FIG. 19"]},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 32","FIG. 3"]},{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 33","b":"30"},{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 34","b":"152"},{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 35","b":"30"},{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 36","b":"181"},{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 37"},{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 38"},{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 39"},{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 40"},{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIG. 41","FIG. 42"],"b":"201"},{"@attributes":{"id":"p-0081","num":"0080"},"figref":["FIG. 42","FIG. 11"],"b":"162"},{"@attributes":{"id":"p-0082","num":"0081"},"figref":["FIG. 43","FIG. 42"],"b":"200"},{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 44"},{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 45"},{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 46","b":"30"},{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIG. 47","b":"210"},{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 48","b":["212","46"]},{"@attributes":{"id":"p-0088","num":"0087"},"figref":["FIG. 49","FIG. 19"]},{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 50"}]},"DETDESC":[{},{}]}
