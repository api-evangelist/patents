---
title: HTTP transaction monitor with sequence replay capacity
abstract: A method for monitoring data flow in a web application hosted on a server includes obtaining a list of HTTP requests processed on the server while interacting with the web application, selecting a number of HTTP requests from the list, and sending a request to the server to re-process the selected number of HTTP requests in a predetermined sequence.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07099939&OS=07099939&RS=07099939
owner: Sun Microsystems Inc.
number: 07099939
owner_city: Santa Clara
owner_country: US
publication_date: 20010605
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","COPYRIGHT STATEMENT","TERMINOLOGY","BACKGROUND OF INVENTION","SUMMARY OF INVENTION","DETAILED DESCRIPTION","Architecture Overview","Storing and Managing HTTP Transaction Data","HTTP Transaction Monitor GUI","HTTP Transaction Monitor Server-Side Functionality","Operation"],"p":["This application claims priority from U.S. Provisional Application Ser. No. 60\/237,823, filed Oct. 3, 2000. This application is related to original U.S. patent application Ser. No. 09\/730,686, entitled \u201cHTTP Transaction Monitor,\u201d filed Dec. 6, 2000, and original U.S. patent application Ser. No. 09\/789,238, entitled \u201cHTTP Transaction Monitor with Replay Capacity,\u201d filed Feb. 20, 2001.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office file or records, but otherwise reserves all copyright rights whatsoever.","The following definitions of some terms are helpful in understanding the background discussion and the detailed description of the invention.","API (Application Programming Interface)\u2014An interface for application programs and utilities to access the internal services provided by the software that comprises the API.","Applet\u2014A Java\u2122 program embedded in a HTML document and executed in a Java\u2122\u2014enabled browser.","ASP\u2122 (Active Server Pages\u2122)\u2014A scripting environment developed by Microsoft Corporation. ASP\u2122 allows HTML, scripts, and ActiveX components to be combined to create dynamic web pages.","Bean\u2014A JavaBeans\u2122 component.","CGI (Common Gateway Interface)\u2014A standard for running external programs from an HTTP server.","CGI Script\u2014A small program written in a script language such as Perl that can be invoked through a request to the web server.","Class\u2014A user-defined data type that defines a collection of objects that share the same characteristics. An object is one instance of the class.","Client\u2014A program, often including a user interface, which initiates contact with another program (a server) for the purposes of exchanging data. The server runs in a different process and\/or on a different host from the client.","Cookie\u2014A packet of information sent by an HTTP server to a web browser and then sent back by the browser each time the browser accesses the same resource on the server or any other set of resources that is declared by the cookie. Cookies are used to maintain state between HTTP transactions. Cookies are not visible to the browser user.","DHTML (Dynamic HTML)\u2014An extension of HTML. DHTML gives greater control over the layout of page elements and the ability to have web pages which change and interact with the user without having to communicate with the server.","Directory\u2014A simulated file folder on disk.","E-commerce (Electronic commerce)\u2014Typically implies purchasing products via the Web. It also covers electronic data interchange, in which one company's computer queries and transmits purchase orders to another company's computer.","Execution Server\u2014An HTTP server that is used by an IDE for the purposes of assisting with the processes of developing dynamic web components. The IDE uses the execution server to run JSPs and servlets, or dynamic page generation components in general.","GUI (Graphical User Interface)\u2014A graphics-based interface that incorporates, for example, icons, menus, and text entry areas and allows for non-linear user interaction (as opposed to character-based interfaces where the user enters data by answering questions in a set order).","Hook\u2014Programming instructions that provide breakpoints for future expansion. Hooks can be used to call some outside routine or function or may be places where additional processing is added.","HTML (HyperText Markup Language)\u2014A hypertext document format used on the World Wide Web.","HTTP (Hypertext Transfer Protocol)\u2014An application-level protocol for distributed, collaborative, hypermedia information systems.","HTTP Request\u2014A message sent by a client to a server using HTTP. The first line of the request contains the method to be applied to the resource requested, the identifier of the resource, and the protocol version in use. The first line is followed by HTTP headers, lines which provide information about the client, which are optionally followed by a data stream.","HTTP Response\u2014A message sent to a client after the HTTP server receives and interprets a request message from the client. The first line of the response includes the protocol version used by the server and a success or error code. The first line is followed by HTTP headers with information about the server and about the (optional) body content that follows the headers as a data stream.","HTTP Server\u2014A server process which processes HTTP requests.","HTTP Session\u2014Part of the Java Servlet\u2122 API. Allows the HTTP server to maintain state between different HTTP requests. The HTTP server knows which session to associate with the request because the browser sends the session ID as part of the request. This can either be done with a cookie or by adding a parameter to the request URL.","IDE (Integrated Development Environment)\u2014An application that facilitates the process of writing software. An IDE typically includes a syntax-based editor, graphical tools for program entry, and integrated support for compiling, executing, and debugging the program.","IDE Session\u2014The instance of an IDE (and all its internal states) that is created when the user starts up and uses the IDE. The session ends when the user exits the IDE instance.","Internal HTTP Server\u2014Sometimes referred to as internal server. An HTTP server that runs in the same process of an application for the purposes of providing services to it.","J2EE\u2122\u2014Java 2 Platform, Enterprise Edition.","JavaBeans\u2122\u2014A component software architecture that runs in the Java\u2122 environment, initially developed by Sun Microsystems, Inc. JavaBeans\u2122 allows developers to create reusable components that can be assembled together using a visual application builder tool.","JSP\u2122 (JavaServer Pages\u2122)\u2014A specification to extend the JavaServlet\u2122 API to generate dynamic web pages on a web server. It includes a set of tags in XML format for creating dynamic content in web pages. In order to use JSP\u2122 on a web server, the web server needs a JSP\u2122 engine and a servlet engine. The JSP\u2122 engine is responsible for generating a servlet from the JSP\u2122 page and maintaining a name convention such that the servlet is invoked when the JSP\u2122 page is processed. JSP\u2122 was developed by Sun Microsystems, Inc.","JSP\u2122 Page\u2014A text-based document that uses fixed template data and JSP\u2122 elements and describes how to process a request to create a response. The template data consists of JSP\u2122 tags embedded in static content which is typically HTML.","LRI (Local Resource Identifier)\u2014The location of a resource relative to the hierarchical structure of the server, e.g., a path relative to the server's document root if the resource is a file.","Plug-in\u2014An auxiliary program that works with a major software package to enhance its capability.","Process\u2014An executing program with its own internal data states that are not accessible to other processes.","Web Resource\u2014A network data object or service that can be identified by a URI.","Server\u2014An application program that accepts connections in order to service requests by sending back responses.","Servlet\u2014A Java\u2122 program that runs exclusively in a servlet engine which is an extension to a web server.","URL (Uniform Resource Locator)\u2014A compact string representative of resources available via the network. A URL has the form <protocol>:\/\/<server name><LRI><?optional parameters>.","Virtual Machine\u2014A self-contained operating environment that behaves as if it is a separate computer. A Java\u2122 virtual machine is a Java\u2122 interpreter that converts Java byte code into machine language one at a time and then executes it.","Web Browser\u2014A client application that requests resources from a web server, usually for the purpose of displaying them. Examples of browsers are Microsoft\u00ae Internet Explorer and Netscape Navigator.","XML (eXtensible Markup Language)\u2014A mark-up language that provides a format for describing structured data.","1. Field of the Invention","The invention relates generally to web application development systems. More specifically, the invention relates to a mechanism for monitoring data flow in a web application, particularly during testing and debugging of the web application.","2. Background Art","A web application is a web site where users can access the information they need and change the state of application logic on a server through a set of web pages. Development of web applications is usually centered around tools and technologies. A web application centered around the Java\u2122 technology may include the following: JSP\u2122 pages and Java\u2122 servlets that handle HTTP requests and generate dynamic content, server-side beans that encapsulate application behavior and state, static HTML files, DHTML files, image files, sound files, and libraries with additional Java\u2122 components, such as client-side Java\u2122 applets and any Java\u2122 class files used by the other Java\u2122 components. The J2EE\u2122 specification describes a standard for how to organize such files into web modules, including describing how they are accessed. The web modules could be developed in an IDE, such as sold under the trade name Forte\u2122 for Java\u2122 by Sun Microsystems, Inc., Palo Alto, Calif.","The process of test-running and debugging web applications that provide dynamic responses to different user inputs involves testing each component that generates pages with every possible type of user input. This includes user input that is technically incorrect (e.g., entering \u201c&&^%\u201d into a field where the expected input is a U.S. zip code). To understand how the process works, consider an e-commerce application that contains a set of pages (A\u2013G) that allows a user to move through a checkout process. The sequence of events for the checkout process is outlined in Table 1 below. A common architecture for this type of web application would be to have each of the pages (A\u2013G) correspond to an individual JSP\u2122 page. Further, because the order in which the pages can be traversed needs to be controlled, all requests for these JSPs\u2122 are handled by a servlet, which allows them to be displayed in appropriate circumstances.",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Sequence of events for checkout process"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Page","Event"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["A","The user views the contents of the shopping cart for the"]},{"entry":[{},"purposes of accepting the selected items. Page A is displayed only"]},{"entry":[{},"if the user has selected some items."]},{"entry":["B","The user enters their credit card information and home address."]},{"entry":["C","The information from page B is displayed, giving the user"]},{"entry":[{},"the option to go back to page B to correct the information or"]},{"entry":[{},"move forward to page D."]},{"entry":["D","The user enters the shipping address."]},{"entry":["E","The shipping address from page D is displayed, giving the user the"]},{"entry":[{},"option to go back to page D to correct the shipping address"]},{"entry":[{},"or move forward to page F."]},{"entry":["F","All the information entered by the user (i.e., items purchased,"]},{"entry":[{},"credit card information, home address, and shipping address)"]},{"entry":[{},"is displayed. Page F gives the user the option to proceed"]},{"entry":[{},"with or cancel the transaction."]},{"entry":["G","A thank-you note is displayed if the user completes the transaction."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Now, suppose that the developer has identified a problem with how the input from page D (i.e., the shipping address) is processed. In order to reproduce the problem, the developer has to achieve a certain state with respect to the web application. This would involve first performing the HTTP transactions required to put something in the shopping cart, or else the controller servlet will not allow the pages to be accessed at all. Then the developer has to move through page A, fill in credit card information and home address on page B, move through page C, and fill in shipping address on D in order to reproduce the problem. HTML forms need to be filled in order to allow the resource that needs debugging to be accessed.","In the scenario described above, it is clearly desirable for the developer to be able to place the web application in the desired state without having to enter data through HTML forms in order to put something in the shopping cart and reenter the same data into the different pages. The mechanism described in U.S. patent application Ser. No. 09\/789,238, supra, allows a user to collect information about HTTP transactions and replay the HTTP transactions at a later time. If the HTTP transactions during shopping (i.e., while selecting items) and the checkout process are recorded, they can be replayed at a later time. To use this mechanism for debugging the web application described above, the developer would have to find the desired transactions to replay, and then replay each one individually. This process has to be repeated for each debugging cycle.","In one aspect, the invention relates to a method for monitoring data flow in a web application hosted on a server which comprises obtaining a list of HTTP requests processed by the server while interacting with the web application, selecting a number of the HTTP requests from the list, and sending a request to the server to re-process the selected number of HTTP requests in a predetermined sequence.","In another aspect, the invention relates to a method for monitoring data flow in a web application hosted on a server which comprises saving HTTP transactions executed on the server while interacting with the web application, selecting a number of the saved HTTP transaction, and sending a request to the server to re-execute the selected number of the saved HTTP transactions in a predetermined sequence.","In another aspect, the invention relates to a mechanism for monitoring data flow in a web application hosted on a server which comprises a directory for storing HTTP transactions executed on the server while interacting with the web application and a display through which a request can be sent to the server to re-execute a selected number of the HTTP transactions in the directory in a predetermined sequence.","In another aspect, the invention relates to a system for testing and debugging a web application which comprises a server hosting the web application, a directory for storing HTTP transactions executed on the server while interacting with the web application, and a client through which a request can be sent to the server re-execute a selected number of the HTTP transactions in the directory in a predetermined sequence.","Other aspects and advantages of the invention will be apparent from the following description and the appended claims.","Embodiments of the invention provide a tool for replaying HTTP transactions in a predetermined sequence during testing and debugging of a web application. The tool allows a user to save HTTP transactions, extract a set of the saved HTTP transactions, and replay all of the HTTP transactions in the set in a predetermined sequence with a single user gesture. The tool is particularly useful when debugging a web application that includes wizard-like behavior, where the user enters data through a number of web pages that must be accessed in a particular order. A very common example of this wizard-like behavior is the checkout process included in most e-commerce applications. As discussed in the background, to reproduce a problem encountered during the checkout process, the web application has to be placed in a certain state. For example, the web application may be set up in such a way that the user is not allowed to start the checkout process unless one or more products have been placed in the shopping cart. Using the tool of the invention, the user can select a set of HTTP transactions that need to be executed in order to place the web application in the desired state. The user can then replay the set of HTTP transactions in a predetermined sequence to place the web application in the desired state.","In the following detailed description of the invention, numerous specific details are set forth in order to provide a more thorough understanding of the invention. For example, a web application which contains JSPs\u2122 and servlets is used in illustrating the principles of the invention. However, it will be apparent to one of ordinary skill in the art that the invention may be practiced without these specific details. For example, the invention is applicable to web applications containing other type of dynamic page generation components such as ASPs\u2122 and CGI scripts. In other instances, well-known features have not been described in detail to avoid obscuring the invention. Also, for convenience, the following description is outlined into five principal sections, including Architecture Overview, Storing and Managing HTTP Transaction Data, HTTP Transaction Monitor GUI, HTTP Transaction Monitor Server-Side Functionality, and Operation.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 1","b":["2","2","6","6","6","6","6","10","10","6","10","6"]},"In accordance with one embodiment of the invention, an HTTP transaction monitor  includes a server-side component  and a client-side component . The server-side component  collects data about HTTP transactions resulting from HTTP requests processed on the execution server . The client-side component  manages and displays the collected data. The HTTP transactions can either be initiated by the IDE  or through an external HTTP client, e.g., a browser, pointed to the host and port of the execution server . The server-side component  includes a data collector  that is responsible for collecting data before and after the execution server  processes the HTTP requests. In one implementation, the data collector  process runs on the execution server  and relies on hooks in the execution server  to intercept HTTP requests in order to collect data about them. In an alternate embodiment, the data collector  may use hooks in a web container (not shown) to intercept HTTP requests. A web container, such as a servlet engine, provides runtime support for dynamic components of the web application. The web container may run inside or outside of the execution server  process.","The server-side component  also includes a request player  running on the execution server . The request player  detects a special type of HTTP request, called a \u201creplay request.\u201d The replay request indicates that a prior HTTP transaction should be re-executed. In one embodiment, the replay request includes data that allows the request player  to retrieve the corresponding transaction record from the client-side component . The transaction record contains the request data, i.e., the IP address of the client from which the HTTP request originated, the HTTP method, the request URI, the protocol version, any query string and parameters, and all the HTTP headers, needed to recreate the prior HTTP request. The request player  rewrites the replay request with the data retrieved from the client-side component  and transfers the modified replay request to the data collector  for data collection. After data collection, the replay request is processed by the execution server . In one implementation, the request player  relies on hooks in the execution server  or hooks in a web container (e.g., a servlet engine) to intercept requests coming into the execution server  in order to determine whether the requests are replay requests.","The client-side component  includes a GUI (or display)  for displaying data about the HTTP requests for which the server-side component  has collected data. The GUI  also allows the user to select an HTTP transaction and send a request to the execution server  to re-execute the HTTP transaction. A component of the GUI  may also send replay requests programmatically (i.e., through function invocation) to the execution server . The request data associated with each replay request may correspond exactly to the original request data associated with the prior HTTP transaction to be re-executed or may be a modification of the original request data. In one implementation, the GUI  is accessible from the IDE , and the IDE  includes a mechanism through which the data collector  can notify the client-side component  of HTTP requests processed by the execution server . This mechanism can be an HTTP server  which is built into the IDE  and configurable from the IDE . If the HTTP transaction monitor  is run as a standalone application, then the client-side component  would be responsible for maintaining the mechanism through which it is notified when the execution server  processes a new HTTP request.","For each HTTP transaction that the execution server  processes, the data collector  collects the five categories of data shown in Table 1. In addition to the categories of data shown in Table 1, the data collector  generates the information required to list the transaction in the GUI . In one embodiment, this information includes the ID of the transaction, the HTTP method, the LRI of the request, and timestamp of the transaction. Additional data may be included to generate more detailed list entries.",{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Categories of Data Collected by Server-Side Component"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Category","List of Data Collected"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Request","The IP address of the host from which the request was sent,"]},{"entry":[{},"the HTTP method, the LRI, path information (if appropriate),"]},{"entry":[{},"the query string, the protocol version, the referrer (if"]},{"entry":[{},"appropriate), the value of any incoming parameters, and the"]},{"entry":[{},"exit status of the HTTP response. All HTTP headers"]},{"entry":[{},"associated with request."]},{"entry":["Cookies","List of incoming and outgoing cookies. For incoming cookies,"]},{"entry":[{},"the name and value is provided. For outgoing cookies, the"]},{"entry":[{},"name, value, domain, time to live, path and whether"]},{"entry":[{},"the cookie requires secure protocol."]},{"entry":["Session","Whether the session exists before and after the transaction."]},{"entry":[{},"Which attributes were set and what their values are before and"]},{"entry":[{},"after the transaction. The session's properties: its ID, when it"]},{"entry":[{},"was created, its maximum inactive interval, and when it was"]},{"entry":[{},"last accessed."]},{"entry":["Servlet\/","Name of the servlet as configured, its class name, its package"]},{"entry":["Server","name, the description given by the developer, and the relative"]},{"entry":["Properties","path to the servlet. The servlet's initialization parameters, if"]},{"entry":[{},"there are any. The absolute path to the J2EE\u2009\u2122 context. The"]},{"entry":[{},"servlet engine's properties (Java\u2009\u2122 Development Kit and"]},{"entry":[{},"platform)."]},{"entry":["Client","The version of the HTTP protocol, the client's IP address, any"]},{"entry":[{},"other information provided through the HTTP headers such as"]},{"entry":[{},"the nature of the client, e.g., the type and version of the"]},{"entry":[{},"browser, the user's language preference, and what formats and"]},{"entry":[{},"character sets the browser can deal with."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The client-side component  includes a mechanism for receiving notification of new HTTP transactions, which are subsequently listed on the GUI . In one embodiment, this functionality is handled by a servlet  that runs on the internal HTTP server  and is called whenever the server-side component  records a new transaction. In one implementation, notification of a newly recorded transaction is sent to the servlet  in the form of an HTTP POST request with a query string appended to the URL and the transaction data (in a structured format such as XML) as the posted data. The HTTP POST request identifies the name of the host on which the IDE  is running and the port number of the internal HTTP server . The query string has the general format: ID|METHOD|RESOURCE, where <ID> is a string that uniquely identifies the transaction, <METHOD> is the HTTP method of the original request, and <RESOURCE> is the path relative to the server root to the resource that was accessed by the original request. The data from the query string is also part of the XML representation. The query string is simply used to add a new transaction to the list in GUI  without requiring the entire transaction record to be processed at notification time. Notification of newly recorded transactions may also be sent programmatically to the servlet . To do this, an HTTP POST request is issued to the servlet  with a query string such as described above appended to the URL. Then, a file (typically in a structured format such as XML) containing the transaction data is sent to the servlet .","In one embodiment the client-side component  uses a directory  to store transaction files. The client-side component  uses normal file operations to access and manipulate the data stored in the directory . In one implementation, the directory  has three subdirectories: \u201ccurrent,\u201d \u201csave,\u201d and \u201creplay.\u201d When the client-side component  is notified that the execution server  has processed a new request, the corresponding transaction is stored in a new file called <id>.xml under the directory \u201ccurrent,\u201d where <ID> is the unique identifier described above, and xml is the extension required for xml files. The GUI  interacts with the directory  through a client controller  to update its transaction list. When the user elects to save a transaction through the GUI , the user invokes a \u201cSave\u201d action on the transaction, which causes the corresponding transaction files to be moved from the \u201ccurrent\u201d directory to the \u201csave\u201d directory. It should be noted that there may be other ways of keeping track of whether the transactions are current or saved. When the user elects to edit and replay a transaction through the GUI , a dialog is displayed which allows the user to edit the transaction. The changes are saved in a temporary file (also called <id>.xml) in the \u201creplay\u201d directory. Upon exiting the IDE , the files in the\u201ccurrent\u201d directory may be deleted to conserve disk space. Files in the \u201csaved\u201d and \u201creplay\u201d directories remain until they are explicitly deleted by the user.","The GUI  may be a software component that can be called from within the IDE  or may be a standalone application.  illustrates a possible representation of the GUI . In the figure, the GUI  includes a single frame  having a left pane  and a right pane . The GUI  displays a list of transactions on the left pane  and data for an individual transaction on the right pane . A row of buttons  above the transaction list on the left pane  allows the user to reload all transactions and to modify display parameters. The button  reloads all the transactions. The button  displays the transactions in alphabetical order, by LRI. The button  displays the transactions in temporal order, last transaction last. The button  displays the transactions in reverse temporal order, last transaction first. The button  toggles whether the time stamp of the transaction is shown or not.","The left pane  displays one supercategory node \u201cAll Transactions.\u201d Under the \u201cAll Transactions\u201d node are subcategory nodes \u201cCurrent Transactions,\u201d \u201cSaved Transactions,\u201d and \u201cTransaction Sequence.\u201d Individual transactions are leaf nodes and reside in either the \u201cCurrent Transactions\u201d or the \u201cSaved Transactions\u201d node. Entries in the \u201cCurrent Transactions\u201d node are available during the current IDE session, while entries under the \u201cSaved Transactions\u201d node persist until they are deleted by the user. The entries under the \u201cCurrent Transactions\u201d and \u201cSaved Transactions\u201d nodes are obtained from the \u201ccurrent\u201d and \u201csave\u201d subdirectories in the directory  (shown in ). The \u201cTransaction Sequence\u201d node contains folders that are created and named by the user to hold sets of HTTP requests to be replayed together as a sequence. The user adds leaf nodes which correspond to individual HTTP request under these sequence folders. Like the \u201cSaved Transactions\u201d entries, the \u201cTransaction Sequence\u201d entries persist until they are deleted by the user.","\u201cAll Transactions,\u201d \u201cCurrent Transactions,\u201d and \u201cSave Transactions\u201d nodes have \u201cDelete all transactions,\u201d \u201cDelete current transactions,\u201d and \u201cDelete saved transactions\u201d actions, respectively. Invoking the \u201cDelete all transactions\u201d action on the \u201cAll Transactions\u201d node deletes all transaction entries and removes all nodes from the GUI . Invoking \u201cDelete current transactions\u201d action on \u201cCurrent Transactions\u201d deletes all current transactions and removes the \u201cCurrent Transactions\u201d node from the GUI 22. Invoking \u201cDelete saved transactions\u201d action on \u201cSaved Transactions\u201d deletes all saved transactions and removes the \u201cSaved Transactions\u201d node from the GUI . The \u201cTransaction sequences\u201d node has two actions: \u201cDelete all sequences\u201d and \u201cCreate new sequence.\u201d The former action deletes all sequence folders and the records they contain and removes the \u201cTransaction sequences\u201d node from the GUI . The latter brings up a dialog with a text field where the user enters the name of the new sequence. The dialog provides the user with the option to specify whether the sequence records transactions. If the sequence is set to record transactions, then for each newly executed transaction, a node representing the request associated with the transaction is added to the sequence folder, and a node representing all the transaction data is added to the \u201cCurrent transactions\u201d folder.","Individual transaction nodes in the \u201cCurrent Transactions\u201d subcategory have six actions: \u201cDisplay,\u201d \u201cSave,\u201d \u201cCopy Request to Sequence,\u201d \u201cReplay,\u201d \u201cEdit and Replay,\u201d and \u201cDelete.\u201d In the \u201cSaved Transactions\u201d subcategory, the individual transaction nodes have five actions: \u201cDisplay,\u201d \u201cCopy Request to Sequence,\u201d \u201cReplay,\u201d \u201cEdit and Replay,\u201d and \u201cDelete.\u201d In one implementation, the list of actions available under each transaction category is displayed in a pop-up menu  when the user right-clicks on a transaction. The \u201cCopy Request to Sequence\u201d action brings up a dialog (not shown) where the user can select or create a sequence folder (under the \u201cTransaction Sequence\u201d node) into which to copy an HTTP request. The \u201cReplay\u201d action causes the original HTTP request to be re-processed by the execution server ( in ), as described in U.S. patent application Ser. No. 09\/789,238, supra. The \u201cEdit and Replay\u201d action brings up a dialog, such as dialog  in , which allows the user to modify the HTTP request data prior to causing it to be re-processed by the execution server ( in ). As shown in , the user can use the tabs  to change Headers, Request, Query, and Server parameters. After making changes, the user can click the \u201cSend transaction\u201d button  to replay the edited transaction or the \u201cCancel\u201d button  to cancel the changes and exit the dialog.","Returning to , the sequence folders under the \u201cTransaction sequence\u201d node are represented by icons which have a badge that indicates whether new transactions have their HTTP requests recorded into the sequence or not. The sequence nodes have the following actions: \u201cToggle request recording,\u201d \u201cReorder,\u201d \u201cRename,\u201d \u201cReplay sequence (step),\u201d \u201cReplay sequence (to end),\u201d and \u201cDelete.\u201d \u201cToggle request recording\u201d determines whether HTTP requests from incoming HTTP transaction records are added to the sequence or not. \u201cReorder\u201d brings up a dialog (not shown) which shows a list of the HTTP request nodes inside the sequence and allows the user to move individual nodes up or down. \u201cRename\u201d allows the user to give the sequence folder a different name. \u201cReplay sequence\u201d causes the HTTP requests described by each sequence folder to be replayed one at a time in sequence. With \u201cReplay sequence (step),\u201d the output from each request is shown before moving on to the next request. With \u201cReplay sequence (to end),\u201d only the output of the last request is shown. To execute the sequence, a thread is started which attempts to execute each request in order, waiting for one to succeed before executing the next one. Each individual request will have a timeout, which can be some default number or can be set by the user. If any individual request fails, the output of that request is displayed to the user, and the user is notified of the problem. Otherwise the output of the last request in the sequence is displayed. The \u201cDelete\u201d action causes the sequence folder and the nodes below it to be deleted.","Unlike the leaf nodes under \u201cCurrent Transactions\u201d and \u201cSaved Transactions\u201d which represent an entire transaction, the leaf nodes under the sequence node represent individual HTTP requests. These nodes have the following actions: \u201cEdit,\u201d \u201cRename,\u201d \u201cReplay,\u201d and \u201cDelete.\u201d \u201cRename\u201d allows the user to change the name of the node. \u201cReplay\u201d allows the individual HTTP request to be resent. \u201cDelete\u201d deletes the request node. \u201cEdit\u201d brings up a dialog, such as dialog  in . Dialog  is similar to the \u201cEdit and Replay\u201d dialog  (shown in ), except that the \u201cSend transaction\u201d button ( in ) has been replaced with a \u201cSave\u201d button . After the user edits the HTTP request, the user clicks the \u201cSave\u201d button  to save the changes or the \u201cCancel\u201d button  to cancel the changes and exit the dialog.","The right pane includes a display component  having six tabs, collectively indicated at . For a transaction selected on the left pane , the six tabs  display the data collected by the server component ( in ) according to the categories shown in Table 1 above. The six tabs  have the labels \u201cRequest,\u201d \u201cCookies,\u201d \u201cSession,\u201d \u201cServlet and Server,\u201d \u201cClient,\u201d and \u201cHeaders,\u201d respectively. The \u201cRequest\u201d tab displays the request and response parameters for a selected transaction. The HTTP headers associated with the request are displayed separately in the \u201cHeaders\u201d tab. The \u201cCookies\u201d tab displays attributes of incoming and outgoing cookies for a selected transaction. The \u201cSession\u201d tab displays the session status before and after executing the selected transaction. The \u201cServlet and Server\u201d tab displays the servlet and server properties when the selected transaction was executed. The \u201cClient\u201d tab displays properties of the client making the request for the selected transaction.",{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIG. 4","FIG. 1"],"b":["22","6","6","22","6","22","22","6","6","6"]},{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIG. 5","FIG. 1"],"b":["16","49","10","10","49","17","49","49","57","23","23","20","17","23","19","20","20","17","49","23","49","17","15","49","17","15","49"],"sub":"13 "},"The data collector  intercepts the incoming request  and collects data about the request. The collected data includes information about the client making the request, the session state before the transaction, incoming cookies, properties of servlets and servlet engine running on the execution server , and all the request data except the exit status (see Table 1 above). After collecting data, the data collector  yields control to the execution server . The execution server  invokes a servlet  to process the request. The servlet  generates a response . After generating the response , the data collector  intercepts the response  and collects data about the response . The collected data includes information about the session state after the transaction, outgoing cookies, and the exit status of the response . The data collector  then notifies the client-side component ( in ) by sending a POST request  to the servlet ( in ). The POST request includes the recorded transaction data in xml format. The data collector  then yields control to the request player , which simply allows the response  to leave the execution server  without modification.","In one implementation, the request player  and data collector  rely on hooks on the execution server  to intercept incoming requests before and after the requests are processed. For the Tomcat web server, the \u201cRequestInterceptor\u201d API is used to intercept HTTP requests and responses, one for the data collection functionality and the other for the replay request functionality. The Tomcat web server is an open-source software project jointly run by Apache Software Foundation and Sun Microsystems Inc. The \u201cRequestInterceptor\u201d API provides hooks for invoking methods before and after the HTTP request is processed. The data collector  uses the \u201cpreService\u201d method of one instance of the \u201cRequestInterceptor\u201d API to invoke methods which record data about the client, the session state before the transaction, the servlet properties data, incoming cookies, and all the request data except the exit status. The data collector  also uses the \u201cpostService\u201d method of the same instance of the \u201cRequestInterceptor\u201d API to invoke methods which record outgoing cookies, session data after the transaction, and the exit status. The request player  uses the \u201cpreService\u201d method of another instance of the \u201cRequestInterceptor\u201d API to intercept incoming requests, looking for query strings matching, for example, \u201cffj_resend.\u201d The invention is not limited to the Tomcat web server, but may be implemented on any web server having an in-process or out-of-process servlet engine (also called servlet runner or web container).","In another implementation, hooks in a server plug-in on the execution server  are used to intercept HTTP requests and responses. For example, the \u201cFilter\u201d API, as described in the version 2.3 of the Java\u2122 Servlet specification, could be used for the same purpose as the \u201cRequestInterceptor\u201d API.","For the developer, the process of developing a web application involves, among other tasks, testing each dynamic web component (in the case of a Java\u2122 application, each JSP\u2122 and servlet) to see that it performs the correct processing and generates the appropriate output. This involves executing individual web components, and also sequences of components as they would be traversed by a user who browses the web site.","Referring to , it is assumed that the web application to be tested has been developed, for example, using an IDE such as IDE . It is further assumed that the developer is using the IDE  to test-run and debug the web application. The contents of the web application is displayed in a GUI  that is included in the IDE . The developer can select a resource, e.g., JSP\u2122 page or servlet or other component, in the web application and ask the IDE  to execute the resource. For example, in , a JSP\u2122 page called \u201cinput\u201d has been selected. To display the page, the IDE  sends an HTTP request to the execution server ( in ). The output of the execution server ( in ), i.e., the HTTP response, is displayed in the browser  which is integrated into the IDE .","Referring to , the first thing that happens when the execution server  receives an HTTP request is that the request player  examines it to see if it is a replay request. If the request is a replay request, the request player requests for the transaction file from servlet  and modifies the request with the transaction data. If the request is not a replay request, the request player  does not modify the request. Instead, the request player  yields control to the data collector . The data collector  then intercepts the request and collects data about the request. After collecting the data, control is returned to the execution server , and the execution server  processes the request. If the functionality is implemented using hooks in a server plug-in (as opposed to the execution server itself), control is yielded to the server plug-in. The execution server  invokes a servlet (not shown) generated from the JSP\u2122 page with the data that came in with the HTTP request. After processing, the execution server  sends the response page back to the browser ( in ). Before the response page is sent to the browser , the data collector  collects data on the response, and then yields control back to the execution server . After collecting data, the data collector  notifies the servlet  of the new transaction. The servlet  in turn notifies the GUI  (through the client controller ) to update its transaction list. The GUI  interacts with the client controller  to get the updated transaction data from the directory .","Using the data collected by the data collector , the developer can examine through the GUI  the attributes of requests coming into the execution server  and attributes and data states of the processing servlet itself before and after the request is processed. If a problem arises, the developer can easily find the source of the problem by examining the transaction data between the browser ( in ) and the server . If a particular request for a resource is one that the developer wants to make regularly throughout the development phase, for instance, in order to verify that the web application continues to work as intended after changes have been made, then the corresponding HTTP transaction can be saved. This allows the developer to replay the transaction during future IDE sessions. The developer can also use the save functionality in case they wish to defer fixing a problem to a later date. The transaction or transactions corresponding to the requests that reproduce the problem can be saved, giving the developer the opportunity to examine and replay them during a future IDE session. The request player  thus saves the developer the trouble of repeatedly accessing the web application resources through a web browser (as a user of the web application would), including reducing the need to fill in HTML forms to generate requests. Because the data collector  records data both for regular and replayed requests, it is easy to compare the results from one test-run to another.","The server-side component  intercepts all requests sent to the execution server , not just requests that are initiated from the IDE . This means that if the machine on which the execution server  is running is networked, then the server-side component  could process HTTP requests from clients on other machines. This feature can be useful in the testing phase. Suppose that a test engineer has identified a way of entering data into a web application that causes a problem for one of the dynamic components. Then the web developer could start up the execution server  with the server-side component . The test engineer can then, on his or her own machine, point a web browser to the host and port of the execution server  to access the web application and enter the data that reproduces the problem. The web developer can then use the client-side component  to examine what happened with the request and replay it as needed from the developer's own computer.","All HTTP requests that the sever-side component  intercepts, whether they originated from the IDE , from the client-side component  (as a replay request), or from another client, are available to the web developer to replay. With reference to the scenario described in the previous paragraph, suppose that the test engineer accessed two resources in the web application, one for a form and one for submitting the data from the form, resulting in two HTTP transactions on the \u201cCurrent Transactions\u201d lists. It is the second transaction, i.e., the one for submitting the data from the form, that will be associated with the bug. The web developer could first replay the second transaction to find out what is going wrong. Then the web developer could make changes to the web application with the aim to fix the problem. After making the changes, the web developer can then replay the same transaction again, this time to confirm that the bug has been fixed. Replaying the transaction saves the web developer from repeatedly loading the form corresponding to the first request and manually entering the data.","Except for the simplest web applications, there will be dynamic resources that are such that they cannot be invoked in isolation. These resources are such that their execution involves processing some condition, and certain output pages are only generated if the conditions are met. The conditions are typically met by executing other resources in such as way that some type of data becomes available to the resource. The background section listed the dynamic resources that generate pages that are part of a checkout process as an example of this behavior. In this case, the dynamic resource that generates the first form of the checkout process would typically generate a page with an information message instead if the user's virtual shopping cart is empty and so on.","Suppose that the developer is aware of a bug that manifests itself part way into the checkout process. In order to reproduce the problem the first time, the developer has to enter data through actual generated web pages. After attempting to fix the problem, the user will then need to verify the fix by reproducing the same HTTP requests again (and again if the first attempt fails). Repeating the process of entering data through the web site is often very time consuming. Using the tool the developer can use the replay feature to manually repeat individual HTTP requests, which saves some time but which can still be inefficient if number of steps to reach the desired state is high. Using the invention described in this application, however, the developer can set up the whole sequence to be replayed.","There are two ways of setting up the sequence. If the transactions corresponding to the requests have already been recorded, the developer can select \u201cCreate new sequence\u201d from the \u201cTransaction Sequences\u201d folder and then select the relevant transactions and use the \u201cCopy request into sequence\u201d action. Alternatively, the developer can create a sequence folder prior to attempting to reproduce the problem and configure the tool to record requests into the sequence. The developer then accesses the web application as a user and enters the data needed to reproduce the problem. Then the recording feature of the sequence is turned off. Now the developer can start working on the problem, and whenever the developer wishes to see if the fix works, the developer can replay the sequence. Thus, the invention benefits the developer (or user) by removing the need to repeatedly move through a sequence of pages to reproduce a problem and verify attempts to fix the problem.","While the invention has been described with respect to a limited number of embodiments, those skilled in the art, having benefit of this disclosure, will appreciate that other embodiments can be devised which do not depart from the scope of the invention as disclosed herein. Accordingly, the scope of the invention should be limited only by the attached claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
