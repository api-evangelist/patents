---
title: Motion control systems
abstract: A motion control system comprising an application program, a plurality of motion controllers, a set of software drivers, and a motion component. Each software driver exposes a service provider interface comprising a set of driver functions. Driver code of at least one software driver associates at least one driver function with at least one control command. The motion component exposes an application programming interface comprising a set of component functions and component code associates at least one of the component functions with at least one of the driver functions. The at least one selected software driver generates at least one control code from the motion controller language associated with the at least one selected motion controller based on the at least one component function called by the application program, the component code, and the driver code of the at least one selectable software driver.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08073557&OS=08073557&RS=08073557
owner: ROY-G-BIV Corporation
number: 08073557
owner_city: Bingen
owner_country: US
publication_date: 20090318
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND OF THE INVENTION","PRIOR ART","OBJECTS OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","I. Method of Generating Control Commands for Controlling a Motion Control Device to Move an Object","II. Motion Control Component","III. Software Drivers","IV. Streams","V. Driver Stub Module","VI. Driver Administrator Module","VII. Driver Administrator CPL Applet","VIII. Driver Administrator CPL Applet","IX. Language Driver","EXAMPLE 1","EXAMPLE 2","EXAMPLE 3","EXAMPLE 4"],"p":["This application Ser. No. 12\/406,921 is a continuation of U.S. patent application Ser. No. 10\/316,451 filed on Dec. 10, 2002, which is incorporated herein in its entirety.","U.S. patent application Ser. No. 10\/316,451 is a continuation-in-part of U.S. patent application Ser. No. 10\/021,669 filed on Dec. 10, 2001, now U.S. Pat. No. 6,516,236 which issued on Feb. 4, 2003, which is incorporated by reference in its entirety and which is a continuation of U.S. patent application Ser. No. 09\/191,981 filed on Nov. 13, 1998, which is a continuation of U.S. patent application Ser. No. 08\/656,421 filed on May 30, 1996, now U.S. Pat. No. 5,867,385 which issued on Feb. 2, 1999, which is a continuation-in-part of U.S. patent application Ser. No. 08\/454,736 filed on May 30, 1995, now U.S. Pat. No. 5,691,897 which issued on Nov. 25, 1997.","U.S. patent application Ser. No. 10\/316,451 is also a continuation-in-part of U.S. patent application Ser. No. 09\/795,777 filed on Feb. 27, 2001, now U.S. Pat. No. 6,513,058 which issued on Jan. 28, 2003, which is incorporated by reference in its entirety and which is a continuation of U.S. patent application Ser. No. 09\/205,627 filed on Dec. 3, 1998, now U.S. Pat. No. 6,209,037 which issued on Mar. 27, 2001, which claims benefit of U.S. Provisional Patent Application Ser. No. 60\/067,466 filed on Dec. 4, 1997, and which is a continuation of U.S. patent application Ser. No. 09\/191,981 filed on Nov. 13, 1998, which is a continuation of U.S. patent application Ser. No. 08\/656,421 filed on May 30, 1996, now U.S. Pat. No. 5,867,385 which issued on Feb. 2, 1999, which is a continuation-in-part of U.S. patent application Ser. No. 08\/454,736 filed on May 30, 1995, now U.S. Pat. No. 5,691,897 which issued on Nov. 25, 1997.","U.S. patent application Ser. No. 10\/316,451 is also a continuation-in-part of U.S. patent application Ser. No. 09\/633,633 filed on Aug. 7, 2000, now U.S. Pat. No. 6,941,543 which issued on Sep. 6, 2005, which is incorporated by reference in its entirety and which is a continuation of U.S. patent application Ser. No. 09\/191,981 filed on Nov. 13, 1998, which is a continuation of U.S. patent application Ser. No. 08\/656,421 filed on May 30, 1996, now U.S. Pat. No. 5,867,385 which issued on Feb. 2, 1999, which is a continuation-in-part of U.S. patent application Ser. No. 08\/454,736 filed on May 30, 1995, now U.S. Pat. No. 5,691,897, which issued on Nov. 25, 1997.","The present invention relates to motion control systems and, more particularly, to interface software that facilitates the creation of hardware independent motion control software.","The purpose of a motion control device is to move an object in a desired manner. The basic components of a motion control device are a controller and a mechanical system. The mechanical system translates signals generated by the controller into movement of an object.","While the mechanical system commonly comprises a drive and an electrical motor, a number of other systems, such as hydraulic or vibrational systems, can be used to cause movement of an object based on a control signal. Additionally, it is possible for a motion control device to comprise a plurality of drives and motors to allow multi-axis control of the movement of the object.","The present invention is of particular importance in the context of a mechanical system including at least one drive and electrical motor having a rotating shaft connected in some way to the object to be moved, and that application will be described in detail herein. But the principles of the present invention are generally applicable to any mechanical system that generates movement based on a control signal. The scope of the present invention should thus be determined based on the claims appended hereto and not the following detailed description.","In a mechanical system comprising a controller, a drive, and an electrical motor, the motor is physically connected to the object to be moved such that rotation of the motor shaft is translated into movement of the object. The drive is an electronic power amplifier adapted to provide power to a motor to rotate the motor shaft in a controlled manner. Based on control commands, the controller controls the drive in a predictable manner such that the object is moved in the desired manner.","These basic components are normally placed into a larger system to accomplish a specific task. For example, one controller may operate in conjunction with several drives and motors in a multi-axis system for moving a tool along a predetermined path relative to a workpiece.","Additionally, the basic components described above are often used in conjunction with a host computer or programmable logic controller (PLC). The host computer or PLC allows the use of a high-level programming language to generate control commands that are passed to the controller. Software running on the host computer is thus designed to simplify the task of programming the controller.","Companies that manufacture motion control devices are, traditionally, hardware oriented companies that manufacture software dedicated to the hardware that they manufacture. These software products may be referred to as low level programs. Low level programs usually work directly with the motion control command language specific to a given motion control device. While such low level programs offer the programmer substantially complete control over the hardware, these programs are highly hardware dependent.","In contrast to low-level programs, high-level software programs, referred to sometimes as factory automation applications, allow a factory system designer to develop application programs that combine large numbers of input\/output (I\/O) devices, including motion control devices, into a complex system used to automate a factory floor environment. These factory automation applications allow any number of I\/O devices to be used in a given system, as long as these devices are supported by the high-level program. Custom applications, developed by other software developers, cannot be developed to take advantage of the simple motion control functionality offered by the factory automation program.","Additionally, these programs do not allow the programmer a great degree of control over the each motion control device in the system. Each program developed with a factory automation application must run within the context of that application.","In the following discussions, a number of documents are cited that are publicly available as of the filing date of the present invention. With many of these documents, the Applicant is not aware of exact publishing dates. The citation of these documents should thus not be considered an admission that they are prior art; the Applicant will take the steps necessary to establish whether these documents are prior art if necessary.","As mentioned above, a number of software programs currently exist for programming individual motion control devices or for aiding in the development of systems containing a number of motion control devices.","The following is a list of documents disclosing presently commercially available high-level software programs: (a) Software Products For Industrial Automation, iconics 1993; (b) The complete, computer-based automation tool (IGSS), Seven Technologies A\/S; (c) OpenBatch Product Brief, PID, Inc.; (d) FIX Product Brochure, Intellution (1994); (e) Paragon TNT Product Brochure, Intec Controls Corp.; (f) WEB 3.0 Product Brochure, Trihedral Engineering Ltd. (1994); and (g) AIMAX-WIN Product Brochure, TA Engineering Co., Inc. The following documents disclose simulation software: (a) ExperTune PID Tuning Software, Gerry Engineering Software; and (b) XANALOG Model NL-SIM Product Brochure, XANALOG.","The following list identifies documents related to low-level programs: (a) Compumotor Digiplan 1993-94 catalog, pages 10-11; (b) Aerotech Motion Control Product Guide, pages 233-34; (c) PMAC Product Catalog, page 43; (d) PC\/DSP-Series Motion Controller C Programming Guide, pages 1-3; (e) Oregon Micro Systems Product Guide, page 17; (f) Precision Microcontrol Product Guide.","The Applicants are also aware of a software model referred to as WOSA that has been defined by Microsoft for use in the Windows programming environment. The WOSA model is discussed in the book Inside Windows 95, on pages 348-351. WOSA is also discussed in the paper entitled WOSA Backgrounder: Delivering Enterprise Services to the Windows-based Desktop. The WOSA model isolates application programmers from the complexities of programming to different service providers by providing an API layer that is independent of an underlying hardware or service and an SPI layer that is hardware independent but service dependent. The WOSA model has no relation to motion control devices.","The Applicants are also aware of the common programming practice in which drivers are provided for hardware such as printers or the like; an application program such as a word processor allows a user to select a driver associated with a given printer to allow the application program to print on that given printer.","While this approach does isolates the application programmer from the complexities of programming to each hardware configuration in existence, this approach does not provide the application programmer with the ability to control the hardware in base incremental steps. In the printer example, an application programmer will not be able to control each stepper motor in the printer using the provided printer driver; instead, the printer driver will control a number of stepper motors in the printer in a predetermined sequence as necessary to implement a group of high level commands.","The software driver model currently used for printers and the like is thus not applicable to the development of a sequence of control commands for motion control devices.","From the foregoing, it should be clear that one primary object of the invention is to provide improved systems and methods for moving objects.","The present invention may be embodied as a motion control system comprising an application program, a plurality of motion controllers, a set of software drivers each comprising driver code, and a motion component comprising component code. The application program comprises at least one call to at least one component function. Each of the motion controllers is capable of causing a motion control operation. A plurality of motion controller languages are associated with the plurality of motion controllers. Each motion controller language comprises control commands, where at least one control command is capable of processing information associated with the movement of an object. At least one of the plurality of motion controller languages is associated with at least one of the motion controllers. Each software driver is associated with at least one of the plurality of motion controller languages. Each software driver exposes a service provider interface comprising a set of driver functions, where the driver functions are independent of the plurality of motion controller languages. At least one driver function is an extended driver function that is associated with a non-primitive motion operation that can be performed using at least one primitive motion operation, where the at least one primitive motion operation cannot be performed using a combination of primitive or non-primitive motion operations. At least one driver function is a core driver function that is associated with a primitive motion operation. The driver code of at least one software driver associates at least one driver function with at least one control command of the at least one motion controller language associated with at least one of the software drivers. At least one selected software driver is associated with at least one selected motion controller. The motion component exposes an application programming interface comprising a set of component functions. Each component function is implemented by component code. At least the component code is independent of the plurality of motion controller languages. The component code associates at least one of the component functions with at least one of the driver functions. The at least one selected software driver generates at least one control code from the motion controller language associated with the at least one selected motion controller based on the at least one component function called by the application program, the component code, and the driver code of the at least one selectable software driver.","The present invention may also be embodied as a motion control system comprising an application program comprising at least one call to at least one component function, a plurality of motion control devices, a set of software drivers each comprising driver code, and a motion component comprising component code. A plurality of unique controller languages are associated with the plurality of motion control devices. Each controller language comprises control commands for processing information associated with motion control devices. Each of the motion control devices comprises a controller capable of generating electrical signals based on at least one control command of the controller language associated with the motion control device and a mechanical system capable of causing a motion control operation based on electrical signals generated by the controller. Each software driver is associated with one of the plurality of controller languages. Each software driver exposes a service provider interface defining a set of driver functions. The driver functions are independent of the plurality of controller languages. At least one driver function is an extended driver function that is associated with a non-primitive motion operation that can be performed using at least one primitive motion operation, where the at least one primitive motion operation cannot be performed using a combination of primitive or non-primitive motion operations. At least one driver function is a core driver function that is associated with a primitive motion operation. The driver code of at least one software driver associates at least one driver function with at least one control command of the at least one controller language associated with at least one of the software drivers. At least one selected software driver is associated with at least one selected motion control device. The motion component exposes an application programming interface comprising a set of component functions. Each component function is implemented by component code. At least the component code is independent of the plurality of controller languages. The component code associates at least one of the component functions with at least one of the driver functions. The at least one selected software driver generates a set of control commands in the controller language associated with the at least one selected motion control device based on the calls to component functions of the application program, the component code, and the driver code of the at least one selected software driver.","The present invention may also be embodied as a motion control system comprising an application program comprising at least one call to at least one component function, a plurality of motion controllers, a set of software drivers each comprising driver code, and a motion component comprising component code. Each of the motion controllers is capable of causing a motion control operation. The plurality of sets of hardware control commands are associated with the plurality of motion controllers. Each set of hardware control commands comprises at least one control command that is capable of processing information associated with the movement of an object. At least one of the plurality of sets of hardware control commands is associated with each of the motion controllers. Each software driver is associated with one of the plurality of sets of hardware control commands. At least one selected software driver is associated with at least one selected motion controller. Each software driver exposes a service provider interface defining a set of driver functions. The driver functions are independent of the plurality of sets of control commands. At least one driver function is an extended driver function that is associated with a non-primitive motion operation that can be performed using a combination of primitive motion operations, where primitive motion operations cannot be performed using a combination of primitive or non-primitive motion operations. At least one driver function is a core driver function that is associated with a primitive motion operation. The driver code of at least one software driver associates at least one driver function with at least one control command of the at least one set of hardware control commands associated with at least one of the software drivers. The motion component exposes an application programming interface comprising a set of component functions. Each component function is implemented by component code. At least the component code is independent of the plurality of controller languages. The component code associates at least one of the component functions with at least one of the driver functions. The at least one selected software driver generates a sequence of control commands from the set of control commands associated with the at least one selected controller based on the calls to component functions of the application program, the component code, and the driver code of the at least one selected software driver.","Referring now to the drawing, depicted therein at  in  is a motion control system constructed in accordance with, and embodying, the principles of the present invention. This system  comprises a personal computer portion  having a hardware bus , a plurality of motion control hardware controllers , , and , and mechanical systems , , and that interact with one or more objects (not shown) to be moved.","The personal computer portion  of the system  can be any system capable of being programmed as described herein, but, in the preferred embodiment, is a system capable of running the Microsoft Windows environment. Such a system will normally comprise a serial port in addition to the hardware bus  shown in .","The hardware bus  provides the physical connections necessary for the computer  to communicate with the hardware controllers . The hardware controllers  control the mechanical system  to move in a predictable manner. The mechanical system  comprises a motor or the like the output shaft of which is coupled to the object to be moved. The combination of the hardware controllers , , and and the mechanical systems , , and forms motion control devices , , and , respectively.","The hardware bus , hardware controllers , and mechanical systems  are all well-known in the art and are discussed herein only to the extent necessary to provide a complete understanding of the present invention.","The personal computer portion  contains a software system  that allows an application user  to create software applications  that control the motion control devices .","More particularly, based on data input by the user  and the contents of the application program , the software system  generates control commands that are transmitted by one or more streams such as those indicated at , , , and . The streams  transmit control commands incorporating the hardware specific command language necessary to control a given motion control device to perform in a desired manner. As will be discussed in more detail below, the streams  implement the communication protocol that allows the control commands to reach the appropriate motion control device  via an appropriate channel (i.e., PC bus, serial port).","Using the system , the application program  is developed such that it contains no code that is specific to any one of the exemplary hardware controllers . In the normal case, the application program , and thus the user  that created the program , is completely isolated from the motion control devices . The user  thus need know nothing about the hardware specific command language or communication protocol associated with each of these devices ; it may even be possible that the command language of one or more of the hardware controllers  was not defined at the time the application program  was created.","The software system  comprises a combination of elements that allow the application program  to be completely isolated from the hardware controllers . In the following discussion, the framework of the software system  will be described in terms of a method of moving an object and\/or a method of generating control commands. After this general discussion, each component of the system  will be described in detail in a specific operating environment.","Initially, it should be noted that, in most situations, the method described in this section will normally but not necessarily involve the labors of at least two and perhaps three separate software programmers: a software system designer; a hardware designer familiar with the intricacies of the motion control device; and a motion control system designer. The application user  discussed above will normally be the motion control system designer, and the roles of the software system designer and hardware designer will become apparent from the following discussion.","The software system designer develops the software system . The software system designer initially defines a set of motion control operations that are used to perform motion control. The motion control operations are not specifically related to any particular motion control device hardware configuration, but are instead abstract operations that all motion control device hardware configurations must perform in order to function.","Motion control operations may either be primitive operations or non-primitive operations. Primitive operations are operations that are necessary for motion control and cannot be simulated using a combination of other motion control operations. Examples of primitive operations include GET POSITION and MOVE RELATIVE, which are necessary for motion control and cannot be emulated using other motion control operations. Non-primitive operations are motion control operations that do not meet the definition of a primitive operations. Examples of non-primitive operations include CONTOUR MOVE, which may be emulated using a combination of primitive motion control operations.","Given the set of motion control operations as defined above, the software system designer next defines a service provider interface (SPI) comprising a number of driver functions. Driver functions may be either core driver functions or extended driver functions. Core driver functions are associated with primitive operations, while extended driver functions are associated with non-primitive operations. As with motion control operations, driver functions are not related to a specific hardware configuration; basically, the driver functions define parameters necessary to implement motion control operations in a generic sense, but do not attach specific values or the like to these parameters. The SPI for the exemplary software system  is attached hereto as Appendix A.","The software system designer next defines an application programming interface (API) comprising a set of component functions. For these component functions, the software system designer writes component code that associates at least some of the component functions with at least some of the driver functions. The relationship between component functions and driver functions need not be one to one: for example, certain component functions are provided for administrative purposes and do not have a corresponding driver function. However, most component functions will have an associated driver function. The API for the exemplary software system  is attached hereto as Appendix B.","The overall software model implemented by the software program  thus contains an API comprising component functions and an SPI comprising driver functions, with the API being related to the SPI by component code associated with the component functions.","In order for the system  to generate the control commands, at least two more components are needed: the application program  and at least one software driver such as the drivers indicated at , , and in .","The software drivers  are normally developed by a hardware designer and are each associated with a single motion control device. The hardware designer writes driver code that dictates how to generate control commands for controlling the motion control device associated therewith to perform the motion control operations associated with at least some of the driver functions.","In the exemplary software system , the software drivers , , and are associated with the motion control devices , , and , respectively. As a software driver exists for each of the motion control devices , , and , these devices , , and form a group of supported motion control devices.","A careful review of the framework of the software system  as described above will illustrate that, of all the components of this system , only the software drivers  are hardware dependent.","The motion control system designer, normally also the user , develops the application program . The application program  comprises a sequence of component functions arranged to define the motion control operations necessary to control a motion control device to move an object in a desired manner. The application program  is any application that uses the system  by programming the motion control component . Applications may program the system  either through OLE Automation or by using any of the custom OLE interfaces making up the API.","As mentioned above, the component code associates many of the component functions with the driver functions, and the driver functions define the parameters necessary to carry out the motion control operations. Thus, with appropriately ordered component functions, the application program  contains the logic necessary to move the object in the desired manner.","Once the application program  has been written and the software drivers  have been provided, the user  selects at least one motion control device from the group of supported motion control devices , , and . Using a driver administrator module , the user  then selects the software driver associated with the selected motion control device. This driver administrator module  is used to install, uninstall, register, and setup each stream.","As currently implemented, the driver administrator  allows only one software driver to be selected. In future versions of the software system , the driver administrator will allow the user to select one or more software drivers.","The software system  thus generates control commands based on the component functions contained in the application program , the component code associated with the component functions, and the driver code associated with the selected software driver .","As the control commands are being generated as described above, they may be directly transmitted to a motion control device to control this device in real time or stored in an output file for later use. The software system  employs the streams  to handle the transmission of the control commands to a desired destination thereof.","In the exemplary system , the destinations of the control commands may be one or more of an output file  and\/or the controllers . Other possible destinations include a debug monitor or window or other custom output mechanism defined for a specific situation. The software system designer, or in some cases the hardware system designer, will write transmit stream code for each stream  that determines how the control commands are to be transferred to a given one of the control command destinations  and . Using the driver administrator , the user  selects one or more of the control command destinations  and , and, later when run, the system  transfers the control commands to the selected control command destination  and\/or  based on the transmit stream code in the stream  associated with the selected control command destination  and\/or .","Many control command destinations such as  and  are capable of transmitting data back to the system . Data transmitted from a control command destination back to the system  will be referred to as response data. The software system designer thus further writes data response stream code for each of the streams , , and that determines how response data is transmitted from the controllers  to the system . The system  thus processes the response data sent by the controllers  based on the data response stream code contained in the streams .","Referring again to , this Figure shows that the system  further comprises a motion control component  and a driver stub module . The motion control component module  is the portion of the software system  that relates the component functions to the driver functions. The motion control component module  thus contains the component code that makes the association between the component functions contained in the application program  and the driver functions.","The driver stub module  is not required to implement the basic software model implemented by the system , but provides the system  with significantly greater flexibility to accommodate diverse motion control hardware configurations with minimal effort.","More particularly, when the driver stub module  is employed, the hardware designer need not develop driver code to implement all of the driver functions; to the contrary, the hardware designer must write driver code for implementing the core driver functions but need not write driver code to implement the extended driver functions. The software system designer provides the motion control driver stub  with stub code that identifies the combinations of core driver functions that are employed to emulate the functionality of extended driver functions.","The motion control component  will determine for the selected software driver  which extended functions, if any, the selected driver  supports. For extended functions that are not supported, referred to herein as non-supported extended driver functions, the motion control component  refers to the driver stub module  to determine the appropriate combination of core driver functions to emulate the functionality of the non-supported extended driver functions. The system  thus generates the control commands necessary to implement the non-supported extended driver functions using the appropriate combination of core driver functions.","The process of determining when extended driver functions need to be emulated can be optimized by providing the motion control component  with a function pointer table that contains a pointer to each of extended functions. When building the function pointer table, the motion control component  checks the selected driver module  to see if it supports each extended function. If the selected driver module  supports the extended function, the motion control component module  stores a pointer to the function, implemented by the selected driver module , in the table location corresponding to the extended function. In the event that the selected driver module  does not support the extended function, the motion control component module  stores a pointer to the extended function implementation located in the driver stub module . The driver stub module  implementation of the extended function contains calls to a plurality of core functions implemented by the selected driver module .","Therefore, the driver stub module  allows the motion control system designer to use, with minimal time and effort by the hardware designer, a working software driver  that contains driver code to implement only the core functions. The software driver  developed to implement the core driver functions can then be improved by developing driver code to implement extended driver functions as desired.","The use of driver code specifically designed to implement extended driver functions is, in general, preferable to relying on the driver stub module  to emulate the extended driver functions; driver code specifically written to implement an extended driver function will almost always obtain a more optimized implementation of the driver function than the emulation of that driver function with a combination of core driver functions.","Referring again for a moment to , this Figure illustrates that the system  additionally comprises a driver administrator CPL applet  and a DDE server . The driver administration CPL applet  generates the user interface through which the user  communicates with the driver administrator module . The DDE server  provides the software interface through which the application program  communicates with the motion control component module .","The motion control component  will now be described in further detail with reference to . The motion control component  is used by every application programming the system  to perform motion control operations. The major set of the API is implemented by this component. When operating, the motion control component  interacts with the driver administrator , to get the current driver, and the driver  and driver stub , to carry out motion control operations. Applications, using system , only interact with the motion control component .","This section describes the design of the motion control component  in three main parts. First, all binary modules that affect the component  are described along with their interactions with the component . Next, the module interaction-map is drawn in more detail to show the interactions between all C++objects used to implement the motion control component . Next, the object interaction-map is tested by displaying the specific interactions that take place during certain, key process that the component  is requested to perform.","The module interaction-map shown in  displays all binary modules and their interactions with the motion control component . As can be seen from the module interaction-map, applications only communicate with the motion control component . From this point, the component  coordinates all interactions between the driver administrator , driver , and driver stub  components.","Breaking the module interaction-map and adding the interactions taking place between all C++ objects used to implement the motion control component , produces the object interaction-map shown in .","Each object in the diagram is described as follows. The CCmpntDisp object is the dispatch object used to dispatch exposed interface methods. During the dispatch process, all raw data is converted into the appropriate C++ form. For example, collections of data passed between OLE components is usually packaged in a raw block of memory. The CCmpntDisp object takes care of packing outgoing data and unpacking incoming data. Data packing involves converting the data between a raw and native C++ format.","The CDriverAdmin object is used to communicate directly with the driver administrator component. All OLE related details are encapsulated within this class.","The CDriverMgr object is used to control all unit mapping taking place before calling the appropriate Driver function. The CUnitMapper object is used to do the actual mapping between units.","The CUnitMapper object is used to map units between the Part Coordinate System (PCS) and the Machine Coordinate System (MCS). Both directions of unit mapping are done by this object.","The CDriver object is used to build the SPI table containing both core and extended Driver functions. Depending on the level of driver support, the extended functions in the SPI table may point to functions implemented in either the driver stub  or the driver .","The following discussion of  describes all main scenarios, or operations, that occur on the motion control component . Each scenario-map displays all objects involved, and the interactions that take place between them in the sequence that they occur.","As shown in , before an application can use the motion control component , it must create an instance of the object, using the CoCreateInstance OLE function, and then initialize the instance calling the exposed Initialize custom interface method implemented by the component .  displays the sequence of events that take place when the Initialize method is called.","During initialization, the following steps occur. First the application must create an instance of the motion control component  by calling the standard OLE function CoCreateInstance. Once loaded, the application must call the component 's exposed Initialize method. When first loaded, the component  loads any registration data previously stored. Next, the component  directs the CCmpntDisp to initialize the system. The CCmpntDisp directs the CDriverAdmin to get the current driver(s) to use. The CDriverAdmin, first, loads the driver administrator  using the standard OLE CoCreateInstance function. Next, it initializes the driver administrator. Then, it queries the driver administrator for the driver(s) to use and their SPI support information. Finally, the driver administrator returns the driver(s) and the support information to the component , and releases all interfaces used from the driver administrator component .","Once receiving the active driver(s)  and their support information, the motion control component  passes the driver(s)  to the CDriverMgr and directs it to initialize the system During its initialization, the CDriverMgr initializes the CUnitMapper. Also while initializing, the CDriverMgr initializes a CDriver for each driver used. After initializing each CDriver, the support information is used to build each SPI table inside each CDriver object. When building the SPI table, all core and supported extended SPI interfaces are queried from the driver. Also, when building the SPI table, the CDriver queries all interfaces, not supported by the driver , from the driver stub .","Referring now to , once the motion control component  is initialized, the application  may perform operations on it. There are two types of operations that may take place on the component : Operations that use core Driver functions, and operations that use extended Driver functions. Even though the difference between the two is completely invisible to the application using the component , the internal interactions are different between the two. The following discussion outline these differences.","The following interactions take place when the component  performs an operation that uses core Driver functions only. First the application must request the operation and pass all pertinent parameters to the component . Next, the component  directs the CCmpntDisp to carry out the operation. The CCmpntDisp then directs the CDriverMgr to perform the operation and passes all pertinent parameters to it. Before carrying out the operation, the CDriverMgr uses the CUnitMapper to convert all units to the Machine Coordinate System (MCS). Next, the CDriverMgr directs the CDriver object to carry out the operation and passes the newly mapped parameters to it. The CDriver object uses its internal SPI table to communicate directly with the core Driver function implemented by the driver component.",{"@attributes":{"id":"p-0107","num":"0106"},"figref":"FIG. 6","b":["35","30"]},"First the application must request the operation and pass all pertinent parameters to the component . Next, the component  directs the CCmpntDisp to carry out the operation. The CCmpntDisp then directs the CDriverMgr to perform the operation and passes all pertinent parameters to it. Before carrying out the operation, the CDriverMgr uses the CUnitMapper to convert all units to the Machine Coordinate System (MCS). Next, the CDriverMgr directs the CDriver object to carry out the operation and passes the newly mapped parameters to it. The CDriver object uses its internal SPI table to communicate directly with the core Driver function implemented by the driver component.","As briefly discussed above, when using the system , there are several types of units and two different coordinate systems used. The process of unit mapping involves converting measurements between the Part and Machine coordinate systems.  illustrates this process, and the following steps occur when the operation is requested.","First the application must request the operation and pass all parameters to the component . Note, all parameters are in the PCS. Next, the component  directs the CCmpntDisp to carry out the operation. The CCmpntDisp directs the CDriverMgr to carry out the operation and passes the PCS parameters to it. The CDriverMgr takes all measurements and uses the CUnitMapper to convert them to the MCS. The newly mapped parameters are then passed to the Cdriver. The CDriver directs either the driver or the driver stub component to carry out the operation.","When the application is finished using the motion control component  it directs the component  to free all of its resources by calling its exposed Release method. This process is depicted in . During the clean-up process, the following steps occur.","First the application must direct the component  to release all of its resources by calling its Release method. When invoked, the component  passes the call on to the CCmpntDisp object. The CCmpntDisp object directs the CDriverMgr to release any resources it is using. The CDriverMgr directs each CDriver object to release any of its resources, then deletes the CDriver objects. First, the CDriver object releases any interfaces it is using from the driver component. Then, the CDriver object releases any interfaces it is using from the driver stub component.",{"@attributes":{"id":"p-0113","num":"0112"},"figref":["FIG. 9","FIG. 10"],"b":["35","35"]},"The driver  is used by both the driver administrator  and the component . Its main purpose is to implement functionality that generates motion control commands for the specific hardware supported. For example, the AT6400 driver, used to control the Compumotor AT6400 motion control hardware, generates AT6400 command codes. During the initialization phase of the system , the driver administrator  communicates with each driver , allowing the user to add, remove, or change the configuration of the driver. When an application, using the system , is run, the component  communicates with the driver  directing it to carry out the appropriate motion control operations.","This section describes the complete design of a generic driver . All drivers are designed from the base design described in this manual. This section is divided into three parts. First, a module interaction-map that describes all binary modules that interact with the driver  is discussed. Next, the module interaction-map is drawn as an object interaction-map, where all the internals of the driver are exposed. In this map, all C++ objects, making up the driver, and their interactions are shown. Next, several scenario-maps are drawn. Each scenario-map displays the interactions taking place between the C++ objects involved during a certain process. Finally, this section describes the interfaces exposed by the driver component, all data structures used, and the definitions of each C++ class used.","Referring now to , the module interaction-map displays all binary modules and their interactions with the driver . There are two modules that interact directly with the driver: the motion control component , and the driver administrator . The driver administrator  queries and changes the driver settings and the component  directs the driver to carry out motion control operations, such as moving to a certain location in the system. Shown at  in  is the standard Windows registration database, referred to herein as the registry.","Breaking the module interaction-map down into more detail by including the interactions taking place between all C++ objects used to implement the driver, produces the object interaction-map. The object interaction-map for the driver  is shown in .","Each object in the diagram is described as follows.","CDriverDisp is the dispatch object used to dispatch exposed interface methods. During the dispatch process, all raw data is converted into the appropriate C++ form. For example, collections of data passed between OLE components is usually packaged in a raw block of memory. The CDriverDisp object takes care of packing outgoing data and unpacking incoming data. Data packing involves converting the data between a raw and native C++ format.","The CStreamMgr object is responsible for managing the set of streams registered with the driver. Streams, may be added, removed, and enabled. Only enabled streams are sent data. The CLSID and enabled status of each stream registered, is stored in the registration database. When communicating to streams, the CStreamMgr is used to send the command string to all enabled streams.","The CCommandMgr object is used to build commands sent to the stream, and extracting responses received from the stream. The CCommandMgr is the controlling object that manages the CResponse, CCommandList, and CStream objects.","The CCommandList object stores the complete list of commands making up the motion control command language. Such commands may be stored as text resources or in a text file.","The CCommand object builds command strings that are then sent to the CStream. Each command built is a complete motion control command string.","The CResponseList object builds CResponse objects that are initialized with the parsing format for the expected response.","The CResponse object converts raw response strings, returned by the CStream, and converts them into C++ data types. For example, a response string containing position data may be converted into a set of double values.","The CStream object is used to communicate directly with the underlying stream component.",{"@attributes":{"id":"p-0127","num":"0126"},"figref":"FIGS. 14-20","b":"30"},"There are two types of operations that occur on the driver . First, the driver administrator  may initiate operations, such as adding streams or configuring the driver. Next, the motion control component  may initiate operations on the driver when an application is actually running. The following discussion describes each perspective, starting with the operations directed by the Driver Administrator; all operations made on the driver by the driver administrator are discussed in the order that they may occur when using the driver.","Before a driver may be used, it must be registered in the OLE system. In order to register a driver the driver administrator first verifies that the module being registered is actually an driver , then it calls the DLLRegisterServer exported function to register the driver. Each module of the system  exports a function called DLLGetModuleType. This function is used to verify that the module is an driver  component.  displays the interactions that take place when registering a driver.","During the registration process shown in , the following steps occur. First, the driver administrator must load the DLL, containing the stream component, verify that the module is an driver . To do so, the driver administrator calls the DLLGetModuleType function, exported by the driver. If the function returns a value that contains the value XMC_DRIVER_MT in the high byte, then the driver administrator proceeds and registers the driver by calling its exported function, DLLRegisterServer. When called, the implementation of the DLLRegisterServer writes all OLE 2.0 registration information to the Windows registration database.","Referring now to , after the driver is registered, the driver administrator can load the component  using the OLE CoCreateInstance function. During the initialization process, the driver loads all registration data and initializes both the CDriverDisp and CStreamMgr C++ objects.","During initialization, the following steps occur.","Before loading the driver component, the driver administrator must query the driver module for its CLSID. Calling the driver's exported function, DLLGetCLSID, returns the CLSID. Once it has the CLSID, the driver administrator may create an instance of the driver by calling the standard OLE function CoCreateInstance. When first loaded, the driver loads any registration data previously stored. Next, the driver directs the CDriverDisp object to initialize the system. When notified, the CDriverDisp object initializes itself and then directs the CStreamMgr to initialize itself. During its initialization, the CStreamMgr loads all stream settings from the registration database. For example, the CLSID and enabled state of all streams previously registered with the driver, are loaded.","After initializing the driver, the driver administrator may perform operations on it. For example, the driver administrator may request the driver to add or remove a stream.  displays the sequence of events occurring when the driver is requested to add a new stream. When adding a stream, the following steps occur.","First the driver administrator directs the stream to add a new stream and passes CLSID of the stream, to be added, to the driver. The driver then passes the CLSID to the CDriverDisp object and directs it to add the stream. The CDriverDisp object passes the information on to the CStreamMgr and directs it to add the stream. In the final step, the CStreamMgr assumes that the module is a valid stream component  and adds the CLSID to the drivers set of information in the registration database.","Another operation requested of the driver, after initialization, is that of querying it for its current settings. Before displaying information about the driver, like the name of the hardware it supports, the driver administrator must query the driver for the information. For example,  displays the process of querying the driver for an enumeration of the streams registered with it. When querying the driver for information, the following steps occur.","First the driver administrator, calls the interface method used to query the driver's stream enumeration. Next, the driver directs the CDriverDisp to create the stream enumeration. The CDriverDisp object then directs the CStreamMgr to prepare the stream enumeration. The CStreamMgr checks the registration database and makes sure its internal state is in sync with the data stored in the registry. Next, it sets a lock that will cause all stream management operations, such as adding or removing streams, to fail. The CStreamMgr prepares the list of streams and loads them into memory using the CStream object. The CStream object loads the stream component using the OLE CoCreateInstance API.","After the driver administrator is done using the driver, it must release the driver by calling its exposed Release method. Calling this method, directs the driver to release all resources used.  displays the process of releasing the driver component. During the clean-up process, the following steps occur.","First the driver administrator must direct the driver component to clean itself up by calling its Release method. When invoked, the driver component passes the call on to the CDriverDisp object. The CDriverDisp object then directs the CStreamMgr to save all data. The CStreamMgr saves all data, including the state of each stream, in the registration database. Finally, the driver saves all internal data in the registration database.","After a driver is successfully installed into the system  and configured using the driver administrator, it is ready for use by the motion control component . The component  uses the driver  when performing motion control operations requested from the application using the component . The following discussion describes the component  directed operations that can take place on the driver.","Before using the driver, it must be initialized by the component . This operation is different from the driver initialization taking place on the driver when used by the driver administrator because the system must be prepared for sending and receiving commands. In order to prepare for the data communication, the stream must be initialized and then opened.  describes the initialization process. The following steps occur during the initialization process.","First the component  must direct the driver to initialize itself. This is usually a two step process. In the first step, the component  creates and instance of the driver using the standard OLE CoCreateInstance function, Next, the Initialize method, exposed by the driver, is called to prepare the driver for data transmissions. When the Initialize method is called, the driver first loads any internal data stored in the registration database . Next, the driver directs the CDriverDisp to initialize the internal system. The CDriverDisp then directs the CStreamMgr to initialize the streams. Next, the CStreamMgr loads all data from the registration database, including the set of all CLSID's and enabled status' for all streams registered with the driver. Then the CStreamMgr loads each enabled stream by creating a new CStream object for each enabled stream. When creating each CStream object, the CLSID for the underlying stream is passed to the CStream object. When each CStream object is created and attached to a stream component it loads the component  by calling the standard OLE CoCreateInstance function. Once the CStreamMgr is done, the CDriverDisp directs the CCommandMgr to initialize itself. During its initialization process, the CCommandMgr initializes and loads the CCommandList. Also, when the CCommandMgr is initializing, it loads the CResponseList corresponding to the CCommandList.","Once the system is initialized, the motion control component  can direct the driver to carry out certain command operations. Command operations are standard motion control operations such as moving to a specific location in the system, or querying the system for the current position.  describes the process of commanding the driver to carry out a certain operation. When commanding the driver to perform a certain operation the following steps occur.","First, the component  directs the driver to perform the operation, such as moving to a position or querying the system for the current position. Next, the driver directs the CDriverDisp object to perform the operation. The CDriverDisp object then directs the CCommandMgr to build the appropriate command. Any parameters related to the command are passed to the CCommandMgr. For example, when directing the driver to move to a certain position, the position information is passed to the CCommandMgr. Next, the CCommandMgr requests the CResponseList to create a CResponse object. The CResponseList looks up the response format and uses it to create a new CResponse object that is returned to the CCommandMgr. Then, the CCommandMgr directs the CCommandList to create the command. Any parameters related to the command are passed to the CCommandList. The CCommandList creates a new CCommand object, looks up the raw command string, and passes it and the command parameters to the CCommand object who then builds the command string.","The CCommandMgr, then passes the CCommand object, returned by the CCommandList, and the previously created CResponse object to the CStreamMgr object. The CStreamMgr object is directed to process the objects. The CStreamMgr passes the CCommand and CResponse objects to all enabled CStream objects. The CStream object queries the CCommand object for the full command string in raw text form. The raw text command is passed to the stream component. Next, the CStream object waits for the response, then reads the raw text response into a buffer. The raw text response is then passed to the CResponse object. Next the CRETONNE object is returned to the CStreamMgr, who returns it to the CCommandMgr, who returns it to the CDriverDisp object. Eventually the CResponse returns to the CDriverDisp object, who then directs the CResponse to convert the response into a generic C++ type. The generic type is returned to the motion control component .","Once the component  is finished using the driver, the driver must be released by calling its Release method. Releasing the driver frees all resources used by the driver.  describes the process of releasing the driver. The following steps occur when cleaning up and freeing all resources used by the driver.","First, the component  must call the driver's Release method. When called, the driver directs the CDriverDisp object to release any resources used. The CDriverDisp then directs the CStreamMgr to free any resources used. The CStreamMgr then frees all active CStream objects. Each CStream object releases all stream component interfaces used. Next the CDriverDisp directs the CCommandMgr to free all of its resources. During its clean-up, the CCommandMgr frees the CCommandList object. To complete its clean-up, the CCommandMgr frees the CResponseList object.","Attached hereto as Appendix D is a document that describes the actual OLE Interfaces exposed, the definitions of the data structures used when passing data around, and the definitions of each class used internally by the driver.","This section describes the stream component  used as the data transport layer between the driver  component and the destination output location such as the motion control device  and\/or the output file . For example, when using motion control hardware that is connected to the PC Bus, the driver  Component will communicate with the PC Bus stream component .","The design of a stream component  will be discussed in three parts. First, a Module Interaction-Map describes the modules that are involved, with respect to the stream, and how they interact with one another. Next, the Object Interaction-Map breaks the Module Interaction-Map down into a more detailed view that not only displays the interactions occurring between modules, but also the interactions taking place between the C++ objects within the stream component . Then, the Object Interaction-Map is \u201ctested\u201d by running it through several Scenario-Maps. Each Scenario-Map displays the object interactions taking place during a certain operation.","The Module Interaction-Map shown in  displays all modules that interact with the stream component . Interactions begin from two different perspectives. First, the driver administration  interacts with the stream component  when installing, removing, and configuring the stream. Next, when used, each driver  interacts with the stream while sending and retrieving data to and from the destination. For example, when a driver writes data to a text file stream, the stream takes care of writing the data out to the file. Or, if the driver reads data from a PC Bus stream, the stream does the actual read from the hardware and passes the data back to the driver.","Drivers only communicate with streams that have been specifically connected to the driver. Once connected, the stream is used to communicate with the destination object, like the PC Bus, serial I\/O connection, text file, or debug monitor.","The stream component  shown in  is the object that operates as the data transport layer for each driver. Each stream has a different target that defines the type of the stream. The following are the current stream targets.\n\n","Similar to the Module Interaction-Map, the Object Interaction-Map displays interactions between modules. In addition, this map, shows all interactions taking place between each C++ object within the stream component .  is the Object Interaction-Map for the stream component .","Each object in the diagram is described as follows. The CStreamDisp object is the dispatch object used to dispatch exposed interface methods. During the dispatch process, all raw data is converted into the appropriate C++ form. For example, collections of data passed between OLE components is usually packaged in a raw block of memory. The CStreamDisp object takes care of packing outgoing data and unpacking incoming data. Data packing involves converting the data between a raw and native C++ format.","The CRegistryMgr object takes care of managing all data stored in the registration database. Since many streams of the same type may exist at the same time, each stream is assigned a handle. The handle assigned, is used by the stream to look up the location it uses to load and store data in the registration database, much as an library index is used to locate a library book.","All input and output is funnelled through the CIOMgr manager. Management of input and output operations consists of buffering data and controlling primitives used to transport data to and from the target location.","The CIOHAL object is the input\/output hardware abstraction layer. With in this object lay all hardware dependent code such as calls to inp and outp. Each different type of stream contains a different implementation of this object.","Scenario-Maps are specialized Object Interaction-Maps that display how each module and the objects inside the stream component interact with one another during the operation described by the map. The Scenario-Maps in  are broken into two different categories; those that are initiated by the driver administrator , and those that are initiated by the driver .","Operations directed by the driver administrator are usually related to initializing, uninitializing, and configuring the stream. The following sections describe all operations, directed by the driver administrator, that take place on the stream.","Before a stream component can be used by anyone, it must be registered in the Windows registration database. Registration is a standard OLE 2.0 operation required in order to use any OLE 2.0 component, such as the stream component.  describes this process. During the registration process, the following steps occur.","First, the driver administrator must load the DLL, containing the stream component, verify that the module is an stream component . To do so, the driver administrator calls the DLLGetModuleType function, exported by the stream. If the high byte in the return value contains the value XMC_STREAM_MT, then the driver administrator proceeds and registers the stream by calling its exported function, DLLRegisterServer. When called, the implementation of the DLLRegisterServer writes all OLE 2.0 registration information to the Windows registration database.","After the stream component is successfully registered, it is ready for initialization. During initialization, the stream component not only initializes itself, but also initializes any device drivers used by registering the driver with the operating system. For example, the Windows NT stream component registers the Windows NT .SYS driver with Windows NT and starts the service.  describes this process. During initialization, the following steps occur.","First the driver administrator must direct the stream to initialize itself. When making this call, the name and location of the driver used, and the handle of the stream are passed into the method as arguments. Once directed to initialize itself, the stream component calls the CStreamDisp and directs it to initialize the system. The CStreamDisp object then directs the CRegistryMgr to load all pertinent data for the stream using the handle passed to it. The CRegistryMgr loads all data from the registration database. After all information is loaded from the registry, the CStreamDisp directs the CIOMgr to register the appropriate driver with the operating system. The CIOMgr directs the CIOHAL to register the driver, if appropriate. If running in Windows NT, the CIOHAL registers the .SYS driver with the Windows NT operating system and starts the driver. If running in Windows 95, the VxD integrity is verified with a quick, dynamic, load and unload.","After initializing the stream component, it may be queried for its current settings or directed to set new settings. Since both operations are very similar, only changing settings will be described. Stream settings include data such as: port addresses, IRQ levels, file names, etc. Any data needed to communicate with the output\/input target are included in the stream settings.  describes the process of changing the streams settings. During the setup process, the following steps occur.","First the driver administrator directs the stream to use the data passed to change its internal data. Once directed, the stream component passes the interface method invocation to the CStreamDisp object. The CStreamDisp object then directs the CRegistryMgr to store the new settings. The CRegistryMgr stores the new values in the registration database.","When the driver administrator is done using a stream component, it must clean up the resources used.  describes this process. During the clean-up process, the following steps occur. First the driver administrator must direct the stream component to clean itself up by calling its Release method. When invoked, the stream component passes the call on to the CStreamDisp object. The CStreamDisp object then directs the CRegistryMgr to save all data. All persistent data is saved to the registration database by the CRegistryMgr.","Driver directed operations occur when each driver  uses the stream component  connected to it. Remember, each stream component is used as the data transport layer. Each driver uses the stream to transfer the motion control command data, it generates, to the output target. Streams are also used to transfer data back to the driver when read operations occur. Only certain streams are readable.","Before the driver can perform operations on the stream, the stream must be initialized. Initialization occurs in two steps. First the OLE stream component must be loaded, and then once it is, the stream must be explicitly initialized.  describes the second portion of the initialization process. The following steps occur during the initialization process.","First the driver must invoke the Initialize methods exported by one of the stream interfaces. When calling Initialize, the driver passes to the stream, the stream handle. Next, the stream passes the directive on to the CStreamDisp object for dispatching. The CStreamDisp object first directs the CRegistryMgr to load all settings stored in the location defined by the stream handle. The CRegistryMgr reads in the data stored in the registry at the handle. After the data is loaded, the CStreamDisp, directs the CIOMgr to initialize itself. As part of its initialization, the CIOMgr initializes the CIOHAL object that it is using.","Once a stream has been initialized, it must be opened. Opening a stream places the stream in a state where it can pass data between the driver and the target.  describes the process of opening a stream. When opening a stream, the following steps occur.","First the driver directs the stream to open itself, by calling the Open exposed interface method. Once directed, the stream passes the call on to the CStreamDisp object. Next, the CStreamDisp object directs the CIOMgr to open the stream. At this time, the CIOMgr prepares any buffers that will later be used when transferring data through the stream. After the buffers are ready, the CIOMgr directs the CIOHAL object to interact with the target and open it. CIOHAL directly communicates with the target or with a device driver and opens the stream. When operating with hardware streams, the device driver, or Serial IO directly communicates with the hardware and prepares it for operation.","After opening a stream, it is ready to perform data transport operations. There are two main data transport operations available: Reading data, and writing data.  describes the process of writing data to the stream. When writing to the stream, the following steps occur. First the driver directs the stream to write data to the target and passes the data to the stream. Next, the stream passes the data to the CStreamDisp object. The CStreamDisp object passes the block of data to the CIOMgr and directs it to write it to the target. The CIOMgr object either passes the complete block of data to the CIOHAL object, or stores the block in an internal buffer and then passes pieces of the buffer to the CIOHAL object until the complete buffer is sent. The CIOHAL object takes the data passed to it and either sends it directly to the target, passes it to a device driver, or calls COMM API to send the data to the Serial IO port. The device driver or COMM API sends the data directly to the hardware controlled.","Certain streams, like the PC Bus and Serial IO streams, return data after write operations occur on them. The data returned may be specific to a previous request for data, or status describing the success or failure of the previous write operation.  describes the process of reading data from the stream. It should be noted that not all streams are readable. Currently, the only readable streams are the PC Bus and Serial streams. During the operation of reading data from the target, the following steps occur.","First the driver directs the stream to read data from the target. The stream passes the call on to the CStreamDisp object. The CStreamDisp object directs the CIOMgr to perform the read. Depending on how the stream is implemented, the CIOMgr may either make one call or multiple calls to the CIOHAL object. If multiple calls are made, all data read is stored in CIOMgr internal buffers. The CIOHAL object either directly communicates to the hardware, uses the COMM API, or a device driver to read the data. If a device driver or the COMM API are used, they directly communicate with the hardware to read the data.","Once the driver is done using the stream, it must direct the stream to clean-up all resources used. To do so, the driver calls the standard Release method.  displays the sequence of events taking place after the Release method is called. The following steps occur when cleaning up and freeing all resources used by the stream.","First the driver must call the stream's Release method. Next, the stream directs the CStreamDisp object to release all resources used. The CStreamDisp object then directs the CIOMgr to free any resources used in buffers, etc. Next, the CIOMgr directs the CIOHAL to free any resources used. During its clean-up and depending on the type of stream, the CIOHAL will delete text files used, close the debug monitor, shut-down the hardware, or direct any device drivers to shut-down the hardware. If device drivers or the COMM API are used, they direct the hardware to shut-down.",{"@attributes":{"id":"p-0178","num":"0184"},"figref":"FIG. 33","b":"28"},"The driver stub module  is used to fill in the extended Driver functions that the driver  is unable to support or implement. By simulating the extended SPI, applications are able to use a larger set of motion control functionality than would be available if the application directly programmed the motion control hardware. In order to implement the extended SPI, the driver stub uses software algorithms that call core SPI interface methods implemented by the driver . During the initialization of the driver stub, the driver  to use is registered with the driver stub.","This section describes all aspects of the driver stub  in three basic parts. The first part of this section describes all binary modules affecting the driver stub. Next, a more detailed view, that includes all C++ objects used inside the driver stub, is described. Then several processes that take place on the driver stub are described.","The module interaction-map displays all binary modules and their interactions with the driver stub . As can be seen from , the driver stub is used by the component . More or less, the driver stub acts as a helper to the component  by filling in all extended Driver functionality possible.","By taking the module interaction-map in  and displaying all interactions taking place with all C++ objects implementing the driver stub, we produce what is called the object interaction-map.  is the object interaction-map for the driver stub  component.","Each object in the diagram is described as follows.\n\n","The following discussion describes all main scenarios, or operations, that occur on the driver stub . Each scenario-map displays all objects involved, and the interactions that take place between them in the sequence that they occur. All operations on the driver stub originate from the motion control component . In addition to the motion control component , the XMC Setup Component interacts with the driver stub when installing the system . It should be noted that all scenarios below assume that the driver stub  has already been registered in the OLE system. Registering this component is the responsibility of the setup application and setup component.","This discussion describes all operations made on the driver stub by the motion control component . Each section is discussed in the order that they may occur when using the driver.","As shown in , before using the driver stub , the motion control component  must initialize it by creating an instance of the driver stub, and then initializing the instance created. Calling the standard OLE function CoCreateInstance completes the first step. After an instance is created, the component  must call the driver stub exposed Initialize interface method. During initialization, the following steps occur.","The component creates an instance of the driver stub by calling the standard OLE function CoCreateInstance. Once loaded, the CLSID of the driver to use is passed to the driver stub when calling its Initialize exposed interface method. When first loaded, the driver loads any registration data previously stored. Next, the component  passes the CLSID, of the driver to use, to the CDriverStubDisp object and directs it to initialize the system. The CDriverStubDisp object then directs the CSPIMgr to initialize itself and passes the driver CLSID to it. The CSPIMgr passes the CLSID to the CSimpleDriver and directs it to only query the core SPI interfaces exposed by the driver. The CSimpleDriver loads an instance of the driver then queries all core interfaces exposed by the driver.","Once the driver stub is initialized, it is ready to perform operations such as performing extended Driver functions.  describes the steps that occur when the component  directs the driver stub to perform an extended SPI operation. The following steps occur when the operation is requested.","First the component  must request the operation and pass all pertinent parameters to the driver stub. Next, the driver stub directs the CDriverStubDisp to handle the operation. The CDriverStubDisp then directs the CSPIMgr to perform the SPI extended function and passes the appropriate XMC_EXT_SPI identifier as a parameter. The CSPIMgr calls the appropriate function corresponding to the XMC_EXT_SPI identifier. The function simulates the extended Driver function and calls the CSimpleDriver for core operations. When directed, the CSimpleDriver performs SPI core functions by directly calling the exposed interfaces implemented by the driver.","When the motion control component  is finished using the driver stub , it must release it by calling the exposed Release method. Calling the Release method causes the driver stub to free all the resources it uses.  displays this sequence of events. During the clean-up process, the following steps occur.","First the component  must direct the driver stub to release all of its resources by calling its Release method. When invoked, the driver component passes the call on to the CDriverStubDisp object. The CDriverStubDisp object then directs the CSPIMgr to release any resources that it was using. The CSPIMgr releases all resources including the CSimpleDriver object used. When freed, the CSimpleDriver releases any interfaces used from the driver.",{"@attributes":{"id":"p-0192","num":"0201"},"figref":"FIG. 39","b":"36"},"The driver administrator  is used from two different perspectives. When the driver administrator Control Panel Applet  is used to configure the system, the applet directs the driver administrator  to carry out the operations. The applet  simply provides the user-interface, and the component  does the real work of managing drivers and streams used with the system . Using the driver administrator component with the control panel applet is the first perspective on using the component .","In the second perspective, the motion control component  uses the driver administrator component to query for the current set of enabled the driver . It should be noted that, currently, only single driver operation is allowed. Clearly, the system  may support multiple drivers that are virtualized. For example, if two, four axis, drivers are installed, applications using the system could act as though they were using an eight axis system.","This section describes the driver administrator  in three main parts. First, all modules interacting with the driver administrator component are described along with their interactions. Next, the module interaction-map is expanded to display all interactions taking place between the C++ objects used to implement the driver administrator  Component. This description is called the object interaction-map. Then, the object interaction-map is tested by running it through several scenarios, or scenario-maps. Each scenario-map displays the events and the order in which they occur in a certain process taking place on the driver administrator component.","The module interaction-map shown in  displays all binary modules and their interactions with the driver administrator  Component. Both the driver administrator CPL  and the motion control component  are the main modules that interact with the driver administrator  Component.","The driver administrator CPL module  provides the user-interface that allows the user to add, configure, and remove drivers and streams in the system . The driver administrator  handles all driver and stream management. Even though the control panel applet provides the user-interface, this module  does the actual management work.","In addition, the driver administrator is used by the component  to access the current driver(s) to use when carrying out motion control operations. For example, if the AT6400 driver is selected as the current driver when the component  queries the driver administrator, the driver administrator returns the CLSID of the AT6400 driver.","Taking the driver administrator , displayed in the module interaction-map, and displaying all interactions occurring between the C++ objects used to implement the administrator , produces the object interaction-map therefor. The object interaction-map for the driver administrator  is shown in .","Each object in the diagram is described as follows.","The CDriverAdminDisp object is the dispatch object used to dispatch exposed interface methods. During the dispatch process, all raw data is converted into the appropriate C++ form. For example, collections of data passed between OLE components is usually packaged in a raw block of memory. The CDriverAdminDisp object takes care of packing outgoing data and unpacking incoming data. Data packing involves converting the data between a raw and native C++ format.","The CDriverInfoMap object is used to build the information used by the driver administrator CPL  when displaying information about each driver or stream.","The CModuleMgr object is responsible for managing all stream and driver modules in the system. A list of all drivers registered are stored persistently in the registration database by the CModuleMgr. Each time a driver or stream is accessed the CModuleMgr is used to get the module.","The CSimpleDriver object is used to directly communicate with the driver component. All OLE specific details are encapsulated within this object.","The CSimpleStream object is used to directly communicate with the stream component. All OLE specific details are encapsulated within this object.",{"@attributes":{"id":"p-0206","num":"0215"},"figref":"FIGS. 42-49","b":"32"},"Referring now to , before using the driver administrator component, it must be initialized.  describes the process of initializing the driver administrator component from either the driver administrator control panel applet or the motion control component. During initialization, the following steps occur.","First, either the control panel applet or the motion control component must create an instance of the driver administrator component by calling the standard OLE function CoCreateInstance. Next, the exposed Initialize interface method must be called. When the Initialize method is called, the driver administrator component directs the CDriverAdminDisp to initialize the system. Next, the CDriverAdminDisp directs the CModuleMgr to initialize itself and any modules that it is managing. The CModuleMgr, first, loads all information from the registration database. Then for each driver registered, the CModuleMgr creates an instance of the driver by calling the standard OLE function CoCreateInstance. Next, the CModuleMgr calls each drivers Initialize method, passing to the method the CLSID of the driver component to attach. The CSimpleDriver attaches to the driver component by calling the standard OLE function CoCreateInstance.","The driver administrator  can register both drivers and streams. Registering drivers is very direct, since the driver administrator manages the drivers registered in the system. Registering streams, on the other hand, is more complex, since each stream must be registered with a driver and the driver manages the streams registered with it, not the driver administrator. The following discussion describes the process of registering both drivers and streams.","Registering a driver entails verifying that the module is actually a driver, verifying that the driver can be loaded, and storing the driver information in a persistent location.  describes this process. When registering a driver, the following steps occur.","First, the driver administrator CPL passes the name of the driver and directs the driver administrator component to register it. Next, the driver administrator component passes the driver name to the CDriverAdminDisp and directs it to register the module. The CDriverAdminDisp directs the CModuleMgr to register the new driver. The CModuleMgr creates a new CSimpleDriver and requests it to register the driver. First the CSimpleDriver verifies that the driver is valid by calling its DLLGetModuleType exported function. If the function returns XMC_DRIVER_MT the CSimpleDriver then calls the driver's exported function DLLRegisterServer to register the module in the OLE system. Next the CLSID is queried from the module by calling its exported DLLGetCLSID function. The CLSID returned is then used to load the driver by calling the standard OLE function CoCreateInstance. If the CSimpleDriver is successful, the CModuleMgr stores the driver CLSID in the registration database.","Registering a stream is similar to registering a driver, but a little more complex, since each stream must be registered with a specific driver.  displays the process of registering a stream. When registering a stream, the following steps occur.","First, the driver administrator CPL passes the CLSID of the driver and the filename of the stream to register with the driver, to the driver administrator component. The driver administrator component directs the CDriverAdminDisp to register the stream. The CDriverAdminDisp object directs the CModuleMgr to register the stream and passes the CLSID of the driver and the name of the stream along to it. First, the CModuleMgr verifies that the CLSID of the driver one of the registered drivers. If it is not, the driver is registered as discussed above.","Next, the CModuleMgr creates a new CSimpleStream object and directs it to verify and load the stream component. The CSimpleStream first verifies that the module is actually an stream component  by calling its exported DLLGetModuleType function. If the function returns XMC_STREAM_MT, the CSimpleStream continues and registers the stream component by calling its DLLRegisterServer exported function. Finally, the CSimpleStream object queries the new module for its CLSID by calling the module's exported DLLGetCLSID function. The new CLSID is used, by the CSimpleStream, to load the stream component using the standard OLE function CoCreateInstance. If the CSimpleStream succeeds, the CLSID of the stream is passed along to the CSimpleDriver who is directed to register the stream. The CSimpleDriver passes the CLSID to the driver component and directs it to register the stream.","The following discussion describes setting information in either a driver or stream. When the user edits information in the driver administrator control panel applet , the applet  directs the driver administrator  to edit the settings for the stream or driver being edited. The following discussion describes how this configuration process works.","Editing the settings of a driver takes place when the user changes the driver settings displayed in the driver administrator CPL. Changing these settings causes the process described in  to occur within the driver administrator component. The following steps occur when setting the driver configuration.","When driver settings are changed in the CPL , the driver administrator CPL directs the driver administrator component to make the appropriate changes to the driver corresponding to the driver handle. A XMC_DRIVER_INFO structure is passed to the component , describing the new values for the driver. The driver administrator component takes the XMC_DRIVER_INFO structure and the handle to the driver and passes the information to the CDriverAdminDisp object, directing it to change the settings in the driver. The CDriverAdminDisp object directs the CModuleMgr to edit the driver corresponding to the driver handle. The CModuleMgr locates the CSimpleDriver with the handle and directs it to change its settings to those stored in the XMC_DRIVER_INFO structure. The CSimpleDriver passes the XMC_DRIVER_INFO structure to the driver component and directs it to change its settings.","As shown in , when the user edits stream settings in the driver administrator CPL , the following steps occur.","After the user changes settings for the stream in the CPL, the driver administrator CPL directs the driver administrator component to change the stream's settings and passes a handle to the driver containing the stream, a handle to the stream, and a XMC_STREAM_INFO structure describing the new values. The driver administrator component directs the CDriverAdminDisp object to change the streams settings. The CDriverAdminDisp object directs the CModuleMgr to change the settings of the stream corresponding to the handle.","First, the CModuleMgr locates the driver corresponding to the driver handle. Next, it requests the CSimpleDriver to change the settings for the stream corresponding to the stream handle. The CSimpleDriver searches for the stream corresponding to the stream handle and directs it to change its settings to those stored in the XMC_STREAM_INFO structure. The CSimpleStream directly communicates with the stream component and directs it to change its settings to those in the XMC_STREAM_INFO structure.","There are two different types of information that may be queried from the driver administrator : the enumeration of all drivers registered, and the driver information map. The motion control component  uses the driver enumeration when selecting the set of drivers to use and control during motion control operations. The driver information map, on the other hand, is used by the driver administrator CPL  to update the user-interface display describing all drivers and streams registered in the system. The following discussion describes the process of querying for both the driver enumeration and the driver information map. Querying for the driver enumeration occurs during the initialization of the motion control component . When initializing, the component  must know what drivers to use when performing motion control operations. The driver administrator  Component is used for that very purpose. Querying the driver enumeration just returns a pointer to the IXMC_EnumDriver interface exposed by the driver administrator  Component.  displays the events that occur when using the interface to get each driver in the enumeration. Using the interface causes, the following steps occur.","First, the motion control component  queries the driver administrator  Component for the next driver. Next, the driver administrator  Component directs the CDriverAdminDisp to get the next driver supported. The CDriverAdminDisp directs the CModuleMgr to get the next driver. The CModuleMgr then directs the CSimpleDriver to either return the CLSID or a pointer to the IUnknown interface for the driver, depending on the parameters of the enumeration. If the CSimpleDriver is requested to return a pointer to the IUnknown interface, the interface is queried from the driver component.","Another set of information that may be queried from the driver administrator  consists of the driver information map. This data is used by the driver administrator CPL  when displaying information describing the drivers and streams registered in the system. As shown in , when querying the system for the driver interface map, the following steps occur.","First, the driver administrator CPL  queries the driver administrator  Component for the current driver information map. When queried, the driver administrator component directs the CDriverAdminDisp to create and load a CDriverInfoMap class. The CDriverAdminDisp creates the CDriverInfoMap. Next, the CDriverAdminDisp passes the CDriverInfoMap to the CModuleMgr and directs it to load the information map. The CModuleMgr queries each driver registered for its internal information. Each CSimpleDriver communicates directly with the driver component and queries it for all pertinent driver information. Next, the CModuleMgr queries each driver for a list of all streams registered with the driver. Using the stream enumeration, each CSimpleDriver creates an array of CSimpleStream objects and returns the array to the CModuleMgr. For each CSimpleStream object in each array, the CModuleMgr queries for all pertinent stream information. Each CSimpleStream communicates directly with the stream component and queries it for all information describing the stream.","After the driver administrator CPL  or the motion control component  are finished using the driver administrator , they must release the component  to free any resources it was using.  describes this process. When cleaning up after a call to the Release method, the following steps occur.","First, either the driver administrator CPL  or the motion control component  must direct the driver administrator  Component to release itself by calling its Release method. Next, the driver administrator component directs the CDriverAdminDisp object to free all resources used in the system. The CDriverAdminDisp then directs the CModuleMgr to free any resources that it is using. First, the CModuleMgr traces through all CSimpleDriver objects, querying each for their CLSID and enabled state. Next, each CSimpleDriver is freed. Each CSimpleDriver object freed, frees all arrays of CSimpleStream objects registered with it. When freed, each CSimpleStream object releases all interfaces that it was using from the stream component. In its final clean-up, each CSimpleDriver releases all interfaces that it was using from the driver component. All CLSID and enabled state information is stored persistently in the registration database.",{"@attributes":{"id":"p-0227","num":"0236"},"figref":"FIG. 50","b":["32","32"]},"This document describes the design of the driver administrator control panel applet  (CPL) that is used by the user to add, configure, and remove both drivers  and stream components  later used by the component  when directed to carry out motion control operations. With regard to design, there are three main types of \u201cviews\u201d used to look at how the control panel applet works.","First, a module interaction map shown in FIG. displays all main executable and user-interactable items, or modules, that the CPL uses and interacts with. For example, when a dialog is displayed by the CPL executable, both the dialog and the CPL modules are considered to interact with one another. Technically, the dialog is not a module since it is a figment displayed on the screen, but none the less, module interaction maps classify them as such since they are key destination points for user-input.","Second, an object interaction map shown in  displays all main objects making up the modules described in the module interaction map. Objects consist of the actual instances of C++ classes defining each object. All interactions between the objects are drawn out in this interaction map.","Finally,  display a set of scenario maps are drawn out using the object interaction map as a basis. Scenario interaction-maps describe the interactions taking place during a specific operation. Initialization, Adding a driver to the system, and Viewing the support offered by a driver, are all examples of a scenario interaction-map.","The design goals for the driver administrator  are the following:\n\n","The following discussion describes the module interaction map for the control panel applet . A module is defined as either an executable binary, an external data file, or a main user-interface element used when interacting with the user.  is a drawing of all modules that interact with each other when running the driver administrator control panel applet.","The driver administrator CPL  is a control panel applet. And, a control panel applet is a special DLL that exports several functions allowing the Windows Control Panel to communicate with the applet.","The Driver Administrator Dialog is the main dialog that appears when selecting the control panel applet icon from the Windows Control Panel.","The Browse Dialog is used to query the user for a filename. For example when adding a new stream or driver, the driver administrator uses this dialog to ask the user for the location of the new driver or stream to add.","The View Support Dialog displays the support provided by the selected driver . Each driver may support a different set of extended functionality. This dialog shows the user exactly how much support is provided by each driver allowing them to determine which functions within their application may not operate when using the driver.","Unlike the Module Interaction-Map described above, the Object Interaction-Map shown in  describes how the actual instances of C++ objects interact with one another within each module.","Other than showing that each dialog is managed by the object, whose name is displayed in the dialog, the main difference from the module IA-map are both the CComCPL and CDriverAdmin C++ objects. Both objects are described below.","As the description of each dialog class is fairly straight forward and very similar to the dialog description above they will not be described in this section. This section will describe all other C++ objects.","The CComCPL is a C++ object that is generated by the COMBuilder application from a template. It is used to handle all Windows messages sent from the Control Panel Application.","The CDriverAdmin object is used to drive, control, and manage the use of the driver administrator  Component. For example, all OLE 2.0 interface management and data translation is handled by this object. Data translation involves translating data from a standard C++ format to a raw format that is handled easily with the OLE 2.0 data transfer mechanisms.","Scenario Interaction-Maps are almost identical to object interaction-maps but they only display the objects and interactions taking part in a specific operation. Also, each interaction is numbered by the sequence in which they occur while the operation is running. The following discussion describes several key operations that occur while running the driver administrator CPL  Applet.","Initialization occurs when the user first runs the CPL Applet. During this process all other objects are initialized and several modules are loaded. There are two steps that take place during the initialization process: First the application is initialized, and second the dialog is initialized with values queried from the driver administrator  Component. The following sections describe each.","Initializing the application, which is shown in , occurs when the application is first run and the main dialog has not yet been displayed. When initializing the application, the following steps occur.","Through a Windows message, Windows notifies the CComCPL object that the Control Panel Applet has just been loaded. CComCPL then loads the CDriverAdminDialog and tells it to do any dialog prepping before going modal. Next, CDriverAdminDialog loads any settings stored in the Registration Database. For example, the current window position and active tab may be stored in the database. CDriverAdminDialog then Loads the CDriverAdmin class and directs it to initialize itself. During initialization, CDriverAdminDialog creates an instance of the driver administrator  and queries all interfaces that will be used.","Once the application is initialized, the default settings to be displayed in the dialog must be set. These values are set when the dialog is initialized, just before displaying it.  describes this process. During the process of initializing the dialog, the following steps occur.","During the dialog preparation that occurs before the DoModal call, CDriverAdminDialog queries the CDriverAdmin object for the driver enumeration to be used when setting initial values to be displayed in the dialog box. CDriverAdmin uses the driver administrator  Component to query for the driver information map, which is then passed back to the CDriverAdminDialog. Once receiving the driver information map, the CDriverAdminDialog uses the information to update all user-interface items related to either drivers or streams.","Adding a driver to the system  can be broken down into two steps. First, the module name must be added to the system. Next, the driver administrator  main dialog must update itself to reflect the new driver just added.","Adding a driver occurs when the user presses the \u201cAdd . . . \u201d button on the driver administrator 's main dialog.  describes this process. When adding a new driver, the following steps occur.","When adding a driver, first the user must press the \u201cAdd . . . \u201d button. After pressing the button, CDriverAdminDialog opens up the common open file dialog. The user must enter in the filename of the driver to add and close the dialog. CDriverAdminDialog then passes the filename to the CDriverAdmin object and calls the RegisterDriver method passing in the name of the module to register as a driver. CDriverAdmin then passes the driver filename to the driver administrator  Component and directs it to register the driver in the system .","The process of updating the main dialog is identical to the process of initializing the dialog discussed above.","Similar to the process of adding a new driver, removing a driver involves both removing the driver from the system and then updating the main dialog. Pressing the \u201cRemove\u201d button removes a driver from the XMC software system.  describes this process. The following steps occur when removing a driver.","To remove a driver, the user must first select the \u201cRemove\u201d button. After pressing the button, the selected driver or parent driver to the selected stream will be removed. CDriverAdminDialog passes the XMC_HDRIVER of the driver to the CDriverAdmin and directs it to remove the driver by calling its UnRegister method. CDriverAdmin passes the XMC_HDRIVER to the driver administrator  Component and directs it to UnRegister the driver.","The process of updating the main dialog is identical to the process of initializing the dialog discussed above.","Viewing Support involves viewing the level of support implemented by the selected driver.  describes the process of providing this information to the user via the View Support Dialog. The following steps occur when viewing the support provided by the driver.","First the user must select the \u201cView Support\u201d button on the driver administrator main dialog. When selected, CDriverAdminDialog queries CDriverAdmin for the driver support information. CDriverAdmin passes the query on to the driver administrator  component who actually fills out the information. Once the queried information is returned, the CDriverAdminDialog passes it on to CViewSupportDialog. CViewSupportDialog initializes itself using the driver support information.","Attached hereto as Appendix H is a document that describes the actual OLE Interfaces exposed, the definitions of the data structures used when passing data around, and the definitions of each class used internally by the driver administrator .","This section contains a description of the driver administrator control panel applet . When using the driver administrator  to configure the motion control system, there are two main items that the user will work with: drivers and streams. Each driver  generates the hardware specific, control codes that are then sent to the selected stream component . Streams facilitate the data transport layer between the driver and the control-code destination.","Depending on the current hardware setup, different streams may be used. For example, if the hardware is connected to the PC Bus, a PC Bus stream will be used to communicate to it. On the other hand, if the hardware is connected through a serial cable to a serial I\/O Port, the serial stream will be used. Finally, all hardware configurations may use the file stream. When using the file stream, all control-codes are sent to the specified file that can be downloaded to the hardware at a later time.","This section describes both drivers and streams, and how each is configured. This section initially describes the driver items and all property pages used to edit them. This section also contains a description of the streams and their property pages. Finally, this section describes the about box containing details on the Software.","The main purpose of each driver is to generate the hardware-specific control-codes directing the hardware to carry out specific motion control actions. For example, such actions may include querying the hardware for the current position or directing the hardware to move to a predetermined location in the system. The following discussion describes the property pages used to configure each driver.","There are two types of properties affecting each driver. First, a set of defaults may be set that are used by the motion control component  as recommended values. The scaling and units used are several example default values. In addition to setting default values, if the driver supports more advanced configuration, pressing the Advanced . . . button will display a dialog box used to set the driver configuration. For example, if a driver does not support streams, the advanced configuration dialog, provided by the driver, will allow the user to set the I\/O Port and IRQ settings.","The properties affecting drivers  are as follows.\n\n","The unit descriptions are as follows:\n\n","The buttons along the bottom of the windows work with the selected driver or stream. The following discussion describes each button and what it does.","Pressing the Make Default button selects the current driver to be the default. If a stream is selected, its parent driver becomes the default driver. The default driver is later used by the motion control component ","Selecting the Add . . . button, displays the Add Module dialog. This dialog is used to add new drivers and streams to the system . Once selected, the new driver or stream will be displayed in the Driver tree view. When adding a stream, the stream is added under the currently selected driver. To enable the stream, you must select the enable check box located in the streams property page.","Selecting the Remove button, removes the current driver or stream selected. If a driver is removed all of its streams are also removed.","Selecting the View Support . . . button displays a dialog used to view the level of XMC support implemented by the driver. For example, all API interfaces and subsequent methods are displayed. If a lack of implementation within the driver prohibits an API interface from operating, the driver stub  is used. If the lack of implementation within the driver  cannot be replaced by operations within the driver stub , the interface or method is disabled.","The following are descriptions of each graphic found in the XMC Support View Dialog.\n\n","Like the properties page, a debug page is also provided to set all debugging settings for the driver. Each driver may specify that all API calls used to control the driver are logged. The logging settings only affect the current driver selected. The Output field allows you to select the output stream where all debug information is sent. When Streams is enabled, debug information is sent to the specified text file. When Debug Monitor is enabled, debug information is sent to the debug monitor if it is running. Using Enable to enable a stream turns it on causing all debug information generated to be sent to the stream. More than one stream may be enabled at one time.","Stream Settings are available for each debug stream supported. Text File allows the name of the text file may be set. The Debug Monitor can only be enabled and disabled.","A stream is the transport layer used by the driver to pass data to the destination location. The destination location may be the actual motion control hardware or even a text file. Usually the control language used by a hardware vendor is supported by several different flavors of their motion control hardware. For example, some vendors have both PC Bus based and Serial I\/O based motion control hardware that understand the same control language. In such a case, the same driver would be used for each hardware setup but it would communicate with different streams depending on the specific hardware setup. Graphically, each stream is listed below each driver that uses the stream.","This section describes the streams supported by the system  and how they are configured.","The PC Bus stream sends all data directly to a PC Bus based motion control hardware system by writing to the specified I\/O Ports and IRQ's defined by the hardware. This section describes both the properties and debug settings available for the PC Bus Stream.","Stream properties only affect the currently selected stream. The user is required to select certain settings, such as the I\/O Port and IRQ. Without setting these values, the PC Bus Stream will not be able to communicate with the hardware. The properties affecting PC Bus Streams are described below.","The I\/O Port is the base port used to communicate with the motion control hardware that the stream is to send data to.","The IRQ is the interrupt request level used by the hardware.","Pressing the Advanced . . . button will display a dialog allowing the user to edit more advanced stream options. For example, if the stream supports a Port I\/O map that the user can edit, the port map would be displayed in this dialog. This button is only enabled for streams supporting advanced features that the user may edit.","When debugging an application program it may be useful to see what codes are actually sent to the hardware. The Debug Settings page for streams allows the user to enable and disable both the Cmd and Bit Streams. The Cmd Stream is used to log all command-codes sent to the hardware. If this level of detail does not provide you with enough information, the Bit Stream may be used. When enabled, the Bit Stream logs all values sent through each hardware port. All values read from and written to each port used by the hardware are logged. Note, when enabled, both streams may significantly slow down the application programming the motion control system.","Serial RS-232 Streams are used to send data from the driver to motion control hardware connected to the computer through the serial I\/O port. Both property and debug settings only affect the selected Serial RS-232 Stream. The following discussion describes the available settings in each in detail.","All Serial RS-232 property settings must be set by the user for they let the stream know what I\/O port and communication protocol to use when communicating with the hardware. The properties affecting Serial RS-232 Streams are as described below.","The Port is the serial port that the hardware is connected to. COM1-COM4 are valid ports that can be used.","The Baud Rate is the speed of data transmission supported by the hardware.","When Hardware is selected a more efficient, but less compatible, communication protocol is used to communicate to the hardware. If errors occur when this protocol is selected, use the XON\/XOFF communication protocol.","When the XON\/XOFF communication protocol is selected a simple and more compatible communication protocol is used.","Debug settings for the Serial RS-232 Stream are very similar to those supported by the PC Bus Stream. Serial RS-232 Streams only support command logging through the Cmd Stream and do not support bit logging.","The Text File Stream is used to build control-code programs for later use. Using this stream facilitates running the XMC software in code-generation-mode. No motion control actions take place when running in this mode. Instead, control-code programs may be built and stored to file. Later, after programs are built and saved, they may be downloaded to the motion control hardware and run. The following discussion describes the property and debug settings for the Text File Stream.","The main property set, when configuring a Text File Stream, is the actual name and location of the file to use. Once set, the stream is ready for use.","The following properties may be configured for the Text File Stream:","Filename is the filename and location of the file used to store all control-codes generated by the driver  selected. Pressing the Browse . . . button displays a dialog allowing you to graphically select the location and filename to use.","No debug settings are available for the Text File Stream.",{"@attributes":{"id":"p-0294","num":"0316"},"figref":"FIG. 58","b":["44","44","28","32","35","42"]},"As with the software drivers  described above, one language driver  is used for each of the motion control devices  of the group of supported motion control devices. The language drivers  perform the same basic function as the software drivers  described above with reference to FIGS.  and -. To the software system , the language drivers  are accessed and respond in the same manner as the software drivers ; the differences between the language drivers  and the software drivers  are entirely internal.","The primary difference between these drivers  and  is that the language drivers  use a database the key fields of which are an index field, a command format field, and a response format field. Each record or row in the database corresponds to a given Driver function.","The purpose of the command and response format templates is to formalize and simplify the process of constructing command data strings and format data strings which contain commands and parameters to be transmitted to the motion control devices . The format templates define how, for a given SPI command, the software system  communicates with a vendor specific hardware command language associated with a given motion control device  associated with a given language driver . Accordingly, one database containing command format templates and response format templates will be created for each such language.","The command format field contains a command format template, and the response format field contains a response format template. Each of these templates comprises a sequence of data type identifiers, macro identifiers, syntax characters, and\/or ASCII characters.","The index field contains a value unique to each Driver function that facilitates the process of looking up the command and response format templates associated with a given Driver function.","The software system designer defines the data type identifiers, macro identifiers, and syntax characters discussed above. In general, the data type identifiers and syntax characters are common to both the command format template and the response format template.","The macro identifiers will normally correspond to macros that are associated with either the command format templates or the response format templates. The ASCII characters are defined by the Driver function and the particular motion control device  with which a given language driver  is associated.","An Excel spreadsheet may be used as an organizational tool that facilitates creation of the database used by the language driver . An example of a Excel spreadsheet that may be used for this purpose is shown in . The spreadsheet shown in  is saved as a tab-delimited file and then copied into the SPI database shown in .","The spreadsheet shown in  is simply an organizational tool and will not be described herein in detail. But it should be noted that the exemplary spreadsheet shown in  sets forth a list of typical command and response data type identifiers, along with descriptions thereof, and lists of command and response macros. These will be supplemented by an additional STRUCT data type that allows the programmer to define a data type that combines the other primitive data types as necessary for a given template.","The language drivers thus operate generally as follows. As described above, the motion component  will call the driver function implemented by the language driver  and, in many cases, will pass parameters necessary to carry out that function. The language driver  will use the index for that driver function to look up the command format template and the response format template associated with the appropriate driver function.","Using the command format template, the language driver  will construct a command data string containing ASCII characters. The command data string carries the commands and parameters necessary to implement the given driver function in a desired manner on the motion control device  associated with the language driver .","Similarly, the language driver  uses the response format template to parse a response data string sent by the particular motion control device  in response to the command data string. The response format template thus allows the language driver  to pass from the motion control device  to the motion control component  any commands and\/or parameters necessary to enable the controlling application  to function as intended.","The following sets forth examples of the process of generating a command data string and parsing a response data string given a set of command and response format templates associated with a single SPI.","The first example illustrates how the language driver  might deal with the Driver function IXMC_DrvExt_Test::Move.",{"@attributes":{"id":"p-0309","num":"0331"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Cmd Format:","D%d,+:@[snd]GO%b+:@[snd]"]},{"entry":[{},"Rsp Format:","@[crlf]>@[rcv]@[crlf]>@[rcv]"]},{"entry":[{},"Driver function Call:","pXMCDrvExtTest->Move( 20.0, 30.0 )"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"This function call directs the motion control device to move 20 units in the x direction and 30 units in the y direction.","The driver communicates with the stream as follows:","Step 1. Perform the operation in the command format template up to the first @ symbol. This builds a raw command string of \u201cD20.0,30.0:\u201d","Step 2. After the first @ symbol is the send command, which sends the string that was built in step 1. The language driver has now reached the G in the command format template.","Step 3. After the send command, the language driver reads a response from the stream to confirm that the command string was received and processed correctly. The response string received from the stream is as follows: \u201c\\r\\n>\u201d.","Step 4. The language driver next uses the response format template to parse the raw response string to verify operation and extract data. The language driver then picks up at the G in the command format template and constructs the next raw command string of \u201cGO11\u201d, leaving off at the last macro.","Step 5. The language driver, picking up at last macro in the command format template, then sends the raw command string created in step 4 to the stream, completing the command format template.","Step 6. Again, after the send command the language driver receives a response data string from the stream as follows: \u201c\\r\\n>\u201d.","Step 7. The language driver next parses the response data string received in step 6.","The second example illustrates how the language driver  might deal with the Driver function IXMC_DrvExt_Test::SetVelocity.",{"@attributes":{"id":"p-0319","num":"0341"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Cmd Format:","V%lf,+@[snd]"]},{"entry":["Rsp Format:","@[crlf]>@[rcv]"]},{"entry":["Driver function Call:","pXMCDrvExtTest->SetVelocity( NOP, 22.0 )"]},{"entry":["Explanation","Set the velocity of the y axis to 22.0."]},{"entry":["Raw Command String:","\u201cV,22.0:\u201d"]},{"entry":["Raw Response String:","\u201c\\r\\n>\u201d (expected)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The third example illustrates how the language driver  might deal with the Driver function",{"@attributes":{"id":"p-0321","num":"0343"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"IXMC_DrvExt_Test::GetVelocity."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Cmd Format:","GV%b+:@[snd]"]},{"entry":["Rsp Format:","%d,+@[crlf]>@[rcv]"]},{"entry":["Driver function","pXMCDrvExtTest->GetVelocity( NOP, &dfY_Vel )"]},{"entry":["Call:",{}]},{"entry":["Explanation","Get the velocity set for the y axis."]},{"entry":["Raw Command","\u201cGV01:\u201d"]},{"entry":["String:",{}]},{"entry":["Raw Response","\u201c,44.0\\r\\n>\u201d (expected)"]},{"entry":"String:"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":"dfY_Vel = 44.0"}]}}]}}},"The fourth example illustrates how the language driver  might deal with the Driver function IXMC_DrvExt_Test::Reset.",{"@attributes":{"id":"p-0323","num":"0345"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Cmd Format:","!RESET:@[snd]MA0:MC0:LH0:@[snd]"]},{"entry":["Rsp Format:","@[crlf]*VENDOR NAME -"]},{"entry":[{},"MODEL@[rcv]@[crlf]>@[rcv]"]},{"entry":["Driver function Call:","pXMCDrvExtTest->Reset( )"]},{"entry":["Explanation","Reset the hardware."]},{"entry":["Raw Command String1:","\u201c!RESET:\u201d"]},{"entry":["Raw Response String1:","\u201c\\r\\n*VENDOR NAME - MODEL\u201d (expected)"]},{"entry":["Raw Command String2:","\u201cMA0:MC0:LH0:\u201d"]},{"entry":["Raw Response String2:","\u201c\\r\\n>\u201d (expected)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"While the language driver  is of particular importance in the context of the software system  described above, this technology may have broader application to any hardware in which ASCII strings are employed to transmit commands to and receive responses from hardware.","The language driver  will now be described in more detail. The language driver  is used by both the driver administration  and the motion control component . Its main purpose is to implement functionality that generates motion control commands for the specific hardware supported.","For example, the AT6400 driver used to control the Compumotor AT6400 motion control hardware, generates AT6400 command codes. During the initialization phase of the system , the driver administrator  communicates with each language driver , allowing the user to add, remove, or change the configuration of the driver . When an application using the system  is run, the component  communicates with the language driver  directing it to carry out the appropriate motion control operations.","Unlike the driver  described above, which communicates with motion control devices  by directly sending binary codes, the language driver  sends ASCII text to the stream , which then sends the information on to the motion control device .","This section makes reference to a number of drawings to describe the features implemented in the language driver : (a) the Module Interaction-Map in  that displays all binary modules that interact with the driver and how they interact with one another; (b) an Object Interaction-Map (), which corresponds to the module interaction map expanded to display the internal C++ objects making up the language driver , and how these objects interact with one another; (c) a number of Scenario Maps () that display the interactions taking place between the C++ objects involved during a certain process; (d) an interface map that describes the interfaces exposed by the language driver component , all data structures used, and the definitions of each C++ class used; and (b) a table illustrating how a typical database employed by the language driver  is constructed ().","The module interaction-map in  displays all binary modules and their interactions with the Language Driver . There are two modules that interact directly with the driver : the Motion Control Component , and the Driver Administrator . The driver administrator  queries and changes the drivers settings and the component  directs the driver  to carry out motion control operations, such as moving to a certain location in the system.","Mores specifically, the module interaction-map shown in  contains the following modules:\n\n","The object interaction-map in  breaks the module interaction-map shown in  down into more detail by including the interactions taking place between all C++ objects used to implement the driver .","Each object in the diagram is described as follows.\n\n","All main scenarios, or operations, that occur on the Language Driver  will now be described with reference to . Each scenario-map contained in these figures displays all objects involved and the interactions that take place between them in the sequence that they occur.","There are two types of operations that occur on the Language driver . First, the Driver administrator  may initiate operations, such as adding streams or configuring the driver. And second, the Motion control component  may initiate operations on the driver when an application is actually running.","Referring now to , all operations made on the driver  by the driver administrator  will be described. Each figure is discussed in the order that it may occur when using the driver .","Before a driver may be used by the XMC Motion Component, it must be registered in the OLE system. As shown in , in order to register a driver the driver administrator, first verifies that the module being registered is actually an appropriate language driver, then it calls the DLLRegisterServer exported function to register the driver. Each module of the system  exports a function called DLLGetModuleType. This function is used to verify that the module is an appropriate driver component.","Next, the driver administrator can load the component using the OLE CoCreateInstance function. During the initialization process, the driver loads all registration data and initializes the CDriverInfo and all C++ manager objects.","The following describes in detail each of the steps set forth in .","1. During initialization, the driver administrator must load the DLL, containing the stream component, verify that the module is an XMC Driver. To do so, the driver administrator calls the DLLGetModuleType function, exported by the driver. If the function returns a value that contains the value XMC_DRIVER_MT in the high byte, then the driver administrator proceeds and registers the driver by calling its exported function, DLLRegisterServer. When called, the implementation of the DLLRegisterServer writes all OLE 2.0 registration information, needed to register the OLE component, to the Windows registration database.","2. Next, the driver administrator must query the driver module for its CLSID. Calling the driver's exported function, DLLGetCLSID, returns the CLSID. Once it has the CLSID, the driver administrator may create an instance of the driver by calling the standard OLE function CoCreateInstance.","3. CoCreateInstance automatically initializes the component by calling the ICOM_Base::Initialize method implemented by the CDriverObject.","4. The implementation of ICOM_Base::Initialize directs both the CDrvCoreDisp to initialize itself.","5. Within its initialization, the CDrvCoreDisp object initializes each of its manager objects, starting with the CcommandMgr.","6. During its initialization, the CCommandMgr directs the CCommandDatabase to load itself.","7. To load the database, the CCommandDatabase object reads in the database and builds the CSPIInfo list of database elements.","8. After initializing the CCommandMgr, the CDrvCoreDisp object directs the CDriverInfoMgr object to create the CDriverInfo object, that will later store the internal state of the Language driver  component.","9. The CDriverInfoMgr object creates the CDriverInfo object and passes it back to the dispatch object. The pointer to this object is later stored in the components state handle, when the CDriverObject calls ICOM_Base2::SetStateHandle.","10. Next, the CDrvCoreDisp object initializes the CStreamMgr, that is used to perform all stream operations.","11. Next, the CDrvCoreDisp object initializes the CRegistryMgr, that is used to perform all registration database operations.","12. Finally, the CDriverObject initializes the CDrvExtDisp object.","It should be noted that all initialization is initiated through the COM Auto-Init mechanism. Auto-init occurs when creating an object. When calling either CoCreateInstance, or calling the IClassFactory::CreateInstance method, the internal COM implementation calls the ICOM_Base::Initialize method. This method triggers the complete initialization process described in this section.","After initializing the driver, the driver administrator may perform operations on it. For example, the driver administrator may request the driver to add or remove a stream.  displays the sequence of events occurring when the driver is requested to add a new stream.","When adding a stream, the following steps occur:","1. The driver administrator directs the driver to add a new stream and passes the filename and CLSID of the stream, to be added, to the driver.","2. The driver then passes the filename and CLSID to the CDriverObject object and directs it to add the stream by calling its CLNGStreamMgmt::AddStream embedded C++ class method.","3. The embedded C++ object, that implements the OLE interface, directs the CDrvExtDisp object to add the stream, passing it a handle of the component state data.","4. The CDrvExtDisp object first typecasts the component state data into a pointer to the CDriverInfo object.","5. Next, the CStreamMgr, is connected to the CDriverInfo object pointer, and directed to add a new stream.","6. In order to add the new stream, the CStreamMgr, uses a CSimpleStream to load and create the stream component.","7. The CSimpleStream object first sets function pointers to the DllGetCLSID, DllGetModuleType and DllRegisterServer functions exported by the component. Before loading the module, the CSimpleStream, first makes sure that the module is actually an XMC Stream by comparing its module type with the XMC_STREAM_MT module type. If it is, the component is registered in the registration database as a n OLE component.","8. Using the DllGetCLSID queried in the previous step, the CSimpleStream gets the components CLSID and calls CoCreateInstance to load an instance of the OLE object.","9. After the CSimpleStream completes the CStreamMgr adds the stream to the CDriverInfo's stream array.","Another operation requested from the driver, after initialization, is that of querying it for its current settings. Before displaying information about the driver, like the name of the hardware it supports, the driver administrator must query the driver for the information.  displays an exemplary process of querying the driver for its driver settings.","When querying the driver for information, the following steps are performed.","1. The driver administrator, calls the interface method used to query the driver's information and passes the call a pointer to the XMC_DRIVER_INFO structure.","2. The call is handled by the implementation of the OLE interface method, implemented by on of the CDriverObject's embedded C++ classes.","3. The embedded C++ object, used to handle the interface, directs either the CDrvCoreDisp or CDrvExtDisp object to carry out the operation, and passes the object th handle to the component state data.","4. The dispatch object type casts the state handle to a CDriverInfo object pointer. Once converted, the CDriverInfo object is queried for the appropriate data.","Upon request, the driver may either save or load its entire configuration to or from the registration database. This operation is used by the XMC Driver Administration component who stores all XMC configuration data in the registration database.  displays the sequence of events that take place when the XMC Driver Administration component directs the driver to load its information from the registry.","During the registration process, the following steps occur.","1. First, using the ICOM_PersistRegDB OLE interface, exposed by the driver, the driver administrator directs the component to load its configuration data.","2. The CDriverObject's embedded object, used to handle all ICOM_PersistRegDB calls, is invoked and performs the operation.","3. Once invoked, the embedded object directs the CDrvCoreDisp object to perform the load, and passes it a handle to the components state data.","4. The CDrvCoreDisp object, first typecasts the state handle to a CDriverInfo object pointer.","5. Next, the CRegistryMgr is connected to the CDriverInfo pointer, and directed to load its contents to or from the registration database.","6. The CRegistryMgr loads all general driver information and fills out the drivers XMC_DRIVER_INFO data structure, stored in the CDriverInfo object.","7. If the driver has any streams information stored, the CRegistryMgr loads the stream information and fills out an XMC_STREAM_INFO structure. The structure is then used to create a new CSimpleStream object.","8. When creating the stream, the CSimpleStream object first queries and calls the DllGetModuleType exported function and verifies that the module is in fact a stream component. If the module is, the CSimpleStream then queries and calls the DLLRegisterServer function exported by the component to register the component.","9. After registering the component, the CSimpleStream object queries and calls the DllGetCLSID exported function to get the components CLSID. Using the CLSID, CoCreateInstance is called to create an instance of the OLE object.","10. Once the CSimpleStream completes, the CRegistryMgr connects a temporary instance of the CStreamMgr to the CDriverInfo object pointer, and directs it to add the new stream.","11. The CStreamMgr directly manipulates the CDriverInfo's stream array to add the new stream. When added, a new instance of the CSimpleStream object is created and attached to the CSimpleStream passed to the CStreamMgr.","12. When attaching itself to the stream, the new CSimpleStream queries the IXMC_StreamInit interface, passed to it, for all interfaces used it bump up the reference counts for the component.","After the driver administrator is done using the driver, it must release the driver by calling its exposed Release method. Calling this method, directs the driver to release all resources used.  displays the process of releasing the driver component.","During the clean-up process, the following steps occur.","1. First, either the XMC Driver Administrator, or the XMC Motion Component call the final IUnknown::Release.","2. When invoked, the IUnknown::Release method implemented by the CDriverObject is called. After calling this method causes the internal OLE reference count to go to zero, driver calls its implementation of ICOM_Base::Uninitialize to clean up all resources used.","3. First, ICOM_Base::Uninitialize directs the CDrvExtDisp to clean up any resources that it was using.","4. Next, ICOM_Base::Uninitialize directs the CDrvCoreDisp object to clean up any resources that it was using.","5. Since the CDrvCoreDisp object contains instances of all manager objects, it begins cleaning them up by first directing the CCommandMgr to destroy any resources that it was using. Internally, the CcommandMgr destroys the CCommandDatabase and all of its contents.","6. Next, the CDrvCoreDisp object implicitly destroys all other manager objects by calling their destructors.","7. And as a final step, the ICOM_Base::Uninitialize method deletes the state handle containing a pointer to the CDriverInfo object. When destroyed, the CDriverInfo object deletes each CSimpleStream object, which in turn release their instance of the XMC Stream component. Upon releasing the final instance of the XMC Stream component, the component dll is freed from memory.","After a driver is successfully installed into the XMC system and configured using the driver administrator, it is ready for use by the XMC Motion Control Component. The component uses the driver when performing motion control operations requested from the application using the component.  describes the component directed operations that can take place on the driver.","Before operating, the XMC Motion Component must query the Driver administrator  component for its driver enumeration. The enumeration returned is used to access all enabled drivers that are directed to perform XMC SPI operations by the XMC Motion Component.","Once the driver enumeration is acquired, the Motion control component  can direct the enabled driver, or drivers, to carry out certain command operations. Command operations are standard motion control operations such as moving to a specific location in the system, or querying the system for the current position.  describes the process of commanding the driver to carry out a certain operation.","When commanding the driver to perform a certain operation, the following steps occur.","1. First, the motion component directs the driver to perform the operation, such as moving to a position or querying the system for the current position.","2. The XMCSPI invocation is handled by the CDriverObject who implements all OLE interfaces exposed by the component.","3. The CDriverObject directs either the CDrvCoreDisp, or CDrvExtDisp object to perform the operation, depending on whether the operation is a core or extended XMCSPI. The component state handle is passed to the dispatch object when called.","4. The dispatch object then typecasts the state handle into a CDriverInfo object pointer.","5. Next, the dispatch object connects the CCommandMgr to the CDriverInfo object pointer and directs it to carry out the operation corresponding to the database index sent. The database index corresponds to the XMCSPI called and is used to locate the language database entry for that SPI call.","6. The CCommandMgr searches the CCommandDatabase for the index and builds a CCommand object corresponding to the XMCSPI operation.","7. Next, the CCommandMgr directly accesses the CDriverInfo and passes the command string, built by the CCommand object, to all enabled streams.","8. Each enabled stream sends the ASCII text to its target. For example, the PCBus steam sends its data to the motion control card located on the PCBus. The text file stream, on the other hand, sends its data to its associated text file.","9. If directed, the CCommandMgr then queries the first readable stream for the results of the commands sent to it.","10. The CSimpleStream reads the raw response from the target and returns it to the CCommandMgr.","11. Once receiving the raw response, the CCommandMgr uses the CResponse object to parse the raw response based on the response format corresponding to the XMCSPI database entry. All response parameters are returned back up the calling chain, and eventually end up in the hands of the original caller, the XMC Motion Component.","The clean-up initiated by the XMC Motion Component by releasing the XMC Driver component is the same as that which occurs when the Driver administrator  object releases the component.","The following discussion describes the actual OLE Interfaces exposed, the definitions of the data structures used when passing data around, and the definitions of each class used internally by the driver.","The following diagram describes all interfaces exposed by the driver specific to driver-component interpretability.  graphically displays the interfaces exposed by the component.","Other than the two standard interfaces exposed, such as IUnknown and IClassFactory, there are three categories of interfaces exposed by the component. The three categories are as follows.\n\n","The following sections describe the interfaces falling into both the COM and LNG categories. All other interfaces are XMCSPI specific and are used for the sole purpose of performing motion control operations.","The following exposed methods in the ICOM_Base interface are used when initializing and uninitializing the component. Each of these methods call the hidden initialize and uninitialize interface methods implemented by all of the component's interfaces.",{"@attributes":{"id":"p-0413","num":"0459"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DECLARE_INTERFACE_( ICOM_Base, IUnknown )"]},{"entry":[{},"{"]},{"entry":[{},"\u2003STDMETHOD ( Initialize )( THISLPVOID pInitInfo ) PURE;"]},{"entry":[{},"\u2003STDMETHOD ( Uninitialize )( THIS ) PURE;"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The ICOM_Base2 interface inherits from the ICOM_Base interface and adds several methods used to manage the internal component state handle. In addition, a method allows the user to translate any HRESULT returned by the component into a human readable text string. The following is a description of the ICOM_Base2 interface.",{"@attributes":{"id":"p-0415","num":"0461"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"DECLARE_INTERFACE_( ICOM_Base2, ICOM_Base )"},{"entry":"{"},{"entry":"\u2003STDMETHOD ( SetStateData )( THISCOM_STATEHANDLE"},{"entry":"hState ) PURE;"},{"entry":"\u2003STDMETHOD ( GetStateData )( THISLPCOM_STATEHANDLE"},{"entry":"phState ) PURE;"},{"entry":"\u2003STDMETHOD ( GetErrorString )( THISHRESULT hr, LPSTR"},{"entry":"pszErr, DWORD dwMax ) PURE;"},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The ICOM_Persist2 interface inherits from the IPersist standard OLE interface and adds several methods used to query the CLSID and module type. The following is a description of the ICOM_Persist2 interface.",{"@attributes":{"id":"p-0417","num":"0463"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"DECLARE_INTERFACE_( ICOM_Persist2, IPersist )"},{"entry":"{"},{"entry":"\u2003STDMETHOD ( GetID )( THISLPDWORD pdwID ) PURE;"},{"entry":"\u2003STDMETHOD ( GetModuleType )( THISLPDWORD pdwMT )"},{"entry":"\u2003PURE;"},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The ICOM_PersistRegDB interface implements similar functionality to that provided by the IPersistFile standard OLE interface. Instead of saving and loading data to and from a file, the ICOM_PersistRegDB operates on the registration database. The following is a description of the ICOM_PersistRegDB interface.",{"@attributes":{"id":"p-0419","num":"0465"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DECLARE_INTERFACE_( ICOM_PersistRegDB, IUnknown )"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\u2003STDMETHOD ( IsDirty )( THIS ) PURE;"]},{"entry":[{},"\u2003\u2003\u2003STDMETHOD ( Load )( THIS_HKEY hKey) PURE;"]},{"entry":[{},"\u2003\u2003\u2003STDMETHOD ( Save )( THIS_ HKEY hKey ) PURE;"]},{"entry":[{},"\u2003\u2003\u2003STDMETHOD ( Clear )( THIS_ HKEY hKey ) PURE;"]},{"entry":[{},"};"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The ILNG_DrvCore_Init interface is used to initialize the language driver component. The following is a description of the ILNG_DrvCore_Init interface.",{"@attributes":{"id":"p-0421","num":"0467"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"DECLARE_INTERFACE_( ILNG_DrvCore_Init, IUnknown )"},{"entry":"{"},{"entry":"\u2003\u2003\u2003STDMETHOD (Create)( THIS_ LPLNG_DRIVER_INFO pDI )"},{"entry":"\u2003\u2003\u2003PURE;"},{"entry":"\u2003\u2003\u2003STDMETHOD (Destroy)( THIS ) PURE;"},{"entry":"\u2003\u2003\u2003STDMETHOD (Setup)( THIS_ LPLNG_DRIVER_INFO pDI )"},{"entry":"\u2003\u2003\u2003PURE;"},{"entry":"\u2003\u2003\u2003STDMETHOD (Stat)( THIS_ LPLNG_DRIVER_INFO pDI )"},{"entry":"\u2003\u2003\u2003PURE;"},{"entry":"\u2003\u2003\u2003STDMETHOD (Register)( THIS ) PURE;"},{"entry":"\u2003\u2003\u2003STDMETHOD (UnRegister)( THIS ) PURE;"},{"entry":"\u2003\u2003\u2003STDMETHOD (IsRegistered)( THIS_ LPBOOL pbRegistered )"},{"entry":"\u2003\u2003\u2003PURE;"},{"entry":"\u2003\u2003\u2003STDMETHOD (Enable)( THIS_ BOOL fEnable ) PURE;"},{"entry":"\u2003\u2003\u2003STDMETHOD (IsEnabled)( THIS_ LPBOOL pbEnabled )"},{"entry":"\u2003\u2003\u2003PURE;"},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The ILNG_DrvExt_StreamMgmt interface is used to perform all stream operations. The following is a description of the LNG_DrvExt_StreamMgmt interface.",{"@attributes":{"id":"p-0423","num":"0469"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"DECLARE_INTERFACE_( ILNG_DrvExt_StreamMgmt, IUnknown )"},{"entry":"{"},{"entry":"\u2003\u2003\u2003STDMETHOD (GetStreamEnumeration)( THIS_ LPENUMUNKNOWN FAR"},{"entry":"*ppEnumStream )"},{"entry":"\u2003\u2003\u2003PURE;"},{"entry":"\u2003\u2003\u2003STDMETHOD (GetStreamCount)( THIS_ LPDWORD pdwCount ) PURE;"},{"entry":"\u2003\u2003\u2003STDMETHOD (GetStreamInit)( THIS_ XMC_STREAMID idStream,"},{"entry":"\u2003\u2003\u2003LPXMCSTREAMINIT FAR *ppStreamInit ) PURE;"},{"entry":"\u2003\u2003\u2003STDMETHOD (GetStreamInitAt)( THIS_ DWORD dwIdx,"},{"entry":"\u2003\u2003\u2003LPXMCSTREAMINIT FAR *ppStreamInit ) PURE;"},{"entry":"\u2003\u2003\u2003STDMETHOD (AddStream)( THIS_ LPXMCSTREAMINIT pStreamInit ) PURE;"},{"entry":"\u2003\u2003\u2003STDMETHOD (RemoveStream)( THIS_ LPXMCSTREAMINIT pStreamInit,"},{"entry":"\u2003\u2003\u2003BOOL bDestroy ) PURE;"},{"entry":"\u2003\u2003\u2003STDMETHOD (RemoveStream)( THIS_ XMC_STREAMID idStream, BOOL"},{"entry":"bDestroy )"},{"entry":"\u2003\u2003\u2003PURE;"},{"entry":"\u2003\u2003\u2003STDMETHOD (RemoveAllStreams)( THIS_ BOOL bDestroy ) PURE;"},{"entry":"\u2003\u2003\u2003STDMETHOD (EnabledStreamsOnly)( THIS_ BOOL bEnabledOnly,"},{"entry":"\u2003\u2003\u2003LPBOOL pbOldEnabledOnly ) PURE;"},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The following are the functions exported by the driver DLL.",{"@attributes":{"id":"p-0425","num":"0471"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"XMC_DRIVER_MODULETYPE\u2003\u2003\u2009DLLGetModuleType( void );"},{"entry":"LPCLSID\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002DLLGetCLSID( void );"},{"entry":"BOOL\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003DLLRegisterServer( void );"},{"entry":"BOOL\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003DLLUnRegisterServer( void );"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The following discussion defines all structures, enumerations, and defines used by the driver.","The XMC_DRIVER_MODULETYPE enumeration defines the type of drivers available. Each driver must return its type when the user calls the exported DLLGetModuleType function.",{"@attributes":{"id":"p-0428","num":"0474"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"enum XMC_DRIVER_MODULETYPE"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\u2003XMC_DRIVER_MT\u2003\u2003\u2003\u2003\u2002\u2009= 0x4000,"]},{"entry":[{},"\u2003\u2003\u2003XMC_DRIVER_MT_AT6400 = 0x4001,"]},{"entry":[{},"\u2003\u2003\u2003XMC_DRIVER_MT_DMC1000\u2003\u2003\u2002\u2009= 0x4002,"]},{"entry":[{},"\u2003\u2003\u2003XMC_DRIVER_MT_DT2000 = 0x4003,"]},{"entry":[{},"\u2003\u2003\u2003XMC_DRIVER_MT_CUSTOM\u2003\u2003\u2003= 0x4004"]},{"entry":[{},"};"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The XMC_DRVCORE_CMD enumeration defines an identifier for every command known to the XMC Driver. For example, every core Driver function has a corresponding XMC_DRVCORE_CMD identifier. This index is used to look up the string block for the command. The definition of the enumeration is as follows.",{"@attributes":{"id":"p-0430","num":"0476"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"enum XMC_DRVCORE_CMD"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\u2003XMC_DCC_MOTION_MOVEABS,"]},{"entry":[{},"\u2003\u2003\u2003XMC_DCC_MOTION_KILL,"]},{"entry":[{},"\u2003\u2003\u2003:"]},{"entry":[{},"};"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The XMC_DRVEXT_CMD enumeration defines an identifier for every extended command known to the XMC Driver. Even though the identifiers exist, the driver may or may not implement the set of commands. For example, every extended Driver function has a corresponding XMC_DRVEXT_CMD identifier. This index is used to look up the string block for the command (if the driver implements the command). The definition of the enumeration is as follows.",{"@attributes":{"id":"p-0432","num":"0478"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"enum XMC_DRVEXT_CMD"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\u2003XMC_DCE_MOTION_MOVEREL,"]},{"entry":[{},"\u2003\u2003\u2003:"]},{"entry":[{},"};"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The LNG_PARAM_DATATYPE enumeration defines all types of data blocks that may be parsed from response strings returned by stream targets.",{"@attributes":{"id":"p-0434","num":"0480"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum _LNG_PARAM_DATATYPE"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\u2003\u2002LNG_ADT_NOP,"]},{"entry":[{},"\u2003\u2003\u2003\u2002LNG_ADT_NOTYPE,"]},{"entry":[{},"\u2003\u2003\u2003\u2002LNG_ADT_NUMBER,"]},{"entry":[{},"\u2003\u2003\u2003\u2002LNG_ADT_STAT_STRING,"]},{"entry":[{},"\u2003\u2003\u2003\u2002LNG_ADT_MEM_STRING"]},{"entry":[{},"} LNG_PARAM_DATATYPE;"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The LNG_PARAM_DATA structure stores all types of data that describe a parameter either built into a command, or parsed from a response.",{"@attributes":{"id":"p-0436","num":"0482"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"struct LNG_PARAM_DATA"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/---- Constructor & Destructor ----"]},{"entry":[{},"\u2003\u2003\u2003\u2003LNG_PARAM_DATA( void );"]},{"entry":[{},"\u2003\u2003\u2003\u2003~LNG_PARAM_DATA( void );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/---- Data ----"]},{"entry":[{},"\u2003\u2003\u2003\u2003LNG_PARAM_DATATYPE adt;"]},{"entry":[{},"\u2003\u2003\u2003\u2003union"]},{"entry":[{},"\u2003\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003double df;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003LPTSTR psz;"]},{"entry":[{},"\u2003\u2003\u2003\u2003};"]},{"entry":[{},"};"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The LNG_DRIVER_INFO structure is used when setting up and querying the state of the driver.",{"@attributes":{"id":"p-0438","num":"0484"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _LNG_DRIVER_INFO"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003\u2003DWORD","\u2003\u2003\u2003\u2003\u2003m_mt;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003\u2003LNG_DRIVERID\u2003m_ID;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003TCHAR","\u2003\u2003\u2003\u2003\u2003m_szName[ LNG_DRIVER_"]},{"entry":[{},{},"\u2003\u2003\u2003\u2003\u2003NAME_LEN+1 ];"]},{"entry":[{},"\u2003\u2003TCHAR","\u2003\u2003\u2003\u2003\u2003m_szDescription["]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"LNG_DRIVER_DESC_LEN+1 ];"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003\u2003TCHAR","\u2003\u2003\u2003\u2003\u2003m_szHWVendor["]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LNG_DRIVER_NAME_LEN+1 ];"]},{"entry":[{},"} LNG_DRIVER_INFO;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Each XMC Driver is responsible for managing all streams used. In order to manage each stream over time in a persistent manner each driver and stream module implement the persistent functionality exposed through the ICOM_PersistRegDB interface. When the driver's implementation of ICOM_PersistRegDB::Save is called, the data is saved to the registry in the following order.",{"@attributes":{"id":"p-0440","num":"0486"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"XMCDriverAdminObject.100"},{"entry":"\u2003|---- Drivers"},{"entry":"\u2003\u2003\u2003\u2003|---- dwCount = <# of drivers>"},{"entry":"\u2003\u2003\u2003\u2003|---- XMCDrv_0"},{"entry":"\u2003\u2003\u2003\u2003| \u2003\u2003\u2002|---- CLSID = {clsid}"},{"entry":"\u2003\u2003\u2003\u2003| \u2003\u2003\u2002|---- dwFlags = <driver flags>"},{"entry":"\u2003\u2003\u2003\u2003| \u2003\u2003\u2002|---- dwID = <driver ID>"},{"entry":"\u2003\u2003\u2003\u2003| \u2003\u2003\u2002|---- dwModuleType = XMC_DRIVER_MT_xxx"},{"entry":"\u2003\u2003\u2003\u2003| \u2003\u2003\u2002|---- szDescription = <user desc of the driver>"},{"entry":"\u2003\u2003\u2003\u2003| \u2003\u2003\u2002|---- Streams"},{"entry":"\u2003\u2003\u2003\u2003| \u2003\u2003\u2002\u2003\u2003\u2003|---- Count = <# of streams>"},{"entry":"\u2003\u2003\u2003\u2003| \u2003\u2003\u2002\u2003\u2003\u2003|---- XMCStrm_0"},{"entry":"\u2003\u2003\u2003\u2003| \u2003\u2003\u2002\u2003\u2003\u2003| \u2003\u2003|---- CLSID = {clsid}"},{"entry":"\u2003\u2003\u2003\u2003| \u2003\u2003\u2002\u2003\u2003\u2003| \u2003\u2003|---- dwID = <strm id>"},{"entry":"\u2003\u2003\u2003\u2003| \u2003\u2003\u2002\u2003\u2003\u2003| \u2003\u2003|---- dwModuleType = "},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002XMC_STREAM_MT_xxx"},{"entry":"\u2003\u2003\u2003\u2003| \u2003\u2003\u2002\u2003\u2003\u2003| \u2003\u2003|---- <stream specific values>"},{"entry":"\u2003\u2003\u2003\u2003| \u2003\u2003\u2002\u2003\u2003\u2003|"},{"entry":"\u2003\u2003\u2003\u2003| \u2003\u2003\u2002\u2003\u2003\u2003|\u2003\u2003\u2002---- XMCStrm_<n>"},{"entry":"\u2003\u2003\u2003\u2003| \u2003\u2003\u2002\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003|---- "},{"entry":"\u2003\u2003\u2003\u2003|"},{"entry":"\u2003\u2003\u2003\u2003|---- XMCDrv_<n>"},{"entry":"\u2003\u2003\u2003\u2003\u2003 \u2003\u2003|---- "},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"It should be clear from the foregoing that the present invention may be embodied in other specific forms without departing from the essential characteristics thereof. The present embodiments are therefore to be considered in all respects as illustrative and not restrictive, the scope of the invention being indicated by the appended claims rather than by the foregoing description; all changes which come within the meaning and range of equivalency of the claims are therefore intended to be embraced therein."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIGS. 4 through 8","FIG. 2"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 9","FIG. 2"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 11","FIG. 1"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 12","FIG. 11"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIGS. 13 through 20","FIG. 11"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 21","FIG. 11"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 22","FIG. 1"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 23","FIG. 22"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIGS. 24 through 32","FIG. 22"]},{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 33","FIG. 22"]},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 34","FIG. 1"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 35","FIG. 34"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIGS. 36 through 38","FIG. 34"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 39","FIG. 34"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 40","FIG. 1"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 41","FIG. 40"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIGS. 42 through 49","FIG. 40"]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 50","FIG. 40"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 51","FIG. 1"]},{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 52","FIG. 51"]},{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIGS. 53 through 57","FIG. 51"]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 58"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 59","FIG. 58"],"b":"44"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIGS. 60-65"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 66","b":"44"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 67","b":"44"}]},"DETDESC":[{},{}]}
