---
title: System and method for formatting data for transmission between an embedded computer and a host computer having different machine characteristics
abstract: A system and method for providing seamless communication with threads executing on an embedded computer. Using a DAT system, a programmer can test the communication interfaces of a thread via either a scripting program, any COM-compliant program, or a graphical test utility. The DAT system automatically formats a block of data that is transmitted between the embedded computer and a host computer and accounts for machine specific enumeration sizes, machine specific pointer sizes, machine specific structure alignment boundaries, machine specific integer sizes, and machine specific byte ordering.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07111302&OS=07111302&RS=07111302
owner: S2 Technologies, Inc.
number: 07111302
owner_city: Cardiff
owner_country: US
publication_date: 20020322
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF CERTAIN EMBODIMENTS OF THE INVENTION"],"p":["This application claims priority to, and incorporates by reference, in their entirety, the following applications: U.S. Provisional Application No. 60,278,212, filed Mar. 23, 2001, titled \u201cSYSTEM FOR DEBUGGING AND TRACING THE PERFORMANCE OF SOFTWARE TARGETED FOR EMBEDDED SYSTEMS\u201d and U.S. Provisional Application No. 60\/299,555, filed Jun. 19, 2001, titled \u201cMESSAGING SYSTEM AND PROCESS\u201d, and U.S. Provisional Application No. 60\/363,436, filed Mar. 11, 2002, titled \u201cDEVELOPMENT AND TESTING SYSTEM AND METHOD.\u201d","This application is related to and incorporates by reference in their entirety, the following commonly owned patent applications that have been filed on even date herewith: U.S. patent application Ser. No. 10\/104,989, titled \u201cSYSTEM AND METHOD FOR BUILDING A DATABASE DEFINING A PLURALITY OF COMMUNICATION INTERFACES\u201d; U.S. patent application Ser. No. 10\/104,985, titled \u201cSYSTEM AND METHOD FOR PROVIDING AN INTERFACE FOR SCRIPTING PROGRAMS TO COMMUNICATE WITH EMBEDDED SYSTEMS\u201d; U.S. patent application Ser. No. 10\/105,062, titled \u201cSYSTEM AND METHOD FOR PROVIDING AN INTERFACE FOR COM-COMPLIANT APPLICATIONS TO COMMUNICATE WITH EMBEDDED SYSTEMS\u201d; U.S. patent application Ser. No. 10\/105,069, titled \u201cSYSTEM AND METHOD FOR GENERATING DATA SETS FOR TESTING EMBEDDED SYSTEMS\u201d; and U.S. patent application Ser. No. 10\/104,997, titled \u201cSYSTEM AND METHOD FOR AUTOMATICALLY GENERATING CODE TEMPLATES FOR COMMUNICATION VIA A PREDEFINED COMMUNICATION INTERFACE\u201d.","1. Field of the Invention","The field of the invention relates to development and testing. More particularly, the field of the invention relates to the development and testing of software.","2. Description of the Related Technology","An embedded device typically includes a microprocessor and application software. The application software runs under the control of a real-time operating system (RTOS) and is typically partitioned into one or more threads. A thread is an independent unit of executable software that shares the control of the microprocessor with other defined threads within the embedded system. In many embedded devices, a thread is allocated its own stack space, given a \u201cpriority\u201d, and assigned other resources that enable the thread to run as an \u201cindependent\u201d entity. Stack space is a section of memory reserved for temporary storage of local variables. Priorities are used by the RTOS to determine which thread gets control of the microprocessor if more than one thread is waiting. Resources can include miscellaneous items such as queues, flags, etc., that are required by the RTOS to manage a thread. Other common terms used for a thread are \u201ctask\u201d and \u201cprocess.\u201d A process also implies a separate address space which protects different processes from adversely affecting each other. An example of a process running on a desktop computer using Microsoft's Windows Operating System (OS) is Microsoft Word.","A common method for threads to communicate with each other is via a messaging application programming interface (API) that is provided by the operating system. A message typically includes an event and optionally a block of data that is sent between at least two threads. For example, a thread (\u201cthe sender\u201d) builds a message and invokes a specific API from the RTOS. The RTOS notifies the other thread (\u201cthe receiver\u201d) that some type of event has occurred. The receiving thread then reads the incoming message. Another common method for threads to communicate is via a function call. Using a function call provided by one thread can be invoked by another thread. Likewise functions can be called by other functions that co-exist in the same thread. Other common terms for a function include a subroutine, a procedure, or a method. As used herein, the term \u201ccommunication interface\u201d is intended to embrace any interface for communicating data between two threads, such as via either messaging or remote function call communication.","There are several problems associated with known development and testing systems for embedded devices as described above. First, known testing systems require the use of the embedded device that has an operational RTOS to test the communication interfaces of the threads and to test the execution of the threads themselves. Disadvantageously, known systems do not have the ability to simulate communication interfaces and the corresponding threads that support them.","Second, when using more than one platform to host running threads, there is a compatibility problem representing interfaces on different machines. Different types of machines store messages differently in their respective memory space. Known testing systems do not automatically format data for transmission to different platforms. An example of incompatibility between two computers is when one computer stores a 16-bit integer (2 bytes) with the least significant byte in low memory (Little Endian) and the other computer stores the least significant byte in high memory (Big Endian). When the applications want to exchange this 16-bit integer, the value of the integer is interpreted differently depending on the computer.","Third, known systems require the creation of a custom desktop tool that can communicate with the embedded software. The process of building interface functionality for a specific embedded application is a time consuming and manual process. The desktop tool and the embedded software both require manual updates to their application to enable them to communicate with each other. Thus, there is no seamless and automatic access via a desktop tool to the interfaces for an embedded software application.","Fourth, desktop applications developed in other programming languages that are incompatible with standard C\/C++ interface definition files cannot interact with the embedded computer seamlessly. Typically, interface definition files define the format of the messages expected by the embedded software. Languages such as Visual Basic, LabVIEW, etc., cannot use standard C interface definition files that define the format of the interfaces. Thus, software engineers that use these languages cannot test the threads executing on the embedded device.","Thus, there is a need for improved devices for development and testing of embedded software that do not have the foregoing limitations.","One aspect of the invention comprises a system for transmitting data. The system comprises: a host computer, a first application executing on the host computer, an embedded computer, a second application executing on the embedded computer, and a database. The database identifies at least one interface characteristic of a plurality of interfaces of the first application and the second application. The database is automatically generated in response to a user request and is based, at least in part, upon an interface description file that is provided by the user.","The system also comprises a communication module that defines an interface for communication with the embedded computer. The first application communicates with the second application via the communication module. The host computer stores host computer machine characteristic information for the embedded computer. The host machine characteristic information includes information selected from the group comprising: an enumeration size, an adaptive enumeration indicator, a short size, a long size, a float size, a double size, a double long size, a pointer size, a structure alignment boundary, an integer size, a byte ordering, a Boolean size, and a character size.","The host computer stores embedded computer machine characteristic information for the host computer. The embedded computer machine characteristic information includes information selected from the group comprising: an enumeration size, a pointer size, a structure alignment boundary, an integer size, and a byte ordering. In response to receiving a communication from the second application that is targeted for the first application, the communication module modifies the communication prior to transmitting the communication to the first application, and wherein the modification is based, at least in part, upon the host computer machine characteristic information, the embedded computer machine characteristic information, and the interface characteristic.","Another aspect of the invention comprises a method of transmitting data. The method comprises automatically generating a database wherein the database includes interface information that describes a plurality of interfaces. The method also comprises receiving a communication from an embedded computer and formatting the communication, based at least upon the interface information and machine characteristic information that describes at least one characteristic of the embedded computer.","Another aspect of the invention comprises a method of transmitting data. The method comprises: receiving a communication from an embedded computer and formatting the received communication, wherein the formatting is based at least in part upon interface information that describes at least one characteristic of the communication and information that describes at least one characteristic of the embedded computer.","The following detailed description is directed to certain specific embodiments of the invention. However, the invention can be embodied in a multitude of different ways as defined and covered by the claims. In this description, reference is made to the drawings wherein like parts are designated with like numerals throughout.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 1","b":["100","100","100"]},"The DAT system  comprises an embedded computer  that is in data communication with a host computer . The embedded computer  executes an embedded computer communication module  that is used to route communications to threads  executing on the embedded computer . The host computer  executes a host computer communication module  that is used to route messages to threads  executing on the host computer . The embedded computer communication module  and the host computer communication module  are able to route to each other messages and\/or other communications sent via other interfaces originating from one platform that are destined for transmission to the other platform. In one embodiment of the invention, all communications from one platform to the other platform are transmitted via the embedded computer communication module  and the host computer communication module .","The embedded computer  can reside on a telephone, a card on a peripheral device, an automobile, a refrigerator, or any other electronic device. The host computer  can include any computing device that includes a display and an input device, e.g., mouse, keyboard.","The host computer  also comprises a communication database  that automatically compiles the embedded and host's interface definition files to capture the \u201ccharacteristics\u201d of a communication interface.","The DAT system  provides a standardized API for messaging and tracing, contains a protocol suite used to implement a seamless messaging and tracing environment, and implements the communication link between the two platforms. In one embodiment of the invention, the API that is provided by the DAT system  includes interfaces for the following: (i) registering a message; (ii) reading a message; (iii) sending command data; (iv) sending response data; (v) broadcasting a message; (vi) subscribing to a message; (vii) returning the list of messages stored in the communication database; (viii) returning the message format of a specific message; and (ix) returning the name and\/or identifier of a specific message. Further exemplary API of the DAT system  are described below.","A studio module  provides a graphical user interface and testing environment for testing the communication interfaces that are identified by the communication database . The DAT system  provides complete visibility and control of all the messages and remote function calls defined by an embedded software application. As an example, using the studio module , a developer can scan the entire list of messages and\/or remote function calls within the database and display them on a screen. Once a specific message or remote function call is selected, the communication database  can be queried to return the element types and names associated with the message.","Upon execution, each of the threads in the embedded computer  and the host computer  register with the DAT system . Registration enables the DAT system  to dynamically route messages without having to \u201chardcode\u201d a routing table. Threads at anytime can call a specific application programming interface \u201cAPI\u201d that is offered by the DAT system  to inform the DAT system  that the requesting thread \u201cowns\u201d a selected message. Owns, in this context, means that the specific thread receives the message anytime another thread and or application sends it. When a request to send a message is issued, the DAT system  determines whether the owning thread is local or on the other platform. If the platform is local, the message is directly routed to the owning thread. If the platform is remote, the message is directly routed to the other platform. If the message originates at the embedded computer , upon receipt, the host computer  formats the message to be compatible with the machine characteristics of the host computer . If the message originates at the host computer , the host computer  formats the messages to be compatible with the machine characteristics of the embedded computer .","The embedded computer communication module , the host computer communication module , and the studio module  each comprise various sub-routines, procedures, definitional statements, and macros. The computer communication module , the host computer communication module , and the studio module  may be written in any programming language such as C, C++, BASIC, Java, Pascal, and Fortran and may be run under the well-known operating system. C, C++, BASIC, Pascal, Java, and Fortran are industry standard programming languages for which many commercial compilers can be used to create executable code.","The embedded computer  may execute under the control of any off-the-shelf or proprietary real-time operating system such as: VxWorks, Nucleus, ThreadX, Windows CE, RTXC, and Embedded Linux.","The host computer  may execute under the control of any off-the-shelf or proprietary operating system, such as: UNIX, LINUX, Disk Operating System (DOS), OS\/2, PalmOS, VxWorks, Windows 3.X, Windows 95, Windows 98, Windows NT, Windows CE, and Windows XP. Each of the threads on embedded computer  and the host computer  can communication respectively with the embedded computer communication module  and the host computer communication module  via a predefined application programming interface API. Set forth below are described certain routines provided by the API. It is to be appreciated that other routines may also be provided.",{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Application Programming Interfaces"},{"entry":"Methods"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Owner Methods"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Broadcast","Broadcasts a response to all subscribed Users."]},{"entry":[{},"(Broadcast message type only)"]},{"entry":["Read Command","Reads the Command sent by a User (One-way &"]},{"entry":[{},"Two-way message types only)"]},{"entry":["Register","Registers ownership of the service associated with"]},{"entry":[{},"the message (One-way & Two-way message types"]},{"entry":[{},"only)"]},{"entry":["Send Response","Sends the response. (Two-way message type only)"]},{"entry":["Un-register","Un-registers ownership of the service. (One-way &"]},{"entry":[{},"Two-way message types only)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"User Methods"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Read Response","Reads the Response sent from the owner. (Two-way"]},{"entry":[{},"and Broadcast message types only)"]},{"entry":["Send and Read","Combines the Send Command and Read Response"]},{"entry":[{},"methods (Two-way message type only)"]},{"entry":["Send Command","Sends the Command to the registered Owner (One-"]},{"entry":[{},"way and Two-way message types only)"]},{"entry":["Subscribe","Subscribes to the service associated with the"]},{"entry":[{},"Message. Once subscribed the Message object will"]},{"entry":[{},"receive all broadcasts sent by any owner of the"]},{"entry":[{},"service. (Broadcast message type only)"]},{"entry":["Un-subscribe","Un-subscribes to the service."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Spy API"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Read Command","Reads (spies on) a copy of a command sent from a"]},{"entry":[{},"User to the Register Owner"]},{"entry":["Read Response","Reads (spies on) a copy of a Response sent from the"]},{"entry":[{},"Owner to the User"]},{"entry":["Register","Register as a spy of the interface to thereafter"]},{"entry":[{},"receive copies of all Commands and Responses sent"]},{"entry":[{},"by Owners and Users of the Service."]},{"entry":["Un-register","Un-register the object as a spy"]},{"entry":["<Dataset methods>","Defined below"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Owner Functions API"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Register","Registers ownership of the service associated with"]},{"entry":[{},"the function"]},{"entry":["Read Parameter List","Reads the Parameter List sent by the Caller"]},{"entry":["Return","Sends the Return Value to the Caller (User)."]},{"entry":["Un-register","Un-registers ownership of the function."]},{"entry":["<Dataset methods>","Defined below"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"User Function API"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Call","Calls the remote function with the Object's"]},{"entry":[{},"Parameter List"]},{"entry":["Read Return Value","Reads the Return Value returned by the Owner."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Spy Function API"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Read Parameter List","Reads (spies on) a copy of the Parameter List sent"]},{"entry":[{},"by the Caller"]},{"entry":["Read Response","Reads (spies on) a copy of the Response sent from"]},{"entry":[{},"the Owner to the User"]},{"entry":["Register","Register the Object as spy of the interface to there-"]},{"entry":[{},"after receive copies of all Calls and Returns made"]},{"entry":[{},"between users and owners of the function."]},{"entry":["Un-register","Un-register the object as a spy."]},{"entry":["<Dataset methods>","Defined below"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Datasets"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Clear All Datasets","Clears\/Deletes all datasets associated with either the"]},{"entry":[{},"Command or Response (Messages), or Input or"]},{"entry":[{},"Output (Functions)"]},{"entry":["Delete Datasets","Deletes a specified number of datasets"]},{"entry":["Insert Datasets","Inserts a specified number of datasets."]},{"entry":["Load Datasets","Loads datasets from the database and associates"]},{"entry":[{},"them with the interface object."]},{"entry":["Store Datasets","Stores the datasets currently associated with the"]},{"entry":[{},"interface object into the database."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Miscellaneous API"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Pointer Setup","Specify the attributes of a the pointer, e.g., IN,"]},{"entry":[{},"IN\/OUT, OUT, pooled, private."]},{"entry":["Pointer Attach","Invoked each time a pointer address or size is"]},{"entry":[{},"modified"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 2","b":["124","124","200","204","124"]},"The information from the interface definition files is organized and stored in the communication database  such that it that can be accessed by other desktop applications via the host computer communication module . An exemplary process of building the communication database  is described below with respect to .","In one embodiment of the invention, the DAT system  provides seamless and automatic ability for an application on the host computer  to make a remote function call to a routine that is on the embedded computer  and vice-versa, without requiring modification of the application other than to link the libraries and header files of the DAT system . An exemplary process of automatically generating code in support of a remote function call is described below with reference to .",{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 3","FIG. 3"],"b":["104","108"]},"With respect to the embodiment of the invention shown in , the DAT system  also comprises a messaging automation component (\u201cMAC\u201d)  and a script engine  for executing a script. In one embodiment of the invention, the MAC  is a COM-compliant object that provides interfaces for performing the following functions: designating ownership of an interface, generating a data set, sending a field of information, sending a data set, receiving a message, and listing each of the messages that are managed by the DAT system . The script engine  can be any proprietary or off-the-shelf engine that supports scripting languages such as: JavaScript, Visual Basic, VBScript, Tcl, JScript, Python, etc.","Set forth below is a description of the various objects that are provided by the MAC  for communication. In one embodiment of the invention, there are 6 classes of interface objects: (i) owner message objects; (ii) user message objects; (iii) spy message objects; (iv) owner function objects; (v) user function objects; and (vi) spy function objects. It is to be appreciated that other type of objects may also be used.","The application programming interfaces of the MAC  are set forth below.",{"@attributes":{"id":"p-0073","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Owner Message Object"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Methods",{}]},{"entry":["Broadcast","Broadcasts a response to all subscribed Users."]},{"entry":[{},"(Broadcast message type only)"]},{"entry":["Read Command","Reads the Command sent by a User (One-way &"]},{"entry":[{},"Two-way message types only)"]},{"entry":["Register","Registers ownership of the service associated with"]},{"entry":[{},"the message (One-way & Two-way message types"]},{"entry":[{},"only)"]},{"entry":["Send Response","Sends the response. (Two-way message type only)"]},{"entry":["Un-register","Un-registers ownership of the service. (One-way &"]},{"entry":[{},"Two-way message types only)"]},{"entry":["<Dataset methods>","Defined below"]},{"entry":"Properties"},{"entry":["Name","Name of the Interface"]},{"entry":["SUID","STRIDE Unique Identifier for the Interface"]},{"entry":["Command Payload","Command payload of the Message Object."]},{"entry":["Response Payload","Response payload of the Message Object."]},{"entry":["Out Pointer Data","Out pointer data-defined as part of the Command"]},{"entry":[{},"payload, populated as apart of the Response."]},{"entry":["<Dataset properties>","Defined below"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"User Message Object"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Methods",{}]},{"entry":["Read Response","Reads the Response sent from the owner. (Two-way"]},{"entry":[{},"and Broadcast message types only)"]},{"entry":["Send and Read","Combines the Send Command and Read Response"]},{"entry":[{},"methods (Two-way message type only)"]},{"entry":["Send Command","Sends the Command to the registered Owner"]},{"entry":[{},"(One-way and Two-way message types only)"]},{"entry":["Subscribe","Subscribes to the service associated with the"]},{"entry":[{},"Message. Once subscribed the Message object will"]},{"entry":[{},"receive all broadcasts sent by any owner of the"]},{"entry":[{},"service. (Broadcast message type only)"]},{"entry":["Un-subscribe","Un-subscribes to the service."]},{"entry":["<Dataset methods>","Defined below"]},{"entry":"Properties"},{"entry":["Name","Name of the Interface"]},{"entry":["SUID","STRIDE Unique Identifier for the Interface"]},{"entry":["Command Payload","Command payload of the Message Object."]},{"entry":["Response Payload","Response payload of the Message Object."]},{"entry":["Out Pointer Data","Out pointer data-defined as part of the Command"]},{"entry":[{},"payload, populated as apart of the Response."]},{"entry":["<Dataset properties>","Defined below"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Spy Message Object"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Methods",{}]},{"entry":["Read Command","Reads (spies on) a copy of a command sent from"]},{"entry":[{},"a User to the Register Owner"]},{"entry":["Read Response","Reads (spies on) a copy of a Response sent from"]},{"entry":[{},"the Owner to the User"]},{"entry":["Register","Register as a spy of the interface to thereafter"]},{"entry":[{},"receive copies of all Commands and Responses sent"]},{"entry":[{},"by Owners and Users of the Service."]},{"entry":["Un-register","Un-register the object as a spy"]},{"entry":["<Dataset methods>","Defined below"]},{"entry":"Properties"},{"entry":["Name","Name of the Interface"]},{"entry":["SUID","STRIDE Unique Identifier for the Interface"]},{"entry":["Command Payload","Command payload of the Message Object."]},{"entry":["Response Payload","Response payload of the Message Object."]},{"entry":["Out Pointer Data","Out pointer data-defined as part of the Command"]},{"entry":[{},"payload, populated as apart of the Response."]},{"entry":["<Dataset properties>","Defined below"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Owner Function Object"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Methods",{}]},{"entry":["Register","Registers ownership of the service associated with"]},{"entry":[{},"the function"]},{"entry":["Read Parameter List","Reads the Parameter List sent by the Caller"]},{"entry":["Return","Sends the Return Value to the Caller (User)."]},{"entry":["Un-register","Un-registers ownership of the function."]},{"entry":["<Dataset methods>","Defined below"]},{"entry":"Properties"},{"entry":["Name","Name of the Interface"]},{"entry":["SUID","STRIDE Unique Identifier for the Interface"]},{"entry":["Parameter List","List of parameters for the Function Object."]},{"entry":["Return Value","Return value for the Function Object."]},{"entry":["Out Pointer Data","Out pointer data-defined as part of the Parameter"]},{"entry":[{},"List, populated as apart of the Output."]},{"entry":["<Dataset properties>","Defined below"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"User Function Object"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Methods",{}]},{"entry":["Call","Calls the remote function with the Object's"]},{"entry":[{},"Parameter List"]},{"entry":["Read Return Value","Reads the Return Value returned by the Owner."]},{"entry":["<Dataset methods>","Defined below"]},{"entry":"Properties"},{"entry":["Name","Name of the Interface"]},{"entry":["SUID","STRIDE Unique Identifier for the Interface"]},{"entry":["Parameter List","List of parameters for the Function Object."]},{"entry":["Return Value","Return value for the Function Object."]},{"entry":["Out Pointer Data","Out pointer data-defined as part of the Parameter"]},{"entry":[{},"List, populated as apart of the Output."]},{"entry":["<Dataset properties>","Defined below"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Spy Function Object"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Methods",{}]},{"entry":["Read Parameter List","Reads (spies on) a copy of the Parameter List sent"]},{"entry":[{},"by the Caller"]},{"entry":["Read Response","Reads (spies on) a copy of the Response sent from"]},{"entry":[{},"the Owner to the User"]},{"entry":["Register","Register the Object as spy of the interface to there-"]},{"entry":[{},"after receive copies of all Calls and Returns made"]},{"entry":[{},"between users and owners of the function."]},{"entry":["Un-register","Un-register the object as a spy."]},{"entry":["<Dataset methods>","Defined below"]},{"entry":"Properties"},{"entry":["Name","Name of the Interface"]},{"entry":["SUID","STRIDE Unique Identifier for the Interface"]},{"entry":["Parameter List","List of parameters for the Function Object."]},{"entry":["Return Value","Return value for the Function Object."]},{"entry":["Out Pointer Data","Out pointer data-defined as part of the Parameter"]},{"entry":[{},"List, populated as apart of the Output."]},{"entry":["<Dataset properties>","Defined below"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Datasets"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Methods",{}]},{"entry":["Clear All Datasets","Clears\/Deletes all datasets associated with either"]},{"entry":[{},"the Command or Response (Message Objects), or"]},{"entry":[{},"Input or Output (Function Objects)"]},{"entry":["Delete Datasets","Deletes a specified number of datasets"]},{"entry":["Insert Datasets","Inserts a specified number of datasets."]},{"entry":["Load Datasets","Loads datasets from the database and associates"]},{"entry":[{},"them with the interface object."]},{"entry":["Store Datasets","Stores the datasets currently associated with the"]},{"entry":[{},"interface object into the database."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In one embodiment, for message objects, datasets are sets of data associated with either the command (command payload) or response (response payload and out pointer data). One-way messages have command datasets, broadcast messages have response datasets, and two-way messages have both. For function objects, datasets are associated with either the input (parameter list) and\/or the output (return value and out pointer data).","Scripting languages allow developers to customize, automate testing, and add macro capabilities. Scripting languages, in general, are easy to use for this type of functionality. Scripting languages also contain much of the same capability found in compiled languages such as loops, conditional statements, etc. A script program is text written in a script language that is executed by a script engine. The messaging automation component  provides a script program seamless and instant access to the communication interfaces of each of the threads in the embedded computer  and the host computer . Using the messaging automation component , fields in a message or parameters in a remote function call can be set, read, tested against, or used in expressions. Via the messaging automation component , the scripting program can also transmit and receive communications seamlessly with software running on either an embedded computer  or the host computer . Furthermore, establishing such communication does not require code changes of the threads executing on either the embedded computer  and\/or the host computer .","In one embodiment of the invention, the script program is launched via an interface that is provided by the studio module . In another embodiment of the invention, the script program does not have to be launched by the studio module , but instead, can be launched and communicate directly with the host computer communication module .",{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIGS. 4A and 4B","b":["312","114","104","108","404","3","404","124","6","9","11","408","412","416"]},{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 5","b":["504","508","512","116"]},"The generated component  provides the COM-compliant application  seamless and instant access to the communication interfaces of an embedded application through predefined API. Using the generated component , the COM-compliant application  seamlessly communicates with threads executing on the embedded computer  and the host computer . The host computer communication platform  automatically formats communication in a form suitable for its destination. An exemplary process of formatting a communication is described below with reference to .","Set forth below is a description of the application programming interfaces that are provided by the generated component .",{"@attributes":{"id":"p-0081","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Owner Message Object"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Methods",{}]},{"entry":["Broadcast","Broadcasts a response to all subscribed Users."]},{"entry":[{},"(Broadcast message type only)"]},{"entry":["Read Command","Reads the Command sent by a User (One-way &"]},{"entry":[{},"Two-way message types only)"]},{"entry":["Register","Registers ownership of the service associated with"]},{"entry":[{},"the message (One-way & Two-way message types"]},{"entry":[{},"only)"]},{"entry":["Send Response","Sends the response. (Two-way message type only)"]},{"entry":["Un-register","Un-registers ownership of the service. (One-way &"]},{"entry":[{},"Two-way message types only)"]},{"entry":["<Dataset methods>","Defined below"]},{"entry":"Properties"},{"entry":["Name","Name of the Interface"]},{"entry":["SUID","STRIDE Unique Identifier for the Interface"]},{"entry":["Command Payload","Command payload of the Message Object."]},{"entry":["Response Payload","Response payload of the Message Object."]},{"entry":["Out Pointer Data","Out pointer data-defined as part of the Command"]},{"entry":[{},"payload, populated as apart of the Response."]},{"entry":["<Dataset properties>","Defined below"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"User Message Object"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Methods",{}]},{"entry":["Read Response","Reads the Response sent from the owner. (Two-way"]},{"entry":[{},"and Broadcast message types only)"]},{"entry":["Send and Read","Combines the Send Command and Read Response"]},{"entry":[{},"methods (Two-way message type only)"]},{"entry":["Send Command","Sends the Command to the registered Owner"]},{"entry":[{},"(One-way and Two-way message types only)"]},{"entry":["Subscribe","Subscribes to the service associated with the"]},{"entry":[{},"Message. Once subscribed the Message object will"]},{"entry":[{},"receive all broadcasts sent by any owner of the"]},{"entry":[{},"service. (Broadcast message type only)"]},{"entry":["Un-subscribe","Un-subscribes to the service."]},{"entry":["<Dataset methods>","Defined below"]},{"entry":"Properties"},{"entry":["Name","Name of the Interface"]},{"entry":["SUID","STRIDE Unique Identifier for the Interface"]},{"entry":["Command Payload","Command payload of the Message Object."]},{"entry":["Response Payload","Response payload of the Message Object."]},{"entry":["Out Pointer Data","Out pointer data-defined as part of the Command"]},{"entry":[{},"payload, populated as apart of the Response."]},{"entry":["<Dataset properties>","Defined below"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Spy Message Object"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Methods",{}]},{"entry":["Read Command","Reads (spies on) a copy of a command sent from"]},{"entry":[{},"a User to the Register Owner"]},{"entry":["Read Response","Reads (spies on) a copy of a Response sent from"]},{"entry":[{},"the Owner to the User"]},{"entry":["Register","Register as a spy of the interface to thereafter"]},{"entry":[{},"receive copies of all Commands and Responses sent"]},{"entry":[{},"by Owners and Users of the Service."]},{"entry":["Un-register","Un-register the object as a spy"]},{"entry":["<Dataset methods>","Defined below"]},{"entry":"Properties"},{"entry":["Name","Name of the Interface"]},{"entry":["SUID","STRIDE Unique Identifier for the Interface"]},{"entry":["Command Payload","Command payload of the Message Object."]},{"entry":["Response Payload","Response payload of the Message Object."]},{"entry":["Out Pointer Data","Out pointer data-defined as part of the Command"]},{"entry":[{},"payload, populated as apart of the Response."]},{"entry":["<Dataset properties>","Defined below"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Owner Function Object"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Methods",{}]},{"entry":["Register","Registers ownership of the service associated with"]},{"entry":[{},"the function"]},{"entry":["Read Parameter List","Reads the Parameter List sent by the Caller"]},{"entry":["Return","Sends the Return Value to the Caller (User)."]},{"entry":["Un-register","Un-registers ownership of the function."]},{"entry":["<Dataset methods>","Defined below"]},{"entry":"Properties"},{"entry":["Name","Name of the Interface"]},{"entry":["SUID","STRIDE Unique Identifier for the Interface"]},{"entry":["Parameter List","List of parameters for the Function Object."]},{"entry":["Return Value","Return value for the Function Object."]},{"entry":["Out Pointer Data","Out pointer data-defined as part of the Parameter"]},{"entry":[{},"List, populated as apart of the Output."]},{"entry":["<Dataset properties>","Defined below"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"User Function Object"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Methods",{}]},{"entry":["Call","Calls the remote function with the Object's"]},{"entry":[{},"Parameter List"]},{"entry":["Read Return Value","Reads the Return Value returned by the Owner."]},{"entry":["<Dataset methods>","Defined below"]},{"entry":"Properties"},{"entry":["Name","Name of the Interface"]},{"entry":["SUID","STRIDE Unique Identifier for the Interface"]},{"entry":["Parameter List","List of parameters for the Function Object."]},{"entry":["Return Value","Return value for the Function Object."]},{"entry":["Out Pointer Data","Out pointer data-defined as part of the Parameter"]},{"entry":[{},"List, populated as apart of the Output."]},{"entry":["<Dataset properties>","Defined below"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Spy Function Object"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Methods",{}]},{"entry":["Read Parameter List","Reads (spies on) a copy of the Parameter List sent"]},{"entry":[{},"by the Caller"]},{"entry":["Read Response","Reads (spies on) a copy of the Response sent from"]},{"entry":[{},"the Owner to the User"]},{"entry":["Register","Register the Object as spy of the interface to there-"]},{"entry":[{},"after receive copies of all Calls and Returns made"]},{"entry":[{},"between users and owners of the function."]},{"entry":["Un-register","Un-register the object as a spy."]},{"entry":["<Dataset methods>","Defined below"]},{"entry":"Properties"},{"entry":["Name","Name of the Interface"]},{"entry":["SUID","STRIDE Unique Identifier for the Interface"]},{"entry":["Parameter List","List of parameters for the Function Object."]},{"entry":["Return Value","Return value for the Function Object."]},{"entry":["Out Pointer Data","Out pointer data-defined as part of the Parameter"]},{"entry":[{},"List, populated as apart of the Output."]},{"entry":["<Dataset properties>","Defined below"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Datasets"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Methods",{}]},{"entry":["Clear All Datasets","Clears\/Deletes all datasets associated with either"]},{"entry":[{},"the Command or Response (Message Objects), or"]},{"entry":[{},"Input or Output (Function Objects)"]},{"entry":["Delete Datasets","Deletes a specified number of datasets"]},{"entry":["Insert Datasets","Inserts a specified number of datasets."]},{"entry":["Load Datasets","Loads datasets from the database and associates"]},{"entry":[{},"them with the interface object."]},{"entry":["Store Datasets","Stores the datasets currently associated with the"]},{"entry":[{},"interface object into the database."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"It is noted, that in one embodiment, the MAC , the studio module , the generated component , can be utilized together to provide a communication system for various types of applications. For example, using the application programming interface of the MAC , a scripting program in a first language can communicate with a scripting program in the same or a second language, a COM-compliant application  via the generated component , a thread executing on the embedded computer , a thread executing on the host computer , and the studio module .","Furthermore, for example, using the application programming interface of the generated component , a COM-compliant application can communicate with a scripting program via the MAC , another COM-compliant application, a thread executing on the embedded computer , a thread executing on the host computer , and the studio module .","Furthermore, for example, using the studio , a user can send and receive messages to and from the COM-compliant application , a scripting program, a thread executing on the host computer , a thread executing on the embedded computer .",{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 6","b":"124"},"The communication database  includes a platform-specific configuration section . The platform-specific configuration section  contains embedded computer machine characteristics and host computer machine characteristics. The characteristics can include items, such as: an indication of whether the platform is big or little Endian, enumeration sizes, pointer sizes, structure alignment boundaries, etc. It is noted that in one embodiment of the invention, the embedded computer machine characteristics and the host computer machine characteristics are stored in a location other than the communication database , such as the host computer communication module  or the embedded computer .","The communication database  also includes a messages section  and a prototypes section . The messages section  and the prototypes section  respectively describe the characteristics of each of the messages and remote function calls on the embedded computer  and the host computer . The characteristics can include: (i) the unique name and or identifier of the message; (ii) the total size of the message; (iii) the type of the communication, e.g., one-way message, two-way message, broadcast message, remote function call; and (iv) the types of data are passed as part of the communication. A one way message is sent from a \u201cuser\u201d of the communication to the \u201cowner\u201d of the communication. A thread can request ownership of a message via a registration routine that is provided via an application programming interface of the host computer communication module . A two way message comprises a \u201ccommand\u201d that is sent from the user to the owner and a \u201cresponse\u201d that is sent from the owner to the user. A broadcast message is sent to all threads that have registered to receive the broadcast.","The communication database  also includes a trace points section  for maintaining trace points. The communication database  also includes a description of the data types that are supported by the messages identified in the messaging section  and the functions listed in the prototypes section .","The data types section  includes: (i) a description of the data types in the data structures that are part of a message or remote function call, e.g., integer, character, Boolean, floating-point, arrays, etc; (ii) the field name of each of the elements in each of the messages; (iii) and a description of characteristics of embedded pointers that may be part of the message.",{"@attributes":{"id":"p-0090","num":"0089"},"figref":["FIG. 7","FIG. 7"],"b":["508","512","508","704","704","512","124","708","1","712","2","512","104"]},{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 8","b":["100","804","100"]},"Next, at a step , the programmer adds API calls to invoke a read method that is provided by the DAT system . Continuing to a step , the programmer adds, where applicable, API calls to invoke a send method that is provided by the DAT system .","Continuing to a state , the programmer adds API calls to \u201csubscribe\u201d to a message. Subscribing to a message allows a subscriber to bind to a specific message and thereafter receive all broadcast transmissions. Other messaging APIs may be provided by the DAT system  such as for the following: sending a command; sending a response; broadcasting a message; and defining the data (content) and meta-data (characteristics) of the payload of a message.",{"@attributes":{"id":"p-0094","num":"0093"},"figref":["FIG. 9","FIG. 9"],"b":"124"},"Starting at a state , the studio module  reads and extracts information from each of a plurality of interface definition files that are provided by the user. Next, at a step , the studio module  extracts the communication interfaces from each of the interface definition files. Information that is extracted can include: (i) the type of the communication, e.g., one-way, two-way, broadcast, remote function call; (ii) the types of data are passed as part of the communication; (iii) a description of the data types in the data structures that are part of a message or remote function call, e.g., integer, character, Boolean; (iv) a description of characteristics of embedded pointers that may be part of the message, e.g., whether the memory is \u201cpooled\u201d or \u201cprivate\u201d, a method of transmitting the memory that is associated with the communication interface, and pointer data that is associated with the communication interface.","Next at a step , the studio module  stores the embedded computer machine characteristics. The embedded computer machine characteristics can be provided by user entry, automatic diagnosis of the embedded computer , or automatically provided by the embedded computer . Examples of the embedded computer machine characteristics are described above with respect to . In one embodiment, it is assumed that these characteristics are fixed, i.e., exactly the same on each connection.","Proceeding to a step , the studio module  stores the host computer machine characteristics. The host computer machine characteristics can be provided by user entry or automatic diagnosis of the host computer . Examples of the host computer machine characteristics are described above with respect to .",{"@attributes":{"id":"p-0098","num":"0097"},"figref":"FIG. 10","b":["100","1004","100","1008"]},"Continuing to a step , the DAT system  formats the payload for transmission to its destination thread. It is noted that if the destination thread is local to the transmitting thread, then formatting may be unnecessary. An exemplary process of formatting data for transmission to a remote platform is described below with reference to . Moving to a step , the DAT system  transmits the formatted payload to the destination thread.",{"@attributes":{"id":"p-0100","num":"0099"},"figref":["FIG. 11","FIG. 11","FIG. 11"],"b":["116","100","108","104"]},"The use of the process shown in  provides interoperability between applications communicating with each other on distributed heterogeneous computing platforms. In one embodiment of the invention, to reduce processing and memory requirements on embedded devices, the DAT system  performs all data formatting on the host computer .","The host computer  uses the platform characteristics of the embedded computer  and the host computer  and the individual interface definition information (\u201cthe communication interface information\u201d) to properly map messages when two applications on the different computers are communicating. In one embodiment, the embedded computer  always sends and receives messages in its native form, i.e., the form in which the message is stored in its memory. The host computer  maps these messages into its form when receiving them, and transforms the messages into the embedded computer  platform's native form when transmitting the messages to the embedded computer .","Starting at a decision state , the host computer communication module  determines whether the destination thread is local or remote. If the thread is local, the process proceeds to a step  and the payload is queued for transmission to the destination thread. If the transmission is local, no further modification of the payload is necessary.","Referring again to the decision step , if the destination thread is not local, the process proceeds to a step , wherein the host computer communication module  copies data in payload and data referenced by pointers into a message for transmission to the embedded computer . An exemplary process of managing pointer data is described in further detail below with reference to , B, C, and D.","Continuing to a step , the host computer communication module  formats, if necessary, the byte order of the elements in data in the payload. For example, if the host computer  is Big Endian, and the embedded computer  is Little Endian, or vice-versa, the host computer communication module  reverses the order of the bits in the data.","Proceeding to a step , the host computer communication module  formats the size of the data types in the payload. For example, if the embedded computer  uses a certain bit-length for certain data types and the host computer uses a different bit-length, the host computer communication module  adjusts the size of the data for transmission to the other platform. Moving to a step , the host computer communication module  adjusts alignment of the data structures according to any requirement of the receiving platform.",{"@attributes":{"id":"p-0107","num":"0106"},"figref":["FIGS. 12A\u201312D","FIG. 12A","FIG. 12A","FIG. 12","FIG. 12"],"b":["104","116","112","112","112","116"]},"Before starting at a state , a thread on the embedded computer  has invoked a send command that is part of the application programming interface of the embedded computer communication module . In response, the embedded computer communication module  has built and then transmitted an inter-platform message to the host computer communication module . The inter-platform message includes the payload that was identified as part of the send command and, if applicable, the data that is referenced by the pointers in the payload.","Starting at a step , the host computer communication module  gets the embedded pointer attributes of a selected pointer in the payload of the transmitted communication. In one embodiment of the invention, the attribute information is stored in the transmitted communication. A first attribute of each pointer is whether the pointer is classified as \u201cIN\u201d, \u201cOUT\u201d, or \u201cIN\/OUT\u201d. The \u201cIN\u201d attribute designates that the data referenced by the pointer is passed from the sender of the command to the owner of the message but no data is to be returned by the owner of the message. The \u201cOUT\u201d attributes designates that the sender of the command will not transmit any data that is referenced by the pointer but data will be returned by the owner and stored in the address referenced by the pointer. The \u201cIN\/OUT\u201d attribute indicates that the data that is referenced by the pointer will be sent from the sender of the command and that the owner of the message will return data that is stored in the memory referenced by the pointer.","A second attribute of each pointer is whether the pointer is \u201cprivate\u201d or \u201cpooled.\u201d Management (freeing of the memory when not in use) of \u201cprivate\u201d memory is handled by the DAT system . Management of \u201cpooled\u201d memory is handled by the user and\/or the owner of a message.","Continuing to a step , the host computer communication module  creates a local buffer to hold the pointer data. Continuing to a decision step , the host computer communication module  determines whether the pointer attribute is either \u201cIN\u201d or \u201cIN\/OUT\u201d. If the pointer attribute is \u201cIN\u201d or \u201cIN\/OUT\u201d, the process proceeds to a step . Continuing to a step , the host computer communication module  copies the pointer data that was transmitted from the embedded computer  into the local buffer. At this step, the host computer communication module  formats the pointer data in accordance with the process described above with reference to steps , , and .","Next, at a step , the host computer communication module  copies the address of the buffer into the payload. Proceeding to a decision step , the host computer communication module  determines whether the first attribute of the pointer is \u201cIN\u201d. If the first attribute of the pointer is \u201cIN\u201d the process proceeds to a decision step . At the decision step , the host computer communication module  determines whether the second attribute of the pointer is \u201cprivate\u201d. If the second attribute of the pointer is private, the process proceeds to a step . Otherwise if the second attribute of the pointer is not private, i.e., pooled, the process ends.","Referring again to the decision step , if the first attribute is not \u201cIN\u201d or \u201cIN\/OUT\u201d, the attribute is the \u201cOUT\u201d and the process proceeds to a step . At the step , the host computer communication module  copies the address of the local buffer into the payload. From step , or from decision step  (if the first attribute is \u201cIN\/OUT\u201d), the process proceeds to a step . At this step, the host computer communication module  waits for thread on the host computer  to invoke a response command that is provided by the application programming interface of the DAT system . Upon receiving the response, the process proceeds to a step . At this step, the response data is formatted for transmission to the embedded computer .","From either step  or from the decision step  (if the second attribute of the pointer is \u201cprivate\u201d), the process proceeds to a step  wherein the host computer communication module  waits for a thread on the host computer  to invoke a read complete command that is in the application programming interface of the host computer communication module . Upon receipt of the read complete command, the process proceeds to a step  wherein the host computer communication module frees the memory.",{"@attributes":{"id":"p-0115","num":"0114"},"figref":["FIG. 12B","FIG. 12B","FIG. 11","FIG. 12B"],"b":["108","104","111","104","108","112","116"]},"Starting at a step , the host computer communication module  creates a buffer to hold an inter-platform message for transmission to the embedded computer . Also, at this step, the host computer communication module  creates a header in the inter-platform message for the embedded pointer. Furthermore, at this step, the host computer communication module  stores the pointer attributes of the pointer in the inter-platform message.","Continuing to a decision step , the host computer communication module  determines whether the pointer attribute of the pointer is \u201cOUT\u201d. If the attributes of a selected pointer is \u201cOUT\u201d, the process ends. However, if the pointer attribute is not \u201cOUT\u201d, i.e., it is \u201cIN\u201d or \u201cIN\/OUT\u201d, the process proceeds to step . At the step , host computer communication module  copies the data referenced by the pointer into the header. Furthermore, the host computer communication module  formats the data for use by a thread on the embedded computer . For example, the host computer communication module performs the steps described above with respect to steps , , and .","Next, at a decision step , the host computer communication module  determines whether the pointer attributes is \u201cIN.\u201d If the pointer attribute is \u201cIN\u201d, the process proceeds to a step . At this step, the host computer communication module  frees the memory, if warranted, i.e., the attributes of the pointer designate \u201cpool\u201d. However, if the pointer attribute is not \u201cIN\u201d, the proceeds ends.",{"@attributes":{"id":"p-0119","num":"0118"},"figref":["FIG. 12C","FIG. 12C","FIG. 11","FIG. 12C"],"b":["112","111","104","104","108","112","116"]},"Before starting at a state , a thread on the embedded computer  has invoked a send response command that is part of the application programming interface of the embedded computer communication module . In response, the embedded computer communication module  has built and then transmitted an inter-platform message to the host computer communication module . The inter-platform message includes the payload that was identified as part of the send response and, if applicable, the data that is referenced by the pointers in the payload.","Starting at a decision step , the host computer communication module  determines whether the pointer attributes of the pointer in the inter-platform message designate the attribute \u201cIN\u201d. If the pointer attributes designate the attribute \u201cIN\u201d, the process proceeds to a step , and the host computer communication module  formats the received data for use with the host computer . For example, in one embodiment, the host computer communication module  performs the steps described above with respect to steps , , and .","However, if the pointer attributes do not designate \u201cIN\u201d, i.e., the pointer attributes designate \u201cIN\/OUT\u201d or \u201cOUT\u201d, the process proceeds to a step . At the step , the host computer communication module  creates a local buffer to store the pointer data that was transmitted by the embedded computer . Continuing to a step , the host computer communication module  copies the pointer data from the inter-platform communication into the local buffer. Next, at step , the host computer communication module  copies the address of the buffer into the received payload.","Proceeding to a decision step , the host computer communication module  determines whether it should free the pointer. In one embodiment of the invention, this is determined by reading the pointer attributes. If the pointer attributes designate \u201cprivate\u201d the host computer communication module  decides to free the memory. However, if the pointer attributes designate \u201cpooled\u201d the host computer communication module  allows the user to free the memory.","If the host computer communication module  determines in step  to free the memory, the process proceeds to a step , wherein the host computer communication module  waits for a thread on the host computer  to invoke the read complete command. Continuing to a step , the host computer communication module  frees the local buffer. From either decision step  (if the host computer communication module  does not free the pointer) or the step  the process ends.",{"@attributes":{"id":"p-0125","num":"0124"},"figref":["FIG. 12D","FIG. 12D","FIG. 11","FIG. 12D"],"b":["108","104","1112","104","104","112","116"]},"Before starting, a thread on the embedded computer  has sent a command message and a thread on the host computer  has responded by invoking the send response routine of API of the DAT system .","Starting at a step , the host computer communication module  allocates space in an outgoing buffer (\u201ca header\u201d) to store the data that is referenced by the pointer. The outgoing buffer is part of an inter-platform message that is sent from the host computer communication module  to the embedded computer communication module . Proceeding to a decision step , the host computer communication module  determines whether the pointer attributes designate \u201cIN\u201d. If the pointer attributes do designate \u201cIN\u201d, i.e., they do not designate \u201cOUT\u201d or \u201cIN\/OUT\u201d, the process proceeds to a decision step . At the decision step , the host computer communication module  determines whether to free memory that is associated with the memory that was allocated during the corresponding send command. In one embodiment of the invention, this is determined by reading the pointer attributes. If the pointer attributes designate \u201cpool\u201d the host computer communication module  decides to free the memory. However, if the pointer attributes designate \u201cprivate\u201d the host computer communication module  allows the user to own and eventually free the memory (via an routine provided by the local operating system). If the host computer communication module  determines it should free the memory, the process proceeds to a step , and the host computer communication module  frees the memory. From either step  or decision step  (if the pointer attributes does not designate \u201cIN\u201d), the process proceeds to a step  and the host computer communication module  formats the data referenced by the pointer for transmission to the embedded computer. For example, in one embodiment, the host computer communication module  performs the steps described above with respect to steps , , and . As part of the formatting, the formatted data is stored in the header (step ).",{"@attributes":{"id":"p-0128","num":"0127"},"figref":"FIG. 13","b":["100","312","1304","128","1312"]},"Moving to a step , the studio module  identifies the corresponding script engine  that is associated with the script type. Continuing to a step , the studio module  initializes the script engine .","Next, at a step , the studio module  loads the messaging automation component (\u201cMAC\u201d) . The process of loading the MAC  is described below with reference to . Proceeding to a step , the MAC  is \u201cexposed\u201d to the script engine . In one embodiment of the invention, exposing the MAC  includes providing the script engine  a handle to the MAC . Next, at a step , the script engine is launched, allowing the script loaded in a step  to access the API of MAC . Moving to a step , a script program can communicate with threads  using the API of the MAC . An exemplary process of using the MAC  is described below with respect to .",{"@attributes":{"id":"p-0131","num":"0130"},"figref":["FIG. 14","FIG. 14","FIG. 13"],"b":["304","1324","1404","128","304","124","1408","304","114","304"]},{"@attributes":{"id":"p-0132","num":"0131"},"figref":["FIGS. 15\u201317","FIG. 15"],"b":["308","304","1504","312","304","1508","116"]},{"@attributes":{"id":"p-0133","num":"0132"},"figref":"FIG. 16A","b":["304","1604","1606"]},"Continuing to a step , the MAC database object retrieves the message definition information from the communication database . In one embodiment of the invention, the message definition information is retrieved via the host computer communication module . In another embodiment of the invention, the message definition information is retrieved directly from the communication database . The message definition information includes: (i) the type of the communication, e.g., one-way, two-way, broadcast, remote function call and (ii) the types of data that are passed as part of the communication. Next, at a step , the MAC database object creates a MAC message object based upon the prototype definition retrieved from the communication database .","Proceeding to a step , the MAC database object retrieves any data sets from the communication database that are stored with respect to the requested message object. Next, at a step , the MAC database object adds the data sets to the message object (created in step ).","Moving to a step , the MAC database object returns a reference to the message object to the script. Next, at a step  the script can set the data fields of the message using reference to the message object. The script has access via the MAC database object to a plurality of readable and writeable data sets. At this step, the script can identify one of the data sets for subsequent usage. Continuing to a step , the script invokes a send method of the method object. Proceeding to a step , the MAC database object sends a data set that is referenced by the current index to the thread that owns the message.","Next, at a decision step , the MAC database object determines whether auto-increment is enabled. Auto-increment enables a script to send different data sets with each send command. If auto-increment is enabled, the process proceeds to a step , and the MAC database object selects the next data set. Referring again to the decision step , if auto-increment is not enabled, the process ends.",{"@attributes":{"id":"p-0138","num":"0137"},"figref":"FIG. 16B","b":["304","1650","1654"]},"Continuing to a step , the MAC database object retrieves the remote function call prototype definition information from the communication database . In one embodiment of the invention, the prototype definition information is retrieved via the host computer communication module . In another embodiment of the invention, the message definition information is retrieved directly from the communication database .","Next, at a step , the MAC database object creates a MAC remote function call object based upon the remote function call prototype definition retrieved from the communication database .","Proceeding to a step , the MAC database object retrieves any data sets from the communication database that are stored with respect to the requested remote function call object. Next, at a step , the MAC database object adds the data sets to the MAC remote function call object.","Moving to a step , the MAC database object returns a reference to the remote function call object to the script. Next, at a step , the script can set the data fields (parameters) of the remote function call using the remote function call object. The script has access via the MAC database object to a plurality of readable and writeable data sets. At this step, the script can identify one of the data sets for subsequent usage. Continuing to a step , the script invokes a call method of the remote function call object. Proceeding to a step , the MAC database object sends a data set that is referenced by the current index to the thread that handles the remote function call.","Next, at a decision step , the MAC database object determines whether auto-increment is enabled. Auto-increment enables a script to send different data sets with each send command. If auto-increment is enabled, the process proceeds to a step , and the MAC database object selects the next data set. Referring again to the decision step , if auto-increment is not enabled, the process ends.",{"@attributes":{"id":"p-0144","num":"0143"},"figref":"FIG. 17A","b":"304"},"Starting at a step , the script calls a read method of the MAC database object. Next, at a step , the MAC database object calls a read API of the host computer communication module . Continuing to a step , the host computer communication module  waits for a message to be received. Proceeding to a step , the MAC database object receives the message and a message identifier from the host computer communication module . Next, at a step , the MAC database object returns a message object to the script, which can in turn access the contents of the requested message.",{"@attributes":{"id":"p-0146","num":"0145"},"figref":"FIG. 17B","b":["304","1750","1754","116"]},"Continuing to a step , the MAC database object waits for a remote function call command message to be received. Next, at a step , the MAC database object receives the remote function command message and the function identifier.","Proceeding to a step , a remote function call object is returned to the script program. Next, at a step , the script program access the input parameters of the remote function call object.","Moving to a step , the MAC database object returns a reference to the remote function call object to the script. Next, at a step , the script invokes a return method of the remote function call object. Continuing to a step , the remote function call object calls the send application programming interface of the host computer communication module . Proceeding to a step , the MAC database object sends a data set that is referenced by the current index to the thread that handles the remote function call.","Next, at a decision step , the MAC database object determines whether auto-increment is enabled. Auto-increment enables a script to send different data sets with each send command. If auto-increment is enabled, the process proceeds to a step , and the MAC database object selects the next data set. Referring again to the decision step , if auto-increment is not enabled, the process ends.",{"@attributes":{"id":"p-0151","num":"0150"},"figref":["FIG. 18","FIG. 5","FIG. 19"],"b":["100","1804","504"]},"Next, at a step , the COM composer builds the generated component  (). The generated component  is a COM object that is accessible by other COM compliant programs. Using the generated component , a COM-compliant program can easily: test a interface, send a communication to a thread that is executing on the embedded computer  or the host computer , receive a communication that is sent from a thread this executing on the embedded computer or the host computer , and other functions as described herein. The generated component  provides a plurality of predefined interfaces for performing each of the foregoing functions. An exemplary process of building the generated component  is described below with reference to .","Continuing to a step , the generated component  is accessible via any COM-compliant language. An exemplary process of using the generated component is described below with reference to .",{"@attributes":{"id":"p-0154","num":"0153"},"figref":["FIG. 19","FIG. 19","FIG. 18"],"b":["504","1804"]},"Starting at a step , a user identifies a database. The DAT system  can support multiple databases for multiple projects. Continuing to a step , the user selects which messages or functions of the selected database are to be included in the generated COM object. In one embodiment of the invention, the user selects the messages and\/or remote function calls via a graphical user interface utility.","Proceeding to a step , the user selects the compiler version. The COM composer  needs to know the version of the compiler that is being used to build the generated component  to provide the proper control files in the proper format. Moving to a step , the COM composer  requests the user to designate the type of build, e.g., release or debug.",{"@attributes":{"id":"p-0157","num":"0156"},"figref":["FIG. 20","FIG. 20","FIG. 18"],"b":["508","1808"]},"Starting at a step , the COM composer tool loads the data that was identified by the user (step ) into memory. Next, at a step , the COM composer tool begins a process that is performed with respect to the following: (i) all of the messages and\/or remote function calls identified by the user (step ), (ii) all of the payloads of the identified messages and\/or remote function calls, and (iii) the root object that is used to access all other objects in the generated component . In one embodiment, steps , , , and  are performed for each of the foregoing objects.","At the step , the COM composer  generates a software interface for each of the objects. An exemplary process of generating an interface is described below with reference to . Next, at a step , the generated component generates a COM class definition for the object, otherwise known as a co-class. Proceeding to a step , the COM composer generates a COM class implementation for each of the COM objects. For further information regarding generating software interfaces, COM class definitions, and a COM class implementations, please see the following references, which are each incorporated by reference in their entirety: DON BOX, ESSENTIAL COM (1998), and BRENT RECTOR, CHRIS SELLS & JIM SPRINGFIELD, ATL INTERNALS (1999).","Moving to a decision step , the COM composer  determines whether it has processed all of the messages\/remote function calls, payloads, and the root object. If all of these items have not been processed, the process returns to the step  (discussed above). However, if all of the items have been processed, the COM composer  proceeds to a step  and provides any compiler specific files that are needed, if any.","Next, at a step , the COM composer  launches the selected compiler to build the generated component . In one embodiment of the invention, the COM component is provided in a dynamic link library \u201c.DLL\u201d. Moving to a step , the COM composer  registers the dynamic link library with a registry in the host computer .",{"@attributes":{"id":"p-0162","num":"0161"},"figref":["FIG. 21","FIG. 21","FIG. 20"],"b":"2012"},"Starting at a step , the COM composer  generates method definitions for \u201cbuilt-in\u201d member functions. Next, at a step , the COM composer  generates accessor function for child objects . For example, the children of the root object includes each of the messages and\/or remote function calls. Furthermore, for example, the children of a message object and\/or a remote function call object includes one or more payloads that are associated with the object. Moving to a step , the COM composer  generates interface for setting and getting properties of objects.",{"@attributes":{"id":"p-0164","num":"0163"},"figref":["FIG. 22","FIG. 22","FIG. 18"],"b":["508","1816"]},"Before starting at a step , the user has opened a COM development environment and located the via the COM development environment the generated component .","Starting at the step , the user creates a reference to the generated component . Next, at a step , the user creates an instance of the root object. Moving to a step , the user can use the root object accessor function to retrieve a desired message object or remote function call object. Continuing to a step , the user can use the accessor function of the object to select a desired payload object.","Proceeding to a step , the user invokes a method of the payload object to get or set properties of the payload object. For, example, the user can store data in the payload object. Next, at a step , the user invokes methods on the message object or the remote function call object to send a communication. The user may also invoke other methods on a message object such as register the message such any broadcast on the message is received by the invoking process. Other methods are described above with reference to . Next, at a step , the user implements an event handler to receive asynchronous communications that are received, if any.",{"@attributes":{"id":"p-0168","num":"0167"},"figref":"FIG. 23","b":["128","128","124","2304","124","124","2312","2316","2320","2324"]},{"@attributes":{"id":"p-0169","num":"0168"},"figref":"FIG. 24","b":["100","128","116","312","508"]},"Starting at a step , the user specifies the communication data paths that are to be traced. For example, the DAT system  can trace that data is sent via a message or via a remote function call.","Next, at a step , the DAT system  monitors and stores the data that is transmitted across each of the designated communication paths. In one embodiment of the invention, the data is stored in a persistent test data object. Proceeding to a step , any thread can then select and retrieve the contents of any of persistent test data objects and use the data for testing. Continuing to a step , one of the threads of the DAT system  uses one of the persistent data object to transmit data from one of the selected persistent data object across one of the communication data paths.",{"@attributes":{"id":"p-0172","num":"0171"},"figref":"FIG. 25","b":["2500","128","2500","2504","124","2508","2508","2510","2508","2510","2512"]},"Using the data set fields , the user can build a payload for a particular command message and set the payload of the response message. Furthermore, the user can select a \u201cstore data set\u201d icon  to store the values in the data set fields  in the communication database . Later, the user can select a \u201cload data set\u201d icon  to load the stored values. Furthermore, the user may select a clock icon  to have the studio module  automatically iterate and transmit the data values in sequence at a user configurable time interval.",{"@attributes":{"id":"p-0174","num":"0173"},"figref":["FIG. 26","FIG. 25"],"b":["2600","2608","2610","2610","2600"]},{"@attributes":{"id":"p-0175","num":"0174"},"figref":["FIG. 27","FIG. 27","FIG. 37"],"b":["112","116","128","128","124"]},"Starting at a step , the user identifies one or more interface definition files that define the communication interface. For example, in code block  of  illustrates a portion of an interface definition file.","Continuing to a step , the user selects one or more of the communication interfaces in the selected interface definition files. In one embodiment of the invention, a code generator provides a graphical user interface utility for selection of the communication interfaces.","Next, at a step , a code template of a \u201cthread\u201d is generated for handling each of selected messages in the interface definition file. An exemplary process of generating a thread is described below with reference to . An exemplary template is shown in code block  of .","Moving to a step , a template of a thread is generated for each of the selected functions in the interface definition file. An exemplary process of generating a thread is described below with reference to . An exemplary template is shown in code block  of .",{"@attributes":{"id":"p-0180","num":"0179"},"figref":["FIG. 28","FIG. 28","FIG. 27"],"b":"2716"},"Before starting at a step , a message handling routine is created to handle all messages that have been identified by the user. The message handling routine includes a loop and, subsequent to the loop, a switch statement. See e.g., code block . Starting at a step , a loop is entered and steps , , and  are performed for each of the identified messages. Continuing to a step , the code generator adds a line of code to register each of the messages. See e.g., code block . In one embodiment of the invention, the source code includes code to invoke a registration routine that is provided by the embedded computer communication module  or the host computer communication module . The call to invoke the registration route is placed prior to the generated switch statement.","Next, at a step , the code generator generates message handling code for each of identified messages. An exemplary process of generating message handling code is described below with reference to . Continuing to a step , the code generator creates routines for sending a message. An exemplary process of creating a routing for sending a message is described below with reference to .",{"@attributes":{"id":"p-0183","num":"0182"},"figref":["FIG. 29","FIG. 29","FIG. 28","FIG. 29","FIG. 27"],"b":["2908","2708"]},"Starting at a step , the code generator generates a case statement. Proceeding to a step , the code generator generates a comment to the user to instruct the user to add code.","Proceeding to a decision step , the code generator determines whether the message is \u201ctwo-way\u201d. If the message is \u201ctwo-way\u201d, the process proceeds to a step . Otherwise, the process proceeds to a step .","At the step , the code generator adds code in the generated case statement to invoke a send response routine. As an example, code block  of  includes a call to the \u201cSendMesessageTwoWayResponse\u201d routine. The process of generating a response routine, such as the \u201cSendMesessageTwoWayResponse\u201d routine, is described below with reference to  of . In one embodiment of the invention, the generated code will invoke an API, e.g., SendResponse, of the DAT system . At this step, the code generator may also generate other APIs for convenience of the user, e.g., routines to setup and attach pointers. Moving to a step , the code generator may also generate code to invoke a release routine that is provided by the API.",{"@attributes":{"id":"p-0187","num":"0186"},"figref":["FIG. 30","FIG. 27","FIG. 30","FIG. 28","FIG. 32"],"b":["2708","2812","3008","3010","3010","3208","3012","3016","3016"]},"Referring again to the decision step , the code generator determines whether message is a broadcast message. If the message is a broadcast, the process proceeds to a step . At the step , the code generator adds code to invoke an broadcast routine that is part of the API of the embedded computer communication module  and the host computer communication module . From steps  (if the communication is \u201cone-way\u201d), , and  the process proceeds to a step . At the step , the code generator determines whether there are pointers present in the payload of the message. If pointers are present, the process proceeds to a step . At the step , the code generator generates code to invoke a pointer setup command that is part of the communication library API. Next, at a step , the code generator generates code to invoke the API attach pointer. It is noted that the generated commands during steps  and  are inserted into the generated code prior to the generated send response command (step ).",{"@attributes":{"id":"p-0189","num":"0188"},"figref":"FIG. 31","b":["112","116"]},"Depending on the embodiment, additional steps may be added, others removed, and the ordering of the steps rearranged. Starting at a step  a loop is performed with respect to steps , , and . In the loop, template code is generated for exestuation on a local platform, i.e., either the embedded computer  or the host computer . The local platform in this context is defined to be the computer that does not have the routine that is to be invoked. Steps , , and  are performed with respect to each of the functions identified by the user in step  of . At the step , the code generator generates a send command. Next, at a step , the code generated generates a read command. Proceeding to a step , the code generator generates code to return a response. An exemplary code block resulting from steps , , and  is shown in code block  of .","Next, at a step , a loop is performed with respect to steps , , , , and . In this loop, template code is generated for execution on the remote platform. Proceeding to a step , the code generator generates code to invoke a registration routine of the API. Moving to a step , the code generator generates code that invokes the local API that was requested by the thread on the other platform and sends a response message. An exemplary code block resulting from steps , , , , and  is shown in code block .","Next, at a decision step , the code generator determines whether there are any pointers in the parameters of the function. If there are no pointers in the parameters of the function, the process ends. However, if there are pointers, the process proceeds to a step  and the code generator generates code to invoke the API to setup a pointer. Moving to a step , the code generator generates code to invoke the API to attach a pointer. The process then ends.","The DAT system  provides a single virtual environment that enables threads to be located on different platforms and still seamlessly communicate with each other. The DAT system  provides communication interoperability between the two platforms by automatically transforming the data depending on the machine characteristics of the embedded computer , the host computer , and the communication interfaces that are stored in the communication database . The DAT system  provides automatic and seamless access to the message-based and remote function call interfaces designed into the embedded computer's software application. The DAT system  automatically extracts interface information and builds a database of messaging and remote function call information.","Using the studio module , a user has complete visibility and control of the embedded application's interfaces without having to address the following issues: (i) updates to a desktop tool to accommodate new messages; (ii) updates to the embedded software to support the desktop tool's new functionality; (iii) what target compiler is used; (iv) what RTOS is used; and (iv) what platform the thread(s) are executing on. The DAT system  allows seamless access to interfaces stored in the communication database  via scripting languages or any COM-compliant application.","While the above detailed description has shown, described, and pointed out novel features of the invention as applied to various embodiments, it will be understood that various omissions, substitutions, and changes in the form and details of the device or process illustrated may be made by those skilled in the art without departing from the spirit of the invention. The scope of the invention is indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIGS. 4A and 4B","FIG. 3"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 5","FIG. 1"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 6","FIG. 1"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 7","FIG. 5"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 8","FIG. 1"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 9","FIG. 1"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 10","FIG. 1"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 12A\u201312D"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 14","FIG. 3"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 15","FIG. 3"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 16A","FIG. 3"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 16B","FIG. 3"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 17A","FIG. 3"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 17B","FIG. 3"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 18","FIG. 5"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 19","FIG. 5"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 20","FIG. 5"]},{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 21","FIG. 1"]},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 22","FIG. 5"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 23","FIG. 1"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 27","FIG. 1"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 33"}]},"DETDESC":[{},{}]}
