---
title: System and methods for tracing individual transactions across a mainframe computing environment
abstract: A performance management system is provided for monitoring performance of an application across a distributed computing environment, including within one or more mainframe computers. In the mainframe environment, a transaction manager is configured to receive a transaction request from an application executing remotely from the mainframe computer. An event agent is invoked via a user exit by the transaction manager and operates to detect events caused by the handling of the transaction by the transaction manager. Upon detecting such events, the event agent generates event messages for select events associated with the transaction, where the event message includes identifying information for the transaction. A translator agent is configured to receive the event messages from the event agent and transmit the event data record to a server located remotely from the mainframe computer, where the event data record includes the identifying information for the transaction.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09311214&OS=09311214&RS=09311214
owner: Dynatrace LLC
number: 09311214
owner_city: Detroit
owner_country: US
publication_date: 20130605
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD","BACKGROUND","DETAILED DESCRIPTION","APPENDIX"],"p":["This application claims the benefit of U.S. Provisional Application No. 61\/731,008, filed on Nov. 29, 2012. The entire disclosure of the above application is incorporated herein by reference.","The present disclosure relates to tracing and monitoring of individual transactions performed by software applications across computing boundaries including a mainframe computing environment.","Object oriented and bytecode based software development platforms including the Oracle JAVA\u2122 platform and the MICROSOFT.NET platform, have gained wide acceptance for developing enterprise class software applications. Bytecode based software provides cross-platform and cross-language compatibility and eases the networked integration of software applications.","Remote method invocation available for the platforms, like Oracle Remote Method Invocation (RMI) and the MICROSOFT.NET Remoting system, and messaging services like the Oracle JAVA\u2122 Messaging Service (JMS) or the MICROSOFT Messaging Queue ease the creation of distributed and loosely coupled architectures.","Approaches like service oriented architecture (SOA) use these features to provide flexible application architectures which can be adapted to rapidly changing market demands.","Albeit, this flexibility eases building and updating the functionality of applications, it constitutes a challenge for conventional performance monitoring and tracing tools which traditionally consider the scope of an isolated application. Most existing tools are not prepared to trace transactions over the borders of threads or different virtual machines. Following the execution path of a transaction over the borders of threads, processes or different host systems is essential for tracing complete end-to-end transactions, which may be processed by a chain of different application servers that may communicate in various ways. Therefore, it is desirable to develop methods for tracing transactions across computing boundaries, including a mainframe computing environment, and preferably without modifications to source code on any monitored platforms.","Information that depicts the different processing stages on different application servers and provides specific performance information for the processing stages is a precondition for performance analysis of distributed applications. To provide such information, it is required to correlate isolated trace information acquired from the different servers participating in a transaction, to depict a consistent end-to-end transaction. The ability to trace transactions across multiple application execution environments, including both distributed and mainframe environments, provides end-to-end visibility for the entire span of the transaction and thereby allows IT departments to locate precise cause of a slowdown in their application.","This section provides background information related to the present disclosure which is not necessarily prior art.","The drawings described herein are for illustrative purposes only of selected embodiments and not all possible implementations, and are not intended to limit the scope of the present disclosure. Corresponding reference numerals indicate corresponding parts throughout the several views of the drawings.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1","b":["10","10","12","14","16","12","14","16","14"]},"In an exemplary embodiment, the application  may be running within a virtual machine, such as a JAVA virtual machine, on a web server. An agent  is injected into the virtual machine, which intercepts the loading of original bytecode, performed by the native loader, and captures the original bytecode. Each agent is provided with a unique agent identifier, which is added to messages sent by the agent and thus allows distinguishing messages received from different agents. The captured bytecode is sent to an instrumentation engine. The captured bytecode may be sent via a computer network to the instrumentation engine. The instrumentation engine extracts meta-data from the received original bytecode. The metadata is used to identify and select the parts of the original bytecode which are augmented with sensor code. The bytecode parts include but are not limited to class definitions, method definitions and constant pools. The selection of the bytecode parts may be based on explicitly specified method and class names, identifying single methods or classes or it may use a rule based system where one rule may match multiple classes or methods. Sensor code is placed in the selected parts of the original bytecode and the instrumented byte code is sent back to the agent which forwards the instrumented bytecode to the bytecode loading process of the virtual machine which loads the instrumented bytecode instead of the original bytecode. Other techniques for instrumenting applications running in a virtual machine are also contemplated by this disclosure.","The instrumentation engine instruments methods which should be monitored with entry sensors to detect invocations of monitored methods and exit sensors, which detect when execution of monitored methods is finished. Exit sensors detect both normal method exits and exits caused by an unhandled exception. It should be noted that a distinction between both exit types is necessary for a monitoring system to provide correct monitoring information but this distinction does not foster the understanding of the present disclosure and is thus omitted here.","The instrumentation engine can also place tagging sensors in methods initiating an interaction with other threads or virtual machines, like methods sending synchronous or asynchronous messages using messaging oriented middleware, methods preparing network messages representing remote message invocations, or methods initiating an interaction with another thread within the same virtual machine. Those tagging sensors extract correlation information from the thread local storage, which is created by entry sensors and store it in a place where it is accessible for the target threads. Placement of tagging sensors may also include insertion of additional member variables via bytecode manipulation to store the extended correlation information.","Additionally, tag extraction sensors are placed in methods that receive interactions from other threads, like methods receiving synchronous or asynchronous messages, methods receiving messages representing remote method invocations or methods starting a new thread. Those methods are subsumed here as thread activation methods. Tag extraction sensors build the counterpart to tagging sensors. The tag extraction sensors store received correlation information within the thread local storage, where it is accessible for other sensors. These different types of sensors are referenced generally as agent  in .","During operation, agent  detects invocation of select methods and generates an event message regarding the invoked methods. The event messages are in turn sent via a computer network to the correlation engine . In some instances, the application  may spawn a transaction request which is to be serviced by the mainframe computer . For example, the application  may query a database hosted on the mainframe computer. In these instances, the agent  also sends an event message across the network to the correlation engine, where the event message indicates the initiation of a transaction request and is tagged with information that uniquely identifies the execution path which spawned the event message (referred to herein in as non-mainframe tag). The mainframe computer  may also be instrumented in a manner which generates event messages regarding invocations made on the mainframe as will be further described below.","The correlation engine  is configured to receive event messages from different sensors throughout the distributed computing environment, including the mainframe computer . Correlation of event messages by the correlation engine  is based on information that uniquely identifies execution paths which spawn the event messages. For each agent, correlation is based on information that uniquely identifies the agent and\/or the execution path. Correlation information is transferred from a monitored thread to other threads that are activated by the monitored thread and thus allows for correlation of related threads by the correlation engine . For further details regarding such correlation and an exemplary performance management system, reference may be had to U.S. Pat. No. 8,234,631 which is incorporated in its entirety herein by reference.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 1 and 2A","b":["14","12","23","23"]},"Different communication techniques may be used to communicate the transaction request from the application  to the transaction manager . For example, message queuing may be used to transmit the request from the application  to the transaction manager  operating in the mainframe environment as shown in . More specifically, a queue manager  is configured to receive the transaction request from the application  and operates to place a transaction into a message queue . The transaction manager  in turn retrieves the transaction from the message queue  for subsequently processing. In an exemplary embodiment, message queuing may be implemented using the WebSphere MQ message oriented middleware although other implementations are contemplated by this disclosure.","In another example, the transaction request from the application  may be received by a transaction gateway, such as the CICS Transaction Gateway  shown in . The CICS transaction gateway  in turn passes the requests to the transaction manager . In particular, the CICS transaction gateway  may pass the request using either the IP interconnectivity protocol (IPIC) or the external CICS interface (EXCI). Other techniques for communicating the transaction request from the application  to the mainframe computer , such as transmitting the request using Simple Object Access Protocol (SOAP), are also contemplated by this disclosure. In this example, the event agent  is interfaced with the transaction manager and sends event messages directly to the correlation engine . It is understood that the event agent  may be interfaced with an event manager and a translator agent as shown in  and further described below.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3","b":["23","24","23","22","24","24","31"]},"User exits are also used to transfer control to the event agent  for other types of application events as well. Various application events can be caused during the handling of a transaction request from the application . Select application events are monitored and detected at  by the event agent . A listing of exemplary agent events is provided below in the appendix, along with detailed notes for each generated event. Upon occurrence of a select application event, control is transferred from the transaction manager  via an applicable user exit to the event agent  which in turn generates the appropriate agent event(s).","Next, the event agent  determines at  identifying information for the application transaction request which caused the event. In the context of message queuing, identifying information for the application transaction includes an identifier for the queue manager, an identifier for the message queue, an identifier for the message itself, and an identifier for the correlation identifier of the message.","When the transaction request is received via a gateway, the identifying information for the transaction request is further defined as an identifier for the gateway (e.g., the CICS transaction gateway). In the context of the CICS transaction gateway, the identifying information for the application transaction depends on the mechanism by which the transaction request is passed on to the transaction manager . For the IPIC protocol, the ApplidQualifier and the Applid, along with the timestamp, uniquely identifies the application transaction. For the EXCI protocol, the ApplidQualifier and the Applid, along with a modified timestamp, uniquely identifies the application transaction, where the timestamp is appended with a two byte binary sequence number to ensure uniqueness.","To ensure that non-mainframe events can be linked with subsequent events generated on the mainframe, the CICS transaction gateway  can be instrumented with an incoming sensor  and an outgoing sensor . The incoming sensor  is configured to detect the transaction request received by the CICS Transaction Gateway  and generate an event message signifying receipt of the transaction request. Likewise, the outgoing sensor  generates an event message signifying that the transaction request has been passed on to the transaction manager . The incoming sensor  and the outgoing sensor  both insert the identifying information for the application transaction into the event message and such information is readily available from the CICS transaction gateway.","It is readily understood that the identifying information for the application transaction may take different forms. In some embodiments, the identifying information for the application transaction may be included with each event message; whereas, in other embodiments, the identifying information for the application transaction may be included in event messages for select events, such as those which initiate a CICS transaction or an execution path in the mainframe runtime environment.","Lastly, the event agent  generates  an event message for the event, where the event message includes the identifying information for the application transaction request. The event messages are then sent at  to the correlation engine . The identifying information for the application transaction is used by the correlation engine  to correlate the events captured in an execution path in the mainframe environment with other event messages of execution paths associated with the transaction from different execution environments. In some embodiments, the event message generated by the event agent  may be translated into a form understood by the correlation engine  before being sent to the correlation engine . It is readily understood that the application events described in this disclosure are representative and other types of application events may be monitored within the scope of this disclosure.","The monitoring process described in  can be extended to track other transactions that are invoked by the initial transaction. With reference to , the initial transaction (i.e., Task ) may start or otherwise link to another transaction (Task ) within the same region of the run-time environment (e.g., same CICS region) or to a transaction (Task ) in a different region of the run-time environment (e.g., different CICS region on same or different logical partition). In a similar manner, user exits are used to transfer control to the event agent  when a link is made to another transaction (e.g., an Insert_Link event represents the EXEC CICS LINK invocation). In addition to identifying information for the application transaction request, the event agent  also determines transaction context information. In CICS, association data is the set of information that describes the environment in which user tasks run and the way that user tasks are attached in a region. This association data is made available and can serve as the transaction context information. Thus, the event agent  can further append the transaction context information to the event messages sent to the correlation engine. In this way, all of the sub-paths in the mainframe environment can be linked back to the originating sub-path to form one continuous path that described the entire user transaction.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIGS. 4A and 4B","b":["24","23","24","24","24"]},"A determination is first made at  as to whether the user exit is an application program interface call to a resource manager supported by the transaction manager . More specifically, a determination is made as to whether the user exit is a return from a resource manager interface (RMI) call handled by the CICS RMI. In the CICS context, this user exit is referred to as XRMIOUT. If the user exit is not a return from an RMI call, then the event agent  determines at  whether any of its sensors are enabled. In the exemplary embodiment, the event agent  may be configured with different types of sensors. For example, the event agent  may be configured with a sensor for detecting message queue (MQ) commands and another sensor for detecting databases calls (e.g., DB2 queries). When a sensor is enabled, the event agent  will detect the applicable application events and take appropriate action. Conversely, the event agent  will ignore application events of a particular type when the corresponding sensor is disabled. If none of the sensors are enabled, processing is complete and control returns at  to the transaction manager .","When one or more sensors are enabled, a determination is made at  as to whether the user exit is for an entry to an RMI call to be handled by the CICS RMI. In the CICS context, this user exit is referred to as XRMIIN. Calls to resource manager interfaces are further described below. Because the transaction may initiate other programs and\/or spawn other execution paths, the event agent  is also configured to handle user exits indicative of such activity. In the exemplary embodiment, a determination is made at  as to whether the user exit indicates a request to link to another program. In the CICS context, this user exit is referred to as XPCREQ. If so, the event agent  gathers information about the link request and generates an applicable event message as indicated at . A user exit is also invoked upon completion of the link request (referred to as XPCREQ Complete). In a similar manner, the event agent  gathers information about the link request and generates an application event message as indicated at . It is understood that the event agent  may be configured to handle other types of user exits (such as task-related exits for context management events associated with start transaction requests) which allow for the tracing of execution paths associated with the transaction being monitored. If the user exit is unmatched, control returns at  to the transaction manager .","When the user exit is deemed to be call to or a return from an RMI call, the user agent  determines at  whether it is already tracing the transaction which caused the user exit. Context information is retained for each transaction. The event agent  can determine whether it is tracing a transaction by examining this transaction context information.","Before the event agent  begins tracing a given transaction, it can expect to detect an MQ command pertaining to the transaction as noted at . That is, the event agent  will begin tracing a given transaction upon detecting a command by the CICS transaction server to get a message (i.e., MQGET) from the message queue . By the time the event agent  gets control from the transaction manager, various registers maintained by the transaction manager  have changed. For example, registers having information for the program currently active in the CICS region would contain values for the event agent . The event agent , however, is interested in learning about the transaction which initiated the event agent . Accordingly, the event agent  will need to locate at  the applicable registers which contain information about the transaction and\/or the application which made the transaction request. Control returns to the transaction manager at  when tracing has not yet begun and the user exit does not pertain to an MQ command.","In the CICS context, the MQGMO data structure contains data associated with the MQGET command.  illustrates a set of registers and pointers used to by the event agent  to obtain the MQMGO data structure. This data structure is available in the system at the time the user exit invokes the event agent . The structure of this control block is provided by the IBM MQSeries API documentation. Of note, an identifier for the message queue (QNAME) is contained in the MQGMO_RESOLVEDQNAME field. The identifier for the queue manager (QMGRNAME) is obtained from a startup program in the CICS region which locates it and caches it in a location known to the event agent .","Additionally, the event agent  accesses a data structure containing message description data as shown in . Likewise, a set of registers and pointers used by the event agent  to obtain the MQMD data structure and the structure of this control block is provided by the IBM MQSeries API documentation. The identifier for the message (MSGID) is contained in the MQGMD_MSGID field and the correlation identifier is contained in the MQGMD CORRELID field. In the exemplary embodiment, the identifier for the queue manager, the identifier for the message queue, the identifier for the message itself, and the correlation identifier of the message are referred to collectively as the identifying information (or tag) for the application transaction. These tags allow for the correlation of associated execution paths. The individual event messages generated by the event agent  for a particular transaction are placed into the context of an execution path by the translation agent . In this way, these event messages can be correlated with the application which initiated the transaction.","Depending on the type of MQ command, the event agent  will handle the command differently. First, a determination is made at  as to whether the MQ command is of the type which places a message onto a queue (i.e., MQPUT). Next, a determination is made at  as to whether the MQ command is of the type which retrieves a message from a queue (i.e., MQGET). In either case, a determination is then made at  as to whether the user exit is for an entry to an RMI call. If so, event agent  will handle the command as indicated at ; otherwise, it is assumed that the user exit is for a return from an RMI call. In this case, the event agent gets the return code at  for the RMI call and the builds an appropriate event message at . The event agent  then sends the event message to the translator agent . It is readily understood that the event agent  may be configured to support other types of MQ commands. Handling of other types of MQ commands does not further the understanding of this disclosure and thus has been omitted.","For transactions the event agent  is already tracing, the event agent  determines at  as to which subsystem the application call pertains to. In the exemplary embodiment, the event agent  supports MQ commands and DB2 queries. For MQ commands, the event agent  determines the type of MQ command and evaluates the MQ command beginning at  in the manner set forth above.","For DB2 queries, a determination is made at  as to whether the user exit was invoked prior to the DB2 query or after the DB2 query. Prior to the query, the event agent  creates SQL attachments at  and then generates the applicable enter event message at . Conversely, after the query, the event agent creates connection pool attachments at  and captures the SQLCODE for the query at . The event agent  will create a JDBC attachment at  when the return code indicates success or a warning. Depending on whether the query was successful or not, the event agent  then creates the applicable event message as indicated at  and , respectively. In either case, control returns at  to the transaction manager . It is readily understood that the event agent  can be configured to support other types of resource interfaces or mainframe subsystems as indicated at .","It is to be understood that only the relevant steps of the agent are discussed in relation to , but that other software-implemented instructions may be needed to control and manage the overall operation of the event agent. For example, the event agent  may be configured to handle other types of application events, such as Task Start, Task End, and Context Management exit events. The event agent  may also be configured to handle transaction requests received via other mechanisms, such as the CICS transaction gateway. Rather than checking for an MQ command in step , the event agent  could be configured to determine what type of mechanism was used to receive the transaction request. In CICS, the mechanism used to receive the transaction request may be indicated in the origin data. In the case the transaction request was received via the CICS transaction gateway, the event agent  can be configured to handle commands associated with this mechanism. Moreover, the event agent  can be configured to determine the identifying information for the transaction request (e.g., the ApplidQualifier and the Applid) from a set of registers in a manner similar to that described in relation to message queuing. For brevity, details for determining such information has been omitted from this disclosure.","Returning to , a translator agent  may be configured to receive event messages from the event agent . In one embodiment, the event messages may be handled by an intermediate event manager  prior to reaching the translator agent . The event manager  operates generally to control the lifecycle of the translator agent . Additionally, the event manager  receives the event messages from the event agent  and places the event messages in an event queue . Prior to placing the event messages in the event queue , the messages may be validated by the event manager . For example, each different type of application event being monitored by the event agent  may be assigned a unique event identifier by the event agent . The event manager  may use the event identifier to validate event messages received from the event agent . Invalid events are not placed into the event queue . The translator agent  retrieves the validated event messages from the event queue . The event manager  may also operate to add an address space identifier of the CICS region (from which the event message originated) to the event message. In other embodiments, event messages may be communicated directly from the event agent  to the translator agent  via shared memory and without the use of the event manager . In yet other embodiments, the event agent  sends event messages directly to the correlation engine  and there is no need for the translator agent .","In some embodiments, the event manager  and the translator agent  may operate, for example in a data collection subsystem (e.g., z\/OS data collector) of the mainframe computer . In other embodiments, the translator agent  operates on a computing device distinct from the mainframe computer. In these embodiments, the event manager  may be configured to transmit the event messages across a computer network to the translator agent . Event messages may be transmitted by the event manager , for example using TCP\/IP or a best effort delivery communication protocol. Other types of communication mechanisms are also contemplated by this disclosure.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 6","b":["27","27","81","27","82","27","27","24","27","27"]},"Next, the translator agent  determines the event type for the message as indicated at . For each event type, the translator agent  processes the event message accordingly. That is, the translator agent  maps data from the event message to the corresponding fields in an event data record. For example, the translator agent  generates a Start Path event record for a Start Root Path event received from the event agent . An exemplary data structure for the Start Path event record is provided as follows.",{"@attributes":{"id":"p-0052","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"StartPathEventRecord {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int","eventType",{}]},{"entry":[{},"long","timestamp;",{}]},{"entry":[{},"List","nodeAttachments;",{}]},{"entry":[{},"int","tagId;",{}]},{"entry":[{},"int","prevAgentId;","\/\/ agent id of path that called this"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"path"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int","prevTagId;","\/\/ tag id of calling path"]},{"entry":[{},"int","prevTagHopCount;","\/\/ hop count from calling path"]},{"entry":[{},"int","rootAgentId;","\/\/ agent id of this new path"]},{"entry":[{},"int","rootTagId;","\/\/ tag id of new path"]},{"entry":[{},"int","threadId;",{}]},{"entry":[{},"String","threadName;",{}]},{"entry":[{},"String","tagInfo;","\/\/ tag for this path"]},{"entry":[{},"bool","start LinkedRootPath;",{}]},{"entry":[{},"byte","sensorId;",{}]},{"entry":[{},"long","timeStamp;",{}]},{"entry":[{},"byte[ ]","PathTag;","\/\/ tag for this path"]},{"entry":[{},"byte[ ]","PrevPathTag;","\/\/ tag of calling path"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"MessagingNodeAttachment {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"String","destinationName;","\/\/ queue name"]},{"entry":[{},"String","queueManagerName;","\/\/ queue manager name"]},{"entry":[{},"long","messageSize;","\/\/ size of message"]},{"entry":[{},"byte","transmissionType;","\/\/ put\/get etc..."]},{"entry":[{},"byte","messageType;","\/\/ WebSphere MQ, for example"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":"16"},"For events that initiate a transaction in the mainframe run-time environment, the event data record for such events includes the identifying information for the application transaction. In the case of the Start Path event record, identifying information for the application transaction (i.e., queue manager name, queue name and message id) may be inserted into the tagInfo field of the event data record. For the remaining events, the translator agent  tags the event data record with the (CICS) transaction context information. Given the identifying information for the application transaction from a preceding event data record, the correlation engine  can correlate subsequent event data records to the application transaction using the transaction context information. In either case, the event data records also include at least one performance metric pertaining to the application transaction. For example, a timestamp at which the program is started signifies a performance metric that will enable the correlation engine  to determine performance pertaining to the application transaction being monitored. Lastly, the translator agent  transmits the event data record to the correlation engine  as indicated at . Again, it is to be understood that only the relevant steps of the agent are discussed in relation to , but that other software-implemented instructions may be needed to control and manage the overall operation of the translator agent","Returning to , execution of the application  may result in a transaction request for the mainframe computer . In the exemplary embodiment, the transaction request may be communicated via message queuing to the mainframe computer . One or more of the agents  monitoring the application  will generate an event message in response to the transaction request. The event message will include information that uniquely identifies the execution paths which spawn the transaction request. In addition, the event message will include identifying information for the application transaction request such as an identifier for the queue manager, an identifier for the message queue and an identifier for the message. In an exemplary embodiment, this event message may mimic the format of the Start Path event record noted above. The event message is sent by the agent  across the network to the correlation engine .","The correlation engine  will also receive event messages from the mainframe computer . Event messages are generated throughout the handling of the transaction by the mainframe in the manner described above. Select event messages are tagged with identifying information for the application transaction, including an identifier for the queue manager, an identifier for the message queue and an identifier for the transaction request. In this way, the identifying information for the application transaction can be used by the correlation engine  to correlate the mainframe events with the application requesting the backend mainframe processing.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 7","b":["16","16"]},"When a transaction manager  is notified that a message should be retrieved from an application message queue , an MQGET API is invoked in that transaction manager  as indicated at  in . In this example, that is CICS Region C259, with an agent id of \u201897\u2019 as noted in the appendix below. Events - are generated when the MQGET API completes. At that time, the XRMIOUT user exit is invoked, allowing the event agent  to intercept the completion of the API call. The tag generated as event  permits the correlation engine  to associate this transaction with the distributed application's MQPUT. Events - are generated as the standard sequence for an MQCLOSE or MQOPEN. Event  is generated via the invocation of the user exit XRMIIN, and events - via XRMIOUT. The program FLCTRIG1 invokes a START transaction API for transaction FLC2. This causes a context management event to invoke the task-related exit which generates event . This Insert Link event is created to facilitate the linking of the current execution path with the new path that is about to begin for a new transaction. The correlation engine  will use the tag information in event  to accomplish that correlation. A start transaction event for this new transaction invoked the task-related exit, which creates events -. These events signal the start of the started transaction FLC2, which in turn starts the user program FLCPGM2. The event  is used by the correlation engine  to link together FLCPGM2 with FLCTRIG1 (event ). Note that the task id has changed from event  to event  to indicate a new execution path (transaction). Execution times for the various programs can be made visible, for example as indicated at .","Events - are generated via the user exits XPCREQ when the user program FLCPGM2 issues a CICS DPL LINK (EXEC CICS LINK PROGRAM(name)) to start a mirror transaction that will execute FLDPGM3 in another CICS Region (C208). The exit event  is generated via a task manager call at the end of the task. This event caused the task-related exit to invoke, which permits the event agent  to generate the corresponding exit event  for the end of the transaction. Event  is generated in this second CICS Region C208, with a new agent id of \u201882\u2019 and a new task id of \u2018354\u2019 as noted in the appendix below. With reference to  in , this indicates a new execution path for the new transaction within a new CICS region. The tags created in event  and  permit the correlation engine  to correctly link these execution paths, even as they cross CICS region boundaries. A task start event invokes the task manager calls at the start of the task, which in turn generates these events. Events - are similar in nature to events -, except that they were generated for a DPL API, rather than a Start Tran API.","Event  represents a CICS LINK API which invokes the user program FLDDB21. This API is intercepted by the user exit XPCREQ. Events - are created via the XRMIIN user exit, and the DB2 Handler code within the event agent . The corresponding exit events, via the XRMIOUT user exit, are events -. This same pattern is repeated for events -. In this way, metrics pertaining to a database call are made visible as indicated at .","User exit XPCREQC is driven by the returns from the CICS LINK API requests and permits the event agent  to generate the corresponding exit events. Event  is the exit event for Event , and Event  is the exit event for event .","A task end event caused the task-related exit to invoke, which permits the event agent  to generate the corresponding exit event  for the end of the transaction indicated by the enter event . Note that event  is the exit for a program traced by agent  and task , when control is returned to the original CICS Region C259.","Events -, and - are standard MQ events, similar to the pattern of events -. Event  is generated via the XRMIIN user exit at the beginning of an MQPUT API. Events - are generated via the XRMIOUT user exit at the end of that MQPUT API. The tag generated in Event  permits the correlation engine  to link the end of the mainframe processing with the corresponding MQGET in the distributed application. Event  is the exit event for the original program, FLCTRIG1.","The techniques described herein may be implemented by one or more computer programs executed by one or more processors. The computer programs include processor-executable instructions that are stored on a non-transitory tangible computer readable medium. The computer programs may also include stored data. Non-limiting examples of the non-transitory tangible computer readable medium are nonvolatile memory, magnetic storage, and optical storage.","Some portions of the above description present the techniques described herein in terms of algorithms and symbolic representations of operations on information. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. These operations, while described functionally or logically, are understood to be implemented by computer programs. Furthermore, it has also proven convenient at times to refer to these arrangements of operations as modules or by functional names, without loss of generality.","Unless specifically stated otherwise as apparent from the above discussion, it is appreciated that throughout the description, discussions utilizing terms such as \u201cprocessing\u201d or \u201ccomputing\u201d or \u201ccalculating\u201d or \u201cdetermining\u201d or \u201cdisplaying\u201d or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system memories or registers or other such information storage, transmission or display devices.","Certain aspects of the described techniques include process steps and instructions described herein in the form of an algorithm. It should be noted that the described process steps and instructions could be embodied in software, firmware or hardware, and when embodied in software, could be downloaded to reside on and be operated from different platforms used by real time network operating systems.","The present disclosure also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes, or it may comprise a general-purpose computer selectively activated or reconfigured by a computer program stored on a computer readable medium that can be accessed by the computer. Such a computer program may be stored in a tangible computer readable storage medium, such as, but is not limited to, any type of disk including floppy disks, optical disks, CD-ROMs, magnetic-optical disks, read-only memories (ROMs), random access memories (RAMs), EPROMs, EEPROMs, magnetic or optical cards, application specific integrated circuits (ASICs), or any type of media suitable for storing electronic instructions, and each coupled to a computer system bus. Furthermore, the computers referred to in the specification may include a single processor or may be architectures employing multiple processor designs for increased computing capability.","The algorithms and operations presented herein are not inherently related to any particular computer or other apparatus. Various general-purpose systems may also be used with programs in accordance with the teachings herein, or it may prove convenient to construct more specialized apparatuses to perform the required method steps. The required structure for a variety of these systems will be apparent to those of skill in the art, along with equivalent variations. In addition, the present disclosure is not described with reference to any particular programming language. It is appreciated that a variety of programming languages may be used to implement the teachings of the present disclosure as described herein.","The present disclosure is well suited to a wide variety of computer network systems over numerous topologies. Within this field, the configuration and management of large networks comprise storage devices and computers that are communicatively coupled to dissimilar computers and storage devices over a network, such as the Internet.","The foregoing description of the embodiments has been provided for purposes of illustration and description. It is not intended to be exhaustive or to limit the disclosure. Individual elements or features of a particular embodiment are generally not limited to that particular embodiment, but, where applicable, are interchangeable and can be used in a selected embodiment, even if not specifically shown or described. The same may also be varied in many ways. Such variations are not to be regarded as a departure from the disclosure, and all such modifications are intended to be included within the scope of the disclosure.","Listing of events in an example transaction scenario:",{"@attributes":{"id":"p-0072","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},"Agent",{},"Task",{}]},{"entry":["Event#","Id","Agent Event","ID","Data associated with the event"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["01*","0097","Start_Path","357","(C)MQ CSQ NMQM [ca8a212359090609]"]},{"entry":["02","0097","CICS_Tran_Att","357","MQ FLC1 0000357 ca8a212359e39788"]},{"entry":["03","0097","Enter","357","FLCTRIG1"]},{"entry":["04","0097","Enter","357","MQGET"]},{"entry":["05","0097","Messaging_Att","357","19 NMQM h06ac259.request.flc1"]},{"entry":["06","0097","Capture","357","0"]},{"entry":["07","0097","Exit","357"]},{"entry":["08","0097","Enter","357","MQCLOSE"]},{"entry":["09","0097","Capture","357","0"]},{"entry":["10","0097","Exit","357"]},{"entry":["11*","0097","Insert_Link","357","(A)Start Tran C2591249240000357S000"]},{"entry":["12*","0097","Start_Path","358","(C)Start Tran C2591249240000357S000"]},{"entry":["13","0097","CICS_Tran_Att","358","START FLC2 0000358 ca8a21235aba1908"]},{"entry":["14","0097","Enter","358","FLCPGM2"]},{"entry":["15","0097","Enter","358","FLDPGM3"]},{"entry":["16*","0097","Insert_Link","358","(S)DPL Link C2591249240000358L0000"]},{"entry":["17","0097","Exit","357"]},{"entry":["18*","0082","Start_Path","354","(C)DPL Link C2591249240000358L0000"]},{"entry":["19","0082","CICS_Tran_Att","354","DPL FLC2 0000354 ca8a21235b767389"]},{"entry":["20","0082","Enter","354","FLDPGM3"]},{"entry":["21","0082","Enter","354","FLDDB21"]},{"entry":["22","0082","Static_SQL_Att","354","FLDDB21 305 2 SET CURRENT SQLID"]},{"entry":["23","0082","Enter","354","SET CURRENT SQLID"]},{"entry":["24","0082","Conn_Pool_Att","354","FLDB2END 1"]},{"entry":["25","0082","Capture","354","0"]},{"entry":["26","0082","Exit","354"]},{"entry":["27","0082","Static_SQL_Att","354","FLDDB21 315 3 INSERT"]},{"entry":["28","0082","Enter","354","INSERT"]},{"entry":["29","0082","Conn_Pool_Att","354","FLDB2END 1"]},{"entry":["30","0082","Capture","354","0"]},{"entry":["31","0082","Exit","354"]},{"entry":["32","0082","Exit","354"]},{"entry":["33","0082","Exit","354"]},{"entry":["34","0097","Exit","358"]},{"entry":["35","0097","Enter","358","MQOPEN"]},{"entry":["36","0097","Capture","358","0"]},{"entry":["37","0097","Exit","358"]},{"entry":["38","0097","Enter","358","MQPUT"]},{"entry":["39*","0097","Insert_Link","358","(A)MQ CSQ NMQM [ca8a21235f02a18a]"]},{"entry":[{},{},{},{},"CSQ NMQM [ca8a212359090609]NMQM"]},{"entry":["40","0097","Messaging_Att","358","Write 168 NMQM h06ac259.reply.flc1"]},{"entry":["41","0097","Capture","358","0"]},{"entry":["42","0097","Exit","358"]},{"entry":["43","0097","Enter","358","MQCLOSE"]},{"entry":["44","0097","Capture","358","0"]},{"entry":["45","0097","Exit","358"]},{"entry":["46","0097","Exit","358"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"Brief description for each event in the listing above:",{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Event#","Event Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u20021","tag for an MQ Message"]},{"entry":["\u20022:","CICS Transaction Attachment (transaction = FLC1,"]},{"entry":[{},"task = 357, triggered by MQ)"]},{"entry":["\u20023:","Enter for the program FLCTRIG1"]},{"entry":["\u20024:","Enter for the MQGET API call"]},{"entry":["\u20025:","Message Attachment"]},{"entry":[{},"(read, size = 19, NMQM = queue manager,"]},{"entry":[{},"h06ac259.request.flc1 = queue name)"]},{"entry":["\u20026:","Reason code returned by MQGET call"]},{"entry":["\u20027:","Exit for the MQGET"]},{"entry":["\u20028:","Enter for the MQCLOSE API call"]},{"entry":["\u20029:","Reason code returned by MQCLOSE call"]},{"entry":["10:","Exit for the MQCLOSE"]},{"entry":["11:","Insert Link"]},{"entry":[{},"an asynchronous (A) transaction in CICS Region C259"]},{"entry":[{},"at 12:49:24 from task 357, \u2018S\u2019 = Start"]},{"entry":["12.","Start Path"]},{"entry":[{},"a tag (C) is generated for CICS Region C259"]},{"entry":[{},"at 12:49:24 from task 357. \u2018S\u2019 = Start"]},{"entry":["13.","CICS Transaction Attachment"]},{"entry":[{},"transaction = FLC2, task = 358, triggered by a START Request"]},{"entry":["14.","Enter for the program FLCPGM2"]},{"entry":["15.","Enter for the program FLDPGM3"]},{"entry":["16.","Insert Link"]},{"entry":[{},"a synchronous tag is generated for CICS Region C259"]},{"entry":[{},"at 12:49:24 for task 358. \u2018L\u2019\u2014Link"]},{"entry":["17.","Exit for task 357 (program FLCTRIG1) (the local instance"]},{"entry":[{},"running in CICS Region C259)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"hop to Agent 82 in CICS Region C208"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["18.","Start Path"]},{"entry":[{},"a tag is generated for CICS Region C259"]},{"entry":[{},"at 12:49:24 for task 358. \u2018L\u2019\u2014Link"]},{"entry":["19.","CICS Transaction Attachment"]},{"entry":[{},"transaction = FLC2, task = 354, triggered by a DPL Request"]},{"entry":["20.","Enter for the program FLDPGM3"]},{"entry":[{},"(running in CICS Region C208)"]},{"entry":["21.","Enter for the program FLDDB21"]},{"entry":["22.","SQL Attachment"]},{"entry":[{},"dbrm = FLDDB21, line # = 305, section # = 2, sql ="]},{"entry":[{},"\u201cSET CURRENT SQLID\u201d"]},{"entry":["23.","Enter for the SQL Verb \u201cSET CURRENT SQLID\u201d"]},{"entry":["24.","Connection Pool Attachment (pool name = FLDDB2END,"]},{"entry":[{},"pool connections = 1)"]},{"entry":["25.","SQLCode Attachment, SQLCODE = 0"]},{"entry":["26.","Exit for SQL Verb \u201cSET CURRENT SQLID\u201d"]},{"entry":["27.","SQL Attachment"]},{"entry":[{},"dbrm = FLDDB21, line # = 315, section # = 3, sql = \u201cINSERT\u201d"]},{"entry":["28.","Enter for the SQL Verb \u201cINSERT\u201d"]},{"entry":["29.","Connection Pool Attachment (pool name = FLDDB2END,"]},{"entry":[{},"pool connections = 1)"]},{"entry":["30.","SQLCode Attachment, SQLCODE = 0"]},{"entry":["31.","Exit for SQL Verb \u201cINSERT\u201d"]},{"entry":["32.","Exit for program FLDDB21"]},{"entry":["33.","Exit for program FLDPGM3"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"return to Agent 97 in CICS Region C259"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["34.","Exit for program FLCPGM3"]},{"entry":["35.","Enter for MQOPEN API Call"]},{"entry":["36.","Reason code returned by MQOPEN call"]},{"entry":["37.","Exit for the MQOPEN"]},{"entry":["38.","Enter for the MQPUT API Call"]},{"entry":["39:","Insert Link"]},{"entry":[{},"for an asynchronous (A) transaction in CICS Region C259"]},{"entry":[{},"with an MQ tag"]},{"entry":["40:","Message Attachment"]},{"entry":[{},"write, size = 168, NMQM = queue manager,"]},{"entry":[{},"h06ac259.reply.flc1 = queue name"]},{"entry":["41:","Reason code returned by the MQPUT call"]},{"entry":["42.","Exit for the MQPUT"]},{"entry":["43:","Enter for the MQCLOSE API call"]},{"entry":["44:","Reason code returned by the MQCLOSE call"]},{"entry":["45:","Exit for the MQCLOSE"]},{"entry":["46.","Exit for the FLCTRIG1 program"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIGS. 2A and 2B"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIGS. 4A and 4B"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIGS. 5A and 5B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
