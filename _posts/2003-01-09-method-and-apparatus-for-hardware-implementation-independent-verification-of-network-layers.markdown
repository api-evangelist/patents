---
title: Method and apparatus for hardware implementation independent verification of network layers
abstract: A verification mechanism monitors incoming and outgoing traffic between a channel adapter and a switch fabric in an InfiniBand system in order to verify that the InfiniBand protocol is correctly followed by the channel adapter. The verification mechanism uses a simple hardware-independent interface to query the channel adapter hardware for specific values and completion queue, queue pair and work queue element attributes that are required for verification. The verification mechanism creates a plurality of verification components that monitor incoming and outgoing messages and verify that each of the channel adapter elements correctly follows the protocol. The verification mechanism is controlled by a verification application programming interface (API) that allows different test benches and tests to incorporate InfiniBand protocol verification in any test system for use with any hardware.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07290051&OS=07290051&RS=07290051
owner: Sun Microsystems, Inc.
number: 07290051
owner_city: Santa Clara
owner_country: US
publication_date: 20030109
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This invention relates to verification and testing of hardware implementations of network channel adapters, and, in particular, to the verification and testing of the network transport and link layers of such hardware implementations.","In conventional computer systems, various components, such as CPUs, memory and peripheral devices, are interconnected by a common signal transfer path called a \u201cbus\u201d. Busses are implemented in a variety of well-known standard architectures including Fibre Channel architecture and, more recently, InfiniBand architecture. These architectures are not memory-mapped architectures. Instead, the CPU and memory are connected to host channel adapters. The input\/output (I\/O) devices are connected to target channel adapters. The host and target channel adapters communicate by messages comprising one or more data packets transmitted over serial point-to-point links established via a hardware switch fabric to which the host and target channel adapters are connected. The messages are enqueued for delivery between the channel adapters. This type of architecture will be referred to as a message-passing queue-oriented architecture in the following description.","The components connected to the channel adapters can control data transfer by creating structures called work queues. Work queues are always created in pairs, called queue pairs, and contain one work queue for send operations and one work queue for receive operations. Each client has one or more queue pairs and each queue pair is independent from other queue pairs. In general, the send work queue of a queue pair holds instructions that cause data to be transferred between a client's memory and another process's memory, and the receive work queue of a queue pair holds instructions that instruct the client where to place data that is received from another process. Another queue called a completion queue receives acknowledgements from the recipient of a message indicating the status of the requested operation. In order to use the work queue pair, a client submits a work request to its respective channel adapter and the work request causes an instruction called a \u201cwork queue element\u201d to be placed on the appropriate send work queue.","Channel adapters developed by different companies and for different products are implemented differently. For example, different channel adapters may have a different internal structure for completion queues, queue pair state, or work queue elements. Even though the internal implementation may differ, in order to work with an InfiniBand system, all channel adapters must follow strictly an InfiniBand protocol that is defined in detail in an InfiniBand Specification Rev 1.0a, The InfiniBand Trade Association (2001).","One part of this specification relates to the manner in which a channel adapter connects to an InfiniBand switch fabric. Typically, the channel adapters connect to the switch fabric by means of a network protocol stack. In order to reduce design complexity, most networks are organized as a series of hardware and software levels or \u201clayers\u201d within each node. These layers interact to format data for transfer between nodes that are communicating over the network. Specifically, predetermined services are performed on the data as it passes through each layer and the layers communicate with each other by means of the predefined protocols. This layered design permits each layer to offer selected services to other layers using a standardized interface that shields those layers from the details of actual implementation of the services.","In an attempt to standardize network architectures, i.e., the sets of layers and protocols used within a network, a generalized model has been proposed by the International Standards Organization (ISO). The model, called the open systems interconnection (OSI) reference model, addresses the interconnection of systems that are \u201copen\u201d for communication with other systems. The proposed OSI model has seven layers which are termed, in ascending interfacing order, the \u201cphysical\u201d, \u201cdata link\u201d, \u201cnetwork\u201d, \u201ctransport\u201d, \u201csession\u201d, \u201cpresentation\u201d and \u201capplication\u201d layers. These layers are arranged to form a protocol \u201cstack\u201d in each node of the network.","In order to verify that a channel adapter is operating properly and complies with the aforementioned InfiniBand protocol, it is necessary to verify that the network layers are operating properly, and, in particular, that the network transport and link layers are operating properly. However, since these layers are implemented in the internal hardware of each channel adapter, it is necessary to test the hardware to determine whether it is implementing the InfiniBand protocol properly in these layers. Thus, special test circuits must be designed for each hardware implementation.","In accordance with the principles of the invention, the InfiniBand protocol verification is separated from hardware implementation details by a hardware-independent verification mechanism that can be used in any functional design verification simulation environment, regardless of the specific hardware channel adapter implementation.","In one embodiment, the verification mechanism monitors incoming and outgoing traffic between a channel adapter and the InfiniBand switch fabric. Since this traffic conforms to the InfiniBand protocol, it is only necessary to determine the attributes of completion queues, queue pairs and work queue elements that are defined by the aforementioned InfiniBand specification and are hardware independent. Similarly, the verification mechanism uses a simple hardware-independent interface to query the channel adapter for hardware-specific values and hardware-specific completion queue, queue pair and work queue element attributes that are required for verification.","In another embodiment, the verification mechanism can be controlled by a verification application programming interface (API) that allows different test benches and tests to incorporate InfiniBand protocol verification in any test system for use with any hardware. This API can be used in any environment without knowledge of all the details of how the verification mechanism is implemented.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 1","FIG. 1"],"sup":["SM","SM","SM"],"b":["100","104","102","106","104","108","109","111"]},"The HCA  is connected to a switch fabric  for both sending and receiving data as indicated schematically by arrows  and . The HCA  can be connected to any number of peripheral busses via the switch fabric . In particular, the HCA  can be connected to various peripherals, of which two,  and  are shown, via a peripheral bus , by means of a target channel adapter (TCA) . TCA  can both send and receive data as indicated schematically by arrows  and . The TCA  also includes a CPU  and a memory . Other TCAs (not shown) may also be present.","Clients of both the HCA  and the TCA  can control data transfer by creating facilities called work queues. Work queues are always created in pairs, called queue pairs, and contain one work queue for send operations and one work queue for receive operations. Each client has one or more queue pairs and each queue pair is independent from other queue pairs. In general, the send work queue of a queue pair holds instructions that cause data to be transferred between a client's memory and another process's memory, and the receive work queue of a queue pair holds instructions that instruct the client where to place data that is received from another process. For example, HCA  has a queue pair consisting of send queue  and receive queue . Similarly, TCA  has a queue pair consisting of send queue  and receive queue . Although only two queue pairs are shown, typically each client would create many more queue pairs in order to conduct its operation. In order to use the queue pair, a client submits a work request to its respective channel adapter and the work request causes an instruction called a Work Queue Element (WQE) to be placed on the appropriate send or receive work queue.","There are several classes of send queue operations, including SEND operations and RDMA operations. For a SEND operation, the WQE specifies a block of data in the client's memory space for the hardware to send to the destination. At the destination, a corresponding already-queued receive WQE in a receive queue specifies where to place that data. For an RDMA operation, the WQE specifies a block of data to be sent and specifies the address at the destination where the data is to be placed.","RDMA operations include RDMA WRITE and RDMA READ. The RDMA WRITE operation stipulates that the hardware is to transfer data from the client's memory to the remote process's memory. The RDMA READ operation stipulates that the hardware is to transfer data from the remote process memory to the client's memory.","Both the host and target channel adapter hardware comprise a transport engine that executes WQEs in the order that they were placed on the send work queue. For example, host channel adapter  includes transport engine  and target channel adapter  includes transport engine . In the process of sending data, the transport engine in the source channel adapter interprets the WQE in its send queue and creates a request message, which includes the data, to send to the destination channel adapter. The transport engine segments the message into multiple packets if necessary, adds the appropriate routing headers, and sends the packet out.","When the destination receives a packet, its transport engine associates the received packet with a particular work queue pair and uses the context of that work queue pair to process the packet and execute the operation. If necessary, the destination transport engine creates an acknowledgment message and sends that message back to the source channel adapter.","When a queue pair is created, it is associated with one of five transport service types that indicate the degree of reliability, the destination and the manner in which the queue pair transfers data. These transport types are reliable connection (RC), unreliable connection (UC), reliable datagram (RD), unreliable datagram (UD) and raw datagram. Reliable transport services use a combination of sequence numbers and acknowledgment messages (ACK\/NAK) to verify packet order delivery, prevent duplicate packets and out-of-sequence packets from being processed, and to detect missing packets (for example, packets lost due to a fabric reconfiguration or packets discarded due to check code violations). Thus, reliable transport services can guarantee that messages are delivered at most once, in order and without corruption (in the absence of errors.) Unreliable transport services cannot guarantee delivery of messages. Thus, the sender receives no acknowledgement of message receipt, there are no packet order guarantees and messages may be dropped upon corruption or dropped and out of order packets. The sender considers the operation complete when the last or only packet has been committed to the fabric and the responder considers the operation complete when it has received an opcode indicating the last or only packet has been received and all validity checks have been completed.","An InfiniBand operation is defined to include a request message and, for reliable services, the corresponding response. Thus, the request message is generated by a requester, and a response, if one exists, is generated by the responder. A request message consists of one or more packets. The packets of a request message are called request packets. A response, except for an RDMA READ response, consists of exactly one packet. A response is also called an \u201cacknowledge.\u201d The response packet acknowledges receipt of one or more packets. The response may acknowledge the receipt of packets that comprise anywhere from a portion of a request message to multiple request messages.","Unreliable transport services do not use acknowledgment messages. They do however generate sequence numbers. This allows a responder to detect out-of-sequence or missing packets and to perform local recovery processing. Both the HCA  and the TCA  also include a completion queue ( and , respectively.)","The structure and operation of the InfiniBand system are described in detail in the InfiniBand Specification Rev 1.0a, (2001) which specification is incorporated by reference herein in its entirety.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 2","sup":["SM","SM","SM","SM"],"b":["200","208","214","220","208","214","220","205","202","204","206","205","212","218","222","208","214","220","210","216","224"]},"Each verification mechanism ,  and  provides the following verification for the transport layer of the InfiniBand Protocol:\n\n","Each verification mechanism ,  and  further provides the following verification for the data link layer of the InfiniBand Protocol:\n\n","The verification mechanisms ,  and  are configured and controlled by a test agent illustrated schematically at . The test agent is not part of the verification system, but it can communicate with each verification mechanism, as described below. In turn, the test agent may be part of, or operate under control of, a test bench (not shown in ). Alternatively, the test agent can be a sequencer driven by a plurality of tests designed by a test technician.","The internal architecture of each verification mechanism  consists of seven main components, as shown in . The transport agent component  provides an application programming interface (API) to the entire verification mechanism so that it can be easily used in any test environment. The transport agent component  creates one or more copies of the service agent component  (as indicated by arrow ), and the completion queue agent component  (as indicated by arrow ). The service agent component, in turn, creates the queue pair component , and the send and receive queue components,  and . Although only one copy of each component is shown in the figure, there may be multiple copies depending on the hardware architecture and the verification operations performed.","Each completion queue agent component, such as component , provides verification of completion of send and receive work requests on an associated channel adapter. Each service agent component, such as , provides verification of a service type and is associated with a completion queue agent component  for completion of its work requests. In addition, each service agent component  contains a queue pair component  that represents a queue pair corresponding to the service type being verified by the service agent component. The queue pair component  includes a receive queue component  and a send queue component . Although not shown in  for clarity, the completion queue agent  can create multiple copies of completion queue element components, each of which represents one completion queue element. Similarly, the send queue agent component can create multiple copies of send work queue element components and the receive queue agent component can create multiple copies of receive work queue element components that are also not shown in . Each work queue element component represents a single work queue element.","The system also defines an HCA agent interface  that is used by both the completion queue agent  (as indicated by arrow ) and service agent component  (as indicated by arrow ) to query the channel adapter hardware  for specific values and completion queue, queue pair and work queue element attributes. The HCA agent interface  controls an HCA agent . Since the HCA agent  must work closely with the channel adapter hardware , its implementation is hardware dependent, although the interface  is hardware independent.","The IB fabric agents  simulate the InfiniBand switch fabric layer. One fabric agent is used for incoming messages  and another fabric agent is used for outgoing messages . Fabric agents  control network verification layer mechanisms (NVLMs)  and  to store data packets that are sent to, and received from, the switch fabric. The NVLMs allow the fabric agent to create errors, such as duplicate or dropped data packets, for testing purposes. An NVLM suitable for use with the fabric agents  is described in detail in co-pending U.S. patent application Ser. No. 09\/852,482, entitled METHOD AND APPARATUS FOR CONFIGURATION INDEPENDENT SIMULATION OF NETWORK LAYER CONDITIONS, filed on May 10, 2001 by Francis Wong, Eduard Rozman and George Plouffe, which application is hereby incorporated in its entirety.","Both the transport agent  and the channel adapter agent  (via the interface ) can be controlled by a test agent  that specifies the tests to be run. This test agent  is not part of the verification system. For example, it might be part of a test bench or a sequencer. In either case, the test agent  runs a set of tests that verify the operation of the transport and data link layers. In order to perform each test in the test set, the test agent  determines which queue pairs should be set up, the messages that are sent and the other details of performing specific tests. The test agent  then generates instructions that are used to create queue pairs, to generate and receive messages and to specify events to be monitored.","However, the test agent  is not hardware-specific. Thus, in order to cause the channel adapter  to perform an operation, such as creating a queue pair, the test agent instructs the hardware-specific HCA agent  to perform the operation by passing hardware-independent information to the HCA agent, via the HCA agent interface  as schematically illustrated by arrow . Once instructed, the hardware-specific HCA Agent  is designed to control a specific channel adapter hardware  to perform the operation. Thus, it contains all the hardware-specific information necessary to operate with a specific piece of hardware. For example, it operates with the bus protocol that is required to interface with the hardware and it issues the proper commands to cause the hardware to perform a specific operation. It also writes to the correct CSRs and uses the correct doorbell mechanism, etc. In order to cause the hardware to perform the requested operations, the HCA agent  actually drives the required bits on the wires that connect it to the channel adapter hardware . Thus, the HCA Agent  is the entity that performs the creation and initialization of queue pairs and completion queues and posts send and receive work queue elements in the channel adapter .","In general, the HCA agent  does not perform any verification except during a few circumstances involving completions where the completion queue agent  of the verification mechanism  cannot verify the exact timing of interrupts since these are hardware-dependent. Consequently, the completion queue agent , via the interface , requests that the HCA agent  verify these interrupt timings as schematically indicated by the arrow .","Verification of the channel adapter operation is performed by the verification mechanism . In particular, the instructions generated by the test agent  that are used by the HCA agent  to control the channel adapter  are also applied to the transport agent  as schematically illustrated by arrow . In response to these instructions, the transport agent  controls the completion queue agent  as indicated by arrow  and the service agent  as indicated by arrow  to create the appropriate components that verify that the operations of the channel adapter  that have been requested by the HCA agent  are performed correctly.","In one embodiment, the verification mechanism  is implemented with an object-oriented software program and each of the verification mechanism components is implemented by an object.  illustrate some of the classes used to instantiate objects that implement the verification mechanism components and the major methods used in these classes. In order to clarify the description, internal data structures and conventional constructor, \u201cget\u201d and \u201cset\u201d methods have been omitted from these figures. However, these additional structures and methods would be well known to those skilled in the art. In addition, although an object-oriented implementation has been illustrated, those skilled in the art would realize that alternative implementations are possible, including non object-oriented programs, hardware and combinations of the two implementations.",{"@attributes":{"id":"p-0061","num":"0069"},"figref":"FIG. 4","b":["402","404","402","300","310","402","300"]},"Similarly, the createQueuePair( ) method causes the service agent component  to create and initialize a queue pair object (described below) and its appropriate send and receive queue objects (also described below) for verifying the creation and operation of a queue pair in the channel adapter hardware. The queue pair object and related queue objects can be manipulated via other methods in the transport agent object. For example, the transitionQueuePairState( ) method informs the queue pair object that a state transition of a specified queue pair number has been requested and is expected. Similar methods are provided to verify the modification of the attributes of a queue pair (modifyQueuePair( )) and retrieve the attributes of a queue pair (queryQueuePair( )). A further method is used first to verify the destruction of a queue pair (destroyQueuePair( )) and then to destroy the related queue pair and queue objects in the verification mechanism.","Additional methods are provided to instruct the completion queue agent component  to create and destroy completion queue objects (createCompletionQueue( ) and destroyCompletionQueue( ), respectively) that verify the creation and destruction of completion queues in the channel adapter hardware. Further methods cause the service agent component  to verify that send requests have been posted (postSendRequest( )) and receive requests have been posted (postReceiveRequest( )) in the channel adapter. Private methods  of the transport agent object validate queue pair numbers, queue pair attributes, send work queue elements and receive work queue elements (validQpNumber( ), validQpAttributes( ), validSendWqe( ) and validRecvWqe( ), respectively).",{"@attributes":{"id":"p-0064","num":"0072"},"figref":["FIG. 5","FIG. 4"]},"The registerWorkCompletionEvent( ) method is called by a completion agent component to register an event to be triggered when a completion is generated by the channel adapter for that particular completion queue. The getCompletions( ) method can also be called by a completion agent component when the aforementioned event is triggered in order to obtain a linked list of completions.","An additional method, expectSolicitedEvent( ), informs the channel adapter agent object that events requested by the verification system are to be expected by the channel adapter. Therefore, if these events are not received, an error will be detected. Additional methods allow a queue pair state transition requested by the transport agent object to be verified (verifyQueuePairStateTransition( )) and a work completion event to be registered (registerWorkCompletionEvent( )). Methods are also provided for validating memory access (validMemoryAccess( )), obtaining memory data (getMemoryData( )) and getting the number of data segments in each send request (getNumDataSegmentsSendRequests( )). An initiateTesting( ) method informs the channel adapter agent object that testing is to begin.",{"@attributes":{"id":"p-0067","num":"0075"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0068","num":"0076"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0069","num":"0077"},"figref":"FIG. 8","b":["800","802","806","808","804"]},"Each of the service agent subclasses has various methods that post send requests (postSendRequest( ) implementing the abstract postSendRequest( ) method of the base class), validate queue pair attributes (validQpAttributes( )) and validate send work queue element attributes (validSendWqeAttributes( )). Methods are also provided for verifying that send requests have been completed (expectSendWorkCompletion( )) and verifying that send work requests have been signaled (isSendWorkRequestSignaled( )). Although each of objects - has methods with the same names, the implementation of these methods depends on the particular service that the object is designed to verify.","Classes and subclasses that implement objects for verifying queue pairs are shown in . The queue pair base class, IbQp , contains internal data array structures (IbSendQueue and IbReceiveQueue) that store the send and receive queue objects that have been instantiated. The IbQp class also includes methods which allow the verification mechanism to post and remove send requests (send work queue entries), (postSendRequest( ) and removeCurrentSendRequest( )), transition the queue pair state (transitionQpState( )), post receive requests (receive work queue entries) (postReceiveRequest( )) and obtain receive requests from the queue pair (getFirstReceiveRequest( ) and getNextReceiveRequest( )). As with the service agent classes, the queue pair classes are subclassed depending on the type of service that the verification mechanism is intended to verify. Each of subclasses - has three methods which are used to obtain the queue pair attributes and to obtain send requests (getQpAttributes( ), getFirstSendRequest( ) and getNextSendRequest( )). Although the method names are the same in each of the four subclasses, the implementation of these methods would be dependent on the actual service type that the subclass is intended to verify.",{"@attributes":{"id":"p-0072","num":"0080"},"figref":"FIGS. 10 and 11","b":["1000","1100","1000","1100"]},{"@attributes":{"id":"p-0073","num":"0081"},"figref":"FIG. 12","b":"1200"},{"@attributes":{"id":"p-0074","num":"0082"},"figref":"FIG. 13","b":"1300"},{"@attributes":{"id":"p-0075","num":"0083"},"figref":"FIG. 14","b":["1400","1402","1406"]},{"@attributes":{"id":"p-0076","num":"0084"},"figref":"FIG. 15","b":["1500","1500"]},"Class  has a multi-packet outgoing message verifier subclass . This latter subclass is used for the reliable connection and the unreliable connection service types that can contain multiple packets. Subclass  contains several abstract methods that are intended for validating the start message and the end message of a request (validStartOfRequestMessage( ) and validEndOfRequestMessage( )). Class  also contains a method for calculating the total packets in a message (calculateTotalPacketsInMessage( ) and a method that allows the corresponding object to set the expected outgoing packet payload (setOutgoingExpectPacketPayload( )).","The multi-packet outgoing message verifier class  has two subclasses, containing methods whose implementation is dependent on the type of service designed to be verified by the corresponding objects. The RC outgoing message verifier class  generates an object that verifies the reliable connection service type. Alternatively, the UC outgoing message verifier type  generates an object that verifies the unreliable connection service type. These subclasses contain methods that allow objects created from them to verify all outgoing messages (verifyOutgoingMessages( )), create the packets expected to be in outgoing messages for verifying them (createOutgoingExpectPacket( )) and to validate the start and the end messages of the request (validStartOfRequestMessage( ) and validEndOfRequestMessage( )). Note that these latter methods implement the abstract methods of the same name in the parent class .","The outgoing message verifier class  also has an additional subclass  for creating an object that verifies unreliable datagram outgoing messages. This subclass contains methods that allow an object created from it to verify all outgoing messages (verifyOutgoingMessages( )), create expected outgoing packets (createOutgoingExpectPacket( )), validate request messages (validRequestMessage( )) and set an expected outgoing packet payload (setOutgoingExpectPacketPayload( )). A further method (possiblePacketForSendWorkRequest( )) is provided for determining whether a packet is a possible packet resulting from a send work request, since packets are not necessarily transmitted in order in an unreliable datagram service type due to different virtual channel usage.",{"@attributes":{"id":"p-0080","num":"0088"},"figref":"FIG. 16","b":["1600","1600","1600","1602"]},"The multi-packet incoming message verifier class  has two subclasses  and  that are specific to the reliable and unreliable connection service types, respectively. These two subclasses contain methods with the same name, but which are implemented specifically for the type of service that the corresponding object is verifying. The methods include watchIncomingMessages( ) that implements the abstract method of the same name in the base class . An isRdmaWriteOperation( ) method checks to see whether or not the operation is an RDMA write operation. Further methods validate the packet opcode sequence (validOpcodeSequence( )), the start and end of request messages (validStartOfRequestMessage( ) and validEndOfRequestMessage( )) and the completed received message (verifyCompletedReceiveMessage( )). A further method, expectReceiveWorkCompletion( ), informs the associated completion agent object that a receive work completion is expected upon receipt of all packets for a message so that the message can be verified.","The incoming message verifier class  also has an unreliable datagram incoming message verifier subclass . This class contains methods that allow the resulting object to watch for incoming messages (watchIncomingMessages( )), validate a request message (validRequestMessage( ), verify the received data (verifyReceivedData( )), verify a completed receive message and verify the data for a complete send operation (verifyCompletedReceiveMessage( ) and verifyCompletedSendMessageData( )). Further methods allow the memory and packet data to be compared (compareMemoryDataAndPacketData( )) and informs the associated completion queue agent object that a receive work completion is expected upon receipt of all packets for a message so that the message can be verified (expectReceiveWorkCompletion.)",{"@attributes":{"id":"p-0083","num":"0091"},"figref":"FIGS. 17-20"},{"@attributes":{"id":"p-0084","num":"0092"},"figref":"FIG. 17","b":["1700","1702","1704","1706","1708","1710"]},"In step , the completion queue verification object self-calls its own verifyWorkComplete( ) method. The method starts a thread to verify all new work completions and the routine finishes in step .",{"@attributes":{"id":"p-0086","num":"0094"},"figref":["FIG. 18","FIG. 18"],"b":["1800","1802","1804","1806"]},"In step , the test agent object instructs the transport agent object to create a queue pair verification object. It does this by calling the createQueuePair( ) method of the transport agent object, again passing in the attributes that were created in response to the request from the test system.","In step , in response to the call to the createQueuePair( ) method, the transport agent object creates a new service agent verification object that, in turn, instantiates a new queue pair verification object. Next, in step , the service agent object, instantiated in step , instantiates new incoming and outgoing message verifier objects. The initialization process then ends in step .","The incoming and outgoing message verifier objects verify the incoming messages and outgoing messages, respectively, that are received and sent from the queue pair. An incoming message object and an outgoing message object are instantiated by each service object that is created by a queue pair object.  is a flowchart that illustrates the initialization process that takes place when a UC incoming message verifier object is instantiated. The corresponding processes for RC, RD and UD message types are very similar and, therefore, are not shown for clarity. This process begins in step  and proceeds to step  where the incoming UC message verifier object registers a receive completion event with the completion agent object. It does this by calling the registerReceiveCompletionEvent( ) method of the completion queue agent, passing in the appropriate parameters.","Next, in step , the incoming message verifier object registers an interest in receiving notifications of incoming packets. This interest is registered in an incoming packet event filter in the network verification layer mechanism that is located in the incoming path from the switch fabric. The incoming message verifier object registers this interest by calling a setPacketEvent( ) method in the incoming packet event filter, passing in the appropriate parameters.","In step , the incoming message verifier object then starts a thread to watch incoming messages to the queue pair by calling its own watchIncomingMessage( ) method. Next, in step , the incoming message verifier object starts a thread to verify incoming messages by calling its own verifyReceivedData( ) method. The initialization process then finishes in step . The watch incoming messages thread continuously waits for notifications of an incoming packet event for which an interest was registered in step . When the event is triggered, the watch incoming messages thread stores copies of packets as the packets are received. Once all packets for a message have been received, the thread notifies the verify received data thread that a new message has been received and needs to be verified. The verify received data thread then examines the message and either prints an error or verifies that the message is correct.",{"@attributes":{"id":"p-0092","num":"0100"},"figref":"FIG. 20","b":["2000","2002"]},"In step , the incoming message verifier object starts a thread to verify outgoing messages by calling its own verifyOutgoingMessages( ) method. This thread continuously waits on the outgoing packet event for which an interest was registered in step . When the event is triggered, the outgoing verifier object verifies the packets as the packets are sent.",{"@attributes":{"id":"p-0094","num":"0102"},"figref":["FIGS. 21-24","FIGS. 21A and 21B","FIG. 22","FIGS. 23A","FIGS. 24A"]},"In particular, , when placed together, form a flowchart that illustrates the steps in a process for posting a send work queue element on a work queue in a local (source) channel adapter and the reception of the corresponding receive request in a remote (destination) channel adapter. This results in the posting of a receive work queue element on the remote work queue.","The local channel adapter would have previously been instructed to create a queue pair as set forth in the example process illustrated in . As with this previous example, the process proceeds in two branches in which the local channel adapter is first instructed to post a send work queue element and the remote channel adapter is instructed to create a queue pair and post a receive work queue element. Then the appropriate incoming and outgoing message verification objects are created in the local and remote verification mechanisms to verify that the posting and reception occurred properly.","This process starts in step  and proceeds to step  where a testing program, or controller, instructs a local test agent object to build a send work queue element. In response, in step , the local test agent builds the work queue element attributes. Then, in step , the local test agent object calls a postSendRequest( ) method in a local HCA agent. In response, in step , the local HCA agent object instructs the local channel adapter hardware to post a send work queue element on the previously created queue pair. Then, in step , the test agent object calls a postSendRequest( ) method in a local transport agent object in the verification mechanism that verifies the operation of the local channel adapter hardware. The local transport agent would have been previously instructed to create verification objects for the creation of a queue pair. These verification objects include a local service agent and its accompanying local queue pair agent. The local transport agent object, in response, in step , calls a postSendRequest( ) method in a local service agent object.","The process then proceeds, via off page connectors  and , to step  where the local test agent object then calls a buildRecvWqeAttributes( ) method, or a similar method, in a remote test agent object. This instruction causes the remote test agent object to call a postReceiveRequest( ) method in a remote HCA agent object as set forth in step .","Next, in step , the remote HCA agent object instructs the remote channel adapter hardware to create a queue pair along the lines of the process set forth in . Then, in step , the remote test agent calls a postReceiveRequest( ) method in a remote transport agent object. Finally, in step , the remote transport agent object calls a postReceiveRequest( ) method in a remote service agent object. The process then finishes in step .",{"@attributes":{"id":"p-0100","num":"0108"},"figref":"FIG. 22","b":["2200","2202","2204"]},"If the outgoing packet is a valid start of request, the process proceeds to step  where the first send work queue entry is retrieved and, in step , the total number of packets in the message is calculated from information in the work queue entry. The process then proceeds to step . Alternatively, if the outgoing packet is not a valid start of request the process proceeds directly to step .","Next, in step , an outgoing packet that would be expected from the packet data and information in the work queue entry is created by calling the createOutgoingExpectPacket( ) method of the outgoing verifier object. In step , the expected and actual packets are compared and an error is generated is the packets are not the same.","If the packets are the same, a check is made in step  to determine if the packet being examined is the last packet in the message. If so, the current send work queue entry is removed and the process proceeds to step  to wait to be notified of another outgoing packet event. Alternatively, if in step , a determination is made that the packet is not the last packet in the message the process proceeds directly to step . Operation continues in this manner as the process is notified of additional outgoing packets.",{"@attributes":{"id":"p-0104","num":"0112"},"figref":["FIGS. 23 and 24","FIGS. 23A-23C"],"b":["2300","2302","2304","2308","2310","2306","2304","2308"]},"If, in step , the packet checks are passed, then the process proceeds to step  where a check is made to determine whether the packet serial number of the received packet is equal to the packet serial number that was expected, indicating that the packet is part of the message being processed. If a packet with an unexpected serial number is received, then, in step , the a determination is made whether the packet is the first packet in a group of packets for the message being processed or is the only packet that will be received in the message. If additional packets are part of the message, then the received packet is part of another message and the process proceeds to step  where the packet is dropped. The process then waits for another packet in step .","Alternatively, if, in step , a determination is made that the received packet is the first packet of a message or that the received packet is the only packet of a message, then the process proceeds, via off-page connectors  and , to step  where the expected packet serial number is set to the actual packet serial number. The process then proceeds to step . Alternatively, if the actual packet serial number of the received packet was the expected serial number as determined in step , then the process proceeds, via off-page connectors  and , directly to step .","In step , the packet op code sequence is examined by calling the validOpcodeSequence( ) method of the incoming message verifier object. If the op code sequence is not valid, then the process proceeds, via off-page connectors  and  back to step  where the packet is discarded and the process repeated with the next received packet.","If the op code sequence is valid, as determined in step , then a determination is made whether the packet is the first packet in a group of packets for the message being processed or is the only packet that will be received in the message. If so, the process proceeds to step  where the number of packet tags is set to zero. Alternatively, if the received packet is not the first packet in a group of packets or is not the only packet, step  is skipped.","Next, in step , a determination is made whether the operation from which the message was generated is an RDMA write operation by calling the isRdmaWriteOperation( ) method of the incoming message verifier object. If so, the process proceeds, via off-page connectors  and  to step  and  where additional checks are made to determine whether the RDMA write operation is allowed and whether the RKEY used in the operation is valid. If either of these checks is not passed, the process proceeds, via off-page connectors ,  and , , back to step  where the packet is dropped and the process repeated for the next received packet.","If the operation is not an RDMA write operation as determined in step , the process proceeds, via off-page connectors  and  to step . The process also arrives at step  if all of the RDMA write checks have been passed. In step , the packet information is saved and a check is made in step  whether the received packet is the last packet of the message. If it is not the last packet, then the process proceeds, via off-page connectors ,  and , , back to step  where the process waits for another packet to be received.","If, in step , a determination is made that the received packet is the last packet in the message, then the process proceeds to step  where the packet information is put on a list. Then, in step , a determination is made whether the message consumes the entire work queue entry. If it does, then the thread informs the associated completion queue agent object that a receive work completion event is expected so that the message can be verified. The thread does this by calling the expectReceiveWorkCompletion( ) method of the incoming message verifier object. Alternatively, if, in step , it is determined that the message does not consume the entire work queue entry, then the process proceeds, via off-page connectors ,  and , , back to step  where the process waits for another packet to be received. Operation continues in this manner until the entire incoming message has been received.","When the receive work completion event is triggered, the completion queue agent starts verification of the received message by calling the verifyCompletedReceiveMessage( ) method of the incoming message verifier object. This method informs the verify received data thread to verify the newly received message.",{"@attributes":{"id":"p-0113","num":"0121"},"figref":["FIGS. 24A and 24B","FIG. 23C"],"b":["2400","2402","2404","2408","2366","2410","2414","2422","2434","2438"]},"Alternatively, if in step , a determination is made that the message consumes the entire work queue entry, then the operation involves a single message and could be either an RDMA operation or a send operation. In order to determine which operation is involved the process proceeds to step  where the first receive work queue entry is retrieved. The process then proceeds, via off-page connectors  and  to step .","In step , a determination is made whether the message payload is empty. If the payload is not empty, then the process proceeds to step  where a determination is made whether the message is a send message or an RDMA message. If the message is a send message, then the send data is verified in step  by calling the verifyCompletedSendMessageData( ) method of the multi-packet incoming message verifier object. Alternatively, if the message is part of an RDMA operation, then the RDMA data is verified by calling the verifyCompletedRdmaWriteMessageData( ) method of the multi-packet incoming message verifier object.","The process then proceeds to step . The process also arrives here if the work queue entry was consumed in step  and if the payload was empty as determined in step . In step , the success of the previously described operations is tested. If these operations were not successful, an error is printed in step  and the process proceeds, via off-page connectors  and , to step  where the process waits for the next receive completion event to occur.","Alternatively, if a determination is made in step  that the operation was successful, then, in step , a determination is made whether the message that was just processed consumes the work queue entry. If it does, then the work queue entry is removed in step  and the process proceeds, via off-page connectors  and , to step  where the process waits for the next receive completion event to occur. Alternatively, if the message does not consume the work queue entry, then the process proceeds, via off-page connectors  and , back to step  where the message information from the next message is retrieved from the message list. This information is then processed as described above. Operation continues in this manner as each receive completion event occurs.","A software implementation of the above-described embodiment may comprise a series of computer instructions either fixed on a tangible medium, such as a computer readable media, for example, a diskette, a CD-ROM, a ROM memory, or a fixed disk, or transmittable to a computer system, via a modem or other interface device over a medium. The medium either can be a tangible medium, including but not limited to optical or analog communications lines, or may be implemented with wireless techniques, including but not limited to microwave, infrared or other transmission techniques. It may also be the Internet. The series of computer instructions embodies all or part of the functionality previously described herein with respect to the invention. Those skilled in the art will appreciate that such computer instructions can be written in a number of programming languages for use with many computer architectures or operating systems. Further, such instructions may be stored using any memory technology, present or future, including, but not limited to, semiconductor, magnetic, optical or other memory devices, or transmitted using any communications technology, present or future, including but not limited to optical, infrared, microwave, or other transmission technologies. It is contemplated that such a computer program product may be distributed as a removable media with accompanying printed or electronic documentation, e.g., shrink wrapped software, pre-loaded with a computer system, e.g., on system ROM or fixed disk, or distributed from a server or electronic bulletin board over a network, e.g., the Internet or World Wide Web.","Although an exemplary embodiment of the invention has been disclosed, it will be apparent to those skilled in the art that various changes and modifications can be made which will achieve some of the advantages of the invention without departing from the spirit and scope of the invention. For example, it will be obvious to those reasonably skilled in the art that, in other implementations, different arrangements can be used for the verification components, including non-object-oriented programs and hardware implementations. Other aspects, such as the specific process flow, as well as other modifications to the inventive concept are intended to be covered by the appended claims"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The above and further advantages of the invention may be better understood by referring to the following description in conjunction with the accompanying drawings in which:",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1","sup":"SM"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIGS. 21A and 21B"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIGS. 23A-23C"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIGS. 24A and 24B"}]},"DETDESC":[{},{}]}
