---
title: Field level concurrency and transaction control for out-of-process object caching
abstract: A method includes executing a multi-threaded, object-oriented application (OOA) on a device; receiving, by multiple threads of the OOA, an object from an out-of-process cache memory; mutating one or more fields of the object, wherein the one or more fields correspond to one or more attributes of the object; and applying an update of the one or more fields that have been mutated to the out-of-process cache memory, wherein the applying the update updates the one or more fields mutated at a field level and not at an object level.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08364903&OS=08364903&RS=08364903
owner: Verizon Patent and Licensing Inc.
number: 08364903
owner_city: Basking Ridge
owner_country: US
publication_date: 20091222
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS"],"p":["Large enterprise-class object-oriented applications (OOAs) may rely on out-of-process object caching solutions to provide high scalability and uninterrupted service in case an application server fails. Although usage of an out-of-process object caching solution may provide scalability and uninterrupted service, other problems may arise, such as response time and coherence of objects.","The following detailed description refers to the accompanying drawings. The same reference numbers in different drawings may identify the same or similar elements. Also, the following detailed description does not limit the invention.","The term \u201cfield,\u201d as used herein, is intended to be broadly interpreted to include a characteristic or an attribute of an object.","The term \u201ccoherence,\u201d as used herein, is intended to be broadly interpreted to include a consistency of an object. By way of example, but not limited thereto, a shared object stored in a cache memory may be subject to changes or mutations to fields of the shared object by multiple threads of an OOA. In such instances, coherence of the shared object includes managing a solidarity associated with the temporal state changes of the shared object.","As the name suggests, out-of-process object caching may run outside of a corresponding application process. Typically, for a Java-based application, an out-of-process caching process may run in one or more Java Virtual Machines (JVMs). In multi-threaded, single or multiple JVM process applications, object level retrieval from and object level replacement to the out-of-process cache, by multiple threads on a shared object, may adversely impact the coherence of the shared object.  is a diagram illustrating an implementation of integrating out-of-process object caching without isolation. As illustrated, a multi-threaded application including thread  and thread  may be executing application processes  and , respectively. Referring to , thread  may get  an object (e.g., a copy of the object) from a cache memory. For purposes of discussion, the object may include fields A, B, and C. Thread  may cause field A of the object to mutate  to A. Concurrently, thread  may also get  the object (e.g., the copy of the object) from the cache memory. Thread  may cause fields B and C of the object to mutate  to B and C, respectively. During this time, thread  may put  the mutated object (e.g., A, B, C) back to the cache memory. Subsequently, thread  may put  the mutated object (e.g., A, B, C) back to the cache memory. In such an instance, thread  is essentially overwriting the changes to field A of the object provided by thread . As further illustrated, subsequently, thread  may get  the overwritten object (e.g., A, B, C).","In this example, even though each of thread  and thread  is able to obtain a copy of the object without contention, object mutations that occur in overlapping time allows one thread (e.g., thread ) to override a state of the object (e.g., one or more fields of the object) at the end of its transaction vis-\u00e0-vis another object mutation associated with another thread (e.g., thread ). In such instances, coherence is not maintained and may, among other things, adversely impact application accuracy (e.g., object consistency).","One approach to avoid object overriding is to add isolation to transactions by utilizing a lock\/unlock application programming interface (API).  is diagram illustrating an implementation of integrating out-of-process object caching with isolation. As illustrated, a multi-threaded application including thread  and thread  may be executing application processes  and , respectively. Referring to , thread  may lock and get  an object (e.g., a copy of the object) from a cache memory. For purposes of discussion, the object may include fields A, B, and C. Thread  may cause field A of the object to mutate  to A. Concurrently, thread  may try lock  of the object, but may be blocked  since thread  has the object in a lock state. In this instance, thread  must wait.","Thread  may complete the mutation of field A of the object and put and unlock  the object (e.g., A, B, C) to a cache memory. Thereafter, thread  may lock and get  the object (e.g., A, B, C), which has been mutated by thread , from the cache memory. Thread  may cause fields B and C of the object to mutate  to B and C, respectively. Thread  may put and unlock  the object (e.g., A, B, C) into the cache memory. Thread  may lock and get  the object that includes the collective mutations of the object previously applied by thread  and thread .","In this example, object level retrieval from and object level replacement to the out-of-process cache memory may not cause a disruption in coherence due to the locking and unlocking of objects. However, threads must process shared objects in a serial manner, which causes, among other things, time inefficiencies, disruption of application flow, etc.","According to an exemplary embodiment, in a multi-threaded, single or multiple JVM-based application, threads may mutate objects at the field level and update the object in the cache memory by providing only the mutated field of the object to the cache memory versus replacing the entire object. The exemplary embodiment may be applicable to single or multiple JVMs in which multiple threads may mutate disjoint fields of a shared object.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 3","FIG. 3"],"b":["1","2","1","2","1","305","1","310","1","2","315","2","320","2","2"]},"As further illustrated in , thread  may apply  field A to the cache memory. Thread  may apply  field B and field C to the cache memory. As will be described in greater detail below, a synchronization mechanism may coordinate the updating of fields associated with the object to the cache memory. Thereafter, thread  may get  the updated object that includes the updated fields (e.g., A, B, C) from the cache memory.","As a result of the foregoing, multiple threads may mutate disjoint fields of the shared object in parallel while maintaining the coherence of the shared object. In this way, application performance, reliability, consistency, etc., may not be compromised.","Since an exemplary embodiment has been broadly described, a more detailed description of this embodiment and other exemplary embodiments are provided below.","Single or multiple JVM-based applications that utilize out-of-process caching has wide applicability. By way of example, but not limited thereto, web-based systems, client\/server systems, peer-to-peer systems, etc., may employ this type of architecture.  is a diagram illustrating an exemplary environment in which out-of-process object caching with field level concurrency may be implemented. As illustrated in , exemplary environment  may include users - through -M (referred to generally as users  or user ), user devices - through -M (referred to generally as user device  or user device ), application servers - through -N (referred to generally as application servers  or application server ), and cache servers - through -Y (referred to generally as cache servers  or cache server ).","The number of devices and configuration in environment  is exemplary and provided for simplicity. In practice, environment  may include more devices, fewer devices, different devices, and\/or differently arranged devices than those illustrated in . For example, application server  and cache server  may be combined into a single device. In such an implementation, there may exist separate process boundaries between the application server  and cache server . Also, some functions described as being performed by a particular device may be performed by a different device or a combination of devices. Environment  may include wired and\/or wireless connections among the devices illustrated.","User device  may include a computational device having the capability to communicate with other devices, systems, networks, and\/or the like. By way of example, but not limited thereto, user device  may correspond to a mobile telephone, a computer (e.g., a desktop, a laptop, a palmtop, etc.), a personal digital assistant (PDA), a personal communication system (PCS) terminal, a pervasive computing device, and\/or some other type of mobile device or stationary device.","Application server  may include a computational device having the capability to communicate with other devices, systems, networks, and\/or the like. For example, application server  may include a computer, a server, or some other type of device. In an exemplary implementation, application server  may include one or more multi-threaded JVM-based applications. By way of example, but not limited thereto, one or more of the multi-threaded JVM-based applications may provide services to users .","Cache server  may include a computational device having the capability to communicate with other devices, systems, networks, and\/or the like. For example, cache server  may include a computer, a server, or some other type of device. In an exemplary implementation, cache server  may store and manage one or more databases of objects (e.g., master copies of objects, shared objects, etc.) which may be utilized by multi-threaded JVM-based applications residing on application server .",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 5","FIG. 5"],"b":["500","400","500","410","415","420","500","505","510","515","520","525","530","500"]},"Processing system  may include one or more processors, microprocessors, data processors, co-processors, application specific integrated circuits (ASICs), controllers, programmable logic devices, chipsets, field programmable gate arrays (FPGAs), or some other component that may interpret and\/or execute instructions and\/or data. Processing system  may control the overall operation, or a portion thereof, of device , based on, for example, an operating system and\/or various applications (e.g., applications ).","Memory\/storage  may include one or more memories and\/or one or more secondary storages. For example, memory\/storage  may include a random access memory (RAM), a dynamic random access memory (DRAM), a read only memory (ROM), a programmable read only memory (PROM), a flash memory, and\/or some other type of memory. Memory\/storage  may include a hard disk (e.g., a magnetic disk, an optical disk, a magneto-optic disk, a solid state disk, etc.) or some other type of computer-readable medium, along with a corresponding drive. Memory\/storage  may include a memory, a storage device, or storage component that is external to and\/or removable from device , such as, for example, a Universal Serial Bus (USB) memory stick, a hard disk, mass storage, off-line storage, etc.","The term \u201ccomputer-readable medium,\u201d as used herein, is intended to be broadly interpreted to include, for example, a memory, a storage device (e.g., a hard disk and corresponding drive), a compact disc (CD), a digital versatile disc (DVD), or the like. The computer-readable medium may be implemented in a single device, in multiple devices, in a centralized manner, or in a distributed manner. Memory\/storage  may store data, application(s), and\/or instructions related to the operation of device .","Applications  may include software that provides various services or functions. For example, with reference to application server , applications  may include one or more multi-threaded JVM-based application. Additionally, with reference to application server , applications  may include one or more applications that provide for data (e.g., object) coherence with respect to an out-of-process cache architecture. Additionally, with reference to cache server , applications  may include one or more applications that provide data (e.g., object) coherence with respect to an out-of-process cache architecture.","Communication interface  may permit device  to communicate with other devices, networks, systems and\/or the like. Communication interface  may include one or more wireless interfaces and\/or wired interfaces.","Input  may permit an input into device . For example, input  may include a button, a keypad, a knob, a touchpad, a keyboard, an input port, a display, a microphone, voice recognition logic, fingerprint recognition logic, a web cam, and\/or some other type of input component.","Output  may permit device  to provide an output. For example, output  may include a display, light emitting diodes (LEDs), an output port, speakers, a vibratory mechanism, and\/or some type of output component.","As described herein, device  may perform operations in response to processing system  executing software instructions contained in a computer-readable medium, such as memory\/storage . The software instructions may be read into memory\/storage  from another computer-readable medium or from another device via communication interface . The software instructions contained in memory\/storage  may cause processing system  to perform processes described herein. Alternatively, hardwired circuitry may be used in place of or in combination with software instructions to implement processes described herein. Thus, implementations described herein are not limited to any specific combination of hardware circuitry and software.","As previously described, multi-threaded JVM-based applications may update fields of a shared object with respect to an out-of-process cache. Described below are exemplary functional components associated with application server  and cache server .",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 6A","FIG. 6A"],"b":["415","415","600","600","605","610","1","610","610","610","600","615","620","625"]},"JVM  may include a Java Virtual Machine. By way of example, but not limited thereto, although not illustrated, JVM  may include a class loader subsystem and an execution engine. JVM  may also organize the memory it needs to execute a program (e.g., a method area, a heap, a Java stack, program counter registers, etc.).","Multi-threaded OOA  may include an object-oriented application. By way of example, but not limited thereto, multi-threaded OOA  may correspond to a multi-threaded Java application, a multi-threaded C++ application, or a multi-threaded .NET application. Threads  may include processes of execution associated with multi-threaded OOA . In an exemplary implementation, as illustrated in , multi-threaded OOA  may correspond to a multi-threaded, multi-JVM-based application.","In an exemplary embodiment, multi-threaded OOA  may collect field mutations of one or more objects from one or more threads . In some instances, the one or more objects may correspond to one or more shared objects. Additionally, multi-threaded OOA  may determine when the one or more fields of the one or more objects may be updated to an out-of-process cache memory. By way of example, but not limited thereto, multi-threaded OOA  and\/or thread  may determine when the shared object may be updated to the cache memory based on shared object and\/or field(s) of shared object visibility, a scope of a call method, and\/or an application flow. For example, assume that thread - (e.g., thread) gains visibility of the shared object during execution of a method (e.g., a method A). Thereafter, either the method A may mutate one or more fields of the shared object directly or may pass the reference of the shared object to one or more other methods. For example, assume that the method A may pass the reference of the shared object to a chain of methods (e.g., a method B, a method C, a method D, etc.) which may mutate one or more fields of the shared object.","Thread - (e.g., thread ) may apply one or more field mutations of the shared object to a local copy of the shared object. In addition, thread - may start recording mutations performed by the chain of methods (e.g., the method B, the method C, etc.) associated with thread . Subsequently, the chain of methods may complete their mutations and return the shared object to the method A. The method A may then make a last mutation to one or more fields of the shared object. The method A may send a batch of field-level updates to the cache memory, which may include the mutations collected during a recording of the mutations performed by the chain of methods. In other words, thread  may start collecting mutations of the shared object when the shared object may be visible to thread  and may then apply the collected mutations to the cache memory before thread  may lose visibility of the shared object.","In another exemplary implementation, thread  may decide to send an update (e.g., a batch update) for the shared object to the cache memory based on thread notification\/communication boundaries. By way of example, but not limited thereto, assume thread - (e.g., thread ) mutates one or more fields of the shared object. Thereafter, thread - may notify another thread - (e.g., thread) for various reasons (e.g., thread - has reached a certain logical point in the application flow). In an exemplary case, thread - may work on the same shared object and may perform its own mutations on one or more fields of the shared object. In this way, thread notification\/communication boundaries may provide a basis for sending an update (e.g., a batch update) of the shared object to the cache memory.","Coherence client  may manage the coherence of objects utilized by multi-threaded OOA . In an exemplary implementation, as previously described, coherence client  may include, among other functional components, object fetcher  and object field poster . Object fetcher  may fetch objects from a cache memory (e.g., residing on cache server ). By way of example, but not limited thereto, object fetcher  may receive a call from multi-threaded OOA  to get one or more objects. Object fetcher  may retrieve the one or more objects from the cache memory and pass the one or more objects to multi-threaded OOA . Threads  of multi-threaded OOA  may then mutate one or more fields of the one or more objects, which may be stored locally on application server . In some instances, the one or more objects may correspond to one or more shared objects. In other instances, the one or more objects may not correspond to one or more shared objects.","Object field poster  may post updates of objects or one or more fields of objects to a cache memory (e.g., residing on cache server ). By way of example, but not limited thereto, object field poster  may receive a call from multi-threaded OOA  to post updates to one or more objects. In some instances, the update may correspond to a replacement post (e.g., updating an object at an object level). In other instances, the update may correspond to a field post (e.g., updating an object at a field level).","Although  illustrates exemplary functional components of an exemplary application server , in other implementations, application server  may include fewer functional components, additional functional components, different functional components, and\/or a different arrangement of functional components than those illustrated in  and described. Additionally, or alternatively, one or more operations described as being performed by a particular functional component may be performed by one or more other functional components, in addition to or instead of the particular functional component.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 6B","FIG. 6B"],"b":["420","420","630","635","640"]},"JVM  may include a Java Virtual Machine. By way of example, but not limited thereto, although not illustrated, JVM  may include a class loader subsystem and an execution engine. JVM  may also organize the memory it needs to execute a program (e.g., a method area, heap, Java stacks, program counter registers, etc.).","Coherence server  may manage the coherence of objects utilized by multi-threaded OOA  (e.g., a multi-threaded, single or multiple JVM-based application). In an exemplary implementation, as previously described, coherence server  may include, among other functional components, object field updater . Object field updater  may manage the updating of objects and one or more fields of objects (e.g., master copies of objects, fields, etc.) stored in a cache memory. In an exemplary implementation, object field updater  may manage a queue (e.g., first-in first-out (FIFO) queue) to which updates to objects and fields of objects may be posted by object field poster  of coherence client . In this way, a synchronization mechanism is provided for updating objects (e.g., at an object level) and fields of objects (e.g., at a field level). Object field updater  may store the updates to objects and fields of an object to the cache memory as such updates may be received by the queue.","Although  illustrates exemplary functional components of cache server , in other implementations, cache server  may include fewer functional components, additional functional components, different functional components, and\/or a different arrangement of functional components than those illustrated in  and described. Additionally, or alternatively, one or more operations described as being performed by a particular functional component may be performed by one or more other functional components, in addition to or instead of the particular functional component.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 6C","b":["415","420","605","415","640","645","625","420","650","655","1","655","655","655"]},"Referring to , it may be assumed that multi-threaded OOA  may be executing and issues a call (e.g., a get ) to coherence client  to obtain one of objects  from cache memory  via coherence server . Based on the call (i.e., get ), object fetcher  of coherence client  may retrieve the object and pass it to multi-threaded OOA . In this example, it may be assumed that the object corresponds to a shared object and that one or more threads  may mutate one or more fields of the shared object. Additionally, it may be assumed that the shared object and\/or the one or more fields of the shared object remain visible to one of threads . In such an instance, multi-threaded OOA  may collect  the one or more fields that have been mutated. For example, multi-threaded OOA  may collect the one or more fields of the shared object as the one or more fields are being mutated by one or more threads ","In an exemplary implementation, based on the application flow, multi-threaded OOA  may determine to update the mutated fields to cache memory . In such an instance, in an exemplary implementation, multi-threaded OOA  may issue a call (e.g., a post ) to coherence client . Post  may indicate to coherence client  to update the mutated fields of the shared object to cache memory .","Object field poster  may receive post  and may provide post  to cache server . As previously described, in an exemplary implementation, object field updater  may manage queue  that the mutated fields of the shared object. Object field updater  may update the mutated fields of the shared object in cache memory  according to an order in which the update (e.g., post ) is received in queue .",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 7","b":["700","700","415","420"]},"Process  may include executing a multi-threaded OOA (block ). For example, application server  may execute a multi-threaded, single or multiple JVM-based application. In an exemplary implementation, the multi-threaded JVM-based application may provide services to one or more users. It may be assumed that multiple threads may be executing.","An object from an out-of-process cache memory may be received (block ). For example, object fetcher  of coherence client  may get an object from cache memory  via coherence server  of cache server . In an exemplary implementation, object fetcher  may get the object based on a call from the multi-threaded JVM-based application. The object may be provided to the multi-threaded JVM-based application. In an exemplary implementation, the object may correspond to a shared object.","One or more fields of the object may be mutated (block ). For example, one or more threads may mutate one or more fields of the object. In an exemplary implementation, the one or more fields mutated may be disjoint with respect to each thread.","The one or more fields mutated may be collected (block ). For example, as previously described, the JVM-based application or one or more of threads  may collect one or more fields of the object, which have been mutated.","It may be determined when to update the out-of-process cache with a field level update (block ). For example, as previously described, the JVM-based application or one or more threads  may determine when to update cache memory  at a field level. By way of example, but not limited thereto, the JVM-based application or one or more threads  may determine when to update cache memory  at a field level based on a visibility of the shared object and\/or field(s) of the shared object, a scope of a call method, an application flow, etc.","In an exemplary implementation, when the JVM-based application or one or more threads  may determine to update cache memory  at the field level, the JVM-based application or one or more threads  may issue a call to coherence client . In some instances, the call may include a batch, field level update of the shared object.","One or more fields of the object may be updated to the out-of-process cache memory (block ). For example, object field poster  of coherence client  may receive the call and apply each updated field of the object to cache memory  via object field updater  of coherence server . As previously described, in an exemplary implementation, object field updater  may manage a queue  to receive field level updates associated with an object from multiple threads. Object field updater  may update the fields in accordance with queue . By way of example, but not limited thereto, queue  may correspond to a FIFO queue.","Although  illustrates an exemplary process  in which field level updates of an object to an out-of-process cache memory may be implemented, in other implementations, process  may include additional operations, fewer operations, and\/or different operations than those illustrated in  and described. For example, multi-threaded OOA  may update at the object level. Additionally, multi-threaded OOA  may update fields of a shared object when the mutations of fields may not be disjoint.","The foregoing description of implementations provides illustration, but is not intended to be exhaustive or to limit the implementations to the precise form disclosed. Accordingly, modifications to the implementations described herein may be possible. For example, although this description has described exemplary embodiments with respect to the JAVA programming language, in other implementations, object-oriented programming languages, other than JAVA may be utilized. By way of example, but not limited thereto, in other embodiments, the C++ programming language and the .NET programming language may be implemented.","The terms \u201ca,\u201d \u201can,\u201d and \u201cthe\u201d are intended to be interpreted to include one or more items. Further, the phrase \u201cbased on\u201d is intended to be interpreted as \u201cbased, at least in part, on,\u201d unless explicitly stated otherwise. The term \u201cand\/or\u201d is intended to be interpreted to include any and all combinations of one or more of the associated items.","In addition, while a series of blocks has been described with regard to the process illustrated in , the order of the blocks may be modified in other implementations. Further, non-dependent blocks may be performed in parallel.","It will be apparent that the embodiments described herein may be implemented in many different forms of software or firmware in combination with hardware in the implementations illustrated in the figures. The actual software code (executable by hardware) or specialized control hardware used to implement the device, method, and\/or system does not limit the disclosure of the invention. Thus, the operation and behavior of the devices and\/or systems, or the performing of the methods was described without reference to the specific software code\u2014it being understood that software and control hardware can be designed to implement the device, method, and\/or system based on the description herein.","Further certain features described above may be implemented as \u201clogic\u201d that performs one or more functions. This logic may include hardware, such as one or more processors, one or more microprocessors, one or more ASICs, one or more FPGAs, etc., software, or a combination of hardware and software.","In the preceding specification, various embodiments have been described with reference to the accompanying drawings. It will, however, be evident that various modifications and changes may be made thereto, and additional embodiments may be implemented, without departing from the broader scope of the invention as set forth in the claims that follow. The specification and drawings are accordingly to be regarded as illustrative rather than restrictive.","No element, act, or instruction used in the present application should be construed as critical or essential to the implementations described herein unless explicitly described as such."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0003","num":"0002"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 6C"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
