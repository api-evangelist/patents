---
title: Computer, resource usage calculation method, and resource usage calculation program
abstract: Provided is a computer, comprising a memory which stores a program and a processor which executes the program which is stored in the memory for each predetermined processing unit, with which a computer resource usage is calculated by a process which is executed for each predetermined processing unit. The computer resources include overlapping resources which are used in an overlapping manner when the program is executed and non-overlapping resources which are not used in an overlapping manner when the program is executed. When calculating the computer resource usage by the process which is executed for each predetermined processing unit, the processor determines, by analyzing the computer resources, the overlapping resources which are used by the process and the non-overlapping resources which are used by the process, and calculates the computer resource usage by the process on the basis of the result of the determination.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09634912&OS=09634912&RS=09634912
owner: Hitachi, Ltd.
number: 09634912
owner_city: Tokyo
owner_country: JP
publication_date: 20110614
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"p":["This application is the National Phase of PCT\/JP2011\/063582, filed Jun. 14, 2011, the disclosures of which is hereby incorporated by reference in its entirety.","This invention relates to a computer, a resource usage calculation method, and a resource usage calculation program.","Each process (for example, business application) of a program (for example, Java application server) that is run on a virtual machine (for example, Java VM) is executed thread by thread. When threads are executed, memory areas (stack areas) dedicated for the individual threads and a memory area (heap area) shared by all the threads are used as needed. An unnecessary memory (object) is collected automatically by a garbage collection (hereinafter referred to as \u201cGC\u201d) function of the virtual machine.","There is known a technology of controlling a process which is executed in a thread in accordance with the memory usage in the process. The process that is executed in the thread includes a process that is executed in a thread alone, a process that is executed in the units of stack frames in a thread, and a process that is executed in a plurality of threads. However, a plurality of processes may use the same memory in an overlapping manner. Therefore, it is difficult to calculate the memory usage in each process executed in a thread.","Japanese Patent Application Laid-open No. 2009-110213 discloses a technology for solving this problem. The technology disclosed in Japanese Patent Application Laid-open No. 2009-110213 can roughly calculate a target memory usage in a specific function (process) which is executed in a thread, based on the remaining memory of the virtual machine at the start of the execution of the specific function and other functions that are executed at the same time as the specific function.","However, the method disclosed in Japanese Patent Application Laid-open No. 2009-110213 has a problem in that the usage of resources (for example, the above-mentioned amount of memory) that are actually used at an arbitrary point of time by a specific process (for example, process executed in the thread) cannot be calculated. This is because it is unknown which resource is used only by a specific process and which resource is used by a specific process and other processes in an overlapping manner.","Accordingly, in view of the above-mentioned problem, it is an object of this invention to provide a computer, a resource usage calculation method, and a resource usage calculation program which are capable of efficiently and accurately calculating the usage of resources that are actually used at an arbitrary point of time by a specific process.","According to an exemplary embodiment of this invention, there is provided a computer for calculating usage of a computer resource used by a process that is executed in a predetermined processing unit, the computer comprising: a memory for storing a program; and a processor for executing the program stored in the memory in each predetermined processing unit, wherein the computer resource comprises overlapping resources that are used in an overlapping manner when the program is executed, and non-overlapping resources that are not used in an overlapping manner when the program is executed, and wherein the processor is configured to: analyze, when calculating the usage of the computer resource used by the process that is executed in the predetermined processing unit, the computer resource to determine which resource in the overlapping resources is used by the process and which resource in the non-overlapping resources is used by the process; and calculate the usage of the computer resource used by the process based on a result of the determination.","According to this invention, the usage of resources that are actually used by a specific process can be efficiently and accurately calculated.","An embodiment of this invention is described below with reference to the accompanying drawings. The following description of this embodiment is given of a case where this invention is adapted to a computer system  on which a Java VM  runs.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 1","FIG. 1"],"b":["1","32","1"]},"In the computer system  (information processing apparatus or computer), the Java VM  executes a Java class file  to carry out a predetermined application process. In other words, the Java class file  is a program for executing the predetermined application process. The Java class file  is written in byte codes which can be interpreted and executed by the Java VM  by using an interpreter. In addition, the Java class file  is written in the Java language. The Java class file  is generated when a Java source file (not shown) that can write the calling of a Java API  is compiled by a Java compiler (not shown).","The computer system  includes a processor (control part) , a main storage device (storage part) , an auxiliary storage device (storage part) , an input device , and an output device . The processor , the main storage device , the auxiliary storage device , the input device , and the output device  are connected to one another by a bus .","The processor  runs various programs stored in the main storage device  to execute various processes.","The main storage device  stores a program, information needed for execution of the program, and the result of executing the program. The main storage device  may be a volatile memory or a non-volatile memory. The main storage device  stores the Java API , the Java VM , a stack area , a data area , and an operating system .","The auxiliary storage device  stores the Java class file , a configuration file , a memory information file , and a command . The Java class file  is a program for executing an application process. The configuration file  records the configurations that control the operation of the Java VM . The memory information file  stores the result of calculation of the memory usage. The command  controls the operation of the Java VM .","The input device  is an interface for inputting necessary information to the computer system . For example, the input device  is a keyboard, a mouse, or the like.","The output device  outputs information such as a processing result to the outside. For example, the output device  is a display.","The stack area  is an area where information needed to execute a thread and the result of processing a thread are stored. When a thread is generated, a unique stack area (for example, stack area -) is assigned to the thread.","The data area  is an area where information needed to execute a program and the result of processing the program are stored. The data area  includes an object storage area  and a memory information table . The object storage area  stores an object generated by the Java VM . The memory information table  stores information on the memory usage of an object that is stored in the object storage area  and information on a reference relationship to the memory. The details of the memory information table  are given later with reference to .","Individual programs that are stored in the main storage device  are described next.","The Java Application Programming Interface (API)  is an interface for the basic functions (for example, a set of libraries) that the Java provides. The Java API  prepares a method for calling, for example, a memory usage calculation part . A method execution part  can call the memory usage calculation part  by executing the method.","The Java VM  includes the method execution part , a thread control part , a GC execution part , the memory usage calculation part , and a memory information output part . The method execution part , the thread control part , the GC execution part , the memory usage calculation part , and the memory information output part  are programs that are executed by the processor . The Java VM  is a language process executing system having a memory management mechanism that dynamically releases unnecessary memory areas.","The method execution part  executes a method thread by thread in accordance with each byte-code command written on the Java class file . When a command is an object generating command, the method execution part  generates an object in the object storage area . When there is no free area in the object storage area , and generation of an object fails, the method execution part  requests the GC execution part  to execute a GC process (GC-process request). When receiving the GC-process request, the GC execution part  executes the GC process to release an unnecessary memory area in the object storage area . Then, the method execution part  executes generation of an object again, and generates an out-of-memory error when the generation of an object also fails.","The thread control part  controls the thread that is executed by the method execution part . Specifically, the thread control part  assigns, for example, the stack area  to the thread that is generated by the method execution part .","When receiving the GC-process request from the method execution part , the GC execution part  performs a GC process on the object storage area .","The memory usage calculation part  calculates the memory usage in the object storage area  using the memory information table . The memory usage calculation part  may be called by the method execution part , or by the GC execution part .","The memory information output part  outputs the result of calculation by the memory usage calculation part  to the output device  such as a display. The memory information output part  may output the calculation result as log data.","The Java VM  includes a flag for controlling the operation of the Java VM  (hereinafter referred to as \u201csetting flag\u201d) and a parameter threshold (hereinafter referred to as \u201cset threshold\u201d). Default values for the setting flag and the set threshold may be changed by specifying the values through the configuration file , the input device , and the command .","A program having functions of the memory usage calculation part  or the memory information output part  that are executed by the Java VM  may be recorded on a recording medium such as a universal serial bus (USB) memory or an SD memory card.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 2","b":"342"},"The memory information table  includes a frame-proprietary memory information table , a frame-shared memory information table , and a thread-shared memory information table . The details of the frame-proprietary memory information table , the frame-shared memory information table , and the thread-shared memory information table are given with reference to .",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 3","b":"342","i":"a "},"Each entry in the frame-proprietary memory information table (hereinafter referred to as \u201cframe-proprietary memory information\u201d) includes a frame-proprietary memory information ID , a thread ID , a method name , a frame-proprietary memory usage , a referent-frame-shared memory information ID , and a referent-thread-shared memory information ID .","The frame-proprietary memory information is information on a memory that is exclusively used by a stack frame relating to a method identified by the method name  in a thread identified by the thread ID , in other words, information on a frame-proprietary memory that is exclusively used by each process executed in the thread.","The frame-proprietary memory information ID  is assigned to each frame-proprietary memory information, and takes a unique value (identifier) to identify each frame-proprietary memory information.","The thread ID  is an identifier to identify a thread.","The method name  is information to identify a stack frame. The method name  is not restrictive, and may be any information which identifies a stack frame. The identity may be enhanced by adding a package name or class name to the method name . The information to identify a stack frame may be the ID of the stack frame. According to the embodiment of this invention, the method name  is used as information to identify a stack frame, for the sake of convenience.","The frame-proprietary memory usage  indicates the usage of the memory that is exclusively used by a stack frame identified by the thread ID  and the method name , in other words, the usage of a frame-proprietary memory.","The referent-frame-shared memory information ID  is a frame-shared memory information ID  of the frame-shared memory information (see ) that is referred to by the frame-proprietary memory information.","The referent-thread-shared memory information ID  is a thread-shared memory information ID  of the thread-shared memory information (see ) that is referred to by the frame-proprietary memory information.",{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 4","b":"342","i":"b "},"Each entry in the frame-shared memory information table (hereinafter referred to as \u201cframe-shared memory information\u201d) includes a frame-proprietary memory information ID , an address , a class name , a frame-shared memory usage , a referent-frame-shared memory information ID , and a referent-thread-shared memory information ID .","The frame-shared memory information is information on a memory that is shared by different stack frames in the same thread, in other words, information on a frame-shared memory that is shared by a plurality of different processes executed in the same thread.","The frame-shared memory information ID  is assigned to each frame-shared memory information, and takes a unique value (identifier) to identify each frame-shared memory information.","The address  is the address of an object which is the root of the reference relationship in the object that is included in the frame-shared memory.","The class name  is the class name of an object which is the root of the reference relationship in the object that is included in the frame-shared memory. The identity may be enhanced by adding a package name to the class name . Because the class name  is obtainable from the object that is specified by the address , the class name  may be omitted. For the sake of convenience, the class name  is not omitted in the description of the embodiment of this invention.","The frame-shared memory usage  indicates the usage of the memory that is shared by different stack frames in the same thread, in other words, the usage of a frame-shared memory.","The referent-frame-shared memory information ID  is a frame-shared memory information ID  of the frame-shared memory information that is referred to by the frame-shared memory information.","The referent-thread-shared memory information ID  is a thread-shared memory information ID  of the thread-shared memory information (see ) that is referred to by the frame-shared memory information.",{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 5","b":"342","i":"c "},"Each entry in the thread-shared memory information table (hereinafter referred to as \u201cthread-shared memory information\u201d) includes a thread-shared memory information ID , an address , a class name , a thread-shared memory usage , a referent-frame-shared memory information ID , and a referent-thread-shared memory information ID .","The thread-shared memory information is information on a memory that is shared by a plurality of different threads, in other words, information on a thread-shared memory.","The thread-shared memory information ID  is assigned to each thread-shared memory information, and takes a unique value (identifier) to identify each thread-shared memory information.","The address  is the address of an object which is the root of the reference relationship in the object that is included in the thread-shared memory.","The class name  is the class name of an object which is the root of the reference relationship in the object that is included in the thread-shared memory. The identity may be enhanced by adding a package name to the class name . Because the class name  is obtainable from the object that is specified by the address , the class name  may be omitted. For the sake of convenience, the class name  is not omitted in the description of the embodiment of this invention.","The thread-shared memory usage  indicates the usage of the memory that is shared by a plurality of different threads, in other words, the usage of a thread-shared memory.","The referent-frame-shared memory information ID  is a frame-shared memory information ID  of the frame-shared memory information (see ) that is referred to by the thread-shared memory information.","The referent-thread-shared memory information ID  is a thread-shared memory information ID  of the thread-shared memory information that is referred to by the thread-shared memory information.",{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 6","b":"601"},"One example of the data structure of the object  to be stored in the object storage area  (see ) is described hereinbelow. The object  includes an object header  and object data .","The object header  is management information for the object . According to the embodiment of this invention, information (for example, an object type bit in ) indicating the type of the object  (any one of \u201cUnanalyzed\u201d, \u201cNecessary\u201d, \u201cFrame Sharing\u201d, and \u201cStack Sharing\u201d) is stored in the object header . The information indicating the type of the object  may be stored in the object data , or may be stored in an area other than the object header  and the object data . The object data  is the body of data of the object .",{"@attributes":{"id":"p-0100","num":"0099"},"figref":"FIG. 7"},"As shown in an object type table  of , object type bits (2-bit values in this example) are associated with the respective object types. According to the embodiment of this invention, a 2-bit value stored in the object header  (see ) is used as the object type bits.","Specifically, an object type bit of \u201c00\u201d indicates that the object type is \u201cUnanalyzed\u201d, in other words, the object has not been analyzed in an object analyzing process (see ).","Further, an object type bit of \u201c01\u201d indicates that the object type is \u201cNecessary\u201d, in other words, it has already been determined in the object analyzing process that the object is needed to execute the program.","Likewise, an object type bit of \u201c10\u201d indicates that the object type is \u201cFrame Sharing\u201d, in other words, it has already been determined in the object analyzing process that the object is referred to by a plurality of different stack frames in the same thread.","Further, an object type bit of \u201c11\u201d indicates that the object type is \u201cThread Sharing\u201d, in other words, it has already been determined in the object analyzing process that the object is referred to by a plurality of different threads.","[Process of Calculating Memory Usage]",{"@attributes":{"id":"p-0107","num":"0106"},"figref":"FIG. 8","b":"324"},"First, in Step , the memory usage calculation part  requests the thread control part  to interrupt all the threads except for the thread that executes the memory usage calculating process (S). The thread control part  interrupts the threads in response to the request.","Next, in Step , the memory usage calculation part  executes the object analyzing process (S) to thereby specify the type of each object in the object storage area . The details of the object analyzing process are given later with reference to .","Next, in Step , the memory usage calculation part  executes the processes of Step  and Step  for each stack frame unprocessed. In other words, the memory usage calculation part  executes the processes of Step  and Step  for every stack frame.","In Step , the memory usage calculation part  registers frame-proprietary memory information corresponding to an unprocessed stack frame in the frame-proprietary memory information table (S). Specifically, the memory usage calculation part  registers the frame-proprietary memory information ID , the thread ID , the method name , and the frame-proprietary memory usage  (having an initial value of 0).","In Step , the memory usage calculation part  calculates the frame-proprietary memory usage  of the unprocessed stack frame (S). Specifically, the memory usage calculation part  calculates the frame-proprietary memory usage  of the unprocessed stack frame while recursively tracing object reference in the unprocessed stack frame. The details of the calculation of the frame-proprietary memory usage  are given later with reference to .","Through the above-mentioned processes of Steps  to , the memory usage calculation part  registers frame-proprietary memory information corresponding to all stack frames in the frame-proprietary memory information table (see ).","In next Step , the memory usage calculation part  executes the processes of Step  and Step  for unprocessed frame-shared memory information and unprocessed thread-shared memory information. In other words, the memory usage calculation part  executes the processes of Step  and Step  for every frame-shared memory information and every thread-shared memory information.","In Step , the memory usage calculation part  executes a frame-shared memory usage calculating process for unprocessed frame-shared memory information (S). Specifically, the memory usage calculation part  adds a memory usage of a referent object indicated by the address  of the unprocessed frame-shared memory information to the frame-shared memory usage  of the unprocessed frame-shared memory information. Then, the memory usage calculation part  shifts (changes) the process target to the referent object, and calculates the frame-shared memory usage  of the unprocessed frame-shared memory information while recursively tracing object reference through steps illustrated in . The details of the process of calculating the frame-shared memory usage are given later with reference to .","In Step , the memory usage calculation part  executes a thread-shared memory usage calculating process for unprocessed thread-shared memory information (S). Specifically, the memory usage calculation part  adds a memory usage of a referent object indicated by the address  of the unprocessed thread-shared memory information to the thread-shared memory usage  of the unprocessed thread-shared memory information. Then, the memory usage calculation part  shifts the process target to the referent object, and calculates the thread-shared memory usage  of the unprocessed thread-shared memory information while recursively tracing object reference through steps illustrated in . The details of the process of calculating the thread-shared memory usage are given later with reference to .","Through the above-mentioned processes of Steps  to , the memory usage calculation part  registers every frame-shared memory information in the frame-shared memory information table (see ). The memory usage calculation part  also registers every thread-shared memory information in the thread-shared memory information table (see ).","In next Step , the memory usage calculation part  makes a thread resuming request to the thread control part  to resume all the threads that have been interrupted in Step  (S).","In next Step , the memory usage calculation part  executes a process of calculating the purpose-based memory usage to calculate the memory usage corresponding to the purpose (S). The details of the process of calculating the purpose-based memory usage are given later with reference to .","Through the processes described above, the memory usage calculation part  can calculate the memory usage of the process that is executed in a thread. The process of Step  may be executed before the process of Step S. In the process of Step , not only the memory usage but also the amount of memory released when at least one thread is terminated may be calculated.","[Object Analyzing Process]",{"@attributes":{"id":"p-0121","num":"0120"},"figref":"FIG. 9","b":["324","341"]},"It should be noted that before executing the object analyzing process, the memory usage calculation part  sets the object type \u201cUnanalyzed\u201d in the object header  of every object stored in the object storage area  (initialization).","First, in Step , with regard to an unprocessed object reference, the memory usage calculation part  executes the processes of Steps  to . In other words, with regard to object reference in all the stack frames in all the threads, the memory usage calculation part  executes the processes of Steps  to .","In Step , the memory usage calculation part  determines the object type of a referent object (S).","When the object type of the referent object is \u201cUnanalyzed\u201d, the memory usage calculation part  sets the object type of the referent object to \u201cNecessary\u201d (S). Then, the memory usage calculation part  shifts the process target to the referent object (S), and recursively executes the object analyzing process () on the referent object (S).","When the object type of the referent object is \u201cNecessary\u201d, the memory usage calculation part  executes a necessary-object analyzing process (S) to analyze whether or not the object type needs to be changed to \u201cFrame Sharing\u201d or \u201cStack Sharing\u201d. Thereafter, the memory usage calculation part  returns to Step  to shift the process target to an unprocessed object reference different from the current object reference. The details of the necessary-object analyzing process are given later with reference to .","When the object type of the referent object is \u201cFrame Sharing\u201d, the memory usage calculation part  executes a frame-shared object analyzing process (S) to analyze whether or not the object type needs to be changed to \u201cThread Sharing\u201d. Thereafter, the memory usage calculation part  returns to Step  to shift the process target to an unprocessed object reference different from the current object reference. The details of the frame-shared object analyzing process are given later with reference to .","When the object type of the referent object is \u201cThread Sharing\u201d, the object type is not changed. Therefore, the memory usage calculation part  returns to Step S without executing the process, and shifts the process target to an unprocessed object reference different from the current object reference.","Through the processes described above, with regard to reference to all objects in all stack frames in all threads, the memory usage calculation part  specifies (sets) the object type in the referent object while recursively tracing the object reference.",{"@attributes":{"id":"p-0130","num":"0129"},"figref":["FIG. 10","FIG. 9"],"b":["906","324"]},"First, in Step , the memory usage calculation part  determines from which stack frame the referent object to be processed has been traced (S). In other words, the memory usage calculation part  compares the stack frame of the tracing source (reference source) at the time of executing the current object analyzing process with the stack frame of the tracing source at the time of executing the object analyzing process in the past.","When the referent object is an object that has already been traced from the same stack frame, the memory usage calculation part  does not change the object type of the referent object.","When the referent object is an object that has already been traced from a different stack frame in the same thread, the memory usage calculation part  sets (changes) the object type of the referent object to \u201cFrame Sharing\u201d (S).","When the referent object is an object that has already been traced from a stack frame in a different thread, the memory usage calculation part  sets the object type of the referent object to \u201cThread Sharing\u201d (S).","Through the processes described above, when the object type of the referent object is \u201cNecessary\u201d, the memory usage calculation part  sets (changes) the object type of the referent object, depending on from which stack frame the referent object has been traced.",{"@attributes":{"id":"p-0136","num":"0135"},"figref":["FIG. 11","FIG. 9"],"b":["907","324"]},"First, in Step , the memory usage calculation part  determines from which stack frame the referent object to be processed has been traced (S). In other words, the memory usage calculation part  compares the stack frame of the tracing source (reference source) at the time of executing the current object analyzing process with the stack frame of the tracing source at the time of executing the object analyzing process in the past.","When the referent object is an object that has already been traced from the same stack frame or when the referent object is an object that has already been traced from a different stack frame in the same thread, the memory usage calculation part  does not change the object type of the referent object.","When the referent object is an object that has already been traced from a stack frame in a different thread, the memory usage calculation part  sets (changes) the object type of the referent object to \u201cThread Sharing\u201d (S).","Through the processes described above, when the object type of the referent object is \u201cFrame Sharing\u201d, the memory usage calculation part  sets (changes) the object type of the referent object, depending on from which stack frame the referent object has been traced.","[Object Type of Each Object Under Object Analyzing Process]","Subsequently, a description is given of how the object type that is set for each object stored in the object storage area  under the object analyzing process illustrated in  changes.",{"@attributes":{"id":"p-0142","num":"0141"},"figref":["FIG. 12","FIG. 12"],"b":"341"},{"@attributes":{"id":"p-0143","num":"0142"},"figref":["FIG. 13","FIG. 13"],"b":"341"},{"@attributes":{"id":"p-0144","num":"0143"},"figref":["FIG. 14","FIG. 14"],"b":"341"},{"@attributes":{"id":"p-0145","num":"0144"},"figref":["FIG. 15","FIG. 15"],"b":"341"},{"@attributes":{"id":"p-0146","num":"0145"},"figref":"FIGS. 12 to 15"},"Characters starting at #F affixed to the upper right of an object indicate the frame-shared memory information ID  (see ). Characters starting at #T indicate the thread-shared memory information ID  (see ). Further, a numeral affixed to the lower right of an object indicates the memory usage of the object.","A stack frame indicated by a double-lined frame (for example, Class2.methodE) is a fixed stack frame (for example, system program). The other stack frames (for example, Class1.methodA) are each a variable stack frame (for example, user program). In other words, stack frames may include a fixed stack frame and a variable stack frame. Further, the type of a stack frame may be used as a condition for selection or determination such as a determination (S) of a condition for canceling a thread control process to be described later with reference to . For example, a thread to be controlled may be canceled when memory shortage occurs in a variable stack frame.","Then, as illustrated in , individual objects in the object storage area  are classified into objects with the letter F or T which are used in an overlapping manner (overlapping objects, overlapping resources) in a program that is executed thread by thread (threads 1 to N in this case), objects with the letter N which are not used in an overlapping manner in principle (non-overlapping objects, non-overlapping resources), and other objects. The overlapping objects include an object with the letter F (object that is shared by a plurality of different processes that are executed in the same thread), and an object the letter T (object shared by a plurality of different threads).","When the processes of Steps  to  in  are executed based on the types of the individual objects illustrated in , the frame-proprietary memory information table of , the frame-shared memory information table of in , and the thread-shared memory information table of  are generated.",{"@attributes":{"id":"p-0151","num":"0150"},"figref":["FIG. 16","FIG. 8"],"b":["805","324"]},"First, in Step , the memory usage calculation part  executes the processes of Steps  to  for an unprocessed referent object. In other words, the memory usage calculation part  executes the processes of Steps  to  for every referent object in the stack frame S.","In Step , the memory usage calculation part  determines the object type of an unprocessed referent object (S).","When the object type of the unprocessed referent object is \u201cNecessary\u201d, the memory that is used by the unprocessed referent object is an proprietary memory of the stack frame S. Therefore, the memory usage calculation part  adds the memory usage of the unprocessed referent object to the frame-proprietary memory usage  of the frame-proprietary memory information corresponding to the stack frame S stored in the frame-proprietary memory information table (S). Then, the memory usage calculation part  shifts the process target to a referent object of the unprocessed referent object (S). Then, the memory usage calculation part  recursively executes the frame-proprietary memory usage calculating process () on the shifted referent object (S).","When the object type of the unprocessed referent object is \u201cFrame Sharing\u201d, the memory that is used by the unprocessed referent object is a memory shared by the stack frame S and another stack frame, in other words, a frame-shared memory. Accordingly, the memory usage calculation part  executes a frame-shared memory information ID registering process (registration target is the frame-proprietary memory information table ) (S). Thereafter, the memory usage calculation part  returns to Step  to shift the process target to an unprocessed referent object different from the current referent object. The details of the frame-shared memory information ID registering process are given later with reference to .","When the object type of the unprocessed referent object is \u201cThread Sharing\u201d, the memory that is used by the unprocessed referent object is a memory shared by a thread associated with the stack frame S and another thread, in other words, a thread-shared memory. Accordingly, the memory usage calculation part  executes a thread-shared memory information ID registering process (registration target is the frame-proprietary memory information table ) (S). Thereafter, the memory usage calculation part  returns to Step  to shift the process target to an unprocessed referent object different from the current referent object. The details of the thread-shared memory information ID registering process are given later with reference to .","Through the processes described above, the memory usage calculation part  calculates the frame-proprietary memory usage  of the stack frame S while recursively tracing object reference in the stack frame S.","For example, in , the frame-proprietary memory usage of a stack frame indicated by Class1.methodB of thread 1 is \u201c36\u201d, which is the sum of the memory usage of \u201c12\u201d of the referent object whose object type is \u201cNecessary\u201d, in other words, the referent object of this stack frame, and the memory usage of \u201c24\u201d of a referent object of this referent object.",{"@attributes":{"id":"p-0159","num":"0158"},"figref":"FIG. 17"},"The memory usage calculation part  executes this process to register, in a registration target table, the frame-shared memory information ID of a referent object whose object type is \u201cFrame Sharing\u201d (hereinafter referred to as \u201creferent object FO\u201d in the description of this process). The registration target table is any one of the frame-proprietary memory information table , the frame-shared memory information table , and the thread-shared memory information table ","First, in Step , the memory usage calculation part  determines whether or not frame-shared memory information corresponding to the referent object FO has already been registered in the frame-shared memory information table (S). Specifically, the memory usage calculation part  makes this determination by comparing the address of the object that is the root of the reference relationship of the referent object FO with the address  of each frame-shared memory information registered in the frame-shared memory information table . When the frame-shared memory information corresponding to the referent object FO is registered (YES at S), the memory usage calculation part  proceeds to Step .","On the other hand, when the frame-shared memory information corresponding to the referent object FO is not registered (NO at S), the memory usage calculation part  registers the frame-shared memory information corresponding to the referent object FO in the frame-shared memory information table (S). Specifically, the memory usage calculation part  registers the frame-shared memory information ID , the address , the class name , and the frame-shared memory usage  (having an initial value of 0).","In Step , the memory usage calculation part  sets (registers) the frame-shared memory information ID  of the frame-shared memory information corresponding to the referent object FO in the referent-frame-shared memory information ID of the registration target table (S).","In Step , specifically, the memory usage calculation part  first acquires the frame-shared memory information ID  of the frame-shared memory information corresponding to the referent object FO from the frame-shared memory information table . Then, the memory usage calculation part  sets the acquired frame-shared memory information ID  in the referent-frame-shared memory information ID of the registration target table.","In other words, when the registration target table is the frame-proprietary memory information table , as in Step  of , the memory usage calculation part  sets the acquired frame-shared memory information ID  in the referent-frame-shared memory information ID  of the frame-proprietary memory information corresponding to the stack frame S stored in the frame-proprietary memory information table . When the registration target table is the frame-shared memory information table , as in Step  of , the memory usage calculation part  sets the acquired frame-shared memory information ID  in the referent-frame-shared memory information ID  of the frame-shared memory information F. When the registration target table is the thread-shared memory information table , as in Step  of , the memory usage calculation part  sets the acquired frame-shared memory information ID  in the referent-frame-shared memory information ID  of the thread-shared memory information T.","Through the processes described above, the memory usage calculation part  registers the frame-shared memory information ID of the referent object FO that is using the frame-shared memory in the registration target table.",{"@attributes":{"id":"p-0167","num":"0166"},"figref":"FIG. 18"},"The memory usage calculation part  executes this process to register, in a registration target table, the thread-shared memory information ID of a referent object whose object type is \u201cThread Sharing\u201d (hereinafter referred to as \u201creferent object SO\u201d in the description of this process). The registration target table is any one of the frame-proprietary memory information table , the frame-shared memory information table , and the thread-shared memory information table ","First, in Step , the memory usage calculation part  determines whether or not thread-shared memory information corresponding to the referent object SO has already been registered in the thread-shared memory information table (S). Specifically, the memory usage calculation part  makes this determination by comparing the address of the object that is the root of the reference relationship of the referent object SO with the address  of each thread-shared memory information registered in the thread-shared memory information table . When the thread-shared memory information corresponding to the referent object SO is registered (YES at S), the memory usage calculation part  proceeds to Step .","On the other hand, when the thread-shared memory information corresponding to the referent object SO is not registered (NO at S), the memory usage calculation part  registers the thread-shared memory information corresponding to the referent object SO in the thread-shared memory information table (S). Specifically, the memory usage calculation part  registers the thread-shared memory information ID , the address , the class name , and the thread-shared memory usage  (having an initial value of 0).","In Step , the memory usage calculation part  sets (registers) the thread-shared memory information ID  of the thread-shared memory information corresponding to the referent object SO in the referent-thread-shared memory information ID of the registration target (S).","In Step , specifically, the memory usage calculation part  first acquires the thread-shared memory information ID  of the thread-shared memory information corresponding to the referent object SO from the thread-shared memory information table . Then, the memory usage calculation part  sets the acquired thread-shared memory information ID  in the referent-frame-shared memory information ID of the registration target table.","In other words, when the registration target table is the frame-proprietary memory information table , as in Step  of , the memory usage calculation part  sets the acquired thread-shared memory information ID  in the referent-thread-shared memory information ID  of the frame-proprietary memory information corresponding to the stack frame S stored in the frame-proprietary memory information table . When the registration target table is the frame-shared memory information table , as in Step  of , the memory usage calculation part  sets the acquired thread-shared memory information ID  in the referent-thread-shared memory information ID  of the frame-shared memory information F. When the registration target table is the thread-shared memory information table , as in Step  of , the memory usage calculation part  sets the acquired thread-shared memory information ID  in the referent-thread-shared memory information ID  of the thread-shared memory information T.","Through the processes described above, the memory usage calculation part  registers the thread-shared memory information ID of the referent object SO that is using the thread-shared memory in the registration target table.",{"@attributes":{"id":"p-0175","num":"0174"},"figref":["FIG. 19","FIG. 8"],"b":["807","324"]},"First, in Step , the memory usage calculation part  adds the memory usage of a referent object indicated by the address  of the frame-shared memory information F (hereinafter referred to as \u201creferent object FR\u201d in the description of this process) to the frame-shared memory usage  of the frame-shared memory information F, and shifts the process target to the referent object FR.","Then, in Step , the memory usage calculation part  executes the processes of Steps  to  for an unprocessed referent object. In other words, the memory usage calculation part  executes the processes of Steps  to  for every referent object in the referent object FR.","In Step , the memory usage calculation part  determines the object type of an unprocessed referent object (S).","When the object type of the unprocessed referent object is \u201cNecessary\u201d, the memory that is used by the unprocessed referent object is a frame-shared memory similarly to the referent object FR. Therefore, the memory usage calculation part  adds the memory usage of the unprocessed referent object to the frame-shared memory usage  of the frame-shared memory information F (S). Then, the memory usage calculation part  shifts the process target to a referent object of the unprocessed referent object (S). Then, the memory usage calculation part  recursively executes the frame-shared memory usage calculating process () on the shifted referent object (S).","When the object type of the unprocessed referent object is \u201cFrame Sharing\u201d, the memory that is used by the unprocessed referent object is a frame-shared memory different from the memory used by the referent object FR. Accordingly, the memory usage calculation part  executes a frame-shared memory information ID registering process (registration target is the frame-shared memory information table ) (S). Thereafter, the memory usage calculation part  returns to Step  to shift the process target to an unprocessed referent object different from the current referent object. The details of the frame-shared memory information ID registering process are as given above with reference to .","When the object type of the unprocessed referent object is \u201cThread Sharing\u201d, the memory that is used by the unprocessed referent object is a thread-shared memory. Accordingly, the memory usage calculation part  executes a thread-shared memory information ID registering process (registration target is the frame-shared memory information table ) (S). Thereafter, the memory usage calculation part  returns to Step  to shift the process target to an unprocessed referent object different from the current referent object. The details of the thread-shared memory information ID registering process are as given above with reference to .","Through the processes described above, the memory usage calculation part  calculates the frame-shared memory usage  of the frame-shared memory information F while recursively tracing object reference in the referent object FR indicated by the address  of the frame-shared memory information F.","For example, in , the frame-shared memory usage of frame-shared memory information indicated by the frame-shared memory information ID of \u201c#F3\u201d is \u201c84\u201d, which is the sum of the memory usage of \u201c76\u201d of the referent object of this frame-shared memory information, and the memory usage of \u201c8\u201d of a referent object which is the referent of this referent object and whose object type is \u201cNecessary\u201d.",{"@attributes":{"id":"p-0184","num":"0183"},"figref":["FIG. 20","FIG. 8"],"b":["808","324"]},"First, in Step , the memory usage calculation part  adds the memory usage of a referent object indicated by the address  of the thread-shared memory information T (hereinafter referred to as \u201creferent object TR\u201d in the description of this process) to the thread-shared memory usage  of the thread-shared memory information T, and shifts the process target to the referent object TR (S).","Thereafter, in Step , the memory usage calculation part  executes the processes of Steps  to  for an unprocessed referent object. In other words, the memory usage calculation part  executes the processes of Steps  to  for every referent object in the referent object TR.","In Step , the memory usage calculation part  determines the object type of an unprocessed referent object (S).","When the object type of the unprocessed referent object is \u201cNecessary\u201d, the memory that is used by the unprocessed referent object is a thread-shared memory similarly to the referent object TR. Therefore, the memory usage calculation part  adds the memory usage of the unprocessed referent object to the thread-shared memory usage  of the thread-shared memory information T (S). Then, the memory usage calculation part  shifts the process target to a referent object of the unprocessed referent object (S). Then, the memory usage calculation part  recursively executes the thread-shared memory usage calculating process () on the shifted referent object (S).","When the object type of the unprocessed referent object is \u201cFrame Sharing\u201d, the memory that is used by the unprocessed referent object is a frame-shared memory. Accordingly, the memory usage calculation part  executes a frame-shared memory information ID registering process (registration target is the thread-shared memory information table ) (S). Thereafter, the memory usage calculation part  returns to Step  to shift the process target to an unprocessed referent object different from the current referent object. The details of the frame-shared memory information ID registering process are as given above with reference to .","When the object type of the unprocessed referent object is \u201cThread Sharing\u201d, the memory that is used by the unprocessed referent object is a thread-shared memory different from the memory used by the referent object TR. Accordingly, the memory usage calculation part  executes a thread-shared memory information ID registering process (registration target is the thread-shared memory information table ) (S). Thereafter, the memory usage calculation part  returns to Step  to shift the process target to an unprocessed referent object different from the current referent object. The details of the thread-sharing memory information ID registering process are as given above with reference to .","Through the processes described above, the memory usage calculation part  calculates the thread-shared memory usage  of the thread-shared memory information T while recursively tracing object reference in the referent object TR indicated by the address  of the thread-shared memory information T.","For example, in , the thread-shared memory usage of thread-shared memory information indicated by the thread-shared memory information ID of \u201c#T1\u201d is \u201c72\u201d, which is the memory usage of the referent object of this thread-shared memory information.","[Example of Calculation of Purpose-Based Memory Usage]","Hereinafter, an example of the purpose-based memory usage calculating process in Step  of  is described with reference to .","[1. Calculation of Total Memory Usage of Specific Thread]",{"@attributes":{"id":"p-0195","num":"0194"},"figref":"FIG. 21"},"The memory usage calculation part  can calculate the total memory usage of a specific thread by executing this process. When the proprietary memory usage of the specific thread (see ) and the shared memory usage of the specific thread (see ) have already been calculated, the total memory usage can be calculated as the sum of the proprietary memory usage and the shared memory usage.","The total memory usage of a specific thread may be calculated as the sum of the following total values S_SUM, F_SUM, and T_SUM.","S_SUM: Total value of the frame-proprietary memory usage  of frame-proprietary memory information S with the same thread ID  that is registered in the frame-proprietary memory information table ","F_SUM: Total value of the frame-shared memory usage  of frame-shared memory information indicated by a set F of frame-shared memory information IDs  that are directly or indirectly referred to from the referent-frame-shared memory information ID  or the referent-thread-shared memory information ID  of frame-proprietary memory information S.","T_SUM: Total value of the thread-shared memory usage  of thread-shared memory information indicated by a set T of thread-shared memory information IDs  that are directly or indirectly referred to from the referent-frame-shared memory information ID  or the referent-thread-shared memory information ID  of frame-proprietary memory information S.","The following describes the flowchart of . The following description is given of a case where the total memory usage of the thread with the thread ID  (see ) of \u201c#1\u201d is calculated, as a specific example.","First, in Step , the memory usage calculation part  repeats the processes of Steps  to  on each frame-proprietary memory information with the same thread ID  of \u201c#1\u201d (hereinafter referred to as \u201cframe-proprietary memory information S\u201d in the description of this process). The frame-proprietary memory information S in the specific example indicates frame-proprietary memory information with the frame-proprietary memory information ID  of \u201c#1\u201d and frame-proprietary memory information with the frame-proprietary memory information ID  of \u201c#2\u201d illustrated in .","In Step , the memory usage calculation part  adds the memory usage of the frame-proprietary memory in the frame-proprietary memory information S to the total value S_SUM (S). In other words, the total value S_SUM is the sum \u201c120\u201d of the memory usage of \u201c84\u201d of the frame-proprietary memory with the frame-proprietary memory information ID  of \u201c#1\u201d and the memory usage of \u201c36\u201d of the frame-proprietary memory with the frame-proprietary memory information ID  of \u201c#2\u201d.","In other words, in this Step , the memory usage calculation part  determines an object to be exclusively used by a target thread (thread with the thread ID  of \u201c#1\u201d in this example; in other words, thread that is not used in an overlapping manner) based on the reference relationship of individual objects that are referred to by the target thread, and calculates the memory usage of this object.","In Step , the memory usage calculation part  executes a referent-frame-shared memory information ID developing process on the referent-frame-shared memory information ID  of the frame-proprietary memory information S (S). Through the process of Step , the memory usage calculation part  acquires information on the frame-shared memory information ID  or the thread-shared memory information ID  that is directly or indirectly referred to from the referent-frame-shared memory information ID  of the frame-proprietary memory information S. The details of the referent-frame-shared memory information ID developing process are given later with reference to .","In Step , the memory usage calculation part  executes a referent-thread-shared memory information ID developing process on the referent-thread-shared memory information ID  of the frame-proprietary memory information S (S). Through the process of Step , the memory usage calculation part  acquires information on the frame-shared memory information ID  or the thread-shared memory information ID  that is directly or indirectly referred to from the referent-thread-shared memory information ID  of the frame-proprietary memory information S. The details of the referent-thread-shared memory information ID developing process are given later with reference to .","In next Step , the memory usage calculation part  calculates the set F of the frame-shared memory information IDs  and the set T of the thread-shared memory information IDs  for each frame-proprietary memory information S having the same thread ID  (S).","In other words, the memory usage calculation part  calculates the set F {\u201c#F1\u201d, \u201c#F2\u201d} of the frame-shared memory information IDs  and the set T {\u201c#T1} of the thread-shared memory information IDs  that are directly or indirectly referred to from the referent-frame-shared memory information ID  or the referent-thread-shared memory information ID  of each frame-proprietary memory information S (see ).","In Step , the set F of frame-shared memory information IDs  and the set T of thread-shared memory information IDs  are calculated to prevent overlapping addition of the memory usage of the frame-shared memory and the thread-shared memory that are referred to by a plurality of stack frames or a plurality of threads to the total memory usage.","In other words, in this Step , the memory usage calculation part  determines an object which is used in an overlapping manner based on the reference relationship of individual objects that are referred to by the target thread.","In next Step , the memory usage calculation part  calculates the total value F_SUM of the frame-shared memory usage  of the frame-shared memory information indicated by the set F (S). In the above-mentioned specific example, the set F is {\u201c#F1\u201d, \u201c#F2\u201d}. In Step , therefore, the total value F_SUM is \u201c72\u201d, which is the sum of the memory usage of \u201c60\u201d of the frame-shared memory specified by the frame-shared memory information ID  of \u201c#F1\u201d and the memory usage of \u201c12\u201d of the frame-shared memory specified by the frame-shared memory information ID  of \u201c#F2\u201d.","In other words, in this Step , the memory usage calculation part  calculates the size of a memory area (memory usage) storing an object shared (used in an overlapping manner) by different stack frames in the target thread among those objects that have been determined as being used in an overlapping manner in Step .","In next Step , the memory usage calculation part  calculates the total value T_SUM of the thread-shared memory usage  of the thread-shared memory information indicated by the set T (S). In the above-mentioned specific example, the set T is {\u201c#T1\u201d}. In Step , therefore, the total value T_SUM is \u201c72\u201d, which is the memory usage of the thread-shared memory specified by the thread-shared memory information ID  of \u201c#T1\u201d.","In other words, in this Step , the memory usage calculation part  calculates the size of a memory area storing an object shared (used in an overlapping manner) by a plurality of different threads (including the target thread) among those objects that have been determined as being used in an overlapping manner in Step .","In Step , the memory usage calculation part  calculates the sum of the total value S_SUM, the total value F_SUM, and the total value T_SUM (S). In the above-mentioned specific example, the total memory usage of the thread with the thread ID of \u201c#1\u201d becomes \u201c264\u201d, which is the sum of \u201c120\u201d, \u201c72\u201d, and \u201c72\u201d.","Through the processes described above, the memory usage calculation part  can calculate the total memory usage of a specific thread (here, thread with the thread ID  of \u201c#1\u201d). It is to be noted that the total memory usage of a thread is, in other words, the maximum memory release released when the thread is terminated.",{"@attributes":{"id":"p-0217","num":"0216"},"figref":["FIG. 22","FIG. 21"],"b":["2103","324"]},"First, in Step , the memory usage calculation part  executes the process of Step  for each frame-shared memory information ID  registered in the referent-frame-shared memory information ID  (see ) of the frame-proprietary memory information S to be processed.","In Step , the memory usage calculation part  develops the frame-shared memory information ID  and the thread-shared memory information ID  that are directly or indirectly referred to from each frame-shared memory information ID  ().","Considered is a case where, for example, the frame-proprietary memory information ID  of the frame-proprietary memory information S to be processed is \u201c#3\u201d (see ). In this case, \u201c#F3\u201d is registered in referent-frame-shared memory information ID  of the frame-proprietary memory information S in the frame-proprietary memory information table . In the frame-shared memory information table (see ), \u201c#T1\u201d is registered in the referent-thread-shared memory information ID  of the frame-shared memory information having the frame-shared memory information ID  of \u201c#F3\u201d. In the thread-shared memory information table (see ), \u201c#F2\u201d is registered in the referent-frame-shared memory information ID  of the thread-shared memory information having the thread-shared memory information ID  of \u201c#T1\u201d.","This implies that the frame-shared memory corresponding to the frame-shared memory information having the frame-shared memory information ID  of \u201c#F3\u201d directly refers to the thread-shared memory corresponding to the thread-shared memory information having the thread-shared memory information ID  of \u201c#T1\u201d. It is also implied that the frame-shared memory corresponding to the frame-shared memory information having the frame-shared memory information ID  of \u201c#F3\u201d indirectly refers to the frame-shared memory corresponding to the frame-shared memory information having the frame-shared memory information ID  of \u201c#F2\u201d.","Through the processes described above, the memory usage calculation part  develops the frame-shared memory information ID  and the thread-shared memory information ID  that are directly or indirectly referred to from the frame-shared memory information ID  registered in the referent-frame-shared memory information ID  of the frame-proprietary memory information S to be processed. In other words, the memory usage calculation part  acquires the reference relationship between the referent-frame-shared memory of the frame-proprietary memory information S, and another frame-shared memory and another thread-shared memory.",{"@attributes":{"id":"p-0223","num":"0222"},"figref":["FIG. 23","FIG. 21"],"b":["2104","324"]},"First, in Step , the memory usage calculation part  executes the process of Step  for each thread-shared memory information ID  registered in the referent-thread-shared memory information ID  (see ) of the frame-proprietary memory information S to be processed.","In Step , the memory usage calculation part  develops the frame-shared memory information ID  and the thread-shared memory information ID  that are directly or indirectly referred to from each thread-shared memory information ID  ().","Through the processes described above, the memory usage calculation part  develops the frame-shared memory information ID  and the thread-shared memory information ID  that are directly or indirectly referred to from the thread-shared memory information ID  registered in the referent-thread-shared memory information ID  of the frame-proprietary memory information S to be processed. In other words, the memory usage calculation part  acquires the reference relationship between the referent-thread-shared memory of the frame-proprietary memory information S, and the frame-shared memory and another thread-shared memory.",{"@attributes":{"id":"p-0227","num":"0226"},"figref":"FIG. 24","b":"342","i":"a "},"A referent-frame-shared memory information ID  and a referent-thread-shared memory information ID  in the frame-proprietary memory information table after development illustrated in  respectively correspond to the referent-frame-shared memory information ID  and the referent-thread-shared memory information ID  in the frame-shared memory information table illustrated in . It is to be noted that same reference numerals are given to the same components as illustrated in  to avoid redundant description thereof.","The referent-frame-shared memory information ID  is the referent-frame-shared memory information ID  developed through the referent-frame-shared memory information ID development process illustrated in . For example, \u201c#F3\u2192#T1\u2192#F2\u201d is registered in the referent-frame-shared memory information ID  with the frame-proprietary memory information ID  of \u201c#3\u201d.","This implies that the frame-shared memory corresponding to the frame-shared memory information having the frame-shared memory information ID  of \u201c#F3\u201d directly refers to the thread-shared memory corresponding to the thread-shared memory information having the thread-shared memory information ID  of \u201c#T1\u201d. It is also implied that the frame-shared memory corresponding to the frame-shared memory information having the frame-shared memory information ID  of \u201c#F3\u201d indirectly refers to the frame-shared memory corresponding to the frame-shared memory information having the frame-shared memory information ID  of \u201c#F2\u201d.","The referent-thread-shared memory information ID  is the referent-thread-shared memory information ID  developed through the referent-thread-shared memory information ID development process illustrated in . For example, \u201c#T1\u2192#F2\u201d is registered in the referent-thread-shared memory information ID  with the frame-proprietary memory information ID  of \u201c#2\u201d.","This implies that the thread-shared memory corresponding to the thread-shared memory information having the thread-shared memory information ID  of \u201c#T1\u201d directly refers to the frame-shared memory corresponding to the frame-shared memory information having the frame-shared memory information ID  of \u201c#F2\u201d.","[2. Calculation of Proprietary Memory Usage by Specific Thread]",{"@attributes":{"id":"p-0234","num":"0233"},"figref":"FIG. 25"},"The memory usage calculation part  can calculate the proprietary memory usage by a specific thread by executing this process. When the total memory usage (see ) and the shared memory usage (see ) by a specific thread have already been calculated, the proprietary memory usage can be calculated as the difference between the total memory usage and the shared memory usage.","The proprietary memory usage by a specific thread may be calculated as the sum of the following total values S_SUM and F_SUM below.","S_SUM: Total value of the frame-proprietary memory usage  of the frame-proprietary memory information S having the same thread ID  registered in the frame-proprietary memory information table ","F_SUM: Total value of the frame-shared memory usage  of frame-shared memory information indicated by a set F in a set A of frame-shared memory information IDs  that are directly or indirectly referred to from the referent-frame-shared memory information ID  or the referent-thread-shared memory information ID  of the frame-proprietary memory information S, excluding a set B of the frame-shared memory information IDs  that are referred to via the thread-shared memory information ID .","The following describes the flowchart of . The following description is given of a case where the proprietary memory usage by the thread with the thread ID  (see ) of \u201c#1\u201d is calculated, as a specific example. The same reference numerals are given to the same components as illustrated in  to avoid redundant description thereof.","In Step , the memory usage calculation part  calculates the set F in the set A of the frame-shared memory information IDs  for each frame-proprietary memory information S having the same thread ID , excluding the set B of the frame-shared memory information IDs  that are referred to via the thread-shared memory information ID  (S).","In other words, first, the memory usage calculation part  calculates the set A {\u201c#F1\u201d, \u201c#F2\u201d} of the frame-shared memory information IDs  that are directly or indirectly referred to from the referent-frame-shared memory information ID  or the referent-thread-shared memory information ID  of each frame-proprietary memory information S (see ).","Then, the memory usage calculation part  calculates the set B {\u201c#F2\u201d} of the frame-shared memory information IDs  that are referred to via the thread-shared memory corresponding to the thread-shared memory information ID  in the set A. As a result, the set F {\u201c#F1\u201d}, which is the set A excluding the set B, is calculated.","In Step , the set F, which is the set A excluding the set B, is calculated to prevent the memory usage of the frame-shared memory shared by a plurality of different threads from being added to the proprietary memory usage.","For example, the frame-shared memory corresponding to the frame-shared memory information with the frame-shared memory information ID  of \u201c#F2\u201d is referred to from the thread-shared memory corresponding to the thread-shared memory information with the thread-shared memory information ID  of \u201c#T1\u201d. According to the embodiment of this invention, such a frame-shared memory that is referred to by the thread-shared memory is classified as \u201cframe-shared memory\u201d, not \u201cthread-shared memory\u201d. Accordingly, the processing of Step  prevents the memory usage of the frame-shared memory that is referred to by the thread-shared memory in this way from being added to the proprietary memory usage.","The frame-shared memory that is referred to by a plurality of different threads in this way may be classified as a thread-shared memory. In this case, the set F that is calculated in Step  is the set of the frame-shared memory information IDs  that are directly or indirectly referred to from the referent-frame-shared memory information ID  or the referent-thread-shared memory information ID  of the frame-proprietary memory information S.","In other words, in this Step , the memory usage calculation part  determines an object which is used in an overlapping manner based on the reference relationship of individual objects that are referred to by the target thread.","In next Step , the memory usage calculation part  calculates the total value F_SUM of the frame-shared memory usage  of the frame-shared memory information indicated by the set F (S). In the above-mentioned specific example, the set F is {\u201c#F1\u201d}. In Step , therefore, the total value F_SUM is \u201c60\u201d, which is the memory usage of the frame-shared memory with the frame-shared memory information ID  of \u201c#F1\u201d.","In other words, in this Step , the memory usage calculation part  calculates the size of a memory area storing an object shared (used in an overlapping manner) by different stack frames in the target thread among those objects that have been determined as being used in an overlapping manner in Step .","In next Step , the memory usage calculation part  calculates the sum of the total value S_SUM and the total value F_SUM (S). In the above-mentioned specific example, the total proprietary memory usage by the thread with the thread ID of \u201c#1\u201d becomes \u201c180\u201d, which is the sum of \u201c120\u201d and \u201c60\u201d.","Through the processes described above, the memory usage calculation part  can calculate the proprietary memory usage by a specific thread (thread with the thread ID  of \u201c#1\u201d in this example). It is to be noted that the proprietary memory usage by a thread is, in other words, the memory release always released when the thread is terminated.","[3. Calculation of Shared Memory Usage by Specific Thread]",{"@attributes":{"id":"p-0252","num":"0251"},"figref":"FIG. 26"},"The memory usage calculation part  can calculate the shared memory usage by a specific thread by executing this process. When the total memory usage (see ) and the proprietary memory usage (see ) by a specific thread have already been calculated, the shared memory usage can be calculated as the difference between the total usage and the proprietary memory usage.","The shared memory usage by a specific thread may be calculated as the sum of the following total values T_SUM and F_SUM below.","T_SUM: Total value of the thread-shared memory usage  of thread-shared memory information indicated by the set T of thread-shared memory information IDs  that are directly or indirectly referred to from the referent-frame-shared memory information ID  or the referent-thread-shared memory information ID  of the frame-proprietary memory information S having the same thread ID  registered in the frame-proprietary memory information table ","F_SUM: Total value of the frame-shared memory usage  of frame-shared memory information indicated by the set F of the frame-shared memory information IDs  that are referred to via the thread-shared memory information ID  in the set A of frame-shared memory information IDs  that are directly or indirectly referred to from the referent-frame-shared memory information ID  or the referent-thread-shared memory information ID  of the frame-proprietary memory information S.","The following describes the flowchart of . The following description is given of a case where the shared memory usage by the thread with the thread ID  (see ) of \u201c#1\u201d is calculated, as a specific example. The same reference numerals are given to the same components as illustrated in  to avoid redundant description thereof.","In Step , the memory usage calculation part  calculates the set T of the thread-shared memory information IDs  for each frame-proprietary memory information S having the same thread ID  (S).","In other words, the memory usage calculation part  calculates the set T {\u201c#T1\u201d} of the thread-shared memory information IDs  that are directly or indirectly referred to from the referent-thread-shared memory information ID  of each frame-proprietary memory information S with the same thread ID  of \u201c#1\u201d (see ).","In other words, in this Step , the memory usage calculation part  determines an object shared (used in an overlapping manner) by a plurality of different threads (including the target thread) based on the reference relationship of individual objects that are referred to by the target thread.","In next Step , the memory usage calculation part  calculates the set F of the frame-shared memory information IDs  that are referred to via the thread-shared memory information ID  in the set A of the frame-shared memory information IDs  for each frame-proprietary memory information S having the same thread ID  (S).","In other words, first, the memory usage calculation part  calculates the set A {\u201c#F1\u201d, \u201c#F2\u201d} of the frame-shared memory information IDs  that are directly or indirectly referred to from the referent-frame-shared memory information ID  or the referent-thread-shared memory information ID  of each frame-proprietary memory information S (see ).","Then, the memory usage calculation part  calculates the set F {\u201c#F2\u201d} of the frame-shared memory information IDs  that are referred to via the thread-shared memory corresponding to the thread-shared memory information ID  in the set A.","In Step , the set F in the set A is calculated to add the memory usage of the frame-shared memory shared by a plurality of different threads to the shared memory usage.","In other words, in this Step , the memory usage calculation part  determines an object shared (used in an overlapping manner) by different stack frames in the target thread based on the reference relationship of individual objects that are referred to by the target thread.","In next Step , the memory usage calculation part  calculates the total value T_SUM of the thread-shared memory usage  of the thread-shared memory information indicated by the set T (S). In the above-mentioned specific example, the set T is {\u201c#T1\u201d}. In Step , therefore, the total value T_SUM is \u201c72\u201d, which is the memory usage of the thread-shared memory with the thread-shared memory information ID  of \u201c#T1\u201d.","In other words, in this Step , the memory usage calculation part  calculates the size of a memory area storing an object that has been determined as being used in an overlapping manner in Step .","In next Step , the memory usage calculation part  calculates the total value F_SUM of the frame-shared memory usage  of the frame-shared memory information indicated by the set F (S). In the above-mentioned specific example, the set F is {\u201c#F2\u201d}. In Step , therefore, the total value F_SUM becomes \u201c12\u201d, which is the memory usage of the frame-shared memory with the frame-shared memory information ID  of \u201c#F2\u201d.","In other words, in this Step , the memory usage calculation part  calculates the size of a memory area storing an object that has been determined as being used in an overlapping manner in Step .","In next Step , the memory usage calculation part  calculates the sum of the total value T_SUM and the total value F_SUM (S). In the above-mentioned specific example, the shared memory usage by the thread with the thread ID of \u201c#1\u201d becomes \u201c84\u201d, which is the sum of \u201c72\u201d and \u201c12\u201d.","Through the processes described above, the memory usage calculation part  can calculate the shared memory usage by a specific thread (thread with the thread ID  of \u201c#1\u201d in this example). It is to be noted that the memory usage of the thread-shared memory is the memory release which is not necessarily be released when the thread is terminated.",{"@attributes":{"id":"p-0272","num":"0271"},"figref":"FIG. 27"},"The example illustrated in  illustrates the proprietary memory usage, the shared memory usage, and the total memory usage by each of threads 1 to n illustrated in . In other words,  illustrates a thread ID , a proprietary memory usage , a shared memory usage , and a total memory usage  in association with one another information.","The proprietary memory usage  is calculated through the processing illustrated in . The shared memory usage  is calculated through the processing illustrated in . The total memory usage  is calculated through the processing illustrated in .","[4. Calculation of Memory Usage and Memory Release by a Plurality of Threads]","The following describes the process for the memory usage calculation part  to calculate the memory usage and memory release by a plurality of threads.","First, the memory usage by a plurality of threads is described.","To calculate the memory usage by a plurality of threads, the memory usage calculation part  considers the reference relationship between the frame-shared memory and the thread-shared memory shared by the plurality of threads. The reference relationship is acquired through the above-mentioned referent-frame-shared memory information ID developing process (see ) and referent-thread-shared memory information ID developing process (see ).","For example, the thread with the thread ID  of \u201c#1\u201d in the frame-proprietary memory information table after development illustrated in  is referring to the thread-shared memory that corresponds to the thread-shared memory information having the thread-shared memory information ID  of \u201c#T1\u201d.","Likewise, the thread with the thread ID  of \u201c#2\u201d is referring to the thread-shared memory that corresponds to the thread-shared memory information having the thread-shared memory information ID  of \u201c#T1\u201d.","Further, the thread with the thread ID  of \u201c#3\u201d is referring to the thread-shared memory that corresponds to the thread-shared memory information having the thread-shared memory information IDs  of \u201c#T1\u201d and \u201c#T2\u201d.","Further, the thread with the thread ID  of \u201c#n\u201d is referring to the thread-shared memory that corresponds to the thread-shared memory information having the thread-shared memory information ID  of \u201c#T2\u201d.","In other words, the threads having the thread IDs  of \u201c#1\u201d, \u201c#2\u201d and \u201c#3\u201d share the thread-shared memory corresponding to the thread-shared memory information with the thread-shared memory information ID  of \u201c#T1\u201d. Likewise, the threads having the thread IDs  of \u201c#3\u201d and \u201c#n\u201d share the thread-shared memory corresponding to the thread-shared memory information with the thread-shared memory information ID  of \u201c#T2\u201d.","Therefore, the memory usage calculation part  calculates the memory usage of a plurality of threads based on the reference relation in such a way that the frame-shared memory information shared by the plurality of threads and the memory usage of the thread-shared memory shared by the plurality of threads are not added in duplication.","In newly executing a thread X that shares a thread-shared memory T with another thread, the memory usage calculation part  can calculate an increase in the memory usage by the thread X.","For example, when there is not any other thread referring to the thread-shared memory T at the time the thread X is newly executed, an increase in the memory usage by the thread X is the sum of the proprietary memory usage by the thread X and the memory usage of the thread-shared memory T. When there is another thread referring to the thread-shared memory T, on the other hand, an increase in the memory usage by the thread X is the proprietary memory usage by the thread X.","The memory usage calculation part  can calculate the memory release released when execution of the plurality of threads is terminated.",{"@attributes":{"id":"p-0288","num":"0287"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0289","num":"0288"},"figref":["FIG. 28","FIG. 15","FIG. 28"],"b":["2801","2802","2803","2804"]},"The thread-proprietary memory release  is the release of the thread-proprietary memory released when a plurality of threads indicated by the thread ID  are terminated. The thread-proprietary memory release  is calculated as the total value of the thread-proprietary memory usage of the individual threads indicated by the thread ID .","When the thread ID  is {\u201c#1\u201d, \u201c#2\u201d}, for example, the thread-proprietary memory release  becomes \u201c300\u201d, which is the sum of the memory usage of the frame-proprietary memory of \u201c180\u201d with the thread ID  (see ) of \u201c#1\u201d, and the memory usage of the frame-proprietary memory of \u201c120\u201d with the thread ID  of \u201c#2\u201d.","The thread-shared memory release  is the release of the thread-shared memory released when a plurality of threads indicated by the thread ID  are terminated. The thread-shared memory release  is calculated as the memory usage of the thread-shared memory that is shared only by a plurality of threads indicated by the thread ID .","When the thread ID  is {\u201c#1\u201d, \u201c#2\u201d}, for example, there is not a thread-shared memory that is shared only by the two threads. Therefore, the thread-shared memory release  becomes \u201c0\u201d. When the thread ID  is {\u201c#3\u201d, \u201c#n\u201d}, on the other hand, the thread-shared memory release  becomes \u201c120\u201d, which is the thread-shared memory usage  of the thread-shared memory that is shared only by those two threads and has the thread-shared memory information ID  (see ) of \u201c#T2\u201d.","The total memory release  is the total release of memory released when a plurality of threads indicated by the thread ID  are terminated. The total memory release  is calculated as the sum of the thread-proprietary memory release  and the thread-shared memory release .","As described above, the memory usage calculation part  according to the embodiment of this invention can efficiently and accurately calculate the amount of memory that is actually used at an arbitrary point of time by the process that is executed by a thread.","[Control of Process Executed by Thread]",{"@attributes":{"id":"p-0297","num":"0296"},"figref":"FIG. 29","b":"32"},"First, in Step , the Java VM  executes the memory usage calculating process (S). As a result, the Java VM  acquires the status of the memory usage by each thread. The details of the memory usage calculating process are the same as described above with reference to .","Next, in Step , the Java VM  determines candidates for a thread to be controlled based on a control policy of the computer system  (S). The candidates for the thread to be controlled may be one in number or plural in number in accordance with the control policy. In addition, the control policy may be specified by the configuration file , or may be specified by another method.","In next Step , the Java VM  determines whether the candidate for the thread to be controlled determined in Step  has been permitted to be canceled (terminated or canceled) based on information set in the configuration file  (S). A thread which is permitted to be canceled may be directly set like \u201cthread X\u201d or may be indirectly set like \u201cthread executing the method X\u201d in the configuration file .","Then, in Step , the Java VM  determines whether an execution condition for canceling the thread is fulfilled based on information set in the configuration file  (S). The execution conditions for canceling the thread are, for example, such a condition that the amount of the memory to be released by cancellation of the candidate for the thread to be controlled is equal to or greater than a predetermined threshold.","When the result of the determination in Step  is YES and the result of the determination in Step  is YES, the Java VM  (memory usage calculation part ) requests the thread control part  to cancel the thread to be controlled, and the thread control part  cancels the thread to be controlled (S).","Then, in Step , the Java VM  requests the GC execution part  to execute the GC, and the GC execution part  executes the GC (S). This releases an unnecessary memory area.","In next Step , the Java VM  resumes execution of the method (S). When the result of the determination in Step  is NO or the result of the determination in Step  is NO, the Java VM  notifies of a memory shortage error (S).","Through the processes described above, when the memory shortage occurs the Java VM  specifies a thread that causes the memory shortage, and cancels the thread so that the GC permits an unnecessary memory to be used again. This makes it possible to efficiently avoid interruption of the Java VM  originating from the memory shortage, and keep execution of the method.","Although the description referring to  has been given of the case where the control target is a thread, the case is not restrictive. For example, the control target may be a process that is executed by a thread.",{"@attributes":{"id":"p-0307","num":"0306"},"figref":["FIG. 30","FIG. 1"],"b":["325","3000","324","3000","6","3000"]},"The output screen  illustrated in  corresponds to the result of calculating the memory usage by each thread illustrated in . In other words, output contents ,  and  respectively represent pieces of information acquired by ranking the proprietary memory usage , the shared memory usage , and the total memory usage  of each thread, and sorting the usage by ranking based on the memory usage.",{"@attributes":{"id":"p-0309","num":"0308"},"figref":"FIG. 30"},"Further, information representing the memory usage by each thread (for example, output information ) may be selected on the output screen . A user selects the output information  by using the input device  (for example, clicking of a mouse). Then, the memory information output part  generates a detailed output screen  (see ) relating to the selected output information , and outputs the output screen  onto the display. As a result, the output screen is changed. The output screen  is described later with reference to .",{"@attributes":{"id":"p-0311","num":"0310"},"figref":"FIG. 31"},"The output screen  illustrated in  is associated with detailed information of the output information  selected in . The \u201cdetail information\u201d in this case is frame-proprietary memory information about a thread relating to the output information  (thread with the thread ID of \u201c#1\u201d). In other words, output contents  and  respectively represent pieces of the frame-proprietary memory information with the frame-proprietary memory information IDs  of \u201c#1\u201d and \u201c#2\u201d.",{"@attributes":{"id":"p-0313","num":"0312"},"figref":"FIG. 31","b":["301","303","304","305","306"]},"Further, information representing the referent-thread-shared memory information ID  (for example, output information ) may be selected on the output screen . The user selects the output information  by using the input device . Then, the memory information output part  generates a detailed output screen  (see ) relating to the selected output information , and outputs the output screen  onto the display. The output screen  is described later with reference to .",{"@attributes":{"id":"p-0315","num":"0314"},"figref":"FIG. 32"},"The output screen  illustrated in  is associated with detailed information of the output information  selected in . The \u201cdetail information\u201d in this case is thread-shared memory information about the referent-thread-shared memory information ID relating to the output information  (\u201c#T1\u201d). In other words, output content  represents the thread-shared memory information with the thread-shared memory information ID  of \u201c#T1\u201d.",{"@attributes":{"id":"p-0317","num":"0316"},"figref":"FIG. 32","b":["501","502","503","504","505","506"]},"Further, information representing the referent-frame-shared memory information ID  (for example, output information ) and information representing the address  (for example, output information ) may be selected on the output screen . The user selects the pieces of output information  and  by using the input device . Then, the memory information output part  generates detailed output screens  and  relating to the selected pieces of output information  and , and outputs the output screens  and  onto the display. The output screens  and  are described later with reference to , respectively.",{"@attributes":{"id":"p-0319","num":"0318"},"figref":"FIG. 33"},"The output screen  illustrated in  is associated with detailed information of the output information  selected in . The \u201cdetail information\u201d in this case is frame-shared memory information about the referent-frame-shared memory information ID relating to the output information  (\u201c#F2\u201d). In other words, output content  represents the frame-shared memory information with the frame-shared memory information ID  of \u201c#F2\u201d.",{"@attributes":{"id":"p-0321","num":"0320"},"figref":"FIG. 33","b":["401","402","403","404","405","406"]},"Further, information representing the class name (for example, output information ) may be selected on the output screen . The user selects the output information  by using the input device . Then, the memory information output part  generates a detailed output screen  (see ) relating to the selected output information , and outputs the output screen  onto the display. The output screen  is described later with reference to .",{"@attributes":{"id":"p-0323","num":"0322"},"figref":"FIG. 34"},"The output screen  illustrated in  is associated with detailed information of the output information  selected in . The \u201cdetail information\u201d in this case is object reference about the address relating to the output information .",{"@attributes":{"id":"p-0325","num":"0324"},"figref":"FIG. 35"},"The output screen  illustrated in  is associated with detailed information of the output information  selected in . The \u201cdetail information\u201d in this case is object reference about the class name relating to the output information .",{"@attributes":{"id":"p-0327","num":"0326"},"figref":["FIG. 36","FIG. 1"],"b":["325","3600","324","3600","6","3600"]},"The output screen  illustrated in  corresponds to the result of calculating the memory release when each thread illustrated in  is terminated. In other words, output contents , , and  respectively represent pieces of information acquired by ranking the thread-proprietary memory release , the thread-shared memory release , and the total memory release  when a plurality of threads indicated by the respective thread IDs  are terminated, and sorting the amounts by ranking based on the memory release.",{"@attributes":{"id":"p-0329","num":"0328"},"figref":"FIG. 30"},"As described above, the memory information output part  according to the embodiment of this invention can output the result of the calculation executed by the memory usage calculation part . This makes it possible to monitor threads using the calculation result. For example, the flow rate can be controlled depending on the memory usage by threads. In addition, threads can be controlled by using the calculation result. For example, it is possible to identify a thread that has a large memory usage, and cancel the execution of the identified thread, thereby releasing the memory. This makes it possible to efficiently suppress the entire system down due to an insufficient memory.","Although the description of the embodiment of this invention has been given of the case where this invention is adapted to the calculation of the memory usage (memory release) in a process which is executed by a thread, this invention is not limited to the case, and may be adapted to other types of processing. For example, this invention may be adapted to all kinds of processing using what constructs a reference relationship, such as resources. Such processes include a program in a broad sense, and include processing which is executed by a thread, processing which is executed in a process, processing which is executed by a CPU, and so forth in a narrow sense. Likewise, this invention may be adapted to all kinds of processing which construct a reference relationship as resources of calculating the memory usage (memory release). The processes include a data structure, a module, and a library in a broad sense, and include an object, a memory, a file (descriptor), and so forth in a narrow sense.","Though the detailed description has been given of this invention referring to the attached drawings, this invention is not limited to this specific configuration, and includes various variations and equivalent configurations within the scope of the accompanying claims."],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1","b":"1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6","b":"601"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 36"}]},"DETDESC":[{},{}]}
