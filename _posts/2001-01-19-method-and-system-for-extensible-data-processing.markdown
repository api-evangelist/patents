---
title: Method and system for extensible data processing
abstract: A system and method of assembling an application for processing image or image-derived data is disclosed. The system includes a base operator configured to interface with one or more derivative operator classes, each operator class including an operator object for executing a processing function on the image or image-derived data. A base multiport node class is provided, which is configured to provide a multiport node for each operator object. The multiport nodes instantiates a pluggable operator for connecting the multiport nodes together at runtime according to user-defined parameters. The connection of multiport nodes implements the processing functions of the operator objects to execute the application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06886168&OS=06886168&RS=06886168
owner: Q3DM, LLC
number: 06886168
owner_city: San Diego
owner_country: US
publication_date: 20010119
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["This application claims the benefit of U.S. Provisional Application No. 60\/177,111, filed Jan. 20, 2000 and entitled \u201cA Software Framework for Scanning Cytometry,\u201d which is incorporated herein in its entirety.","1. Field of the Invention","The invention relates generally to images of specimens. In particular, the invention relates to extendable image processing architectures.","2. Description of the Related Art","An image of a biological specimen can be a useful tool in diagnosing a variety of pathological conditions. For instance, images of biological specimens can reveal cells in the process of dividing. Since cancer is characterized by rapidly dividing cells, an image showing an unusually large number of cells dividing can indicate the presence of cancerous cells.","Various image processing operations can be performed on the images or image-derived data. For instance, one operation can be a filter that selectively generates a processed image according to filtering criteria, such as selecting a particular type of specimen within an image. The processed image could then be presented to another processing operation, such as a threshold operation that renders a new processed image of specimen images that exceed a particular defined threshold.","The number and types of image processing operations can change over time, and vary with respect to a desired application. In order to change the image processing operations, or change parameters of particular processing operations, a change is usually required to the image processing software code which requires completely recompiling the code with the changes. Further, conventional systems do not allow parametric changes on the fly during runtime of an application without stopping the application and\/or needing to recompile the application code. For the above reasons, there is a need for a system and method for customizing an image processing platform, which supports the ability to be dynamically defined during run time of the image processing operations.","The invention relates to a architecture for a customizable image processing platform. In one embodiment of the invention, a system for assembling an application for processing image or image-derived data includes a base operator configured to interface with one or more derivative operator classes, each operator class including an operator object for executing a processing function on the image or image-derived data. The system according to the embodiment further includes a base multiport node class configured to provide a multiport node object for each operator object. The multiport node objects instantiate a pluggable operator for connecting the multiport node objects together at runtime according to user-defined parameters, and wherein the connection of multiport node objects implements the processing functions of the operator objects to execute the application.","In accordance with another embodiment, a method of assembling an application for processing image or image-derived data includes providing a base operator having an interface for interacting with one or more derivative operator classes, each operator class including an operator object for executing a processing function on the image or image-derived data. The method further includes providing a base multiport node configured to provide a multiport node for each interacting operator object, and connecting the multiport nodes with a pluggable operator instantiated by the multiport nodes.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1","b":["10","14","10","12","14","16","14","18","16","14","14","16","12","12","16","16","12","16","14","16","16","18","16","16","14","14"]},"The system  also includes a processing unit  in communication with the imaging device , a display  and one or more user interfaces . The processing unit  houses electronics  for controlling various operations of the system . For instance, the electronics  can control movement of the imaging device  relative to the specimen . The display  can be used to show at least a portion of one or more specimen images  which have been generated by the system . The displayed image is visible to an operator in a display area. The display  can also be used to indicate a variety of system  conditions to the operator.","An operator can use the one or more user interfaces  to interact with the system  and vary system parameters. For instance, an operator can use a user interface to manipulate the display area . The operator can change the portion of a specimen image  which is visible by scrolling to a new portion of the specimen image , zooming in and\/or zooming out on the specimen image . A suitable user interface includes, but is not limited to, a keyboard and a mouse. Although a single processing unit , one or more user interfaces  and display  are illustrated, the system  can include a plurality of processing units , displays  and user interfaces .","The electronics  can include one or more processors  for performing instructions stored or carried on a machine readable medium . Suitable processors  include, but are not limited to, programmed general purpose digital computers, microprocessors, digital signal processors (DSP), integrated circuits, application specific integrated circuits (ASICs), logic gate arrays and switching arrays.","The one or more processors  are in communication with one or more working memories  and one or more storage memories . Suitable working memories  include, but are not limited to, volatile memories such as RAM and other memories from which a processor primarily works during execution of instructions. Suitable storage memories  include, but are not limited to, non-volatile memories such as a disk drive.","The working memory and\/or the storage device are examples of or contain machine readable media which store data developed during operation of the system  and\/or instructions to be executed by the one or more processors . Other machine readable media which can serve as the working memory and\/or the storage device include, but are not limited to, optical discs such as a compact disk (CD), CD-ROM, CD-R (a recordable CD-ROM that can be read on a CD-ROM drive), CD-RW (multiple-write CD), CD-E (recordable and erasable CD), or DVD (digital video disc). Alternatively, instead of, or in addition to an optical disc, the machine readable media can include one or more of the following: a magnetic data storage diskette (floppy disk), a Zip disk, DASD storage (e.g., a conventional \u201chard drive\u201d or a RAID array), magnetic tape, RAM, electronic read-only memory (e.g., ROM, EPROM, or EEPROM), paper punch cards, or transmission media such as digital and\/or analog communication links.","In some instances, one or more of the machine readable media are positioned outside or remote from the processing unit . For instance, the machine readable medium  may be part of, or may be connected to, a server computer that is connected to a network, in order to make the machine-readable code available to other computers. The network may be a local area network (LAN), a wide area network (WAN), or any other type of network. This arrangement enables one or more other computers connected to the network to copy instructions and\/or data from the machine readable medium  that is part of, or connected to, the (server) computer, to a machine readable medium  that is part of, or connected to, the processing unit . This may be accomplished, for example, by connecting computers from one or more networks, over the Internet.","In other instances, the machine readable medium  may be part of, or may be connected to, a computer that is operating a bulletin board system  (BBS), which can be accessed by other computers. This arrangement enables the processing unit  to connect to the BBS and copy the instructions and\/or data from the machine readable medium  that is part of, or connected to, the computer that is operating the BBS, to the machine readable medium  in communication with the processing unit .",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 2","FIG. 2"],"b":["100","100","20","102","104"]},"As illustrated in , all processing operations are derived from the base operator . In an exemplary embodiment, the base operator  is an abstract class implementing an API. In order to create a new processing operator, a new class is derived from the base operator , and override the appropriate virtual functions. The system only calls functions in the base operator API to accomplish processing tasks, and therefore the system is not dependent on additional functions (helper functions, etc.) added to the interface of these newly-derived classes.","An outline of the functionality and responsibilities for an implementation of base operator derived classes, or operator objects  is as follows. Each operator object  has N inputs and M outputs (also referred to as ports) and return these values through a series of functions for getting the number of respective ports. For each input and output port, the operator object  returns the type information for that port. To implement the algorithm functionality, the operator implementation overrides a base operator's virtual function, called processOperatorInputs( ), that processes the operator object inputs. All base operator objects are responsible for creating and managing the lifetime of their outputs, thus the operator object's  virtual destructor must free these output resources when the object is destroyed.","In a specific example, when the operator object  is constructed by the system, the following general interface protocols are established. When a function processOperatorInputs( ) is called, an array of pointers to n valid base object  objects is passed in through the apInput input parameter. An array that holds m pointers to base object  objects is passed in though the apOutput parameter\u2014a processOperatorInputs( ) function is expected to copy the appropriate base object pointers into this array to represent the result of the operation for which it is responsible. For each input port, the type information does not generally change during the operator object's lifetime. Similarly, the operator object does not change the type information associated with its outputs. If an operator has either its connectivity to other processing nodes changed, or its configuration changed, it is possible that this could cause a change in the number of input\/output ports and their associated types. Changes in the connectivity or the configuration of operators are not allowed in the midst of a processing cycle; thus, the number and types of the input\/output ports should never change during a processing cycle.","The three classes, the base multiport node , multiport node  and pluggable operator  isolate the base operator  from dependencies within the structure of the system, while providing the interconnection and modular processing functionality. The pluggable operator  has a pointer to each base operator derived object . The pluggable operator  calls the operator class functions to determine the number of inputs and outputs, and their associated types. This information enables the pluggable operator  to create the input and output arrays, which contain the pointers to the base object class  objects. These arrays are used as parameters for an operator input processing function, to accomplish the associated image processing.","Based on the processing connectivity of the multiport nodes , the pluggable operator  calls the node's  predecessors to get references to the appropriate base object class  objects and then copies these references into the input array before calling the operator input processing function. Similarly, when the call to the operator inputs processing function returns to the pluggable operator , the results of the operation can then be passed to the node's ancestors from the output references in the same manner. The call direction is one way from the pluggable operator  to the base operator-derived operator object, and never the other way. The pluggable operator  calls functions of the operator objects  only through a base operator  abstract base class interface. The use of the base operator  as an abstract base class isolates the system from changes in implementations of the operator objects  derived from the base operator .","As illustrated by the class hierarchy shown in , the pluggable operator  is derived from the abstract base class multiport node . The multiport node  includes implementations necessary to support the plugging aspects for the interconnection of the operator ports between processing nodes. The multiport node  does not directly support the base operator objects , and has no dependencies on them. The pluggable operator  makes all calls to the operator object functions, and isolates the rest of the system from these calls and functions.","The multiport node  is derived from the base multiport node  class. The base multiport node  is a pure abstract interface without implementation code. In an exemplary embodiment, the base multiport node  forms an application programming interface (API). Since the system generally handles processing nodes through the base multiport node , changes to the partial implementation of multiport nodes  do not require recompilation of those components though this abstract interface.","After the API user has defined a new processing element to be derived from base operator  as an operator object , a maker function for the class must be implemented so that instances of the new object can be constructed and dynamically loaded by the system at runtime. Since object code for the new operator will be compiled after the processing application is compiled, it is not possible to directly link this newly defined operator object into the application. However, since the pluggable operator  operates on this new operator object though the base operator , it is not necessary for the system to know all of the details related to this specific operator object. If the system can get a valid base operator pointer from a dynamically created object derived from the base operator base class, this will enable the system to dynamically load the new object into the system, and the pluggable operator  can operate on it.","The maker function operates as follows in an exemplary embodiment. Within the same dynamic link library (DLL) defining the new operator, the API user also defines a standard C function that constructs this new operator and returns a pointer to it. For instance, if a new operator called CabcLinearFilter was derived from base operator , a standard C function returning a valid base operator pointer would suffice. For instance, a single statement can be used such as (new CabcLinearFilter).","Once a new base operator-derived operator object  has been defined along with the appropriate maker function, the system can construct the new operator object . The path to the DLL and the name of the maker function must be known. Conventional operating systems allow dynamical loading of libraries into a running process, such as, e.g. LoadLibrary( ), dlopen( ), etc. Once the library (module, shared object, etc.) is loaded by the process, the address of specific functions are then available though the function names, for example, GetProcAddress( ), dlsym( ), etc. After the system calls the maker function, it will have a valid base operator pointer for passing to the pluggable operator  object. These steps allow the system to dynamically load, create and connect a processing block that uses the functionality in this newly defined operator.","In more detail, and in accordance with an exemplary embodiment, the roles and responsibilities of the base abstract classes and derivatives follows.","Base Operator","The base operator  abstracts processing functionality of the application. The base operator  is an abstract base class whose primary responsibility is to provide a generalized interface so that processing functions done by operator objects, derived from the base operator, such as functions to provide a data source, filter, threshold, or data sink, etc. can be dealt with in a generic manner.","In an embodiment, the getSymbolicName( ) and setSymbolicName( ) are exemplary names that represent functions for assigning an arbitrary text label to the operator object for identification and description of the particular operator object. This text label may be something like \u201cEdge detecting Linear Filter,\u201d and can be changed throughout the operator object's lifetime.","Operator Object","These classes are implementations that are subclassed from the base operator abstract class. There are several pure virtual functions not implemented by the base operator that must be implemented before the derived class can be instantiated, or actually created in an executable. One responsibility of an operator object is to create and manage its own outputs. In an example embodiment, other functions of the operator objects are:\n\n","For configuration and persistence, the following functions can be used:\n\n","For pre- and post-processing, the following functions can be used:\n\n","The general guarantee to the processing function is as follows:","An array of valid pointers to valid inputs is passed in via an array and these inputs are valid during the function call.","An array that can hold pointers for each of the outputs will be passed in as well. Upon successful completion of the processing done by this operator, references to the outputs (managed by this operator) are copied into this array before returning from this function. This is how the results of this operation are passed to the outside. The output references must remain valid until the next call to one of the following three functions (initValidateInputsSetupOutputs, processOperatorInputs or deinit), or when the operator object is destroyed.\n\n","Base Multiport Node","The base multiport node class abstracts the plugging together of and doing processing on, interconnected base multiport nodes. The base multiport node class is an abstract base class whose primary responsibility is to provide a generalized interface to isolate the system using it from the actual implementation details that support the behaviors provided. For instance, a user of the base multiport node class knows nothing about the object that does the actual processing (i.e. the actual operator object derived from the base operator).","Multiport Node","The multiport node abstract class implements the plugging together with other multiport nodes, which enables the multiport nodes to do their \u2018work\u2019 on their inputs. The multiport node class is derived from base multiport node, in part to isolate the base multiport node class from changes in the implementation of the algorithm. Since the pure virtual functions are not all implemented in the multiport node class, this class is still abstract, and thus cannot be directly instantiated.","In an example implementation, the multiport node includes the following functions. For initializing the input\/output port count, the following functions can be used:\n\n","For connectivity with other multiport nodes, the following functions can be used:\n\n","For getting input data for a multiport node from predecessor nodes:\n\n","Pluggable Operator","The pluggable operator class is derived from multiport node class, and is a fully implemented class\u2014it can be instantiated. Of the three classes discussed in the multiport node class hierarchy, the pluggable operator class is the only class that knows about the base operator class, and which operations are held by the base operator class to accomplish the actual processing done by the multiport nodes that are connected together.","The pluggable operator implements many of the pure virtual functions in the base multiport node interface by forwarding calls to a member function of the operator object that it holds. For example, the pure virtual member function in the base multiport node interface is implemented by the pluggable operator class. The PluggableOperator::doIt( ) function ultimately calls the virtual BaseOperator::processOperatorInputs( ) member function to do the processing work. In one embodiment, the virtual processOperatorInputs( ) function can be implemented by the class derived from the base operator class.","The initializing, processing and de-initializing functions of the pluggable operator include:\n\n","The configuration and persistence functions, which can include calls forwarded to the base operator object managed by the pluggable operator are:\n\n","For pre- and post-processing, including calls forwarded to the base operator object managed by the pluggable operator:\n\n",{"@attributes":{"id":"p-0059","num":"0090"},"figref":"FIG. 3","b":["106","106","111","112","106","112","106","111","106","106","106","110"]},{"@attributes":{"id":"p-0060","num":"0091"},"figref":"FIG. 4","b":["118","120"]},"The directed arrows illustrate the connectivity between the output and input ports of the multiport nodes. The input ports are shown on the left side of the box labeled \u201cpluggable operator,\u201d and the output ports are shown on the right side of the box. The interconnectivity of the multiport nodes is supported by the multiport node class hierarchy. The boxes directly below the pluggable operators are operator objects  that are derived from the base operator. The solid connector signifies that the pluggable operator owns the operator object. The operator objects are configured to manage their own outputs. Thus, the image\/measurement output objects are connected by a line with a solid connector. Some of the operator objects may not own objects that they use, and are indicated by a hollow connector.",{"@attributes":{"id":"p-0062","num":"0093"},"figref":["FIGS. 5 and 6","FIG. 5","FIG. 6","FIG. 5"]},"Although the above disclosure is applicable to biological specimens, the disclosure can be applied to processing images of non-biological specimens. For instance, the specimens can be semiconductor wafer and\/or integrated circuits. Accordingly, the disclosure can be useful for inspection of integrated circuits and other solid state applications.","Other embodiments, combinations and modifications of this invention will occur readily to those of ordinary skill in the art in view of these teachings.","Therefore, this invention is to be limited only by the following claims, which include all such embodiments and modifications when viewed in conjunction with the above specification and accompanying drawings."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 5 and 6"}]},"DETDESC":[{},{}]}
