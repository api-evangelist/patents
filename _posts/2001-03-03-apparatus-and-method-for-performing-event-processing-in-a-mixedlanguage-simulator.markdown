---
title: Apparatus and method for performing event processing in a mixed-language simulator
abstract: An apparatus performs event processing in a mixed-language simulator. The apparatus comprises logic for generating a list of actions to be performed for a given trigger event occurrence and for processing at least some of the listed actions in a source-code-to-HDL-interface domain before performing a context switch from the source-code-to-HDL-interface domain to a source code model domain. By listing actions to be performed for a given trigger event occurrence and then processing listed actions before switching contexts, the amount of context switching between the HDL model domain and the source code model domain that occurs during the simulation is reduced.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07058562&OS=07058562&RS=07058562
owner: Hewlett-Packard Development Company, L.P.
number: 07058562
owner_city: Houston
owner_country: US
publication_date: 20010303
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","CVI Event Processing Algorithm","Dual Clock CVI Module Example"],"p":["The present invention relates to a mixed-language simulator and, more particularly, to a method and an apparatus for performing event processing in a mixed-language simulator that utilizes models written in different languages to simulate hardware designs.","It is known to mix models of hardware blocks written in the C programming language with models of hardware blocks written in the Verilog\u00ae hardware description language (HDL). These models are input to a Verilog\u00ae (hereinafter referred to as \u201cVerilog\u201d) simulator program, which performs the hardware simulation. One advantage of using the C programming language to construct some of the modeling blocks, rather than modeling all of the blocks in the Verilog HDL, is that it allows a higher level of abstraction to be used to create the major components of the hardware product being designed. For example, high-level C language descriptions can be written for ICs (Integrated Circuits) and modules within the ICs. These models can then be tied together early in the development cycle to form a complete system-level model. Full system level simulations can then be performed throughout the development of the product, thereby minimizing the potential for discovering system-level defects during the final integration of hardware and software.","Once the higher-level system model has been generated, each hardware block comprising the system model is then progressively refined to lower levels of abstraction by writing the lower-level model portions in the Verilog HDL until the lowest levels of the models, i.e., the gate or transistor levels, have been generated. The mixed-language capability of the simulator allows uneven, parallel development among teams designing different pieces of the project, and provides the flexibility needed to optimize full-system simulation for performance and memory usage.","One of the problems associated with existing implementations of Mixed C and Verilog simulators is the overhead involved with switching context between the Verilog and C portions of the simulation. Prior techniques have included running the C simulation as a separate process with a communication channel to the HDL simulator, or, alternatively, running the C model code and the HDL simulator in the same process, but executing the C model code directly and immediately on trigger signals when events occur in the simulator. With both techniques, a large number of context switches are required. Context switches increase processing overhead, which results in penalties in terms of simulator performance.","The present invention provides an apparatus and a method for performing event processing in a mixed-language simulator in a manner that minimizes context switching between at least one model written in a source code language and at least one model written in a hardware description language (HDL). The present invention comprises logic for generating a list of actions to be performed for a given trigger event occurrence and for attempting to process at least some of the listed actions in a source-code-to-HDL-interface domain before performing a context switch from the source-code-to-HDL-interface domain to a source code model domain. The HDL model domain corresponds to execution of a model written in the HDL. The source code model domain corresponds to execution of a model written in the source code language. The source-code-to-HDL-interface domain corresponds to execution of source-code-to-HDL-interface code. By generating the list of actions and attempting to perform at least some of the actions before the context switch is performed, an amount of context switching between the HDL model domain and the source code and interface domains performed during simulation is minimized.","The method for performing event processing in a mixed-language simulator, which may be performed by a computer program being executed by the apparatus of the present invention, comprises the steps of determining when a trigger event has occurred, if a determination is made that a trigger event has occurred, determining a type of trigger event that has occurred, generating a list of actions to be performed based on the determination made as to the type of trigger event that has occurred, determining which of the actions in the list are enabled and which of the actions in the list are not enabled, attempting to process each of the enabled actions, and causing a context switch from a source-code-to-HDL-interface domain to a source code model domain to occur once attempts have been made to process each of the enabled actions. When the context switch from the source-code-to-HDL-interface domain to the source code domain occurs, the source code language model is executed.","These and other features and advantages of the present invention will become apparent from the following description, drawings and claims.","In order to minimize context switching overhead, the present invention collects all of the evaluations of the C model that occur at a given simulation time and places them in a single invocation of C model evaluator, thus minimizing the number of memory transitions required between the C simulator and the HDL simulator. By doing this the computer system on which the simulation is executing can take better advantage of local caching of memory, and thus the execution speed of the mixed simulation is enhanced.","The present invention provides for specifying the configuration of models prior to a mixed-language simulation and for performing an event processing algorithm during the simulation to simulate a hardware design. The term \u201cmixed-language,\u201d as that term is used herein, is intended to denote the mixture of models written in some higher-level source code programming language and models written in a hardware description language (HDL). The present invention is not limited to using any particular higher-level source code programming language or to any particular HDL. However, because Verilog hardware simulators are currently the most widely used simulators, the present invention will be described with respect to using a Verilog simulator and the associated Verilog HDL and Verilog programming language interface (PLI).","Similarly, because the C programming language is currently the most popular source code programming language utilized with Verilog simulators to create mixed-language simulators, the present invention will be described with respect to using this particular programming language with a Verilog simulator and the associated Verilog HDL and PLI.","However, the description of the present invention is only being limited in this way for purposes of brevity and for the purpose of illustrating one particular embodiment of the present invention. Those skilled in the art will understand, in view of the description provided herein, the manner in which other source code programming languages and other simulators, HDLs and PLIs may be utilized to carry out the present invention.","The following references, which are incorporated herein by reference in their entireties, provide information relating to hardware simulation, including mixed-language hardware simulation, and it is believed that they may be useful reference materials for understanding the concepts and implementation details of the present invention: Burgoon, David A., Powell, Edward W., Sorensen, Lief J., Waitz, John A. Sundragon, \u201cNext Generation Concurrent Engineering for Complex Dual-Platform Subsystem Design,\u201d Proceedings of the DesignCon 2000 On-Chip System Design Conference; Burgoon, David A., \u201cAchieving Concurrent Engineering for Complex Subsystem Design: The Case for Hardware Functional Modeling using C,\u201d Proceedings of the DesignCon 1998 On-Chip System Design Conference, pp. 357\u2013371; Burgoon, David A., \u201cA Mixed-Language Simulator for Concurrent Engineering,\u201d Proceedings for the 1998 IVC\/VIUF Conference, pp 114\u2013119; Sternheim, Eli Ph.D. interHDL, Inc.; Rajvir Singh, interHDL, Inc.; Yatin Trivedi Y T Associates \u201cDigital Design and Synthesis with Verilog HDL\u201d ISBN 0-9627488-2-x, Copyright 1993 Automata Publishing Company, San Jose, Calif. 95129; and Stroustrup, Bjame, \u201cC++ Programming Language, Third Edition\u201d ISBN 0-201-88954-4, copyright 1997 by AT&T.","An embodiment of the present invention will now be described with reference to utilization of a Verilog simulator, its associated HDL and PLI, and the C programming language to describe the manner in which the configurations of the models are specified prior to simulation and the manner in which event processing occurs during simulation. Specifying the configurations of the models to be used during simulation is accomplished in accordance with the present invention in a manner that is easy, efficient, and non-redundant. Processing of events during simulation is performed in a manner that maximizes simulator performance. Rather than using separate processes for performing event processing for models written in the C programming language and models written in the Verilog HDL, a single process algorithm is utilized. All of the models are comprised as threads within the same process and the event processing algorithm minimizes switching between the HDL simulator thread and the C model threads.","Because the tasks associated with specifying the configurations of the models are performed prior to simulation, the manner in which these tasks are performed will first be described with reference to , and then the manner in which events are processed during simulation in accordance with the present invention will be described with reference to . The present invention improves hardware modeling by (1) simplifying the task of writing C models, (2) simplifying the writing of a C-to-Verilog Interface (hereinafter referred to as \u201cCVI\u201d) and (3) improving the performance of the resulting mixed C\/Verilog simulation. Objective (1) is accomplished by providing a new C language application programming interface (API) that makes the C code look more like Verilog code modules. Objective (2) is accomplished by employing a set of Verilog PLI tasks that understand how the C API functions. Objective (3) is accomplished by compiling the C model into the Verilog executable so that the all events are processed in the same process.","The version of the PLI utilized in accordance with an example embodiment is Verilog PLI Version 2.0, although other PLI versions, such as Verilog PLI Version 1.0, for example. The Open Verilog International (OVI) PLI functions of both PLI versions have been adopted as part of the Verilog Procedural Interface (VPI) specified in the IEEE 1364 standard. The VPI functions corresponding to PLI Version 2.0 provide a consistent, object-oriented model for accessing all Verilog data structures.","The basic concepts of the present invention will now be described with reference to the block diagram of , which illustrates the manner in which models written in C are interfaced with models written in Verilog. The elements of the portion  of a C model to be simulated are above the dashed line . The elements of the portion  of a Verilog model to be simulated are below the dashed line . The C model portion  comprises input and output nodes  and , respectively, thread(s) , input port  of the thread(s)  and output port  of the thread(s) . The C-to-Verilog Interface (CVI) module , which interfaces the C model portion  with the Verilog portion , is written in Verilog.","The CVI module  utilizes PUT and GET calls  and , respectively, and Verilog signals and registers. The Verilog signals of the PUT calls are the \u201cdata\u201d signal , and the \u201cenable\u201d signal . The PUT calls utilize a \u201cfull\u201d register . The Verilog signal of the GET calls  is the \u201cenable\u201d signal . The registers of the GET calls  are the \u201cdata\u201d and \u201cempty\u201d registers,  and , respectively. The signals of the PUT and GET calls  and  are objects that are declared as type Wire in the Verilog HDL. The registers of the PUT and GET calls  and  are declared as type Reg in the Verilog HDL.","The signals , , and  can be viewed as input ports on the CVI module  that do not have internal registers declared for them. The values of the signals are fed in to either the PUT or GET calls from outside of the CVI module , or are stored locally within the CVI module  and fed to the PUT and GET calls. The aforementioned VPI functions that enable the C code to manipulate Verilog objects from within the CVI module  preferably only write values into objects that are of type Reg, but can sample the values of both type Reg and type Wire.","When a trigger event occurs, the PUT call  samples the data signal , which is the data argument to the PUT call , and stores the value that is sampled into the node  to which it corresponds. The nodes  and  preferably have a first-in-first-out (FIFO) structure, as discussed below in more detail. If node  becomes full, the PUT call will write a value to the register  associated with the PUT call  to indicate that the node  is full and cannot accept more data. If the enable signal  is low, then preferably the PUT action is disabled. In this case, when a trigger event occurs that triggers the PUT call , the PUT call  will not attempt to sample data or send data out to the node  when an event occurs that triggers the PUT call . If the enable signal  is high when an event occurs that triggers the PUT call , preferably the PUT call  will be enabled and data will be sampled and output to the node .","With respect to the GET call , if the enable signal  is high when an event occurs that triggers the GET call , preferably the GET call will read data out of the node , which corresponds to the data argument of the GET call , and write the data to data register  specified by the data argument of the GET call . If the node  is empty, preferably the GET call  will set a value in the register  to indicate that the node  was empty. If the enable signal  is low when an event occurs that triggers the GET call , preferably the GET call  will be disabled and will not attempt to read data out of the node . The enable signal  could be disabled (i.e., low) when, for example, a downstream CVI or Verilog block (not shown) is not ready to receive more data. Both the PUT and GET calls  and , respectively, receive clock signals that trigger them when a specified signal transition edge (i.e., a trigger event) of the clock occurs.","The CVI module  system tasks execute as part of the combined C and Verilog simulation process. In accordance with the present invention, the C model portion  represents the functionality of a Verilog module by having one or more \u201cthreads\u201d . A thread  can be thought of as a separate stream of execution that shares memory with other threads in the same process. This allows all of the threads to communicate through a first-in-first-out (FIFO) structure of the nodes  and . The order of execution of threads  can be controlled to execute in a selected order mode, or allowed to run in a random order mode. Utilizing the controlled order mode ensures that simulation results will be repeatable.","Each of the threads  has a list of input ports  and output ports  through which they read and\/or write a specific associated node. The thread  can write to a node through an output port  and read from a node through an input port . A port is preferably connected to exactly one node, but a node may connect with multiple thread input\/output ports. Thread module \u201cinstances\u201d are wired together by associating their ports to nodes. Code modules can also be instantiated into higher-level code modules to form a hierarchy. The nodes associated with the ports of each thread or module instance are unique. For example, if a block containing a node is instantiated more than once in the design, then each block instance contains a distinct copy of that node.","Conceptually, a node represents a collection of wires in a hardware design that conveys information between blocks. As stated above, the node preferably is modeled as a FIFO. The FIFO has a size that preferably is specified at design initialization. The node holds a list of data values that are to be passed between blocks sequentially. Each entry in the node is stored with the same type of C language \u201cstruct,\u201d which is a user-defined type that can have an arbitrary size. The data in the FIFO can be thought of as the values that would appear on the wires of a design over time. The depth of the node controls how many future data values the C model can calculate before the FIFO full state of the node  causes it to suspend. The concept of storing data representing the value of a signal at multiple times will be referred to herein as \u201ctemporal buffering\u201d.","A node maintains a list of the threads that read or write to it. Writing to the node preferably corresponds to adding data to the next empty slot in the list. Each reader of the node has a separate read pointer associated with it. A data slot in the FIFO is not considered empty until all readers have read that slot. For an input\/output (I\/O) port on a C model, the thread that is writing does a read after every write. This is because the I\/O port is also listed as a reader of the node. Therefore, if the writing thread did not read back the values, the thread's read pointer would get behind and permanently stall. A thread also reads all data from other threads coming in on an I\/O port of a C model before starting to write to the I\/O port of the C model. This ensures that the internal state of the thread will be consistent with all past events before the change in write\/read direction occurs.","Since different compilers encode data in C structures in different orders, each node has function pointers associated with it that can be used to encode and decode the C structures in a standard byte order. Preferably, only nodes attached to ports associated with CVI modules need to define and set encode and decode function pointers. Nodes connected to C model ports associated with CVI modules utilize additional information added to the node when GET and PUT tasks are processed during the simulation initialization. The CVI implementation of the present invention uses separate calls for reading and writing nodes that pass in information about which CVI instance is performing the read or write operation. The CVI read and write operations preferably exchange data only with the set of threads associated with the CVI instance.","There preferably are four CVI system tasks that are utilized by the present invention, namely, $gps get_fm_c( ), $gps_put_to_c( ), $gps_pull_fmco( ), $gps_push_to_c( ). These system tasks are only used in the Verilog initial block of a CVI module . Each call to a system task preferably is associated with exactly one port on the C model. The port handle argument along with the Verilog instance path of the calling CVI module is used to uniquely identify the corresponding C port instance. A given C model port has only one input type CVI function and one output type CVI function associated with it.","The C model API of the present invention includes C model tools that form a new C model API having a corresponding set of API rules. A C model API library preferably is built around two basic concepts, namely, modules and nodes. The C model API modules are used to mimic the hierarchical nature of a hardware design and are intended to map one-to-one to the top-level modules in the corresponding Verilog model portions of the design. The syntax for a C model API module preferably looks similar to that of Verilog and preferably Verilog module templates are created from C by running a translator that exports the C model hierarchy in the form of a Verilog netlist. There are two types of C model API modules, namely, blocks and threads. Blocks only call other blocks and\/or threads, and thus have no behavioral code associated with them. They are essentially like a Verilog module containing only instantiations of other modules. A thread is a leaf module that models behavior and only calls C model API library functions and standard C functions.","A C model API module preferably has only one argument, namely, a pointer to a user-defined structure. The user-defined structure preferably includes a list of three predefined types, namely, gps_input, gps_output, and gps_inout, which are described below with reference to an example of a C model API of the present invention, and constants, which preferably are of type \u201cint.\u201d All data comes into or leaves a C model API module through the ports defined in the argument. Thus, a typical (thread) C model API module declaration in accordance with the present invention might look as follows:",{"@attributes":{"id":"p-0038","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["gps_struct(mfu)","\/\/ the struct name (mfu) must match a module name"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"gps_input","reset;"]},{"entry":[{},"gps_output","busy;"]},{"entry":[{},"gps_input","fifo_in;"]},{"entry":[{},"gps_output","fifo_out;"]},{"entry":[{},"gps_inout","readback_bus;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int","mfu_reg;","\/\/ local mfu register"]},{"entry":[{},"};"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["gps_module_thread(mfu, myptr)","\/\/ (modulename,reference_pointer_to_struct)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"\/\/ assume there are 3 mfu's in this design so they each need a"]},{"entry":[{},"\/\/ separate set of registers"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"int data;","\/\/ this is a procedure local so it disappears each"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ pass thru the thread"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"gps_read_or_suspend(myptr\u2212>fifo_in,&data)"]},{"entry":[{},"if (something)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"myptr\u2212>mfu_rag = data;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"gps_write_or_suspend(myptr\u2212>fifo_out,&data);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The nodes of the C model API of the present invention greatly simplify the creation of the CVI modules. All communication between C model API modules is accomplished through nodes. Thus, a port of one C model API module is connected to a node, which is then connected to one or more ports of other C model API modules. A node is equivalent to a bus or wire in Verilog. In C, a node essentially allows time to be separated between modules that mimic parallel execution, but that, in reality, execute one at a time (i.e., on a uniprocessor, or in repeatable simulation mode). A node does not communicate with another node, but rather, it communicates with a thread module containing reads or writes on one of the module ports. Thus, preferably only one node is allowed on any one \u201cnet,\u201d or set of connections to modules. It is up to the designer to determine where in the hierarchy the node is actually declared. Nodes are most easily created in a calling block, but can be created inside a called block, as discussed below in more detail. The following example below demonstrates this.","Specifically, a node may be created by declaring its name and then calling gps_inst_node( ) with its depth and width. To ensure good performance, it has been determined that a depth declared to be 64 or greater is suitable, and that only power of 2 depths should be allowed. By programming a node to a depth of 1, tight coupling between threads can be obtained. This is useful for signals such as, for example, \u201creset\u201d (which typically has multiple readers), where it is undesirable for threads to proceed until all threads have been reset.","As stated above, nodes preferably can have multiple readers and multiple writers. If there are multiple readers, each reader advances at its own rate. The slowest reader determines the \u201cused\u201d count (the number of occupied node entries) for all writers. With multiple writers, it is up to the programmer to control which thread may write to a node next, in order to keep the write data in the proper order. Writes can be forced to occur, even if the node is full, by using the argument gps_write_over( ), as opposed to what is referred to herein as the gps_write_or suspend( ) argument. In accordance with the preferred embodiment, the ability to read without the possibility of suspending is provided by checking the node \u201cused\u201d count (i.e., using gps_used( ) or gps_empty( )) before issuing the read (i.e., before using the gps_read_or suspend( )).","A port on a module may be declared gps_inout. When this is the case, it is preferable that the programmer or designer ensure a node is always read to an empty condition before writing the node. In addition, every write should be accompanied by a \u201cdummy\u201d read to insure that the read pointer for the writing thread does not get behind. Nodes preferably have data-in-flight between threads. When modeling signals such as \u201cbusy\u201d or \u201cWPNE\u201d (write pipe not empty) that indicate unprocessed data, the receiving block cannot indicate a busy condition because it has not read the data yet. To solve this problem, the node write functions preferably allow a secondary node to be written, as a side effect of writing the primary node. This is accomplished by attaching one or more \u201cbusy\u201d nodes to an instantiated node. Whenever the node is written, a \u201c1\u201d will also be written to the attached \u201cbusy\u201d nodes, which can only have a data width of \u201cint.\u201d \u201cBusy\u201d nodes preferably will generally have a depth of 1 and are written in overwrite mode since only the latest value is important. \u201cReset\u201d nodes also preferably have a depth of 1 to insure that all blocks have read the reset value before a new value can be written.","Locks (i.e., gps_node_lock_or_suspend( ) and gps_unlock( )) are used to prevent another thread from changing the state of a node that needs to be frozen. This is necessary on \u201cbusy\u201d nodes where one thread is attempting to clear the \u201cbusy\u201d signal, while another thread is trying to set the \u201cbusy\u201d signal as a side effect of writing an input to the first thread. Thus, locks allow a thread to safely change an output by blocking other threads from performing operations that may affect the output. One or more \u201creset\u201d nodes may also be attached to a node. When an attached \u201creset\u201d is \u201c1,\u201d the node will reset all internal pointers to zero. Attached \u201creset\u201d nodes may only have a width of \u201cint.\u201d The C model API of the present invention creates a special thread that goes through all the attached \u201creset\u201d nodes looking for an active reset data value. When it finds one, it forces each node into a reset state until the reset condition is cleared.","Below is an example of the manner in which nodes can be created and hooked up or connected to modules. It should be noted that the identifier \u201cchip\u201d corresponds to a block module and \u201cmfu\u201d corresponds to a thread module.",{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"gps_struct (chip)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"gps_input","reset;"]},{"entry":[{},"gps_input","in_bus;"]},{"entry":[{},"gps_output","out_bus;"]},{"entry":[{},"};"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"gps_module_block (chip, chipports)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"gps_dec1_node(mfu0to1);","\/\/ declare node"]},{"entry":[{},"gps_dec1_node(in_bus);","\/\/ input node is declared inside chip !"]},{"entry":[{},"gps_dec1_node(busy0);","\/\/ busy for mful0"]},{"entry":[{},"gps_node_busy1;","\/\/ busy for mful \u2212"]},{"entry":[{},{},"\/\/ another way to do the same thing"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"gps_dec1_inst(mfu,mfu_0);","\/\/ declare one instance of mfu"]},{"entry":[{},"gps_dec1_inst(mfu,mfu_1);","\/\/ declare another instance of mfu"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"unsigned int","bus;","\/\/ bus is 32 bits"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ end of declarations - start executable code"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"gps_inst_node(busy0,1,sizeof(int));","\/\/ create busy node"]},{"entry":[{},"gps_inst_node(busy1,1,sizeof(int));","\/\/ create busy node"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"gps_inst_node(chipports\u2212>in_bus,64, sizeof (bus));"]},{"entry":[{},"\/\/ create input node"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"gps_node_busy(mfu0to1,busy0);","\/\/ attach busy to node"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"gps_inst_node(mfu0to1,64,sizeof(bus));","\/\/ create node depth=64"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"gps_node_rset(mfu0to1,port\u2212>reset);","\/\/ attach reset to node"]},{"entry":[{},"gps_node_busy(mfu0to1,busy1)","\/\/ attach busy to node"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ instantiate and wire up mfu_0"]},{"entry":[{},"gps_inst_module(mfu_0);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"gps_port(mfu_0\u2212>reset",",chipports\u2212>reset)"]},{"entry":[{},"gps_port(mfu_0\u2212>fifoin",",chipports\u2212>in_bus);"]},{"entry":[{},"gps_port(mfu_0\u2212>fifoout",",mfu0to1);"]},{"entry":[{},"gps_port(mfu_0\u2212>busy",",busy0);"]},{"entry":[{},"gps_cnst(mfu_0\u2212>mfu_id",",0);"]},{"entry":[{},"gps_end();"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ instantiate and wire up mfu_1"]},{"entry":[{},"gps_inst_module(mfu_1);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"gps_port(mfu_1\u2212>reset",",chipports\u2212>reset)"]},{"entry":[{},"gps_port(mfu_1\u2212>fifoin",",mfu0to1);"]},{"entry":[{},"gps_port(mfu_1\u2212>fifoout",",chipports\u2212>out_bus);"]},{"entry":[{},"gps_port(mfu_1\u2212>busy",",busy1);"]},{"entry":[{},"gps_cnst(mfu_1\u2212>mfu_id",",1);"]},{"entry":[{},"gps_end();"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"It should also be noted that the node for in_bus on chip preferably is declared inside the module instead of at the next higher level in the hierarchy. This allows programmers or designers who prefer to embed the node into a block to do so since it is modeling a FIFO present in that block. Because no node exists in the higher level, when chip is instantiated, the port name is used twice in the gps_port hookup call as shown below:\n\n","Preferably, all C model API exposed defines, variables, typedefs, structures, and function calls are contained in the file gps_hwsim.h. Most functions preferably are macros that invoke one or more functions.",{"@attributes":{"id":"p-0048","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Preferred Embodiment of the C Model API"},{"entry":"The C model API, in accordance with the preferred embodiment, is described"},{"entry":"by the following:"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["declaration macros:",{}]},{"entry":["gps_struct(ModuleName)","used to declare a module structure"]},{"entry":["gps_module_block(ModuleName)","used to declare block (hierarchy)"]},{"entry":"modules"},{"entry":["gps_module_thread(ModuleName)","used to declare thread (leaf) modules"]},{"entry":["gps decl inst(ModuleName,InstanceName)","used to declare an instance of a module"]},{"entry":["gps_decl_node(NodeName)","used to declare a node"]},{"entry":"typedefs:"},{"entry":["gps_node","alternate way to declare nodes"]},{"entry":["gps_input","used to declare an input port in the gps_struct"]},{"entry":["gps_output","used to declare an output port in the gps_struct"]},{"entry":["gps_inout","used to declare an bi-directional port in the gps_struct"]},{"entry":"module instantiation macros:"},{"entry":["gps_inst_module(InstanceName)","instantiate a module"]},{"entry":["gps_port(PortName,Nodename)","hook up module port"]},{"entry":["gps_cnst(PortName,Value)","hook up module constant port"]},{"entry":["gps_end()","end instantiate"]},{"entry":"node instantiation macros:"},{"entry":["gps_inst_node(NodeName,Depth,Width)","instantiate a node"]},{"entry":["gps_node_rset(NodeName,ResetNodeOrPort)","attach a reset to node"]},{"entry":["gps_node_busy(NodeName,BusyNodeOrPort)","attach a busy to node"]},{"entry":"node macros:"},{"entry":["gps_free(PortName)","returns int (free == 0) means full"]},{"entry":["gps_used(PortName)","returns int (used == 0) means empty"]},{"entry":["gps_empty(PortName)","returns TRUE\/FALSE"]},{"entry":["gps_full(PortName)","returns TRUE\/FALSE"]},{"entry":["gps_write_or_suspend(PortName,&Data)","normal write"]},{"entry":["gps_write_over(PortName,&Data)","trash last empty if full"]},{"entry":["gps_read_or_suspend(PortName,&Data)","normal read"]},{"entry":["gps_peek_or_suspend(PortName,&Data)","get data but don't advance node"]},{"entry":["gps_io_read_or_suspend(PortName,&Data)","for input\/output nodes"]},{"entry":["gps_read_if_not_empty(PortName,&Data)","reads one entry if not empty"]},{"entry":["gps_read_until_empty(PortName,&Data)","read until empty (no suspend)"]},{"entry":"miscellaneous functions:"},{"entry":["gps_suspend()","suspend the current thread (nothing else to do)"]},{"entry":["gps_node_lock_or_suspend(PortName)","lock thread ports (used for busy determination)"]},{"entry":["gps_unlock()","unlock all locked thread ports"]},{"entry":["gps_force_thread_active()","the thread is considered active even if no ops"]},{"entry":"completed"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The manner in which a mixed-language simulator is initialized in accordance with the preferred embodiment of the present invention will now be described. One of the primary features of the present invention that enables non-redundant specification of the configuration of the mixed-language model is that, inside the initial blocks of the Verilog model, tasks are called that analyze the hierarchy path within the Verilog model and identify the corresponding hierarchy path in the C model. These tasks mark flags within the C model that inform the C model of which connections within the C model are to be enabled or disabled. The specific way in which these functions are accomplished in accordance with the preferred embodiment will now be described with reference to the flow chart of .","The first step in specifying the configuration is to dynamically load the project-specific portion of the C model into the simulator, as indicated by block  in the flow chart. When the C model is loaded, C code contained within a shared library is loaded into the executable image of the simulation process by the operating system dynamic loader. This is accomplished through use of a VPI callback triggered at the beginning of the Verilog initialization sequence, or, in the case of a stand-alone C model, on startup of the stand-alone C model simulation. The phrase \u201cstand-alone C simulation\u201d is intended to denote herein simulation of a hardware design in which the code models utilized by the simulator to perform the simulation are all written in the C programming language (i.e., no models are written in an HDL).","The shared library comprises functions defined in the C language that will be used by the simulator during simulation. An argument is defined to specify the shared library name for the C model to be loaded. Function naming rules are defined to help avoid namespace collisions of C model functions with simulator functions.","Once the C model has been loaded, a C model builder function is called to build the C model hierarchy, as indicated by block . During the initialization phase of startup, the C model threads and nodes are instantiated in order to build the C model hierarchy. The C model may have run-time configurable options that control how the C model is built. In this case, these options can be specified through command line arguments that allow the user to specify name=value pairs in a namespace specific to the C model. If a variable name is not found in the C model namespace, then the Verilog variable definition namespace will be searched. In the case of a stand-alone C simulator, a \u201cVerilog Namespace\u201d will be created in the stand-alone C simulator by placing values set with Verilog style command line arguments into the Verilog namespace.","A scope resolution syntax preferably is provided to allow the C model author to restrict the resolution of a variable to only the C or Verilog namespace. The syntax of the variable definition arguments for the stand-alone C simulator is kept the same as that used for the Verilog simulator. The stand-alone C simulator will also provide a mechanism, similar to the Verilog \u201c-f\u201d argument, for reading arguments from a file. This simplifies writing of the \u201cmakefile\u201d used to invoke the simulator. The same code for accessing the C model namespace can be used in the stand-alone C simulator and in the Verilog simulator. The configuration of the design is specified in a file that is interpreted in conjunction with the makefile to produce a list of invocation arguments for the simulator, including C model variable definitions, Verilog defines, include directories, and specific files to be loaded or compiled. It should be noted that variables defined in the Verilog namespace can be used to control selection of hierarchy options in both the C and Verilog portions of the model.","After the C model has been built, the Verilog \u201cinitialization\u201d (initial) blocks are executed, as indicated by block  in the flow chart. Inside of these blocks, calls are made to the GET and PUT tasks. Each GET and PUT call knows where it was called from in the Verilog model hierarchy. These calls use their respective hierarchy paths in the Verilog model to find the corresponding hierarchy paths in the C model. When these calls find the ports of the corresponding paths in the C model, they cause the respective ports in the C model to be tagged to indicate that the ports have corresponding GET and PUT calls in the Verilog CVI module. From this tagging process, the C model can determine which ports are active in the C model and which are not. Ports in the C model that are inactive correspond to portions of the C model that are to be simulated with the Verilog model. Ports in the C model that are active correspond to portions of the mixed-language model that will be simulated with the C model portions and the resulting signals will be processed and interfaced to the Verilog model portions by the CVI modules .","A \u201cPort_CVI_mode\u201d and \u201cNode_CVI_mode\u201d flag exist for each of the ports and nodes of the C model. In the case of a stand-alone C model simulator, when the C model is invoked in stand-alone mode, all of the Port_CVI_mode flags are initialized to \u201cfalse,\u201d and all of the C model threads are therefore active. When a mixed C and Verilog simulation is started, all of the port CVI mode flags are initialized to \u201ctrue\u201d. When the CVI GET and PUT tasks are called from the initial blocks of the CVI modules, the flag on the corresponding port, and any hierarchical ports at higher levels, will be set to \u201cfalse\u201d. The C model then uses the flag settings to determine which connections are to be left active. A C model with all CVI_mode flags on its ports set to \u201ctrue\u201d is deactivated because the functionality of that model portion is to be simulated in Verilog. A C model with all of the Port_CVI_mode flags set to \u201cfalse\u201d is assumed to be active, either because a CVI module is present or because the stand-alone C simulation was started. If some of the Port_CVI_mode flags are set to \u201ctrue\u201d and some are set to \u201cfalse\u201d on a primitive CVI instance, an error is reported indicating that the CVI module has not handled all the ports of the corresponding C model.","At the end of the Verilog initialization sequence, a C model invocation phase occurs, as indicated by block . During this phase, a routine is called to determine which C models are active and, if so, which of its ports that correspond to CVI module ports are active. This is needed to optimize simulation performance by eliminating node connections and VPI callback events that are not needed. The routine determines whether C model ports that are associated with CVI ports are active by checking the readers and writers of each node in the C model. Any node that has reader or writer ports with the Port_CVI_mode flag set to \u201ctrue\u201d gets flagged as Node_CVI_mode \u201ctrue.\u201d CVI module ports connected to nodes in the C model that have their Node_CVI_mode flags set to \u201ctrue\u201d are enabled by the routine. Enablement of a CVI mode node can be thought of as allowing the values of data modeled in C nodes to be read from or written to the corresponding Verilog signals. For special case situations, a node can be forced to be active by preceding the port name with \u2018F:\u2019 in the CVI system task first argument. This preferably is used only when it is desired to force a node's data to be copied to Verilog, even if the node connects only between two CVI modules.","The aforementioned $gps_get_fm_c( ),$gps_put_to_c( ), and $gps_push_to_c( ) CVI system tasks are also responsible for setting up callbacks that are activated when a user-specified Verilog event occurs, such as a clock edge or value change. For a given trigger event, a list of callback actions to be performed is created in the CVI module. The order in which the actions are performed is determined by the order in which the calls appear in the CVI module. For each call, a list of previously defined callback events is searched, and, if found, a callback action is added to the list for that event. If a callback event is not found on the list, a new callback action list is created. Each callback action includes information about the corresponding C model port and the Verilog signals associated with it.","The CVI modules  preferably ensure that the data in the Verilog registers is formatted consistently, independent of machine architecture and compiler. To accomplish this, CVI code performs checks to determine if a node has an associated \u201cencode\/decode\u201d function pointer that is set. If it does, then this function is used to reorder the bytes returned from or written to the C model into a standard, machine-independent order. A default \u201cencode\/decode\u201d function that handles integer data preferably is provided in the thread library. For other data types, the author of the C model preferably set a model-specific \u201cencode\/decode\u201d function for all nodes that may connect to CVI modules of the Verilog model.","It can therefore be seen from the discussion of  that the CVI modules  are responsible for \u201cself-configuring\u201d the connections between threads when invoking in a mixed C and Verilog simulation. Thus, duplication, or redundancy, is avoided when specifying if models are to use Verilog or C. The CVI modules  corresponding to any blocks that are to be modeled in C are simply loaded into the Verilog simulator, and the CVI modules  then automatically activate the appropriate connections. Therefore, no C model language specific arguments are needed to control model mode.","The read and write operations on nodes that are in CVI mode differ from those of nodes that are in C-only mode. An example node structure for a CVI mode node is shown below in Table 1.",{"@attributes":{"id":"p-0061","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CVI mode node structure"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"13"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"10","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"11","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"12","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"13","colwidth":"21pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["C2V","Src","Dest","Data","WP","RP","RP","RP","RP","RP","RP","RP","RP"]},{"entry":["subnode","ID","ID",{},{},"T1","T2","T3","T4","T5","C1","C2","Lag"]},{"entry":["V2C","Data","WP","RP","RP","RP"]},{"entry":["subnode","C1",{},"T1","T2","Lag"]},{"entry":["V2C","Data","WP","RP","RP","RP","RP"]},{"entry":["subnode","C2",{},"T3","T4","T5","Lag"]},{"entry":{"@attributes":{"namest":"1","nameend":"13","align":"center","rowsep":"1"}}}]}}]}}},"When a node is in CVI_mode, its depth is reduced to 2 if it was greater than 2. The SrcID and DestID values shown in the table are used to insure that data is addressed so that the CVI routines communicate only with their corresponding threads. The DestID value is also used to inform the CVI module that a write of NULL data occurred. A NULL data write by the C model results in the status register being set low, and the Verilog signal being set to high-Z. The source and destination checking makes it possible for the CVI modules of the Verilog model to support bi-directional connections, with multiple readers and writers. A bi-directional example is discussed below with reference to .","An optional status register value can also be used as the tri-state control signal in the CVI modules of the Verilog model. Blank boxes in Table 1 represent data storage locations. When a node is converted to CVI mode, it has a V2C (Verilog-to-C) subnode created for each CVI writer of the node. Each CVI instance that reads the node is registered in a C2V (C-to-Verilog) subnode read pointer list. In the C2V and V2C sections of the node, a lagging read pointer indicates the oldest unread data slot. Each thread that reads the node is registered in the C2V subnode, and in the V2C subnode for the CVI instance to which the thread corresponds.","CVI read or write operations pass in an inst ID value as an argument. The inst ID value is used to find the correct read pointer in the C2V subnode for a read, and the correct V2C subnode to which to write. The CVI read calls always read from the C2V portion of the node. The CVI write calls always write to the V2C portion of the node. The V2C subnode always has a depth of 1. The V2C data value holds the last data sampled from Verilog. A read pointer for each C model corresponding to a CVI instance is allocated in the V2C subnode. This read pointer indicates whether the corresponding C model has read the data in the V2C subnode.","When a C model portion writes a CVI mode node, it sets the C2V write pointer (WP). When a C model thread reads a CVI mode node, it advances its corresponding read pointer (RP) in the V2C subnode. If the C2V read pointer indicates unread data for that thread, then the C2V read pointer is also advanced. The C2V pointer may be empty in the case where the data in the V2C subnode came from a Verilog model driving the net associated with this node.","As stated above, the Verilog signal arguments may be wire or register type Verilog objects. Any arbitrary set of signals can be combined by declaring a wire object with an assign expression containing a concatenation of signals. The resulting list of bits in CVI Data_sig or Data_reg arguments to the GET and PUT tasks must correctly map to the fixed byte order defined by the encode\/decode function of the C model port's associated node. It is up to the CVI module author to correctly map the generic signals associated with the GET and PUT tasks to the specific signals and protocol of the Verilog model portion that is being modeled. A CVI module may use as many GET and PUT calls as needed. All of the callback actions are grouped by trigger event, and the actions for a given trigger event are executed in the order in which the system tasks appear in the CVI module's initial block. Actions that are blocked at a given trigger event may prevent other actions for the same trigger event in the CVI module from completing. The CVI system tasks are as follows:\n\n","A bi-directional port is modeled by using both the $gps_get_fm_c( ) calls and $gps_put_to_c( ) calls with the same Port_handle. This works because all port connections to the C model node are really bidirectional. A read from a port obtains the oldest value from the FIFO of the connected node, and a write adds a new youngest entry to the FIFO of the node. By using the signals from both system calls, in combination with a tri-state assign statement in the CVI module, a wide variety of bi-directional signal protocols can be modeled. An example of a system with bi-directional signals is provided below in detail with reference to .","The $gps_push_to_c( ) system function is used to model asynchronous signals. Whenever Data_sig changes, the new value is written in \u201cWrite Over\u201d mode to the node associated with Port_handle. The $gps_pull_fm_c( ) system function is also used to model asynchronous signals. Whenever a new value is written to the node associated with Port_handle, the Data_reg value is updated.","A delay feature is used to control the timing of power-on reset nodes. If Delay_spec is defined, then a second reader is defined, and this read occurs after the specified delay. If Delay_reg is specified, then it is set to the value read using the Delay_spec in a TransportDelay mode. In any of the CVI system task calls, an \u201cF:\u201d can be included at the beginning of the Port_handle string to force a specified port to be active, even if the port is only connected to other CVI ports. This call has the effect of setting the port's associated node to be in CVI mode.","When building a CVI module of the Verilog model, inclusion of system task calls in procedural blocks is not necessary. Preferably, all actions to be taken during the simulation are setup as callbacks by the CVI system tasks in the initial block. One of the main reasons for designing a CVI module in this way is to provide compatibility with cycle-based simulation. However, procedural blocks can be used in CVI modules if needed, provided they are cycle based simulation compatible. Generally, this means that they must follow the synthesis subset, and they cannot call any system tasks, or rely on Verilog #delay values.","In order to illustrate how the CVI modules may be used in accordance with the present invention, a unidirectional example will now be provided with reference to  in order to provide an understanding of the flow of data between the CVI modules and the Verilog and C model portions. The example shown in  demonstrates several different types of unidirectional FIFO interfaces. Since the model  corresponding to thread  is a Verilog model, thread  and its associated connections  and  to node  and node  labeled with numerals  and , respectively, are shown with dashed lines to indicate that they are disabled. The trigger event in this system is @(posedge Clk_i), or in other words, the positive edge of clock signal Clk_i, which is labeled with numeral . By using Verilog modeling code in the CVI module to connect external control signals to the GET and PUT system tasks, a wide variety of inter-module signaling protocols can be supported.","The Verilog code for the CVI module  in this example could look as follows:",{"@attributes":{"id":"p-0073","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Module block1 (Clk_i, Dout, Din, Empty, Read, Write, Full);"},{"entry":"input Clk_i, Empty, Full;"},{"entry":"output Write, Read;"},{"entry":"input [3:0] Din;"},{"entry":"output [3:0] Dout;"},{"entry":"reg [7:0] data_reg;"},{"entry":"reg valid_reg, st_reg;"},{"entry":"wire NotEmpty = ~Empty;"},{"entry":"wire Notfull = ~Full;"},{"entry":"assign Dout = {data_reg[7],data_reg[5:4],data_reg[0]};"},{"entry":"assign Write = (valid_reg & ! Full);"},{"entry":"assign Read = (st_reg & ! Empty);"},{"entry":"wire [5:0] put_din = {Din[3],1\u2032b0,Din[2:1],3'b0,Din[0]};"},{"entry":"initial begin"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$gps_put_to_c(\u201cDin\u201d, NotEmpty, \u201c@(posedge Clk_i)\u201d, 0,"]},{"entry":[{},"put_din, st_reg);"]},{"entry":[{},"$gps_get_fm_c(\u201cDout\u201d, NotFull, \u201c@(posedge Clk_i)\u201d, 0,"]},{"entry":[{},"data_reg, valid_reg);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"end"},{"entry":"endmodule"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":["41","42","43","44"]},"The use of a concatenation in the above assign statement should be noted. This associates the bits of the output port Dout of the CVI module , which corresponds to arrow , to specific bits of data_reg . This is also where the CVI module author associates the bits written into data_reg  to the actual Verilog signals to which they correspond. Similarly, the data_sig argument  of the PUT system task (put_din) uses a concatenation to encode the incoming Verilog signals  into specific bits. The bit order in data_reg  and of data_sig  does not need to change with machine architecture because of the use of the aforementioned encode and decode functions.","The arrows , , , , , and  shown in  connecting to nodes , , , and  represent calls to read or write a port that is connected to the corresponding node. As in , in this example, the variables represented by blocks shown in bold in the CVI modules correspond to Verilog registers. The C model portions of the mixed-language model to be simulated are represented by the nodes , , , and  and by threads , , and . In the case of a stand-alone C model simulation, the CVI modules  and  and the Verilog model  would not be needed. However, for mixed-language simulation, CVI modules are instantiated for the portions of the mixed-language model that are to be simulated in C, and Verilog model portions are instantiated for the blocks that are to be simulated in Verilog.","As discussed above with reference to , during initialization, the GET and PUT tasks of the CVI modules  and  set flags on the nodes and the ports of the corresponding threads that the simulator uses during initialization to determine which connections need to be activated. The Verilog model  does not have any GET or PUT task calls, so the CVI_mode flags corresponding to ports associated with the second thread  are not modified from their initial value. This results in disablement of the second thread , and the lines  and  associated with the Verilog model  are dashed to indicate this. The C model has readers and writers that can be registered for the GET and PUT tasks that are in the CVI modules. If those readers and writers are not registered, the C model is able to determine that there is no data flowing from the Verilog model  into the second node  or out of the third node  associated with the second thread . Therefore, the simulator is able to determine that the second thread  does not ever need to be invoked as an executing thread.","Therefore, instead of the second thread  reading data out of the second node , the trigger action clock signal  causes the GET action of CVI module  to be activated, which causes the data to be read out of the second node  and stored in register  as a Verilog data signal. Each time the clock signal  occurs, the input model Verilog block  drives an empty signal  out and a data signal  out in the Verilog portion of the simulation. As the clock signal occurs, the enable signal  of the PUT call is set so that the PUT call knows that it is supposed to sample data on some particular clock edge when the input model  determined there was data. Thus, when the empty signal  goes low, the enable signal  goes high, thereby causing the PUT call to sample the data signal  coming in from the input model  into the CVI module  when the value in the status register  of the PUT call is high. This causes the PUT call to write the data signal  via an encode function into the first node .","Then, in the evaluation phase, a deferred action handler will schedule the first thread  to have some time to execute and then thread  will read out of the first node  the data that got written to it by the PUT call. The thread  will then process this data and write the results of this processing into the second node . Meanwhile, the GET call of CVI module  was triggered on the same clock edge that triggered the PUT call. Therefore, the GET call will continue attempting to read data out of the second node  until data is present in the second node , or until an iteration limit condition occurs indicating that the C model is stable. The data read out of node  is written into the data register  associated with the GET call, and then is driven out of the CVI module  as a Verilog signal  on the next clock signal.","The value of the status register  of CVI module  becomes \u201ctrue\u201d if the GET call successfully obtained data from the second node , which causes the write signal  to go high. On the next clock cycle, the Verilog model  will sample the write signal  and determine that it is high, and will therefore sample the data  from the data register  coming into the Verilog model . The Verilog model  will process the new data and, some number of clock cycles later, will set its write signal . Verilog model  will maintain the data value as long as the full signal  of CVI module  is high. Then, on some later clock cycle, the CVI module  will set the full signal  low. This occurs as the third thread  reads data from the node , thus freeing up a slot in which to write data into the third node . On a cycle when the node full flag has been set low (signal ), and the write enable input signal  is high, the PUT task in CVI module  will sample the data  coming out of the Verilog model . The CVI module  PUT task will then write the data to the third node  of the third thread  and the process will continue in the manner described above with reference to the CVI module .","The example shown in  illustrates the manner in which the CVI system tasks are used to model a multipoint, bidirectional bus . The bus protocol is assumed to include, in the data bits of the bus , information that determines which of the CVI modules , , , or  will be allowed to write on the next cycle. For simplicity, no Verilog model portions are shown in , although they are presumed to exist. Also, all of the CVI modules that are not writing data are assumed to be reading data, and determining whether the data is to be used by them. The focus of this example is to illustrate how multiple readers and writers of a node are managed, rather than a specific bus protocol or addressing mechanism.","Each of the CVI modules \u2013 has a corresponding thread associated with it. The first, second, third and fourth threads are labeled with the numerals , , , and , respectively. Node  represents the data on the bus . Each of the threads has a bidirectional arrow connecting its port to the node . This is meant to indicate that each thread can read and write the ports associated with the node . Whenever a thread writes to a bidirectional node, the following procedures are preferably followed:\n\n","The source and destination thread ID stored with the data in the CVI mode node, and the CVI subnode structure are particularly important for the bidirectional case represented by . It should be noted that multiple CVI modules with the same trigger event might be connected to the same node. This means that each of the CVI modules with the valid signal high will sample the data and write it to the node . Therefore, multiple copies of the same data for the same trigger event appear in the V2C subnodes of the node . Without the association of threads , , , and  to specific V2C subnodes, the C models would process that same data multiple times, and get out of sequence.","Data written by a thread is addressed to only the corresponding CVI module, and data written by a CVI module is addressed to only its corresponding thread. Also, in cycles in which the C model is stable, but no data was written by the corresponding threads of the CVI modules, the corresponding status registers  associated with the GET calls of the CVI modules to be set low. The status registers  can therefore be used as tri-state enable signals in the CVI modules. The instance with the status register  set high causes the bus  to be driven for that clock cycle, and the other CVI modules (i.e., those with the status registers set low) will have their output drive enable signals  set low. The Verilog code for the CVI modules of the bi-directional block in this example might look as follows:",{"@attributes":{"id":"p-0084","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Module io_block (Clk_i, Data, Write, Full);"},{"entry":"input Clk_i;"},{"entry":"Data [7:0] Data;"},{"entry":"inout Write, Full;"},{"entry":"req [7:0] data_reg;"},{"entry":"req valid_reg, st_reg, empty_reg, full_reg;"},{"entry":"wire (strong1, pull0) Write, Full;"},{"entry":"assign Data = valid_reg ? data_reg : 8\u2032bz;"},{"entry":"assign Write = (valid_reg & ! Full);"},{"entry":"wire NotFull = (st_reg & ! valid_reg);"},{"entry":"wire data_put_en = (!valid_reg & Write);"},{"entry":"initial begin"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$gps_put_to_c(\u201cData\u201d, data_put_en, \u201c@(posedge Clk_i)\u201d,"]},{"entry":[{},"full_reg, Data, st_reg);"]},{"entry":[{},"$gps_get_fm_c(\u201cData\u201d, NotFull, \u201c@(posedge Clk_i)\u201d, empty_reg,"]},{"entry":[{},"data_reg, valid_reg);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"end"},{"entry":"endmodule"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The nets shown as dotted lines represent a wired OR operation. Any CVI module that drives high the Write net  or the Full net , results in the net value being high. The net value is low only if none of the CVI modules are driving high. This can be accomplished in Verilog by using a wire for the Full and Write ports that drives strong 1 and resistive 0. In this case, the Full and Write ports must also be declared as I\/O ports. The meaning of the Write signal  is that there is valid data on the bus  that should be written. If none of the CVI modules have valid data, then the bus  goes to high-Z and the Write signal will be low. The Full signal  goes high when any CVI module, other than the current writer, becomes full. This signal also forces the Write signal  low, and informs the writing CVI module that the next data written will not be received. The writing CVI module therefore knows not to attempt to write a new value on the next cycle.","The event processing algorithm of the present invention in accordance with the preferred embodiment will now be described with reference to .  is a flow chart illustrating the CVI event processing algorithm of the present invention in accordance with the preferred embodiment. When a trigger event (block ) that is listed in GET, PUT, or PUSH calls occurs, an \u201cAction Callback\u201d function (block ) is called, which obtains a list of edge events that are to be processed for that trigger event (block ). The list of edge events obtained by the \u201cAction Callback\u201d function (block ) is specific to a particular CVI instance, and is structured in the manner shown in  and discussed below in detail. The \u201cAction Callback\u201d function (block ) checks the value of the trigger signal as retrieved from the HDL simulator, and compares it with the value expected for each event type (block  of ).","If the data value of the trigger signal matches the value of the edge type expected for that event, the \u201cAction Callback\u201d function (block ) checks the enable signal and the current full or empty register value specified in the system function calls. This step of checking the enable signal and the current full or empty register value specified in the system function calls is represented by decision block . If the enable signal is HIGH, and the previous event full or empty register is low, then the action is considered enabled and is added to the \u201cenabled deferred action list\u201d for the trigger event that occurred, as indicated by block . If the enable signal is LOW, or the previous event full or empty register is high, then the action is NOT enabled, and it is added to the \u201ccompleted deferred action list\u201d , as indicated by the arrow from decision block  to circle  on the right-hand side of the figure and by the arrow from the connection circle  on the left-hand side of the document to the completed deferred action list . The circles  having the letter \u201cA\u201d within them correspond to the same node in the flow chart of .","For enabled PUT or PUSH actions, the current data signal value is sampled and stored, as indicated by block . It is important that data sampling be done immediately when the trigger signals occur, because other models may have changed the value of the signal by the time the deferred action handler is called, and simulation results would then be invalid. The order of the events in the enabled deferred action list (block ) is maintained so that the evaluation order matches the order in which the events are coded in the CVI module. The enabled deferred action list (block ) contains all the deferred actions for all CVI modules that have occurred at a given simulation time. In essence, each CVI instance is listed, and each listed CVI instance, in turn, comprises a list of associated deferred actions that are to be processed.","After the aforementioned action processing function (block ) places an action on the deferred action list (block  and ), it then determines whether or not the deferred action callback handler has been scheduled (decision block ). If the deferred action callback handler has not been scheduled, the deferred action callback handler is scheduled to occur at the end of the events within the current time, as indicated by block . Execution then returns to the Verilog simulator code, as indicated by block . The deferred action callback handler performs a \u201cdeferred action callback\u201d function, which is represented by the entry point  and by blocks , , and . The deferred action callback function is executed at the end of processing events for the current time, but before closing the current times' ability to write new data values. In the VPI, this callback reason is called \u201ccbReadWriteSync\u201d. The deferred action handler iterates until all of the enabled actions have been completed, the C model is stable, or the iteration limit is exceeded. These iterations are represented by the blocks , , , ,  and . The functions performed by these blocks can be characterized as follows:","For each CVI instance and each trigger event with enabled deferred actions, process actions () at the top of each execution branch on the enabled deferred action list () until an action cannot be completed, then go to the next execution branch; when all execution branches for a given trigger event have been tried, go on to the next trigger event; when all trigger events in an instance have been processed, go on to the next instance; as each action is completed, a success flag is set (Action Completion Status of Object  in ), and the action is moved to the completed deferred action list (); at the end of the list of CVI instances, suspend execution of the Verilog thread (which also executes the C-to-Verilog Interface functions) and allow the C model threads to run (); after the C models have run, process any PULL actions () that were scheduled due to the C model writing new values into a \u201cDeferred Pull action list\u201d (); check for C model stability () and then start the next iteration if it is determined () that there are more enabled deferred actions to be processed.","In accordance with this example embodiment, the C model is deemed to be stable if no threads have read or written data to any port after two cycles through all of the threads have occurred. If the iteration limit is exceeded before the enabled deferred action list is empty, preferably the remaining actions are aborted, register values are set to unknown, and a warning is issued (not shown). If the C model became stable, then remaining PUT and PUSH actions are handled in the same manner as when the iteration limit has been exceeded. However, GET actions for which the C model supplied no new data are not considered to be an error, but are considered complete with a status of false. This is because there may simply be no more data available at the time. The CVI module will use the status flag in this case to generate an HDL language signal to indicate whether the data is valid.","After the iteration loop (blocks , , , , , ) exits, the status, empty, and full registers for actions on the completed deferred action list are set during a process represented by block . The status register is set using the completion status flag, and the empty or full registers are set by checking the final state of the associated node. Execution then returns to Verilog, as indicated by block .","In , each of the objects in the CVI module data structure, in accordance with the preferred embodiment, are shown. Entries that are pointers to other objects are shown with the referenced object type in Bold followed by \u2018->\u2019. Fields shown with values separated by \u2018\/\u2019 are enumerations of specific choices which specify the record type. For example the \u201cEvent\u201d object  can be a \u2018pos\u2019, \u2018neg\u2019, or \u2018any\u2019 edge event, or a \u2018begin\u2019, \u2018end\u2019, \u2018fork\u2019 or \u2018join\u2019 blocking statement. Fields containing the \u2018|\u2019 character, as in the \u201cEvent\u201d object , indicate that the object operates in distinct modes which may affect how other fields are used. The objects' primary relationships are shown with arrows . The object relations shown with solid-line arrows  indicate that the CVI module data structure relation is built once during the initialization phase of simulation (blocks  and  of ). The building of the objects and relations represented by these blocks (, , , , ) corresponds to the static portions of the CVI module data structure objects. The object relationships shown with dashed-line arrows  indicate object relationships (blocks  to ,  to  and ) that are dynamically changing as the simulation runs.","The static portion of the CVI module data structure is built up as the simulator is processing the initial blocks in the Verilog CVI modules (block  in ). As the CVI system tasks are called, the corresponding task finds the Verilog model and scope from which it was called, and inserts an Action object  that saves the argument information from the task. The Action object  includes an Action list that includes the port name and associated node pointer enable, status, and data argument handles, as well as the action type. The Trigger object  includes a Trigger list that holds names and handles for trigger signals appearing in the GET, PUT or PUSH calls of the instance, as well as a list of edge and block statement type Event objects  associated with the trigger signals. For the PUSH action, the trigger event is a value change of the signal itself. Each Event object  has a pointer to a GET or PUT action object  that should be processed when the event occurs. The Action list and the Trigger List are static during the simulation, but the enabled deferred action Trigger list and the completed deferred action list contained in the Deferred Action List object  change as events are scheduled and processed during the simulation.","In order to improve performance, in accordance with the preferred embodiment of the present invention, the trigger event argument of the task is separated out into the Trigger object  and the Event object . This separation allows task calls within the same model that have the same trigger signal to share the same Trigger object, and thus only one callback is needed for each trigger signal in the model. The entry point for the static model database is a global variable, represented by block , references the first CVI Module object  on the list. The Deferred Action List object  is the entry point for the dynamically changing portion of the action database. As trigger events occur, Deferred Action objects  are moved from a free list (referenced from the \u201cFirst Free Deferred Action\u201d field of object ), and are placed on either the enabled or completed deferred action lists contained in the Deferred Action List object . The type field in the Event object  can be set to a begin\/end\/fork\/join blocking statement. These types correspond to Verilog grouping statements. These grouping Event objects act as templates to define the sequence order for the processing of events on the Deferred Action List object . The grouping Event object  results in a corresponding grouping statement in the Deferred Action object  when the event list for Trigger object  is processed.","The deferred action list entries are added to the Deferred Action List object  as action events occur, and are removed as they are completed by iterations of the C model, as described above with reference to . An instance in the CVI Module object  may contain multiple CVI scope objects . The first scope always corresponds to the CVI module. Other scopes are created when named Verilog begin-end or fork-join blocks are defined. It is the scope path from which a CVI task is called that is matched against the C model instance path during the intialization phase described in . Verilog named begin-end blocks can therefore be used to define additional hierarchy levels in order to create a correspondence with the C model.","The code module shown below is a contrived example of a CVI module with multiple trigger signals and two independent data paths. The purpose of this example",{"@attributes":{"id":"p-0098","num":"0116"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Module dual_clk_block (ClkA_i, ClkB_i, DataA_i, DataB_i,"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"DataA_o, DataB_o, En_A, En_B, Valid_A, Valid_B);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"input ClkA_i, ClkB_i;"},{"entry":"input [7:0] DataA_i, DataB_i;"},{"entry":"output [7:0] DataA_o, DataB_o;"},{"entry":"output Valid_A, Valid_B;"},{"entry":"reg [7:0] DataA_o, DataB_o;"},{"entry":"reg st_A, st_B, Valid_A, Valid_B;"},{"entry":"initial begin"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"$gps_put_to_c(\u201cDataA_i\u201d, En_A, \u201c@(posedge ClkA_i)\u201d,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"0, DataA_i, st_A);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"$gps_get_fm_c(\u201cDataA_o\u201d, 1,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u201c@(posedge ClkA_i or negedge ClkB_i)\u201d,"]},{"entry":[{},"0, DataA_o, Valid_A);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"$gps_put_to_c(\u201cDataB_i\u201d, En_B, \u201d@(posedge ClkB_i)\u201d,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"0, DataB_i, st_B);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"$gps_get_fm_c(\u201cDataB_o\u201d, 1, \u201c@(ClkB_i)\u201d,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"0, DataB_o, Valid_B);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"end"},{"entry":"endmodule"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{},"figref":"FIG. 7"},"The example Verilog module above is represented in  starting with CVI Module object , and the CVI Scope object , which in this case corresponds to the scope for the entire module. The GET and PUT calls for the above module get translated into the Action objects , ,  and  shown in . The trigger signals referenced in these calls are represented in  as the Trigger objects  and . The edge specification qualifiers on the GET and PUT call trigger expressions are represented as the Event objects , , , , and . The order of events in the list is derived from the order in which the GET and PUT calls appear in the CVI module. It should be noted that the list contains a trigger object (blocks  and ) for each unique trigger signal (ClkA_I and ClkB_I) that is used in the module. Also, it should be noted that the same action can be activated by more than one event, and possibly from different trigger signals, as is the case shown for Action object , which is referrenced from Event objects  and .","For the example action database shown in , when a positive edge of trigger signal ClkA_i occurs, for example, then the Deferred Action list entries shown in  will be generated. The Deferred Action List object  represents the global list containing all deferred actions needing to be processed at the current time. The CVI Model object  and Trigger object  corresponds to the CVI Model object  and Trigger object  in . The Event object  results in the generation of Deferred Action object , and Event object  results in the generation of Deferred Action object . When the Deferrered Action Handler procedure (, block ) is called, it will process Deferred Action object  first, and Deferred Action object  next. As the actions are completed, they are moved to the completed action list of the CVI Model object . This list is stored on the \u201cFirst Completed Deferred Action\u201d field shown in the CVI Module object  in .","Therefore, it can be seen from the embodiments described above that the present invention minimizes the number of context switches required in order to process trigger events. By deferring actions to be processed for trigger events, rather than processing them directly and immediately as trigger events occur, actions are processed efficiently in the HDL model domain and in the source model domain, thereby minimizing the number of context switches between the HDL model domain and the source code model domain and reducing processing overhead. Consequently, the mixed-language simulation is optimized.","It should be noted that the present invention has been described with respect to one particular implementation, which corresponds to the preferred embodiment of the present invention. However, as will be understood by those skilled in the art that, in view of the description provided herein, the present invention can be implemented in a number of ways to achieve the goals of the present invention, i.e., utilizing mixed-language models in a simulator to test and model hardware designs. Therefore, those skilled in the art will understand that modifications can be made to the implementation discussed above, and that all such modifications are within the scope of the present invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 8","FIG. 7"]}]},"DETDESC":[{},{}]}
