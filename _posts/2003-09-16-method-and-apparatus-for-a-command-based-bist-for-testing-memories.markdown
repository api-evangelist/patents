---
title: Method and apparatus for a command based bist for testing memories
abstract: Methods and apparatuses in which two or more memories share a processor for Built In Self Test algorithms and features are described. The processor initiates a Built In Self Test for the memories. Each memory has an intelligence wrapper bounding that memory. Each intelligence wrapper contains control logic to decode a command from the processor. Each intelligence wrapper contains logic to execute a set of test vectors on a bounded memory. The processor sends a command based self-test to each intelligence wrapper at a first clock speed and the control logic executes the operations associated with that command at a second clock speed asynchronous with the first speed. The processor loads the command containing representations of a march element and data to one or more of the intelligence wrappers via a serial bus.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07290186&OS=07290186&RS=07290186
owner: Virage Logic Corporation
number: 07290186
owner_city: Fremont
owner_country: US
publication_date: 20030916
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["NOTICE OF COPYRIGHT","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DISCUSSION"],"p":["A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the software engine and its modules, as it appears in the Patent and Trademark Office Patent file or records, but otherwise reserves all copyright rights whatsoever.","Embodiments of the invention generally relate to self testing of memories. More particularly, an aspect of an embodiment of the invention relates to self testing of memories embedded on a chip.","A built-in self-test (BIST) system of memories typically consists of a processor and a number of memories to be tested to find defects. In general during the BIST, the processor applies a set of test vectors to the memory cores. The processor then receives and evaluates the response to the test vectors to determine whether a defect exists in one or more word lines being tested in the memory. The processor may compare the results from the memory output with the predicted values to determine whether a defect exists.",{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1","b":["1","2","3"]},"The information and routing paths pertaining to the self-test of one of the memories could be as follows. Several lines could carry test input data bits. Several lines could carry expected data bits back to the processor. Several lines in parallel to the data lines may carry the march algorithm steps. Several lines may carry the address information on which word line or word lines are to be tested. All of that information from the processor needs to be received by the memory in parallel so that the desired target memory can be vector tested to determine whether a defect exists or not in the memory cells in the memory.","The processor and memories clock cycle may be synchronized such that on each clock cycle the processor provides the necessary data and control information to test an operation on a single address or all of the addresses in a memory under test. An intelligence wrapper surrounds each memory. The processor sends all of the information needed to conduct a march sequence of built-in self-test in parallel on a particular word line to each intelligence wrapper.","This parallel architecture for sending BIST information works fine for a small number of memories that have a large byte capacity. Each memory takes up a large amount of routing paths, such as 25, from the processor. The accumulation of all of the BIST routing paths for all of the memories takes up a lot of space on a system on a chip. However, since there may be only a few large memories on a system of a chip, the cost benefit analysis is fine. However, in a system on a chip design that utilizes a large amount of small memories, such as register files, this many routing paths per memory may not be acceptable.","Another disadvantage of a parallel architecture from the processor to the memories may be that both operate in a synchronous timing cycle. The operations sent from the processor in the parallel lines occur at the clock speed of the memory. Each clock cycle, the processor sends all of the information in parallel needed to conduct a March sequence of the built-in self-test on the memory. Those operations then are executed on the memory at the speed of the memory. Those operations are also evaluated at the speed of the memory. Thus, the built-in self-test processor is generally built to run at the same clock speed as the memories during the built in self-testing. Building a built-in self-test processor that operates at a lower frequency than the memories may be significantly easier.","Methods and apparatuses in which two or more memories share a processor for Built In Self Test algorithms and features are described. The processor initiates a Built In Self Test for the memories. Each memory has an intelligence wrapper bounding that memory. Each intelligence wrapper contains control logic to decode a command from the processor. Each intelligence wrapper contains logic to execute a set of test vectors on a bounded memory. The processor sends a command based self-test to each intelligence wrapper at a first clock speed and the control logic executes the operations associated with that command at a second clock speed asynchronous with the first speed. The processor loads the command containing representations of a march element and data to one or more of the intelligence wrappers via a serial bus.","While the invention is subject to various modifications and alternative forms, specific embodiments thereof have been shown by way of example in the drawings and will herein be described in detail. The invention should be understood to not be limited to the particular forms disclosed, but on the contrary, the intention is to cover all modifications, equivalents, and alternatives falling within the spirit and scope of the invention.","In the following description, numerous specific details are set forth, such as examples of specific data signals, named components, connections, number of memories, etc., in order to provide a thorough understanding of the present invention. It will be apparent, however, to one of ordinary skill in the art that the present invention may be practiced without these specific details. In other instances, well known components or methods have not been described in detail but rather in a block diagram in order to avoid unnecessarily obscuring the present invention. Further, specific numeric references such as first clock speed, may be made. However, the specific numeric reference should not be interpreted as a literal sequential order but rather interpreted that the first clock speed is different than a second clock speed. Thus, the specific details set forth are merely exemplary. The specific details may be varied from and still be contemplated to be within the spirit and scope of the present invention.","In general, methods and apparatuses in which two or more memories share a processor for Built In Self Test algorithms and features are described. The processor initiates BIST for the memories. Each memory has an intelligence wrapper bounding that memory. Each intelligence wrapper contains control logic to decode a command from the processor. Each intelligence wrapper contains logic to execute a set of test vectors on a bounded memory. The processor sends a command based self-test to each intelligence wrapper at a first clock speed. The control logic in the intelligence wrapper executes the operations associated with that command at a second clock speed asynchronous with the first speed. The processor loads the command containing representations of one or more march elements, data, and other similar information to one or more of the intelligence wrappers via a serial bus. A march algorithm may be composed of a sequence of one or more march elements. In an embodiment, one march element exists per command.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2","b":["202","204","206","208","224","226","242","202","208","224","202","226","242","204","206","212","222","204","206"]},"All of the memories - may share the processor  for the built-in self-test features and algorithms. The intelligence wrapper for each memory contains control logic to decode the command from the processor. The intelligence wrapper for each memory contains control logic on how to execute a set of test vectors on the bounded target memory to detect defects in that memory. For example, the first intelligence wrapper  contains a first logic . The processor  loads the command containing representations of the march element, the input data, the expected data, and address information specifying where to apply data to addresses in the memory via the serial interface. The command contains representations of the march element(s), test data, etc. coded in a compressed format. The representations may be the same information but in a compressed format. The control logic expands the representations of the march element(s), the input data, the expected output data, and address information on where to apply data to addresses in the memory to its full-uncompressed form.","The processor may have a few lines routing between the processor  and each memory - and intelligence wrapper -. The routing paths may be the main serial bus  with a few parallel routing paths for additional control lines . For example, six routing paths for self test purposes may exist between the processor and each bounded memory to be tested. Since all of the data and instructions required to execute a march algorithm for a built-in self-test may load serially via one main serial bus, the number of required routing paths between the processor and each memory can be drastically reduced.","Further, since the processor  sends the information via a command serially, the command may be sent to the intelligence wrapper at a first clocking speed, such as 10-30 mega hertz. The control logic in the intelligence wrapper receives the command, decodes the command, and executes operations associated with that command at a second clocking speed such as 600 or 700 mega hertz. The first speed is asynchronous with the second speed meaning that the processes occur at different speeds.","The control logic may be implemented as a state machine configured to decode and execute the set of test vectors coming from the processor . The processor  sends the commands in a compressed form and the state machine expands the representations of information in the command to their full-uncompressed form. In some prior art, the processor would send all the vector test data in an expanded form across the parallel lines to test the memory.","In the command, a representation of input or expected data may be a cipher, such as a 1 and 0 or a 1 and an A, which can then be looked up in a data table to determine the uncompressed bits and operations that correspond to the compressed information. When the control logic decodes the data representation for that memory, then the data representation may expand out from the two bit cipher to be a sequence of 16 bits of 1's and 0's or 32 bits of 1's and 0's depending upon the width of the word line being tested. Thus, the command may contain input data representations on the data strings to be applied to the memory being tested. The command may also contain expected output data from the memories.","Similarly, the command may include a compressed form, such as ciphers, of march algorithm sequences, address information on the memories to be tested in a compressed form, etc., which can then be decompressed and expanded so that these operations may be carried out by logic within the intelligence wrapper.","March algorithms may be memory operations such as a read operation or a write operation. March algorithms may also indicate whether a single word line address is being tested or all of the word lines in the entire memory are being tested. March algorithms may also indicate whether the entire memory is tested with these read\/write operations from the highest address to the lowest address or the lowest address to the highest address. Thus, the command may have representations of the read\/write operations to be performed and the sequence of those operations to be performed on the memory. Further, the command may also include address information specifying which memories or word lines are to be tested. The command may also contain other similar information.","The processor  serially sends a command to one or more of the memories and the intelligence wrappers surrounding each memory. Logic in the intelligence wrapper may begin to decode each bit in the command as the logic receives each bit. Once the entire command has been received at the logic, then the processor may send an instruction to the intelligence wrapper to execute that command.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 3","b":["302","344","304","326","342","308","324","326","342"]},"The built-in self-test of the memory detects any defects in the memory core and may be conducted asynchronous to the operation of the processor. Redundancy allocation logic  contained in the processor  may have an algorithm to allocate the one or more redundant components in each memory, such as redundant columns and redundant rows, while fault testing each memory. The repair fuse box  stores the repair signature for each memory.","The intelligence wrapper that bounds each memory may contain logic configured specific to the particulars of that memory as well as logic that needs to be conducted at a high clock speed. For example, the size of each memory may be different, such as 512 kilobytes or 256 kilobytes, and each intelligence wrapper may contain its own address counter. Similarly, logic on how to execute the march algorithm on that particular memory may be in the intelligence wrapper. Logic that is common to all of the memories during a self-test may be stored in the shared processor such as logic to determine the type of march algorithm to apply to the memory under test, the shared March algorithm container, and other similar shared logic.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 4","b":["406","402","426","428","404","402","450","402","450","426","452","450","402","454","402","444","426","450","408","450"]},"The processor  may contain logic  on determining which algorithms to run for the built-in self-test such the read\/write sequences etc., the data vectors, address counting logic, etc. The address counter logic supplies and determines the address in the memory for the next set of tests. The processor  may contain logic  to compress information used in a self test of the memories embedded on the chip. The processor  may contain logic  to communicate the compressed information in a serial manner to logic bounding each of the memories.","Logic on how to execute the built-in self-test algorithms may be decoupled from the processor and placed into the intelligence wrapper. The state machine  in the intelligence wrapper  may be configured on how to carry out the execution of the BIST algorithms received from the processor  for that specific memory . As discussed, the intelligence wrapper  is located very close to the memory core  and bound around the memory core . Thus, the logic in the intelligence wrapper  may operate at a high speed, such as the clock speed of the memory , to perform the various BIST test on that memory. The logic in the intelligence wrapper may operate at a clock speed greater than the clock speed of the processor .","The processor , through the serial interface bus  loads the command containing the representations of the march algorithm, data, and address representations into the scan chain register  in a serial manner. If twenty bits exist in the command, then after twenty clock cycles the command will be fully loaded into the scan chain register . After the initial bit is loaded into the scan chain register , the logic within the intelligence wrapper  may begin decoding the loaded bits on every clock cycle. After all, for example, twenty bits, load, then the command will be fully loaded into the scan chain register . The processor  may direct the execution of that command by applying a command force signal through the command force routing path  to the state machine  in the intelligence wrapper . The logic in the intelligence wrapper  executes the command from the processor , thereby executing the next sequence of the march algorithm on the memory .","The intelligence wrapper may contain address generation logic , data generation logic , control generation logic , data comparison logic , as well as the command execution state machine , the command scan chain register , and other similar logic. The address generation logic  may generate the X and Y coordinates of the memory word line to be tested. The data generation logic  may expand the representation of the data input in the command to generate the sequence of data to be tested for that particular memory  and the number of bits needed to test a word length in that memory . For example, 16-bit word length, 32-bit word length etc. The data generation logic  may receive a representation of the input data such as the cipher A. Based off of that A representation from the command, the data generation logic  may then generate a sequence of 16 1 and 0's to word line being tested. If the cipher were, for example, a 1 and a B, the data generation logic  would then generate a different sequence of 1's and 0's for that 16-bit word line being tested. The control generation logic  controls the read\/write operations on the selected addresses in the memory  based upon the march algorithm contained within the command. The control generation logic  controls how those read and write operations are performed on the memory  and whether it is a specific memory word line being tested or all of the word lines in the memory  are being tested. The control generation logic  may also control the direction of sequences of operations on the memory . The control generation logic  may determine whether the memory  is being tested from the highest memory address to the lowest memory address, or from the lowest memory address to the highest memory address based upon the march algorithm contained within the command.","Data comparison logic  is configured to compare the actual vectors at an output of the bounded target memory  with the predicted vector results provided by the command. The data comparison logic  may be, for example, an Exclusive Or gate (XOR) series knowing and comparing what the referenced values should to be to what the actual output test data from the memory is.","Sequences of march algorithms may be carried out to perform an entire built-in self-test to detect all of the defects in a memory . A march algorithm in the command may instruct the control generation logic  to conduct a single operation, such as a read operation, or may instruct the control generation logic  to perform several operations back to back such as a read operation, then a write operation, followed by another write operation on a given word line all back to back. Then every word line tested will then perform that series of operations, a read, write, and a write on each word line in that memory . The intelligence wrapper  does not need to wait to receive another serially fed command to perform those three operations in rapid succession.","As discussed, the processor  may operate asynchronously from the clock of the memory  and thus be able to run at a lower frequency than the memory, which may be much easier to design. The commands from the processor may be executed by the logic in the intelligence wrapper  at the higher frequency memory speed and transferred serially from the processor  at the bus speed. Because the logic in the intelligence wrapper  may run at a higher speed than a prior parallel architecture coming across the bus, the BIST test run may take nearly the same time or even less time then some prior techniques.","The processor  may connect to greater amount of memories ,  using a command based BIST architecture because a fewer number of routing lines  need to exist between each memory and the processor. The BIST resources on a system on a chip take up less space then some prior techniques because a greater amount of memories may be connected per processor and fewer routing paths are needed.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIGS. 5","FIGS. 5"],"i":["a ","d ","a","c"],"b":["5","5","570","572","574","574","576","576"]},"Referring to , the element descriptor block  may be tied a number of actions to be performed on the memory. For example, the first action descriptor block  may list an initial operation to be performed on the memory such as a read operation, the second action descriptor block  may list the next operation to be performed on the memory such as a write operation. The Nth action descriptor block  may list the final back to back operation to be performed on the memory.","Each action descriptor block - may point to the data descriptor blocks ,  of information shown in . The data descriptor block  may provide the input data for that operation. The data descriptor block  may provide the expected output data for that operation based upon the input test vectors. Thus, an action description block may contain a field such as CD that contains the data pattern, which the logic uses during that particular read\/write operation. The entire BIST test may be composed of thousands of commands.","Alternatively, a structure of a command does not need to be a loose conglomeration of blocks of information related to each another. Referring to , the structure of the command may be a series of bits and the position of a bit within that string of sequential bits associates that bit with particular section of information. A command may be such that, for example, the initial N number of bits  in the command represent the addresses of the memory being tested and the direction of that march algorithm, the next N number of bits  represent the number and type of operations to be performed, the next N number of bits  represent in the command may correspond to the input data representation that will be used, the next sequential N number of bits  represent may be the expected data results, etc.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 6"},"In block , the designs for each processor and memory component for the embedded memory are supplied to the memory compiler, as well as other design parameters such as the number of columns and number of rows of the array, the available size on the chip and other parameters. Thus, the designs for one or more memories that share a processor for Built In Self Test may be supplied to the memory compiler. A memory compiler may be a software program comprised of multiple algorithms and designs for the purpose of generating a circuit design and a layout in a space available on a target chip. The set of application-specific algorithms and interfaces of the memory compiler may be used by system IC integrators to rapidly create hundreds of silicon-proven memory cores. The memory compiler receives the memory component designs and utilizes those memory component designs in conjunction with memory circuit designs to optimize a circuit design and layout in the space available on a target chip.","In block , the memory compiler generates a netlist and a layout targeted to fit in the space available on a target chip. The memory compiler stores the data representing the embedded memory typically on a machine-readable medium. The memory compiler selects the memory component building blocks so that they are sized appropriate for the targeted fabrication technology. The memory compiler then provides the memory layout to be used to generate one or more lithographic masks to be used in the fabrication of that embedded memory. The memory compiler also provides a netlist for verification of the embedded memory.","In block , the memory layout generated is integrated with the rest of the layout for the chip and a machine generates the lithographic masks that contain the information necessary for the fabrication of a functional device. The machine generates one or more lithographic masks to be used to transfer that circuit design onto the chip. The memory solution for embedded applications integrates easily with the standard single poly CMOS processes.","In block , a fabrication facility fabricates the chips with the embedded memories using the lithographic masks generated from the memory compiler's circuit design and layout. Fabrication facilities may use a standard CMOS logic process having minimum line widths such as 1.0 um, 0.50 um, 0.35 um, 0.25 um, 0.18 um, 0.13 um, 0.10 um, 90 nm, or less, to fabricate the chips. The size of the CMOS logic process employed typically defines the smallest minimum lithographic dimension that can be fabricated on the chip using the lithographic masks, which in turn determines minimum component size. In an embodiment, light is shown through these lithographic masks onto the chip to transfer the circuit design and layout for the embedded memory onto the chip itself. In an embodiment, the memory compiler is designed for embedded applications in the standard CMOS logic process.","In one embodiment, the software used to facilitate the memory compiler can be embodied onto a machine-readable medium. A machine-readable medium includes any mechanism that provides (e.g., stores and\/or transmits) information in a form readable by a machine (e.g., a computer). For example, a machine-readable medium includes read only memory (ROM); random access memory (RAM); magnetic disk storage media; optical storage media; flash memory devices; DVD's, electrical, optical, acoustical or other form of propagated signals (e.g., carrier waves, infrared signals, digital signals, EPROMs, EEPROMs, FLASH, magnetic or optical cards, or any type of media suitable for storing electronic instructions. Slower mediums could be cached to a faster, more practical, medium.","In an embodiment, an example memory compiler may comprise the following. A graphic user interface, a common set of processing elements, and a library of files containing design elements such as circuits, control logic, and cell arrays that define the complier. In an embodiment, object code in a set of executable software programs.","As noted, in an embodiment, a designer chooses the specifics of the memory configuration to produce a set of files defining the requested memory instances. A memory instance may include front end views and back end files. The front end views support documentation, simulation, debugging, and testing. The back end files, such as a layout, physical LEF, etc are for layout and fabrication.","The memory complier outputs may include Behavioral Models and Test Benches (Verilog, VHDL), \u2022Timing Models (TLF, .Lib and STAMP), Test Models (MemBIST, FastScan), Structural Netlists (EDIF, Spice), Power Models (WattWatcher, ALF), Floorplanning and Place&Route Models, Physical LEF, FRAM, Layout (GDS), Datasheets (including power, timing, and area specifications, as well as other outputs. When programming occurs or if a revision is needed, the designer merely has to redesign the block, a few metal and via masks.","Some portions of the detailed descriptions above are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.","It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussions, it is appreciated that throughout the description, discussions utilizing terms such as \u201cprocessing\u201d or \u201ccomputing\u201d or \u201ccalculating\u201d or \u201cdetermining\u201d or \u201cdisplaying\u201d or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers, or other such information storage, transmission or display devices."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The drawings refer to embodiments of the invention in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIGS. 5","i":["a ","d "],"b":"5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
