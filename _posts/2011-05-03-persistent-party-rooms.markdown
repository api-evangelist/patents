---
title: Persistent party rooms
abstract: Using persistent party rooms, including: initializing, via a computing device, a global array according to a hierarchical server architecture; determining, via the computing device, whether or not to create a new persistent party room or to join a previously bookmarked persistent party room; creating, via the computing device, the new persistent party room within a position indexed in the global array; and joining, via the computing device, the previously bookmarked persistent party room by searching for the previously bookmarked party room utilizing the global array.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09331858&OS=09331858&RS=09331858
owner: SONY COMPUTER ENTERTAINMENT INC.
number: 09331858
owner_city: Tokyo
owner_country: JP
publication_date: 20110503
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","The present application relates to online gaming environments, and more specifically, to party rooms or chat rooms used while playing games.","2. Background","Party rooms are online chat environments where gamers may voice chat, text chat, video chat, etc., while playing games or online games, during a game or during a break in a game. One of the problems with party rooms is that they are transitory and do not persist from session to session. Currently, party rooms must be recreated anew by the user whenever everyone leaves a room and when anyone wants to return to that party room or join a new one. This approach may be inefficient from an end-user point of view.","Implementations of the present application provide for persistent party rooms that are persistent and that can be bookmarked and returned.","In one implementation, provided is a method for using persistent party rooms, including: initializing, via a computing device, a global array according to a hierarchical server architecture; determining, via the computing device, whether or not to create a new persistent party room or to join a previously bookmarked persistent party room; creating, via the computing device, the new persistent party room within a position indexed in the global array; and joining, via the computing device, the previously bookmarked persistent party room by searching for the previously bookmarked party room utilizing the global array.","In another implementation, provided is a non-transitory computer-readable storage medium storing a computer program, the computer program including executable instructions that cause a computer to perform a method for using persistent party rooms, the method including: initializing a global array according to a hierarchical server architecture; determining whether or not to create a new persistent party room or to join a previously bookmarked persistent party room; creating the new persistent party room within a position indexed in the global array; and joining the previously bookmarked persistent party room by searching for the previously bookmarked party room utilizing the global array.","In yet another implementation, provided is a system of using persistent party rooms, including: at least one computer system including persistent party room software; at least one server storing persistent party room information to be interfaced with the persistent party room software; and a network connecting the at least one computer system and the at least one server.","Other features and advantages of the present application will become more readily apparent to those of ordinary skill in the art after reviewing the following detailed description and accompanying drawings.","Certain implementations as disclosed herein provide for persistent party rooms. After reading this description it will become apparent how to implement the present application in various alternative implementations and alternative applications. However, although various implementations of the present invention will be described herein, it is understood that these implementations are presented by way of example only, and not limitation. As such, this detailed description of various alternative implementations should not be construed to limit the scope or breadth of the present application.","In one implementation, a persistent party room is a pseudo-permanent party room that may appear to the user as a permanent party room but may be destroyed and then created when any user returns to the party room, which can be bookmarked. The party room is used to keep friends or online players together while they jump from game to game and still engage in voice chat, text chat, video chat, etc., even if they are playing different titles. With persistent party rooms, friends may bookmark or save a party room in order to easily join the same party room again at a later time.","A bookmarked persistent party room is a central place friends coordinate to go when they are in the mood to play games with one another. For instance, a bookmarked persistent party room could be named \u201cFPS\u201d for friends of a user who like to play First Person Shooters, or a room called \u201cRacing\u201d for friends who like to play racing games. A user can then join any of the persistent party rooms depending on which game the user wishes to play, the user's mood, or which persistent party room may have more or less people in it. The backend of software used to administer persistent party rooms stores an associated unique ID of the persistent party room. When a user wishes to join a persistent party room, the system searches to determine if a bookmark of the associated unique ID exists. If a bookmark does not exist, a new associated unique ID is created. This approach conserves resources by keeping these persistent party rooms always around. To the user, it appears as if the persistent party rooms always exist, but in reality they are destroyed when everyone leaves the persistent party room (saved and bookmarked by a pointer representing the associated unique ID) and then created again when the first user joins the bookmarked persistent party room, where the associated unique ID of the persistent party room is looked up by the system.","Currently, a party room implementation allows a user to create one party room which friends can then be invited to join or be allowed to join, usually via some search. When all the users have left the party room, it is destroyed. When a user then wishes to enter the party room, the party room is recreated by the user.","The persistent party room as disclosed by the present application solves this inefficiency problem by bookmarking or saving a persistent party room via an associated unique ID so that it can be quickly referenced or used at a later time. Users may be able to create different types of persistent party rooms centering around different types of activities with their friends. Additionally, if friends are having a good time in a persistent party room, they can choose to bookmark the persistent party room and coordinate their activity so that all or some of their friends join them in the same persistent party room the next time they are available to play. The scheduling of games is further made convenient by using a joined game acknowledgment feature in tandem with the persistent party rooms, so slots in games are reserved beforehand.","In one implementation, provided is persistent party room software that may be stored and executed by a computer system to create persistent party rooms where users can group together to play games, text chat, voice chat, video chat, etc. In one implementation, the computer system may be a next generation game console such as consoles from, for example, Sony Playstation\u00ae.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1","b":["100","100","102","104","106","108","110","112","114","100"]},"Current persistent party room toolbar  displays which persistent party room the user is currently in. The heart icon in  may be grayed out if the current persistent party room has not been bookmarked. If the user touches the grayed heart icon, the heart icon will turn red, and the current persistent party room will be bookmarked and the relevant bookmark data information (such as the associated unique ID of the room) may be saved to local storage. The bookmark information saved in local storage may be compared against the bookmark information for party rooms that are occupied by friends or other users.","Current member list  shows the users or friends who are currently in the present persistent party room. If the room occupied by a user matches a room that has previously been bookmarked, the heart icon in  turns to red next to the name of the room. Furthermore, touching a user listed in current member  would bring up a profile of that user in a user information box. In one implementation, a user information box would hover near a cursor if the cursor was positioned over a user's name. In another implementation, clicking a user's name would open up another page showing a user information box, or open up a smaller window showing the user information box.","Persistent party room list  provides a list of bookmarked rooms so that the user can decide to join them at anytime. The heart icons next to the room names also indicate whether or not a room has been bookmarked. If a bookmarked party room does not exist and the user wishes to create one, then the persistent party room will be created on the server with an associated unique ID.","User chat GUI window  allows a user to type in text, videos, links, or other information, to communicate with other users. User chat buttons  reflect various modes of communicating with other users (text, video, phone, etc.), and these modes of communication are not limited to the buttons shown. User information box  compiles information about the current user.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 2","FIG. 2"],"b":["200","202","202","204","204","206"]},"In one implementation, the room  is where the persistent party room is stored, and each persistent party room (of room ) exists in one world , which exists on one server . In one implementation, each server  has multiple worlds  in it and each world  has multiple rooms  in it. Each persistent party room (e.g., room ) may be created on a particular server  and world . Each room , world  and server  may have an associated unique ID (e.g., room ID, world ID, server ID). In one implementation, each room ID uses the world ID and the server ID in this unique ID. In another implementation, each world ID uses the server ID inside of its unique ID. In another implementation, each of the IDs can track data about information associated with its other IDs (e.g., each server ID can locate information about its associated world ID and room ID, each world ID can locate information about its associated server ID and room ID, and each room ID can locate information about its associated server ID and world ID).",{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 3","FIG. 3","FIG. 4"],"b":["300","300","302","304"]},"In decision box , a decision is made of whether to join a bookmarked persistent party room or to create a new persistent party room. If the answer to decision box  is to create a new persistent party room, then the next box is box , where a new persistent party room is created. If the answer to decision box  is to join a bookmarked persistent party room, then the next box is decision box , which may branch out into at least one of three different scenarios: route A and then box , route B and then box , or route C and then box .","Box , after route A, is the scenario where no bookmarked persistent party rooms are found and where no duplicate persistent party rooms are found, and is further explained below in conjunction with the description of . Box , after route B, is the scenario where no bookmarked persistent party rooms are found and where duplicate persistent party rooms are found, and is further explained below in conjunction with the description of . Box , after route C, is the scenario where bookmarked persistent party rooms are found, and is further explained below in conjunction with the description of .","After box  or boxes ,  or , the next box is decision box , which inquires as to whether or not the method  is done processing (i.e., whether or not any more persistent party rooms should be created or joined). If the answer to decision box  is no, then the method  goes back to box . In one implementation, the above boxes may be performed by a system implementing the persistent party room software or techniques discussed in the present application.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 4","FIG. 3","FIG. 3","FIG. 4","FIG. 3"],"b":["304","3040","302","3040","3041","3042","3043","3044","3045","3046","3046","306"]},"In one implementation, the above-described process may get a list of all server IDs, from each server ID get a list of all world IDs, create an array containing all the world IDs across all the servers, and sort the array for safety to assure it will be the same and in order across all clients.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 5","FIG. 3","FIG. 3","FIG. 5"],"b":["310","3100","306","3100","3101"]},"In one implementation, the bookmark UID is approximately 64 bytes of data. The bookmark UID may also be used to decide which world ID (from the array, e.g., GlobalWorldIDListArray) to create a persistent party room in. In box , the bookmark UID is used to decide in which world ID from the array to create a persistent party room by adding up the data contained in the bookmark UID, for example, in 16 bit chunks and storing it in another world list array (entitled, for example, WorldListChunk). In one implementation, the word list array may be another 16 bit (or 2 byte) value, and all the bytes in the bookmark UID structure are summed up and saved as a 16 bit value named, for example, WorldListChunk. The overflow that may occur during summing up is arbitrary, and the goal is to obtain some randomness by using all the bytes in the bookmark UID structure. Then, in box , a world ID is indexed or picked out of the GlobalWorldIDListArray by using, for example, the following formula: WorldListChunk % Count(GlobalWorldIDListArray)=GlobalWorldIDListArrayIndex, where GlobalWorldIDListArrayIndex represents an index into the GlobalWorldIDListArray and also contains the world ID in which to create the persistent party room, and where represents the modulo operator and also where Count is the length of the GlobalWorldIDListArray. Therefore, the bookmark UID is used to index into the GlobalWorldIDListArray. In box , GlobalWorldIDListArraylndex is used as an index into the GlobalWorldIDListArray, which will contain the world ID in which to create the persistent party room. Then, in box  the process finishes, and in one implementation the next box may be box  in .",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 6","FIG. 3","FIG. 3","FIG. 3","FIG. 6"],"b":["312","312","3120","308","3120","3121","3122"]},"In decision box , the branch question is asked whether any of the party rooms with the bookmark UID already exist.","If the answer to decision box  is no, then the next box is box , where a new persistent party room is created. In box , the new persistent party room created in box  is joined with the bookmark UID, and then the method goes back to box  to perform another search to determine how many persistent party rooms exist with the current bookmark UID. Then, boxes  and  may be repeated to finish in box . In one implementation, the answer to decision box  on the first pass may be a no.","However, if the answer to decision box  is yes, then the next box is box , which verifies if only one persistent party room exists (the current persistent party room) with the same bookmark UID as above. If only one persistent party room exists, then the method finishes in box , and in one implementation may go onto box  in . In one implementation, the answer to decision box  may be yes on the first pass which would imply more than one bookmarked room was found.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 7","FIG. 3","FIG. 3","FIG. 3","FIG. 7"],"b":["314","314","3140","308","3140","3141","3142"]},"In decision box , the branch question is asked whether any of the party rooms with the bookmark UID already exist.","If the answer to decision box  is no, then box  is executed, where the first persistent party room in the search results is joined, effectively destroying or replacing the current persistent party room with the joined persistent party room. Then, the method finishes in box  and may proceed onto box  in . In one implementation, the answer to decision box  on the first pass may be a no.","However, if the answer to decision box  is yes, then the method proceeds to decision box . In decision box  a determination is made whether the current persistent party room is the first one that comes up in the search results when more than one persistent party room exists with the same bookmark UID. If the answer to decision box  is yes, then the method finishes in box , which in one implementation may go onto box  in . In one implementation, the answer to decision box  may be yes on the first pass which would imply more than one bookmarked room was found.","Going back to decision box , if the answer to decision box  is no, then the method proceeds to box , where a new persistent party room is created. In box , the new persistent party room created in box  is joined with the bookmark UID, and then the method goes back to box  to perform another search to determine how many persistent party rooms exist with the current bookmark UID. Then, boxes ,  and  may be repeated to finish in box .",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 8","FIG. 3","FIG. 3","FIG. 3","FIG. 8","FIG. 3"],"b":["316","316","3160","308","3160","3161","3162","3163","3163","3163","3164","318"]},"In one implementation, a joined game acknowledgment feature may be integrated into the persistent party rooms. Essentially, a joined game acknowledgment is a feature that may be supported by certain games. The joined game acknowledgment feature allows a player playing a game to reserve a slot for another player, without having to take the player's attention off the current game being played. That is, the reservation and organization of the slots is done behind the scenes. For instance, player A is playing a game while player B is interested in joining the same game player A is playing. Instead of waiting for an open slot to become available and waiting around with an open game screen or instead of unnecessarily launching into the game only to found out that by the time Player B's game was loaded, Player A's game is now full, player B may use the joined game acknowledgment feature to reserve a slot in the game beforehand. Player B may also get a dialogue or dialogue box stating that Player A's game is full before even attempting to launch Player A's game. The game has the joined game acknowledgment feature, and works behind the scenes without having to get player A involved to reserve a spot beforehand for player B. Player B is then sent an acknowledgment that a given spot is reserved.","In one implementation, the joined game acknowledgment feature supports an NP basic system. In one implementation, NP Basic may be a system that allows for the sending\/receiving of game presence (online\/offline status of friends, for example), and also allows for the sending\/receiving of game presence in a joinable game or a non-joinable game (e.g., single player game). In a joinable game, the game presence may contain the details of the online game session that other friends can join into. The joined game acknowledgment feature may be used in tandem with persistent party rooms and all types of party rooms (including non-persistent party rooms) so that users waiting in a party room may instantly join active games or reserve spots in active games and not have to wait around for slots to open. Using the joined game acknowledgment feature, users in party rooms may also reserve game slots in each other's games as long as they are in the same party. The join game acknowledgment feature further provides a better user experience for the users in any party room since users can immediately know if other games played by party members are full or invalid (e.g., game sessions do not exist anymore). The load times for games can reach several minutes sometimes, so this can be irritating to the user if they must wait for a game to launch before they find out that another party member's game is full or invalid. The join game acknowledgment feature deftly avoids this problem by not having the user wait needlessly for something that may not materialize.","In one implementation, the application programming interface of the persistent party rooms may support NP-Basic systems or NP-Basic program calls. The application programming interface of the persistent party rooms may also be implemented with flags (which may be stored for each party member) that are used to communicate the joined game acknowledgment feature and also whether certain games support the joined game acknowledgment feature and\/or whether party members are playing a game that supports the joined game acknowledgment feature. What also may be supported is data describing whether party members in a persistent party room or any other type of party room are playing a given game and what session of the game is currently being played.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 9A","b":["900","902","902","900","900","990"]},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 9B","b":["900","990","910","900","910","920","910","990","910","900"]},"Memory  stores data temporarily for use by the other components of the computer system . In one implementation, memory  is implemented as RAM. In one implementation, memory  also includes long-term or permanent memory, such as flash memory and\/or ROM.","Storage  stores data temporarily or long term for use by other components of the computer system , such as for storing data used by the persistent party room software . In one implementation, storage  is a hard disk drive.","The media device  receives removable media and reads and\/or writes data to the inserted media. In one implementation, for example, the media device  is an optical disc drive.","The user interface  includes components for accepting user input from the user of the computer system  and presenting information to the user. In one implementation, the user interface  includes a keyboard, a mouse, audio speakers, and a display. The controller  uses input from the user to adjust the operation of the computer system .","The I\/O interface  includes one or more I\/O ports to connect to corresponding I\/O devices, such as external storage or supplemental devices (e.g., a printer or a PDA). In one implementation, the ports of the I\/O interface  include ports such as: USB ports, PCMCIA ports, serial ports, and\/or parallel ports. In another implementation, the I\/O interface  includes a wireless interface for communication with external devices wirelessly.","The network interface  includes a wired and\/or wireless network connection, such as an RJ-45 or \u201cWi-Fi\u201d interface (including, but not limited to 802.11) supporting an Ethernet connection.","The computer system  includes additional hardware and software typical of computer systems (e.g., power, cooling, operating system), though these components are not specifically shown in  for simplicity. In other implementations, different configurations of the computer system can be used (e.g., different bus or storage configurations or a multi-processor configuration). In one implementation, the computer system is a next generation game console from, for example, Sony Playstation\u00ae.","In one implementation, huge bandwidth savings may be experienced by using persistent party rooms. Because party rooms according to the current party room implementations are killed and re-created per session, persistent party rooms conserve large amounts of bandwidth resources by using bookmark pointers that store information about a give persistent party room. Furthermore, persistent party rooms avoid the bandwidth problems associated with star grid or mesh networks used when players are waiting in a lobby to play a game.","The description herein of the disclosed implementations is provided to enable any person skilled in the art to make or use the present application. Numerous modifications to these implementations would be readily apparent to those skilled in the art, and the principals defined herein can be applied to other implementations without departing from the spirit or scope of the present application. For example, although the specification describes persistent party rooms in the context of online games, these persistent party rooms can be used with any online or offline activity (offline in being based in an intranet, for example or local home network). In another example, the persistent party rooms can be used over computers or mobile devices, in addition to game consoles. Thus, the present application is not intended to be limited to the implementations shown herein but is to be accorded the widest scope consistent with the principal and novel features disclosed herein.","Various implementations of the present application are realized in electronic hardware, computer software, or combinations of these technologies. Some implementations include one or more computer programs executed by one or more computing devices. In general, the computing device includes one or more processors, one or more data-storage components (e.g., volatile or non-volatile memory modules and persistent optical and magnetic storage devices, such as hard and floppy disk drives, CD-ROM drives, and magnetic tape drives), one or more input devices (e.g., game controllers, mice and keyboards), and one or more output devices (e.g., display devices).","The computer programs include executable code that is usually stored in a persistent storage medium and then copied into memory at run-time. At least one processor executes the code by retrieving program instructions from memory in a prescribed order. When executing the program code, the computer receives data from the input and\/or storage devices, performs operations on the data, and then delivers the resulting data to the output and\/or storage devices.","Those of skill in the art will appreciate that the various illustrative modules and method steps described herein can be implemented as electronic hardware, software, firmware or combinations of the foregoing. To clearly illustrate this interchangeability of hardware and software, various illustrative modules and method steps have been described herein generally in terms of their functionality. Whether such functionality is implemented as hardware or software depends upon the particular application and design constraints imposed on the overall system. Skilled persons can implement the described functionality in varying ways for each particular application, but such implementation decisions should not be interpreted as causing a departure from the scope of the present application. In addition, the grouping of functions within a module or step is for ease of description. Specific functions can be moved from one module or step to another without departing from the present application.","Additionally, the steps of a method or technique described in connection with the implementations disclosed herein can be embodied directly in hardware, in a software module executed by a processor, or in a combination of the two. A software module can reside in RAM memory, flash memory, ROM memory, EPROM memory, EEPROM memory, registers, hard disk, a removable disk, a CD-ROM, or any other form of storage medium including a network storage medium. An example storage medium can be coupled to the processor such that the processor can read information from, and write information to, the storage medium. In the alternative, the storage medium can be integral to the processor. The processor and the storage medium can also reside in an ASIC.","All features of each above-discussed example are not necessarily required in a particular implementation of the present application. Further, it is to be understood that the description and drawings presented herein are representative of the subject matter which is broadly contemplated by the present application. It is further understood that the scope of the present application fully encompasses other implementations that may become obvious to those skilled in the art and that the scope of the present application is accordingly limited by nothing other than the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9A"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9B"}]},"DETDESC":[{},{}]}
