---
title: Methods and systems for information capture
abstract: Systems and methods for information capture from articles are described. In one embodiment, a plurality of keystrokes associated with an application is received, each keystroke is processed to determine an associated action forming a plurality of associated actions, and an event is determined based at least in part on the plurality of associated actions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07941439&OS=07941439&RS=07941439
owner: Google Inc.
number: 07941439
owner_city: Mountain View
owner_country: US
publication_date: 20040331
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION OF SPECIFIC EMBODIMENTS"],"p":["The invention generally relates to search engines. More particularly, the invention relates to methods and systems for information capture.","Users generate and access a large number of articles, such as emails, web pages, word processing documents, spreadsheet documents, instant messenger messages, and presentation documents, using a client device, such as a personal computer, personal digital assistant, or mobile phone. Some articles are stored on one or more storage devices coupled to, accessible by, or otherwise associated with the client device(s). Users sometimes wish to search the storage device(s) for articles.","Conventional client-device search applications may significantly degrade the performance of the client device. For example, certain conventional client-device search applications typically use batch processing to index all articles, which can result in noticeably slower performance of the client device during the batch processing. Additionally, batch processing occurs only periodically. Therefore, when a user performs a search, the most recent articles are sometimes not included in the results. Moreover, if the batch processing is scheduled for a time when the client device is not operational and is thus not performed for an extended period of time, the index of articles associated with the client device can become outdated. Conventional client-device search applications can also need to rebuild the index at each batch processing or build new partial indexes and perform a merge operation that can use a lot of client-device resources. Conventional client-device search applications also sometimes use a great deal of system resources when operational, resulting in slower performance of the client device.","Additionally, conventional client-device search applications can require an explicit search query from a user to generate results, and may be limited to examining file names or the contents of a particular application's files.","Embodiments of the present invention comprise methods and systems for information capture. In one embodiment, a plurality of keystrokes associated with an application is received, each keystroke is processed to determine an associated action forming a plurality of associated actions, and an event is determined based at least in part on the plurality of associated actions. In another embodiment, a plurality of display calls associated with an application are received, the plurality of display calls are processed to determine a display, and an event is determined based at least in part on the display.","These exemplary embodiments are mentioned not to limit or define the invention, but to provide examples of embodiments of the invention to aid understanding thereof. Exemplary embodiments are discussed in the Detailed Description, and further description of the invention is provided there. Advantages offered by the various embodiments of the present invention may be further understood by examining this specification.","Referring now to the drawings in which like numerals indicate like elements throughout the several figures,  is a block diagram illustrating an exemplary environment for implementation of an embodiment of the present invention. While the environment shown in  reflects a client-side search engine architecture embodiment, other embodiments are possible. The system  shown in  includes multiple client devices -that can communicate with a server device  over a network . The network  shown in  comprises the Internet. In other embodiments, other networks, such as an intranet, may be used instead. Moreover, methods according to the present invention may operate within a single client device that does not communicate with a server device or a network.","The client devices -shown in  each include a computer-readable medium . The embodiment shown in  includes a random access memory (RAM)  coupled to a processor . The processor  executes computer-executable program instructions stored in memory . Such processors may include a microprocessor, an ASIC, state machines, or other processor, and can be any of a number of suitable computer processors, such as processors from Intel Corporation of Santa Clara, Calif. and Motorola Corporation of Schaumburg, Ill. Such processors include, or may be in communication with, media, for example computer-readable media, which stores instructions that, when executed by the processor, cause the processor to perform the steps described herein. Embodiments of computer-readable media include, but are not limited to, an electronic, optical, magnetic, or other storage or transmission device capable of providing a processor, such as the processor  of client , with computer-readable instructions. Other examples of suitable media include, but are not limited to, a floppy disk, CD-ROM, DVD, magnetic disk, memory chip, ROM, RAM, an ASIC, a configured processor, all optical media, all magnetic tape or other magnetic media, or any other medium from which a computer processor can read instructions. Also, various other forms of computer-readable media may transmit or carry instructions to a computer, including a router, private or public network, or other transmission device or channel, both wired and wireless. The instructions may comprise code from any suitable computer-programming language, including, for example, C, C++, C#, Visual Basic, Java, Python, Perl, and JavaScript.","Client devices -can be coupled to a network , or alternatively, can be stand alone machines. Client devices -may also include a number of external or internal devices such as a mouse, a CD-ROM, DVD, a keyboard, a display device, or other input or output devices. Examples of client devices -are personal computers, digital assistants, personal digital assistants, cellular phones, mobile phones, smart phones, pagers, digital tablets, laptop computers, Internet appliances, and other processor-based devices. In general, the client devices -may be any type of processor-based platform that operates on any suitable operating system, such as Microsoft\u00ae Windows\u00ae or Linux, capable of supporting one or more client application programs. For example, the client device can comprise a personal computer executing client application programs, also known as client applications . The client applications  can be contained in memory  and can include, for example, a word processing application, a spreadsheet application, an email application, an instant messenger application, a presentation application, an Internet browser application, a calendar\/organizer application, a video playing application, an audio playing application, an image display application, a file management program, an operating system shell, and other applications capable of being executed by a client device. Client applications may also include client-side applications that interact with or accesses other applications (such as, for example, a web-browser executing on the client device that interacts with a remote e-mail server to access e-mail).","The user can interact with the various client applications  and articles associated with the client applications  via various input and output devices of the client device . Articles include, for example, word processor documents, spreadsheet documents, presentation documents, emails, instant messenger messages, database entries, calendar entries, appointment entries, task manager entries, source code files, and other client application program content, files, messages, items, web pages of various formats, such as HTML, XML, XHTML, Portable Document Format (PDF) files, and media files, such as image files, audio files, and video files, or any other documents or items or groups of documents or items or information of any suitable type whatsoever.","The user's interaction with articles, the client applications , and the client device creates event data that may be observed, recorded, analyzed or otherwise used. An event can be any occurrence possible associated with an article, client application , or client device , such as inputting text in an article, displaying an article on a display device, sending an article, receiving an article, manipulating an input device, opening an article, saving an article, printing an article, closing an article, opening a client application program, closing a client application program, idle time, processor load, disk access, memory usage, bringing a client application program to the foreground, changing visual display details of the application (such as resizing or minimizing) and any other suitable occurrence associated with an article, a client application program, or the client device whatsoever. Additionally, event data can be generated when the client device interacts with an article independent of the user , such as when receiving an email or performing a scheduled task.","The memory  of the client device can also contain a capture processor , a queue , and a search engine . The client device can also contain or is in communication with a data store . The capture processor  can capture events and pass them to the queue . The queue  can pass the captured events to the search engine  or the search engine  can retrieve new events from the queue . In one embodiment, the queue  notifies the search engine  when a new event arrives in the queue  and the search engine  retrieves the event (or events) from the queue  when the search engine  is ready to process the event (or events). When the search engine receives an event it can be processed and can be stored in the data store . The search engine  can receive an explicit query from the user or generate an implicit query and it can retrieve information from the data store  in response to the query. In another embodiment, the queue is located in the search engine . In still another embodiment, the client device does not have a queue and the events are passed from the capture processor  directly to the search engine . According to other embodiments, the event data is transferred using an information exchange protocol. The information exchange protocol can comprise, for example, any suitable rule or convention facilitating data exchange, and can include, for example, any one of the following communication mechanisms: Extensible Markup Language-Remote Procedure Calling protocol (XML\/RPC), Hypertext Transfer Protocol (HTTP), Simple Object Access Protocol (SOAP), shared memory, sockets, local or remote procedure calling, or any other suitable information exchange mechanism.","The capture processor  can capture an event by identifying and extracting event data associated with an event. Examples of events include sending or receiving an instant messenger message, a user viewing a web page, saving a word processing document, printing a spreadsheet document, inputting text to compose or edit an email, opening a presentation application, closing an instant messenger application, entering a keystroke, moving the mouse, and hovering the mouse over a hyperlink. An example of event data captured by the capture processor  for an event involving the viewing of a web page by a user includes the URL of the web page, the time and date the user viewed the web page, and the content of the web page.","In one embodiment, the capture processor  may comprise multiple capture components. For example, the capture processor  can comprise a separate capture component for each client application in order to capture events associated with each application. The capture processor  can also comprise a separate capture component to monitor and capture keystrokes input by the user and a separate capture component that can monitor and capture items, such as text, displayed on a display device associated with the client device . The keystroke capture component and the display capture component can be used to capture events when a client application capture component is not available for a client application or in conjunction with a client application capture component. The keystroke capture component can also contain or access a keystroke database. The keystroke database can provide correlation between keystrokes and actions for applications. The keystroke capture component and the display capture component can also contain or access a history of previous keyboard or display events.","In one embodiment, the capture processor  can comprise a separate capture component that monitors overall network activity in order to capture event data associated with network activity, such as the receipt of an instant messenger message. The capture processor  can comprise a separate capture component that monitors overall client device performance data, such as processor load, idle time, disk access, the client applications in use, and the amount of memory available. An individual capture component can monitor multiple client applications and multiple capture components can monitor different aspects of a single client application.","In one embodiment, the capture processor , through the individual capture components, can monitor activity on the client device and can capture events by a generalized event definition and registration mechanism, such as an event schema. Each capture component can define its own event schema or can use a predefined one. Event schemas can differ depending on the client application or activity the capture component is monitoring. Generally, the event schema can describe the format for an event, for example, by providing fields for event data associated with the event (such as time of the event) and fields related to any associated article (such as title) as well as the content of any associated article (such as document body). An event schema can describe the format for any suitable event data that relates to an event. For example, an event schema for user input, such as words typed or displayed to a display device, can include the application used for the input, the format of the text, the words and other items input, and the time input. An event schema for an email event received by a user can include header information, such as the content from the subject, to, from, cc, and time received fields, and body information. An event schema for a web page currently being viewed by a user can include the Uniform Resource Locator (URL) of the web page, the time being viewed, and the content of the web page. An event schema for a word processing document being saved by a user can include the title of the document, the time saved, the location of the document, the format of the document, the text of the document, and a pointer to the location of the document.","In one embodiment, the keyboard capture component may not use an event schema. Rather, in this embodiment, the keyboard capture component can convert keystrokes to a sequence of words and then can pass the sequence of words to another component, such as the word processing capture component. The word processing capture can use an event schema to express information sent by the keystroke capture component.","More generally, an event schema can describe the state of the system around the time of the event. For example, an event schema can contain a URL for a web page event associated with a previous web page that the user navigated from. In addition, event schema can describe fields with more complicated structure like lists. For example, an event schema can contain fields that list multiple recipients. An event schema can also contain optional fields so that an application can include additional event data if desired.","The capture processor  can capture events occurring presently (or \u201creal-time events\u201d) and can capture events that have occurred in the past (or \u201chistorical events\u201d). Real-time events can be \u201cindexable\u201d or \u201cnon-indexable\u201d. In one embodiment, the search engine  indexes indexable real-time events, but does not index non-indexable real-time events. The search engine  may determine whether to index an event based on the importance of the event. Indexable real-time events can be more important events associated with an article, such as viewing a web page, loading or saving a file, and receiving or sending an instant message or email. Non-indexable events can be deemed not important enough by the search engine  to index and store the event, such as moving the mouse or selecting a portion of text in an article. Non-indexable events can be used by the search engine  to update the current user state. While all real-time events can relate to what the user is currently doing (or the current user state), indexable real-time events can be indexed and stored in the data store . Alternatively, the search engine  can index all real-time events. Real-time events can include, for example, sending or receiving an article, such as an instant messenger message, examining a portion of an article, such as selecting a portion of text or moving a mouse over a portion of a web page, changing an article, such as typing a word in an email or pasting a sentence in a word processing document, closing an article, such as closing an instant messenger window or changing an email message being viewed, loading, saving, opening, or viewing an article, such as a word processing document, web page, or email, listening to or saving an MP3 file or other audio\/video file, or updating the metadata of an article, such as book marking a web page, printing a presentation document, deleting a word processing document, or moving a spreadsheet document.","Historical events are similar to indexable real-time events except that the event occurred before the installation of the search engine  or was otherwise not captured, because, for example, the search engine  was not operational for a period of time while the client device was operational or because no capture component existed for a specific type of historical event at the time the event took place. Examples of historical events include the user's saved word processing documents, media files, presentation documents, calendar entries, and spreadsheet documents, the emails in a user's inbox, and the web pages bookmarked by the user. The capture processor  can capture historical events by periodically crawling the memory  and any associated data storage device for events not previously captured by the capture processor . The capture processor  can also capture historical events by requesting certain client applications, such as a web browser or an email application, to retrieve articles and other associated information. For example, the capture processor  can request that the web browser application obtain all viewed web pages by the user or request that the email application obtain all email messages associated with the user. These articles may not currently exist in memory  or on a storage device of the client device . For example, the email application may have to retrieve emails from a server device. In one embodiment, the search engine  indexes historical events.","In the embodiment shown in , events captured by the capture processor  are sent to the queue  in the format described by an event schema. The capture processor  can also send performance data to the queue . Examples of performance data include current processor load, average processor load over a predetermined period of time, idle time, disk access, the client applications in use, and the amount of memory available. Performance data can also be provided by specific performance monitoring components, some of which may be part of the search engine , for example. The performance data in the queue  can be retrieved by the search engine  and the capture components of the capture processor . For example, capture components can retrieve the performance data to alter how many events are sent to the queue  or how detailed the events are that are sent (fewer or smaller events when the system is busy) or how frequently events are sent (events are sent less often when the system is busy or there are too many events waiting to be processed). The search engine  can use performance data to determine when it indexes various events and when and how often it issues implicit queries.","In one embodiment, the queue  holds events until the search engine  is ready to process an event or events. Alternatively, the queue  uses the performance data to help determine how quickly to provide the events to the search engine . The queue  can comprise one or more separate queues including a user state queue and an index queue. The index queue can queue indexable events, for example. Alternatively, the queue  can have additional queues or comprise a single queue. The queue  can be implemented as a circular priority queue using memory mapped files. The queue can be a multiple-priority queue where higher priority events are served before lower priority events, and other components may be able to specify the type of events they are interested in. Generally, real-time events can be given higher priority than historical events, and indexable events can be given higher priority than non-indexable real-time events. Other implementations of the queue  are possible. In another embodiment, the client device does not have a queue . In this embodiment, events are passed directly from the capture processor  to the search engine . In other embodiments, events can be transferred between the capture components and the search engine using suitable information exchange mechanisms such as: Extensible Markup Language-Remote Procedure Calling protocol (XML\/RPC), Hypertext Transfer Protocol (HTTP), Simple Object Access Protocol (SOAP), shared memory, sockets, local or remote procedure calling, or any other suitable information exchange mechanism.","The search engine  can contain an indexer , a query system , and a formatter . The query system  can retrieve all real-time events and performance data from the queue . The query system  can use performance data and real-time events to update the current user state and generate an implicit query. An implicit query can be an automatically generated query based on the current user state. The query system  can also receive and process explicit queries from the user . Performance data can also be retrieved by the search engine  from the queue  for use in determining the amount of activity possible by the search engine .","In the embodiment shown in , indexable real-time events and historical events (indexable events) are retrieved from the queue  by the indexer . Alternatively, the queue  may send the indexable events to the indexer . The indexer  can index the indexable events and can send them to the data store  where they are stored. The data store  can be any type of computer-readable media and can be integrated with the client device , such as a hard drive, or external to the client device , such as an external hard drive or on another data storage device accessed through the network . The data store can be one or more logical or physical storage areas. In one embodiment, the data store  can be in memory . The data store  may facilitate one or combination of methods for storing data, including without limitation, arrays, hash tables, lists, and pairs, and may include compression and encryption. In the embodiment shown in , the data store comprises an index , a database  and a repository .","In the embodiment shown in , when the indexer  receives an event, the indexer  can determine, from the event schema, terms (if any) associated with the event, the time of the event (if available), images (if any) associated with the event, and\/or other information defining the event. The indexer  can also determine if the event relates to other events and associate the event with related events. For example, for an event concerning a web page, the indexer  can associate this event with other events concerning the same web page. This association information can be stored in the database  in a document for each group of related events.","The indexer  can send and incorporate the terms and times, associated with the event in the index  of the data store . The event can be sent to the database  for storage and the content of the associated article and any associated images can be stored in the repository . The conversation object associated with instant messenger messages can be stored in the database .","In the embodiment shown in , a user can input an explicit query into a search engine interface displayed on the client device , which is received by the search engine . The search engine  can also generate an implicit query based on a current user state, which can be determined by the query system  from real-time events. Based on the query, the query system  can locate relevant information in the data store  and provide a result set. In one embodiment, the result set comprises article identifiers for articles associated with the client applications  or client articles. Client articles include articles associated with the user or client device , such as the user's emails, word processing documents, instant messenger messages, previously viewed web pages and any other article or portion of an article associated with the client device or user . An article identifier may be, for example, a Uniform Resource Locator (URL), a file name, a link, an icon, a path for a local file, or other suitable information that may identify an article. In another embodiment, the result set also comprises article identifiers for articles located on the network  or network articles located by a search engine on a server device. Network articles include articles located on the network  not previously viewed or otherwise referenced by the user , such as web pages not previously viewed by the user ","The formatter  can receive the search result set from the query system  of the search engine  and can format the results for output to a display processor . In one embodiment, the formatter  can format the results in XML, HTML, or tab delineated text. The display processor  can be contained in memory  and can control the display of the result set on a display device associated with the client device . The display processor  may comprise various components. For example, in one embodiment, the display processor  comprises a Hypertext Transfer Protocol (HTTP) server that receives requests for information and responds by constructing and transmitting Hypertext Markup Language (HTML) pages. In one such embodiment, the HTTP server comprises a scaled-down version of the Apache Web server. The display processor  can be associated with a set of APIs to allow various applications to receive the results and display them in various formats. The display APIs can be implemented in various ways, including, for example as, DLL exports, COM interface, VB, JAVA, or .NET libraries, or as a web service.","Through the client devices -, users -can communicate over the network , with each other and with other systems and devices coupled to the network . As shown in , a server device  can be coupled to the network . In the embodiment shown in , the search engine  can transmit a search query comprised of an explicit or implicit query or both to the server device . The user can also enter a search query in a search engine interface, which can be transmitted to the server device  by the client device via the network . In another embodiment, the query signal may instead be sent to a proxy server (not shown), which then transmits the query signal to server device . Other configurations are also possible.","The server device  can include a server executing a search engine application program, such as the Google\u2122 search engine. In other embodiments, the server device  can comprise a related information server or an advertising server. Similar to the client devices -, the server device  can include a processor  coupled to a computer-readable memory . Server device , depicted as a single computer system, may be implemented as a network of computer processors. Examples of a server device  are servers, mainframe computers, networked computers, a processor-based device, and similar types of systems and devices. The server processor  can be any of a number of computer processors, such as processors from Intel Corporation of Santa Clara, Calif. and Motorola Corporation of Schaumburg, Ill. In another embodiment, the server device  may exist on a client-device. In still another embodiment, there can be multiple server devices .","Memory  contains the search engine application program, also known as a network search engine . The search engine  can locate relevant information from the network  in response to a search query from a client device . The search engine  then can provide a result set to the client device via the network . The result set can comprise one or more article identifiers. An article identifier may be, for example, a Uniform Resource Locator (URL), a file name, a link, an icon, a path for a local file, or anything else that identifies an article. In one embodiment, an article identifier can comprise a URL associated with an article.","In one embodiment, the server device , or related device, has previously performed a crawl of the network  to locate articles, such as web pages, stored at other devices or systems coupled to the network , and indexed the articles in memory  or on another data storage device.","It should be noted that other embodiments of the present invention may comprise systems having different architecture than that which is shown in . For example, in some other embodiments of the present invention, the client device is a stand alone device and is not coupled to a network. The system  shown in  is merely exemplary, and is used to explain the exemplary methods shown in .","Various methods in accordance with the present invention may be carried out. For example, in one embodiment, a plurality of keystrokes associated with an application is received, each keystroke is processed to determine an associated action forming a plurality of associated actions, and an event is determined based at least in part on the plurality of associated actions. An application in focus can first be determined.","In one embodiment, the event can be a number of words and it can be determined that the plurality of associated actions forms a word or words. The word or words can be determined at least in part by the receipt of at least one keystroke indicating a space or a punctuation symbol. In another embodiment, the event can be a number of characters and it can be determined that the plurality of associated actions form a character or characters.","In one embodiment, a capture state can be updated after each keystroke is processed. In one embodiment, a current user state can be updated based at least in part on the event. The event can be indexed and stored.","In one embodiment, each associated action can be determined at least in part by matching the keystroke to an entry in a keystroke table and determining an action in the keystroke table associated with the entry. The action can comprise one of adding a character to a word, deleting a character from a word, inserting a character, overwriting a character, deleting a word, deleting a paragraph, selecting an item, and repositioning the cursor. The keystroke table can be associated with the application or can be a generic keystroke table.","In another embodiment, a plurality of keystrokes are received associated with an application, an event is determined based on user input, and it is determined whether to index the event. User input can be one or more of a number of words determined from the plurality of keystrokes, a number of characters determined from the plurality of keystrokes, and a change is focus from the application to another application. Whether to index the event can comprise determining whether the event is important to the user.","In another embodiment, a plurality of display calls associated with an application are received, the plurality of display calls are processed to determine a display, and an event is determined based at least in part on the display. The display can be determined at least in part by using an array of a current state of the display and updating the array with the display call and can be determined at least in part by constructing display items based at least in part on display positions of the display calls. The plurality of display calls can be processed by one or more of analyzing one or more of the x,y coordinates, lengths, and relative positions of a plurality of items written to the display using display calls.","In one embodiment, an application in focus is first determined. In one embodiment, the event is a number of words and it can be determined that the display includes a word or words. In one embodiment, a capture state can be updated after each display call is processed and a current user state can be updated based at least in part on the event.","In one embodiment, it can be determined whether to index the event and the event can be indexed and stored if it is so determined.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 2","FIG. 2","FIG. 1","FIG. 2"],"b":["200","200","200","100","100"]},"In , the capture processor  captures an event. The capture processor  can capture an event by identifying and compiling event data associated with the event upon the occurrence of the event. The capture processor  may have separate capture components for each client application, network monitoring, performance data capture, keystroke capture, and display capture. For example, an event can occur when a user types a predetermined number of words in a client application. The event data associated with this event can be, for example, the application used for the input, the format of the text, the words input, and the time input. In one embodiment, the capture component can use a generalized event definition mechanism, such as an event schema that it has previously registered with the client device , to capture or express the event.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 3","FIG. 3"],"b":["202","112","302"],"i":"a"},"In , the keystroke capture component is called. The keystroke capture component can operate regularly or even constantly so that it monitors all keystroke activity or can be selectively called by the capture processor  or other capture components when needed or at various times. In , the keystroke capture component can determine the client application in focus. The application in focus is the client application currently being used by the user . For example, it can be the client application that the user is inputting text in. In one embodiment, the application in focus is determined so that the keystroke capture component can use the keystroke table associated with the application in focus from the keystroke database. For example, if the application in focus is a specific word processing application, the keystroke capture component can call up the corresponding specific word processing application keystroke table.","In , the event data is reset by the keystroke capture component. In one embodiment, event data is complied in an event in a format defined by an event schema and the keystroke capture component can register a specific keystroke capture event schema and resetting the event comprises clearing out any existing event data. A counter N can also be reset. In one embodiment, the counter counts the number of words captured by the keystroke capture component. In such embodiment, when the event is reset the counter is reset to zero.","In , the keystroke capture component captures a keystroke input by the user . A user can input a keystroke through a variety of input devices, such as a keyboard. A keystroke can include a single key input or a multiple key input and can include a text input and an editing command input. For example, a keystroke can include the \u201cG\u201d key and the \u201cShift\u201d and the \u201cG\u201d keys. A keystroke can also include the \u201cBackspace\u201d key and the \u201cControl\u201d and \u201cBackspace\u201d keys. The keystroke capture component can receive a keystroke by receiving keystroke messages through an application callback that can be invoked by the operating system. The keystroke capture component can also receive a keystroke through monitoring an input buffer, such as a keyboard buffer, at the operating system level. Other methods of inputting characters, such as handwriting, can be captured.","In , the keystroke capture component processes the keystroke. In the embodiment shown, the keystroke capture component processes the received keystroke by matching the keystroke to an entry in the keystroke table for the specific application in focus and determining the respective action for the keystroke. For example, if the received keystroke is the \u201cSHIFT\u201d key and the \u201cG\u201d key in a specific word processing application, the keystroke capture component matches the \u201cSHIFT\u201d key and the \u201cG\u201d key in the keystroke table for the specific application and can determine the associated action, for example, the output of the letter \u201cG\u201d. If the received keystroke is the \u201cControl\u201d and \u201cBackspace\u201d keys, the keystroke capture component can match these keys with the respective action in the keystroke table for the specific application and determine the associated action, for example, the action of deleting the word preceding the cursor. Other possible actions include moving the cursor up or down one line, moving the cursor up or down one paragraph, and moving the cursor to the beginning or end of a document, for example. The keystroke capture component can keep track of the current position of the cursor with respect to previous characters entered. For example, if the user types 5 characters, hits \u201cleft arrow\u201d three times, types one character, and hits \u201cright arrow\u201d three times, the component can identify that the user went back and inserted a character in the word (for applications where \u201cleft arrow\u201d corresponds with moving the cursor back one character). The component can further keep track of whether each application is in \u201cinsert\u201d mode, so that it knows if new characters overlay any existing characters.","In another embodiment, the keystroke capture component may not process the keystrokes directly. Instead, the keystroke capture component may first pass keystrokes to the operating system, as if the user had actively sent them to the keyboard capture component, and not an application. In this way, the operating system can do the work of translating keystrokes into higher level messages (characters, key movement, etc.), and can then return these messages to the keystroke capture component for further processing. Sending keystrokes to the operating system for intermediate processing, instead of processing them directly, may be advantageous for several reasons. For example, it may avoid some of the difficulties of handling multi-keystroke characters (including non-English character entry), and it may ensure keystrokes get processed in a manner that is consistent with operating system behavior.","In , the keystroke capture component adds the processed keystroke to the event data. In the embodiment shown, the keystroke capture component captures event data in as described by the event schema and the processed keystroke is added to the event data. For example, if the processed keystroke indicates the addition of the letter G, the letter G is added to the event data. If the processed keystroke indicates to delete the word preceding the cursor and a word is contained in the event data this word can be deleted. Additionally, the keystroke capture component can add the processed keystroke to a capture state. The keystroke capture component can maintain the capture state containing previous keystrokes as it is determined what recent word(s) the user has entered. The capture state can be updated before an event is generated.","In , the keystroke capture component determines if a complete word has been added to the event. A word can be a series of characters representing a spoken word, abbreviation, term, or semantic unit. For example, \u201cWORLD SERIES\u201d, \u201cASCII\u201d, \u201cMR\u201d and \u201cGOOGLE\u201d can be words. The keystroke capture component can determine if a complete word has been entered by a variety of methods. In one embodiment, the keystroke capture component looks for a series of characters followed by a space, such as \u201cGOOGLE\u201d, or certain punctuation characters, such as \u201cGOOGLE,\u201d to determine if a complete word has been entered. If a complete word has not been entered, then the keystroke capture component goes to step . In , the keystroke capture component can determine whether the application previously in focus is still in focus or if the application in focus has changed and another application is now in focus. If the application in focus has not changed, the keystroke capture component returns to step  and receives another keystroke. If the application in focus has changed, the keystroke capture component returns to step  and determines the current application in focus. If the keystroke capture component identifies an action such as moving the cursor up one line, it may update the capture state to reflect the new cursor location. If the keystroke capture component does not have the capture state for that location, or cannot accurately pinpoint the new location, it may simply reset any partially captured word. As another example, the keystroke \u201cshift left arrow\u201d may select the previous character in a particular application. The keystroke capture component can recognize this action and possible subsequent actions such as deleting the selection or pasting the selection elsewhere in the document.","If, in step , the keystroke capture component determines that a complete word has been received, then in step  the counter N is incremented by one. In step , the capture processor determines if the counter N equals an integer T. The integer T can be, for example, a number of words. The number of words can be predetermined or can be determined based on a variety of suitable factors, such as the current application in focus or other user activity. In one example, T equals one so that the keystroke capture component may create an event upon the identification of each word entered by the user . Alternatively, T can be a number of characters. Like the number of words, the number of characters can be predetermined or can be determined based on a variety of suitable factors. If, in step , N is found not to equal T, then the keystroke capture component goes to step , where the keystroke capture component determines if the application in focus has changed. If the keystroke capture component determines that N does equal T, then the keystroke capture component proceeds to step . For example, if N is a counter counting the number of words captured and T is set to one and \u201cGOGGLE\u201d is received, then the keystroke capture component proceeds to step .","In , the keystroke capture component compiles the event. In the embodiment shown, the keystroke capture component compiles the event by compiling the event data associated with specific fields described by the event schema. For example, the event data can include the application used for the input, the format of the text, the word or words input, and the time input. When the keystroke capture component has compiled the event, the method  can continue at step  as shown in .",{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 4","FIG. 2","FIG. 4"],"b":["202","102","400","124"],"i":"a"},"In , the display capture component determines the application in focus. The application in focus is the client application currently being used by the user . For example, in a windows based operating system environment the display capture component determines which window the user is actively using.","In , the display capture component resets the event. The display capture component resets an event for a variety of reasons, such as the user has switched the application in focus, an event has been captured and sent to the queue , or a variety of other reasons. In one embodiment, the display capture component captures an event by placing event data in an event format according to an event schema and can reset the event by indicating a new event. In one embodiment, any existing event data previously determined and associated with a previous event may be saved. The existing event data can be saved in a capture state maintained by the display capture component. In another embodiment, the indication of a new event may trigger the sending of the existing event data in an event to the queue , for example.","In , the display capture component receives a display call. A display call can be an instruction sent by the operating system to the display device associated with the client device that instructs the display device to display an item or change the display of an item on the display device. For example, the display call can be to display the text \u201cGoogle\u201d in font \u201cTimes New Roman\u201d at a display position, such as position x,y. This display call can, for example, cause the display on the screen of a computer monitor of the text \u201cGoogle\u201d at the position x,y in the active window and in the font \u201cTimes New Roman\u201d. A display call can also be, for example, to delete an item at a given position, change the font of a word, or change the position of an item on the display. The display calls can be determined by injecting code into applications or through the use of Dynamic Link Libraries (DLL) to hook and intercept operating system Application Programming Interface (API) calls. Other methods of output, such as calls to a printer driver, can be captured.","In , the display capture component processes the display call to determine the current display. The display can be what the user sees in the current display window. In the embodiment shown, the display capture component keeps an array of items that have been written in the current display. The display capture component can use the x and y coordinates of the items to determine words, spaces between words and the beginning of a new line. The display call may be used by the display capture component to update the array of the current display. For example, if the display call is to write the text \u201cGoogle\u201d in font \u201cTimes New Roman\u201d at position x,y then the text \u201cGoogle\u201d in font \u201cTimes New Roman\u201d is added to the display at position x,y. The updated array associated with the current display can then be added to the event. The capture state can also be updated with the updated array by the display capture component.","In , the display capture component determines whether a complete event has occurred. For example, an event can occur after a single word is added to the display on the display device. Alternatively, an event can occur after a predetermined number of words have been displayed. The display capture component can use the updated array of displayed items by using the x and y coordinates of items in the array to determine words and spaces between words to determine if an event has occurred. If the display capture component determines that a complete event has not yet occurred, then the display capture component proceeds to step . In , the display capture component determines whether the application in focus has changed. If the application in focus has not changed, the display capture component receives the next display call at . If the application in focus has changed, the display capture component determines the application in focus at .","If the display capture component determines that a complete event has occurred then the display capture component proceeds to . In , the display capture component can compile the event. In the embodiment shown the display capture component compiles the event by providing all the event data described in an event schema. For example, the event data can include the application used, the format of the display, the time of display, the content displayed, the font and font size of any words displayed and any other data that can be used to define the event. Once the event is captured, the method proceeds with step  in . The keystroke capture component and the display capture component can be used together to determine user activity, for example, what the user is viewing on a visual output device, such as a display.","Returning to , in , the capture processor  determines whether the event captured is an indexable event. As explained above, some real-time events may not be indexed (non-indexable real-time events). In one embodiment, non-indexable real-time events are used to update the current user state and are, for example, examining a portion of an article; changing an article, and closing an article. In this embodiment, non-indexable events are not indexed or sent for storage by the indexer . Indexable events can be indexable real-time events or historical events. Keystrokes and display calls can be non-indexable events, such as the input of a number of words by a user or the display of a number of words on a display device. Keystrokes and display calls can also be indexable events, such as, for example, when an entire article or portion of an article is input by a user or displayed on a display device.","If an indexable event is determined, then, in , the event can be sent by the capture processor  to the queue  with an indication that it is an indexable event. In the embodiment shown in , indexable real-time events are sent to both a user state queue and an index queue within queue  and historical events are sent to the index queue within the queue . Alternatively, indexable real-time events may not be sent to the user state queue to save computational time. The capture processor  can send the event in a form described by an event schema to the queue .","If the event is determined to be a non-indexable event, then, in , the non-indexable event can be sent by the capture processor  to the user state queue of the queue  with an indication that it is not to be indexed. For example, when a user is composing an email a capture component can capture a number of words input by the user in the composition of the email. A capture component can capture the input text as an event. While this event can be helpful in determining a current state of the user , it may not be important enough to be indexed and sent for storage by the search engine, so that the user may later retrieve this information. Alternatively, for an example where a user opens a received email, while this event can provide information on a current user state, it can also be indexed and sent for storage by the search engine , because the user may later be interested in retrieving this email.","In one embodiment, the queue  holds the event until the search engine is ready to receive it. Based on the event data, the event can be prioritized on the queue  for handling. For example, historical events are given a lower priority for processing by the queue  than real-time events. In one embodiment, when the indexer  is ready to process another event, it can retrieve an event or events from the index queue in the queue . The query system  can retrieve an event or events from the user state queue of the queue , when it is ready to update the user state. In another embodiment, a queue is not used and events are sent directly to the search engine  from the capture processor .","In , the indexer  indexes and stores the event. The indexer  can retrieve an event from the queue  when it is ready to process the event. In one embodiment, the indexer  determines if the event is a duplicate event and if not assigns an Event ID to the event. The indexer  can also associate the event with related events. In the embodiment shown in , using the event schema, the indexer determines indexable terms associated with the event, dates and times associated with the event, and other data associated with the event. The indexer  can associate the Event ID with the indexable terms that are contained in the index . The event can be stored in the database  and the content of the event can be stored in the repository .","The environment shown reflects a client-side search engine architecture embodiment. Other embodiments are possible, such as a stand alone client device or a network search engine.","While the above description contains many specifics, these specifics should not be construed as limitations on the scope of the invention, but merely as exemplifications of the disclosed embodiments. Those skilled in the art will envision many other possible variations that are within the scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["These and other features, aspects, and advantages of the present invention are better understood when the following Detailed Description is read with reference to the accompanying drawings, wherein:",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
