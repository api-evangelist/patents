---
title: Rendering lines with sample weighting
abstract: A graphics system and method for displaying lines on a display device. The system may comprise a sample buffer, a rendering unit and a sample-to-pixel calculation unit. The rendering unit may (a) generate a plurality of sample positions in a two-dimensional space, (b) determine a sample normal distance for each of the sample positions with respect to a line defined by the line-draw command, (c) assign sample values to the sample positions based on the sample normal distance of each of the sample positions, and (d) store the sample values in the sample buffer. The sample-to-pixel calculation unit may read sample values from the sample buffer, filter them to determine a pixel value, and transmit the pixel value to the display device. The rendering unit may render the line sample values with a narrower width to pre-compensate for the line-expanding effect of the filtering performed by the sample-to-pixel calculation unit.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06947057&OS=06947057&RS=06947057
owner: Sun Microsystems, Inc.
number: 06947057
owner_city: Santa Clara
owner_country: US
publication_date: 20001229
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF SEVERAL EMBODIMENTS"],"p":["This application claims the benefit of U.S. Provisional Application No. 60\/189,994, filed Mar. 17, 2000, titled \u201cGRAPHICS SYSTEM HAVING A SUPER-SAMPLED SAMPLE BUFFER AND HAVING SINGLE SAMPLE PER PIXEL SUPPORT\u201d by N. David Naegle, Scott R. Nelson, and Michael Deering.","This application claims the benefit of U.S. Provisional Application No. 60\/175,384, filed on Jan. 11, 2000, titled \u201cPhotorealistic Hardware Antialiasing\u201d and U.S. Provisional Application No. 60\/243,674, filed on Oct. 26, 2000, titled \u201cRenderig Lines With Sample Weighting\u201d.","1. Field of the Invention","This invention relates generally to the field of computer graphics and, more particularly, to high performance graphics systems.","2. Description of the Related Art","A computer system typically relies upon its graphics system for producing visual output on a computer screen or display device. Early graphics systems were only responsible for taking what the processor produced as output and displaying it on the screen. In essence, they acted as simple translators or interfaces. Modern graphics systems, however, incorporate graphics processors with a great deal of processing power. The graphics systems now act more like coprocessors rather than simple translators. This change is due to the recent increase in both the complexity and amount of data being sent to the display device. For example, modem computer displays have many more pixels, greater color depth, and are able to display images with higher refresh rates than earlier models. Similarly, the images displayed are now more complex and may involve advanced rendering and visual techniques such as anti-aliasing and texture mapping.","As a result, without considerable processing power in the graphics system, the computer's system CPU would spend a great deal of time performing graphics calculations. This could rob the computer system of the processing power needed for performing other tasks associated with program execution and thereby dramatically reduce overall system performance. With a powerful graphics system, however, when the CPU is instructed to draw a box on the screen, the CPU is freed from having to compute the position and color of each pixel. Instead, the CPU may send a request to the video card stating: \u201cdraw a box at these coordinates\u201d. The graphics system then draws the box, freeing the CPU to perform other tasks.","Generally, a graphics system in a computer (also referred to as a graphics system) is a type of video adapter that contains its own processor to boost performance levels. These processors are specialized for computing graphical transformations, so they tend to achieve better results than the general-purpose CPU used by the computer system. In addition, they free up the computer's CPU to execute other commands while the graphics system is handling graphics computations. The popularity of graphical applications, and especially multimedia applications, has made high performance graphics systems a common feature of computer systems. Most computer manufacturers now bundle a high performance graphics system with their systems.","Since graphics systems typically perform only a limited set of functions, they may be customized and therefore far more efficient at graphics operations than the computer's general-purpose microprocessor. While early graphics systems were limited to performing two-dimensional (2D) graphics, their functionality has increased to support three-dimensional (3D) wire-frame graphics, 3D solids, and now includes support for textures and special effects such as advanced shading, fogging, alpha-blending, and specular highlighting.","The rendering ability of 3D graphics systems has been improving at a breakneck pace. A few years ago, shaded images of simple objects could only be rendered at a few frames per second, but today's systems support rendering of complex objects at 60 Hz or higher. At this rate of increase, in the not too distant future, graphics systems will literally be able to render more pixels in \u201creal-time\u201d than a single human's visual system can perceive. While this extra performance may be useable in multiple-viewer environments, it may be wasted in the more common single-viewer environments. Thus, a graphics system is desired which is capable of utilizing the increased graphics processing power to generate images that are more realistic.","While the number of pixels and frame rate is important in determining graphics system performance, another factor of equal or greater importance is the visual quality of the image generated. For example, an image with a high pixel density may still appear unrealistic if edges within the image are too sharp or jagged (also referred to as \u201caliased\u201d). One well-known technique to overcome these problems is anti-aliasing. Anti-aliasing involves smoothing the edges of objects by shading pixels along the borders of graphical elements. More specifically, anti-aliasing entails removing higher frequency components from an image before they cause disturbing visual artifacts. For example, anti-aliasing may soften or smooth high contrast edges in an image by forcing certain pixels to intermediate values (e.g., around the silhouette of a bright object superimposed against a dark background).","Another visual effect used to increase the realism of computer images is alpha blending. Alpha blending is a technique that controls the transparency of an object, allowing realistic rendering of translucent surfaces such as water or glass. Another effect used to improve realism is fogging. Fogging obscures an object as it moves away from the viewer. Simple fogging is a special case of alpha blending in which the degree of alpha changes with distance so that the object appears to vanish into a haze as the object moves away from the viewer. This simple fogging may also be referred to as \u201cdepth cueing\u201d or atmospheric attenuation, i.e., lowering the contrast of an object so that it appears less prominent as it recedes. More complex types of fogging go beyond a simple linear function to provide more complex relationships between the level of translucence and an object's distance from the viewer. Current state of the art software systems go even further by utilizing atmospheric models to provide low-lying fog with improved realism.","While the techniques listed above may dramatically improve the appearance of computer graphics images, they also have certain limitations. In particular, they may introduce their own aberrations and are typically limited by the density of pixels displayed on the display device.","As a result, a graphics system is desired which is capable of utilizing increased performance levels to increase not only the number of pixels rendered but also the quality of the image rendered. In addition, a graphics system is desired which is capable of utilizing increases in processing power to improve the results of graphics effects such as anti-aliasing.","Prior art graphics systems have generally fallen short of these goals. Prior art graphics systems use a conventional frame buffer for refreshing pixel\/video data on the display. The frame buffer stores rows and columns of pixels that exactly correspond to respective row and column locations on the display. Prior art graphics systems render 2D and\/or 3D images or objects into the frame buffer in pixel form, and then read the pixels from the frame buffer during a screen refresh to refresh the display. Thus, the frame buffer stores the output pixels that are provided to the display. To reduce visual artifacts that may be created by refreshing the screen at the same time the frame buffer is being updated, most graphics systems' frame buffers are double-buffered.","To obtain images that are more realistic, some prior art graphics systems have gone further by generating more than one sample per pixel. As used herein, the term \u201csample\u201d refers to calculated color information that indicates the color, depth (z), and potentially other information, of a particular point on an object or image. For example, a sample may comprise the following component values: a red value, a green value, a blue value, a z value, and an alpha value (e.g., representing the transparency of the sample). A sample may also comprise other information, e.g., a z-depth value, a blur value, an intensity value, brighter-than-bright information, and an indicator that the sample consists partially or completely of control information rather than color information (i.e., \u201csample control information\u201d). By calculating more samples than pixels (i.e., super-sampling), a more detailed image is calculated than can be displayed on the display device. For example, a graphics system may calculate four samples for each pixel to be output to the display device. After the samples are calculated, they are then combined or filtered to form the pixels that are stored in the frame buffer and then conveyed to the display device. Using pixels formed in this manner may create a more realistic final image because overly abrupt changes in the image may be smoothed by the filtering process.","These prior art super-sampling systems typically generate a number of samples that are far greater than the number of pixel locations on the display. These prior art systems typically have rendering processors that calculate the samples and store them into a render buffer. Filtering hardware then reads the samples from the render buffer, filters the samples to create pixels, and then stores the pixels in a traditional frame buffer. The traditional frame buffer is typically double-buffered, with one side being used for refreshing the display device while the other side is updated by the filtering hardware. Once the samples have been filtered, the resulting pixels are stored in a traditional frame buffer that is used to refresh to display device. These systems, however, have generally suffered from limitations imposed by the conventional frame buffer and by the added latency caused by the render buffer and filtering. Therefore, an improved graphics system is desired which includes the benefits of pixel super-sampling while avoiding the drawbacks of the conventional frame buffer.","In certain cases, filtering may generate undesirable results, for example, when filtering lines or other objects that have already been anti-aliased. Line segments drawn using rectangular grids, other than vertical and horizontal lines, typically appear jaggy without anti-aliasing. In order to make these lines appear less jaggy, prior to super-sampling\/filtering techniques, anti-aliasing methods were used. However, when filtering is applied to lines that have already been anti-aliased, the lines may appear to be wider beyond a desirable level. Therefore, a method and system are desired to correctly render anti-aliased lines in a super-sampling\/filtering environment.","The present invention comprises a computer graphics system that utilizes a super-sampled sample buffer and one or more programmable sample-to-pixel calculation units for refreshing the display. In one embodiment, the graphics system may have a graphics processor configured to render (or draw) the samples, a super-sampled sample buffer, and a sample-to-pixel calculation unit.","The graphics processor may generate a plurality of samples (based on a selected set of sample positions) and store the samples into a sample buffer. The graphics processor preferably generates and stores more than one sample for at least a subset of the pixel locations on the display. Thus, the sample buffer is a super-sampled (also referred to as \u201cover-sampled\u201d) sample buffer that stores a number of samples that, in some embodiments, may be far greater than the number of pixel locations on the display. In other embodiments, the total number of samples may be closer to, equal to, or even less than the total number of pixel locations on the display device, but the samples may be more densely positioned in certain areas and less densely positioned in other areas.","The sample-to-pixel calculation unit is configured to read the samples from the super-sampled sample buffer and filter or convolve the samples into respective output pixels, wherein the output pixels are then provided to refresh the display. As used herein, the terms \u201cfilter\u201d and \u201cconvolve\u201d are used interchangeably and refer to mathematically manipulating one or more samples to generate a pixel (e.g., by averaging, by applying a convolution function, by summing, by applying a filtering function, by weighting the samples and then manipulating them, by applying a randomized function, etc.). The sample-to-pixel calculation unit selects one or more samples and filters them to generate an output pixel. The number of samples selected and or filtered by the sample-to-pixel calculation unit may be one or, in the preferred embodiment, greater than one, but this may vary depending upon the exact implementation.","In some embodiments, the number of samples used to form each pixel may vary. For example, the underlying average sample density in the sample buffer may vary, the extent of the filter may vary, and\/or the number of samples for a particular pixel may vary due to stochastic variations in the sample density. In some embodiments, the average number of samples contributing to a pixel may vary on a per-pixel basis, on a per-scan line basis, on a per-region basis, on a per-frame basis, or the number may remain constant. The sample-to-pixel calculation unit may access the samples from the super-sampled sample buffer, perform a real-time filtering operation, and then provide the resulting output pixels to the display in real-time. The graphics system may operate without a conventional frame buffer, i.e., the graphics system does not utilize a conventional frame buffer that stores the actual pixel values that are being refreshed on the display. Note some displays may have internal frame buffers, but these are considered an integral part of the display device, not the graphics system. Thus, the sample-to-pixel calculation units may calculate each pixel for each screen refresh \u201con-the-fly\u201d. As used herein, the term \u201con-the-fly\u201d refers to a function that is performed at or near the display device's refresh rate\u201d. For example, filtering samples \u201con-the-fly\u201d means calculating enough output pixels at a rate high enough to support the refresh rate of a display device. \u201cReal-time\u201d means at, near, or above the human visual system's perception capabilities for motion fusion (how often a picture must be changed to give the illusion of continuous motion) and flicker fusion (how often light intensity must be changed to give the illusion of continuous). These concepts are further described in the book \u201cSpatial Vision\u201d by Russel L. De Valois and Karen K. De Valois, Oxford University Press, 1988.","Line-draw commands are typically among the graphics instructions received by the graphics system. A command for drawing a line on a display may provide, in one embodiment, coordinates for the two line ends, color information (e.g., R, G, B), as well as other attributes (such as an alpha transparency value, a depth z value, and texture coordinates, etc.).","In one set of embodiments, the graphics system may comprise a sample buffer, a rendering unit and a sample-to-pixel calculation unit. The rendering unit may be configured to:\n\n","The sample-to-pixel calculation unit may be configured to read one or more of the sample values from the sample buffer, operate on (e.g. spatially filter) the one or more sample values to determine a pixel value, and transmit the pixel value to a display device.","The sample normal distance of a sample may be defined as the perpendicular distance between the sample and the line segment. The rendering unit may compute the sample normal distance for a sample by determining a vertical displacement (or horizontal displacement) between the sample and the line segment, and multiplying the vertical distance (or horizontal displacement) by a correction factor which depends on the line of the line segment. The correction factor may be stored in a lookup table. The lookup table may contain correction factors for slope values spanning an interval such as [\u22121,1].","The rendering unit may evaluate a window function (e.g. by table lookup) for each of said sample positions based on the corresponding sample normal distances. The window function value thereby obtained may be used to determine the sample value (e.g. color value and\/or transparency value) at the corresponding sample position. The window function achieves a smooth transition of sample values in the direction normal to the line segment. In one embodiment, the window function achieves a smooth transition of transparency values from totally opaque on the line segment to totally transparency at some normal distance away from the line segment. In another embodiment, the window function achieves a smooth transition of color values from a line color value on the line segment to background color value(s) at some distance away from the line segment.","The sample-to-pixel calculation units may perform filtering on sample values to generate pixel values. This filtering has an expanding effect on the width of the displayed lines. In some embodiments, the rendering unit may be configured to evaluate the window function on a scalar multiple of the sample normal distances instead of the sample normal distances themselves. In other words, the sample normal distances may be multiplied by an anti-aliasing correction factor to obtain a scaled distance value. The scaled distance value may be used to evaluate the window function. When the anti-aliasing correction factor is greater than one, the line as represented in terms of the sample values is narrower in the normal direction. The narrower line in terms of sample values pre-compensates for the line-expanding effect of the filtering in the sample-to-pixel calculation units. Thus, the line as displayed on screen may appear more consistent with a desired width. As the anti-aliasing correction factor is increased, the apparent width of the line on screen (e.g. on a display screen or a projection screen) is reduced.","The window function may have a wide variety of functional forms. In one embodiment, the window function is a Gaussian function. The window function may transition (not necessarily monotonically) from one to zero as the absolute value of sample normal distance increases from zero to some positive value.","In some embodiments, the anti-aliasing correction factor (ACF) may be controlled by user input. For example, in one embodiment, the graphics system couples to a host computer, and the host computer may support a graphical user interface through which the user may control the anti-aliasing correction factor. The user may supply control inputs (e.g. may manipulate a graphical icon using an input device such as a mouse) to increase and\/or decrease the anti-aliasing correction factor until the size of lines displayed on screen have a desired width.","While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents, and alternatives falling within the spirit and scope of the present invention as defined by the appended claims. Please note that the headings are for organizational purposes only and are not meant to limit the description or claims. The word \u201cmay\u201d is used in this application in a permissive sense (i.e., having the potential to, being able to), not a mandatory sense (i.e., must). Similarly, the word include, and derivations thereof, are used herein to mean \u201cincluding, but not limited to.\u201d","FIG. \u2014Computer System",{"@attributes":{"id":"p-0063","num":"0066"},"figref":"FIG. 1","b":["80","80","82","84","84","84","84","84","84","84","84"],"sub":["1 ","G","1 ","G ","1 ","G "]},"Various input devices may be connected to system unit , including a keyboard , a mouse , a video camera, a trackball, a digitizing tablet, a six-degree of freedom input device, a head tracker, an eye tracker, a data glove, body sensors, a touch-sensitive screen, etc. Application software may be executed by computer system  to display 3-D graphical objects on projection screen SCR and\/or monitor devices A and B. It is noted that projection devices PDthrough PDmay project their respective component images onto a surface other than a conventional projection screen, and\/or onto surfaces that are curved (e.g. the retina of a human eye).","FIG. \u2014Computer System Block Diagram",{"@attributes":{"id":"p-0065","num":"0068"},"figref":"FIG. 2","b":["80","80","102","112","104","106","104","104"]},"Host CPU  may be realized by any of a variety of processor technologies. For example, host CPU  may comprise one or more general purpose microprocessors, parallel processors, vector processors, digital signal processors, etc., or any combination thereof. System memory  may include one or more memory subsystems representing different types of memory technology. For example, system memory  may include read-only memory (ROM) and\/or random access memory (RAM)\u2014such as static random access memory (SRAM), synchronous dynamic random access memory (SDRAM) and\/or Rambus dynamic access memory (RDRAM).","System bus  may comprise one or more communication buses or host computer buses (e.g., for communication between host processors and memory subsystems). In addition, various peripheral devices and peripheral buses may be connected to system bus .","Graphics system  may comprise one or more graphics boards. The graphics boards may couple to system bus  by any of a variety of connectivity technologies (e.g. crossbar switches). The graphics boards may generate video signals for display devices DDthrough DDin response to graphics commands and data received from one or more graphics applications executing on host CPU . Display devices DDthrough DDmay include monitor devices A and B, and projection device PDthrough PD.  illustrates one embodiment of a graphics board GB for enhancing 3D-graphics performance.","Graphics board GB may couple to one or more busses of various types in addition to system bus . Furthermore, graphics board GB may couple to a communication port, and thereby, directly receive graphics data from an external source such as the Internet or a local area network.","Host CPU  may transfer information to\/from graphics board GB according to a programmed input\/output (I\/O) protocol over system bus . Alternately, graphics board GB may access system memory  according to a direct memory access (DMA) protocol or through intelligent bus mastering.","A graphics application, e.g. an application conforming to an application programming interface (API) such as OpenGL\u00ae or Java\u00ae 3D, may execute on host CPU  and generate commands and data that define geometric primitives such as polygons for output on display devices DDthrough DD. Host CPU  may transfer this graphics data to system memory . Thereafter, the host CPU  may transfer the graphics data to graphics board GB over system bus . In another embodiment, graphics board GB may read geometry data arrays from system memory  using DMA access cycles. In yet another embodiment, graphics board GB may be coupled to system memory  through a direct port, such as an Advanced Graphics Port (AGP) promulgated by Intel Corporation.","Graphics board GB may receive graphics data from any of various sources including host CPU , system memory  or any other memory, external sources such as a network (e.g., the Internet) or a broadcast medium (e.g. television). While graphics board GB is described above as a part of computer system , graphics board GB may also be configured as a stand-alone device.","Graphics board GB may be comprised in any of various systems including a network PC, an Internet appliance, a game console, a virtual reality system, a CAD\/CAM station, a simulator (e.g. an aircraft flight simulator), a television (e.g. an HDTV system or an interactive television system), or other devices which display 2D and\/or 3D graphics.","As shown in , graphics board GB may comprise a graphics processing unit (GPU) , a super-sampled sample buffer , and one or more sample-to-pixel calculation units - through -V. Graphics board GB may also comprise one or more digital-to-analog converters (DACs) A-B.","Graphics processing unit  may comprise any combination of processing technologies. For example, graphics processing unit  may comprise specialized graphics processors or calculation units, multimedia processors, DSPs, general-purpose processors, reconfigurable logic (e.g. programmable gate arrays), dedicated ASIC chips, etc.","In one embodiment, graphics processing unit  may comprise one or more rendering units A-D. Graphics processing unit  may also comprise one or more control units , and one or more schedule units . Sample buffer  may comprise one or more sample memories A-P.","A. Control Unit ","Control unit  operates as the interface between graphics board GB and CPU , i.e. controls the transfer of data between graphics board GB and CPU . In embodiments where rendering units A-D comprise two or more rendering units, control unit  may also divide a stream of graphics data received from CPU  and\/or system memory  into a corresponding number of parallel streams that are routed to the individual rendering units.","The graphics data stream may be received from CPU  and\/or system memory  in a compressed form. Graphics data compression may advantageously reduce the required transfer bandwidth for the graphics data stream. In one embodiment, control unit  may be configured to split and route the received data stream to rendering units A-D in compressed form.","The graphics data may comprise graphics primitives. As used herein, the term graphics primitive includes polygons, parametric surfaces, splines, NURBS (non-uniform rational B-splines), sub-division surfaces, fractals, volume primitives, and particle systems. These graphics primitives are described in detail in the textbook entitled \u201cComputer Graphics: Principles and Practice\u201d by James D. Foley, et al., published by Addison-Wesley Publishing Co., Inc., 1996.","It is noted that the embodiments and examples presented herein are described in terms of polygons (e.g. triangles) for the sake of simplicity. However, any type of graphics primitive may be used instead of or in addition to polygons in these embodiments and examples.","B. Rendering Units A-D","Each of rendering units A-D (also referred to herein as draw units) may receive a stream of graphics data from control unit , and perform a number of functions in response to the graphics stream. For example, each of rendering units A-D may be configured to perform decompression (if the received graphics data is presented in compressed form), transformation, clipping, lighting, texturing, depth cueing, transparency processing, setup, and virtual screen-space rendering of graphics primitives occurring within the graphics stream. Each of rendering units A-D may comprise one or more processors (e.g. specialized graphics processors, digital signal processors, general purpose processors, etc.) and\/or specialized circuitry (e.g. ASIC chips).","In one embodiment, each of rendering units A-D may be configured in accord with rendering unit J illustrated in FIG. B. Rendering unit J may comprise a first rendering unit  and second rendering unit . First rendering unit  may be configured to perform decompression (for compressed graphics data), format conversion, transformation, lighting, etc. Second rendering unit  may be configured to perform setup computations, virtual screen space rasterization, sample rendering, etc. First rendering unit  may be coupled to first data memory , and second rendering unit  may be coupled to second data memory . First data memory  may comprise RDRAM, and second data memory  may comprise SDRAM. First rendering unit  may comprise one or more processors such as media processors. Second rendering unit  may comprise a dedicated ASIC chip.","Depending upon the type of compressed graphics data received, rendering units A-D may be configured to perform arithmetic decoding, run-length decoding, Huffman decoding, and dictionary decoding (e.g., LZ, LZSS, LZ, and LZW). Rendering units A-D may also be configured to decode graphics data that has been compressed using geometric compression. Geometric compression of 3D graphics data may achieve significant reductions in data size while retaining most of the image quality. A number of methods for compressing and decompressing 3D geometry are described in:\n\n","Rendering units A-D may be configured to perform transformation. Transformation refers to applying a geometric operation to a primitive or an object comprising a set of primitives. For example, an object represented by a set of vertices in a local coordinate system may be embedded with arbitrary position, orientation, and size in world space using an appropriate sequence of translation, rotation, and scaling transformations. Transformation may also comprise reflection, skewing, or any other affine transformation. More generally, transformations may comprise non-linear operations.","Rendering units A-D may be configured to perform lighting. Lighting refers to calculating the illumination of the objects. Lighting computations result in an assignment of color and\/or brightness to objects or to selected points (e.g. vertices) on objects. Depending upon the shading algorithm being used (e.g., constant, Gouraud, or Phong shading), lighting may be evaluated at a number of different locations. For example, if constant shading is used (i.e., the lighted surface of a polygon is assigned a constant illumination value), then the lighting need only be calculated once per polygon. If Gouraud shading is used, then the lighting is calculated once per vertex. Phong shading calculates the lighting on a per-sample basis.","Rendering units A-D may be configured to perform clipping. Clipping refers to the elimination of primitives or portions of primitives, which lie outside a clipping region (e.g. a two-dimensional viewport rectangle). For example, the clipping of a triangle to the two-dimensional viewport may result in a polygon (i.e. the polygon which lies interior to the triangle and the rectangle). The resultant polygon may be fragmented into sub-primitives (e.g. triangles). In the preferred embodiment, only primitives (or portions of primitives) which survive the clipping computation are rendered in terms of samples.","Rendering units A-D may be configured to perform virtual screen space rendering. Virtual screen space rendering refers to calculations that are performed to generate samples for graphics primitives. For example, the vertices of a triangle in 3-D may be projected onto the 2-D viewport. The projected triangle may be populated with samples, and ordinate values (e.g. red, green, blue, alpha, Z, etc.) may be assigned to the samples based on the corresponding ordinates values already determined for the projected vertices. (For example, the red value for each sample in the projected triangle may be interpolated from the known red values of the vertices.) These sample ordinate values for the projected triangle may be stored in sample buffer . A virtual image accumulates in sample buffer  as successive primitives are rendered. Thus, the 2-D viewport is said to be a virtual screen on which the virtual image is rendered. The sample ordinate values comprising the virtual image are stored into sample buffer . Points in the 2-D viewport are described in terms of virtual screen coordinates X and Y, and are said to reside in virtual screen space.","When the virtual image is complete, e.g., when all graphics primitives have been rendered, sample-to-pixel calculation units  may access the samples comprising the virtual image, and may filter the samples to generate pixel ordinate values (e.g. red, green, blue, alpha, etc.). In other words, the sample-to-pixel calculation units  may perform a spatial convolution of the virtual image with respect to a convolution kernel C(X,Y) to generate pixel ordinate values. For example, a sample-to-pixel calculation unit may compute a red value Rfor a pixel P at any location (X,Y) in virtual screen space based on the relation \n\n\nwhere the summation is evaluated at sample positions (X,Y) in a neighborhood of location (X,Y), and where R(X,Y) are the red values corresponding to sample positions (X,Y). Since convolution kernel C(X,Y) may be non-zero only in a neighborhood of the origin, the displaced kernel C(X\u2212X,Y\u2212Y) may take non-zero values only in a neighborhood of location (X,Y). Similar summations to compute other pixel ordinate values (e.g. green, blue, alpha, etc.) in terms of the corresponding sample ordinate values may be performed. In the preferred embodiment, some or all of the pixel ordinate value summations may be performed in parallel.\n","The value E is a normalization value that may be computed according to the relation\n\n(),\n\nwhere the summation is evaluated for the same samples (X,Y) as in the red pixel value summation above. The summation for the normalization value E may be performed in parallel with the red, green, blue, and\/or alpha pixel value summations. The location (X,Y) may be referred to as a pixel center, or a pixel origin. The pixel ordinate values (e.g. RGB) may be presented to one or more of display devices DDthrough DD.\n","In the embodiment of graphics board GB shown in , rendering units A-D compute sample values instead of pixel values. This allows rendering units A-D to perform super-sampling, i.e. to compute more than one sample per pixel. Super-sampling is discussed more thoroughly below. More details on super-sampling are discussed in the following books:\n\n","Sample buffer  may be double-buffered so that rendering units A-D may write samples for a first virtual image into a first portion of sample buffer , while a second virtual image is simultaneously read from a second portion of sample buffer  by sample-to-pixel calculation units .","It is noted that the 2-D viewport and the virtual image, which is rendered with samples into sample buffer , may correspond to an area larger than the area which is physically displayed via display devices DDthrough DD. For example, the 2-D viewport may include a viewable subwindow. The viewable subwindow may represent displayable graphics information, while the marginal area of the 2-D viewport (outside the viewable subwindow) may allow for various effects such as panning and zooming. In other words, only that portion of the virtual image which lies within the viewable subwindow gets physically displayed. In one embodiment, the viewable subwindow equals the whole of the 2-D viewport. In this case, all of the virtual image gets physically displayed.","C. Data Memories","In some embodiments, each of rendering units A-D may be configured with two memories similar to rendering unit J of FIG. B. First memory  may store data and instructions for rendering unit . Second memory  may store data and\/or instructions for second rendering unit . While implementations may vary, in one embodiment memories  and  may comprise two 8 MByte SDRAMs providing 16 MBytes of storage for each rendering unit A-D. Memories  and  may also comprise RDRAMs (Rambus DRAMs). In one embodiment, RDRAMs may be used to support the decompression and setup operations of each rendering unit, while SDRAMs may be used to support the draw functions of each rendering unit.","D. Schedule Unit","Schedule unit  may be coupled between rendering units A-D and sample memories A-P. Schedule unit  is configured to sequence the completed samples and store them in sample memories A-P. Note in larger configurations, multiple schedule units  may be used in parallel. In one embodiment, schedule unit  may be implemented as a crossbar switch.","E. Sample Memories","Super-sampled sample buffer  comprises sample memories A-P, which are configured to store the plurality of samples generated by rendering units A-D. As used herein, the term \u201csample buffer\u201d refers to one or more memories which store samples. As previously noted, samples may be filtered to form each pixel ordinate value. Pixel ordinate values may be provided to one or more of display devices DDthrough DD. Sample buffer  may be configured to support super-sampling, critical sampling, or sub-sampling with respect to pixel resolution. In other words, the average distance between adjacent samples in the virtual image (stored in sample buffer ) may be smaller than, equal to, or larger than the average distance between adjacent pixel centers in virtual screen space. Furthermore, because the convolution kernel C(X,Y) may take non-zero functional values over a neighborhood which spans several pixel centers, a single sample may contribute to several pixels.","Sample memories A-P may comprise any of various types of memories (e.g., SDRAMs, SRAMs, RDRAMs, 3DRAMs, or next-generation 3DRAMs) in varying sizes. In one embodiment, each schedule unit  is coupled to four banks of sample memories, where each bank comprises four 3DRAM-64 memories. Together, the 3DRAM-64 memories may form a 116-bit deep super-sampled sample buffer that stores multiple samples per pixel. For example, in one embodiment, each of sample memories A-P may store up to sixteen samples per pixel.","3DRAM-64 memories are specialized memories configured to support full internal double buffering with single-buffered Z in one chip. The double-buffered portion comprises two RGBX buffers, where X is a fourth channel that can be used to store other information (e.g., alpha). 3DRAM-64 memories also have a lookup table that takes in window ID information and controls an internal 2-1 or 3-1 multiplexor that selects which buffer's contents will be output. 3DRAM-64 memories are next-generation 3DRAM memories that may soon be available from Mitsubishi Electric Corporation's Semiconductor Group. In one embodiment, 32 chips used in combination are sufficient to create a double-buffered 1280\u00d71024 super-sampled sample buffer with eight samples per pixel.","Since the 3DRAM-64 memories are internally double-buffered, the input pins for each of the two frame buffers in the double-buffered system are time multiplexed (using multiplexors within the memories). The output pins may be similarly time multiplexed. This allows reduced pin count while still providing the benefits of double buffering. 3DRAM-64 memories further reduce pin count by not having Z output pins. Since Z comparison and memory buffer selection are dealt with internally, use of the 3DRAM-64 memories may simplify the configuration of sample buffer . For example, sample buffer  may require little or no selection logic on the output side of the 3DRAM-64 memories. The 3DRAM-64 memories also reduce memory bandwidth since information may be written into a 3DRAM-64 memory without the traditional process of reading data out, performing a Z comparison, and then writing data back in. Instead, the data may be simply written into the 3DRAM-64 memory, with the memory performing the steps described above internally.","Each of rendering units A-D may be configured to generate a plurality of sample positions according to one or more sample positioning schemes. For example, in one embodiment, samples may be positioned on a regular grid. In another embodiment, samples may be positioned based on perturbations (i.e. displacements) from a regular grid. This perturbed-regular grid-positioning scheme may generate random sample positions if the perturbations are random or pseudo-random values. In yet another embodiment, samples may be randomly positioned according to any of a variety of methods for generating random number sequences.","The sample positions (or offsets that are added to regular grid positions to form the sample positions) may be read from a sample position memory (e.g., a RAM\/ROM table). Upon receiving a polygon that is to be rendered, a rendering unit may determine which samples fall within the polygon based upon the sample positions. The rendering unit may render the samples that fall within the polygon, i.e. interpolate ordinate values (e.g. color values, alpha, depth, etc.) for the samples based on the corresponding ordinate values already determined for the vertices of the polygon. The rendering unit may then store the rendered samples in sample buffer . Note as used herein the terms render and draw are used interchangeably and refer to calculating ordinate values for samples.","F. Sample-to-pixel Calculation Units","Sample-to-pixel calculation units - through -V (collectively referred to as sample-to-pixel calculation units ) may be coupled between sample memories A-P and DACs A-B. Sample-to-pixel calculation units  are configured to read selected samples from sample memories A-P and then perform a filtering operation (e.g. a convolution) on the samples to generate the output pixel values which are provided to one or more of DACs A-B. Sample-to-pixel calculation units  may be programmable to perform different filter functions at different times depending upon the type of output desired.","In one embodiment, sample-to-pixel calculation units  may implement a super-sample reconstruction band-pass filter to convert the super-sampled sample buffer data (stored in sample memories A-P) to pixel values. The support of the band-pass filter may cover a rectangular area in virtual screen space which is Lpixels high and Wpixels wide. Thus, the number of samples covered by the band-pass filter is approximately equal to HWS, where S is the number of samples per pixel. A variety of values for L, Wand S are contemplated. For example, in one embodiment of the band-pass filter L=W=5. It is noted that with certain sample positioning schemes (see the discussion attending , A & B), the number of samples that fall within the filter support may vary as the filter center (i.e. pixel center) is moved in the virtual screen space.","In other embodiments, sample-to-pixel calculation units  may filter a selected number of samples to calculate an output pixel. The selected samples may be multiplied by a spatial weighting function that gives weights to samples based on their position with respect to the center of the pixel being calculated.","The filtering operations performed by sample-to-pixel calculation units  may use any of a variety of filters. For example, the filtering operations may comprise convolution with a box filter, a tent filter, a cylindrical filter, a cone filter, a Gaussian filter, a Catmull-Rom filter, a Mitchell-Netravali filter, a windowed sinc filter, etc., or any combination thereof. Furthermore, the support of the filters used by sample-to-pixel calculation units  may be circular, elliptical, rectangular (e.g. square), triangular, hexagonal, etc.","Sample-to-pixel calculation units  may also be configured with one or more of the following features: color look-up using pseudo color tables, direct color, inverse gamma correction, and conversion of pixels to non-linear light space. Other features of sample-to-pixel calculation units  may include programmable video timing generators, programmable pixel clock synthesizers, cursor generators, and crossbar functions.","Once the sample-to-pixel calculation units  have computed color values for pixels, e.g. pixels in a scan line, the pixels may output to one or more video output channels through DACs A-B.","G. Digital-to-Analog Converters","Digital-to-Analog Converters (DACs) A-B, collectively referred to as DACs , operate as the final output stage of graphics board GB. DACs  translate digital pixel data received from sample-to-pixel calculation units  into analog video signals. DAC A couples to output video channel A, and DAC B couples to output video channel B. DAC A may receive a first stream of digital pixel data from one or more of sample-to-pixel calculation units , and converts the first stream into a first video signal which is asserted onto output video channel A. Similarly, DAC B may receive a second stream of digital pixel data from one or more of sample-to-pixel calculation units , and converts the second stream into a second video signal which is asserted onto output video channel B.","In the preferred embodiment, sample-to-pixel calculation units  provide pixel values to DACs  without an intervening frame buffer. However, in one alternate embodiment, sample-to-pixel calculation units  output the pixel values to a frame buffer prior to display.","In one embodiment, some or all of DACs  may be bypassed or omitted in order to output digital pixel data in lieu of analog video signals. This may be useful where some or all of display devices DDthrough DDare based on a digital technology (e.g., an LCD-type display, an LCOS display, or a digital micro-mirror display).","In the preferred embodiment, multiple graphics boards may be chained together so that they share the effort of generating video data for a display device. Thus, in the preferred embodiment, graphics board GB includes a first interface for receiving one or more digital video streams from any previous graphics board in the chain, and a second interface for transmitting digital video streams to any subsequent graphics board in the chain.","It is noted that various embodiments of graphics board GB are contemplated with varying numbers of rendering units, schedule units, sample-to-pixel calculation units, sample memories, more or less than two DACs, more or less than two video output channels, etc.",{"@attributes":{"id":"h-0008","num":"0000"},"figref":"FIGS. 4","b":["5","5"]},{"@attributes":{"id":"p-0119","num":"0127"},"figref":"FIG. 4","b":["150","74","70","150","170"]},"Turning now to , an example of one embodiment of super-sampling is illustrated. In this embodiment, rendering units A-D compute two samples per pixel. The samples are distributed according to a regular grid. Even though there are more samples than pixels in , sample-to-pixel calculation units  could compute output pixel values using one sample per pixel, e.g. by throwing out all but the sample nearest to the center of each pixel. However, a number of advantages arise from computing pixel values based on multiple samples.","A support region  is superimposed over pixel , and illustrates the support of a filter which is localized at pixel . The support of a filter is the set of locations over which the filter (i.e. the filter kernel) takes non-zero values. In this example, the support region  is a circular disc. A sample-to-pixel calculation unit may perform a filtering operation using any of a variety of filters which have region  as their support region. Thus, the sample-to-pixel calculation unit may compute the output pixel values (e.g. red, green, blue and Z values) for pixel  based only on samples A and B, because these are the only samples which fall within region . This filtering operation may advantageously improve the realism of a displayed image by smoothing abrupt edges in the displayed image (i.e., by performing anti-aliasing). The filtering operation may simply average the values of samples A-B to form the corresponding output values of pixel . More generally, the filtering operation may generate a weighted sum of the values of samples A-B, where the contribution of each sample is weighted according to some function of the sample's position (or distance) with respect to the center of pixel . The filter, and thus support region , may be repositioned for each output pixel being calculated. In other words, the filter center may visit the center of each output pixel for which pixel values are to be computed. Other filters and filter positioning schemes are also possible and contemplated.","In the example of , there are two samples per pixel. In general, however, there is no requirement that the number of samples be related to the number of pixels. The number of samples may be completely independent of the number of pixels. For example, the number of samples may be smaller than the number of pixels. (This is the condition that defines sub-sampling).","Turning now to , another embodiment of super-sampling is illustrated. In this embodiment, the samples are positioned randomly. Thus, the number of samples used to calculate output pixel values may vary from pixel to pixel. Rendering units A-D calculate color information at each sample position.","FIGS. -\u2014Super-sampled Sample Buffer with Real-time Convolution",{"@attributes":{"id":"p-0124","num":"0132"},"figref":"FIG. 6","b":["350","352","352","90","140","150","154","350"]},"In addition to the vertex data, draw process  (which may be performed by each of rendering units A-D) also receives sample position information from a sample position memory . The sample position information defines the location of samples in virtual screen space, i.e. in the 2-D viewport. Draw process  selects the samples that fall within the polygon currently being rendered, calculates a set of ordinate values (e.g. red, green, blue, Z, alpha, and\/or depth of field information) for each of these samples based on their respective positions within the polygon. For example, the Z value of a sample that falls within a triangle may be interpolated from the known Z values of the three vertices. Each set of computed sample ordinate values may be stored into sample buffer .","In one embodiment, sample position memory  may be embodied within rendering units A-D. In another embodiment, sample position memory  may be realized as part of as a separate memory, external to rendering units A-D.","Sample position memory  may store sample positions in terms of their virtual screen coordinates (X,Y). Alternatively, sample position memory  may be configured to store only offsets dX and dY for the samples with respect to positions on a regular grid. Storing only the offsets may use less storage space than storing the entire coordinates (X,Y) for each sample. A dedicated sample position unit (not shown) may read and process the sample position information stored in sample position memory  to generate sample positions. More detailed information on the computation of sample positions is included below (see description of FIGS.  and ).","In another embodiment, sample position memory  may be configured to store a table of random numbers. Sample position memory  may also comprise dedicated hardware to generate one or more different types of regular grids. This hardware may be programmable. The stored random numbers may be added as offsets to the regular grid positions generated by the hardware. In one embodiment, sample position memory  may be programmable to access or \u201cunfold\u201d the random number table in a number of different ways, and thus, may deliver more apparent randomness for a given length of the random number table. Thus, a smaller table may be used without generating the visual artifacts caused by simple repetition of sample position offsets.","Sample-to-pixel calculation process  uses the same sample positions as draw process . Thus, in one embodiment, sample position memory  may generate a sequence of random offsets to compute sample positions for draw process , and may subsequently regenerate the same sequence of random offsets to compute the same sample positions for sample-to-pixel calculation process . In other words, the unfolding of the random number table may be repeatable. Thus, it may not be necessary to store sample positions at the time of their generation for draw process .","As shown in , sample position memory  may be configured to generate sample offsets according to a number of different sample-positioning schemes such as a regular grid scheme, a perturbed-regular grid scheme, or a random (i.e. stochastic) positioning scheme. Graphics board GB may receive an indication from the host operating system, device driver, or the geometry data  that indicates which type of sample positioning scheme is to be used. Thus, sample position memory  is configurable or programmable to generate sample position information according to one or more different schemes. More detailed information on several sample-positioning schemes is provided below. See description of FIG. .","In one embodiment, sample position memory  may comprise a RAM\/ROM that contains stochastically determined sample points or sample offsets. Thus, the density of samples in virtual screen space may not be uniform when observed at small scale. Two bins with equal area centered at different locations in virtual screen space may contain different numbers of samples. As used herein, the term \u201cbin\u201d refers to a region or area in virtual screen space.","An array of bins may be superimposed over virtual screen space, i.e. the 2-D viewport, and the storage of samples in sample buffer  may be organized in terms of bins. Sample buffer  may comprise an array of memory blocks which correspond to the bins. Each memory block may store the sample ordinate values (e.g. red, green, blue, Z, alpha, etc.) for the samples that fall within the corresponding bin. The approximate location of a sample is given by the bin in which it resides. The memory blocks may have addresses which are easily computable from the corresponding bin locations in virtual screen space, and vice versa. Thus, the use of bins may simplify the storage and access of sample values in sample buffer .","Suppose (for the sake of discussion) that the 2-D viewport ranges from (0000,0000) to (FFFF,FFFF) in hexadecimal virtual screen coordinates. This 2-D viewport may be overlaid with a rectangular array of bins whose lower-left corners reside at the locations (XX00,YY00) where XX and YY independently run from 0\u00d700 to 0\u00d7FF. Thus, there are 256 bins in each of the vertical and horizontal directions with each bin spanning a square in virtual screen space with side length of 256. Suppose that each memory block is configured to store sample ordinate values for up to 16 samples, and that the set of sample ordinate values for each sample comprises 4 bytes. In this case, the address of the memory block corresponding to the bin located at (XX00,YY00) may be simply computed by the relation BinAddr=(XX+YY*256)*16*4. For example, the sample S=(1C3B,23A7) resides in the bin located at (1C00,2300). The set of ordinate values for sample S is then stored in the memory block residing at address 0\u00d78C700=(0\u00d7231C)(0\u00d740) in sample buffer . The number of bins and numerical ranges given in this example are not meant to be limiting.","The bins may tile the 2-D viewport in a regular array, e.g. in a square array, rectangular array, triangular array, hexagonal array, etc., or in an irregular array. Bins may occur in a variety of sizes and shapes. The sizes and shapes may be programmable. The maximum number of samples that may populate a bin is determined by the storage space allocated to the corresponding memory block. This maximum number of samples is referred to herein as the bin sample capacity, or simply, the bin capacity. The bin capacity may take any of a variety of values. The bin capacity value may be programmable. Henceforth, the spatial bins in virtual screen space and their corresponding memory blocks may be referred to simply as \u201cbins\u201d. The context will determine whether a memory bin or a spatial bin is being referred to.","The specific position of each sample within a bin may be determined by looking up the sample's offset in the RAM\/ROM table, i.e., the sample's offset with respect to the bin position (e.g. the lower-left corner or center of the bin, etc.). However, depending upon the implementation, not all choices for the bin capacity may have a unique set of offsets stored in the RAM\/ROM table. Offsets for a first bin capacity value may be determined by accessing a subset of the offsets stored for a second larger bin capacity value. In one embodiment, each bin capacity value supports at least four different sample-positioning schemes. The use of different sample positioning schemes may reduce final image artifacts that would arise in a scheme of naively repeating sample positions.","In one embodiment, sample position memory  may store pairs of 8-bit numbers, each pair comprising an x-offset and a y-offset. (Other offsets are also possible, e.g., a time offset, a Z-offset, etc.) When added to a bin position, each pair defines a particular position in virtual screen space, i.e. the 2-D viewport. To improve read access times, sample position memory  may be constructed in a wide\/parallel manner so as to allow the memory to output more than one sample position per read cycle.","Once the sample positions have been read from sample position memory , draw process  selects the samples that fall within the polygon currently being rendered. Draw process  then calculates ordinate values (e.g. color values, Z, alpha, depth of field, etc.) for each of these samples and stores the data into sample buffer . In one embodiment, sample buffer  may only single-buffer Z values (and perhaps alpha values) while double-buffering other sample ordinates such as color. Unlike prior art systems, graphics system  may use double-buffering for all samples (although not all components of samples may be double-buffered, i.e., the samples may have some components that are not double-buffered). In one embodiment, the samples are stored into sample buffer  in bins. In some embodiments, the bin capacity may vary from frame to frame. In addition, the bin capacity may vary spatially for bins within a single frame rendered into sample buffer . For example, bins on the edge of the 2-D viewport may have a smaller bin capacity than bins corresponding to the center of the 2-D viewport. Since viewers are likely to focus their attention mostly on the center of the screen SCR, more processing bandwidth may be dedicated to providing enhanced image quality in the center of 2-D viewport. Note that the size and shape of bins may also vary from region to region, or from frame to frame. The use of bins will be described in greater detail below in connection with FIG. .","In parallel with draw process , filter process  is configured to: (a) read sample positions from sample position memory , (b) read corresponding sample values from sample buffer , (c) filter the sample values, and (d) output the resulting output pixel values onto video channels A and\/or B. Sample-to-pixel calculation units  implement filter process . Filter process  is operable to generate the red, green, and blue values for an output pixel based on a spatial filtering of the corresponding data for a selected plurality of samples, e.g. samples falling in a neighborhood of the pixel center. Other values such as alpha may also be generated. In one embodiment, filter process  is configured to: (i) determine the distance of each sample from the pixel center; (ii) multiply each sample's ordinate values (e.g., red, green, blue, alpha) by a filter weight that is a specific (programmable) function of the sample's distance; (iii) generate sums of the weighted ordinates values, one sum per ordinate (e.g. a sum for red, a sum for green, . . . ), and (iv) normalize the sums to generate the corresponding pixel ordinate values. Filter process  is described in greater detail below (see description accompanying , A, and ).","In the embodiment just described, the filter kernel is a function of distance from the pixel center. However, in alternative embodiments, the filter kernel may be a more general function of X and Y displacements from the pixel center. Also, the support of the filter, i.e. the 2-D neighborhood over which the filter kernel takes non-zero values, may not be a circular disk. Any sample falling within the support of the filter kernel may affect the output pixel value being computed.",{"@attributes":{"id":"p-0140","num":"0148"},"figref":"FIG. 7","b":["354","354","354","354","354","354","354","354","354","354","360","354","354","354","352","354","360","354","354","352","360"]},"Yet another alternative embodiment may store tags to offsets with the sample values in super-sampled sample buffer . These tags may be used to look-up the offset (i.e. perturbations) dX and dY associated with each particular sample.","FIGS. -: Sample Positioning Schemes",{"@attributes":{"id":"p-0142","num":"0150"},"figref":"FIG. 8","b":"190"},"In the perturbed regular positioning scheme , sample positions are defined in terms of perturbations from a set of fixed positions on a regular grid or tiling. In one embodiment, the samples may be displaced from their corresponding fixed grid positions by random x and y offsets, or by random angles (ranging from 0 to 360 degrees) and random radii (ranging from zero to a maximum radius). The offsets may be generated in a number of ways, e.g. by hardware based upon a small number of seeds, by reading a table of stored offsets, or by using a pseudo-random function. Once again, perturbed regular grid scheme  may be based on any type of regular grid or tiling. Samples generated by perturbation with respect to a grid or hexagonal tiling may be particularly desirable due to the geometric properties of these configurations.","Stochastic sample positioning scheme  represents a third potential type of scheme for positioning samples. Stochastic sample positioning involves randomly distributing the samples across the 2-D viewport. Random positioning of samples may be accomplished through a number of different methods, e.g., using a random number generator such as an internal clock to generate pseudo-random numbers. Random numbers or positions may also be pre-calculated and stored in memory.","Turning now to , details of one embodiment of perturbed regular positioning scheme  are shown. In this embodiment, samples are randomly offset from a regular square grid by x- and y-offsets. As the enlarged area shows, sample  has an x-offset  that specifies its horizontal displacement from its corresponding grid intersection point . Similarly, sample  also has a y-offset  that specifies its vertical displacement from grid intersection point . The random x-offset  and y-offset  may be limited to a particular range of values. For example, the x-offset may be limited to the range from zero to X, where Xis the width of a grid rectangle. Similarly, the y-offset may be limited to the range from zero to Y, where Yis the height of a grid rectangle. The random offset may also be specified by an angle and radius with respect to the grid intersection point .",{"@attributes":{"id":"p-0146","num":"0154"},"figref":"FIG. 10","b":["192","138","198","124","126","132","138","354"]},"FIG. \u2014Computing Pixels from Samples","As discussed earlier, the 2-D viewport may be covered with an array of spatial bins. Each spatial bin may be populated with samples whose positions are determined by sample position memory . Each spatial bin corresponds to a memory bin in sample buffer . A memory bin stores the sample ordinate values (e.g. red, green, blue, Z, alpha, etc.) for the samples that reside in the corresponding spatial bin. Sample-to-pixel calculation units  (also referred to as convolve units ) are configured to read memory bins from sample buffer  and to convert sample values contained within the memory bins into pixel values.",{"@attributes":{"id":"p-0148","num":"0156"},"figref":"FIG. 11","b":["162","1","4","170","1","170","4","170","1","1","162","170"]},{"@attributes":{"id":"p-0149","num":"0157"},"figref":"FIG. 11","b":["170","170"]},"The amount of the overlap between columns may depend upon the horizontal diameter of the filter support for the filter kernel being used. The example shown in  illustrates an overlap of two bins. Each square (such as square ) represents a single bin comprising one or more samples. Advantageously, this configuration may allow sample-to-pixel calculation units  to work independently and in parallel, with each of the sample-to-pixel calculation units  receiving and convolving samples residing in the memory bins of the corresponding column. Overlapping the columns may prevent visual bands or other artifacts from appearing at the column boundaries for any operators larger than a pixel in extent.","Furthermore, the embodiment of  may include a plurality of bin caches  which couple to sample buffer . In addition, each of bin caches  couples to a corresponding one of sample-to-pixel calculation units . Bin cache -I (where I takes any value from one to four) stores a collection of memory bins from Column I, and serves as a cache for sample-to-pixel calculation unit -I. Bin cache -I may have an optimized coupling to sample buffer  which facilitates access to the memory bins for Column I. Since the convolution calculation for two adjacent convolution centers may involve many of the same memory bins, bin caches  may increase the overall access bandwidth to sample buffer .",{"@attributes":{"id":"p-0152","num":"0160"},"figref":"FIG. 12A","b":["162","400","406","170","400","176","402","404","176","400","400"],"sub":["L ","L ","v ","L ","v "]},"After completing convolution computations at a convolution center, convolution filter kernel  shifts to the next convolution center. Kernel  may be visualized as proceeding horizontally within Column I in the direction indicated by arrow . When kernel  reaches the right boundary  of Column I, it may shift down one or more bin rows, and then, proceed horizontally starting from the left column boundary . Thus the convolution operation proceeds in a scan line fashion, generating successive rows of output pixels for display.","In one embodiment, the cache line-depth parameter Dis set equal to D+1. In the example of , the filter support covers D=5 bins vertically. Thus, the cache line-depth parameter D=6=5+1. The additional bin row in bin cache -I allows the processing of memory bins (accessed from bin cache -I) to be more substantially out of synchronization with the loading of memory bins (into bin cache -I) than if the cache line-depth parameter Dwere set at the theoretical minimum value D.","In one embodiment, sample buffer  and bin cache -I may be configured for row-oriented burst transfers. If a request for a memory bin misses in bin cache -I, the entire bin row containing the requested memory bin may be fetched from sample buffer  in a burst transfer. Thus, the first convolution of a scan line may fill the bin cache -I with all the memory bins necessary for all subsequent convolutions in the scan line. For example, in performing the first convolution in the current scan line at the first convolution center , sample-to-pixel calculation unit -I may assert a series of requests for memory bins, i.e. for the memory bins corresponding to those spatial bins (rendered in shade) which intersect the support of filter kernel . Because the filter support  intersects five bin rows, in a worst case scenario, five of these memory bin requests will miss bin cache -I and induce loading of all five bin rows from sample buffer . Thus, after the first convolution of the current scan line is complete, bin cache -I may contain the memory bins indicated by the heavily outlined rectangle . Memory bin requests asserted by all subsequent convolutions in the current scan line may hit in bin cache -I, and thus, may experience significantly decreased bin access time.","In general, the first convolution in a given scan line may experience fewer than the worst case number of misses to bin cache -I because bin cache -I may already contain some or all of the bin rows necessary for the current scan line. For example, if convolution centers are located at the center of each spatial bin, the vertical distance between successive scan lines (of convolution centers) corresponds to the distance between successive bin rows, and thus, the first convolution of a scan line may induce loading of a single bin row, the remaining four bin rows having already been loaded in bin cache -I in response to convolutions in previous scan lines.","If the successive convolution centers in a scan line are expected to depart from a purely horizontal trajectory across Column I, the cache line-depth parameter Dmay be set to accommodate the maximum expected vertical deviation of the convolution centers. For example, in , the convolution centers follow a curved path across Column I. The curved path deviates from a horizontal path by approximately two bins vertically. Since the support of the filter kernel covers a 3 by 3 array of spatial bins, bin cache -I may advantageously have a cache line-depth Dof at least five (i.e. two plus three).","As mentioned above, Columns  through  of the 2-D viewport may be configured to overlap horizontally. The size of the overlap between adjacent Columns may be configured to accommodate the maximum expected horizontal deviation of convolution centers from nominal convolution centers on a rectangular grid.","FIGS. A&B\u2014Rendering Samples into a Super-sampled Sample Buffer",{"@attributes":{"id":"p-0159","num":"0167"},"figref":["FIGS. 13A&B","FIGS. 13A&B"],"b":["200","140","102","106","202","140","150","204","150","150","206"],"sub":["x","y ","z"]},"In step , rendering unit A may process the vertices and convert the vertices into an appropriate space for lighting and clipping prior to the perspective divide and transform to virtual screen space. In step , rendering unit A may assemble the stream of vertex data structures into triangles.","If the graphics board GB implements variable resolution super-sampling, rendering unit A may compare the triangles with a set of sample-density region boundaries (as indicated in step ). In variable-resolution super-sampling, different regions of the 2-D viewport may be allocated different sample densities based upon a number of factors (e.g., the center of the attention of an observer on projection screen SCR as determined by eye or head tracking). If the triangle crosses a sample-density region boundary (step ), then the triangle may be divided into two smaller polygons (e.g. triangles) along the region boundary (step ). The polygons may be further subdivided into triangles if necessary (since the generic slicing of a triangle gives a triangle and a quadrilateral). Thus, each newly formed triangle may be assigned a single sample density. In one embodiment, rendering unit A may be configured to render the original triangle twice, i.e. once with each sample density, and then, to clip the two versions to fit into the two respective sample density regions.","In step , rendering unit A selects one of the sample positioning schemes (e.g., regular, perturbed regular, stochastic, etc.) from sample position memory . In one embodiment, the sample positioning scheme may be pre-programmed into the sample position memory . In another embodiment, the sample-positioning scheme may be selected \u201con the fly\u201d.","In step , rendering unit A may determine a subset of spatial bins which, based on their positional relation to the given triangle, may contribute samples that fall within the given triangle. The bins in this subset are referred to herein as candidate bins. In one embodiment, rendering unit A may determine the candidate bins by computing a minimal bin bounding box, i.e. a minimal rectangle of bins which efficiently contains the triangle bounding box, as suggested in FIG. C. For example, rendering unit A may first compute coordinates for a triangle bounding box by determining the maximum and minimum of the x and y coordinates of the triangle vertices. By rounding up and down the triangle bounding box coordinates, rendering unit  may determine coordinates for the minimal bin bounding box. In another embodiment, rendering unit A may use triangle vertex data to determine a more efficient (i.e. smaller) subset of candidate bins as shown in FIG. D. Rendering unit A may eliminate bins in the minimal bin bounding box which have no intersection with the triangle.","In step , rendering unit A may compute a set of sample positions for each of the candidate bins by reading positional offsets dX and dY from sample position memory  and adding the positional offsets to the coordinates of the corresponding bin origin (e.g. the lower-left corner of the bin). For various embodiments of the sample position computation, refer to the textual description above corresponding to .","In step , rendering unit A may filter the sample-positions in the candidate bins with respect to the given triangle as suggested in FIG. E. In other words, rendering unit A may operate on the sample positions to determine those sample positions which reside inside the triangle. In one embodiment, rendering unit A may use the triangle vertices to compute parameters for linear edge equations corresponding to the three edges of the triangle. For each of the sample positions, rendering unit A may compute a vertical or horizontal displacement of the sample with respect to each of the three edges of the triangle. Rendering unit A may examine the signs of the three edge-relative displacements to determine whether the sample position is inside or outside the triangle.","For each sample position that is determined to be within the triangle, rendering unit A may interpolate sample ordinate values (e.g. color values, alpha, Z, texture values, etc.) based on the known ordinate values at the vertices of the triangle as indicated in step . In step , render unit A may forward the rendered sample ordinate values to schedule unit , which then stores the samples in sample buffer .","The embodiment of the rendering method described above is not meant to be limiting. For example, in some embodiments, two or more of the steps shown in  as occurring serially may be implemented in parallel. Furthermore, some steps may be reduced or eliminated in certain embodiments of the graphics system (e.g., steps - in embodiments that do not implement geometry compression, or steps - in embodiments that do not implement a variable resolution super-sampled sample buffer).","FIG. \u2014Generating Output Pixels Values from Sample Values",{"@attributes":{"id":"p-0168","num":"0176"},"figref":["FIG. 14","FIG. 12A"],"b":["162","250","162","252","176","170","254","400"]},"Each sample in the selected bins (i.e. bins that have been identified in step ) is then individually examined to determine if the sample does indeed contribute samples to the support of filter kernel  (as indicated in steps -). This determination may be based upon the distance from the sample to the center of the output pixel being generated.","In one embodiment, the sample-to-pixel calculation units  may be configured to calculate this sample distance (i.e., the distance of the sample from the filter center) and then use it to index into a table storing filter weight values (as indicated in step ). In another embodiment, however, the potentially expensive calculation for determining the distance from the center of the pixel to the sample (which typically involves a square root function) may be avoided by using distance squared to index into the table of filter weights. In one embodiment, this squared-distance indexing scheme may be facilitated by using a floating point format for the distance (e.g., four or five bits of mantissa and three bits of exponent), thereby allowing much of the accuracy to be maintained while compensating for the increased range in values. The table of filter weights may be stored in ROM and\/or RAM. Filter tables implemented in RAM may, in some embodiments, allow the graphics system to vary the filter coefficients on a per-frame or per-session basis. For example, the filter coefficients may be varied to compensate for known shortcomings of a display and\/or projection device or for the user's personal preferences. The graphics system can also vary the filter coefficients on a screen area basis within a frame, or on a per-output pixel basis. In another alternative embodiment, graphics board GB may include specialized hardware (e.g., multipliers and adders) to calculate the desired filter weights for each sample. The filter weight for samples outside the limits of the convolution filter may simply be multiplied by a filter weight of zero (step ), or they may be removed from the convolution-sum calculation entirely.","In one alternative embodiment, the filter kernel may not be expressible as a function of distance with respect to the filter center. For example, a pyramidal tent filter is not expressible as a function of distance from the filter center. Thus, filter weights may be tabulated (or computed) in terms of X and Y sample-displacements with respect to the filter center.","Once the filter weight for a sample has been determined, the ordinate values (e.g. red, green, blue, alpha, etc.) for the sample may then be multiplied by the filter weight (as indicated in step ). Each of the weighted ordinate values may then be added to a corresponding cumulative sum\u2014one cumulative sum for each ordinate\u2014as indicated in step . The filter weight itself may be added to a cumulative sum of filter weights (as indicated in step ). After all samples residing in the support of the filter have been processed, the cumulative sums of the weighted ordinate values may be divided by the cumulative sum of filter weights (as indicated in step ). It is noted that the number of samples which fall within the filter support may vary as the filter center moves within the 2-D viewport. The normalization step  compensates for the variable gain which is introduced by this nonuniformity in the number of included samples, and thus, prevents the computed pixel values from appearing too bright or too dark due to the sample number variation. Finally, the normalized output pixels may be output for gamma correction, digital-to-analog conversion (if necessary), and eventual display (step ).","FIG. \u2014Example Output Pixel Convolution",{"@attributes":{"id":"p-0173","num":"0181"},"figref":"FIG. 15","b":["288","288","288","296","294","292","290","290"]},"Example ordinate values for samples - are illustrated in boxes -. In this example, each sample comprises red, green, blue and alpha values, in addition to the sample's positional data. Block  illustrates the calculation of each pixel ordinate value prior to normalization. As previously noted, the filter values may be summed to obtain a normalization value . Normalization value  is used to divide out the unwanted gain arising from the non-constancy of the number of samples captured by the filter support. Block  illustrates the normalization process and the final normalized pixel ordinate values.","The filter presented in  has been chosen for descriptive purposes only and is not meant to be limiting. A wide variety of filters may be used for pixel value computations depending upon the desired filtering effect(s). It is a well known fact that the sinc filter realizes an ideal band-pass filter. However, the sinc filter takes non-zero values over the whole of the X-Y plane. Thus, various windowed approximations of the sinc filter have been developed. Some of these approximations such as the cone filter or Gaussian filter approximate only the central lobe of the sinc filter, and thus, achieve a smoothing effect on the sampled image. Better approximations such as the Mitchell-Netravali filter (including the Catmull-Rom filter as a special case) are obtained by approximating some of the negative lobes and positive lobes which surround the central positive lobe of the sinc filter. The negative lobes allow a filter to more effectively retain spatial frequencies up to the cutoff frequency and reject spatial frequencies beyond the cutoff frequency. A negative lobe is a portion of a filter where the filter values are negative. Thus, some of the samples residing in the support of a filter may be assigned negative filter values (i.e. filter weights).","A wide variety of filters may be used for the pixel value convolutions including filters such as a box filter, a tent filter, a cylinder filter, a cone filter, a Gaussian filter, a Catmull-Rom filter, a Mitchell-Netravali filter, any windowed approximation of a sinc filter, etc. Furthermore, the support of the filters used for the pixel value convolutions may be circular, elliptical, rectangular (e.g. square), triangular, hexagonal, etc.","The piecewise constant filter function shown in  with four constant regions is not meant to be limiting. For example, in one embodiment the convolution filter may have a large number of regions each with an assigned filter value (which may be positive, negative and\/or zero). In another embodiment, the convolution filter may be a continuous function that is evaluated for each sample based on the sample's distance (or X and Y displacements) from the pixel center. Also note that floating point values may be used for increased precision.","Rendering Lines","The graphics instructions received by graphics system  may include line-draw commands. In some embodiments, a command for drawing a line may provide coordinates for two points P=(X,Y,Z) and P=(X,Y,Z) defining the line ends. The line-draw command may also comprise color information (e.g., R, G, B), as well as other attributes such as a line width value D, an alpha transparency value, texture coordinates, etc.  shows one embodiment of a method for rendering a line in response to a line-draw command.","In step , one of rendering units A-D, e.g. rendering unit A, may receive a line-draw command. The following discussion will refer to rendering unit A. However, it is to be understood that any or all of rendering units A-D may be configured to perform the processing operations associated with FIG. .","In step , rendering unit A may compute a horizontal displacement DeltaX and a vertical displacement DeltaY between the line segment endpoints Pand P:\n\nDeltaX=X\u2212X,\n\nDeltaY=Y\u2212Y.\n","In step , rendering unit A may compare the absolute value of DeltaX to the absolute value of DeltaY. If the absolute value of DeltaX is greater than or equal to the absolute value of DeltaY, the line segment is said to be X-Major. If the absolute value of DeltaX is smaller than the absolute value of DeltaY, the line segment is said to be Y-Major. Rendering unit A labels the line segment as X-Major or Y-Major depending on the result of the absolute value comparison.","In step , rendering unit A may compute parameters m and b for a line equation corresponding to the line segment from Pto P. If the line segment is X-Major, rendering unit A may compute parameters m and b for the line equation in the form y=mx+b, i.e. m=DeltaY*(1\/DeltaX) and b=Y\u2212m*X. If the line segment is Y-Major, rendering unit A may compute parameters m and b for the line equation in the form x=my+b, i.e. m=DeltaX*(1\/DeltaY) and b=X\u2212m*Y. By computing the slope and intercept for the line segment in this major-sensitive fashion, slopes are guaranteed to be between negative one and one, and thus, the number of bits allocated for storing slope m may be more efficiently utilized. It is noted that the reciprocal values (1\/DeltaX) and (1\/DeltaY) may be computed by lookup in a ROM table.","In step , rendering unit A may determine a line bounding box  around the line segment  as suggested by FIG. A. The line bounding box  may have a width din the direction normal to the line segment . The bounding box width dmay be computed based on the line width value Dsupplied in the line-draw command. For example, in one embodiment, the bounding box width dmay be a scalar multiple of the line width value D, i.e. d=k*D.","Rendering unit A may compute a slope and intercept for each side of the line bounding box based on (a) the bounding box width d, and (b) the slope m and intercept b of the line segment . For an X-Major line segment, rendering unit A may determine the upper and lower box edges by the equations\n\n+()\n\nand\n\n+()\n\nrespectively, where V=(\u00bd)d*secant(\u03b8), and where \u03b8 is the angle that the line segment forms with respect to the positive x axis. It is noted that the value secant(\u03b8) may be stored in a lookup table addressed by slope m.\n","In step , rendering unit A may determine a set of candidate bins in the virtual screen space which intersect with the triangle bounding box as suggested in FIG. B. The candidate bins are denoted with heavy outline.","In step , rendering unit A may compute a set of sample positions for each of the candidate bins as suggested by FIG. C. For example, rendering unit A may read positional offsets dX and dY from sample position memory  and add the positional offsets to the coordinates of the corresponding bin origin (e.g. the lower-left corner of the bin). For various embodiments of the sample position computation, refer to the textual description above corresponding to .","In step , rendering unit A may filter the sample positions in the candidate bins to determine those sample positions that fall within the line bounding box  as suggested by FIG. D. Samples interior to the line bounding box  are illustrated as blackened dots, while samples outside the line bounding box are illustrated as unfilled dots.","In step , rendering unit A may assign color values (and\/or transparency values) to the sample positions inside the line bounding box  based on their normal distance from the line segment . Rendering unit A may assign color values (and\/or transparency values) to samples using a window function which varies in the direction normal to the line segment .","For example, if the line color is blue and the background color is white, rendering unit A may implement a Gaussian transition of sample colors from blue on the line segment  to white at some normal distance away from the line segment . More generally, in one embodiment, rendering unit A may assign color vector (R,G,B)s to an interior sample (i.e. a sample interior to the line bounding box) according to the vector relation:\n\n()()*()+(1())*(),\n\nwhere (R,G,B)denote the line color vector, (R,G,B)denotes the background color, ddenotes the normal distance of the sample from the line segment , and w(d) is the window function. The window function may have a maximum value of one on the line segment, i.e. for d=0, and may converge to zero as dincreases. The window function may have any of a variety of functional forms. For example, the window function may be a Gaussian window, a raised cosine window, a Mitchell-Netavali window, a polynomial window, etc.  illustrates a Gaussian window function w(d). The Gaussian window may have the form\n\n()=exp[\u2212()],\n\nwhere exp[*] denotes the exponential function, and r is a scalar value that may depend on the line width parameter D.\n","If line segment  is X-Major, rendering unit A may compute the sample normal distance dfrom the vertical distance vbetween the sample and the line segment  as suggested by FIG. F. In particular, rendering unit A may compute the vertical distance vaccording to the expression\n\n\u2212(),\n\nwhere xis the x-coordinate of the sample, yis the y-coordinate of the sample, and m and b are the slope and intercept respectively of the line segment . Rendering unit A may then compute the sample normal distance daccording to the relation\n\n*cos(\u03b8),\n\nwhere \u03b8 is the angle between the line segment  and the positive x axis, and cos(\u03b8) denotes the cosine of angle \u03b8. It is noted that the value cos(\u03b8) depends on the slope m of the line segment , and thus, does not vary from sample to sample. The values of cos(\u03b8) for slopes m in the closed interval [\u22121,1] may pre-computed and stored in a lookup table. Rendering unit A may lookup the value cos(\u03b8) any time after computing the line slope m. The value cos(\u03b8) may be referred to herein as the slope correction factor. It is noted that the angle \u03b8 is presented here for convenience of discussion, and may not be physically computed.\n","If the line segment  is Y-Major, rendering unit A may compute the sample normal distance dbased on the horizontal distance hbetween the sample and the line segment  using a similar set of computations with the roles of x and y interchanged, and the angle \u03b8 measured from the positive y axis to the line  instead of from the positive x axis.","In one set of embodiments, rendering unit A may vary the transparency of samples instead of color. For example, if the line color is blue, rendering unit A may assign the color blue to all samples in the line bounding box, and may implement a Gaussian transition of sample transparency values from totally opaque on the line segment  to totally transparent at some normal distance from the line segment . When these samples are written to sample buffer , sample buffer  may automatically perform transparency blending (i.e. alpha-blending) with respect to samples already stored in sample buffer . Thus, the spatial transition of color values from solid blue at the center of the line to ambient colors away from the line may be automatically implemented by the alpha-blending feature of the sample buffer . More generally, rendering unit A may assign transparency value \u03b1to a sample (i.e. a sample interior to the line bounding box) according to the relation:\n\n\u03b1=1(),\n\nwhere \u03b1=0 denotes total opacity and \u03b1=1 denotes total transparency.\n","In one embodiment, rendering unit A may vary both sample color and sample transparency as a function of sample normal distance with respect to the line segment .","By modulating sample color and\/or transparency with a window function, rendering unit A achieves an anti-aliasing effect on the line segment . High spatial frequencies in the direction normal to the line segment are removed, and thus, the display device is able to present the line segment  without ringing at the line edges. The anti-aliased line may be more pleasing to the eye of the viewer.","In another embodiment, the window function w(d) may be a rectangular function. Thus, rendering unit A may not apply any anti-aliasing to the sample values (i.e. color and\/or transparency of the samples interior to the line bounding box). However, as described above, sample-to-pixel calculation units  performs spatial filtering on groups of sample values to generate pixel values. Thus, the sample-to-pixel calculation units  may smooth out the edges of lines before they are presented to the display device.","In step , rendering unit A may store the sample values (i.e. the sample color values, transparency value, texture values, etc.) in sample buffer . If alpha-blending is turned on, sample buffer  may automatically perform an alpha-blending (i.e. transparency mixing) operation on the in-coming samples with respect to samples already stored in sample buffer . In other words, the color values of an in-coming sample may mix with the color values of an existing sample (i.e. a sample already resident within sample buffer ) having the same or approximately the same sample position. The amount of mixing may be determined by the transparency value of the in-coming sample. If alpha-blending is turned off, sample buffer  may store or discard the in-coming sample depending on the result of a z-comparison between the in-coming sample and the existing sample. If the in-coming sample passes the z-comparison, the sample buffer  may overwrite existing samples with the in-coming samples.","In one embodiment, rendering unit A comprise one or more processors executing program code which implement any or all of the steps of FIG. . In another embodiment, rendering unit A may comprise dedicated circuitry (such as an ASIC chip, a gate array, analog circuitry, etc.) for implementing any or all of the steps of FIG. . In yet another embodiment, rendering unit A may comprise one or processors running some of the steps of , and dedicated hardware implementing the remaining steps of FIG. .","Pre-compensation for Anti-aliasing in Convolve Units","As described above, graphics system  includes sample-to-pixel calculation units  which are configured to read samples values from the sample buffer  and perform spatial filtering of the samples values to generate pixel values. The spatial filtering achieves an anti-aliasing effect on graphical objects including lines. However, as described above, rendering unit A may perform anti-aliasing on line sample values using a window function. Thus, samples corresponding to lines may be subjected to two waves of anti-aliasing, i.e. the first in the rendering unit A and the second in the sample-to-pixel calculation units . Therefore, lines may appear wider than originally intended, or excessively \u201csmoothed out\u201d.","In one embodiment, lines may be made to appear more consistent with a desired width by employing a narrower window (e.g. a narrower Gaussian window) in the rendering unit A. In other words, rendering unit A may use a narrower window on samples in line bounding box  to pre-compensate for the \u201cline-expanding\u201d effect of the spatial filtering performed in the sample-to-pixel calculation units .","Rendering unit A may apply a narrower window to samples while using the same window function w(*) by scaling the sample normal distances dby a scalar value C greater than one before evaluating the window function. For example, rendering unit A may assign transparency value \u03b1to a sample according to the relation\n\n\u03b1=1().\n\nBecause scalar value C is greater than one, sample transparency values \u03b1more quickly transition from one to zero as sample normal distance increases. The scalar value C may be referred to herein as the anti-aliasing correction factor (ACF).\n","In another embodiment, rendering unit A may apply the narrower window to sample color vectors according to the relation\n\n()()*()+(1())*().\n\nBecause anti-aliasing correction factor C is greater than one, the sample color vector more quickly transitions from the line color to the background color as the sample normal distance increases.\n","In some embodiments, the anti-aliasing correction factor ACF may be determined empirically. In other embodiments, the anti-aliasing correction factor C may be controlled by user input. In one embodiment, a certain initial value may be chosen for the ACF, the object (e.g., the line segment) may be observed on the display, and the value of the ACF may be adjusted so that the observed width of the object matches a desired width. For example, host CPU  may support a graphical user interface which allows the user to control the value of anti-aliasing correction factor C. The graphical user interface may transmit an indication of the desired anti-aliasing correction factor C (or an indication of a desired change in the anti-aliasing correction factor C) to graphics system  in response to a user input event. For example, the user may manipulate a graphical control knob or slider with an input device (such as mouse ) to change the value of anti-aliasing correction factor C. The user may increase and\/or decrease the anti-aliasing correction factor C until the lines displayed on a display device (e.g. display device A or B, or any of projection devices PDthrough PD) have a satisfactory appearance.","In one embodiment, graphics system  may include an input device (e.g. a control knob coupled to a variable potentiometer or variable capacitor) dedicated for controlling the anti-aliasing correction factor C in addition to or instead of the software control provided by the graphical user interface.",{"@attributes":{"id":"p-0204","num":"0212"},"figref":["FIG. 18","FIG. 18"],"b":["112","150","2106","2108","2108","2106","2106"]},"It is apparent from  that line segments other than vertical or horizontal line segments may appear jaggy when drawn using a rectangular grid. The sample anti-aliasing techniques described above may be used in order for the line segment  to appear less jaggy. In one embodiment, instead of illuminating samples within certain boundaries and not illuminating pixels outside those boundaries, rendering unit A may modulate sample color and\/or transparency with a window function that varies in the direction normal to the line segment . The modulation induced by the window function may generate a more pleasing image by smoothing jaggies.","Even in those embodiments where one sample is allocated per pixel region, a sample-to-pixel calculation unit may filter more than one sample to generate a given pixel value. In other words, the filter kernel for a sample-to-pixel calculation unit may span more than one pixel region. Thus, even in non-supersampled embodiments, rendering unit A may implement line-width pre-compensation to sample color and\/or transparency value as described above by multiplying sample normal distances dby the anti-aliasing correction factor C, and evaluating the window function value on the scaled distance C*d.","Although the embodiments above have been described in considerable detail, other versions are possible. Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications. Note the headings used herein are for organizational purposes only and are not meant to limit the description provided herein or the claims attached hereto."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing, as well as other objects, features, and advantages of this invention may be more completely understood by reference to the following detailed description when read together with the accompanying drawings in which:",{"@attributes":{"id":"p-0033","num":"0036"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0034","num":"0037"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0035","num":"0038"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0036","num":"0039"},"figref":"FIG. 3B","b":"112"},{"@attributes":{"id":"p-0037","num":"0040"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0038","num":"0041"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0039","num":"0042"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0040","num":"0043"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0041","num":"0044"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0042","num":"0045"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0043","num":"0046"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0044","num":"0047"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0045","num":"0048"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0046","num":"0049"},"figref":["FIG. 12A","FIG. 11"],"b":"400"},{"@attributes":{"id":"p-0047","num":"0050"},"figref":["FIG. 12B","FIG. 11"],"b":"400"},{"@attributes":{"id":"p-0048","num":"0051"},"figref":"FIGS. 13A and 13B"},{"@attributes":{"id":"p-0049","num":"0052"},"figref":"FIG. 13C"},{"@attributes":{"id":"p-0050","num":"0053"},"figref":"FIG. 13D"},{"@attributes":{"id":"p-0051","num":"0054"},"figref":"FIG. 13E"},{"@attributes":{"id":"p-0052","num":"0055"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0053","num":"0056"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0054","num":"0057"},"figref":"FIG. 16","b":"162"},{"@attributes":{"id":"p-0055","num":"0058"},"figref":"FIG. 17A","b":["2106","2108","2106"]},{"@attributes":{"id":"p-0056","num":"0059"},"figref":"FIG. 17B","b":"2108"},{"@attributes":{"id":"p-0057","num":"0060"},"figref":"FIG. 17C"},{"@attributes":{"id":"p-0058","num":"0061"},"figref":"FIG. 17D","b":"2108"},{"@attributes":{"id":"p-0059","num":"0062"},"figref":"FIG. 17E"},{"@attributes":{"id":"p-0060","num":"0063"},"figref":"FIG. 17F","b":"2106"},{"@attributes":{"id":"p-0061","num":"0064"},"figref":"FIG. 18","b":"2108"}]},"DETDESC":[{},{}]}
