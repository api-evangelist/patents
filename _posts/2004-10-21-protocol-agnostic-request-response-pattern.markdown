---
title: Protocol agnostic request response pattern
abstract: A system and method for facilitating communications over a protocol is provided. The system includes a class factory that holds identifiers associated with determining which, if any, registered protocol object creator should be employed to create a protocol object. The protocol object implements an abstract network protocol base class. The protocol object is employed to abstract details of communicating over a protocol and to provide a byte stream interface to communications occurring over the protocol, while removing protocol specific code from an application program. The method includes creating an instance of a protocol object from a source of registered protocol handlers based on a request to communicate over a protocol and using a base class API to communicate over the protocol through the protocol object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07730499&OS=07730499&RS=07730499
owner: Microsoft Corporation
number: 07730499
owner_city: Redmond
owner_country: US
publication_date: 20041021
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application is a divisional of U.S. patent application Ser. No. 09\/818,447, filed Mar. 27, 2001, entitled \u201cPROTOCOL AGNOSTIC REQUEST RESPONSE PATTERN,\u201d the entirety of which is incorporated herein by reference.","The present invention relates generally to computer programming and more particularly to simplifying communications over one of a plurality of protocols by providing network objects operable to abstract protocol specific communication details.","As has more applications, services and content sources (collectively \u201cresources\u201d) have become available on servers accessible over networks, it has become more common for remote users and\/or programs (collectively \u201cconsumers\u201d) to access those resources on such servers over such networks. But communicating with a resource on a server, via a network requires formatting communications consistently with a protocol supported by the network and\/or server, which complicates such communications. There are many protocols supported by many different networks and\/or servers. For example, messages traversing the Internet can be formatted in protocols including, but not limited to, Hypertext Transfer Protocol (HTTP), File Transfer Protocol (FTP) and Simple Mail Transport Protocol (SMTP). Such a diversity of protocols facilitates communications between a wide range of consumers and resources in a variety of methods. But such diversity also leads to problems for programmers trying to access resources available on servers reachable through different networks and by different protocols.","Conventionally, a program written to access a resource provided over a network had to include code specific to the protocol employed to transport messages across the network. For example, a programmer writing a peer-to-peer application for sharing files across a network had to include code specific to the protocol between the peer processes. Including such protocol specific code in a program can negatively impact writing such a program by requiring the programmer(s) involved in writing the program to learn and account for protocol details. Learning such protocol specific details, and coding to account for such protocol specific details can increase program complexity while reducing program flexibility, thus increasing programming costs. Since protocols can change, program flexibility is important to program utility and lifespan, and thus to reducing lifetime costs associated with a program. For example, a program written to communicate specifically via HTTP 1.0 may not be able to communicate via HTTP 1.1. Thus, the program may need to be rewritten and recompiled to take advantage of the newer protocol, adding complexity and related cost to the program.","Programmers writing programs that seek to interact with resources addressable by a URI (Uniform Resource Identifier) typically are required to know the URI, to know the protocol employed to access the URI and to write code specific to the protocol required to access that URI. Thus, changing the URI of a resource could require a program to be rewritten and recompiled, thus introducing opportunities to introduce new bugs into a system. Thus, conventional systems limit the relocatability of resources.","Programmers are further constrained by conventional systems and methods that require a program to transmit and receive messages in message sizes and formats dictated by a protocol. For example, a protocol supporting transferring email messages may require an email message comprising a thousand words to be transmitted as a series of packets with headers and\/or trailers according to that protocol. Similarly, a book chapter comprising twenty kilobytes of data may be received as a series of one kilobyte blocks according to a second protocol. Such protocol specific size restrictions add complexity to programs and limit the ability of one program to access multiple different resources available over a variety of protocols.","Thus a system and\/or method for simplifying application communications over a plurality of protocols is still needed to mitigate problems associated with conventional systems.","The following presents a simplified summary of the invention in order to provide a basic understanding of some aspects of the invention. This summary is not an extensive overview of the invention. It is not intended to identify key or critical elements of the invention or to delineate the scope of the invention. Its sole purpose is to present some concepts of the invention in a simplified form as a prelude to the more detailed description that is presented later.","The present invention provides and a system and method for a program to communicate over a variety of protocols without having to rewrite and recompile the program when interacting with different protocols. The system further facilitates a program interacting with a new protocol without having to rewrite and recompile the program. Further, the system facilitates receiving and sending messages to a resource over a network through a byte stream interface, rather than through a protocol specific interface. Such a byte stream interface can be read and\/or written by an application without accounting for protocol specific formatting, sizing and\/or packaging details, thus mitigating formatting and sizing problems associated with conventional systems.","The system includes a class factory operable to select protocol object creators that produce objects associated with the various protocols. Which protocol object creator to employ can be determined by identifiers associated with the resource to be accessed, the class factory and the protocols. The identifiers can be, for example, registered URIs. When a programmer desires to write an application that will access a resource addressable by the identifier, the programmer will be able to request that the class factory provide an object suitable for communicating over the protocol(s) by which the resource can be reached. The programmer will not be required to learn or account for details associated with communicating by the protocol(s) employed to communicate with the resource. Rather, the programmer will be able to treat data received from resources as a byte stream. Thus, complexity problems associated with conventional systems are mitigated.","If a suitable protocol object creator has been registered with the class factory, then the class factory will employ the registered protocol object creator to create and provide a protocol object capable of communicating over a desired protocol. The protocol object will make messages received over the protocol appear as a continuous byte stream to the programmer. In addition, the protocol object facilitates sending messages by writing to a continuous byte stream. Thus, size problems associated with reading and writing in conventional systems are mitigated.","The system includes a protocol object creator registration system that facilitates making new protocol object creators (and thus new protocol objects) available to applications. When such protocol object creators become available, they can be registered with the class factory, thus facilitating creating associated new protocol objects. Such registration makes protocol objects available to the application program without requiring a rewrite or recompile of the application program. Thus, problems associated with program flexibility and adaptability are mitigated.","The present invention also provides a method for allowing an application program to communicate over different protocols. The method includes registering protocol handlers with a protocol object generating process. The method includes accepting a request from an application seeking to communicate with an entity addressable via an identifier (e.g., a URI). The method accepts the request and resolves which, if any protocol object generating process should be employed to generate a protocol object. The selected protocol object generating process then creates an instance of a protocol object from the registered protocol handlers. For example, if the application seeks to communicate with an entity reachable via HTTP, the method can return a protocol object capable of processing HTTP requests and responses. The protocol object is further operable to make such requests and responses appear as a byte stream to the application employing the protocol object, selectively removing protocol specific formatting details and\/or characters from incoming data and selectively adding protocol specific formatting details and\/or characters to outgoing data. The application program can then communicate with the resource through the protocol object by employing methods available through a base class API. For example, the application program can employ protocol object byte stream read and\/or write methods to communicate with the resource.","To the accomplishment of the foregoing and related ends, certain illustrative aspects of the invention are described herein in connection with the following description and the annexed drawings. These aspects are indicative of but a few of the various ways in which the principles of the invention may be employed and the present invention is intended to include all such aspects and their equivalents. Other advantages and novel features of the invention may become apparent from the following detailed description of the invention when considered in conjunction with the drawings.","The present invention is now described with reference to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It may be evident to one skilled in the art that the present invention may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to facilitate description of the present invention.","The term \u201ccomponent\u201d refers to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component may be a process running on a processor, a processor, an object, an executable, a thread of execution, a program and a computer. By way of illustration, both an application running on a server and the server can be components.","The term \u201cclass factory\u201d refers to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a class factory may be a process running on a processor, a processor, an object, an executable, a thread of execution, a program and a computer. By way of illustration, both an application running on a server and the server can be class factories.","The term \u201ccreator\u201d refers to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a creator may be a process running on a processor, a processor, an object, an executable, a thread of execution, a program and a computer. By way of illustration, both an application running on a server and the server can be creators.","The term \u201cconstructor\u201d refers to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a constructor may be a process running on a processor, a processor, an object, an executable, a thread of execution, a program and a computer. By way of illustration, both an application running on a server and the server can be constructors.","It is to be appreciated that various aspects of the present invention may employ technologies associated with facilitating unconstrained optimization and\/or minimization of error costs. Thus, non-linear training systems\/methodologies (e.g., back propagation, Bayesian, fuzzy sets, non-linear regression, or other neural networking paradigms including mixture of experts, cerebella model arithmetic computer (CMACS), radial basis functions, directed search networks and function link networks) may be employed.","Referring initially to , a plurality of programs  are illustrated communicating with a plurality of services , a plurality of applications  and a plurality of content sources  via a plurality of protocols . The services , applications  and content sources  can be referred to collectively as the resources . While services , applications  and content sources  are illustrated as the resources , it is to be appreciated by one skilled in the art that the present invention facilitates communications between the programs  and any suitable resource with which communications over a protocol are possible.","Conventionally, a program desiring to communicate with a resource is required to include code specific to the protocol by which the program and the resource will communicate. For example, a program desiring to access a Hypertext Markup Language (HTML) Web page can be required to include code specific to the Hypertext Transfer Protocol (HTTP). Embedding such code in a program increases program complexity while reducing program flexibility. Thus, the present invention facilitates writing a program to interact with the resources  while remaining abstracted from the details of the plurality of protocols .",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 2","b":["200","210","240","230","200","210","220","210","240","250","250","230","200","210","210"]},"Conventionally, the program  would be required to format data intended for a first resource in a manner consistent with a first protocol  through which the resource could be accessed. By way of illustration, if the resource were an HTML page, the program  could be required to include code specific to an HTTP protocol. By way of further illustration, if a second resource were an FTP data source, then the program  could be required to include code specific to an FTP protocol. Including such protocol specific code in the program  can increase the program  complexity and cost. Furthermore, including such protocol specific code in the program  can limit the flexibility and thus shorten the lifespan of the program . If the program  desired to communicate with more than one resource, then the program  could be required to include code specific to each of the protocols with which it would interact, thus increasing the program  size and complexity.","The present invention thus provides a protocol object  that mitigates problems associated with requiring the inclusion of protocol specific code in the program . By way of illustration, if the resource were an HTML page, the program  would not be required to include code specific to an HTTP protocol, rather the program  would communicate via a first byte stream  with a first protocol object . The first protocol object  would include the protocol specific code that facilitates communicating via the HTTP protocol. By way of further illustration, if the resource were an FTP data source, then the program  would not be required to include code specific to an FTP protocol. Rather, the program  would communicate via a second byte stream  with a second protocol object . The second protocol object  would include the protocol specific code that facilitates communicating via the FTP protocol. The protocol objects  could convert the byte streams  to formats consistent with the protocol by which the desired resources are accessed. For example, a first protocol object  could convert a first byte stream  intended for the resource into data consistent with an HTTP protocol while a second protocol object  could convert a second byte stream  intended for the resource into data consistent with an FTP protocol.","The present invention thus mitigates complexity and inflexibility problems associated with conventional systems by providing protocol objects  that hide the protocol specific details from the program , making access to the resources  possible via a byte stream . The present invention thus simplifies writing applications that communicate with one or more resources via one or more protocols. Thus, writing applications that can read from a first resource via a first protocol and then write to a second resource via a second protocol is simplified. Furthermore, writing applications that read from resources that are mobile (e.g., change their URI) without requiring the application to be recompiled is simplified. By way of illustration, a program  may communicate with a resource locatable via a first URI through a first protocol but then the resource may change its URI. Conventionally, the program  may be required to add additional code to deal with a new protocol through which the resource would be accessed. Including such additional code could require recompiling the program . But the present invention can accept, by way of illustration, a URI as an identifier to determine which of a plurality of protocol objects to employ to communicate with a resource. Thus, no additional code needs to be added to the program  to facilitate dealing with the different protocol and thus no recompilation is required.","Turning now to , a schematic block diagram illustrates a program  employing a reading object  and a writing object  to access a resource  via a protocol . The writing object  may be, for example, a WEB_REQUEST object, which accepts a byte stream  and produces data  consistent with the protocol . The reading object  may be, for example, a WEB_RESPONSE object, which produces a byte stream  from data  formatted consistently with the protocol . The writing object  and the reading object  thus make the resource  appear as a pair of byte streams to the program , simplifying the process of writing the program . Although a WEB_REQUEST object and a WEB_RESPONSE object are illustrated as examples of the writing object  and the reading object , it is to be appreciated by one skilled in the art that any appropriate reading and\/or writing objects can be employed in accordance with the present invention. Furthermore, although the writing object  and reading object  are illustrated as two separate objects, it is to be appreciated by one skilled in the art that the reading and writing functionality may be accomplished in a greater or lesser number of separate, combined, and\/or distributed objects. It is to be further appreciated that although a reading object  is illustrated, a reading component and\/or a reader may perform the reading functionality. Any suitable reading component and\/or reader may be employed in accordance with the present invention. Similarly, it is to be further appreciated that although a writing object  is illustrated, a writing component and\/or writer may perform the answering functionality. Any suitable writing component and\/or writer may be employed in accordance with the present invention.","Due to the functionality provided by the reading object  and the writing object , the program  is not required to include code specific to the protocol , but rather includes code that can be employed to generate the creation of the reading object  and the writing object . Such generating code can be employed to create objects that can be employed to communicate with a plurality of resources via a plurality of protocols. Furthermore, such generating code can be responsive to parameters input to the program , allowing the program  to be flexible. The input parameters may, for example, be associated with identifiers stored in a class factory (e.g., , ) employed to select a protocol object creator to employ to create the reading object  and\/or the writing object . Thus, with input parameters available to be passed through to a class factory callable by generic program code, the program  can be isolated from protocol specific details, increasing flexibility and lifespan over conventional systems. The program  may invoke such generating code one or more times, as needed, to communicate concurrently with one or more resources via one or more protocols. Thus, complexity and program size problems associated with conventional systems are mitigated.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 4","b":["400","450","410","480","430","420","470","400","480","450","410","420","410","410","410","420","440","430","440","400","410","400","410","450","450","460","430","470","440","460","410","450","440","460","430","450","460","470","410","430","420","440"]},"While the program  is illustrated interacting with one outgoing byte stream  and one incoming byte stream , it is to be appreciated by one skilled in the art that the program  may concurrently communicate with one or more resources by one or more protocols, and therefore more than one outgoing byte stream  may be associated with the program  and more than one incoming byte stream  may be associated with the program . Similarly, more than one writing object  may be associated with the program  and more than one reading object  may be associated with the program .","Referring now to , a system  for facilitating an application  communicating over a plurality of protocols is illustrated. The system  includes a class factory  that has access to a first constructor , and a second constructor through an Nth constructor , N being an integer. The constructors , through can be referred to collectively as the constructors . The first constructor may be operable to produce protocol objects that facilitate interacting with a first protocol (e.g., HTTP) while the second constructor may be operable to produce protocol objects that facilitate interacting with a second protocol (e.g., FTP). To communicate with a resource (e.g., , ) via a protocol (e.g., , ) the application  can first request that a protocol object be created by the class factory . The class factory  can select an appropriate constructor to employ to construct such a protocol object based on an identifier associated with the resource (e.g., , ) with which the application  seeks to communicate. By way of illustration, if the application  seeks to communicate with a resource identified by the URI http:\/\/www.abc.com\/123.html then the class factory  may employ a constructor to produce a protocol object operable to interact with the HTTP protocol. By way of further illustration, if the application  seeks to communicate with a resource identified by the URI ftp:\/\/www.abc.com\/123 then the class factory  may employ a constructor to produce a protocol object operable to interact with the FTP protocol.","Thus, in the example presented, the application  only needs to supply a URI to the class factory . The URI can be an input to the application  (e.g., a command line parameter, a field read from a file, a string input by a user) that is employed by the code that invokes the operations of the class factory . Thus, the application  can be insulated from protocol specific actions, thereby mitigating flexibility problems associated with conventional systems. The class factory  is then responsible for selecting an appropriate constructor, invoking a create method in the chosen constructor and returning a protocol object operable to facilitate the desired communication to the application . Thus, by moving creator selection to a class factory, that is external to the application , flexibility and complexity problems associated with conventional systems are mitigated. The class factory  can access a data store  of registered protocol handlers to facilitate determining which, if any, constructor to employ to create a protocol object for a desired communication. By way of illustration, the data store  of registered protocol handlers may store items including, but not limited to, a list of constructors associated with one or more URIs, a list of constructors associated with one or more URI prefixes and a list of rules for selecting a constructor based on a URI. While the previous sentence refers to lists, it is to be appreciated by one skilled in the art that the data store  can employ other data structures including, but not limited to, an array, a table, a database, a stack, a heap, a linked list, a heap and a data cube.","One problem with conventional systems was the difficulty with which such systems responded to new protocols. Thus, turning to , a system  for registering new protocol object constructors with a class factory  is illustrated. Before the addition of a new constructor and related registered protocol handler information, the class factory  had access to a first constructor and a second constructor through an Nth constructor , N being an integer. The first constructor may be operable to produce protocol objects associated with a first protocol (e.g., HTTP), while the second constructor may be operable to produce protocol objects associated with a second protocol (e.g., FTP). Information sufficient to determine which constructor, if any, is appropriate to employ to construct a protocol object to facilitate a desired communication can be stored in a data store  of registered protocol handlers. The data store  may store items including, but not limited to, a list of constructors associated with one or more URIs, a list of constructors associated with one or more URI prefixes and a list of rules for selecting a constructor based on a URI. While the previous sentence refers to lists, it is to be appreciated by one skilled in the art that the data store  can employ other data structures including, but not limited to, an array, a table, a database, a stack, a heap, a linked list, a heap and a data cube.","When a registering entity  desires to add a new protocol to the class factory  set of protocols for which constructors are available, the registering entity  will take at least two actions. The registering entity  will produce a new constructor , and the registering entity will register the new constructor with the data store . Registering the new constructor with the data store  may involve updating items including, but not limited to, a list of constructors associated with one or more URIs, a list of constructors associated with one or more URI prefixes and a list of rules for selecting a constructor based on a URI. While the previous sentence refers to lists, it is to be appreciated by one skilled in the art that updating the data store  can involve updating other data structures including, but not limited to, an array, a table, a database, a stack, a heap, a linked list, a heap and a data cube. Once the data store  is updated, then the class factory  can employ the new constructor to create protocol objects associated with the new protocol. It is to be appreciated by one skilled in the art that although a registering entity  is illustrated, that an adding component may be employed to add an identifier to the data store  and that any suitable adding component may be employed with the present invention.","Adding a new constructor operable to produce protocol objects associated with the new protocol can thus be completed without requiring changes to an application (e.g., , ). To acquire a protocol object created by the new constructor , an application (e.g., , ) would not require recompilation, thus mitigating lifespan problems associated with conventional systems. An application (e.g., , ) may not even be aware that the new constructor became available. By way of illustration, acquiring a protocol object operable to facilitate access to a resource through a new protocol may involve inputting a parameter to an application (e.g., , ), and passing the parameter to existing generator code that will in turn access the class factory . The parameter may be a URI. To acquire a protocol object created by the new constructor , an application (e.g., , ) could provide a URI to the class factory, which would be responsible for determining that the new constructor was available and appropriate for the desired communication, and which would further be responsible for invoking the new constructor and returning the protocol object(s) created by the new constructor . The class factory  will be able to interact with the new constructor and an application will be able to interact with a protocol object created by the new constructor if the new constructor implements a set of methods defined in an abstract network base class. Such abstract base class enabled access to the new constructor can thus be accomplished with no changes to the application program.","Thus, turning to , an abstract base class  and a protocol handler class  that inherits from the abstract base class  and which implements the abstract base class  are illustrated. The abstract base class  defines an interface , which includes N methods, N being an integer. The abstract base class  may also define one or more properties. The protocol handler class  inherits from the abstract base class , and implements the interface . In an abstract base class, methods are defined but not implemented. The present invention employs such abstract base classes to define an interface that protocol handler classes can implement.","The interface  can have methods including, but not limited to, methods for creating an object, methods for writing to a byte stream, methods for reading from a byte stream, methods for adding protocol specific information to data, methods for removing protocol specific information from data, methods for registering a protocol object creator and methods for determining the status of a communication. It is to be appreciated by one skilled in the art that some methods may be visible to an application program interacting with a protocol handler class object  (e.g., write to byte stream, read to byte stream) while other methods may not be visible to such an application program (e.g., add protocol header, remove protocol header). It is to be further appreciated that some methods (e.g., creator methods) may be invoked by a class factory (e.g., , ). The implementation of the interface  by the class specific object  facilitates implementing class factory functionality, with such functionality being removed from an application program, which thus mitigates application program complexity problems.","Thus, turning to , a block diagram illustrates a class factory  with a registry  of protocol object creators. The registry  of protocol object creators can include identifiers that can be employed to resolve a URI. Such identifiers may be associated with parameters that can be input to an application (e.g., , ). The registry  can be employed to associate identifiers with protocol object creators from protocol objects that have implemented an interface  and that in so doing have overridden the one method in the interface , create . By way of illustration, the creator method  may be an implementation of the interface  create method , with the creator method  defined by a protocol object class associated with facilitating HTTP communications. By way of further illustration, the creator method  may be an implementation of the interface  create method , with the creator method  being defined by a protocol object class associated with facilitating FTP communications.","The registry  can be indexed, for example, by a URI, and\/or by a prefix associated with a URI. For example, the prefix \u201chttp\u201d in a URI http:\/\/www.abc.com\/123.html may be employed as an identifier in the registry . The identifier can be employed to locate a creator method  appropriate to create a protocol object associated with facilitating communications via the HTTP protocol. The creator method  can be, for example, the HTTP_WEB_REQUEST method. Also, for example, the prefix \u201cftp\u201d in a URI ftp:\/\/www.abc.com\/123.ftp may be employed as an identifier in the registry . The identifier can be employed to locate a creator method  appropriate to create a protocol object associated with facilitating communications via the FTP protocol. The creator method  can be, for example, the FTP_WEB_REQUEST method.","By employing the registry  and the identifiers stored in the registry  to locate methods implementing methods defined in the interface , the present invention facilitates adding creator methods that can be employed to create protocol objects associated with new protocols, with such addition not requiring changes to an application employing such creator methods. The registry  can be updated, and a new creator method can be added without requiring rewriting and\/or recompilation of an application (e.g., , ), thus mitigating complexity and lifespan problems associated with conventional systems.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 9","b":"900"},"The base class definition  can include properties and methods. The properties can include, but are not limited to, a request property, a method property, a content_length property, a content_type property and a proxy property. The methods can include, but are not limited to, a get_request_stream method, a get_response method, a create (string) method, a create (URI) method and a register_prefix method. While five properties and five methods are illustrated in , it is to be appreciated by one skilled in the art that a greater or lesser number of properties and\/or methods can be employed in a writing object in accordance with the present invention.","The request property may hold, for example, a URI for a resource associated with the writing object. The method property may hold, for example, an identifier of a protocol method employed by the writing object. The content_length property may hold, for example, the length of the data portion of a protocol request packet. The content_type property may hold, for example, the type of content associated with a protocol request packet. The proxy property can hold, for example, a proxy address through which a protocol request should be sent. Thus, data stored in the properties can be employed to facilitate communications via a protocol by storing information employed in facilitating such communications. Storing such information in a protocol object implementing a base class facilitates reducing program complexity by removing such protocol specific information from an application program, thus mitigating complexity problems associated with conventional systems.","The get_request_stream method may be employed, for example, to return an object that can be employed to write data to a protocol object via a byte stream. The stream object can be employed for communication methods including, but not limited to, synchronous (e.g., requests synchronized with following responses with no intervening requests and\/or responses) and asynchronous methods (e.g., request and responses may have intervening requests and\/or responses and responses may be delivered out of order). The get_response method may be employed, for example, to return a protocol object that provides a byte stream interface to messages received from a resource via a protocol. The protocol object may be, for example, a WEB_RESPONSE object. The create (string) method can be employed, for example, to produce a protocol object based, at least in part, on the value of the string passed to the create method. Similarly, the create (URI) method can be employed, for example, to produce a protocol object based, at least in part, on the value of the URI passed to the create method. The URI may have been provided to an application as an input parameter (e.g., command line, read from file, provided through interactive method). By way of illustration, the create (URI) method, when invoked by the call create (\u201chttp\u201d) may cause a create ( ) method implemented in an HTTP_WEB_REQUEST class object to be invoked to create a protocol object that facilitates communicating via an HTTP protocol.","The register_prefix method can be employed, for example, to register a prefix in a class factory data store (e.g., , ) to facilitate invoking an appropriate creator based on an identifier. By way of illustration, if a new protocol (e.g., the XYZ protocol) was created, and a constructor associated with the XYZ protocol was created, the constructor operable to produce an XYZ protocol class object, then the register_prefix (XYZ, XYZ_WEB_REQUEST::CREATE( )) method may be employed to update a class factory data store (e.g., , ) to facilitate invoking the XYZ_WEB_REQUEST::CREATE( ) method when a program desires to communicate with a resource reachable via the XYZ protocol. Moving such functionality to methods implementing an abstract base class facilitates simplifying programs and thus mitigates complexity problems associated with conventional systems.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 10","b":"1000"},"The status property may hold, for example, a status code associated with a server response (e.g., HTTP  error code). The status_description property may hold, for example, a string describing the response status code (e.g., \u201cpage not found\u201d). The content_length property may hold, for example, the length of the response from the server. The response_uri may hold, for example, a URI that was associated with a response from a server. Thus, data stored in the properties can be employed to facilitate communications via a protocol by storing information employed in facilitating such communications. Storing such information in properties in a protocol object that implements the abstract base class facilitates reducing program complexity by removing such protocol specific information from an application program, thus mitigating complexity problems associated with conventional systems.","The get_response_stream method may, for example, return a response stream object employed to read data from a resource. The close method may, for example, be employed to close a response stream object, thus severing communications with a resource. Moving such functionality to methods implementing an abstract base class facilitates simplifying programs and thus mitigates complexity problems associated with conventional systems.","In view of the exemplary systems shown and described above, methodologies, which may be implemented in accordance with the present invention, will be better appreciated with reference to the flow diagram of . While for purposes of simplicity of explanation, the methodology of  is shown and described as a series of blocks, it is to be understood and appreciated that the present invention is not limited by the order of the blocks, as some blocks may, in accordance with the present invention, occur in different orders and\/or concurrently with other blocks from that shown and described herein. Moreover, not all illustrated blocks may be required to implement a methodology in accordance with the present invention.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 11","b":["1100","1110","1110","1120","1110","1130","1130","1140","1130","1150","1110","1130","1110"]},"At , the requested communication can be undertaken, such communication facilitated by employing the protocol object(s) created at . At  a determination is made concerning whether the requested communication is complete. If the determination at  is NO, then processing can proceed at . If the determination at  is YES, then at  the protocol object(s) created at  may be released (e.g., deallocated, destructed). At  a determination is made concerning whether there are any more requests to communicate. If the determination at  is YES, then processing continues at . If the determination at  is NO, then processing concludes.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":["FIG. 12","FIG. 12"],"b":"1210"},"With reference to , an exemplary environment  for implementing various aspects of the invention includes a computer , the computer  including a processing unit , a system memory  and a system bus . The system bus  couples system components including, but not limited to, the system memory  to the processing unit . The processing unit  may be any of various commercially available processors. Dual microprocessors and other multi-processor architectures also can be employed as the processing unit .","The system bus  can be any of several types of bus structure including a memory bus or memory controller, a peripheral bus and a local bus using any of a variety of commercially available bus architectures. The system memory  includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS), containing the basic routines that help to transfer information between elements within the computer , such as during start-up, is stored in ROM .","The computer  further includes a hard disk drive , a magnetic disk drive , (e.g., to read from or write to a removable disk ) and an optical disk drive , (e.g., for reading a CD-ROM disk  or to read from or write to other optical media). The hard disk drive , magnetic disk drive  and optical disk drive  can be connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface  and an optical drive interface , respectively. The drives and their associated computer-readable media provide nonvolatile storage of data, data structures, computer-executable instructions, etc. for the computer , including for the storage of broadcast programming in a suitable digital format. Although the description of computer-readable media above refers to a hard disk, a removable magnetic disk and a CD, it should be appreciated by those skilled in the art that other types of media which are readable by a computer, such as zip drives, magnetic cassettes, flash memory cards, digital video disks, cartridges, and the like, may also be used in the exemplary operating environment, and further that any such media may contain computer-executable instructions for performing the methods of the present invention.","A number of program modules can be stored in the drives and RAM , including an operating system , one or more application programs , other program modules  and program data . It is to be appreciated that the present invention can be implemented with various commercially available operating systems or combinations of operating systems.","A user can enter commands and information into the computer  through a keyboard  and a pointing device, such as a mouse . Other input devices (not shown) may include a microphone, an IR remote control, a joystick, a game pad, a satellite dish, cameras, in the sense of gesture interpreted through cameras and machine-vision software, a scanner, or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus , but may be connected by other interfaces, such as a parallel port, a game port, a universal serial bus (\u201cUSB\u201d), an IR interface, etc. A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor, a computer typically includes other peripheral output devices (not shown), such as speakers, printers etc.","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer(s) . The remote computer(s)  may be a workstation, a server computer, a router, a personal computer, microprocessor based entertainment appliance, a peer device or other common network node, and typically includes many or all of the elements described relative to the computer , although, for purposes of brevity, only a memory storage device  is illustrated. The logical connections depicted include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the local network  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem , or is connected to a communications server on the LAN, or has other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","What has been described above includes examples of the present invention. It is, of course, not possible to describe every conceivable combination of components or methodologies for purposes of describing the present invention, but one of ordinary skill in the art may recognize that many further combinations and permutations of the present invention are possible. Accordingly, the present invention is intended to embrace all such alterations, modifications and variations that fall within the spirit and scope of the appended claims. Furthermore, to the extent that the term \u201cincludes\u201d is used in either the detailed description or the claims, such term is intended to be inclusive in a manner similar to the term \u201ccomprising\u201d, as comprising is interpreted as a transitional word in a claim."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
