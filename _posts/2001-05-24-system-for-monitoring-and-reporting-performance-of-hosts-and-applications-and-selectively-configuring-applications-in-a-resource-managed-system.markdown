---
title: System for monitoring and reporting performance of hosts and applications and selectively configuring applications in a resource managed system
abstract: A monitoring system for a distributed environment including a plurality of hosts capable of executing multiple copies of a scalable application includes a first device for generating first data corresponding to performance of all copies of the scalable application; a second device for generating second data corresponding to performance of all host in the distributed environment; and a third device for generating performance metrics based on the first and second data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07051098&OS=07051098&RS=07051098
owner: United States of America as represented by the Secretary of the Navy
number: 07051098
owner_city: Washington
owner_country: US
publication_date: 20010524
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["The instant application claims priority from Provisional Patent Application Ser. No. 60\/207,891, which was filed on May 25, 2000. The Provisional Patent Application is incorporated herein in its entirety by reference.","The invention described herein was made in the performance of official duties by employees of the Department of the Navy or by researchers under contract to an agency of the United States government and, thus, the invention disclosed herein may be manufactured, used, licensed by or for the Government for governmental purposes without the payment of any royalties thereon.","The present invention relates generally to resource management systems by which networked computers cooperate in performing at least one task too complex for a single computer to perform. More specifically, the present invention relates to a resource management system which dynamically and remotely controls networked computers to thereby permit them to cooperate in performing tasks that are too complex for any single computer to perform. Advantageously, software programs for converting a general purpose computer network into a resource managed network are also disclosed.","Resource Management consists of a set of cooperating computer programs that provides an ability to dynamically allocate computing tasks to a collection of networked computing resources (computer processors interconnected on a network) based on the following measures:\n\n","Many attempts to form distributed systems and environments have been made in the past. For example, several companies and organizations have networked multiple computers to form a massively parallel supercomputer of sorts. One the best known of these efforts is SETI@home, which is organized by SETI (Search for Extraterrestrial Intelligence), a scientific effort aiming to determine if there is intelligent life out in the universe.","Typically, the search means the search of billions of radio frequencies that flood the universe in the hopes of finding another civilization that might be transmitting a radio signal. Most of the SETI programs in existence today, including those at UC Berkeley, build large computers that analyze that data from the telescope in real time. None of these computers look very deeply at the data for weak signals nor do they look for a large class of signal types. The reason for this is because they are limited by the amount of computer power available for data analysis. To extract the weakest signals, a great amount of computer power is necessary. It would take a monstrous supercomputer to get the job done. Moreover, SETI programs could never afford to build or buy that computing power. Thus, rather than use a huge computer to do the job, the SETI team developed software to use thousands of small computers, all working simultaneously on different parts of the analysis, to run the search routine. This is accomplished with a screen saver that can retrieve a data block over the internet, analyze that data, and then report the results back to SETI.","Several commercial companies are developing and implementing similar capabilities. Moreover, several companies, most notably IBM, have developed networks where each networked desktop computer becomes a parallel processor in a distributed computer system when the desktop computer is otherwise idle.","It will be appreciated that these approaches to computing in a distributed environment do not provide a system that is both flexible and adaptive (or at least easily adapted) to changes in system configuration, performance bottlenecks, survivability requirements, scalability, etc.","What is needed is a Resource Management Architecture which permits flexible control, i.e., allowing autonomous start up and shut down of application copies on host machines to accommodate changes in data processing requirements. What is also needed is functionality included in the Resource Management Architecture which permits the Resource Management Architecture to determine the near-optimal alignment of host and application resources in the distributed environment. It would be desirable to have a user-friendly technique with which to specify quality of service (QoS) requirements for each host, each application, and the network in which the hosts are connected. What is also needed is instrumentation to ensure that the specified QoS goals are being met.","Based on the above and foregoing, it can be appreciated that there presently exists a need in the art for a Resource Management Architecture, which overcomes the above-described deficiencies. The present invention was motivated by a desire to overcome the drawbacks and shortcomings of the presently available technology, and thereby fulfill this need in the art.","According to one aspect, the present invention provides a monitoring system for a distributed environment including a plurality of hosts capable of executing multiple copies of a scalable application, which includes a first device for generating first data corresponding to performance of all copies of the scalable application; a second device for generating second data corresponding to performance of all host in the distributed environment; and a third device for generating performance metrics based on the first and second data.","The Resource Management Architecture, which was and is being developed by the Naval Surface Warfare Center\u2014Dahlgren Division (NSWC-DD), provides capabilities for monitoring hosts, networks, and applications within a distributed computing environment. Moreover, the Resource Management Architecture provides the capability of dynamically allocating, and reallocating, applications to hosts as needed in order to maintain user-specified system performance goals. Advantageously, the Resource Management architecture provides functionality for determining both how each component within the distributed environment is performing and what options are available for attempting to correct deficient performance, determining the proper actions that should be taken, and enacting the determined course of action. In addition to these capabilities, the architecture also allows for operator control over creating and loading pre-defined static, dynamic, or combined static and dynamic system and\/or host configurations. One particularly desirable feature of the Resource Management Architecture is that it provides capabilities for monitoring system performance along with the ability to dynamically allocate and reallocate system resources as required.","Before addressing the various features and aspects of the present invention, it would be useful to establish both terminology and the conventions that the instant application will follow throughout. In terms of terminology, a glossary section is presented below. In terms of conventions, this application includes information such as source code listing in an Appendix section. Since the source code itself is hundreds of pages, the Appendix section is divided into attached pages, e.g., Attached Appendix A, and an optical disk section, e.g., CD-Appendix N. Thus, while the appendices are listed in order, the reader must look to the signaling language to determine whether any particular appendix is actually provided in printed form.",{"@attributes":{"id":"p-0030","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["API","API (application programming interface) A set of subroutines or"]},{"entry":[{},"functions that a program, or application, can call to invoke some"]},{"entry":[{},"functionality contained in another software or hardware component."]},{"entry":[{},"The Windows API consists of more than 1,000 functions that"]},{"entry":[{},"programs written in C, C++, Pascal, and other languages can call to"]},{"entry":[{},"create windows, open files, and perform other essential tasks. An"]},{"entry":[{},"application that wants to display an on-screen message can call"]},{"entry":[{},"Windows' MessageBox API function, for example."]},{"entry":["BNF","Acronym for \u2018Backus Normal Form\u2019 (often incorrectly expanded as"]},{"entry":[{},"\u2018Backus-Naur Form\u2019), a metasyntactic notation used to specify the"]},{"entry":[{},"syntax of programming languages, command sets, and the like."]},{"entry":[{},"Widely used for language descriptions but seldom documented"]},{"entry":[{},"anywhere, so that it must usually be learned by osmosis from other"]},{"entry":[{},"hackers."]},{"entry":["DAEMON","A background process on a host or Web server (normally in a UNIX"]},{"entry":[{},"environment), waiting to perform tasks. Well-known examples of"]},{"entry":[{},"daemons are sendmail and HTTP daemon."]},{"entry":["FUNCTION","A capability available on a host due to the presence of software (e.g., a"]},{"entry":[{},"program), a software module (e.g., an API), etc."]},{"entry":["GLOBUS","Wide area network (WAN) enterprise management and control"]},{"entry":[{},"capability developed under DARPA sponsorship by USC\/ISI."]},{"entry":["HOST","A device including a central processor controlled by an operating system."]},{"entry":["ICMP","Internet Control Message Protocol - ICMP is an extension to the"]},{"entry":[{},"Internet Protocol. It allows for the generation of error messages, test"]},{"entry":[{},"packets and informational messages related to IP. It is defined in STD"]},{"entry":[{},"5, RFC 792."]},{"entry":["JEWEL","An open-source instrumentation package produced by the German"]},{"entry":[{},"National Research Center for Computer Science"]},{"entry":["NFS","Network File System - A protocol developed by Sun Microsystems,"]},{"entry":[{},"and defined in RFC 1094, which allows a computer system to access"]},{"entry":[{},"files over a network as if they were on its local disks. This protocol"]},{"entry":[{},"has been incorporated in products by more than two hundred"]},{"entry":[{},"companies, and is now a de facto Internet standard."]},{"entry":["QoS","Quality of Service"]},{"entry":["REMOS","Remos (REsource MOnitoring System)is a network bandwidth and"]},{"entry":[{},"topology monitoring system developed under DARPA sponsorship by"]},{"entry":[{},"CMU. Remos allows network-aware applications to obtain relevant"]},{"entry":[{},"information about their execution environment. The major challenges"]},{"entry":[{},"in defining a uniform interface are network heterogeneity, diversity in"]},{"entry":[{},"traffic requirements, variability of the information, and resource"]},{"entry":[{},"sharing in the network. Remos provides an API that addresses these"]},{"entry":[{},"issue by striking a compromise between accuracy (the information"]},{"entry":[{},"provided is best-effort, but includes statistical information if"]},{"entry":[{},"available) and efficiency (providing a query-based interface, so"]},{"entry":[{},"applications incur overhead only when they acquire information)."]},{"entry":[{},"Remos supports two classes of queries. \u201cFlow queries\u201d provide a"]},{"entry":[{},"portable way to describe a communication step to the Remos"]},{"entry":[{},"implementation, which uses its platform-dependent knowledge to"]},{"entry":[{},"return to the user the capacity of the network to meet this request."]},{"entry":[{},"\u201cTopology queries\u201d reverse the process, with the Remos"]},{"entry":[{},"implementation providing a portable description of the network's"]},{"entry":[{},"behavior to the application."]},{"entry":["SNMP","Simple Network Management Protocol Internet standard protocol"]},{"entry":[{},"defined in STD 15, RFC 1157; developed to manage nodes, e.g., hubs"]},{"entry":[{},"and switches, on an IP network."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"An exemplary system for implementing the Resource Management Architecture according to the present invention is illustrate in , B, which includes a plurality of Host computers A, B, . . . , N operatively connected to one another and Resource Management hardware RM via a Network . It will be appreciated that the hardware configuration illustrated in , B constitutes a so-called grid system. It will also be appreciated that the network  advantageously can be any known network, e.g., a local area network (LAN) or a wide area network (WAN). It will also be appreciated that the hardware RM need not be a discrete piece of equipment; the hardware RM advantageously can be distributed across multiple platforms, e.g., the host computer(s), as discussed in detail below. In addressing the functional elements and applications in the distributed environment, it will be appreciated that hosts A\u2013N each can instantiate applications \u2013M. Thus, when all applications are being addressed, these applications will be denoted as A\u2013NM.","Still referring to , B, each of the hosts A, B, etc., preferably is controlled by an operating system (OSA, OSB, etc.), which permits Host A, for example, to execute applications A\u2013AN, as well as an instrumentation daemon IDA, a Program Control (PC) agent PCA, and a Host Monitor HMA. It should be noted that instrumentation daemon IDA, PC agent PCA, and Host Monitor HMA are integral to the Resource Management Architecture while the operating system OSA and applications A\u2013AN are well known to one of ordinary skill in the art.","In , B, the Resource Management Architecture RM advantageously includes an instrument collector  receiving data from all of the instrumentation daemons (IDA\u2013IDN) and providing data to instrument correlator(s) , which, in turn, provide correlation data to corresponding quality of service (QoS) managers . Resource Management Architecture RM also receives data from host monitors HMA\u2013HMN at history servers , which maintain status and performance histories on each of the hosts A\u2013N and provide selected information to host load analyzer . Analyzer  advantageously determines the host and network loads for both hosts A\u2013N and their connecting network  and provides that information to Resource Manager , which is the primary decision making component of the Resource Management Architecture. It will be appreciated that Resource Manager  also receives information from the QoS managers  and exchanges information with program controller . Program controller  sends startup and shutdown orders to the Program Control Agents based on operator or Resource Manager-initiated orders. It will be appreciated that the operator-initiated orders are received via the one of the program control displays .","As will be discussed in greater detail below, the Resource Manager  is the primary decision-making component of the Resource Management Architecture. The Resource Manager  is responsible for determining:\n\n","Before leaving , B, is should be noted that the functions, e.g., instantiated programs or software program modules, in the Resource Management Architecture advantageously can be distributed across multiple platforms, e.g., multiple hosts (which may or may not be the illustrated Hosts A\u2013N) or a grid system.","The major functional groups of the Resource Management Architecture according to the present invention are illustrated in , B. The functions illustrated as solid boxes are components of the Resource Management Architecture and are fully described below; the functions denoted by diagonal striping denote third-party software which has been integrated with the Resource Management Architecture but does not provide core functionality. Thus, the latter functions will be described only to the extent necessary to provide integration details. Moreover, it will be appreciated that the functions and functionality of the Resource Management Architecture according to the present invention are interconnected to one another via middleware, which provides message passing interfaces between substantially all of the Resource Management functions. This middleware package, RMComms, is fully described below.","The major functional groups provided by the Resource Management architecture in an exemplary embodiment of the present invention are illustrated in , B. A summary of the functions provided by the Resource Management Architecture is available in Attached Appendix A. These functions, taken together, provide an integrated capability for monitoring and control of a distributed computing environment. In addition, many of the functions (and functional groups) within the Resource Management Architecture can also be run in a non-integrated configuration, thus providing subsets of the integrated Resource Management capabilities.","These function(al) groups illustrated in , B include:\n\n","As mentioned above, the RMComms middleware package provides the internal message passing interfaces between substantially all of the Resource Management functions both within each functional group and between the various functional groups. The middleware provides for automatic location-transparent many-to-many client-server connections. Low-overhead, reliable message passing capabilities are provided. Registration of message handler callback functions for specified requested message types is provided with the message handler functions being invoked when messages arrive. Registration of connection status callback functions, which are invoked when either new connections are made or existing connections are broken, is also provided. The middleware package also allows for multiple client and server objects to be instantiated in the same application, is thread-safe, and provides an easy-to-use object-oriented API through which all capabilities are accessed.","A detailed overview of each functional group and each function instantiated within each of the function groups FG\u2013FG of the exemplary embodiment of the Resource Management Architecture illustrated in , B, including the capabilities provided by the functional group or function, will now be described in greater detail. The discussion below also includes an overview of the information flow between function blocks within the same functional group and between function blocks in separate functional groups.","FG\u2014Host and Network Monitoring Functional Group","Functional group FG provides extensive monitoring capabilities at the host and network levels. The information monitored includes statuses, configuration information, performance metrics, and detected fault conditions. By monitoring the individual hosts and network components within the distributed environment, the functional group FG determines:\n\n","It will be appreciated that the functional group FG makes these determinations by (or while) providing:\n\n","Host monitors FGA\u2013FGN, which monitor the status and performance of hosts A\u2013N, respectively, are instantiated on each host machine within the distributed environment. Host Monitors FGA\u2013FGN employ operating system-level mechanisms to retrieve status, configuration, and performance information on each host A\u2013N. The information retrieved includes:\n\n","The information that the Host Monitors FGA\u2013FGN collect advantageously can be formatted into operating system-independent message formats. These message formats provide a pseudo-standardized set of state, status, and performance information which is useful to other components of the Resource Management Architecture, i.e., other components do not have to be aware of or deal with the minor differences between data formats and semantics. It will be appreciated that since not all the state and performance data is available on every platform, in order to indicate which information is available, a group of flags are set in the host configuration message indicating whether specific data items are valid on a particular platform.","History Servers FGA\u2013FGN are responsible for collecting information from the Host Monitors FGA\u2013FGN and maintaining histories on the statuses, statistics, and performance of each host A\u2013N in the distributed environment. This information advantageously can be requested by other functions instantiated in the Resource Management Architecture. Preferably, the primary consumers of the status information obtained by the History Servers FGA\u2013FGN are the Host Load Analyzer (Hardware Broker) component of the Resource Allocation Decision-Making functional group FG, the Host Display FGA\u2013FGN and the Path Display FG of the Displays functional group FG. The Host Load Analyzer FG receives information on host configuration and loads (primarily CPU, memory, and network data) from History Servers FGA\u2013FGN and employs this information to assign host fitness scores. Each Host Display, e.g., FGA, receives and displays current status information on one of the hosts A\u2013N, including process status information, and network connectivity information. Each Host Display can also request that a respective one of the History Servers FGA\u2013FGN provide CPU load information, network load information, paging activity data, and memory utilization information, which is used to drive line graph charts for specific selected hosts.","It will be appreciated that History Servers FGA\u2013FGN are designed so that multiple copies can be run simultaneously. Each of the History Servers FGA\u2013FGN advantageously can be configured to either monitor all Host Monitors or to monitor only a selected set of Host Monitors. It should be mentioned at this point that the History Servers FGA\u2013FGN determine the list of hosts in the distributed environment that could potentially be monitored from the System Specification Library. In this manner, the History Servers advantageously can be used to provide survivability (by having multiple History Servers connected to each Host Monitor) and\/or to perform load-sharing (with the History Servers FGA\u2013FGN each monitoring only a subset of the Host Monitors). It will also be appreciated that the History Servers FGA\u2013FGN can be configured to periodically record history data to disk. These disk files can then be used for off-line analysis of the Resource Management Architecture.","The Host Discovery function FG employs Perl scripts in making SNMP and ICMP ping calls. These calls are used to periodically scan each subnet and host address in the distributed environment in an attempt to determine whether there have been any host status changes. In an exemplary case, the list of hosts and subnets that are to be monitored is read in from a file; alternatively, this information can reside in and be read from the System Specification Library, which is discussed in greater detail below.","It should be mentioned that when a new host is first detected, the new host's operating system configuration is queried by the Host Discovery function FG via SNMP calls. Information on the newly discovered host and its operating system configuration is then sent to the Program Control function FG in application control functional group FG. Likewise, when a host fails to respond to multiple SNMP and ping queries, a message indicating that the host appears to have gone down is sent to the Program Control function FG.","The final component of the Host and Network Monitoring functional group FG is the Remos Network Data Broker FG, which receives information on network link bandwidth and network link bandwidth utilization from the SNMP-based Remos network monitoring tool mentioned above. The network information is accessed via the Remos application programming interface (API) library and is then sent on to the Host Load Analyzer (Hardware Broker) function FG of the Resource Allocation Decision-Making functional group FG. The network information received from Remos consists of the maximum potential bandwidth and the current bandwidth utilization on specific host network links. As mentioned above, Remos network monitoring tool FG is not a core component of the Resource Management Architecture; that being the case, no further details on either Remos or the Remos Network Data Broker are provided in the instant application.","FG\u2014Application-Level Instrumentation Functional Group","The Instrumentation functional group FG advantageously provides general-purpose application event reporting and event correlation capabilities. The Instrumentation functional group permits instrumented application data to be easily accessible to other components of the Resource Management Architecture. The functional group provides capabilities for collecting and correlating application-provided data such as application statuses, states, performance, and internally detected errors. Low-overhead API's are provided that the applications can use for sending internal event and performance data to the instrumentation components. The instrumentation functional group FG can collect data from applications on hosts A\u2013N throughout the distributed environment. The functional group also provides grammar-driven capabilities for correlating, combining, and reformatting application data into higher-level metrics (composite events) for use by displays or other functional groups of the Resource Management Architecture.","The Instrumentation functional group provides:\n\n","As illustrated in , B, the Instrumentation functional group FG includes the components enumerated below. In addition, Instrumentation APIs and Jewel Instrumentation will be addressed along with the Instrumentation functional group, i.e., the Instrumentation functional group includes:\n\n","The applications, e.g., A\u2013AN, link in the Instrumentation API Library FG and make API calls to construct and send out instrumentation event messages. Three separate APIs are provided for use by the applications:\n\n","Preferably, the instrumented data is sent from the application to one of the Instrumentation Daemons FGA\u2013FGN on a respective one of the hosts A\u2013N where the application is running. The currently preferred mechanism for data transfer is via UNIX FIFO (first in-first out) IPC (inter-process communication) mechanisms. It will be appreciated that the FIFO mechanism was chosen based on reliability, low overhead, and ease of implementation. Alternative data passing mechanisms including shared message queues are considered to be within the scope of the present invention.","As mentioned above, an Instrumentation Daemon resides on each host in the distributed environment. The Instrumentation Daemon is interrupted whenever new data is written to the FIFO. The Instrumentation Daemon reads the data from the FIFO, reformats the data into the standard internal Instrumentation message format (discussed below), and sends the data to each of the respective Instrumentation Collectors FGA\u2013FGN that are currently active. Alternatively, an event request filtering mechanism can be implemented so that specific event messages will only be sent to those ones of the Instrumentation Collectors FGA\u2013FGN that have requested the message.","The standard instrumentation message format includes a header, a format string describing the application-provided data contained in the message, and the actual data values. The message components are illustrated in Attached Appendix B.","The Instrumentation Collectors FGA\u2013FGN receive instrumentation messages from the Instrumentation Daemons FGA\u2013FGN on each host A\u2013N, respectively, in the distributed environment. Currently, the Instrumentation Collectors FGA\u2013FGN send every instrumentation message to all Instrumentation Brokers FGA\u2013FGN and Instrumentation Correlators (Brokers) FGA\u2013FGN that have connected to the Instrumentation Collectors FGA\u2013FGN. The Instrumentation Collectors FGA\u2013FGN serve as a pass-through server for instrumentation messages. The Instrumentation Collectors do support architecture scalability in the sense that without the Instrumentation Collectors, the Instrumentation Broker FG and Instrumentation Correlators FGA\u2013FGN would need to maintain connections to the Instrumentation Daemons FGA\u2013FGN on every host. As discussed above, an event request filtering mechanism advantageously can be implemented so that specific event messages will only be sent to those Instrumentation Brokers\/Instrumentation Correlators that have requested the message.","Preferably, the Instrumentation Correlators FGA\u2013FGN provide grammar-driven capabilities for correlating, combining, and reformatting application data into higher-level metrics (composite events) for use by displays or other components of the Resource Management Architecture. Each Correlator reads in a user-specified correlation grammar file which is interpreted at run-time by the Correlator's instrumentation correlation engine.","The Instrumentation Brokers FGA\u2013FGN are task-specific applications built around a common code package. The Instrumentation Brokers FGA\u2013FGN receive instrumentation messages from the Instrumentation Collectors FGA\u2013FGN, filter all received instrumentation messages to find the messages of interest, and perform task-specific message data reformatting and manipulation for driving other components such as displays or other components of the Resource Management Architecture. This Instrumentation Broker approach permits instrumentation data sources to be quickly integrated for test, display, and debugging purposes.","It should be mentioned at this point that the Jewel Instrumentation Broker FG (hereafter referred to the QoS Monitor) is a legacy architecture component that served as a broker between the Jewel instrumentation package components and Resource Management components and displays. The QoS Monitor FG was responsible for polling the Jewel Collector components to retrieve application event messages. These messages were then reformatted and used to drive several displays and the QoS Managers FGA\u2013FGN. The Jewel instrumentation package has now been replaced in all applications, however the message reformatting capabilities of the QoS Monitor have been maintained so that several displays and the existing QoS Manager interface do not have to be upgraded immediately. The QoS Monitor component has been modified so that it receives instrumentation data from both Jewel and the Instrumentation Collectors.","FG\u2014System Specifications Functional Group","Still referring to , B, it should be noted that a System Specification Language has been developed which allows the user to specify both (1) software system structure, capabilities, dependencies, and requirements, and (2) hardware system (computer and network) structure, capabilities, and configuration. System Specification Files, generally denoted FG, which are based on this specification language, are created by the user and provide a model of the software and hardware components of the distributed computing environment which is used by the Resource Management Architecture. The language grammar advantageously can capture the following information related to the distributed environment and the applications that can run within the distributed environment:\n\n","It will be appreciated that the System Specification Language allows for grouping hardware and software components into systems and subsystems in order to create a hierarchy of components. Each application system and subsystem can be assigned a priority which is used at run-time to determine the relative importance of applications running in the distributed environment.","At the application level, the hardware, operating system, and other host requirements for each application can be specified along with information describing how to start up, configure, and shutdown the application. This information can include:\n\n","At the host level, the operating system and version, the hardware architecture, the host's network interface name, and the SPEC organization's SPECfp95 and SPECint95 ratings for the host can be specified. At the network level, router and switch configurations and bandwidths can also be specified.","Moreover, application data flow paths can be defined including a graph of the data flow between applications along with performance requirements tied to one of more of the applications within the path. It should be mentioned that these defined requirements are named and are tied at run-time to Instrumentation Event data provided by the Instrumentation Correlators FGA\u2013FGN. Monitoring of the performance requirements is the responsibility of the QoS Manager components FGA\u2013FGN, as discussed in greater detail below.","As noted above, the System Specification Language provides a hierarchical structure for defining software and hardware systems. The current structure is shown below:\n\n","The specification information is accessed by linking in a specification parser library FG and making library calls to read in the files and convert them to an internal object model, and by making object access method calls to retrieve specific data items. The specification library is written in C++ and has been ported to all of the development platforms in the testbed. The library is currently being used by most of the Resource Management components, including Program Control FG, the Resource Manager FG, the QoS Managers FGA\u2013FGN, the Hardware Broker FG, and the History Servers FGA\u2013FGN.","It should be mentioned that the software used to construct the API library consists of (1) a parser file that defines the grammar (in BNF format), (2) a lexical analyzer file that defines the tokens of the language, and (3) a set of C++ System Specification classes for storing the specification file information. The lexical analyzer file is compiled with the GNU flex (lex) utility and the parser file is compiled using the GNU bison (yacc) utility. The flex and bison utilities create C source files which are then compiled along with the C++ System Specification object storage classes to create the System Specification Library (SSL) FG. This library is then linked with the Resource Management applications. An overview of this structure is provided in ; a more detailed discussion of the various functions are provided below.","FG\u2014Resource Allocation Decision-Making Functional Group","As illustrated in , B, the Resource Allocation Decision-Making functional group provides the reasoning and decision-making capabilities of the Resource Management architecture. The functions associated with this functional group employ information (listed below) to (1) determine the state and health of the distributed environment (hosts, networks, and applications), and (2) determine what allocation and reallocation actions need to be taken. The information provided to functional group FG includes:\n\n","The subsystem components make decisions based on the following triggers and data sources:\n\n","The Resource Allocation Decision-Making functional group implements one of the three discrete functions listed below:\n\n","As mentioned above, the Resource Manager FG is the primary decision-making component of the Resource Management Architecture. It is responsible for:\n\n","In order to accomplish these tasks, the Resource Manager FG maintains a global view of the state of the entire distributed environment including status information on all hosts A\u2013N, network , and applications A\u2013NM. In addition, the Resource Manager FG also calculates software and hardware readiness metrics and reports these readiness values, for display purposes, to the display functional group FG.","It will be appreciated from , B that the Resource Manager FG receives status and failure information about hosts, networks, and applications from Program Control function FG. This information includes both periodic status updates and immediate updates when statuses change such as a new host being detected or an application failing. In the case of application shutdown, information as to whether the application was shutdown intentionally or whether the application failed is also provided. Program Control function FG also issues requests to the Resource Manager FG when new applications need to be dynamically allocated and when the Program Control function FG determines that the Resource Manager FG needs to assess and attempt to resolve inter-application dependencies (such as one application which needs to be running prior to starting up another application).","The Resource Manager FG responds to faulted applications and hosts by determining whether the failed applications can and should be restarted and attempting to determine where (and if) there are hosts available that the application can run on. When a decision is made by the Resource Manager FG, a message is sent to Program Control FG specifying what application to start and where to put it, i.e., which of hosts A\u2013N to start the application on. The same general mechanism is used when Program Control FG requests that the Resource Manager FG determine where to start new applications and\/or how to resolve inter-application dependencies; the Resource Manager FG responds with orders indicating what applications to start and where to start them. The Resource Manager FG advantageously can send application shutdown instructions to Program Control FG requesting that a certain application be stopped; this can occur when the QoS Managers FGA\u2013FGN indicate that certain scalable applications have too many copies running or when application system priority changes (when an application changes from a high priority to a lower priority) occur resulting in scaling back the application system configuration.","The Resource Manager FG also receives host load and host fitness information on all known hosts from the Hardware Broker (Host Load Analyzer) FG. This information includes (1) overall host fitness scores, (2) CPU-based fitness scores, (3) network-based fitness scores, and (4) memory and paging-based fitness scores, along with (5) the SPEC95\u2122 rating of the hosts. These scores are used by the Resource Manager FG for determining the \u201cbest\u201d hosts for placing new applications when:\n\n","It should be noted that when the Resource Manager FG is first started, it reads in the System Specification Files FG (via calls to System Specification Library FG) which contains the list of hosts that are known to be associated with the distributed environment and information on all applications that can be run in the distributed environment. The application-level information includes where, i.e., on which host, specific applications can be run, which applications are scalable, which applications can be restarted, and any dependencies between applications.","The Resource Manager FG currently responds to application system priority changes received from the Readiness Broker (translation software in or associated with the Readiness Display FG) in the following manner:\n\n","The Resource Manager FG also sends information about allocation and reallocation decisions to the Resource Management Decision Review Displays FGA\u2013FGN, as discussed in greater detail below. Information on the decision that was made, what event the decision was in response to, and how long it took to both make the decision and implement the decision advantageously are also sent to the display functional group FG. In addition, information about the alternative choices for where an application could have potentially been placed is also provided (if applicable); in an exemplary case, this information includes the host fitness scores for the selected host and the next best host choices which could have been selected.","As described above, the Resource Manager FG communicates with Program Control FG, the Hardware Broker FG, the QoS Managers FGA\u2013FGN, QoS Specification Control (not shown), the Readiness Broker of display FG, the Globus Broker (e.g., message translation software (not shown)), and the RM Decision Review Displays FGA\u2013FGN using the RMComms middleware, which will be discussed in greater detail below.","The Hardware Broker (Host Load Analyzer) FG is the host load analysis component of the Resource Management Architecture, which is primarily responsible for determining the host and network loads on each host A\u2013N within the distributed computing environment. The Hardware Broker FG assigns a set of fitness scores for each host and periodically provides the list of fitness scores to the Resource Manager FG.","The Hardware Broker FG advantageously receives operating system-level statuses and statistics for each host A\u2013N from the History Server(s) FGA\u2013FGN, respectively. This information can be employed for calculating CPU, network, memory, paging activity, and overall fitness scores for each of the hosts A\u2013N. Preferably, the Hardware Broker FG periodically, e.g, once per second, provides the complete list of host fitness scores to the Resource Manager FG.","It should be noted that when the Hardware Broker FG is first started, it reads in the System Specification Files FG (via calls to the System Specification Library (SSL) FG), which files contain the list of hosts that are known to be in the distributed environment. The Hardware Broker FG also receives, e.g., reads in a file containing, information about the bandwidth and maximum packet sizes on all known network subnets in the distributed environment. It will be appreciated that this data advantageously can be used for converting host network load information based on packet counts to load information based on bytes per second and percentage of available bandwidth.","Periodically, e.g., approximately every three seconds, the Hardware Broker FG transmits a list of overall and network host fitness scores to the Hardware Broker Instrumentation Display which was constructed using the Graph Tool Instrumentation Display FGA\u2013FGN. Moreover, the Hardware Broker FG advantageously can receive host-based network load data from the Remos Network Data Broker function FG, which receives network data via the Remos Network Monitoring software 2. It should be noted that if Remos network data is available for any of the hosts A\u2013N that are being monitored, the Remos reported network data advantageously can be used for calculating the network fitness score for that host, rather than using the host network data received from the History Server(s) FGA\u2013FGN.","The QoS Managers FGA\u2013FGN of functional group FG are responsible for monitoring application-level performance requirements. These requirements are defined in the System Specification Files FG and are monitored primarily via instrumentation data obtained directly from the application code. The QoS Managers FGA\u2013FGN advantageously can determine if applications or application paths are meeting their assigned requirements. If an application is not meeting its performance requirements and the application is scalable (in the sense that multiple copies can be run and the copies will perform load-sharing across the copies), the QoS Managers FGA\u2013FGN will either request that the Resource Manager FG scale up a new copy of the application or move the application to a new host (as an attempt to achieve better performance). Moreover, if there are multiple copies of a scalable application running, and all copies are performing well below the specified requirement threshold, the QoS Managers FGA\u2013FGN will request that the Resource Manager FG shutdown a specific copy. It should be noted that the division of responsibility between the QoS Managers FGA\u2013FGN and the Resource Manager FG is that the QoS Managers determine what actions would potentially improve performance, while the Resource Manager has final authority to determine whether to implement the requested action(s).","Each of the QoS Managers FGA\u2013FGN can be scaled for both redundancy and for load-sharing. In an exemplary case, each copy of the QoS Manager monitors all of the requirements associated with a single application path defined in the System Specification Files FG. It will be appreciated that the specific path to be monitored can be specified via command-line parameters. By default, without specifying a path via the command-line, the QoS Managers FGA\u2013FGN will monitor all requirements for all paths defined in the System Specification Files FG.","It should be mentioned that, in one exemplary embodiment, the QoS Managers FGA\u2013FGN each employ a sliding window algorithm to determine when to declare that applications should be scaled up or scaled down. The inputs to the algorithm define both high and low sampling window sizes, the maximum number of allowed violations within the sampling window, and violation thresholds as a percentage of the actual specified requirement value. It should also be mentioned that the sliding window algorithm was selected in order to damp out unexpected \u201cnoise\u201d or \u201cspikes\u201d in the measured performance data. Moreover, the threshold value as a percentage of the actual requirement value was selected in order to scale up, or scale down, prior to violating the specified hard requirement. The QoS Managers FGA\u2013FGN provide application scale up and scale down requests to the Resource Manager FG when the measured performance data for an associated application violates either the high (scale up) or low (scale down) sliding window criteria for a specific requirement. A scale up request indicates which application on which host has violated the performance criteria, and a scale down request indicates which application on which host is recommended to be shutdown. It will be appreciated that the success of this algorithm is highly dependent on the rate of change and noisiness of the measured data.","Any of the QoS Managers FGA\u2013FGN can also request that the Resource Manager FG move an application. This will occur in the case where one copy of an application is performing much worse than all other running copies of the same application. In an exemplary case, the move request is implemented as a scale up request followed by a scale down request (of the badly performing copy). In that case, the scale down request does not get sent to the Resource Manager FG until the scale up action has been implemented. The QoS Managers FGA\u2013FGN preferably employ application \u201csettling times,\u201d defined in the System Specification Files FG, to ensure that once a requested action has been sent to the Resource Manager FG that no additional actions are requested for that application until after the settling time has elapsed. It will be appreciated that this provides time for initialization and configuration among the application copies to occur. Alternatively, System Specification Language inter-application dependency definitions advantageously can be used instead of settling times.","The QoS Managers FGA\u2013FGN also receive application status and state information from Program Control FG, which periodically sends application status updates for all running applications and also sends immediate indications of any applications which have been started or stopped. This information is used by the QoS Managers FGA\u2013FGN, along with the instrumented performance data being received via the QoS Monitor FG and Instrumentation Correlator FG, to determine the exact state of all monitored applications that are running. This information is also used to determine when (and if) requested actions have been implemented by the Resource Manager FG. The information is also used for setting up and discarding internal data structures used for monitoring the performance of each application A\u2013NM.","It will be appreciated that the QoS Managers FGA\u2013FGN also receive application-level instrumentation data indicating current application performance values from the Instrumentation Correlators (Brokers) FGA\u2013FGN, the Instrumentation Brokers FGA\u2013FGN, and\/or the Jewel Instrumentation Broker (QoS Monitor) FG. The instrumentation data that is received contains (at a minimum) (1) the timetag when the data was generated, (2) the hostname and IP address of the host where the application that the data is associated with is running, (3) the process id (pid) of the application that the data is associated with, and (4) the event number of the instrumentation message. Preferably, the event number of the instrumentation message specifies the type of instrumentation data that has been received; the hostname, IP address, and pid are used, in conjunction with the application data received from Program Control FG, to determine the specific application that the data is associated with.","When the contents of the instrumentation message match any of the application performance requirements that are currently being monitored by the QoS Managers FGA\u2013FGN, the data value is added to the proper requirement sliding window for the specified application. The sliding window algorithm is then checked to determine if the new sample triggered a violation of either the high or low sliding window. If a high threshold sliding window violation occurs and the application does not already have the maximum number of copies running, a determination is made as to whether performance can be best improved by starting a new application (scale up) or by moving an existing copy to a different host. The corresponding action recommendation will then be sent to the Resource Manager FG. In an exemplary case, the criteria for determining whether an application should be moved rather than scaled up is based on relative performance of the replicated applications. More specifically, if one application is performing much worse [>50%] than the other copies, the recommendation will be to move the application. Likewise, if the new sample triggers a low threshold sliding window violation and the application has more than the minimum number of copies running, a recommendation will be sent to the Resource Manager FG requesting that the copy of the application that is experiencing the worst performance be scaled down.","FG\u2014Resource (Application) Control Functional Group","As discussed above, the Resource Control capabilities provided by the Resource Management Architecture consist of controlling application startup, configuration, and shutdown on hosts within the distributed environment. This capability, known as Application Control or Program Control (hereafter referred to as Program Control) provides a powerful distributed configuration capability. The Program Control capabilities permit an operator to startup and control applications running on platforms throughout the distributed environment via an easy-to-use interactive display. These capabilities are provided by the Application Control functional group FG.","More specifically, the Application Control functional group provides application control (i.e., Program Control) capabilities which permit starting, stopping, and configuring applications on each of the hosts in the distributed environment. The functional group provides both interactive operator control of the distributed environment as well as automatic control via configuration orders received from the Resource Allocation Decision-Making functional group FG, i.e., the Resource Manager component. The interactive controls allow an operator to create, load, save, and edit pre-defined system configurations, e.g., lists of applications that are to be run, with or without specific host mappings, determine the status and configuration of currently running programs, and start and stop any or all applications. Both static (operator-entered) mappings of applications to hosts and dynamic mappings of applications to hosts (where the Resource Allocation Decision-Making functional group FG will be queried to determine the proper mapping at run-time) advantageously can be defined. The functional group also provides application fault detection capabilities which are triggered by the unexpected death, i.e., fault, of an application that was started by the functional group. A basic host fault detection capability is also provided which is triggered based on failure to receive heartbeat messages from functional group components running on a particular host.","A brief description of each function provided by the functional group FG is provided below; a detailed discussion of the Resource Control functional group FG and associated data flow will be provided in discussing .\n\n","It should be mentioned here that the Program Control functional group employs the application startup and shutdown information defined in the System Specification Files FG. When an application entry is first created interactively at one of the Program Control Displays FGA\u2013FGN, all of the startup and shutdown information for that application, as specified in the System Specification Files FG, are loaded in as default settings. Once a configuration file entry has been created, all configuration information on the application is read in from the configuration file except for the application environment variable settings which are still set based on the System Specification Files FG.","As mentioned above, a Program Control agent resides on each host. The agent is responsible for providing direct control over application startup and shutdown. The agent receives control orders from the Control component and is then responsible for implementing the orders. Each of the PC Agents FGA\u2013FGN implements application startup and shutdown orders via system call mechanisms specific to the particular operating system of the host. For example, on the Unix platforms, to start an application, the fork( ) and execv( ) function calls are used to create the application. The csh command is executed to start up the applications. Moreover, if the application needs to run in a console, an xterm is configured for the application to run in. In addition, if logging of either stdout or stderr is specified, the proper redirection operators are configured and the output log file is set to \u201c\/usr\/tmp\/<userid>_<appname>_<pid>.log\u201d. All environment variables needed by the application are also configured and passed in at the execv( ) call. The current working directory is also set by the chdir( ) command, and the new application is made a process group leader via the setpgid( ) function. Other operating systems invoke applications using different calls.","In order to stop an application on the Unix platforms, if a signal is to be sent to the application, the killpg( ) function is used, or else if a script or command is to be executed to shutdown the application, the csh command is executed (via the system( ) function) specifying the full path and executable name of the command along with any arguments for the command. It should be noted that if the application default shutdown time elapses and the application has not died, the respective one of the Program Control Agents FGA\u2013FGN advantageously sends a SIGKILL signal to the application by calling killpg( ).","As illustrated in , B, the Program Control Agents (PCA\u2013PCN) advantageously can be instantiated on stand-alone hosts A\u2013N. In that case, the Program Control Agents PCA\u2013PCN (FGA\u2013FGN in , B) send heartbeat messages to Program Control FG approximately once per second to indicate that they are still \u201cup and running.\u201d Moreover, every ten seconds, the Program Control Agents PCA\u2013PCN (FGA\u2013FGN) send complete configuration information on all running applications to Program Control FG. It should be noted that the terminology employed in , B differs from that in , B to emphasize the distinction between software instantiated on a host and a function provided by the Resource Management Architecture.","The Program Control function FG is the decision-making component of the Program Control functional group FG. It maintains complete information on everything that is running across all platforms in the distributed environment. The Program Control function FG receives input data from PCA\u2013PCN (FGA\u2013FGN), the Program Control Displays FGA\u2013FGN, the Resource Manager FG, and the Host Discovery function FG.","It will be appreciated from the preceding discussion that the Program Control FG provides startup and shutdown orders to the Program Control Agents FGA\u2013FGN based on operator or Resource Manager-initiated orders. If the Program Control Agents report that an application has terminated abnormally, the Program Control FG provides a notification to the Resource Manager FG, to the Program Control Displays FGA\u2013FGN, and to any other component to which it is connected. When the Program Control function FG is first brought up, it can be configured to attempt to start Program Control agents on every host defined in the System Specification Files. The Program Control function FG will also attempt to start a Program Control Agent on a newly discovered host (discovered via the Host Discovery function FG) if Host Discovery has been enabled on the Program Control Displays FGA\u2013FGN.","The Program Control function FG also receives periodic heartbeat messages, e.g., once per second, from each of the Program Control Agents FGA\u2013FGN, as discussed above. If Fault Detection has been enabled at the Program Control Displays FGA\u2013FGN, if three consecutive heartbeat messages from an Agent, e.g., FGA, are missed, the host that the agent is running on is declared down and all linked functions, including the Resource Manager FG and the Displays FGA\u2013FGN are notified.","As mentioned above, the Program Control function FG sends out periodic application status updates as well as immediate notification when applications are started up, are shutdown, or fail. These notifications are sent out to all linked functions.","It should be noted that the Program Control function FG uses the same message traffic and internal processing for handling application startup and shutdown orders received from either the Resource Manager FG or from the Program Control Displays FGA\u2013FGN. However, if a startup order received from one of the Program Control Displays FGA\u2013FGN indicates that the Resource Manager FG should determine where to run the application, a request to allocate the application is sent to the Resource Manager FG. When no response is received from the Resource Manager FG within a predetermined timeout period, the Program Control function FG will automatically start the application on the default host. Moreover, when an application startup cannot proceed due to an unfulfilled application startup dependency, a request will be made to the Resource Manager FG to attempt to resolve the dependency. If the Resource Manager FG either cannot resolve the dependency or no response is received within a predetermined timeout period, the application startup will fail, and a \u201cdependency failed\u201d indication will be sent to the Display. It will be appreciated that this will cause the application status to be displayed in, for example, yellow and post an alert to the Alert window on one of the Program Control Displays FGA\u2013FGN.","Preferably, Program Control function FG also handles simple startup timing dependencies between applications and will reorder a list of applications that were selected to be started simultaneously if doing so will resolve startup order dependencies between the applications. Otherwise, the Program Control function FG sends a request to the Resource Manager to attempt to resolve the dependencies.","The Program Control Display serves as the operator console for controlling the distributed environment. From the Display, shown in , B, the operator can:\n\n","It will be appreciated from , B that multiple Program Control Displays FGA\u2013FGN advantageously can be run simultaneously. If this is done, any configuration change actions will be reflected on all the displays. Whenever application stop or start actions are taken by the display operator, a message is sent to the Program Control function FG which is responsible for enacting the start or stop action. The Program Control function FG also sends indications of any status changes to the Program Control Displays FGA\u2013FGN as soon as the status changes are seen. In addition, periodic status updates are also sent to the Program Control Displays FGA\u2013FGN.","The Program Control Configuration Files are text files that are read in by the Program Control Display when the operator wishes to load a new application configuration. A Configuration File is an ASCII file containing a list of applications. The format of an entry in a Configuration File is shown in Table 1 below.",{"@attributes":{"id":"p-0108","num":"0282"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Application","TACFIRE:tacfire"]},{"entry":["Host","electra1"]},{"entry":["Display","umbriel1:0.0"]},{"entry":["Auto_Start","0"]},{"entry":["RM_Start","0"]},{"entry":["Console","1"]},{"entry":["Time_Delay","1"]},{"entry":["StartupDir","\u201c$ENV_SIM_VERSION\/TACFIREprocessor\u201d"]},{"entry":["StartupExe","\u201c$ENV_SIM_VERSION\/TACFIREprocessor\/tacfire\u201d"]},{"entry":["StartupArgs","\u201c-disport \u2003$DIS_PORT_NUM \u2003-cffhost"]},{"entry":[{},"%(HOSTNAME, AAW:Tactical_Sims:CFF_Broker)\u201d"]},{"entry":["ShutdownExe","SIGINT"]},{"entry":["LogType","STDOUT"]},{"entry":["LogDir","\u201c\/usr\/tmp\u201d"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The Configuration file advantageously can include the following fields:\n\n","A number of displays which show system configuration data and instrumentation data in near real-time are included as part of the Resource Management Architecture. These displays support operator and user monitoring of the operation of the distributed environment including host and network statuses and performance, application system statuses and performance, as well as the status and performance of the other Resource Management architecture functions. Most of the displays use OpenGL and Motif, the latter being built with ICS's Builder Xcessory toolkit, and run on Silicon Graphics (SGI) platforms in an exemplary case. Several of the displays can also run on the Sun Solaris platforms. The displays that make up the display functional group FG include:\n\n",{"@attributes":{"id":"p-0111","num":"0303"},"figref":["FIGS. 6A","FIGS. 7A"],"b":["6","62","62","7"]},{"@attributes":{"id":"p-0112","num":"0304"},"figref":"FIGS. 8A","b":["8","64"]},{"@attributes":{"id":"p-0113","num":"0305"},"figref":"FIGS. 9A","b":["9","68","42","42","50"]},{"@attributes":{"id":"p-0114","num":"0306"},"figref":"FIGS. 10A","b":["10","11","11","69","69","69","69"]},{"@attributes":{"id":"p-0115","num":"0307"},"figref":"FIGS. 12A","b":["12","66","66","42"]},"As mentioned above, the RMComms middleware package provides object-oriented client-server services for message communication between distributed applications and function modules. The middleware provides location transparency and automatic socket connections and reconnections between client and server applications. These services advantageously can be accessed through an object-oriented API which allows client and server objects to be easily created and exchange user-defined message data. The abstraction provided by the API allows the user to quickly and easily create distributed applications without needing to be aware of the details of the underlying network mechanisms. The RMComms middleware provides the following functions:\n\n","The RMComms middleware is implemented as a shareable object-oriented C++ library. The library provides four primary object classes, which are detailed in Attached Appendix C. It will be appreciated that the applications link with this library and can then instantiate client and server objects for communicating with other local or remote applications. It should be mentioned that the application source code must also include a set of header files that allow connections between client and server objects, where each server type is assigned a server port number. For clients and servers that want to communicate, both the client and the server objects are created specifying the same server port number. Multiple servers of the same type can also be created, which all use the same server port number. This advantageously provides the ability for many-to-many client-server connections to be established, as illustrated in . Control of which servers the clients actually connect to is handled on the client side; clients can specify whether they wish to establish connections with all servers in the distributed environment, with a particular set of servers, or with all servers running on a particular set of hosts.","The operation of the Resource Management Architecture will now be described while referring to , which illustrate various operations in the distributed environment. More specifically, the Resource Management Architecture of the system illustrated in  includes hosts A\u2013N, where host A provides a video source server application A-, host B provides a video distribution application B-, a contract application B-, and a host load monitor B-, and host C provides a display broker application C- applying video signals to a display driver C-. It will be appreciated that host D is idle and that the connections between the various hosts constitute the network \u2032. In addition, the Resource Management Architecture of  instantiates various functions, e.g., an instrumentation broker FG\u2032, a QoS manager FG\u2032, a resource manager FG\u2032 and a program control FG\u2032. The instrumentation broker FG\u2032 receives data from each of the applications running in the distributed environment, although only the lines of communication between the applications running on host B are actually depicted. From the discussion above, it will be appreciated that each of the applications is linked to an Instrumentation API.","Referring now to , a QoS violation and its consequences is depicted. In particular, the Instrumentation broker FG\u2032 provides data to the QoS manager FG\u2032 which is indicative of a QoS violation. The QoS manager FG\u2032 notifies the resource manager FG\u2032 of the violation; the resource manager determines that duplicate copies of the applications running on host B are required and that these copies should be placed on host D. The resource manager FG\u2032 transmits instructions to the Program Control function FG\u2032, which starts copies of the running applications, i.e., a video distribution application D-, a contract application D-, and a host load monitor D-, on host D.  illustrates shutdown of the application copies running on host B. It will be appreciated that this shutdown may be initiated responsive to the original QoS violation, another QoS violation, or a query from the user.","Having discussed the various functions and features of the Resource Management Architecture in gross, selected functions and features will now be described in detail. It will be appreciated that the discussion of the various functions will be signaled using the designations established with respect to , B.","FG\u2014Resource Manager Function","As mentioned above, the Resource Manager FG is the primary decision-making component of the Resource Management functional group. It is responsible for:\n\n","In order to accomplish these tasks, the Resource Manager FG maintains a global view of the state of the entire distributed environment including status information on all hosts, networks, and applications. In addition, the Resource Manager FG also calculates software and hardware readiness metrics and reports these readiness values for display purposes.","The Resource Manager FG is an object-oriented multi-threaded application written in C++, which uses the RMComms middleware for all external communication. The Resource Manager FG communicates with the various software components instantiating the (1) Program Control FG, 2) Hardware Broker FG, 3) QoS Managers FGA\u2013FGN, 4) QoS Specification Control FG, 5) Readiness Broker in Readiness Display FG, 6) Globus Broker (not shown), and 7) RM Decision Review Displays FGA\u2013FGN.","It will be appreciated that the Resource Manager FG receives status and failure information about hosts and networks from the Host and Network Monitoring functional group FG, and applications from the Program Control functional group FG. This information includes periodic status updates as well as immediate updates when statuses change, e.g., when a new host is detected or an application fails. In the case of any application shutdown, information as to whether the applications were intentionally shutdown or whether the application actually failed advantageously can be provided. The Program Control function FG also issues requests to the Resource Manager FG whenever new applications need to be dynamically allocated and whenever the Program Control function FG determines that the Resource Manager FG needs to assess and attempt to resolve inter-application dependencies (e.g., one application which needs to be running prior to starting up another application).","The Resource Manager FG responds to applications faults and host failures by determining whether the failed applications can and should be restarted and attempting to determine where (and if) there are hosts available that the application can run on. When a decision is made by the Resource Manager FG, a message is sent to Program Control function FG specifying what application to start and where to put it. The same general mechanism is used when the Program Control function requests that the Resource Manager FG determine where to start new applications and\/or how to resolve inter-application dependencies; the Resource Manager FG responds with orders indicating what applications to start and where to start them. The Resource Manager FG advantageously can send application shutdown orders to the Program Control function FG requesting that a certain running application be stopped; this can occur when the QoS Managers indicate that certain scalable applications have too many copies running or when application system priority changes (to lower priorities) occur resulting in scaling back the application system configuration. See  and the associated discussion above.","The Resource Manager FG receives host load and host fitness information from the Hardware Broker (Host Load Analyzer) function FG. This information includes overall host fitness scores, CPU-based fitness scores, network-based fitness scores, and memory and paging-based fitness scores along with the SPEC rating of the hosts. This information is received approximately once a second and includes information on all known hosts in the distributed system. These scores are used by the Resource Manager FG for determining the \u201cbest\u201d hosts for placing new applications when:\n\n","Advantageously, the Resource Manager FG also receives requests from the QoS Managers FGA\u2013FGN for scaling up, moving, or scaling down specific applications. The Resource Manager FG responds to these requests by determining whether the request should be acted upon and, if so, determines the specific action to take and issues orders to the Program Control function FG to start up or shutdown specific applications on specific hosts. The QoS Managers FGA\u2013FGN are responsible for monitoring specific system performance metrics (e.g., quality of service, or QoS, requirements) via instrumentation and determining if performance can be improved by scaling up or moving certain applications. When this occurs, the QoS Managers send a request to the Resource Manager FG indicating that a new copy of a specific application should be started. If the QoS Managers determine that the performance of a scalable application can be improved by moving an application, a scale up request is first sent to the Resource Manager FG and when the new application has been started, a scaledown request is then sent to the Resource Manager FG. Moreover, when the QoS Managers FGA\u2013FGN determine that there are more copies of scalable application running then are needed, requests to shutdown specific applications are sent to the Resource Manager FG.","It will be appreciated that the Resource Management Architecture distributes functionality between the QoS Managers FGA\u2013FGN and the Resource Manager FG. Thus, the QoS Managers determine what actions would potentially improve performance, while the Resource Manager FG has final authority to determine whether to implement the requested actions.","It should be noted that when the Resource Manager FG is first started, it reads in the System Specification Files FG (via calls to the System Specification Library (SSL) FG) which contains the list of hosts that are known to be (operating) in the distributed environment and information on all applications that can be run in the distributed environment. The application-level information includes where specific applications can be run, which applications are scalable, which applications can be restarted, and any dependencies between applications. In addition, the Resource Manager FG receives updated application survivability specifications from the QoS Specification Control function. This information overrides the application survivability information that was initially loaded in from the System Specification Files FG for the specified application. The information is used by the Resource Manager FG to determine whether the specific application will be restarted if it fails at run-time.","It should also be noted that the Resource Manager FG sends application system and hardware system readiness and system (mission) priority information to the Readiness Broker, which is a translator withing the Readiness Display FG and to the Globus Broker (another Broker (not shown)). The Readiness Broker is responsible for driving a GUI\/display FG, which shows the current readiness data and allows the system (mission) priorities to be changed and sent back to the Resource Manager FG. The Globus Broker provides basically the same functionality except that only a high-level subset of the readiness data provided to the Readiness Broker is provided to the Globus Broker. The readiness information sent to the Readiness Broker consists of readiness values for each application, application subsystem, and application system defined in the System Specification Files FG. The scores advantageously can be based on the status (up\/down) of the applications and the percentage of potential copies of scalable applications that are currently running. Host and network readiness scores are determined based on the host loads and host fitness scores received from the Hardware Broker FG.","The Resource Manager FG also sends information about allocation and reallocation decisions to the RM Decision Review Display FG (, B). Information on the decision that was made, what event the decision was in response to, and how long it took to both make the decision and implement the decision are sent to the display. In addition, information about the top choices for where an application could have potentially been placed is also sent (if applicable); this information includes the host fitness scores for the selected host and other hosts which could have been selected.","As described above, the Resource Manager function FG communicates with Program Control FG, the Hardware Broker FG, the QoS Managers FGA\u2013FGN, QoS Specification Control (not shown\u2014legacy function), the Readiness Broker of the Readiness Display FG, the Globus Broker (not shown), and the RM Decision Review Display FG using the RMComms middleware. The message formats and contents of each message that is exchanged between the Resource Manager function FG and other functional elements of the Resource Management architecture are described in CD-Appendix D. The timing and\/or event trigger for each message is also described.","FG\u2014Host Load Analyzer (Hardware Broker) Function","The Hardware Broker FG provides the host load analysis function of the Resource Management functional group FG. It is responsible primarily for determining the host and network loads on each host within the distributed computing environment. The Hardware Broker FG assigns a set of fitness scores for each host and periodically provides the list of fitness scores to the Resource Manager FG.  illustrates the connectivity and high-level data flow between the Hardware Broker and the other Resource Management and Resource Management-related components.","The Hardware Broker FG is an object-oriented multi-threaded application written in C++, which uses the RMComms middleware for all external communication. It receives operating system-level statuses and statistics for each host from the History Server(s) FGA\u2013FGN. This information is used for calculating CPU, network, memory, paging activity, and overall fitness scores for each host. The Hardware Broker periodically (once per second) sends the list of host fitness scores to the Resource Manager FG.","When the Hardware Broker FG is first started, it reads in the System Specification Files FG (via calls to System Specification Library (SSL) FG) which contain the list of hosts that are known to be in the distributed environment. The Hardware Broker also reads in the file networks.dat which contains a list of information about the bandwidth and maximum packet sizes on known network subnets. It should be mentioned that this data is used for converting host network load information based on packet counts to load information based on bytes per second and percentage of available bandwidth.","It should be mentioned that there are two other RMComms interfaces that the Hardware Broker FG uses. Periodically (approximately every three seconds), the Hardware Broker FG sends a list of overall and network host fitness scores to the Hardware Broker Instrumentation Display FGA\u2013FGN. As mentioned above, these displays were constructed using the Graph Tool described in the Instrumentation Graph Tool Display. Additionally, the Hardware Broker FG can receive host-based network load data from the Remos Broker FG, which receives network data via the Remos Network Monitoring software (denoted  in , B). If Remos network data is available for any of the hosts that are being monitored, the Remos data is used for the network fitness score calculation for that host rather than the host network data received from the History Server(s).","The exemplary instance of the Hardware Broker FG is an object-oriented multi-threaded application. At the highest level, the Hardware Broker object contains the elements listed in Table II below. It will be noted that Table II contains a brief description of each of these objects. Additional details are provided in CD-Appendix E.",{"@attributes":{"id":"p-0138","num":"0374"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE II"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["No.","Title","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","Host Fitness Database","The Host Fitness Database object stores load history"]},{"entry":[{},"object (FitnessDB","data and fitness score information for each host. The"]},{"entry":[{},"class)","Host Fitness Database is updated and fitness scores are"]},{"entry":[{},{},"recalculated when new History Server Host Status"]},{"entry":[{},{},"Response Messages are received. For each host, a"]},{"entry":[{},{},"circular queue of host load history data (HostInstance"]},{"entry":[{},{},"class) is maintained with the newest data being placed"]},{"entry":[{},{},"at the end of the queue; this history data is used for"]},{"entry":[{},{},"recalculating host fitness scores. The Host Fitness"]},{"entry":[{},{},"Database also contains a System Specification Library"]},{"entry":[{},{},"(SSL) object which is used to access SPEC rating"]},{"entry":[{},{},"information for the hosts."]},{"entry":["2","Signal Registration","The Signal Registration object allows for a user-"]},{"entry":[{},"object (SignalRegistry","defined SIGINT signal handler to be registered in order"]},{"entry":[{},"class)","to permit the Hardware Broker FG40 to be shutdown"]},{"entry":[{},{},"gracefully."]},{"entry":["3","Network Subnet","The Network Subnet Information Database object is"]},{"entry":[{},"Information Database","used to store IP address, maximum bandwidth, and"]},{"entry":[{},"object (SubnetDB","MTU size for each network specified in the"]},{"entry":[{},"class)","networks.dat file. This information is used for"]},{"entry":[{},{},"converting network packet load information to"]},{"entry":[{},{},"bytes\/second network load information."]},{"entry":["4","Remos Host Network","The Remos Host Network Bandwidth Database object"]},{"entry":[{},"Bandwidth Database","stores the latest Remos-reported network bandwidth"]},{"entry":[{},"object (RemosDB","information for each host being monitored. The"]},{"entry":[{},"class)","information stored consists of available bandwidth as"]},{"entry":[{},{},"well as maximum potential bandwidth on a specific"]},{"entry":[{},{},"host network link. If Remos bandwidth information is"]},{"entry":[{},{},"available for a host and the latest data is less than 5"]},{"entry":[{},{},"seconds old, the Remos data will be used for"]},{"entry":[{},{},"calculating the network fitness score for the host."]},{"entry":["5","History Server","The History Server Interface object inherits from the"]},{"entry":[{},"Interface object","RMComms TCPCommClient class and is responsible"]},{"entry":[{},"(HistServInterface","for maintaining connections to the History Server(s),"]},{"entry":[{},"class)","for registering status and message handler callback"]},{"entry":[{},{},"functions, for sending messages to the History"]},{"entry":[{},{},"Server(s), and for invoking the status and message"]},{"entry":[{},{},"handler callback functions when connections to"]},{"entry":[{},{},"History Servers are either established or broken or new"]},{"entry":[{},{},"messages are received from a History Server."]},{"entry":["6","Instrumentation Graph","The Instrumentation Graph Tool Display Interface"]},{"entry":[{},"Tool Display Interface","object inherits from the RMComms TCPCommServer"]},{"entry":[{},"object (InstrInterface","class and is responsible for maintaining connections to"]},{"entry":[{},"class)","the Graph Tool Display(s), for registering status and"]},{"entry":[{},{},"message handler callback functions, for sending"]},{"entry":[{},{},"messages to the Graph Tool Display(s), and for"]},{"entry":[{},{},"invoking the status and message handler callback"]},{"entry":[{},{},"functions when connections to Graph Tool Displays"]},{"entry":[{},{},"are either established or broken or new messages are"]},{"entry":[{},{},"received from a Graph Tool Display."]},{"entry":["7","Resource Manager","The Resource Manager Interface object inherits from"]},{"entry":[{},"Interface object","the RMComms TCPCommServer class and is"]},{"entry":[{},"(ResMgrInterface","responsible for maintaining connections to the"]},{"entry":[{},"class)","Resource Manager for registering status and message"]},{"entry":[{},{},"handler callback functions, for sending messages to the"]},{"entry":[{},{},"Resource Manager, and for invoking the status and"]},{"entry":[{},{},"message handler callback functions when connections"]},{"entry":[{},{},"the Resource Manager are either established or broken"]},{"entry":[{},{},"or new messages are received from the Resource"]},{"entry":[{},{},"Manager."]},{"entry":["8","Remos Broker","The Remos Broker Interface object inherits from the"]},{"entry":[{},"Interface object","RMComms TCPCommClient class and is responsible"]},{"entry":[{},"(RemosInterface class)","for maintaining connections to the Remos Broker for"]},{"entry":[{},{},"registering status and message handler callback"]},{"entry":[{},{},"functions, for sending messages to the Remos Broker,"]},{"entry":[{},{},"and for invoking the status and message handler"]},{"entry":[{},{},"callback functions when connections the Remos"]},{"entry":[{},{},"Broker are either established or broken or new"]},{"entry":[{},{},"messages are received from the Remos Broker."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"44"},"The QoS Managers FGA\u2013FGN are responsible for monitoring application-level performance requirements, which requirements are defined in the System Specification Files FG and are monitored primarily via instrumentation data obtained directly from the application code. The QoS Managers FGA\u2013FGN advantageously determine if applications or application paths are satisfying their assigned requirements. When an application is not meeting its performance requirements and the application is scalable (in the sense that multiple copies can be run and the copies will perform load-sharing across the copies), the QoS Managers FGA\u2013FGN will either request that the Resource Manager FG scale up a new copy of the application or move the application to a new host (which hopefully will result in better performance). Moreover, if there are multiple copies of a scalable application running, and all copies are performing below the specified requirement threshold, the QoS Managers FGA\u2013FGN will request that the Resource Manager shutdown a specific copy.","The QoS Manager is a single-threaded application written in C\/C++. It should be noted that the application can be scaled for both redundancy and\/or load-sharing. In an exemplary case, each copy of the QoS Manager monitors all of the requirements associated with a single application path defined in the System Specification Files FG. It will be appreciated that the specific path to be monitored can be specified via command-line parameters. By default, without specifying a path via the command-line, the QoS Manager will monitor all requirements for all defined paths.","As mentioned above, the QoS Manager advantageously uses a sliding window algorithm to determine when to declare that applications should be scaled up or scaled down. The inputs to the algorithm define both high and low sampling window sizes, the maximum number of allowed violations within the sampling window, and violation thresholds as a percentage of the actual specified requirement value. It will be appreciated that the sliding window algorithm was selected in an effort to damp out unexpected \u201cnoise\u201d or \u201cspikes\u201d in the measured performance data. Use of threshold value states as a percentage of the actual requirement value was selected in order to scale up, or scale down, prior to violating the specified hard requirement. It will be understood that the success of this approach is highly dependent on the rate of change and noisiness of the measured data.","Again, the QoS Manager uses the RMComms middleware for all external communication. Each copy of the Resource Manager talks to (1) Resource Manager FG, (2) Program Control FG, (3) QoS Specification Control (not shown), (4) QoS Monitor FG, (5) Instrumentation Correlators FGA\u2013FGN, (6) Graph Tool Instrumentation Displays FGA\u2013FGN, and (7) History Servers FGA\u2013FGN. In an exemplary case, the QoS Managers FGA\u2013FGN advantageously can receive configuration orders from the Resource Manager FG, which allows the Resource Manager FG to configure each QoS Manager to monitor specific application paths and also set the sliding window criteria to be used by each respective QoS Manager.","Each copy of the QoS Manager advantageously can transmit application scale up and scale down requests to the Resource Manager FG when the measured performance data for a respective application violates either the high (scale up) or low (scale down) sliding window criteria for a specific requirement. A scale up request indicates which application on which host has violated the performance criteria, and a scale down request indicates which application on which host is recommended to be shutdown. Each copy of the QoS Manager can also request that the Resource Manager move an application. This will occur in the case where one copy of an application is performing much worse than all other running copies. The move request is implemented as a scale up request followed by a scale down request (of the badly performing copy); the scale down request is not transmitted to the Resource Manager FG until the scale up action has been implemented.","The QoS Managers FGA\u2013FGN use the application \u201csettling times\u201d defined in the System Specification Files to ensure that once a requested action has been sent to the Resource Manager that no additional actions are requested until after the application settling time has elapsed. This provides time for initialization and configuration among the application copies to occur. In future releases, the inter-application dependencies will be used instead.","The division of responsibility between the QoS Managers FGA\u2013FGN and the Resource Manager FG is as follows:\n\n","It should be mentioned that there is a Request Acknowledge message from the Resource Manager FG which has been defined and implemented within the QoS Manager code. This message is intended to provide feedback to the QoS Manager indicating that the request had been successfully received and whether the Resource Manager FG intends to implement the request.","As previously mentioned, the QoS Managers FGA\u2013FGN receive application status and state information from the Program Control function FG. Program Control periodically sends application status updates for all running applications and also sends immediate indications of any applications which have been started or stopped. This information is used by the QoS Managers FGA\u2013FGN, along with the instrumented performance data being received via the QoS Monitor FG and Instrumentation Correlators FGA\u2013FGN, to determine the exact state of the monitored applications A\u2013NM that are running. This information is also used to determine when (and if) requested actions have been implemented by the Resource Manager FG. The information is also used for setting up and discarding internal data structures used for monitoring the performance of each application.","The QoS Managers FGA\u2013FGN also receive application-level instrumentation data indicating current application performance values from the Instrumentation Correlators FGA\u2013FGN, the Instrumentation Brokers FGA\u2013FGN, and\/or the Jewel Instrumentation Broker (QoS Monitor) FG. The instrumentation data that is received contains (at a minimum):\n\n","If the contents of the instrumentation message match any of the application performance requirements that are currently being monitored by the QoS Manager, the data value is added to the proper requirement sliding window for the specified application. The sliding window algorithm is then checked to determine if the new sample triggered a violation of either the high or low sliding window. If a high threshold sliding window violation occurs and the application does not already have the maximum number of copies running, a determination is made as to whether performance can be best improved by starting a new application (scale up) or by moving an existing copy to a different host. The corresponding action recommendation will then be sent to the Resource Manager. In an exemplary case, the criteria for determining whether an application should be moved rather than scaled up is based on relative performance of the replicated applications. Thus, if one application is performing much worse [>50%] than the other copies, the recommendation will be to move the application. Likewise, if the new sample triggers a low threshold sliding window violation, and the application has more than the minimum number of copies running, a recommendation will be sent to the Resource Manager FG requesting that the copy of the application that is experiencing the worst performance be scaled down.","It will be appreciated from the discussion above that when a copy of the QoS Manager is first started, it reads in the System Specification Files FG (via calls to System Specification Library (SSL) FG), which contain the list of hosts that are known to be in the distributed environment and information on all applications that can be run in the distributed environment. The application-level information includes where specific applications can be run, which applications are scalable, which applications can be restarted, and any dependencies between applications.","It should also be mentioned that the Resource Manager FG receives updated application survivability specifications from the QoS Specification Control component. This information overrides the application survivability information that was initially loaded in from the System Specification Files for the specified application. The information is used by the Resource Manager FG to determine whether the specific application will be restarted if it fails at run-time.","As described above, the QoS Managers FGA\u2013FGN communicates with the Resource Manager FG, Program Control FG, the QoS Specification Control (not shown), the QoS Monitor FG, an Instrumentation Correlator (generally denoted FG), a Graph Tool Instrumentation Display (generally denoted FG), and the History Servers FGA\u2013FGN using the RMComms middleware. The message formats and contents of each message that is exchanged between the QoS Managers FGA\u2013FGN and these other functional components are described in greater detail in CD-Appendix F. Additional details regarding the timing and\/or event trigger for each message is also described in the Appendix.","FG: System Specification Language & System Specification Library (SSL) Functions","In order to effectively manage a pool of computing resources, the Resource Manager FG requires some means or mechanism of determining the capabilities and configuration of the computing resources under its control, as well as the software components that need to be executed and the dependencies of these software components on both hardware and software resources. Additionally, the Resource Manager FG requires the capability to determine the expected mission-level and application-level requirements. Furthermore, the Resource Manager FG must be able to determine what control capabilities are available to be used to attempt to recover from fault or QoS violation conditions.","In order to address these needs, a System and Software Specification Grammar has been developed to capture the \u201cstatic\u201d information needed by the Resource Manager FG for effectively managing a pool of distributed resources. The grammar captures the following information:\n\n","As part of the grammar development effort, a specification library has also been developed that parses the specification files and provides an API for accessing the specification information. It will be noted that the specification library was written in C++ and has been ported for all development platforms including Solaris 2.6, Solaris 2.7, Irix 6.5, HP-UX 10.20, Red Hat Linux 6.0, and Windows NT 4.0. The library advantageously can be used by substantially all of the Resource Management functional elements, including Program Control FG, Resource Manager FG, Path QoS Managers, Hardware Broker FG, and History Servers FGA\u2013FGN.","As illustrated in , the API library consists of a yacc file FG that defines the BNF grammar, a lex file FG that defines the tokens of the language, and a set of C++ classes FG that store the spec file information. The lex file FG is compiled with the GNU tool flex FG and it creates a C++ source file FG. The GNU tool bison FG  compiles the yacc file FG and creates C++ source and header files FG and FG. It will be noted that the lex source file FG includes the yacc header file FG. The C++ compiler FG then compiles these two source files to create lex and yacc objects FG and FG. The C++ compiler FG also compiles the C++ storage classes FG. All of these objects are linked into a single library FG to be utilized by an application.  illustrates this process flow.","The Software Specifications Grammar (SSG) provides techniques for describing the characteristics and requirements of dynamic, path-based real-time systems as well as providing abstractions to describe the properties of the software, such as hierarchical structure, inter-connectivity relationships, and run-time execution constraints. The SSG also allows description of the physical structure or composition of the hardware such as LANs, hosts, interconnecting devices or ICs (such as bridges, hubs, and routers), and their statically known properties (e.g., peak capacities). Furthermore, the Quality-of-Service (QoS) requirements on various system components advantageously can be described.","At the highest level, a specification consists of a collection of software systems, hardware systems, and network systems. The language rules for specifying systems are described generally below and in detail in CD-Appendix G. The system specification language hierarchy is shown below; selected details will be presented immediately following.\n\n","It will be appreciated that a software specification is a collection of software systems, each of which consists of one or more software subsystems. Specification files are provided by the developer to capture as much knowledge about their software system as possible. These files provide a model of the actual systems which can be used by the Resource Manager FG at run-time.","In contrast, an application is an executable program that can be started as an autonomous process on a host. Application attributes include all information necessary to startup and shutdown the application. Associated startup block and the shutdown blocks describe how to start and stop the application and includes information such as the directory and name of the application, command line options, and environment variable settings.","An application instantiates an SSL object by calling its constructor. This parses the spec files in the specified directory and populates the object hierarchy to provide the data to the application. The SSL class contains an SSL_Container member, that holds the spec file data in its lists and maps. All the systems from the spec files are contained in the appropriate list, software systems in the swSysList, hardware systems in hwSysList, and network systems in nwSysList. The pathList contains all the paths in the spec files. The hostList contains all the hosts in the spec files; this list is also available from the entries in hwSysList. The processList contains a list of processes from the CONFIGURATION block. Moreover, it should be noted that one or more configuration blocks can exist per application. For example, an application that runs on more than one platform would have multiple CONFIGURATION blocks with different platforms in each HARDWARE block.","The application startup block contains all the information necessary to, automatically or manually, start an application. This information includes supported hardware (host) type, operating-system type, and operating-system version(s). This may be further constrained by an optional list of the names of hosts that can run the application. The startup information also includes the working directory for reading and writing data files, the name of the executable, and an ordered list of arguments that must be passed on the command line when the application is started. Last is a list of processes expected to be seen on the system when the application is running.","An application shutdown block indicates the command(s) to be used for termination of the application. A shutdown command may be a POSIX signal name or may be a shell script or batch file. Supported signals include SIGKILL, SIGQUIT, SIGHUP, SIGUSR, SIGUSR, SIGSTOP, SIGINT, and SIGTERM. The ShutdownTime parameter is the maximum time to wait for the an application to die gracefully before forcing the application to terminate via the SIGKILL signal.","Other blocks are available. For example, a dependency block indicates any dependencies the application may have with the startup and\/or shutdown of other applications (e.g., it may be required that a particular application be started before another application can be started). It will be noted that the dependency block is used by both Application Control FG and the Resource Manager FG to determine whether or not it is safe to start an application, stop an application, or let an application continue to run.","The scalability specification for an application indicates whether an application can be scaled via replication. Scalable applications are programmed to exploit load sharing among replicas, and can adapt dynamically to varying numbers of replicas. The specification also indicates whether an application combines its input stream (which may be received from different predecessor applications and\/or devices), and splits its output stream (which may be distributed to different successor applications and\/or devices) are also specified. \u201cCombining\u201d and \u201csplitting\u201d are commonly called \u201cforking\u201d and \u201cjoining\u201d in parallel computing paradigms.","Specification files advantageously can be provided to describe a given set of networks that exist in a distributed runtime environment. A network system specification describes the LANs and ICs (interconnection devices such as switches, hubs and routers). A system consists of one or more subsystems. A subsystem may contain LANs (each with an associated peak bandwidth specification) and ICs (each containing a description of network membership).","Advantageously, a real-time QoS requirement specification includes timing constraints such as simple deadlines, inter-processing times, and throughputs. A simple deadline is defined as the maximum end-to-end path latency during a cycle from the beginning to the end of the path. Inter-processing time is defined as a maximum allowable time between processing of a particular element in the path. The throughput requirement is defined as the minimum number of data items that the path must process during a unit period of time. Each timing constraint specification may also include items that relate to the dynamic monitoring of the constraint. These include minimum and maximum slack values (that must be maintained at run-time), the size of a moving window of measured samples that should be observed, and the maximum tolerable number of violations (within the window).","CD-Appendix G described a specification grammar for declaring requirements on applications in a dynamic, distributed, heterogeneous resource pool. The grammar allows the description of environment-dependent application features, which allows for the modeling and dynamic resource management of such systems.","A common API was developed to allow Resource Management functions access to the information contained in the spec files. This is an object oriented API is, in an exemplary case, written in C++, with libraries ported to all supported platforms. The object is populated by parsing the spec files using the BNF grammar defined by lex and yacc syntax and compiled with GNU tools flex and bison, as discussed above. Actual population occurs in the semantic actions of the yacc file.","The SSL_System class is a generic class that can hold data for a software system, hardware system, or network system. The type member describes the type of system it contains. It also contains a pointer to its parent (it allows for nested systems of the same type), and a name of the system. The sysList contains its SSL_System children, and compList contains a list of the system's components (a list of hosts, for a hardware system for example).","Preferably, the Application Program Interface (API) for the System Specification Library (SSL) FG uses the C++ Standard Template Library for data structures such as linked lists and hash tables (maps). An application first instantiates the SSL object by calling its constructor with the name of the directory where the specification files reside. This object contains functions that allow setting this directory after calling its constructor (setSpecDir(directory name)), clearing the object of all currently held data (clear( )), parsing a specific file (parseSpec(filename)), and rebuilding the object (rebuild( ), implicitly clears the object first). Once instantiated, this object provides access to the data in the specification files. CD-Appendix G provides additional discussion regarding this aspect of the SSL. It will be appreciated that the SSL object provides methods that return all the data it contains. For example, the getSWSystems returns an STL list of all the software systems specified in the specification files. Each entry in this list provides its data by methods such as getSysName( ), and the set of application components (ApplicationSpec) that make up the system. All data can be retrieved in this manner.","FG: Host and Network Monitoring Functional Group","As mentioned above, extensive monitoring capabilities are provided in the Resource Management architecture at the host and network levels. The information monitored includes statuses, configuration information, performance metrics, and detected fault conditions. Moreover, the Host and Network functional group FG consists of four components including:\n\n","It will be appreciated that Network information is collected by both the Remos broker FG and indirectly via the Host Monitors FGA\u2013FGN. See , B. The Remos Broker FG accesses the Remos network information via the Remos API. As mentioned previously, Remos uses SNMP calls to the LAN switches and hosts. The Host Discovery function FG uses both SNMP and ICMP (ping) calls to each host A\u2013N to determine if a new host(s) has (have) come on-line or previously discovered hosts have gone down. The Host Monitors FGA\u2013FGN employ Operating System calls to gather host and network performance statistics. Internally, the History Servers FGA\u2013FGN collect data from the Host Monitors FGA\u2013FGN. The Monitoring functional group provides its information to the rest of the Resource Management components using RMComms TCPCommServer objects, which are discussed in detail elsewhere. The Remos Broker FG sends data to the Host Load Analyzer FG, the History Servers FGA\u2013FGN send data to the Display functional group FG and Host Load Analyzer FG, and the Host Discovery function FG provides Program Control FG with information on detected or faulted hosts. Additional details on these functional elements are provided immediately below.","FGA\u2013FGN Host Monitors","For monitoring the status and performance of hosts, a Host Monitor process runs on each machine within the distributed environment. These Host Monitors FGA\u2013FGN use operating system-level mechanisms to retrieve status, configuration, and performance information of each host A\u2013N. The information retrieved includes 1) operating system version and machine configuration, 2) CPU configuration, status, and utilization, 3) memory configuration and usage, 4) network configuration, status, and utilization, 5) filesystem configuration, status, and utilization, and 6) process statuses including CPU, memory, network, and filesystem utilization for each process. While the Host Monitors are primarily responsible for monitoring the status of a particular host, they also provide information on network load as seen by a particular host. In the same manner, the Host Monitors FGA\u2013FGN also provide information and statistics concerning any remotely mounted filesystems (e.g., NFS).","Preferably, the information the Host Monitors FGA\u2013FGN collect is formatted into operating system-independent message formats. These message formats attempt to provide a pseudo-standardized set of state, status, and performance information which is useful to other components of the Resource Management architecture and such that other components do not have to be aware of or deal with the minor deltas between data formats and semantics. Since not all the state and performance data is available on every platform, to indicate which information is available, a group of flags are set in the host configuration message indicating whether specific data items are valid on a particular platform.","It will be appreciated that the Host Monitors FGA\u2013FGN have a very specific interface with the History Servers FGA\u2013FGN. It periodically (once a second) sends its data to all History Servers connected to it (this is transparent, a property of the RMComms TCPCommServer); the History Server makes no requests to the Host Monitors.","More specifically, the Host Monitors FGA\u2013FGN have been designed and implemented in C++. This decision allows for a completely modular design in which platform-specific code can be restricted to a small number of modules. This approach alleviates any of the problems associated with porting to various platforms. Currently there is support for Sun SPARC based architectures running Solaris 2.6 and 2.7, Silicon Graphics MIPS based architectures running IRIX 6.5., Hewlett Packard PA-RISC based architectures running HP1020, and Pentium based architecture running both WinNT 4.0 Workstation and Red Hat Linux 6.0. The Host Monitor source compiles under the native compilers provided by Sun Microsystems and Silicon Graphics for their respective platforms. The Gnu C++ compiler (version 2.8.1) may also be used on Hewlett Packard PA-RISC based architectures under HP-UX 10.20 and Red Hat Linux. Microsoft Visual C++ compiles the Windows NT Host Monitor. All Host Monitors utilize the I\/O library package supported by the Resource Management (RM) group under the NSWC's High Performance Distributed Computing (HiperD) initiative.","The Host Monitors FGA\u2013FGN accumulate data on a periodic interval specified at invocation. System process table data is accumulated and then filtered to eliminate \u201cuninteresting\u201d processes (usually meaning processes belonging to user ID 0 or 1). It is important to note that system-wide data is accumulated and processed before the filtering stage, so as to insure a complete picture of system-wide performance. This system-wide data, along with the filtered process list, is then made available to the I\/O module for subsequent transmission to client applications.","FGA\u2013FGN: History Servers","The History Servers FGA\u2013FGN are responsible for collecting information from the Host Monitors and maintaining histories on the statuses, statistics, and performance of each host in the distributed environment. This information can be requested by other Resource Management functional group. Currently, the primary consumers of the status information are the Host Load Analyzer (Hardware Broker) FG component of the Resource Allocation Decision-Making functional group FG, the Host Display(s) FGA\u2013FGN, and the Path Display FG. The Host Load Analyzer FG receives information on host configuration and loads (primarily CPU, memory, and network data) and uses this to assign host fitness scores. The Host Displays FGA\u2013FGN receive and display current host status information, process status information, and network connectivity information. It should be mentioned that the Host Display can also request that the History Servers provide CPU load information, network load information, paging activity data, and memory utilization information which is used to drive line graph charts for specific hosts selected at the Host Display.","The History Servers FGA\u2013FGN are designed so that multiple copies can be run simultaneously. Each History Server can be configured to either monitor all Host Monitors FGA\u2013FGN or to monitor only a selected subset of the Host Monitors. It will be noted that the History Servers FGA\u2013FGN determine the list of hosts in the distributed environment that could potentially be monitored from the System Specification Library (SSL). In this manner, the History Servers FGA\u2013FGN can be used to provide survivability (by having multiple History Servers FGA\u2013FGN connected to each Host Monitor) and\/or to perform load-sharing (with the History Servers FGA\u2013FGN each monitoring only a subset of the Host Monitors). The History Servers FGA\u2013FGN can also be configured to periodically record history data to disk. These disk files can then be used for off-line analysis.","The History Server function of Resource Management acts as a data broker between daemons monitoring individual hosts, known as host monitors FGA\u2013FGN, and other functional components of Resource Management. The host monitors collect performance information (such as CPU utilization and process status data) from hosts of various platforms (SGI, SUN, HP, Windows NT, and Linux). The host monitors use a RMComms TCPCommServer object to distribute this data. For further information, refer to the host monitor and RMComms documentation. The History Server s FGA\u2013FGN collect and store this data from the host monitors FGA\u2013FGN and distribute it to other Resource Management Clients, such as the Host Displays FGA\u2013FGN, Graph Display FGA\u2013FGN, Path Display FG, and the Hardware Broker. FG","Each History Server has two modes of operation relating to fault tolerance, scalability, and workload distribution between multiple instances of History Servers. The first mode determines at initialization (through command line arguments or default) the set of hosts to monitor, and this set remains static for the life of the History Server process. The second mode recognizes the existence of other History Server processes and coordinates between them. It allows for dynamic changing of the set of hosts each History Server monitors (example: two History Servers each monitoring half of the hosts, a third History Server starts, and all three History Servers reconfigure to each monitor one third of the hosts.) This also allows History Servers to preserve the data it collected by sending it to the others, providing fault tolerance.","The History Server function is written in C++ with an object-oriented design. The main routine processes the command line arguments, retrieves the list of hosts to monitor using an SSL object, instantiates the main History_Server object, and spawns the Collector, Distributor, Communicator, and Display thread. These threads share the main History_Server object. The Collector thread is responsible for collecting and storing data from the host monitors. The Distributor thread processes requests from RM Clients. The Communicator thread waits for events with other History Servers and takes appropriate actions, including triggering the Display thread to update the History Server Display.","FG\u2014Host Discovery","The Host Discovery function FG advantageously can use a Perl script that makes SNMP (Simple Network Management Protocol) calls and ICMP ping calls. These calls are used to periodically scan each subnet and host address in the distributed environment to attempt to determine whether there have been any host status changes. In an exemplary case, the list of hosts and subnets that are to be monitored is read in from a file.","The host discovery FG issues MIB-II SNMP queries to obtain information on the hosts A\u2013N on the network. When a new host is first detected, the new host's operating system configuration is queried via SNMP calls. Information on the newly discovered host and its operating system configuration is then sent to the Program Control function FG. Likewise, when a host fails to respond to multiple SNMP and ping queries, a message indicating that the host appears to have gone down is sent to the Program Control function.","The Host Discovery function FG interfaces with Program Control FG using a C++ wrapper class around the Perl script. This wrapper class contains an RMComms TCPCommServer, making the data collected by the SNMP calls available to the rest of the Resource Management components.","FG\u2014Remos Network Data Broker","The final functional component of the Host and Network Monitoring functional group is the Remos Network Data Broker FG  which receives information on network link bandwidth and network link bandwidth utilization from the SNMP-based Remos network monitoring tool, as shown in , B and\/or . The network information is accessed via the Remos API library and is then sent on to the Host Load Analyzer (Hardware Broker) function FG of the Resource Allocation Decision-Making functional group FG using an RMComms TCPCommServer. Remos works by using SNMP to query the switches (via the bridge collector) to collect information on network configuration as well as bandwidth utilization on each link and also issues SNMP MIB-II queries to each host to collect the host's view of network utilization. The network information received from Remos consists of the maximum potential bandwidth and the current bandwidth utilization on specific host network links.","The Remos Broker FG  provides the following information about the network link for each host. The data is sent to the Host Load Analyzer (Hardware Broker) approximately every 2 seconds. The Remos Broker FG uses configuration files listing specific hosts and switches that should be queried.","The functions implemented by Host Monitor functional group FG have been designed to provide a system monitoring capability not normally supplied by standard SVR4 or BSD Unix services. Such services include cross-platform reporting of system process loading, CPU performance, network performance and periodic status summary reporting. The Host Monitors were developed to support efforts by the HiperD Resource Management group, attempting to provide a common set of OS level parameters useful for assessing host and network load and status, for supporting resource allocation\/reallocation algorithms, and attempting to provide a minimally intrusive, close to real-time capability for gathering this data.","Host Discovery Design","The Host Discovery function FG of the Resource Management architecture provides resource discovery of hosts on a network. It identifies new hosts that come online or previously known hosts that have gone offline. The Host Discovery component can determine the hostname, the operating system name and version, and in some cases the machine architecture and manufacturer of a newly discovered host. This information is sent to Program Control so the new host can be added to the pool of resources.","The Host Discovery functional element FG consists of a Perl script that contains the resource discovery functionality, and a C++ object that receives the output of the Perl script and provides this information to Program Control via an RMComms TCPCommServer connection. This is described in CD-Appendix H. More specifically, the Perl script host_discovery.pl issues ICMP (ping) calls and MIB-II SNMP queries to discover new hosts. On initialization, the script populates a data structure called Net_info for each of the networks (subnets) it needs to monitor. Currently this information is hard-coded, the subnet is defined as 172.30.1, and the lower and upper limits for the host are 1 and 254 respectively. It then initializes the global variables for the server host and port, network domain, and the executable path for the ping (fping) command","The host_discovery.pl script establishes a baseline of existing hosts using the current set of hosts that answer the fping call. For each network\/subnet defined in its list of Net_info (Net_info.pm) data structures, it calls fping and builds a list of IP addresses of hosts that answered the ping, known as reachable hosts, and a list for those hosts that did not answer the ping. For each reachable host, a Host_info (Host_info.pm) data structure is populated to store the host's information. (Key fields in the Host_info data structure include IP address, hostname, operating system and version, architecture class, and manufacturer.) Since the IP address of the reachable host is known, a call to gethostbyaddr( ) is used to get the hostname. Other information for the host is obtained by making a MIB-II (Management Interface Base version 2) system Group (Object ID 1.3.6.1.2.1.1.1.0) SNMP call to the SNMP agent on each reachable host. This SNMP query returns information on the configuration of a specific network device (in this case, the configuration of each reachable host).","The host_discovery.pl script makes SNMP calls by using subroutines freely available for public use (freeware), created by Simon Leinen. These subroutines are contained in the files BER.pm and SNMP_Session.pm. The SNMP_Session is configurable for specifying timeouts and number of retries before declaring a host unavailable, and for specifying the SNMP Object Id (OID).","Additional general and specific details regarding functional elements of the Host and Networking functional group FG are provided in CD-Appendix H.","FG: Instrumentation Functional Group","As mentioned above, the NSWC-DD Instrumentation System provides general-purpose application event reporting and event correlation capabilities. The Instrumentation system forms an architecture that allows instrumented application data to be easily accessible by other components of the Resource Management architecture. The major functional components of the Instrumentation System architecture are the following:\n\n","The applications link in the Instrumentation API Library and make API call to construct and send out instrumentation event messages. Three separate APIs are provided for use by the applications: 1) a printf( )-style API which allows the code to format, build, and send instrumentation data with a single function call, 2) a buffer-construction-style API where the multiple function calls are made to construct the instrumentation buffer iteratively, one data element per call, and 3) a Jewel function call API based on the existing API provided by the Jewel instrumentation package (an open-source package produced by the German National Research Center for Computer Science). The first two APIs are the preferred programming interfaces and take advantage of several key new instrumentation features. It will be appreciated that the Jewel API is provided solely for backwards compatibility with existing instrumented application code and is implemented as a set of wrappers around the printf( )-style API. All three APIs are supported for C and C++. Ada bindings have been produced for the buffer-construction-style API and the Jewel function call API.","The instrumented data is sent from the application to the Instrumentation Daemon on the same host. The current mechanism for data transfer is via UNIX FIFO IPC (inter-process communication) mechanisms. The FIFO mechanism was chosen based on reliability, low overhead, and ease of implementation. Future implementations of the Instrumentation system may explore alternate data passing mechanisms including shared message queues.","Instrumentation Daemon","An Instrumentation Daemon resides on each host in the distributed environment. The Instrumentation Daemon is interrupted when new data is written to the FIFO. The Instrumentation Daemon reads the data from the FIFO and reformats the data into the standard internal Instrumentation message format and sends the data to each of the Instrumentation Collectors that are currently active. (For future implementations, an event request filtering mechanism will be implemented so that specific event messages will only be sent to those Instrumentation Collectors that have requested the message.)","Instrumentation Collectors","The Instrumentation Collectors receive instrumentation messages from the Instrumentation Daemons on each host in the distributed environment. Currently, the Instrumentation Collectors send every instrumentation message to all Instrumentation Brokers and Instrumentation Correlators that have connected to the Instrumentation Collector. (For future implementations, an event request filtering mechanism will be implemented so that specific event messages will only be sent to those Instrumentation Brokers and Instrumentation Correlators that have requested the message. For now, the Instrumentation Collector serves as a pass-through server for instrumentation messages. The Instrumentation Collector does supports architecture scalability in the sense that without the Instrumentation Collectors, each Instrumentation Broker and Instrumentation Correlators would need to maintain connections to the Instrumentation Daemons on every host.)","Instrumentation Correlators","The Instrumentation Correlators provide grammar-driven capabilities for correlating, combining, and reformatting application data into higher-level metrics (composite events) for use by displays or other Resource Management components. Each Correlator reads in a user-specified correlation grammar file that is interpreted at run-time by the Correlator's instrumentation correlation engine.","Instrumentation Brokers","The Instrumentation Brokers are task-specific applications built around a common code package. The Instrumentation Brokers receive instrumentation messages from the Instrumentation Collectors, filter all received instrumentation messages to find the messages of interest, and perform task-specific message data reformatting and manipulation for driving other components such as displays or other Resource Management components. The Instrumentation Broker approach allows for instrumentation data sources to be quickly integrated for test, display, and debugging purposes. (As the Instrumentation Correlator grammar and correlation engine mature in future releases, it is anticipated that the Instrumentation Broker approach will be used less frequently.)","Jewel Instrumentation Broker (QoS Monitor)","The Jewel Instrumentation Broker (hereafter referred to the QoS Monitor) is a legacy architecture component that served as a broker between the Jewel instrumentation package components and Resource Management components and displays. The QoS Monitor was responsible for polling the Jewel Collector components to retrieve application event messages. These messages were then reformatted and used to drive several displays and the QoS Managers. The Jewel instrumentation package has now been replaced in all applications, however the message reformatting capabilities of the QoS Monitor have been maintained so that several displays and the existing QoS Manager interface do not have to be upgraded immediately. The QoS Monitor component has been modified so that it receives instrumentation data from both Jewel and the Instrumentation Collectors.","Middleware","The RMComms middleware package, which is described in the RMComms Middleware Design Report, provides the internal message passing interfaces between the Resource Management components connected via the network. The middleware provides for automatic location-transparent many-to-many client-server connections. Low overhead, reliable message passing capabilities are provided. Registration of message handler callback functions for specified requested message types are provided with the message handler functions being invoked when messages arrive. Registration of connection status callback functions which are invoked when either new connections are made or existing connections are broken is also provided. The middleware package also allows for multiple client and server objects to be instantiated in the same application, is thread-safe, and provides an easy-to-use object-oriented API through which all capabilities are accessed.","Additional details regarding the Instrumentation functional group FG are provided in CD-Appendix I.","FG: Resource Manager","The Resource Manager  is the primary decision-making component of the Resource Management toolkit. It is responsible for: 1) responding to application and host failures by determining if and what recovery actions should be taken, 2) determining if and where to place new copies of scalable applications or which scalable applications should be shutdown when the QoS Managers FGA\u2013FGN indicate that scale-up or scale-down actions should be taken based on measured application performance, 3) determining where new applications should be placed when requested to do so by Program Control, and 4) determining which and how many applications should run based on application system (mission) priorities. In order to accomplish these tasks, the Resource Manager  maintains a global view of the state of the entire distributed environment including status information on all hosts, networks, and applications. In addition, the Resource Manager  also calculates software and hardware readiness metrics and reports these readiness values for display purposes. , B show the connectivity and high-level data flow between the Resource Manager  and the other Resource Management-related components.","The Resource Manager  receives status and failure information about hosts, networks, and applications from Program Control. This information includes periodic status updates as well as immediate updates when statuses change such as a new host being detected or an application failing. In the case of applications going down, information as to whether the applications were shutdown on purpose or whether they failed is also sent. Program Control also issues requests to the Resource Manager  when new applications need to be dynamically allocated and when Program Control determines that the Resource Manager  needs to assess and attempt to resolve inter-application dependencies (such as an application which needs to be running prior to starting up another application).","The Resource Manager  responds to faulted applications and hosts by determining whether the failed applications can and should be restarted and attempting to determine where (and if) there are hosts available that the application can run on. When a decision is made by the Resource Manager , a message is sent to Program Control specifying what application to start and where to put it. The same general mechanism is used when Program Control requests that the Resource Manager  determine where to start new applications and\/or how to resolve inter-application dependencies; the Resource Manager  responds with orders indicating what applications to start and where to start them. The Resource Manager  also sends application shutdown orders to Program Control requesting that certain application be stopped; this can occur when the QoS Managers FGA\u2013FGN indicate that certain scalable applications have too many copies running or when application system priority changes (to lower priorities) occur resulting in scaling back the application system configuration.","The Resource Manager  receives host load and host fitness information on all known hosts from the Hardware Broker  (Host Load Analyzer). This information include overall host fitness scores, CPU-based fitness scores, network-based fitness scores, and memory and paging-based fitness scores along with the SPEC95 ratings of the hosts. This information is received approximately once a second and includes information on all known hosts in the distributed system. These scores are used by the Resource Manager  for determining the \u201cbest\u201d hosts for placing new applications when: 1) responding to requests from the QoS Managers FGA\u2013FGN to scale up additional copies of an application, 2) attempting to restart failed applications, 3) responding to requests to dynamically allocate certain applications, and 4) responding to application system (mission) priority changes which require scaling up additional applications.","The Resource Manager  receives requests from the QoS Managers FGA\u2013FGN for scaling up, moving, or scaling down specific applications. The Resource Manager FG responds to these requests by determining whether the request should be acted upon and, if so, determines the specific action to take and issues orders to Program Control to start up or shutdown specific applications on specific hosts. The QoS Managers FGA\u2013FGN are responsible for monitoring specific system performance metrics (e.g., quality of service, or QoS, requirements) via instrumentation and determining if performance can be improved by scaling up or moving certain applications. When this occurs, the QoS Managers FGA\u2013FGN send a request to the Resource Manager FG indicating that a new copy of a specific application should be started. If the QoS Managers FGA\u2013FGN determine that the performance of a scalable application can be improved by moving an application, a scale up request is first sent to the Resource Manager FG and when the new application has been started, a scaledown request is then sent to the Resource Manager. Also, when the QoS Managers FGA\u2013FGN determine that there are more copies of scalable application running then are needed, requests to shutdown specific applications are sent to the Resource Manager FG. The division of responsibility is that the QoS Managers FGA\u2013FGN determine what actions would potentially improve performance, but the Resource Manager FG has final authority to determine whether to implement the requested actions.","When the Resource Manager FG is first started, it reads in the System Specification Files (via System Specification Library, SSL, calls) which contain the list of hosts that are known to be in the distributed environment and information on all applications that can be run in the distributed environment. The System Specification Files also include application-level information including where specific applications can be run, which applications are scalable, which applications can be restarted, and any dependencies between applications.","The Resource Manager FG can also receive updated application survivability specifications from the QoS Specification Control component. This information overrides the application survivability information that was initially loaded in from the System Specification Files for specified applications. The information is used by the Resource Manager FG to determine whether the specific applications will be restarted if they fail at run-time.","The Resource Manager FG sends application system and hardware system readiness and system (mission) priority information to the Readiness Broker and to the Globus Broker. The Readiness Broker is responsible for driving a GUI\/display which shows the current readiness data and allows the system (mission) priorities to be changed and sent back to the Resource Manager FG. The Globus Broker provides basically the same functionality except that only a high-level subset of the readiness data provided to the Readiness Broker is provided to the Globus Broker. The readiness information sent to the Readiness Broker consists of readiness values for each application, application subsystem, and application system defined in the System Specification Files. The readiness scores are currently based on the status (up\/down) of the applications within a system or subsystem along with the percentage of potential copies of scalable applications that are currently running. Host and network readiness scores are also calculated and are the scores are determined based on the host load information and host fitness scores received from the Hardware Broker .","The Resource Manager FG also sends information about allocation and reallocation decisions to the Resource Management Decision Review Display. Information on the decision that was made, what event the decision was in response to, and how long it took to both make the decision and implement the decision are sent to the display. In addition, information about the top choices for where an application could have potentially been placed is also sent (if applicable); this information includes the host fitness scores for the selected host and the next best host choices which could have been selected.","See CD-Appendix M for additional details regarding Resource Manager FG.","In the Background Section of the application, the reader may have interpreted the sentence \u201cThe present invention relates generally to resource management systems by which networked computers cooperate in performing at least one task too complex for a single computer to perform\u201d to indicate that the Resource Management Architecture is limited to such applications. Thus, while the Resource Management Architecture generally supports tasks distributed across multiple hosts, it is not limited to only those tasks that must be distributed due to the inability to run them on a single machine. Moreover, the Resource Management functional elements advantageously could be used to control a set of applications which all run on the same machine while still providing monitoring, fault tolerance, etc. (albeit that this is not the normal or even the intended configuration). Furthermore, the Resource Management Architecture, as discussed above, deals with resource managed applications, where the managed characteristic may be one of scalability, survivability, fault tolerance or priority.",{"@attributes":{"id":"p-0216","num":"0501"},"figref":"FIG. 15","b":["400","400","402","412","408","420","420","420","410","400","412","414","404","406","402","420","412","414","400"]},{"@attributes":{"id":"p-0217","num":"0502"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE III"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["APPENDIX","TYPE","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["A","Attached","Resource Management Architecture Function List"]},{"entry":["B","Attached","Standard Instrumentation Message Format"]},{"entry":["C","Attached","API Listing for RMComms"]},{"entry":["D","CD","Resource Manager Interface Messages"]},{"entry":["E","CD","Host Load Analyzer (Hardware Broker) Function"]},{"entry":["F","CD","Quality-of-service (QoS) Manager Function"]},{"entry":["G","CD","FG3: System Specification Language & System Specification"]},{"entry":[{},{},"Library (SSL) Functions"]},{"entry":["H","CD","Host And Network Monitoring Functional Group"]},{"entry":["I","CD","Instrumentation Functional Group"]},{"entry":["J","CD","Display Functional Group"]},{"entry":["K","CD","RMComms Network Communication Middleware Design"]},{"entry":["L","CD","System Readiness Display"]},{"entry":["M","CD","Resource Manager FG42"]},{"entry":["N","CD","Instrumentation Graph Tool"]},{"entry":["O","CD","Host Discovery Function"]},{"entry":["P","CD","Instrumentation Application Programming Interface (API)"]},{"entry":["Q","CD","Program Control Application Controller"]},{"entry":["R","CD","Program Control Display"]},{"entry":["S","CD","Program Control Functional Group"]},{"entry":["T","CD","QoS Manager"]},{"entry":["U","CD","Resource Allocation Decision-making Functional Group"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Table III provides a listing of the Appendices included for all purposes in the application. It will be noted that the majority of the listed Appendices are provided on the CD-ROM filed concurrently with the application. In addition, the CD-ROM also includes the source code listing for the Resource Management Architecture according to the present invention.","Although presently preferred embodiments of the present invention have been described in detail herein, it should be clearly understood that many variations and\/or modifications of the basic inventive concepts herein taught, which may appear to those skilled in the pertinent art, will still fall within the spirit and scope of the present invention, as defined in the appended claims."],"GOVINT":[{},{}],"heading":["STATEMENT OF GOVERNMENT INTEREST","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["These and various other features and aspects of the present invention will be readily understood with reference to the following detailed description taken in conjunction with the accompanying drawings, in which like or similar numbers are used throughout, and in which:",{"@attributes":{"id":"p-0014","num":"0017"},"figref":"FIGS. 1A","b":"1"},{"@attributes":{"id":"p-0015","num":"0018"},"figref":"FIGS. 2A","b":"2"},{"@attributes":{"id":"p-0016","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0020"},"figref":["FIG. 4","FIGS. 2A"],"b":["5","2"]},{"@attributes":{"id":"p-0018","num":"0021"},"figref":["FIGS. 5A","FIG. 4"],"b":["5","54"]},{"@attributes":{"id":"p-0019","num":"0022"},"figref":"FIGS. 6A","b":"6"},{"@attributes":{"id":"p-0020","num":"0023"},"figref":["FIGS. 7A","FIGS. 6A"],"b":["7","6"]},{"@attributes":{"id":"p-0021","num":"0024"},"figref":"FIGS. 8A","b":"8"},{"@attributes":{"id":"p-0022","num":"0025"},"figref":"FIGS. 9A","b":"9"},{"@attributes":{"id":"p-0023","num":"0026"},"figref":"FIGS. 10A","b":["10","11","11"]},{"@attributes":{"id":"p-0024","num":"0027"},"figref":"FIGS. 12A","b":["12","66"]},{"@attributes":{"id":"p-0025","num":"0028"},"figref":"FIGS. 13A","b":["13","13"]},{"@attributes":{"id":"p-0026","num":"0029"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0027","num":"0030"},"figref":"FIG. 15"}]},"DETDESC":[{},{}]}
