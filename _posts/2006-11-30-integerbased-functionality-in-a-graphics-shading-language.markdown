---
title: Integer-based functionality in a graphics shading language
abstract: One embodiment of the present invention sets forth a technique for improving the flexibility and programmability of a graphics pipeline by adding application programming interface (API) extensions to the OpenGL Shading Language (GLSL) that provide native support for integer data types and operations. The integer API extensions span from the API to the hardware execution units within a graphics processing unit (GPU), thereby providing native integer support throughout the graphics pipeline.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08044951&OS=08044951&RS=08044951
owner: NVIDIA Corporation
number: 08044951
owner_city: Santa Clara
owner_country: US
publication_date: 20061130
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","The Integer Application Programming Interface Extensions"],"p":["The current application claims the benefit of U.S. Provisional Application No. 60\/833,978, filed on Jul. 28, 2006 and having the title, \u201cAPI Extensions for Advanced Graphics Processing Units.\u201d This related application is hereby incorporated by reference in its entirety. The current application also is a continuation-in-part of U.S. application Ser. No. 10\/883,893, filed on Jul. 2, 2004 now U.S. Pat. No. 7,426,724 and having the title, \u201cOptimized Chaining of Vertex and Fragment Programs.\u201d This additional related application is also hereby incorporated by reference in its entirety.","1. Field of the Invention","Embodiments of the present invention generally relate to graphics programming and more specifically to integer-based functionality in a graphics shading language.","2. Description of the Related Art","Over the past decade, the cost of adding on-chip logic to processors has substantially decreased. Consequently, certain types of processors, such as advanced graphics processing units (GPUs), now include functionality not previously available in earlier GPU designs. For example, the newest GPUs are now able to perform full integer processing operations; whereas, such operations could not be effectively performed on the GPU. One benefit of this new capability is that more efficient graphics processing may now be performed on the GPU, thereby increasing overall performance in the graphics pipeline.","To fully realize additional processing capabilities of advanced GPUs, as much GPU functionality as possible needs to be exposed to graphics application developers. Among other things, doing so enables graphics application developers to tailor their shader programs to optimize the way GPUs process graphics scenes and images. Exposing new GPU processing capabilities, like full integer processing, to graphics application developers requires that the application programming interface (API) be configured with new calls and libraries that make new features and functionalities directly accessible by developers.","Some graphics APIs expose an interface to graphics application developers that consists of a set of calls written in a high-level programming language. To access specific capabilities of a target GPU, graphics application developers typically write shader programs for the target GPU in a high-level programming language such as the OpenGL shading language (GLSL). The shader programs are conveyed through the API to driver software that is configured to compile and assemble the shader programs into machine code programs. The machine code programs are then executed on the appropriate GPU processing units, as specified in the original shader program text.","As is well-known, floating-point values are useful in representing parameters related to graphics image data, such as light intensity or object depth, floating-point values are inappropriate in more general data processing that involve bit-wise operators or data structure indices. Integer values, however, are commonly used for processing bit-wise operators and computing data structure indices. Therefore, shader programs include constructs for storing and processing data in both integer and floating-point formats. One drawback of prior art APIs is that values that are encoded within the shader program using an integer format are not guaranteed to be processed using integer data types within a target GPU. In fact, integer variables within prior art APIs are typically converted to a floating-point format for processing within the GPU, precluding many integer related functions such as bitwise and pointer operators. For example, in OpenGL\u2122 an integer value \u201c2\u201d used within a shader program is actually converted to a floating-point value \u201c2.0\u201d for processing within the GPU since integers are not supported as a native data type within the existing OpenGL\u2122 API. The fact that OpenGL\u2122 always casts values to a floating-point representation for processing within the GPU limits the applicability of OpenGL\u2122 and GLSL to more general computational tasks desirable is more advanced graphics pipeline architectures. This API limitation thus restricts developers from taking advantage of native integer math support recently added to a new generation of GPUs.","As the foregoing illustrates, what is needed in the art is an application programming interface that exposes new processing capabilities of GPUs, such as the ability to perform native integer math operations, to graphics application developers.","One embodiment of the present invention sets forth a method for processing integer data operations on a graphics processing unit. The method includes the steps of receiving a first shader program configured to be executed by a first shader unit in the graphics processing unit and a second shader program configured to be executed by a second shader unit in the graphics processing unit, wherein both the first shader program and the second shader program include instructions written in a high-level shading language, and wherein the instructions include integer data operations; converting the high-level shading language instructions of the first shader program and the second shader program into assembly code; linking the assembly code instructions of the first shader program with the assembly code instructions of the second shader program; and converting the linked assembly code instructions of the first shader program and the second shader program into microcode instructions that can be executed on the graphics processing unit. The method also includes the step of transmitting the microcode instructions of the first shader program to the first shader unit and the microcode instructions of the second shader program to the second shader unit.","One advantage of the disclosed method is that it enables graphics application developers to program with integer data types that can then be passed by a software driver to an advanced graphics processing unit that is configured to perform full integer data operations.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1","b":["100","100","102","104","110","150","160","170","102","110","104","102","110","110","150","104","102","150","102","150","104","150","110","102","110","102","104","150","102","160","150","160","170"]},"The system memory  includes an application program , one or more high-level shader programs , an API  and a GPU driver . The application program  generates calls to the API  in order to produce a desired set of results, typically in the form of a sequence of graphics images. The application program  also transmits one or more high-level shading programs  to the API  for processing within the GPU driver . The high-level shading programs are typically source code text of high-level programming instructions that are designed to operate on one or more shaders within the GPU . The API  functionality is typically implemented within the GPU driver . The GPU driver  includes a compiler\/linker  configured to process the high-level shader programs  into program objects that are typically represented by assembly language text optimized for a specific shader or shaders. A GPU microcode assembler  processes the program objects into machine code shader programs that may include a machine code vertex shader program , a machine code geometry shader program  and a machine code fragment shader program . In alternate embodiments, the compiler\/linker directly generates the machine code shader programs , ,  without the need for an intermediate assembly language version of the shader programs. A linked shader program image  is generated by linking the individual shader programs , , .","The GPU local memory  includes a set of machine code shader programs , a uniform storage buffer , a texture buffer  and a frame buffer . The machine code shader programs  are transmitted from the GPU driver  to GPU local memory . The machine code shader programs  may include, without limitation, the machine code vertex shader program , the machine code geometry shader program , the machine code fragment shader program , or any number of variations of each. The uniform storage buffer  stores one or more uniform variables, also called \u201cuniforms.\u201d A uniform variable is held constant during a given invocation of the associated shader but may be altered between invocations. The texture buffer  stores data elements typically organized in one-dimensional, two-dimensional or three-dimensional structures. Data stored within the texture buffer  is typically accessed with the assistance of application specific hardware that provides for a dimensional access view of the data. For example a two-dimensional surface may be addressed with the assistance of a hardware unit that transposes a horizontal and vertical surface location into a physical memory address that corresponds to the location. The frame buffer  includes at least one two-dimensional surface that is used to drive the display . The frame buffer  may include more than one two-dimensional surfaces so that the GPU  can render to one two-dimensional surface while a second two-dimensional surface is used to drive the display .","The GPU  includes a vertex shader , a geometry shader  and a fragment shader . As is well-known, the vertex shader  receives a sequence of one or more sets of vertex attributes, where each set of vertex attributes is typically associated with one vertex and one or more vertices are associated with a geometric primitive. The vertex shader  processes the vertex attributes, performing such operations as evaluating the vertex's position relative to the viewer and evaluating lighting equations to determine each vertex color. The vertex shader  may also use data from buffers stored in the GPU local memory . For example, the vertex shader  may use data from the uniform storage buffer  or the texture buffer . The machine code vertex shader program  executes on the vertex shader , imparting specific processing behavior according to specific requirements and specifications of the application program . The geometry shader  receives sets of processed vertices from the vertex shader . The geometry shader  performs per-primitive operations on vertices grouped into primitives such as triangles, lines, strips and points emitted by the vertex shader , enabling functionality such as shadow volume generation and procedural synthesis. The machine code geometry shader program  executes on the geometry shader , imparting specific processing behavior according to specific requirements and specifications of the application program . A fixed-function rasterizer (not shown) that is situated between the geometry shader  and the fragment shader  scan converts an individual geometric primitive into a set of fragments with interpolated vertex attributes. The fragment shader  processes the fragments, each containing fragment data, which may include raster position, depth or interpolated vertex attributes, such as texture coordinates, opacity, and other relevant per-pixel data, to produce final pixel values. The final pixel values are stored in the frame buffer  by a fixed-function raster operations unit (not shown) that also performs operations such as depth and stencil tests as well as any blending of the final pixel values with values currently stored in the frame buffer. The machine code fragment shader program  executes on the fragment shader , resulting in specific processing behavior according to specific requirements and specifications of the application program .","The display  is an output device capable of emitting a visual image corresponding to an input data signal. For example, the display may be built using a cathode ray tube (CRT) monitor, a liquid crystal display, or any other suitable display system. The input data signal to the display  is typically generated by scanning out the contents of one or more frames of image data that is stored in the frame buffer .",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2","b":["200","200","112","114","118","118","150","150"]},"The high-level shader programs  may include a high-level vertex shader program , a high-level geometry shader program  and a high-level fragment shader program . Each of the high-level shader programs  is transmitted through the API  to the compiler\/linker  within the GPU driver . The compiler\/linker  compiles the high-level shader programs  into assembly language program objects. The compiler\/linker  and optimizations related to linking shader programs for concurrent execution are discussed in greater detail in the patent application titled, \u201cOptimized Chaining of Vertex and Fragment Programs,\u201d filed on Jul. 2, 2004 and having U.S. patent application Ser. No. 10\/883,893. The subject matter of this patent application is hereby incorporated by reference in its entirety.","Under shader programming model , domain-specific shader programs, such as high-level vertex shader program , high-level geometry shader program , and high-level fragment shader program , are compiled using a common instruction set target, supported by unified instruction set architecture (ISA) library . With the common instruction set, application developers can compile high-level shader programs in different domains using a core set of instructions having the same syntax and consequently should expect faster compile times for such shader programs. One example of this common ISA is supported by the Unified Instruction Set Architecture (\u201cISA\u201d) developed by NVIDIA Corporation, Santa Clara, U.S.A. The details of the Unified ISA are fully disclosed in the U.S. patent application titled, \u201cA Unified Assembly Instruction Set for Graphics Processing,\u201d filed on Oct. 10, 2006 and having application Ser. No. 11\/548,241. The subject matter of this application is hereby incorporated by reference in its entirety.","Compiler\/linker , which includes code generator  and unified ISA library , provides cross-domain linking capabilities. Specifically, compiler\/linker  translates the high-level shader programs designated for different domains (e.g., high-level vertex shader program , high-level geometry shader program , and high-level fragment shader program ), which are written in high-level shading language, into distinct compiled software objects in the form of assembly code. Further, instead of sending these compiled objects of assembly code individually to separate GPU microcode assemblers (not shown), compiler\/linker  also \u201clinks\u201d the compiled assembly code to generate a single compiled\/linked program object, also in the form of either assembly code or machine code. To link multiple compiled objects from different domains (also referred to as to \u201crendezvous\u201d), compiler\/linker  needs to reconcile the use of symbols across the domains. Specifically, there are generally two types of symbols, the first type being defined or exported symbols, and the second type being undefined or imported symbols. The first type of symbols broadly refers to functions or variables that are present in one compiled object (e.g., vertex shader assembly code) and should be made available for use by other compiled objects (e.g., geometry shader assembly code and\/or fragment shader assembly code). The second type of symbols broadly refers to functions or variables that are called or referenced by one compiled object (e.g., vertex shader assembly code) but are not internally defined within this compiled object.","Additionally, compiler\/linker  supports two types of linking, linking by name and linking by semantics. To illustrate linking by name, suppose Color is the name of a variable containing color values to be passed from the vertex shader program to the fragment shader program. Suppose also that Color is defined in this vertex shader program. In programming model , compiler\/linker  facilitates the establishment and maintenance of the input\/output relationship between high-level vertex shader program  and, for example, high-level geometry shader program  without requiring any explicit variables-to-hardware mappings in the shader programs, so long as the two shader programs use the name Color consistently. To link by semantics, on the other hand, the variable names are not required to be the same. While GLSL generally does not link by semantics, an exception within GLSL is where built-in names have semantic association. For example, gl_Position refers to the position of a vertex, gl_Color refers to the color of a fragment and gl_TexCoord[0] refers to the first of a set of texture coordinates for a vertex or fragment. A second use of linking by semantics occurs with the use of BindFragDataLocationNV( ) described in greater detail herein. Suppose high-level vertex shader program  uses a variable with the name of Vertex_Color for storing the color type X to be passed to high-level geometry shader program , and high-level geometry shader program  uses a variable with the name of Geometry Color for receiving the color type X. In this scenario, compiler\/linker  is still capable of establishing and maintaining the input\/output relationship between high-level vertex shader program  and high-level geometry shader program , so long as Vertex Color and Geometry Color are assigned the same semantics corresponding to the color type X.","The program objects are transmitted to the GPU microcode assembler , which generates machine code programs, including a machine code vertex shader program , a machine code geometry shader program  and a machine code fragment shader program . The machine code vertex shader program  is transmitted to a vertex processing unit  for execution. Similarly, the machine code geometry shader program  is transmitted to a primitive processing unit  for execution and the machine code fragment shader program  is transmitted to a fragment processing unit  for execution.","A data assembler  and the vertex processing unit  function as the vertex shader  of . The data assembler  is a fixed-function unit that collects vertex data for high-order surfaces, primitives, and the like, and outputs the vertex data to vertex processing unit . The data assembler  may gather data from buffers stored within system memory  and GPU local memory  as well as from API calls from the application program  used to specify vertex attributes. The vertex processing unit  is a programmable execution unit that is configured to execute a machine code vertex shader program , transforming vertex data as specified by the vertex shader programs. For example, vertex processing unit  may be programmed to transform the vertex data from an object-based coordinate representation (object space) to an alternatively based coordinate system such as world space or normalized device coordinates (NDC) space. The vertex processing unit  may read texture map data as well as uniform data that is stored in GPU local memory  through an interface (not shown) for use in processing the vertex data. The vertex shader  represents the vertex processing domain of the GPU .","A primitive assembler  and the primitive processing unit  function as the geometry shader . A second primitive assembler (not shown) may be included subsequent to the primitive processing unit  in the data flow through the GPU . The primitive assembler  is fixed-function unit that receives processed vertex data from vertex processing unit  and constructs graphics primitives, e.g., points, lines, triangles, or the like, for processing by primitive processing unit . In prior art systems, the primitive processing unit performs well-known, fixed-function viewport operations such as clipping, projection and related transformations on the incoming vertex data. In the GPU , the primitive processing unit  is a programmable execution unit that is configured to execute machine code geometry shader program  to process graphics primitives received from the primitive assembler  as specified by the geometry shader program . For example, in addition to well-known viewport operations, the primitive processing unit  may be programmed to subdivide the graphics primitives into one or more new graphics primitives and calculate parameters, such as plane equation coefficients, that are used to rasterize the new graphics primitives. The primitive processing unit  may read texture map data that is stored in GPU local memory  through an interface (not shown) for use in processing the geometry data. The geometry shader  represents the geometry processing domain of the GPU . The primitive processing unit  outputs the parameters and new graphics primitives to a rasterizer . The rasterizer  is a fixed-function unit that scan converts the new graphics primitives and outputs fragments and coverage data to the fragment processing unit .","The fragment processing unit  performs the functions of the fragment shader  of . The fragment processing unit  is a programmable execution unit that is configured to execute machine code fragment shader programs  to transform fragments received from rasterizer  as specified by the machine code fragment shader program . For example, the fragment processing unit  may be programmed to perform operations such as perspective correction, texture mapping, shading, blending, and the like, to produce shaded fragments that are output to a raster operations unit . The fragment processing unit  may read texture map data as well as uniform data that is stored in local memory  through an interface (not shown) for use in processing the fragment data. The raster operations unit  optionally performs fixed-function computations such as near and far plane clipping and raster operations, such as stencil, z test and the like, and outputs pixel data as processed graphics data for storage in a buffer in the GPU local memory , such as the frame buffer .",{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 3","FIG. 1","FIG. 1","FIG. 2"],"b":["152","154","156","200","152","124","310","152","315","164","320","166","322","154","322","126","154","315","164","320","166","324","156","156","128","324","156","315","164","320","166","156","326","168"]},"In prior art systems, the vertex shader results , geometry shader results , uniform data  and texture data  are typically a collection of floating-point values and the shaded pixels  are written to fixed-structure buffers within the frame buffer . As previously described herein, some new generation GPUs augment this type of floating-point support with full integer support. Full integer support includes, without limitation, API support to specify shader inputs as integer values as well as data processing within each functional unit, data transmission between functional units and data storage within the programmable graphics pipeline and the GPU local memory , enabling a mix of both integers and floating-point values within the vertex attributes , values of uniforms within the uniform storage buffer , values within the texture buffer , vertex shader results , geometry shader results , shaded pixels , uniform data  and texture data . To provide the new integer support within a GPU to shader program developers, the present invention extends GLSL to incorporate, among other things, integer functions and integer data storage types. A more specific description of the OpenGL\u2122 extensions that support full integer processing is set forth below in the next section of the present application.","Flat shading is a rasterizer feature were the attribute value of all fragments generated for a given point, line or triangle is taken from the corresponding value of a single vertex. One new processing capability enabled by the OpenGL\u2122 extensions described herein is a generalization of flat shading to include any parameter passed from one functional unit to the next. In prior art systems, flat shading was possible only on specific floating-point vertex attributes. However, with the introduction of full integer support within the processing model of the API, a flat shaded integer value is now possible across all parameters. The OpenGL\u2122 extensions pertaining to flat shading are also set forth in the following section.","Another newly enabled processing capability generalizes the output of the fragment shader to include named output buffers within the frame buffer. In prior art systems that include strongly typed high-level shading languages, only fixed-frame buffer output structures, such as floating-point vectors are possible. However, with full integer support for programmatically representing integer values within the fragment shader, including buffer address indices, named buffers are now enabled within the OpenGL\u2122 API. Again, the OpenGL\u2122 extensions pertaining to named output buffers are also set forth in the following section.","In sum, native integer math data types and operations are added to OpenGL's\u2122 GLSL, allowing developers of shader programs to take advantage of native math functionality recently incorporated within advanced graphics processing units. Linking between shader programs that, in combination, may span the vertex, geometry and fragment domains enables the optimization of varying variables of both integer and floating-point data types across the different domains. New capabilities are also enabled, such as the ability to flat shade any parameter passed from one shader to another as well as the ability to incorporate named output buffers within the fragment shader program, by virtue of making the full integer processing capabilities of advanced graphics processing units available to graphics application developers.","Extensions to the OpenGL Shading Language (GLSL) and related APIs to support native integer processing are discussed in this section. Persons skilled in the art will appreciate that the information in this section should be considered in conjunction with the current OpenGL 2.0\u2122 specification.","Importantly, the extensions presented herein introduce two new integer data types: a signed 32-bit integer type that is represented in two's-compliment format and an unsigned 32-bit integer type. The signed 32-bit integer has a type of \u201cint\u201d while the unsigned 32-bit integer has a type of \u201cunsigned int\u201d or simply \u201cuint.\u201d Functional extensions that operate on these new integer data types are listed below in TABLE 1. Signed integers include the variables \u201cai,\u201d \u201cbi\u201d and \u201czi.\u201d Unsigned integers include the variables \u201cau,\u201d \u201cbu\u201d and \u201czu.\u201d The variable \u201cn\u201d indicates a positive count and may be a signed or unsigned integer value. The variable \u201caf\u201d is a floating-point type. While prior art systems included integer variables to conveniently represent basic counting and looping variables, any computation using such variables was not guaranteed to be performed using native integers, precluding the use of any bitwise operators. Furthermore, the total range of values was limited, typically to 16-bit values.",{"@attributes":{"id":"p-0038","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Function","Operation"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Signed Addition","zi = ai + bi"]},{"entry":[{},"Absolute Value","zi = abs (ai)"]},{"entry":[{},"Unsigned Multiplication ","zu = au * bu"]},{"entry":[{},"Signed Multiplication","zi = ai * bi"]},{"entry":[{},"Signed Negate","Zi = \u2212ai"]},{"entry":[{},"Bitwise exclusive-\u201cor\u201d","zu = au {circumflex over (\u2009)} bu"]},{"entry":[{},"Bitwise invert","zu = ~au"]},{"entry":[{},"Bitwise \u201cand\u201d","zu = au & bu"]},{"entry":[{},"Bitwise \u201cor\u201d","zu = au | bu"]},{"entry":[{},"Signed Shift Left","zi = ai << n"]},{"entry":[{},"Signed Shift Right","zi = ai >> n"]},{"entry":[{},"Unsigned Shift Left","zu = au << n"]},{"entry":[{},"Unsigned Shift Right","zu = au >> n"]},{"entry":[{},"Round to closest integer","zi = ROUND (af)"]},{"entry":[{},"Truncate to integer","zi = TRUNC (af)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The math functions and bitwise operators shown in TABLE 1 are performed according to well-known techniques in the field of computer arithmetic. The ROUND ( ) function selects the integer value closest to the corresponding input floating-point value. The TRUNC ( ) function truncates the fractional portion of a floating-point value to yield an integer value.","With the addition of integer data types, new functions and structures are added to the GLSL function library. TABLE 2 sets forth new API commands for specifying integer vertex attribute data. Additionally, fragment shaders can define their own output variables, and declare these output variables to be of type floating-point, integer or unsigned integer. These variables are bound to a fragment color index with the new API command BindFragDataLocationNV( ) and directed to buffers using the existing DrawBuffer( ) or DrawBuffers( ) API commands. Data may be retrieved using GetFragDataLocationNV( )",{"@attributes":{"id":"p-0041","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Type","Function Name","Arguments"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void","VertexAttribl1iNV","(uint index, int x);"]},{"entry":["void","VertexAttribl2iNV","(uint index, int x, int y);"]},{"entry":["void","VertexAttribl3iNV","(uint index, int x, int y, int z);"]},{"entry":["void","VertexAttribl4iNV","(uint index, int x, int y, int z, int w);"]},{"entry":["void","VertexAttribl1uiNV ","(uint index, uint x);"]},{"entry":["void","VertexAttribl2uiNV","(uint index, uint x, uint y);"]},{"entry":["void","VertexAttribl3uiNV","(uint index, uint x, uint y, uint z);"]},{"entry":["void","VertexAttribl4uiNV","(uint index, uint x, uint y, uint z, uint w);"]},{"entry":["void","VertexAttribl1ivNV ","(uint index, const int *v);"]},{"entry":["void","VertexAttribl2ivNV","(uint index, const int *v);"]},{"entry":["void","VertexAttribl3ivNV","(uint index, const int *v);"]},{"entry":["void","VertexAttribl4ivNV","(uint index, const int *v);"]},{"entry":["void","VertexAttribl1uivNV","(uint index, const uint *v);"]},{"entry":["void","VertexAttribl2uivNV ","(uint index, const uint *v);"]},{"entry":["void","VertexAttribl3uivNV ","(uint index, const uint *v);"]},{"entry":["void","VertexAttribl4uivNV ","(uint index, const uint *v);"]},{"entry":["void","VertexAttribl4bvNV","(uint index, const byte *v);"]},{"entry":["void","VertexAttribl4svNV","(uint index, const short *v);"]},{"entry":["void","VertexAttribl4ubvNV ","(uint index, const ubyte *v);"]},{"entry":["void","VertexAttribl4usvNV","(uint index, const ushort *v);"]},{"entry":["void","VertexAttriblPointerNV","(uint index, int size, enum type, "]},{"entry":[{},{},"sizei stride,"]},{"entry":[{},{},"const void *pointer);"]},{"entry":["void","GetVertexAttriblivNV","(uint index, enum pname, int *params);"]},{"entry":["void","GetVertexAttribluivNV ","(uint index, enum pname, uint *params);"]},{"entry":["void","Uniform1uiNV","(int location, uint v0);"]},{"entry":["void","Uniform2uiNV","(int location, uint v0, uint v1);"]},{"entry":["void","Uniform3uiNV","(int location, uint v0, uint v1, uint v2);"]},{"entry":["void","Uniform4uiNV","(int location, uint v0, uint v1, "]},{"entry":[{},{},"uint v2, uint v3);"]},{"entry":["void","Uniform1uivNV","(int location, sizei count, "]},{"entry":[{},{},"const uint *value);"]},{"entry":["void","Uniform2uivNV","(int location, sizei count, "]},{"entry":[{},{},"const uint *value);"]},{"entry":["void","Uniform3uivNV","(int location, sizei count, "]},{"entry":[{},{},"const uint *value);"]},{"entry":["void","Uniform4uivNV","(int location, sizei count, "]},{"entry":[{},{},"const uint *value);"]},{"entry":["void","GetUniformuiv","(uint program, int location, "]},{"entry":[{},{},"uint *params);"]},{"entry":["void","BindFragData ","(uint program, uint "]},{"entry":[{},"LocationNV","colorNumber, const char"]},{"entry":[{},{},"*name);"]},{"entry":["int","GetFragData ","(uint program, const char *name);"]},{"entry":[{},"LocationNV"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"TABLE 3 sets forth a new integer token type that is accepted by the <pname> parameters of the API commands, including, without limitation, GetVertexAttribdv( ) GetVertexAttribfv( ) GetVertexAttribiv( ) GetVertexAttribIuivNV( ) and GetVertexAttribIivNV( ).",{"@attributes":{"id":"p-0043","num":"0042"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Token Name","Token Numeric Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["VERTEX_ATTRIB_ARRAY_INTEGER_NV","0x88FD"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"TABLE 4 sets forth new integer token types that are accepted by the function GetActiveUniform( ) as return values for the corresponding return <type> parameter.",{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Token Name","Token Numeric Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["UNSIGNED_INT","0x1405"]},{"entry":["UNSIGNED_INT_VEC2_NV","0x8DC6"]},{"entry":["UNSIGNED_INT_VEC3_NV","0x8DC7"]},{"entry":["UNSIGNED_INT_VEC4_NV","0x8DC8"]},{"entry":["INT_SAMPLER_1D_NV","0x8DC9"]},{"entry":["INT_SAMPLER_2D_NV","0x8DCA"]},{"entry":["INT_SAMPLER_3D_NV","0x8DCB"]},{"entry":["INT_SAMPLER_CUBE_NV","0x8DCC"]},{"entry":["INT_SAMPLER_2D_RECT_NV","0x8DCD"]},{"entry":["INT_SAMPLER_1D_ARRAY_NV","0x8DCE"]},{"entry":["INT_SAMPLER_2D_ARRAY_NV","0x8DCF"]},{"entry":["INT_SAMPLER_BUFFER_NV","0x8DD0"]},{"entry":["UNSIGNED_INT_SAMPLER_1D_NV","0x8DD1"]},{"entry":["UNSIGNED_INT_SAMPLER_2D_NV","0x8DD2"]},{"entry":["UNSIGNED_INT_SAMPLER_3D_NV","0x8DD3"]},{"entry":["UNSIGNED_INT_SAMPLER_CUBE_NV","0x8DD4"]},{"entry":["UNSIGNED_INT_SAMPLER_2D_RECT_NV","0x8DD5"]},{"entry":["UNSIGNED_INT_SAMPLER_1D_ARRAY_NV","0x8DD6"]},{"entry":["UNSIGNED_INT_SAMPLER_2D_ARRAY_NV","0x8DD7"]},{"entry":["UNSIGNED_INT_SAMPLER_BUFFER_NV","0x8DD8"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"TABLE 5 sets forth new integer token types that are accepted by the <pname> parameters of the API commands, including, without limitation theGetBooleanv( ) GetIntegerv( ) GetFloatv( ) and GetDoublev( )",{"@attributes":{"id":"p-0047","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Token Name","Token Numeric Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["MIN_PROGRAM_TEXEL_OFFSET_NV","0x8904"]},{"entry":["MAX_PROGRAM_TEXEL_OFFSET_NV","0x8905"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"With full integer support within the GPU, integer vertex attributes may be declared as signed or unsigned integers. To load integer vertex attributes while preserving the proper integer data type, a vertex shader program should use the commands set forth below in TABLE 6:",{"@attributes":{"id":"p-0049","num":"0048"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Type","Function Name","Arguments"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Void","VertexAttribl[1234]{i,ui}NV","(uint index, T values);"]},{"entry":["Void","VertexAttribl[1234]{i,ui}vNV ","(uint index, T values);"]},{"entry":["Void","VertexAttribl4{b, s, ub, us}vNV ","(uint index, T values);"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The VertexAttribI* command should match the type of the attribute declared in the vertex shader. In the event of a type mismatch, the attribute values may be undefined. This means that the unsigned versions of the VertexAttribI* commands should be used to load data for unsigned integer vertex attributes or vectors, and the signed versions of the VertexAttribI* commands should be used for signed integer vertex attributes or vectors. This also means that the VertexAttribI* commands should not be used to load data for a vertex attribute declared as a float, float vector or matrix, otherwise their values are undefined. By enforcing a policy of matching types within the API, a single set of registers within the GPU  may be used for storing vertex attributes of different data types. Die area within the GPU  is thereby saved by avoiding the use of additional registers to store each different type of attribute data.","The <index> parameter in the well-known VertexAttribPointer( ) command and the newly disclosed VertexAttribIPointerNV( ) command identifies the generic vertex attribute array being described. The error INVALID_VALUE is generated if <index> is greater than or equal to MAX_VERTEX_ATTRIBS. Generic attribute arrays with integer <type> arguments can be handled in one of three ways: converted to float by normalizing to [0,1] or [\u22121,1], converted directly to float, or left as integers. Data for an array specified by VertexAttribPointer( ) is converted to floating-point by normalizing if the <normalized> parameter is TRUE, and converted directly to floating-point otherwise. Data for an array specified by VertexAttribIPointerNV is stored using un-modified integer values. The following command specifies a vertex attribute pointer using integer data types:",{"@attributes":{"id":"p-0052","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void VertexAttriblPointerNV","(uint index, int size, enum type,"]},{"entry":[{},"sizei stride, const void *pointer);"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"TABLE 7 specifies vertex array sizes (values per vertex) and data types. The \u201cinteger handling\u201d column indicates how fixed-point data types are handled: \u201ccast\u201d means that they converted to floating-point directly, \u201cnormalize\u201d means that they are converted to floating-point by normalizing to [0,1] (for unsigned types) or [\u22121,1] (for signed types), \u201cinteger\u201d means that they remain as integer values, and \u201cflag\u201d means that either \u201ccast\u201d or \u201cnormalized\u201d applies, depending on the setting of the <normalized> flag in VertexAttribPointer( ):",{"@attributes":{"id":"p-0054","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Command","Sizes","Integer Handling ","Types"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["VertexPointer","2, 3, 4","cast",". . ."]},{"entry":["NormalPointer","3","normalize",". . ."]},{"entry":["ColorPointe","3, 4","normalize",". . ."]},{"entry":["SecondaryColorPointer ","3","normalize",". . ."]},{"entry":["IndexPointer","1","cast",". . ."]},{"entry":["FogCoordPointer","1","n\/a",". . ."]},{"entry":["TexCoordPointer","1, 2, 3, 4","cast",". . ."]},{"entry":["EdgeFlagPointer","1","integer",". . ."]},{"entry":["VertexAttribPointer","1, 2, 3, 4","flag",". . ."]},{"entry":["VertexAttriblPointerNV","1, 2, 3, 4","integer","byte, ubyte, short, "]},{"entry":[{},{},{},"ushort, int, uint"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"The following pseudo-code illustrates the processing of vertex attributes with respect to the use of the different VertexAttrib* commands:",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"for (j = 1; j < genericAttributes; j++) {"},{"entry":"\u2003if (generic vertex attribute j array enabled) {"},{"entry":"\u2003\u2003if (generic vertex attribute j array is a pure integer array)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003VertexAttribl[size][type]vNV\u2003\u2003(j, generic vertex attribute j"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003array element i);"},{"entry":"\u2003\u2003} else if\u2003\u2003(generic vertex attribute j array normalization"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003flag is set and <type> is not FLOAT or DOUBLE) {"},{"entry":"\u2003\u2003\u2003VertexAttrib[size]N[type]v\u2003(j, generic vertex attribute j"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003array element i);"},{"entry":"\u2003\u2003} else {"},{"entry":"\u2003\u2003\u2003VertexAttrib[size][type]v\u2003(j, generic vertex attribute j"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003array element i);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"}"},{"entry":"if (generic vertex attribute 0 array enabled) {"},{"entry":"\u2003\u2003if (generic vertex attribute 0 array is a pure integer array) {"},{"entry":"\u2003\u2003\u2003VertexAttribl[size][type]vNV\u2003(0, generic vertex attribute 0"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003array element i);"},{"entry":"\u2003\u2003} else if\u2003\u2003(generic vertex attribute 0 array normalization flag"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003is set and <type> is not FLOAT or DOUBLE) {"},{"entry":"\u2003\u2003\u2003VertexAttrib[size]N[type]v\u2003\u2003(0, generic vertex attribute 0"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003array element i);"},{"entry":"\u2003\u2003} else {"},{"entry":"\u2003\u2003\u2003VertexAttrib[size][type]v\u2003\u2003\u2003(0, generic vertex attribute 0"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003array element i);"},{"entry":"\u2003\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"If a vertex or geometry shader is active, the fixed-function flat shading control specified using glShadeModel( ) applies to the built-in varying variables gl_FrontColor, gl_BackColor, gl_FrontSecondaryColor and gl_BackSecondaryColor. Through the OpenGL Shading Language varying qualifier \u201cflat\u201d any vertex attribute can be flagged to be flat-shaded.","After lighting, clamping or masking and potentially flat shading, vertex attributes, including colors, texture and fog coordinates, shader varying variables and point sizes, computed on a per vertex basis, are clipped. Those attributes associated with a vertex that lies within the clip volume are unaffected by clipping. However, if a primitive is clipped, the attributes assigned to vertices produced by clipping are generated by interpolating attributes along the clipped edge.","For example, suppose the attributes assigned to the two vertices P1 and P2 of an unclipped edge be a1 and a2. The value of t for a clipped point P is used to obtain the attribute associated with P is given by Equation 1:\n\n1+(1)*2\u2003\u2003(Equation 1)\n\nIf the attribute is specified to use interpolation without perspective correction in a shader (using the \u201cnoperspective\u201d keyword), then the attribute associated with P is:\n\n1+(1\u2212\u2032)*2\u2003\u2003(Equation 2)\n\nwhere,\n\n\u2032=(1)\/(1+(1)*2)\u2003\u2003(Equation 3)\n","In Equation 3, w1 and w2 are the w clip coordinates of P1 and P2, respectively. If w1 or w2 is either zero or negative, the value of the associated attribute is undefined.","For a vector attribute, multiplying by a scalar means multiplying each vector component by the scalar. Polygon clipping may create a clipped vertex along an edge of the clip volume's boundary. This situation is handled by noting that polygon clipping proceeds by clipping against one plane of the clip volume's boundary at a time. Attribute clipping is done in the same way, so that clipped points always occur at the intersection of polygon edges (possibly already clipped) with the clip volume's boundary.","TABLE 8 sets forth additional return types available from GetActiveUniform( ) that augment the prior art return types available from GetActiveUniform( ) to incorporate integer data types.",{"@attributes":{"id":"p-0063","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Type"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"INT_SAMPLER_1D_NV,"},{"entry":"INT_SAMPLER_2D_NV,"},{"entry":"INT_SAMPLER_3D_NV,"},{"entry":"INT_SAMPLER_CUBE_NV,"},{"entry":"INT_SAMPLER_2D_RECT_NV,"},{"entry":"INT_SAMPLER_1D_ARRAY_NV,"},{"entry":"INT_SAMPLER_2D_ARRAY_NV,"},{"entry":"INT_SAMPLER_BUFFER_NV,"},{"entry":"UNSIGNED_INT,"},{"entry":"UNSIGNED_INT_VEC2_NV,"},{"entry":"UNSIGNED_INT_VEC3_NV,"},{"entry":"UNSIGNED_INT_VEC4_NV,"},{"entry":"UNSIGNED_INT_SAMPLER_1D_NV,"},{"entry":"UNSIGNED_INT_SAMPLER_2D_NV,"},{"entry":"UNSIGNED_INT_SAMPLER_3D_NV,"},{"entry":"UNSIGNED_INT_SAMPLER_CUBE_NV,"},{"entry":"UNSIGNED_INT_SAMPLER_2D_RECT_NV,"},{"entry":"UNSIGNED_INT_SAMPLER_1D_ARRAY_NV,"},{"entry":"UNSIGNED_INT_SAMPLER_2D_ARRAY_NV,"},{"entry":"UNSIGNED_INT_SAMPLER_BUFFER_NV."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The Uniform*ui{v} commands load sets of one to four unsigned integer values into a uniform location defined as a unsigned integer, an unsigned integer vector, an array of unsigned integers or an array of unsigned integer vectors. TABLE 9 lists extensions to the Uniform*ui{v} commands that provide native integer access to uniform data types:",{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Type","Function Name","Arguments"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void","Uniform{1234}uiNV","(int location, T value)"]},{"entry":["void","Uniform{1234}uivNV","(int location, sizei count, T value)"]},{"entry":["void ","GetUniformfv","(uint program, int location, float *params)"]},{"entry":["void ","GetUniformiv","(uint program, int location, int *params)"]},{"entry":["void ","GetUniformuiv","(uint program, int location, uint *params)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Extending the GLSL texture lookup to include integer texel fetch operations provides the ability to extract a single texel from a specified texture image. The integer coordinates passed to the texel fetch functions are used directly as the texel coordinates (i, j, k) into the texture image. This in turn means the texture image is point-sampled (no filtering is performed). The level of detail accessed is computed by adding the specified level-of-detail parameter <lod> to the base level of the texture, level_base.","The texel fetch functions typically do not perform depth comparisons or access cube maps. Unlike filtered texel accesses, texel fetches typically do not support LOD clamping or any texture wrap mode, and should use a mipmapped minification filter to access any level of detail other than the base level.","Unlike the typical texture map lookup, the results of an integer texel fetch are undefined if any of the following conditions, representing an out-of-bounds lookup request, are true:\n\n","In addition to having access to vertex attributes and uniform variables, vertex shaders can access the read-only built-in variable gl_VertexID. This variable holds the integer index <i> implicitly passed to ArrayElement( ) to specify a given vertex number.","A vertex shader can write to built-in as well as user-defined varying variables. The values associated with a varying variable are typically interpolated across the primitive associated with the corresponding output, unless the varying variable is specified to be flat shaded. For example, the built-in output variables gl_FrontColor, gl_BackColor, gl_FrontSecondaryColor, and gl_BackSecondaryColor hold the front and back colors for the primary and secondary colors for the current vertex. The built-in output variable gl_TexCoordn is an array that holds the set of texture coordinates for the current vertex. The built-in output variable gl_FogFragCoord is used as the \u201cc\u201d value, as described in section 3.10 \u201cFog\u201d of the OpenGL\u2122 2.0 specification. The built-in special variable gl_Position is intended to hold the homogeneous vertex position. Writing gl_Position is optional. The built-in special variable gl_ClipVertex holds the vertex coordinate used in the clipping stage, as described in section 2.12 \u201cClipping\u201d of the OpenGL 2.0\u2122 specification. The built-in special variable gl_PointSize, if written, holds the size of the point to be rasterized, measured in pixels.","Textures with a base internal format of DEPTH_COMPONENT are extended to support texture image specification commands if the target is either TEXTURE_CUBE_MAP or PROXY_TEXTURE_CUBE_MAP. Using this format in conjunction with other targets may result in an INVALID_OPERATION error.","The variable gl_PrimitiveID is a new, read-only variable input to the fragment shader. The integer value of gl_PrimitiveID specifies the ID of the primitive currently being processed. Furthermore, if a geometry shader is active, the built-in variable gl_PrimitiveID contains the ID value emitted by the geometry shader for the provoking vertex. If no geometry shader is active, gl_PrimitiveID is filled with the number of primitives processed by the rasterizer since the last time Begin was called (directly or indirectly via vertex array functions). The first primitive generated after a Begin is numbered zero, and the primitive ID counter is incremented after every individual point, line, or polygon primitive is processed. For polygons drawn in point or line mode, the primitive ID counter is incremented only once, even though multiple points or lines may be drawn. For QUADS and QUAD_STRIP primitives that are decomposed into triangles, the primitive ID is incremented after each complete quad is processed. For POLYGON primitives, the primitive ID counter is undefined. The primitive ID is undefined for fragments generated by DrawPixels( ) or Bitmap( ) Restarting a primitive topology using the primitive restart index has no effect on the primitive ID counter.","A fragment shader can also write to \u201cvarying out\u201d variables (varying variables designated as outputs), which are used in the subsequent per-fragment operations. Varying out variables can be used to write floating-point, integer or unsigned integer values destined for buffers attached to a frame buffer object, or destined for color buffers attached to the default frame buffer. The GLSL specification describes the values that may be output by a fragment shader in terms of three built-in variables, gl_FragColor, gl_FragData[n] and gl_FragDepth. This invention extends GLSL to provide varying out variables as a second category of variables that may be used buy the fragment shader to output data. If fragment clamping is enabled, the final fragment color values or the final fragment data values or the final varying out variable values written by a fragment shader are clamped to the range [0,1] and then may be converted to fixed-point. Only user-defined varying out variables declared as a floating-point type are clamped and may be converted. Integer values are not clamped. If fragment clamping is disabled, the final fragment color values or the final fragment data values or the final varying output variable values are typically not modified.","The values of user-defined varying out variables are directed to a color buffer within the frame buffer in a two step process. First the varying out variable is bound to a fragment color by using a reference number. The compiler\/linker assigns a reference number to each varying out variable, unless overridden by the command BindFragDataLocationNV( ) The reference number of the fragment color assigned for each user-defined varying out variable can be queried with GetFragDataLocationNV( ) Next, the DrawBuffer or DrawBuffers commands direct each fragment color associated with each reference number to a particular buffer.","The binding of a user-defined varying out variable to a fragment color reference number can be specified explicitly using the command:","void BindFragDataLocationNV (uint program, uint colorNumber,\n\n","The BindFragDataLocationNV ( ) command specifies that the varying out variable name in program should be bound to fragment color colorNumber when the program is next linked. If name was bound previously, its assigned binding is replaced with colorNumber. The string referenced by name should be terminated using a null character. The error INVALID_VALUE is generated if colorNumber is equal or greater than MAX_DRAW_BUFFERS. BindFragDataLocationNV( ) has no effect until the program is linked. In particular, it doesn't modify the bindings of varying out variables in a program that has already been linked. The error INVALID OPERATION should be generated if name starts with the reserved \u201cgl_\u201d prefix.","When a program is linked, any varying out variables without a binding specified through BindFragDataLocationNV( ) should automatically be bound to fragment colors by the compiler\/linker. Such bindings can be queried using the command GetFragDataLocationNV( ) LinkProgram( ) should fail if the assigned binding of a varying out variable would cause the compiler\/linker to reference a non-existent fragment color reference number (one greater than or equal to MAX DRAW_BUFFERS). LinkProgram( ) should also fail if more than one varying out variable is bound to the same reference number.","BindFragDataLocationNV may be issued before any shader objects are attached to a program object. Hence binding any name (except a name starting with \u201cgl_\u201d) to a color reference number, including a name that is never used as a varying out variable in any fragment shader object. Assigned bindings for variables that do not exist are ignored. After a program object has been linked successfully, the bindings of varying out variable names to color numbers can be queried. The following command returns the number of the fragment color that the varying out variable name was bound to when the program object program was last linked:","int GetFragDataLocationNV (uint program, const char *name);","The name string should be a null terminated. If program has not been successfully linked, the error \u201cINVALID OPERATION\u201d is generated. If name is not a varying out variable, or if an error occurs, then \u201c\u22121\u201d is returned.","New data structure types are added to accommodate integer types within existing data types. TABLE 10 sets forth a set of new integer structures added to the OpenGL\u2122 API to accommodate full integer support.",{"@attributes":{"id":"p-0083","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Type Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["unsigned int","An unsigned integer"]},{"entry":["uvec2","A two component unsigned integer vector"]},{"entry":["uvec3","A three component unsigned integer vector"]},{"entry":["uvec4","A four component unsigned integer vector"]},{"entry":["isampler1D","handle for accessing an integer 1D texture"]},{"entry":["isampler2D","handle for accessing an integer 2D texture"]},{"entry":["isampler3D","handle for accessing an integer 3D texture"]},{"entry":["isamplerCube","handle for accessing an integer cube mapped texture"]},{"entry":["isampler2DRect","handle for accessing an integer 2D"]},{"entry":[{},"rectangular texture"]},{"entry":["isampler1DArray","handle for accessing an integer 1D"]},{"entry":[{},"array depth texture with comparison"]},{"entry":["isampler2DArray ","handle for accessing an integer 2D"]},{"entry":[{},"array depth texture with comparison"]},{"entry":["isamplerBuffer","handle for accessing an integer buffer texture"]},{"entry":["usampler1D","handle for accessing an unsigned integer 1D texture"]},{"entry":["usampler2D","handle for accessing an unsigned integer 2D texture"]},{"entry":["usampler3D","handle for accessing an unsigned integer 3D texture"]},{"entry":["usamplerCube","handle for accessing an unsigned integer"]},{"entry":[{},"cube mapped texture"]},{"entry":[{},"2D depth texture with comparison"]},{"entry":["usampler2DRect","handle for accessing an unsigned integer"]},{"entry":[{},"2D rectangular texture"]},{"entry":["usampler1DArray","handle for accessing an unsigned integer 1D"]},{"entry":[{},"array depth texture with comparison"]},{"entry":["usampler2DArray","handle for accessing an unsigned integer 2D"]},{"entry":[{},"array depth texture with comparison"]},{"entry":["usamplerBuffer ","handle for accessing an unsigned integer"]},{"entry":[{},"buffer texture"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"If a texture with a signed integer internal format is accessed, one of the signed integer sampler types should be used. If a texture with an unsigned integer internal format is accessed, one of the unsigned integer sampler types should be used. Otherwise, one of the default (float) sampler types should be used. If the types of a sampler and the corresponding texture internal format do not match, the result of a texture lookup should be undefined.","If an integer sampler type is used, the result of a texture lookup is an ivec4. If an unsigned integer sampler type is used, the result of a texture lookup is a uvec4. If a default sampler type is used, the result of a texture lookup is a vec4, where each component is in the range [0, 1].","All of the following functions accept integer sampler types in addition to the core \u201csamplerBuffer\u201d sampler type. For example, textureSizeBuffer( ) accepts variables of type samplerBuffer, as shown, as well as the two corresponding integer forms of samplerBuffer, isamplerBuffer (the signed integer form) and usamplerBuffer (the unsigned integer form). Extending the generalization of the previous example to texture lookups, a \u201csamplerXXX\u201d variable returns a vec4, an \u201cisamplerXXX\u201d variable returns an ivec4, and a \u201cusamplerXXX\u201d returns a uvec4. For the textureSize1Darray( ) function, the first (\u201c.x\u201d) component of the returned vector is filled with the width of the texture image and the second component with the number of layers in the texture array. For the textureSize2Darray( ) function, the first two components (\u201c.x\u201d and \u201c.y\u201d) of the returned vector are filled with the width and height of the texture image, respectively. The third component (\u201c.z\u201d) is filled with the number of layers in the texture array. Integer and unsigned texture lookup functions are provided in the API using function overloading. Overloaded functions that use integer or unsigned-integer versions of the sampler types return ivec4 or uvec4 types, respectively. For the \u201carray\u201d versions, the layer of the texture array to access is either coord.t or coord.p, depending on the use of the 1D or 2D texel fetch lookup, respectively. An exception to the generalized API extensions described herein applies to the family of \u201ctextureSize\u201d functions, which always return either an integer or integer vector, regardless of the sampler type.","The following commands, set forth in TABLE 11 use integer texture coordinates <coord> to lookup a single texel from the level-of-detail <lod> on the texture bound to <sampler> as described in the OpenGL\u2122 specification under \u201cTexel Fetches.\u201d",{"@attributes":{"id":"p-0088","num":"0096"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Type","Function Name","Arguments"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["vec4","texelFetch1D","(sampler1D sampler, int coord, int lod)"]},{"entry":["vec4","texelFetch2D","(sampler2D sampler, ivec2 coord, int lod)"]},{"entry":["vec4","texelFetch3D","(sampler3D sampler, ivec3 coord, int lod)"]},{"entry":["vec4","texelFetch2Drect","(sampler2DRect sampler, ivec2 coord, int lod)"]},{"entry":["vec4","texelFetch1Darray ","(sampler1DArray sampler, ivec2 coord, int lod)"]},{"entry":["vec4","texelFetch2Darray ","(sampler2DArray sampler, ivec3 coord, int lod)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The following functions, set forth in TABLE 12, return the width, height, depth and number of layers for a texture bound to <sampler> at level of detail <lod>.",{"@attributes":{"id":"p-0090","num":"0098"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Type","Function Name","Arguments"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["int","textureSizeBuffer ","(samplerBuffer sampler)"]},{"entry":["int","textureSize1D","(sampler1D sampler, int lod)"]},{"entry":["ivec2","textureSize2D","(sampler2D sampler, int lod)"]},{"entry":["ivec3","textureSize3D","(sampler3D sampler, int lod)"]},{"entry":["ivec2","textureSizeCube","(samplerCube sampler, int lod)"]},{"entry":["ivec2","textureSize2Drect ","(sampler2DRect sampler, int lod)"]},{"entry":["ivec2","textureSize1Darray ","(sampler1DArray sampler, int lod)"]},{"entry":["ivec3","textureSize2Darray ","(sampler2DArray sampler, int lod)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"TABLE 13 sets fort a set of functions used to perform a texture lookup at the coordinate specified by the first element (coord.s) of texture coordinate coord within the layer indicated by the second coordinate coord.t of the 1D texture array currently bound to sampler. The layer being accessed is computed by layer=max (0, min(d\u22121, floor (coord.t+0.5)) where \u2018d\u2019 is the depth of the texture array.",{"@attributes":{"id":"p-0092","num":"0100"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 13"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Type ","Function Name","Arguments"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"vec4 ","texture1Darray","(sampler1DArray sampler, "]},{"entry":[{},{},{},"vec2 coord [, float bias])"]},{"entry":[{},"vec4 ","texture1DarrayLod","(sampler1DArray sampler, "]},{"entry":[{},{},{},"vec2 coord, float lod)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"TABLE 14 sets fort a set of functions used to perform a texture lookup at the coordinate specified by the first two elements (coord.s, coord.t) of texture coordinate coord to perform a texture lookup in the layer indicated by the third coordinate coord.p of the 2D texture array currently bound to sampler. The layer to access is computed by layer=max (0, min(d\u22121, floor (coord.p+0.5)) where \u2018d\u2019 is the depth of the texture array.",{"@attributes":{"id":"p-0094","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 14"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Type ","Function Name","Arguments"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["vec4 ","texture2Darray","(sampler2DArray sampler, vec3 coord [, float bias])"]},{"entry":["vec4 ","texture2DarrayLod","(sampler2DArray sampler, vec3 coord, float lod)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"TABLE 15 sets froth a set of functions relevant to shadow mapping. The shadow1Darray( ) and shadow1DarrayLod( ) functions use texture coordinate coord.s to perform a depth comparison lookup on an array layer of the depth texture bound to sampler, as described in version 2.0 of the OpenGL\u2122 specification. The layer being accessed is indicated by the second coordinate coord.t and is computed by layer=max (0, min(d\u22121, floor (coord.t+0.5)) where \u2018d\u2019 is the depth of the texture array. The third component of coord (coord.p) is used as the R value. The texture bound to sampler should be a depth texture, or results are undefined. The shadow2Darray( ) function uses texture coordinate (coord.s, coord.t) to perform a depth comparison lookup on an array layer of the depth texture bound to sampler, as described in version 2.0 of the OpenGL\u2122 specification. The layer being accessed is indicated by the third coordinate coord.p and is computed by layer=max (0, min(d\u22121, floor (coord.p+0.5)) where \u2018d\u2019 is the depth of the texture array. The fourth component of coord (coord.q) is used as the R value. The texture bound to sampler should be a depth texture, or results are undefined. The ShadowCube( ) function uses texture coordinate (coord.s, coord.t, coord.p) to perform a depth comparison lookup on the depth cubemap bound to sampler, as described in section 3.8.14 of the OpenGL\u2122 2.0 specification. The direction of the vector (coord.s, coord.t, coord.p) is used to select which face of the cubemap a 2-dimensional texture lookup is performed on, as described in the OpenGL\u2122 2.0 specification. The fourth component of coord (coord.q) is used as the R value. The texture bound to sampler should be a depth cubemap, otherwise results are undefined.",{"@attributes":{"id":"p-0096","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 15"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Type ","Function Name","Arguments"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["vec4 ","shadow1Darray","(sampler1DArrayShadow "]},{"entry":[{},{},"sampler, vec3 coord, [float"]},{"entry":[{},{},"bias])"]},{"entry":["vec4 ","shadow1DarrayLod ","(sampler1DArrayShadow "]},{"entry":[{},{},"sampler, vec3 coord, float lod)"]},{"entry":["vec4 ","shadow2Darray","(sampler2DArrayShadow sampler, "]},{"entry":[{},{},"vec4 coord)"]},{"entry":["vec4","shadowCube","(samplerCubeShadow sampler, vec4 coord)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"TABLE 16 sets forth the \u201coffset\u201d version of each existing texture API function and provides an extra parameter <offset> which is added to the (u, v, w) texel coordinates before looking up each texel. Note that <offset> does not generally apply to the layer coordinate for texture arrays, as explained in detail in section 3.8.7 of the OpenGL\u2122 2.0 Specification. Note also that texel offsets are generally not supported for cubemaps or buffer textures.",{"@attributes":{"id":"p-0098","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 16"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Type ","Function Name","Arguments"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["vec4 ","texture1Doffset","(sampler1D sampler, float coord, int offset [, float"]},{"entry":[{},{},"bias])"]},{"entry":["vec4 ","texture1Dproj-","(sampler1D sampler, vec2 coord, int offset [, float"]},{"entry":[{},"Offset","bias])"]},{"entry":["vec4 ","texture1Dproj-","(sampler1D sampler, vec4 coord, int offset"]},{"entry":[{},"Offset","[, float bias])"]},{"entry":["vec4 ","texture1Dlod-","(sampler1D sampler, float coord, float lod, int"]},{"entry":[{},"Offset","offset)"]},{"entry":["vec4 ","texture1Dproj-","(sampler1D sampler, vec2 coord, float lod, int"]},{"entry":[{},"LodOffset","offset)"]},{"entry":["vec4 ","texture1Dproj-","(sampler1D sampler, vec4 coord, float lod, int"]},{"entry":[{},"LodOffset","offset)"]},{"entry":["vec4 ","texture2Doffset","(sampler2D sampler, vec2 coord, ivec2 offset"]},{"entry":[{},{},"[, float bias])"]},{"entry":["vec4 ","texture2Dproj-","(sampler2D sampler, vec3 coord, ivec2 offset"]},{"entry":[{},"Offset","[, float bias])"]},{"entry":["vec4","texture2Dproj-","(sampler2D sampler, vec4 coord, ivec2 offset"]},{"entry":[{},"Offset","[, float bias])"]},{"entry":["vec4","texture2Dlod-","(sampler2D sampler, vec2 coord, float lod,"]},{"entry":[{},"Offset","ivec2 offset)"]},{"entry":["vec4","texture2Dproj-","(sampler2D sampler, vec3 coord, float lod,"]},{"entry":[{},"LodOffset","ivec2 offset)"]},{"entry":["vec4","texture2Dproj-","(sampler2D sampler, vec4 coord, float lod,"]},{"entry":[{},"LodOffset","ivec2 offset)"]},{"entry":["vec4","texture3Doffset","(sampler3D sampler, vec3 coord, ivec3 offset"]},{"entry":[{},{},"[, float bias])"]},{"entry":["vec4","texture3Dproj-","(sampler3D sampler, vec4 coord, ivec3 offset"]},{"entry":[{},"Offset","[, float bias])"]},{"entry":["vec4","texture3Dlod-","(sampler3D sampler, vec3 coord, float lod,"]},{"entry":[{},"Offset","ivec3 offset)"]},{"entry":["vec4","texture3Dproj-","(sampler3D sampler, vec4 coord, float lod,"]},{"entry":[{},"LodOffset","ivec3 offset)"]},{"entry":["vec4","shadow1Doffset","(sampler1DShadow sampler, vec3 coord, int"]},{"entry":[{},{},"offset [, float bias])"]},{"entry":["vec4","shadow2Doffset","(sampler2DShadow sampler, vec3 coord, ivec2"]},{"entry":[{},{},"offset [, float bias])"]},{"entry":["vec4","shadow1Dproj-","(sampler1DShadow sampler, vec4 coord, int"]},{"entry":[{},"Offset","offset [, float bias])"]},{"entry":["vec4","shadow2Dproj-","(sampler2DShadow sampler, vec4 coord, ivec2"]},{"entry":[{},"Offset","offset [, float bias])"]},{"entry":["vec4","shadow1Dlod-","(sampler1DShadow sampler, vec3 coord, float"]},{"entry":[{},"Offset","lod, int offset)"]},{"entry":["vec4 ","shadow2Dlod-","(sampler2DShadow sampler, vec3 coord, float"]},{"entry":[{},"Offset","lod, ivec2 offset)"]},{"entry":["vec4 ","shadow1Dproj-","(sampler1DShadow sampler, vec4 coord, float"]},{"entry":[{},"LodOffset","lod, int offset)"]},{"entry":["vec4","shadow2Dproj-","(sampler2DShadow sampler, vec4 coord, float"]},{"entry":[{},"LodOffset","lod, ivec2 offset)"]},{"entry":["vec4 ","texture2Drect-","(sampler2DRect sampler, vec2 coord, ivec2"]},{"entry":[{},"Offset","offset)"]},{"entry":["vec4 ","texture2Drect-","(sampler2DRect sampler, vec3 coord, ivec2"]},{"entry":[{},"ProjOffset ","offset)"]},{"entry":["vec4 ","texture2Drect-","(sampler2DRect sampler, vec4 coord, ivec2"]},{"entry":[{},"ProjOffset ","offset)"]},{"entry":["vec4 ","shadow2Drect-","(sampler2DRectShadow sampler, vec3 coord,"]},{"entry":[{},"Offset","ivec2 offset)"]},{"entry":["vec4 ","shadow2Drect-","(sampler2DRectShadow sampler, vec4 coord,"]},{"entry":[{},"ProjOffset","ivec2 offset)"]},{"entry":["vec4 ","texelFetch1Doffset","(sampler1D sampler, int coord, int lod, int offset)"]},{"entry":["vec4 ","texelFetch2Doffset","(sampler2D sampler, ivec2 coord, int lod, ivec2"]},{"entry":[{},{},"offset)"]},{"entry":["vec4 ","texelFetch3Doffset","(sampler3D sampler, ivec3 coord, int lod, ivec3"]},{"entry":[{},{},"offset)"]},{"entry":["vec4 ","texelFetch2-","(sampler2DRect sampler, ivec2 coord, int lod,"]},{"entry":[{},"DrectOffset","ivec2 offset)"]},{"entry":["vec4 ","texelFetch1-","(sampler1DArray sampler, ivec2 coord, int lod,"]},{"entry":[{},"DarrayOffset","int offset)"]},{"entry":["vec4 ","texelFetch2-","(sampler2DArray sampler, ivec3 coord, int lod,"]},{"entry":[{},"DarrayOffset","ivec2 offset)"]},{"entry":["vec4 ","texture1Darray-","(sampler1DArray sampler, vec2 coord, int offset"]},{"entry":[{},"Offset","[, float bias])"]},{"entry":["vec4 ","texture1Darray-","(sampler1DArrayNv sampler, vec2 coord, float"]},{"entry":[{},"LodOffset ","lod, int offset)"]},{"entry":["vec4 ","texture2Darray-","(sampler2DArray sampler, vec3 coord, ivec2"]},{"entry":[{},"Offset","offset [, float bias])"]},{"entry":["vec4 ","texture2Darray-","(sampler2DArray sampler, vec3 coord, float lod,"]},{"entry":[{},"LodOffset","ivec2 offset)"]},{"entry":["vec4 ","shadow1Darray-","(sampler1DArrayShadow sampler, vec3 coord,"]},{"entry":[{},"Offset","int offset, [float bias])"]},{"entry":["vec4 ","shadow1Darray-","(sampler1DArrayShadow sampler, vec3 coord,"]},{"entry":[{},"LodOffset","float lod, int offset)"]},{"entry":["vec4 ","shadow2Darray-","(sampler2DArrayShadow sampler, vec4 coord,"]},{"entry":[{},"Offset","ivec2 offset)"]},{"entry":["vec4 ","texture1Dgrad-","(sampler1D sampler, float coord, float ddx, float"]},{"entry":[{},"Offset","ddy, int offset);"]},{"entry":["vec4 ","texture1Dproj-","(sampler2D sampler, vec2 coord, float ddx, float"]},{"entry":[{},"GradOffset ","ddy, int offset);"]},{"entry":["vec4 ","texture1Dproj-","(sampler2D sampler, vec4 coord, float ddx, float"]},{"entry":[{},"GradOffset ","ddy, int offset);"]},{"entry":["vec4 ","texture1Darray-","(sampler1D sampler, vec2 coord, float ddx, float"]},{"entry":[{},"GradOffset","ddy, int offset);"]},{"entry":["vec4 ","texture2Dgrad-","(sampler2D sampler, vec2 coord, vec2 ddx,"]},{"entry":[{},"Offset","vec2 ddy, ivec2 offset);"]},{"entry":["vec4 ","texture2Dproj- ","(sampler2D sampler, vec3 coord, vec2 ddx,"]},{"entry":[{},"GradOffset","vec2 ddy, ivec2 offset);"]},{"entry":["vec4 ","texture2Dproj-","(sampler2D sampler, vec4 coord, vec2 ddx,"]},{"entry":[{},"GradOffset ","vec2 ddy, ivec2 offset);"]},{"entry":["vec4 ","texture2Darray-","(sampler2D sampler, vec3 coord, vec2 ddx,"]},{"entry":[{},"GradOffset","vec2 ddy, ivec2 offset);"]},{"entry":["vec4 ","texture3Dgrad-","(sampler3D sampler, vec3 coord, vec3 ddx,"]},{"entry":[{},"Offset","vec3 ddy, ivec3 offset);"]},{"entry":["vec4 ","texture3Dproj-","(sampler3D sampler, vec4 coord, vec3 ddx,"]},{"entry":[{},"GradOffset ","vec3 ddy, ivec3 offset);"]},{"entry":["vec4 ","shadow1Dgrad-","(sampler1DShadow sampler, vec3 coord, float"]},{"entry":[{},"Offset","ddx, float ddy, int offset);"]},{"entry":["vec4 ","shadow1Dproj-","(sampler1DShadow sampler, vec4 coord, float"]},{"entry":[{},"GradOffset ","ddx, float ddy, int offset);"]},{"entry":["vec4 ","shadow1Darray-","(sampler1DShadow sampler, vec3 coord, float"]},{"entry":[{},"GradOffset","ddx, float ddy, int offset);"]},{"entry":["vec4 ","shadow2Dgrad-","(sampler2DShadow sampler, vec3 coord, vec2"]},{"entry":[{},"Offset","ddx, vec2 ddy, ivec2 offset);"]},{"entry":["vec4 ","shadow2Dproj-","(sampler2DShadow sampler, vec4 coord, vec2"]},{"entry":[{},"GradOffset","ddx, vec2 ddy, ivec2 offset);"]},{"entry":["vec4 ","shadow2Darray- ","(sampler2DShadow sampler, vec4 coord, vec2"]},{"entry":[{},"GradOffset","ddx, vec2 ddy, ivec2 offset);"]},{"entry":["vec4 ","texture2Drect-","(sampler2D sampler, vec2 coord, vec2 ddx,"]},{"entry":[{},"GradOffset","vec2 ddy, ivec2 offset);"]},{"entry":["vec4 ","texture2DrectProj-","(sampler2D sampler, vec3 coord, vec2 ddx,"]},{"entry":[{},"GradOffset","vec2 ddy, ivec2 offset);"]},{"entry":["vec4 ","texture2DrectProj-","(sampler2D sampler, vec4 coord, vec2"]},{"entry":[{},"GradOffset","ddx,vec2 ddy, ivec2 offset);"]},{"entry":["vec4 ","shadow2Drect-","(sampler2DShadow sampler, vec3 coord, vec2"]},{"entry":[{},"GradOffset","ddx, vec2 ddy, ivec2 offset);"]},{"entry":["vec4 ","shadow2Drect- ","(sampler2DShadow sampler, vec4 coord, vec2"]},{"entry":[{},"ProjGradOffset","ddx, vec2 ddy, ivec2 offset);"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"While the forgoing is directed to embodiments of the present invention, other and further embodiments of the invention may be devised without departing from the basic scope thereof, and the scope thereof is determined by the claims that follow.","All trademarks are the respective property of their owners."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features of the present invention can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to embodiments, some of which are illustrated in the appended drawings. It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 3","FIG. 1"]}]},"DETDESC":[{},{}]}
