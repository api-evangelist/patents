---
title: Constraint injection system for immunizing software programs against vulnerabilities and attacks
abstract: A constraint is inserted into a program to address a vulnerability of the program to attacks. The constraint includes a segment of code that determines when the program has been asked to execute a “corner case” which does not occur in normal operations. The constraint code can access a library of detector and remediator functions to detect various attacks and remediate against them. Optionally, the detector can be employed without the remediator for analysis. The context of the program can be saved and restored if necessary to continue operating after remediation is performed. The constraints can include descriptors, along with machine instructions or byte code, which indicate how the constraints are to be used.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08656497&OS=08656497&RS=08656497
owner: VMware, Inc.
number: 08656497
owner_city: Palo Alto
owner_country: US
publication_date: 20110401
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application is a continuation of and claims benefit of U.S. Patent Application This application claims the benefit of U.S. patent application Ser. No. 11\/422,547, filed Jun. 6, 2006, which in turn claims benefit of U.S. Provisional Patent Application 60\/688,099, filed Jun. 7, 2005, applications of which are incorporated herein by reference in their entireties.","Computer hosts are subject to a variety of attacks, such as denial of service, privilege elevation, directory traversal, buffer overflow, unauthorized remote or local execution\/access, information leakage, and the like. Such attacks can be particularly damaging and costly for enterprises such as corporations, governments and other large organizations. As a result, an industry has been developed to protect against such attacks. For example, protective software is developed proactively, in anticipation of future attacks. Although proactive protection can prevent a large class of attacks, host intrusion prevention cannot solely rely on proactive protection. There are many other possible attack vectors available on a system, and no proactive system can guarantee 100% coverage against known and unknown attacks, including those not yet developed. Current applications and operating systems are far too complex for any intrusion prevention system to accurately identify all possible attack vectors. Thus, there is a need for a broad and flexible system that can react to any possible vulnerability or attack in a timely manner.","Further, the current and most effective method of reactively handling vulnerabilities is to patch the system. When a vulnerability is discovered, a patch is created, typically by an independent software vendor (ISV). A Typical patch replaces an executable file or dynamically linked library, requiring a restart of the application or a reboot of the system to activate a patch. A typical patch process involves fixing the bugs in the code, then recompiling the code and releasing an executable with the necessary modules. However, a patch update has many of the disadvantages of a software upgrade: it typically requires a reboot of the application, it is a single monolithic change to the application that can alter the normal operating behavior, eliminating a problematic patch is cumbersome, and there is no customer visibility into the effectiveness of a patch.","A technique is needed for protecting software which addresses the above and other issues.","The technology herein, roughly described, provides a constraint injection system and technique for protecting software.","The constraint injection system and technique protects precisely in application memory near the vulnerability itself, rather than outside the application memory at the system or network perimeter. A constraint is usually a few machine instructions that are inserted into the program. A constraint can also be inserted into an active application where the program instructions reside in memory. The system and technique provides the capability to address any known type of software flaw, including those that permit attacks such as denial of service, privilege elevation, directory traversal, buffer overflow, unauthorized remote or local execution\/access, information leakage, and the like, while maintaining critical business continuity. The system and technique complements conventional patching and, because of the speed with which it can be deployed, reduces the exposure of programs to attacks.","New constraints can be applied to running applications without restart or reboot, and updates can be provided periodically or otherwise as needed. Similarly, there is no need to upgrade hardware or other programs. Furthermore, the constraint injection technique can be run in a detect mode, in which it accurately indicates the risk of user\/application interference before the constraint is enabled, and in a protect mode in which the constraint is enabled.","The constraint injection system and technique also enables fine-grained administrative control by a server, group or operating system, for example.","In one embodiment, a computer-implemented method for protecting software includes inserting constraint code into the program at a patch point which is between instructions of the computer program, and executing the constraint code when a control flow of the computer program reaches the patch point. The constraint code may include assembly code or machine instructions, for instance. The constraint code can call a detector for detecting if a vulnerability is invoked in the computer program, and call a remediator, responsive to the detector, for taking remediation action. In one approach, the inserting includes copying a code fragment of the computer program to a cache, and inserting at least one instruction of the constraint code into the code fragment in the cache, between the instructions of the computer program. In another approach, the inserting includes replacing at least one instruction of the computer program with at least one instruction of the constraint code, and storing the at least one replaced instruction at a gateway, in which case no cache is needed.","In another embodiment, a computer-implemented method for protecting software includes identifying a vulnerability in a computer program, developing a constraint for eliminating the vulnerability, the constraint comprising code which is inserted into the computer program at a specified point, and releasing the constraint to at least one customer.","Corresponding systems and program storage devices are also provided.","1. Introduction\u2014Anatomy of a Vulnerability","While a constraint injection system can be applied to many problems, as described in section 3, one of the main applications is protecting vulnerabilities of a computer program. Most vulnerabilities are corner cases that should never happen in normal operation of the software. A corner case is a problem or situation that occurs only outside of normal operating parameters\u2014especially one that manifests itself when multiple environmental variables or conditions are simultaneously at extreme levels. They usually result from a developer failing to account for that case when writing the software code. Corner cases result in vulnerabilities than can be exploited to carry out actions that should not be allowed under the normal operating assumptions of the program.","For most vulnerabilities, a simple check, such as a few instructions, e.g., assembly instructions, carried out at the right point of the program execution, is sufficient to detect the corner case. For example, such a check may determine if a value is out of range or if certain patterns are present in a string. These checks don't detect the corner cases in normal operations. When the check, inserted in the program, detects the invocation of the corner case, a simple remediation such as returning an error code, changing an out of range data value so that it is in range, truncating a string, or changing the control flow of the program, is sufficient to avoid exploitation of the vulnerability. Hard issues in dynamic program upgrades such as state changes or data structure changes are typically not required in checking and remediation of a vulnerability.","2. A Constraint Injection System","We introduce a technique that can provide immunization against program vulnerabilities. As previously mentioned, the exploitation of a vulnerability can be avoided by inserting a simple check and remediation code into an existing application program. A constraint injection system is a system that allows insertion\/injection of one or more code segments (constraints) into an application for this purpose. In particular, a constraint can include detector code, which determines when a corner case is invoked, and remediator code, which takes remediation action once the corner case is detected.","Generally, a constraint has a designated application, and each constraint addresses one vulnerability. Usually, a constraint targets a particular address in the application where it is inserted. This location is designated by the constraint developer. Once injected, it is triggered by control flowing through the patch point.","Within the application, specific components such as a library component and an executable component are named. For example, with Microsoft Windows\u00ae, a Dynamic Link Library (DLL) and an Executable (.EXE) file are named. Generally, any type of library and executable can be provided for use with any system, including Unix and others. The application and components are identified by a version number and a hash. Filtering criteria can be used to identify the applicability of a constraint.","The following is a set of attributes present in some of the possible manifestations of a constraint injection system:","2a. Stable","The constraint injection system is stable by itself, and the system or the constraints within the system introduce only minimal disruptions to the system, helping to increase the overall availability of the system.","2b. Secure","The constraint injection system does not introduce any new exploitable attack vectors to the system. All communication and constraints are checked and verified for authenticity.","2c. Comprehensive","Most constraint implementations provide the ability to inject an arbitrary piece of code into an arbitrary point in the application code. This is an extremely powerful tool which has the ability to identify and fix most problems in a program, as there are no restrictions in the ability to modify the program.","2d. Dynamic","In implementations where the constraints are injected into application memory, a new constraint can be inserted into a running application, e.g., dynamically. In most implementations, it is possible to turn a constraint on and off dynamically as the application is running. It is also possible to toggle any customer-visible switches, such as toggling between detection and protection mode dynamically.","2e. Removable","In most implementations, it is possible to remove the constraint from a running application.","2f. Minimal","It is possible to create a constraint to addresses a single vulnerability. Thus, a typical constraint should have minimal impact on the overall system. A collection of constraints protects the system against known vulnerabilities.","2g. Customer-Visible","The status and statistics of constraints can be made customer visible. For example, each constraint can have a customer-friendly description. Constraints can be maintained as customer-visible databases. Furthermore, the customer can control individual constraints, such as turning them on or off, and setting detector or protector modes. The customer can observe the behavior of active constraints, such as the number of invocations of the detector, the number of triggerings of the remediator, the number of errors, remediation action taken, and a current state such as on or off, or detector or protector mode. The ability to create a debug log with customer-visible debug settings to understand false positives and errors can also be provided. The status of the constraint can indicate if it is on or off, if it is applicable in a system and if it is active or passive. The system can also gather statistics about the effectiveness of the constraint such as how many times the constraint was invoked.","3. Problems Addressed by Constraint Injection","A constraint injection system is a flexible system that is not limited to solving program vulnerability problems. This section describes this and other possible applications of a constraint injection system.","3a. Patching a Vulnerability","A primary goal of a constraint injection system is to protect software systems against known vulnerabilities. Since vulnerabilities are known before most of the attacks against them are released, protecting against the vulnerabilities in a timely manner provides a proactive Intrusion Prevention System (IPS).","3b. Protecting Against an Attack","As with patching a vulnerability, a constraint can be created against a known attack. In particular, by analyzing the attack to understand how it deviates from the normal program behavior, a constraint can be crafted to check and stop that deviation.","3c. Fixing a Program Bug","Since a constraint has the ability to change an arbitrary piece of code in an application, it can be used to fix many other classes of bugs that do not lead to a vulnerability.","3d. Filtering Content","A constraint can monitor data flowing within an application and search and filter the data. This can be achieved by inserting a constraint that gets executed with the movement of data.","3e. Enforcing a Security Policy","A constraint can enforce a security policy in an application, such as by restricting the existing functionality of the application. A constraint can insert code to limit, bypass or disable a specific feature.","3f. Extending the Application Functionality","As a corollary to security policy enforcement, a constraint can be used to extend and enhance the functionality of an application.","3g. Monitoring the Application Behavior","A constraint can be used to monitor certain program behavior by inserting checks on the control flow path pertaining to that behavior, and reporting relevant results to a monitoring system outside the program. This can also be used to monitor system and application performance, stability and availability.","4. Constraint Injection System Overview","A constraint injection system can span three domains: creation; management; and deployment. Most constraints are created at the security laboratories of a constraint vendor, an Intrusion Prevention System (IPS) vendor, an Independent Software Vendor (ISV), an Original Equipment Manufacturer (OEM) vendor which developed the application which is to be protected, or a third party security professional. The constraints can be managed and administered by an Enterprise Network Operations Center (NOC) of a customer of the constraint injection system. The NOC is typically a physical space from which a large telecommunications network is managed, monitored and supervised. Finally, the constraints are deployed at the hosts in the enterprise.","Primary types of constraints include: 1) constraints targeting a known vulnerability, attack or a program bug, 2) general constraints that can address a wide range of problems or enforce lockdowns or other policies (these constraints may require configuration, tuning or training), and 3) built-in constraints delivered with the constraint injection system that protect against known vulnerabilities and enforce accepted policies. The functionality of the constraint injection system can be understood further in view of the following description.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 1","b":["105","110","115","135"]},"In a second possible path, a security patch is released (step ). For example, an OEM software vendor such as Microsoft Corp. periodically releases security patches in response to discovered vulnerabilities. The patch is differenced against the original module to identify the modified code (step ). Then, the security laboratory determines how to force the program to execute the modified code, e.g., by applying the correct input sequence or other another appropriate tool (step ). Subsequently, the vulnerability is identified (step ).","In a third path, when an attack is released (step ), the attack is acquired (step ) and its activities are traced (step ) by observing what it does when attacking a controlled, vulnerable system. Subsequently, the vulnerability is identified (step ). Typically, when an attack is released, news of the release is publicized as a warning to others by customers, software vendors, software security industry groups and sometimes the general news media. In other cases, customers may choose to handle attacks privately to avoid negative publicity.","Thus, in all three paths, after an analysis is performed, the vulnerability is identified (step ), and a constraint can be developed to detect the vulnerability and remediate against it (step ). The constraint code can be ported to different versions of the module that is patched (step ). That is, multiple versions of the same software can exist in deployment. Some of these differences are not customer visible (for example, an earlier patch was applied or not). Each version typically has one or two slightly different files. Thus, a patch should be ported to all the versions of a file that might be running in a customer machine. The constraints are extensively tested (step ) before being released, e.g., to customers (step ).",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 2","b":["240","210","220","240","210","220","215","240","215","220","240"]},"Delivery of the constraints , such as in the form of libraries, can also take multiple paths. For example, the security laboratory  can deliver the constraints directly to the customer . Or, the security laboratory  can deliver the constraints to the OEM software vendor  which, in turn, delivers the constraints to the customer . In another approach, the security laboratory can provide tools for developing and delivering the constraints  to the OEM software vendor  or to a constraint developer . Either of these entities can use the tools to prepare the constraints  and deliver them to the customer  as a service. The security laboratory  optionally uses the help of a vulnerability information provider  in multiple stages of constraint creation to develop the constraints. The vulnerability information provider  can be individuals or companies who reverse engineer programs and\/or track and analyze the information on vulnerabilities to help the constraint developer  create the constraints. The multiple stages of constraint creation generally refer to steps ,  or ,  or , and  of . Sometimes the vulnerability information provider  can also perform steps  and part of step  to take some of the burden of constraint creation off of the constraint developer .","In another approach, the customer itself develops the constraints and\/or constraint injection software if it has the available resources.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 3","FIG. 4","FIG. 3"],"i":"a","b":["420","420","430","430","440","350","305","330","340","350","360","350"]},"An original, unmodified program, which is to receive the constraint, includes a code fragment  which has a number of instructions, e.g., instruction A , instruction B , instruction C  and instruction D , for instance. The original program refers to the program as it exists before a constraint is injected to protect against attacks. A Managed Program Execution Engine (MPEE)  controls the creation and management of a secure code cache . Further details regarding a possible implementation of the secure code cache  can be found in U.S. patent application publication no. 2005\/0010804, published Jan. 13, 2005, titled \u201cSecure Execution Of A Computer Program Using a Code Cache,\u201d, incorporated herein by reference.","The MPEE  creates a modified code fragment  from the original code fragment . In particular, the modified code fragment  includes a save context instruction , a change stack instruction , a call gateway instruction , a return status instruction , and a restore context instruction , which are inserted at a patch point which is between the instruction B  and the instruction C . Here, we assume a constraint is a single unit that gets inserted into a single location with a single detector\/remediator function. However, it is also possible for a constraint to be provided by using a collection of patch points, where each patch point has its own insertion point, detector and\/or remediator functions (see ). Generally, a constraint can be inserted into any location in an application. The locations need not be predefined.","The specific location for inserting the constraint is specified by the constraint developer. The function of the save context instruction  is to save the application context, the function of the change stack instruction  is to change the stack from the current stack to the MPEE stack, the function of the return status instruction  is to return a status of the detector to the user, the function of the call gateway instruction  is to call the constraint gateway , and the function of the restore context instruction  is to restore the application context. See  for further details. The context is mainly denoted by the registers. Each context will have its own stack. However, the current stack is identified by the stack pointer register, thus, changing the registers will change the stack.","A Constraint Management Engine (CME)  coordinates with the MPEE  so that when the original code fragment  is copied from the original program location  into the secure code cache , it is correctly modified to reflect the modified code fragment . When the control-flow invokes the constraint, it calls the constraint gateway . In particular, when the control flow passes through the modified fragment , the call gateway instruction  calls the constraint gateway . The constraint gateway , using a deployment status given by the constraint management system , calls the appropriate one or more constraints in constraint libraries . More than one constraint can be attached to the same instruction. The constraint libraries  include a detector  and a remediator , which in turn may call a set of predefined functions from a predefined functions library . See section 19. The predefined functions may include, e.g., string copy, string compare, and other functions that multiple constraints may use. The constraint libraries  also include a constraint descriptor , discussed below in section 9. The constraint gateway  subsequently makes a call return to the code fragment , such as to the return status instruction .","The detector  determines whether the modified fragment  is attempting to invoke the vulnerability, in which case that fact is reported and the remediator  is called. The detector  should have no adverse impact on the program, such as changing the program state. That is, the detector code should not modify any program visible memory or program registers, acquire program visible resources, modify program control flow, or crash and hang the system. Exception conditions should be caught, and checks should be made for infinite loops. If a problem is encountered, the constraint can be exited. For recurring problems, the constraint can be disabled.","The remediator  has the ability to change the application to fix a vulnerability, such as by changing any application visible memory location, or changing control flow of the program, e.g., by returning from the current application function or jumping over a few application instructions after a trampoline. A trampoline is a small piece of code that is created at run time, mainly in the stack. This code is generated to help the program transfer control from one place to another. The original code transfers control to the trampoline code, which will then transfer control to the destination. There are multiple uses for trampolines. For example, when the destination is not known at compile-time, the trampoline can do the control transfer without patching the binary. When the type of the branch is not known (short or long), the trampoline can help insert a variable-sized instruction. Trampolines can also be used to handle long branches.","Allowed program level remediation action can also be taken, such as killing a thread and\/or process and throwing an exception. The remediator code should change the program behavior only minimally to the extent needed to stop an attack.","The constraint management engine  coordinates with the outside world via an external interface for managing constraints , e.g., to set the deployment state of the constraints as well as to load new constraint libraries. For example, the external interface  can communicate with the central controller  via the node manager .","The constraint system can be implemented on the Microsoft\u00ae Internet Security and Acceleration (ISA) Server, in one possible implementation.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 4","FIG. 2"],"i":"a ","b":["410","412","414","235","410","420","420"]},"The servers can also provide information to the central controller  regarding stability and possible false-positives, thereby facilitating the deployment and improving the overall availability. When an event is triggered, the server nodes can use intelligence to differentiate a security event from a false positive and also aggregate that information at the central controller  to improve the accuracy and inform the system administrator. Furthermore, each server or other end-point can have a node manager  that acts as an intermediary between the central controller  and an application core  within each individual application.","The central controller  stores the constraints in a constraint store , and collects information regarding the current status of the constraints in a constraint information module . A deployment settings and status module  enables an administrator to manage the deployment of the constraints and informs the administrator of the current status. A statistics module  collects statistical data regarding the constraints. See section 12 below for further information.","Also, in , between the node manager  and the core , the notation \u201cread only memory\u201d denotes the mechanism to pass constraint information from the node manager  to the application  by sharing a memory page between the two processes, the notation \u201cConstraint Library load\u201d denotes that the node manager  loads information from the libraries  and  of , into the application , and the notation \u201cnotification\u201d denotes a mechanism that notifies the application  that new information is available (for example, this may be implemented using either an interrupt type or polling type mechanism). User preferences for constraint deployment, such as on, off, detect or protect can also be provided in the notification. The notation \u201cread only memory\u201d denotes a shared memory page that communicates current operational characteristics from the application  to the node manager . For example, status information and statistics related to constraint deployments can be provided. Lastly, the notation \u201cevent log\u201d denotes that events generated by the core  can be logged at the node manager .",{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 4","FIG. 4","FIG. 4","FIG. 4"],"i":["b ","a","a","a. "],"b":["460","475","470","480","475","482","490","480","420","484","492","482","490","430","483","486","490","494","486","494","482","490","490","482","486","494","440"]},{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 5","FIG. 3"],"b":["311","502","504","506","507"]},"The constraint gateway identifies the constraint that was executed (step ). If the constraint is active and selected (decision block ), the detector in the constraint library is called (step ). If the current constraint is not in the protect mode, the detector status is returned to the user (step ), and execution continues at the application code (step ) after restoring the application context (step ). Thus, even if the constraint is not deployed in the protector mode, status information, statistics and the like can be reported. If the current constraint is in the protect mode (decision block ), and if a return code from the detector indicates that remediation is necessary (decision block ), then the remediator (step ) is called. Depending on the return code of the remediator (decision block ), different paths can be taken. In one path, the current thread and\/or process is terminated (step ). In a second path, the control flow is changed to a different application address, in which case the fragment from the jump target is found or created (step ), the modified application context is restored (step ) and the fragment is executed (step ). In a third path, the program continues executing from the point where the constraint was invoked, in which case the application context, which may be modified, is restored (step ) and the fragment continues executing (step ).",{"@attributes":{"id":"p-0073","num":"0072"},"figref":["FIG. 6","FIG. 6","FIG. 3"],"b":["312","313","314","315","316","305","330","322","324","326","328"]},"When a new constraint is loaded (step ), the information about the constraint is recorded (step ). Next, for all of the affected applications and the modules within the applications listed in the constraint (step ), the system checks to see if the application is currently running and the module is currently loaded (decision block ). Note that step  will be invoked multiple times by the step \u2014once per each module. If the module is loaded, additional checks are carried out. For example, the version of the module in memory can be checked against the version provided (decision block ). Specifically, when a new module is loaded into memory (step ), for each constraint (step ), all the active constraints are queried to see if any of them includes the module being deployed (decision block ). Thus, at decision block , the version of the provided module can be compared to the version of the module in memory. If all the checks pass, then, for each patch point in the module (step ), patch point selection logic is executed (decision block ). The patch point selection logic relates to matching the constraint application policy (Section 11, below). If the patch point selection logic selects deployment, a hash of the program bits around the patch point is calculated and compared to the provided hash in a hash check (decision block ). If the hash check indicates a match, the patch point is deployed (step ).","The process is completed (step ) when the module is not loaded (decision block ), the module versions do not match (decision block ), the patch point selection logic does not select deployment (decision block ), or the hash check does not indicate a match (decision block ).",{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 7","b":["705","710","715","720","725"]},{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 8","FIG. 3"],"b":["311","805","810","815","820","825","830","835","840","815","840"]},"5. Constraint Categories","Constraints can be categorized by their interactions with the end-user or the system administrator at the enterprise.","5a. Black-Box Constraints","The constraint developer has the option of providing a constraint as a black box constraint. Black box constraints do not allow the customer any per-constraint configurability. The only option the customer has is to decide where to deploy the constraint. However, the constraint injection system may provide generic options for all constraints, such as the ability to deploy in Intrusion Detection System (IDS) or Intrusion Prevention System (IPS) modes. In the IDS mode, or detect mode, intrusions are detected, but preventative action is not taken, while in the IPS mode, or protect mode, preventative action is taken, in addition to the detection. The IDS mode thus can indicate the risk of user\/application interference before the constraint is enabled. Most constraints against vulnerabilities, attacks and bugs can meet the customer's need while minimizing complexity when provided as black-box constraints.","5b. Parameter-Exposed Constraints","The user can supply a set of arguments (or parameters) to the constraint to tune the constraint. Further, a constraint can check for broad or generic problems. Such constraints may need to be tuned to match each application and the deployment scenario. Thus, the constraint can expose a per-constraint interface to the customer. Most policy enforcement constraints fit into this category.","5c. GUI-Exposed Constraints","An advanced form of a parameter-exposed constraint has a Graphical User Interface (GUI) component associated with it. This can be implemented using a simple GUI creation language, an accompanying Java or Active-X component, or any other GUI technology.","5d. Customer-Developed Constraints","Ultimately, an Application Programming Interface (API) for constraint development can be exposed to the customer.","6. Constraint Scope","The scope of a constraint can be unlimited in its ability to insert arbitrary code, or restricted to fit a specific method of program modification such as API interception. API interception refers to capturing the interactions between an application and an operating system at the API level. This section describes a set of possible scope restrictions, as well as a detector and remediator model.","6a. Arbitrary Code Block Injection","A constraint injection system has the ability to inject a constraint in the form of a small block of assembly code into a program. This provides the ultimate power to the constraint, as it provides the ability to monitor or change the program's behavior without restrictions.","6b. Restricted Code Block Injection","The assembly code injection can be restricted according to one or more Application Binary Interfaces (ABIs). An ABI is a set of rules the code in the detector and the remediator has to follow. The ABI rules for the detector and the remediator are different. An ABI describes the low-level interface between an application program and the operating system, between an application and its libraries, or between component parts of the application. An ABI allows compiled object code to function without changes on any system using a compatible ABI. The ABI can be tailored to support all the necessary functionality while disallowing any extra power that can negatively impact the application. For example, an ABI for constraints used for data collection will not allow any modifications to the application state or any application control transfer.","6c. Detector and Remediator Code Block Injection","Constraints for vulnerabilities can be developed within a detector\/remediator paradigm since most vulnerabilities are due to a corner case that should never occur in normal operation. As discussed previously, the detector checks for the occurrence of the corner case and the remediator takes the necessary remediation action when the corner case is detected. Thus, the detector can follow a very restrictive ABI so that it can provide a strong guarantee that it will not change the normal program behavior. This can be achieved by restricting the detector so that it cannot change normal program state, including:\n\n","This can be achieved by catching any exception condition and by checking for infinite loops.","When the constraint is run in the detect mode, it has no impact on the normal program operation. This is important because some constraints can generate false positives, and remediation action taken as a result of these false positives can impact the normal program behavior. In this mode, the customers can observe and test the constraint for false positives without impacting the application.","The remediator has the ability to modify the program state and change the control flow of the program. However, the ABI for the remediator can also be restricted by providing it with an interface to carry out the remediation action.","Simple constraints (referring to both the detector and the remediator) will be stateless. However, it is possible to extend the constraint injection system such that a constraint can capture, store, modify and share the internal state across time or with other constraints. Constraint-state information should be decoupled from the program state.","6d. Validation Routine for API Interception","As APIs are a publicly visible, thus stable and known, points in a program, they provide a good opportunity for interception. A validation routine can validate the arguments passed in the API call. As all system calls are implemented as an API, API interception is a superset of system-call interception.","The API validators, a type of constraint, are also a small block of assembly code. However, this block has to follow an even more restricted form of the ABI than that followed by general constraints. For example, this code can only access memory that is part of the input data structures for the API. The API validator ABI will provide access to each of the arguments to the API. The data types of the arguments of individual APIs are validated, thus making the allowed accesses more precise and restrictive.","The API validators can also be extended to accommodate simple interceptions similar to input filtering, where, for a given API and an argument, a regular expression is provided to validate the argument.","6e. Regular Expression for Input Filtering","A typical input filter is a regular expression. All inputs to the application (the type of the input is given by the policy) are checked against the regular expression. The alphabet used to build the regular expression can include ASCII and Unicode characters, memory addresses and a set of special terms defined by the API. If needed, a more powerful grammar can be developed to express the input filters.","Each application is analyzed to find appropriate filter points. Filters and filter points are tagged as belonging to one or more categories, as indicated by Table 1. For applications that were not analyzed and tagged, a set of generic rules can be used to identify what to filter and what category each filter point is associated with. Table 1 provides a partial list of possible input point categories.",{"@attributes":{"id":"p-0096","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Name:","Category:","Description:"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["EI","External Input","All inputs from external sources"]},{"entry":["EIR","External input","Inputs as-is (may be encrypted"]},{"entry":[{},"pre-processed","or unexpanded)"]},{"entry":["EIO","External input","Inputs after expansion,"]},{"entry":[{},"post-processed","decryption and reassembly"]},{"entry":["EO","External output","Data being sent out of the system"]},{"entry":["FN","File names","Names for files"]},{"entry":["FNR","File names - read","Names for files to read"]},{"entry":["FNW","File names - write","Names for files to write"]},{"entry":["FNC","File names - create","Names for files that will be created"]},{"entry":["FC","File content","Data being read\/written to a file"]},{"entry":["FCR","File content - read","Data that is read from a file"]},{"entry":["FCW","File content - write","Data that is written to a file"]},{"entry":["CS","Command string","Shell commands that are executed"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Two types of monitors for input selection can be used:","1. Generic Monitors\u2014using the Microsoft Windows\u00ae API, for instance, special API interceptors can be created as generic selectors that can be applied to any program.","2. Custom Monitors\u2014with the full knowledge of a given program, a specific interception point can be monitored for input filtering.","7. Constraint Patch Point Identification","It is important to precisely describe where to insert the constraint in the application code. As the application code is executed, when the control flow passes over the patch point, the constraint will be invoked. This section describes possible patch points for constraints.","7a. Address Offset","When a constraint is inserted into a known module (e.g., an executable or a library), an offset from the starting address of the module can be provided to indicate the patch point.","7b. Absolute Address","If the module is guaranteed not to be relocated by the loader, the absolute address can be used to describe the patch point.","7c. Symbolic Offset","In order to support multiple versions of a module that may be slightly different, a symbolic address with an offset can be provided to describe the patch point. The constraint injection system can resolve the symbolic address and add the offset to determine the actual insertion point.","7d. API Interception Hook","To describe a constraint at an API function provided by the operating system or the common libraries, the name of the function can be used. Thus, the constraint can be applicable across multiple major and minor versions of the library. Furthermore, a constraint can be created without having access to the application.","7e. System Call Hook","Constraints can be inserted before and\/or after a system call. System calls can be identified by the special machine instruction that performs the kernel transfer. Some operating systems such as Microsoft Windows\u00ae renumber system calls between versions, in which case a table that maps the system call to the call number according to the Operating System (OS) version can be used to allow the system call identification to work across multiple OS versions.","7f. Code Pattern Match Hook","Instead of identifying a location, the constraint injection system can check for a particular collection of instructions to identify where to insert a constraint. A simple search involves matching an exact code sequence. However, this search can be complex. For example, regular expression matching may be used.","7g. Multi-Mode","A multiple mode system uses criteria such as a symbolic offset or system call to identify a general region, and then searches that area to find a code pattern to locate the exact patch point. There are other possible combinations for multi-mode selection. The address calculation can also include more complex algorithms.","8. Constraint Injection Methods","An important aspect of a constraint injection system is the method used to inject the constraint into the application code. Some of the injection methods only provide a partial set of desired attributes of a constraint injection system. This section describes a few possible injection methods.","8a. Trampoline Method","The constraint can be invoked by inserting a trampoline, or short section of code, into the given location of the memory image of the application module. Since this insertion should occur concurrently with other active threads, the trampoline insertion has to be atomic. Furthermore, it can overwrite an instruction at a valid instruction boundary. These limitations impose restrictions on where trampolines can be installed and the type of instruction that can be inserted. It may be necessary to have a short jump to a nearby location before transferring control into the constraint code block.","8b. Code Cache Method","This method, discussed previously in connection with , involves a system that creates a cache of the instruction blocks of the original program and executes the instructions out of the cache. The Memory Firewall\u2122, available from Determina Corp., Redwood City, Calif., is an example of a system that creates an instruction cache. However, other approaches may be used as well. Since the instruction cache remaps the address space and provides an application-transparent translation from the original address to the cache address, it is possible to change the shape of the instruction block. Thus, it is possible to insert multiple instructions into a program instruction block by expanding the block in cache. Furthermore, the MPEE  (), which provides a cache management system, can provide synchronization between multiple threads so that the code insertion does not need to be atomic, allowing the insertion of multiple instructions. This provides a flexible framework for constraint injection. When a code block is copied to the code cache, the constraint injection system can check to see if an active constraint is designated to be inserted into that block. If an active constraint is so designated, the constraint injection system can rewrite the block with the constraint code or insert a call to the constraint code. If a new constraint arrived while the application is running and the insertion point is already in the code cache, that cache block can be flushed and recreated with the constraint inserted. The recreation can occur immediately or lazily when the program counter is transferred to that block next time.","8c. Binary Rewrite Method","In this method, the executable or the library can be modified offline to insert the constraint, e.g., by inserting a trampoline or rearranging the code. The constraint can be in-lined, or a constraint function can be added to the module. Note that this method is unable to provide dynamic injection of constraints.","8d. Object Code Rewrite Method","In this method, the modification occurs in the program development tool chain. This can occur at many points, such as at the compiler, assembler, or the linker.","8e. Byte Code Modification Method","This method is applied when the program is released as byte code, and can rewrite the byte code to include the constraints by the loader, execute the constraints in the interpreter, or insert the constraints in the Just In-Time compiler when the byte code is translated into machine code.","8f. Application\/System Defined Interception Point Method","Operating systems and complex applications provide APIs for inserting functionality for monitoring or changing the application behavior. In this method, an application or operating system-specific constraint injection system can be created using one of these APIs provided by the application or the OS. The constraint will get invoked when the underlying application or the operating system calls the API. However, such a system cannot support insertion at any arbitrary point in the application.","8g. Loader Rewrite Method","When a module is loaded into the memory space, the loader can scan the module and insert any applicable constraint. This can be done either by inserting a trampoline or inlining the constraint by rearranging the code in the module. However, the loader method cannot support dynamic insertion after the library or the executable is loaded.","8h. System Call Shim Method","In this method, a limited form of constraint that allows the monitoring of system calls can be implemented using a system call shim either from within the user space or the kernel space.","9. Constraint Descriptor","The constraint descriptor  () provides a description associated with each constraint that helps the constraint injection system decide when, where and how to apply the constraint. There are many variations of constraint descriptors possible. Two example instantiations of a constraint descriptor are provided below. In particular, Table 2 provides a basic constraint descriptor, while Table 3 provides an extended constraint descriptor.","9a. Basic Constraint Descriptor","Table 2 depicts an instance of a descriptor provided by each constraint. The example is geared toward use with Microsoft Windows\u00ae, but is generally applicable. One possible representation uses an extensible markup language (XML) file. The constraints may use this descriptor, in one approach.",{"@attributes":{"id":"p-0119","num":"0122"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Descriptor:","Definition\/Comment:"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["xml_file_version","XML file version."]},{"entry":["xml_file_timestamp","The timestamp of the creation of the"]},{"entry":[{},"XML file."]},{"entry":["xml_file_signature","Signature generated using a private"]},{"entry":[{},"key; used to verify XML integrity at"]},{"entry":[{},"the customer site by the"]},{"entry":[{},"management console."]},{"entry":["constraint_injection_engine_version+","Version of the constraint injection"]},{"entry":[{},"system."]},{"entry":["policy+","Customer visible unit size. This is"]},{"entry":[{},"the level at which the customer"]},{"entry":[{},"configures and views results. A"]},{"entry":[{},"policy defines the attributes and"]},{"entry":[{},"constraints for a single vulnerability"]},{"entry":[{},"announcement (e.g., security"]},{"entry":[{},"bulletin), say Microsoft's MS-2004-"]},{"entry":[{},"0120. However, such an announce-"]},{"entry":[{},"ment can have more than one"]},{"entry":[{},"vulnerability fixed, so a policy can"]},{"entry":[{},"address more than one vulnerability."]},{"entry":["policy_id","Unique positive integer identifying"]},{"entry":[{},"a policy. Same if a new version is"]},{"entry":[{},"released to replace an old one."]},{"entry":["Name","A string name for the policy."]},{"entry":[{},"Visible to the customer."]},{"entry":["Description","Comment string describing the"]},{"entry":[{},"policy. Visible to the customer."]},{"entry":["external_id","Either a Common Vulnerabilities"]},{"entry":[{},"and Exposures (CVE\u2009\u00ae) #, a"]},{"entry":[{},"Candidate (CAN) CVE # such as a"]},{"entry":[{},"Microsoft CAN #, or something"]},{"entry":[{},"else that identifies the patch by an"]},{"entry":[{},"external source."]},{"entry":["Version","Mainly for the management console"]},{"entry":[{},"to filter among different versions of"]},{"entry":[{},"the same constraint and send only"]},{"entry":[{},"the latest version to the core."]},{"entry":["policy_class","One of:"]},{"entry":[{},"VULNERABILITY - Protects"]},{"entry":[{},"against a known vulnerability."]},{"entry":[{},"Typically start with the detect"]},{"entry":[{},"mode."]},{"entry":[{},"ATTACK - Protects against a"]},{"entry":[{},"known attack. Preferably put into"]},{"entry":[{},"protect mode directly."]},{"entry":[{},"LOCKDOWN - Enforces a system"]},{"entry":[{},"lockdown. As this is optional and"]},{"entry":[{},"requires customer interaction, it"]},{"entry":[{},"should be in off or detect mode by"]},{"entry":[{},"default."]},{"entry":[{},"MONITOR - Monitor specified"]},{"entry":[{},"activity in an application. This can"]},{"entry":[{},"be used to help an external event"]},{"entry":[{},"correlator. Here, the remediator"]},{"entry":[{},"should have the properties of the"]},{"entry":[{},"detector, i.e. not modify the"]},{"entry":[{},"application. It should issue a"]},{"entry":[{},"message that can get aggregated by"]},{"entry":[{},"an event correlator. Thus, can start"]},{"entry":[{},"in off or protect mode."]},{"entry":["constraint_dll","Base name of constraint DLL or"]},{"entry":[{},"other library without path. Core"]},{"entry":[{},"assumes all DLLs will be in a DLL"]},{"entry":[{},"cache managed by Central"]},{"entry":[{},"Controller e.g., in a single directory."]},{"entry":["constraint_dll_hash","Hash value used by core to verify"]},{"entry":[{},"that \u201cconstraint_dll\u201d hasn't been"]},{"entry":[{},"tampered with."]},{"entry":["os_major* (\u201c*\u201d indicates that","Specifies the operating system for"]},{"entry":["the term will appear zero, one","which the policy is applicable, e.g.,"]},{"entry":["or many times)","Windows\u2009\u00ae 2000, 2003 or XP."]},{"entry":[{},"Only for filtering by the manage-"]},{"entry":[{},"ment console and customer"]},{"entry":[{},"visibility; not for core."]},{"entry":["os_servicepatck*","The service pack number of the"]},{"entry":[{},"operating system."]},{"entry":["os_patch*","The patch level of the operating"]},{"entry":[{},"system."]},{"entry":["executable_list*","A list of executable names, no"]},{"entry":[{},"paths; only for filtering by the"]},{"entry":[{},"management console and node"]},{"entry":[{},"manager, and for customer"]},{"entry":[{},"visibility; not used by core; empty"]},{"entry":[{},"means applicable to any executable"]},{"entry":[{},"using the DLLs involved."]},{"entry":["Timestamp","Creation timestamp for the policy."]},{"entry":["Mode","Default mode of application for this"]},{"entry":[{},"policy. Can be detect, protect or off."]},{"entry":["constraint_reset_function","Symbol or offset from the base"]},{"entry":[{},"address of the function in"]},{"entry":[{},"\u201cconstraint_dll\u201d that will be called"]},{"entry":[{},"to init\/reset state at injection, flush"]},{"entry":[{},"and exception-abort time."]},{"entry":["vulnerability+ (\u201c+\u201d indicates","Each \u201cvulnerability\u201d defines the"]},{"entry":["that the term will appear one or","constraint for one vulnerability in"]},{"entry":["many times)","the policy. If a \u201cpolicy\u201d intends to"]},{"entry":[{},"handle more than one vulnerability,"]},{"entry":[{},"then there should be a"]},{"entry":[{},"\u201cvulnerability\u201d for each. This is not"]},{"entry":[{},"visible to the customer, only"]},{"entry":[{},"\u201cexternal_id\u201d is; it used for internal"]},{"entry":[{},"tracking. The reason this is invisible"]},{"entry":[{},"to the customer is that they only"]},{"entry":[{},"see, e.g., MS-####-####, not all the"]},{"entry":[{},"vulnerabilities fixed by it."]},{"entry":["vulnerability_id","A unique positive integer that"]},{"entry":[{},"identifies the vulnerability."]},{"entry":["Description","Comment string describing the"]},{"entry":[{},"\u201ccomponent\u201d and the constraint for"]},{"entry":[{},"it."]},{"entry":["set+","Each \u201cset\u201d defines all the modules"]},{"entry":[{},"affected by a vulnerability and the"]},{"entry":[{},"corresponding constraint. \u201cSets\u201d are"]},{"entry":[{},"used to handle different versions of"]},{"entry":[{},"one or more modules that may have"]},{"entry":[{},"the same vulnerability that need to"]},{"entry":[{},"be patched. This done by defining a"]},{"entry":[{},"different \u201cset\u201d for each set of"]},{"entry":[{},"module versions requiring a patch."]},{"entry":[{},"Only one \u201cset\u201d should be applicable"]},{"entry":[{},"for a given process, i.e., \u201csets\u201d are"]},{"entry":[{},"mutually exclusive."]},{"entry":["module+","Defines the module to be patched,"]},{"entry":[{},"its characteristics, patch points and"]},{"entry":[{},"constraint code."]},{"entry":["pe_name","Used to identify the module to be"]},{"entry":[{},"patched. A value must be specified"]},{"entry":[{},"even if it is \u201c\u201d."]},{"entry":["Pe_checksum","Used to identify the module to be"]},{"entry":[{},"patched. A value must be specified"]},{"entry":[{},"even if it is \u201c\u201d."]},{"entry":[{},"Must specify even if zero, e.g.,"]},{"entry":[{},"whatever is in the portable"]},{"entry":[{},"executable (PE) or other executable"]},{"entry":[{},"file."]},{"entry":["pe_timestamp","Used to identify the module to be"]},{"entry":[{},"patched. A value must be specified"]},{"entry":[{},"even if it is \u201c\u201d."]},{"entry":[{},"Must specify even if zero, e.g.,"]},{"entry":[{},"whatever is in the portable"]},{"entry":[{},"executable (PE) or other executable"]},{"entry":[{},"file."]},{"entry":["pe_size","Used to identify the module to be"]},{"entry":[{},"patched. A value must be specified"]},{"entry":[{},"even if it is \u201c\u201d."]},{"entry":[{},"Must specify even if zero, e.g.,"]},{"entry":[{},"whatever is in the portable"]},{"entry":[{},"executable (PE) or other executable"]},{"entry":[{},"file."]},{"entry":["hash+","Set of hash definitions, one per"]},{"entry":[{},"patch point, used to verify that each"]},{"entry":[{},"patch point is correct. Even if one"]},{"entry":[{},"doesn't match, the PE file is"]},{"entry":[{},"rejected."]},{"entry":["start_addr","Offset, from the base address, from"]},{"entry":[{},"which the hash is to be computed."]},{"entry":["Length","Number of bytes to be used in the"]},{"entry":[{},"hash computation."]},{"entry":["hash_value","Hash value to check against."]},{"entry":["patch_point+","Defines the offset to be patched and"]},{"entry":[{},"the constraint code for it."]},{"entry":["offset","Symbol or offset relative to the base"]},{"entry":[{},"address of the module to be"]},{"entry":[{},"patched."]},{"entry":["detector_fn","Symbol or offset relative to the base"]},{"entry":[{},"address of the constraint DLL"]},{"entry":[{},"which specifics the detector code to"]},{"entry":[{},"call."]},{"entry":["remediator_fn","Same as the above, but for the"]},{"entry":[{},"remediator."]},{"entry":["return_addr","Symbol or offset relative to the base"]},{"entry":[{},"address of the module to be patched"]},{"entry":[{},"where control should go to after"]},{"entry":[{},"executing the remediator code, if"]},{"entry":[{},"requested by the remediator. This"]},{"entry":[{},"allows the remediator to change the"]},{"entry":[{},"flow of the application's execution."]},{"entry":["precedence","A global rank to decide which"]},{"entry":[{},"constraint code gets injected first if"]},{"entry":[{},"two of them have to be injected at"]},{"entry":[{},"the same \u201coffset\u201d."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The following fields (Table 3) can be use to supplement or replace the fields in the basic descriptor (Table 2) to provide a more extensive form of a constraint descriptor.",{"@attributes":{"id":"p-0121","num":"0124"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Unique ID","Num1.Num2.Num3","Num 1 - Unique number of the"]},{"entry":[{},{},"originator"]},{"entry":[{},{},"Num 2 - A unique assigned number"]},{"entry":[{},{},"by the originator"]},{"entry":[{},{},"Num 3 - the year"]},{"entry":["Type","POL","Policy constraint"]},{"entry":[{},"GEN","A general constraint that protects"]},{"entry":[{},{},"against a class of attacks"]},{"entry":[{},"VUL","A constraint against a known"]},{"entry":[{},{},"vulnerability"]},{"entry":[{},"ATT","A constraint against a known attack"]},{"entry":["Constraint","CODEBLK","A general constraint with a code block"]},{"entry":["Type","SYSCALL","An API interceptor"]},{"entry":[{},"INPTFIL","An input filter"]},{"entry":[{},"INPTMONC","A monitor code that intercepts a"]},{"entry":[{},{},"known specific input point and"]},{"entry":[{},{},"extracts the input for input filtering."]},{"entry":[{},{},"Interfaces with the runtime system."]},{"entry":[{},"INPTMONG","A monitor code that uses API"]},{"entry":[{},{},"interception to intercept A generic"]},{"entry":[{},{},"input point for input filtering."]},{"entry":[{},{},"Interfaces with the runtime system."]},{"entry":["Originator -","Short String","Name of the originator\/creator of the"]},{"entry":["Major",{},"constraint"]},{"entry":["Originator -","Short String","Some descriptive information about"]},{"entry":["Minor","(optional)","originator within the organization"]},{"entry":["Confidence","Number between 0","Provides originator's confidence on"]},{"entry":[{},"and 15","lack of false positives."]},{"entry":[{},{},"0 - can have false positives"]},{"entry":[{},{},"15 - cannot have false positives"]},{"entry":["Importance","Number between 0","Originator's estimate on how"]},{"entry":[{},"and 15","important this constraint is."]},{"entry":[{},{},"0 - optional constraint, not that"]},{"entry":[{},{},"important"]},{"entry":[{},{},"15 - critical constraint, extremely"]},{"entry":[{},{},"important"]},{"entry":["Invalidates","A list of unique IDs","Constraints that are superseded by this"]},{"entry":[{},"(optional)","constraint"]},{"entry":["Requires","A list of unique IDs","Constraints that are required in order"]},{"entry":[{},"(optional)","to deploy this constraint"]},{"entry":["Applies to","List of","Nm. - the name of an executable or a"]},{"entry":[{},"<nm., ver., info>","DLL"]},{"entry":[{},{},"Ver. - the version number, can include"]},{"entry":[{},{},"\u201c*\u201d in version fields to identify all"]},{"entry":[{},{},"minor versions"]},{"entry":[{},{},"Info. - Specific information for"]},{"entry":[{},{},"different constraint types"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"INFO","CODEBLK","Offset from the beginning of code"]},{"entry":[{},{},{},"segment to insert the check"]},{"entry":[{},{},"SYSCALL","The name or number of the syscall to"]},{"entry":[{},{},{},"monitor"]},{"entry":[{},{},"INPTFIL","Type of input to filter"]},{"entry":[{},{},"INPTMONG","Type of input available for filtering"]},{"entry":[{},{},{},"and API name"]},{"entry":[{},{},"INPTMONC","Type of input available for filtering"]},{"entry":[{},{},{},"and offset from the beginning of the"]},{"entry":[{},{},{},"code segment to insert the check"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"A constraint injection system may require each constraint to provide machine instructions along with the constraint descriptor. This can be either an arbitrary block of instructions or an instruction block that follows a given set of rules, e.g., a restrictive ABI. When a constraint is invoked by the constraint injection system, this code block can be executed. A constraint injection system can support a mix of these languages. Note that, in a detector and remediator based solution, each constraint can carry two code blocks, one for the detector and one for the remediator. A constraint can be implemented using the following techniques.","10a. Function in a Library","When a constraint is injected, a library file such as a DLL can provide the code for the constraint. This library can have an exported function for the constraint, which is called by the constraint injection system. Each library can have functions for multiple constraints. The constraint injection system can support either a single comprehensive library with all the constraints, or multiple libraries, each with only the new constraints.","10b. Machine Instruction Function Object","Instead of relying on the loader to load the constraint function library, the constraint injection system can directly provide the machine code for the constraint function. This information is copied into the program's memory by the constraint injection system. However, the constraint injection system has to resolve the symbols and perform the linking. The linking functionality required is simple since the constraint functions have a very limited ABI. Furthermore, not exposing the constraint functions to the application makes the constraint injection system more transparent. Another issue is relocation of the code. The constraint injection system can either carry out the relocation or demand position-independent code.","10c. Machine Instruction Code Block Insertion","The constraint code, provided as a code block, can be directly inlined into application code at the appropriate locations when the code cache is built. This can lead to better performance when executing constraints.","10d. Machine Instruction Code Block Replacement","This is very similar to machine instruction code block insertion, where instead of inserting a code block, the existing code block is replaced.","10e. Byte Code","Instead of providing machine instructions, a byte code can be used to describe the constraint. When the constraint code has to follow a restricted ABI, the byte code provides a simple way of enforcing that ABI. The byte code should have a simple mapping to the machine instructions.","Table 4 provides an example of a simple constraint byte code format. The byte code can be either a part of the constraint descriptor or a separate file. SP denotes a space.",{"@attributes":{"id":"p-0129","num":"0132"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Byte code:","Machine instructions\/comments:"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["constraint_code","\u201c[\u201d [SP] <globals> SP <all_cons> [SP] \u201c]\u201d"]},{"entry":["globals","\u201c(\u201c [SP] <num_glob> _[SP] <glob_list> [SP] \u201c)\u201d"]},{"entry":["num_glob","The count of the data units in the glob_list"]},{"entry":["glob_list","<glob_list> [SP] <data> | <data> |  "]},{"entry":["data","\u201c<\u201d [SP] <num_bytes> [SP] \u201c>\u201d |"]},{"entry":[{},"\u201c<\u201d [SP] <num_bytes> SP <init_string> [SP] \u201c>\u201d"]},{"entry":["num_bytes","Numeric value of number of bytes to allocate"]},{"entry":["Init_string","Hexadecimal byte string. The number of bytes in the string should be"]},{"entry":[{},"less or equal to num_bytes"]},{"entry":["all_cons","<num_cons> [SP] <cons_list>"]},{"entry":["num_cons","The count constraint units in the cons_list"]},{"entry":["cons_list","<cons_list> [SP] <constraint> | <constraint>"]},{"entry":["constraint","\u201c(\u201c [SP] <offset> SP <num_inject> [SP] <inject_list> [SP] \u201c)\u201d"]},{"entry":["offset","The starting injection address is the base address of the DLL or other"]},{"entry":[{},"library plus the offset."]},{"entry":["num_inject","The count of inject units in inject_list. The number of inject units has to"]},{"entry":[{},"be less than 256."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Regarding the following entries, the inject units, e.g., constraint code segments, of the"},{"entry":"inject list will be inserted sequentially in to the program. Thus, the control flow through"},{"entry":"the last instruction of a inject unit will reach the first instruction of the next unit. After"},{"entry":"executing the last instruction in the last inject unit, the first instruction of the basic block,"},{"entry":"one at the address pointed by the offset, will be executed. Note that the addresses for the"},{"entry":"instructions are not specified and the instructions will be relocated by the MPEE."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["inject_list","<inject_list> [SP] \u201c<\u201d <inject> \u201c>\u201d | \u201c<\u201d <inject> \u201c>\u201d"]},{"entry":["inject","<instr_string> | <branch_instr> | <library_call> | <lea> | <frame_in> |"]},{"entry":[{},"<frame_out>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"The following entries provide a byte string of instructions. Canstandardize on little endian"},{"entry":"or big endian."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["instr_string","\u201cX\u201d <instr_pack>"]},{"entry":["instr_pack","A hexadecimal byte string of a list of non-control-transfer instructions."]},{"entry":[{},"No instructions that use PC offset are in the list."]},{"entry":["branch_instr","\u201cB\u201d <jump short> | \u201cB\u201d <jump absolute> | \u201cB\u201d <return>"]},{"entry":["jump_short","<js_opcode> <js_num>"]},{"entry":["js_opcode","A hexadecimal word of the opcodes of Jcc (Jump if Condition)"]},{"entry":[{},"instruction. Only the Jump Short instructions are supported. The valid"]},{"entry":[{},"opcodes are:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"JO","70","JS","78"]},{"entry":[{},"JB","72","JNS","79"]},{"entry":[{},"JNO","71","JP","7A"]},{"entry":[{},"JC","72","JPE","7A"]},{"entry":[{},"JNAE","72","JNP","7B"]},{"entry":[{},"JAE","73","JPO","7B"]},{"entry":[{},"JNB","73","JL","7C"]},{"entry":[{},"JNC","73","JNGE","7C"]},{"entry":[{},"JE","74","JGE","7D"]},{"entry":[{},"JZ","74","JNL","7D"]},{"entry":[{},"JNE","75","JLE","7E"]},{"entry":[{},"JNZ","75","JNG","7E"]},{"entry":[{},"JBE","76","JG","7F"]},{"entry":[{},"JNA","76","JNLE","7F"]},{"entry":[{},"JA","77","JCXZ","E3"]},{"entry":[{},"JNBE","77","JECXZ","E3"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["js_num","Two bytes in hex format. The integer identifies a constraint from the"]},{"entry":[{},"cons_list. The constraints are numbered implicitly from 0 upwards in"]},{"entry":[{},"the order they are in the constraint list. This number is translated to the"]},{"entry":[{},"correct relative address so that the branch will take the control to the"]},{"entry":[{},"beginning of that constraint."]},{"entry":["jump_absolute","Byte string of a JMP (jump) instruction with absolute address given in"]},{"entry":[{},"an operand. The valid instructions are"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"JMP ptr16:16","EA cd"]},{"entry":[{},"JMP ptr16:32","EA cp"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["return","Byte string of one of the return instructions:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"RET","C3"]},{"entry":[{},"RET","C2XX"]},{"entry":[{},"RET","CAXX"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"The following entries provide a mechanism to load the address of a global data item. Note"},{"entry":"that references to globals will need to use this restricted form to get the address."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["lea","\u201cL\u201d r32 data_num"]},{"entry":["r32","A one byte integer value that select one of the 32-bit registers."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"EAX","0"]},{"entry":[{},"ECX","1"]},{"entry":[{},"EDX","2"]},{"entry":[{},"EBX","3"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["data_num","Two bytes in hex format. The integer identifies a data item from the"]},{"entry":[{},"glob_list. The data are numbered implicitly from 0 upwards in the order"]},{"entry":[{},"they are in the glob_list. This number is translated to the correct"]},{"entry":[{},"relative address so that the load effective address will load the"]},{"entry":[{},"beginning address of the assigned location for the data."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"The following two pseudo instructions create a new frame for the constraint instructions to"},{"entry":"use and restore the application frame. \u201cFrame in\u201d will switch the stack to the internal DR"},{"entry":"stack and save the original registers and arithmetic flags (but not the floating point"},{"entry":"context). \u201cFrame out\u201d restores the original application frame, and restores the registers"},{"entry":"and the arithmetic flags to the state when the frame_in was called. Only a single frame_in"},{"entry":"can be issued within a constraint. When frame_in is issued, it requires a single invocation"},{"entry":"of frame_out before giving control back to the application. Note that this cannot be done"},{"entry":"as a library call since library calls require a usable stack."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["frame_in","\u201cFI\u201d"]},{"entry":["frame_out","\u201cFO\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"The following instructions invoke a library routine from the constraint injection support"},{"entry":"library. The call frame setup and breakdown is similar to the normal C calling convention."},{"entry":"Thus, in order to call a library function, a new frame needs to be present."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["library_call","\u201cC\u201d library_num"]},{"entry":["library_num","Two bytes in hex format. The integer identifies the library routine to be"]},{"entry":[{},"invoked."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Combining the information provided in the constraint descriptor with the current machine state (e.g., version of the OS, application, libraries loaded, etc.), current threat landscape, information on other related constraints and user instructions, the constraint injection system can decide which applications the constraint should be injected into, and when to perform that task. The filtering of the constraints for a given application can be performed using the following information\/criteria:\n\n","The constraints can be created by an appropriate vendor, as discussed previously in connection with . Users who wish to deploy the constraints, using a central management console, download the constraints and manage them, as discussed in connection with . The controller  interfaces with a node manager at each server. The node manager in turn interfaces with the core constraint injection system that runs on the protected applications. Using the controller, the users have the ability to manage the system at the granularity of a constraint and obtain information on the status and effectiveness of each constraint. The user is able to dynamically turn a constraint on and off, and to put a constraint into a detect or protect mode, as discussed previously. The user is also provided with the deployment status and statistics on each constraint. This feedback information can include:\n\n","Each violation detected by the constraint or an error detected by the constraint injection system can generate an event to an event log. It is also possible to generate a forensics file for further analysis.","13. Constraint Injecting and Flushing","Once a patch point has been identified, the injection takes place. The code injected can save the application's stack, switch to the constraint stack, push all of the application's registers on to the stack and start constraint execution. After constraint execution, the application registers and stack are restored, and the control flow resumes at the actual instruction at the patch point. After the injection is completed, and before the constraint is executed, \u201cconstraint_reset_function\u201d is invoked to set up a state required by the constraint.","Bookkeeping, such as status, statistics, violation reporting, etc., can be done for each constraint, so that the constraints execution can be wrapped in a sandbox. This can be done using a gateway function or a prologue-epilogue function pair, for instance. The advantage of using a gateway is that only the call to the gateway can be injected at the call site. However, this means that the constraint (both the remediator and detector) can be invoked with a function pointer inside the constraint injection system, which is considered to be a security hazard. This problem can be overcome using a prologue-epilogue function pair. That is, at the call site, inject a call to a prologue function, then a call to the detector, then to the remediator and then to the epilogue along with control flow logic as needed. However, one drawback is that a large amount of code has to be injected for a given patch point. If the security issue with the gateway model can be resolved (using write protection for core text or doing a target validation before calling it), that model should be favored.","If more than one constraint needs to be applied at a point, the \u201cprecedence\u201d (Table 2) is used to determine the order of injection. Note that each constraint does not get a new clean set of application registers. There will be only one set. If an earlier constraint modifies it, then the subsequent constraint can see the change. Otherwise, the remediation offered by an earlier constraint will be lost. The constraint can be designed to handle this situation.","The atomicity of injection can be at the \u201cvulnerability\u201d level, not \u201cpolicy\u201d level, e.g., if all modules required by at least one \u201cset\u201d in a \u201cvulnerability\u201d are satisfied, then its constraint will be injected even if other \u201cvulnerabilities\u201d in the same \u201cpolicy\u201d aren't ready. If injection isn't done at this level, then a \u201cvulnerability\u201d can be exposed until others in its \u201cpolicy\u201d are ready to be patched, which defeats the purpose of constraint injection.","Another dimension of atomicity is whether to inject the constraint as each DLL matches or wait until all DLLs required are matched for a given \u201cvulnerability\u201d, when the libraries are DLLs. Injecting when all DLLs are matched for a given \u201cvulnerability\u201d is logical from an atomicity point of view. However, if one DLL is loaded early and matches, and another DLL is loaded later in the execution, the security hole in the first DLL will be unpatched until the second DLL is loaded. This can be handled by creating another \u201cvulnerability\u201d for the same policy with a different \u201cset\u201d. Thus, both the inject-as-you-load and the inject-after-all-are-loaded approaches have merits and demerits.","Unlike injecting, flushing happens only at a \u201cpolicy\u201d level. Flushing means that the fix offered by a policy is being removed, which means for all its \u201cvulnerabilities\u201d. A \u201cpolicy\u201d can be flushed under one of the following circumstances:\n\n","Immediately after flushing, \u201cconstraint_reset_function\u201d is invoked to clear up a constraint state.","14. Constraint\u2014Information Verification","As constraint information will be transmitted from the constraint developer to the customer site and eventually to the core of an application, verifying the integrity of the information at the customer site is key to prevent problems due to tampering.","First, the transmitted XML file, e.g., descriptor file, should be verified by the CME . Signed certificates can be used to communicate with the constraint developer's web site, for instance, to download the XML file. Once the file is obtained, it can be verified using the \u201cxml_file_signature\u201d (Table 2).","Second, the integrity of the constraint library transmitted should be verified. For each \u201cconstraint_dll\u201d, in a \u201cpolicy\u201d, there exists a \u201cconstraint_dll_hash\u201d. Using this hash value, the core can validate a constraint library. A verification failure will result in an event being logged.","15. ABI of the Constraint Library","Since constraints should have a minimal impact on the application and its availability, what goes into a constraint library can be highly restricted to avoid an adverse impact on a live application. For example, the following restrictions or set of rules can be imposed on the constraints using an ABI:\n\n","Each detector can be called with one argument, namely a pointer to a context structure. Macros can be provided to the constraint writer to read and write to the application's registers using this pointer. Each detector can return one of the following status codes:\n\n","The following additional restrictions or set of rules can be imposed on the detector using an ABI:\n\n","A program analysis tool can be used to check and enforce these guidelines during constraint development. However, the guidelines are not absolute rules. In those rare occasions when no other option is available, these guidelines can be ignored. But, it should be done after much consideration, approval from an oversight team and a lot of quality assurance. Note that byte code based constraints can make the task of enforcing these ABI restrictions simple and make it possible to validate the ABI in the constraint injection system.","17. ABI of the Remediator","Each remediator can be called with the two arguments. The first is the same as for the detectors, which is used by the remediator to read and write to application registers (unlike the detector which can only read). The second is a pointer to a buffer of fixed size which can be used by the remediator to provide information that can be written to the event log. The remediator can perform one or more of the following:\n\n","The following additional restrictions or set of rules can be imposed on the remediator using an ABI:\n\n","The execution of a constraint can result in an infinite loop or access violation exception (due to dereferencing NULL, invalid or protected memory). The constraint injection system need not deal with infinite loops; instead, the constraint writer can deal with it at constraint creation time as an ABI restriction.","In the case of an access violation, a constraint injection system's exception handler can identify the exception to be related to a constraint, terminate the constraint execution and return to the gateway\/prologue-epilogue function with the appropriate status code and let the reminder of the cleanup and bookkeeping be done by that function.","19. Functions Called by the Constraints","The detector and remediator ABIs allow the detector and remediator, respectively, to call a predefined set of support functions, including functions belonging to the following classes:\n\n","Care should be taken when the functions change the application-visible state to avoid a program crash. Functions called by the detector have further restrictions such as avoiding modifications to any application-visible state.","20. Using the Managed Program Execution Core","The Managed Program Execution Core in the Memory Firewall\u2122 product, available from Determina Corp., Redwood City, Calif., provides a suitable substrate to implement a constraint injection system. Since the core creates a code cache and executes all instructions through the cache, it is possible to insert any instruction sequence at an arbitrary address. The code cache creation process allows for atomic insertions and deletions of constraints. It also provides the basis for sandboxed execution of the constraints. The core also has the mechanisms to provide input-output (I\/O) and memory management functions minimally visible to the application. However, the use of this product is an example implementation only as other implementations are also possible.","21. Supported Applications Classes","It is difficult, if not impossible, to provide customized constraints for every application used by all customers. This would require having thousands of installations and quality assurance support. Furthermore, application customization and multiple versions can make this task even more difficult. To simplify matters, applications can be divided into three categories.","21a. Applications Available at the Constraint Development Lab (e.g., the Security Laboratory)",{"@attributes":{"id":"p-0155","num":"0000"},"ul":{"@attributes":{"id":"ul0023","list-style":"none"},"li":{"@attributes":{"id":"ul0023-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0024","list-style":"none"},"li":["The constraint developer has the full knowledge of the application\n        \n        ","Constraints are built to fix the specific vulnerability in the application","Examples: Microsoft Windows\u00ae services, Internet Information Services (IIS) (a Microsoft\u00ae web server), and Oracle\u00ae database software.\n\n21b. Applications Accessible by the Constraint Developers\n","The constraint developer uses the application for one-time analysis","Validation\/Interception points are built by analyzing the application\n        \n        ","Examples: PeopleSoft enterprise application software, Siebel business application software, WinZip compression utility, and IIS version-1.\n\n21c. Applications Never Seen by the Constraint Developers\n","No knowledge of the application","Only Generic API Interception or custom libraries","Examples: Foobar FTP server, custom applications.\n\n22. Example Constraint Code\n"]}}}},"The following provides an example of constraint code for a constraint that protects against the vulnerability announced by Microsoft in their security bulletin MS03-007. This is an unchecked buffer vulnerability that can lead to a total system compromise in IIS due to the use of a long file name. Further details can be found at http:\/\/www.microsoft.com\/technet\/security\/bulletin\/MS03-007.mspx. After analyzing the vulnerability, the constraint developer produces a constraint.  provides the source code (detector and protector functions) of the constraint. The vulnerability relates to the use of a long file name. As indicated, the patch point is right before a call to the function RtlInitUnicodeString, which is a function that truncates a Unicode string's length to 16 bits integer.  provides a disassembly of the code in NTDLL.DLL where the constraint is applied. NTDLL.DLL is a core operating system component used to interact with the Windows\u00ae kernel. There is a simple vulnerability in this code. The length of the argument is not checked against the maximum possible length of a file name, creating an opportunity for a buffer overflow attack. Thus, a constraint as described above is injected to check the length before calling the function RtlInitUnicodeString.  provides an XML file that is produced and shipped to customers. The XML file provides the information needed to identify the need for a constraint and deploy the constraint to the Central Controller at the customer site. It provides information for the customer, identifying which vulnerability is protected, information on when and where to deploy the constraint and information about detector and protector functions provided.","23. Standalone Framework for Constraint Injection","Another embodiment of constraint injection involves using a standalone framework that loads and inject the constraints directly into the application memory without using a code cache. In this approach, when a protected application is started, a special DLL or other library that manages constraints is loaded. This library implements a routine that the Constraint Management Engine (CME) can invoke when a change to the set of constraints or change to the deployment has occurred. This can be done in two ways. One method is by inserting hooks (or callbacks) onto the application's regular control-flow so that when the application executes it will invoke a DLL or other library routine on a regular basis. Another method is to use special operating system mechanisms to invoke a routine in the application from an external call from the CME.","When the constraint manager routine of the DLL or other library is invoked, it will check with the CME regarding which constraints should be applicable to the application. This will occur either at the startup or when CME provides a notification that there is a change or when a new library is loaded. At startup, all active libraries loaded into the memory are scanned and that version information is matched with the list of constraints given by the CME. When the CME provides a notification of a change to the list, again that active library list is checked against the updated constraint list provided by the CME. The loading of a new library is detected by hooking the loading process. When this hook is invoked, it will check the new library against the constraint list provided by the CME. A new constraint can be installed or an active constraint is deactivated using the following mechanism.","First, it is desirable to guarantee that all the threads that are executing in the address space are at a safe point which allows modify of the memory image without creating race conditions. One way to enforce this is to suspend all the threads and check the program counter location on which the threads were suspended. If the program counter is at an unsafe location, then that thread is resumed and allowed to reach a safe point at which it is suspended again. Or, the current program counter can be relocated to the constraint gateway. It is desirable to ensure that this process is safe with respect to the loader modifying the application image since the loader may modify the memory image of the library. This can nominally be done by waiting until the loader finishes the modifying of the memory. An alternative method to enforcing safety without suspending all threads is to make sure that modifications to the memory image can coexist with execution of that region. This can be achieved, e.g., by using atomic updates if the instruction inserted is small, or by first atomically inserting a few instructions which will generate a fault if they are executed and then changing the needed instructions from the bottom-up. If a thread reaches the modification region while it is being modified, it will throw an exception, which can be caught. When an exception is caught, the thread is stopped until the injection is over.","Second, the constraint can be loaded into the memory if it is not already loaded into the memory image. This can be done by using the loader, if the constraint is given as a regular DLL or other library, or by copying the constraint instructions into the memory using a custom loader.","Next, each patch point is examined to ensure that it conforms to the specification of the patch point. In this case, the patch point should have the following eight additional restrictions listed below, in one example implementation.","1. A patch point specifies the address where the constraint is injected into the application code. The patch point must always be at an instruction boundary. The five bytes after the patch point are called a \u201cpatch region\u201d and will be overwritten during constraint injection. The bytes taken by the instructions that start in the patch region are known as the \u201cextended patch region\u201d. If the last instruction in the patch region extends past the end of it, the expended patch region will be greater than five bytes. For example, see Table 5.",{"@attributes":{"id":"p-0163","num":"0251"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["text: 767A6E1C 50","push","eax",{}]},{"entry":["text: 767A6E1D 64 89 25 00 00 00 00","mov","large","fs: 0, esp"]},{"entry":["text: 767A6E24 51","push","ecx"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"If the patch point is 767A6E1C, the patch region will cover five bytes from address 767A6E1C to 767A6E21. The extended patch region will cover eight bytes from address 767A6E1C to 767A6E23.","2. None of the bytes in the patch region can be a target of a control transfer instruction anywhere in the program.","3. None of the instructions that end in the first four bytes of the patch region can be a CALL or a non-conditional JMP instruction. It is acceptable for a CALL or JMP instruction to end at the last byte of the patch region.","4. None of the bytes in the patch region can be read anywhere in the program.","5. None of the bytes in the extended patch region can be written anywhere in the program.","6. None of the instructions that start in the patch region can be an INT or an INT3 instruction.","7. As a consequence of restriction #4, the extended patch region must not include any relocations.","8. The patch region must not cross a thirty-two byte cache line boundary (only required if using atomic injection).","Before proceeding with the injection, we calculate the validity of the patch point by computing a hash function of the instructions in the vicinity of the patch point. However, if another constraint was injected within the vicinity, then the computation of the hash function needs to utilize the original instructions that were moved to the constraint gateway.","Next, the patch point in the application memory is modified to insert a control transfer instruction to the constraint gateway. Before the modification occurs, the application instruction(s) at the patch point are copied to the constraint gateway so they will get executed before (or after) the constraint is executed. However, if the instructions that are copied over are control transfer instructions that have relative addressing, the address has to be modified. This may require expansion of the relative address size.","If the constraint being injected requests control flow transfer to another location as one of its remediation actions, and if that location is already patched with a different constraint, then the control flow transfer is modified to go directly to that constraint. Furthermore, if any other active constraints require control flow transfers to the patch point of the current constraint, these transfers are also modified to go to the constraint directly.","The system also intercepts any memory protection to make a read-only page writable. The constraints are removed, and when the page is made executable again, the injection process is performed again.",{"@attributes":{"id":"p-0176","num":"0264"},"figref":["FIG. 12","FIG. 3"],"b":["1100","1120","1100","1120","1100","1101","1102","1103","1104","1105","1110","1111","1112","1113","1120","1121","1101","1104","1122","1125","1110","1112","1126","1103","1105","1111","1113"]},"Two gateways can be called from the modified program  via trampolines provided by code fragments  and . The gateway for the call to CME  includes a code fragment  with a save context instruction , a call CME instruction , a restore context instruction , the instruction Y , and a back to program instruction . Instruction Y  can be executed before or after instruction . A control flow is transferred from the gateway  to the CME  at the instruction . The control flow returns to the gateway  from the CME  for executing the restore context instruction , for example. The gateway for the patch point  includes a code fragment  with a save context instruction , a call detector and remediator instruction , a restore context instruction , the instruction C , and a back to program instruction . A control flow is transferred from the gateway  to the libraries  at the instruction . The control flow returns to the gateway  from the libraries  for executing the restore context instruction , for example.","The CME , external interface for managing constraints , constraint libraries , including detector , remediator  and descriptor  libraries, and the predefined support functions library , are comparable to their namesakes in , described previously.","At a patch point, an instruction of the code fragment  is rewritten to provide the code fragment  which includes a call, via the go to gateway instruction , to the custom gateway for the patch point . The saving and restoring is performed on the gateway for the patch point . In particular, the application context is saved at instruction . The detector  and remediator  libraries are called at instruction . The control flow is returned to the gateway  so that the application context is restored at instruction . Instruction C  is also called, before or after instruction . The control flow then returns back to the program at instruction . In particular, the control flow can return to instruction D  of the modified program , for instance.","Note that the instructions that were overwritten are copied to the gateways. In particular, instruction C , which was overwritten by the go to gateway instruction , was moved to the gateway for the patch point , and instruction Y , which was overwritten by the go to gateway instruction , was copied to the gateway for the call to the CME . In order to change the control flow to the CME , trampolines are inserted in the commonly executed paths , as indicated by code fragment . The external interface for managing the constraints  can also call the CME . Thus, as the code fragment  of the program executes, the control flow is transferred to the gateway  for calling the constraint libraries . As the code fragment  executes, the control flow is transferred to the gateway  for invoking the special DLL or other library that manages the constraints, such as by installing a new constraint, deactivating an active constraint, detecting the loading of a new library by the computer program, and determining which constraints are applicable to the computer program.","The present invention can be accomplished using hardware, software, or a combination of both hardware and software. The software used for the present invention is stored on one or more processor readable storage devices including hard disk drives, CD-ROMs, DVDs, optical disks, floppy disks, tape drives, RAM, ROM, flash memory or other suitable storage devices. In alternative embodiments, some or all of the software can be replaced by dedicated hardware including custom integrated circuits, gate arrays, FPGAs, PLDs, and special purpose processors. In one embodiment, software implementing the present invention is used to program one or more processors. The processors can be in communication with one or more storage devices, peripherals and\/or communication interfaces.","The foregoing detailed description of the technology herein has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the technology to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. The described embodiments were chosen in order to best explain the principles of the technology and its practical application to thereby enable others skilled in the art to best utilize the technology in various embodiments and with various modifications as are suited to the particular use contemplated. It is intended that the scope of the technology be defined by the claims appended hereto."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4","i":"a "},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4","i":"b "},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 10","FIG. 9"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
