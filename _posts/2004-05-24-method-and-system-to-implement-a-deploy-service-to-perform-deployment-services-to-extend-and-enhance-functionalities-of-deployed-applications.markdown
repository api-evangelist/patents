---
title: Method and system to implement a deploy service to perform deployment services to extend and enhance functionalities of deployed applications
abstract: A system and method are described for implementing and using a deploy system for deployment of entities. In one embodiment, a deploy service is implemented as a module on a J2EE engine to perform deployment services on a container on the J2EE engine. The deployment services include deploying one or more entities on the container which includes a J2EE container and/or a non-J2EE container.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07735097&OS=07735097&RS=07735097
owner: SAP AG
number: 07735097
owner_city: Walldorf
owner_country: DE
publication_date: 20040524
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","This invention relates generally to the field of deployment. More particularly, an embodiment relates to implementing and using a deploy system to facilitate deployment of entities and expansion of a Java 2 Enterprise Edition architecture (J2EE).","2. Description of the Related Art","Traditional client-server systems employ a two-tiered architecture such as that illustrated in . Applications  executed on the client-side  of the two-tiered architecture are comprised of a monolithic set of program code including a graphical user interface (GUI) component, presentation logic, business logic and a network interface that enables the client  to communicate over a network  with one or more servers . A database  maintained on the server  provides non-volatile storage for the data accessed and\/or processed by the application .","As is known in the art, the \u201cbusiness logic\u201d component of the application represents the core of the application, i.e., the rules governing the underlying business process (or other functionality) provided by the application. The \u201cpresentation logic\u201d describes the specific manner in which the results of the business logic are formatted for display on the user interface. The \u201cdatabase\u201d  includes data access logic used by the business logic to store and retrieve data.","The limitations of the two-tiered architecture illustrated in  become apparent when employed within a large enterprise. For example, installing and maintaining up-to-date client-side applications on a large number of different clients is a difficult task, even with the aid of automated administration tools. Moreover, a tight coupling of business logic, presentation logic and the user interface logic makes the client-side code very brittle. Changing the client-side user interface of such applications is extremely hard without breaking the business logic, and vice versa. This problem is aggravated by the fact that, in a dynamic enterprise environment, the business logic may be changed frequently in response to changing business rules. Accordingly, the two-tiered architecture is an inefficient solution for enterprise systems.","In response to limitations associated with the two-tiered client-server architecture, a multi-tiered architecture has been developed, as illustrated in . In the multi-tiered system, the presentation logic , business logic  and database  are logically separated from the user interface  of the application. These layers are moved off of the client  to one or more dedicated servers on the network . For example, the presentation logic , the business logic , and the database  may each be maintained on separate servers, ,  and , respectively.","This separation of logic components and the user interface provides a more flexible and scalable architecture compared to that provided by the two-tier model. For example, the separation ensures that all clients  share a single implementation of business logic . If business rules change, changing the current implementation of business logic  to a new version may not require updating any client-side program code. In addition, presentation logic  may be provided which generates code for a variety of different user interfaces , which may be standard browsers such as Internet Explorer\u00ae or Netscape Navigator\u00ae.","The multi-tiered architecture illustrated in  may be implemented using a variety of different application technologies at each of the layers of the multi-tier architecture, including those based on the Java 2 Platform, Enterprise Edition\u2122 standard, the Microsoft NET standard and\/or the Advanced Business Application Programming (ABAP) standard developed by SAP AG.","For example, in a J2EE environment, such as the one illustrated in , the business layer  is to handle the core business logic of the application having Enterprise JavaBean\u2122 (EJB or enterprise bean) components with support for EJB containers . While the presentation layer  is responsible for generating servlets and Java ServerPages\u2122 (JSP or JSP pages) interpretable with support for Web containers  by different types of browsers at the client  via a web server  a network  (e.g., Internet or intranet).","The J2EE engine  is a tool commonly used in software development and deployment today. Generally, using the J2EE engine  reduces the costs and complexity associated with developing multi-tier enterprise services. Another advantage of J2EE engine  is that it can be relatively rapidly deployed and enhanced as the need arises. J2EE engine  is currently used in many large-scale application development and deployment projects for these reasons.","However, as application development projects grow larger and are diversified, deployment of applications becomes increasingly important. For example, it is useful to have an improved deployment service and management, including a variety of containers, application interfaces, transaction management and modules, notification and information status system, resource pooling, and security checks.","A system and method are described for implementing and using a deploy system for deployment of entities. In one embodiment, a deploy service is implemented as a module on a J2EE engine to perform deployment services on a container on the J2EE engine. The deployment services include deploying one or more entities on the container which includes a J2EE container and\/or a non-J2EE container.","Described below is a system and method for implementing and using a deploy service. Throughout the description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the embodiments of the present invention. It will be apparent, however, to one skilled in the art that the present invention may be practiced without some of these specific details. In other instances, well-known structures and devices are shown in block diagram form to avoid obscuring the underlying principles of the present invention.","In the following description, numerous specific details such as logic implementations, opcodes, resource partitioning, resource sharing, and resource duplication implementations, types and interrelationships of system components, and logic partitioning\/integration choices may be set forth in order to provide a more thorough understanding of various embodiments of the present invention. It will be appreciated, however, to one skilled in the art that the embodiments of the present invention may be practiced without such specific details, based on the disclosure provided. In other instances, control structures, gate level circuits and full software instruction sequences have not been shown in detail in order not to obscure the invention. Those of ordinary skill in the art, with the included descriptions, will be able to implement appropriate functionality without undue experimentation.","Various embodiments of the present invention will be described below. The various embodiments may be performed by hardware components or may be embodied in machine-executable instructions, which may be used to cause a general-purpose or special-purpose processor or a machine or logic circuits programmed with the instructions to perform the various embodiments. Alternatively, the various embodiments may be performed by a combination of hardware and software.","Various embodiments of the present invention may be provided as a computer program product, which may include a machine-readable medium having stored thereon instructions, which may be used to program a computer (or other electronic devices) to perform a process according to various embodiments of the present invention. The machine-readable medium may include, but is not limited to, floppy diskette, optical disk, compact disk-read-only memory (CD-ROM), magneto-optical disk, read-only memory (ROM) random access memory (RAM), erasable programmable read-only memory (EPROM), electrically erasable programmable read-only memory (EEPROM), magnetic or optical card, flash memory, or another type of media\/machine-readable medium suitable for storing electronic instructions. Moreover, various embodiments of the present invention may also be downloaded as a computer program product, wherein the program may be transferred from a remote computer to a requesting computer by way of data signals embodied in a carrier wave or other propagation medium via a communication link (e.g., a modem or network connection).",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 2","b":["200","200","200","210","220","230","210","220","230","200","200"]},"The distributed services level  serves as an interface between the JMA  and one or more users or clients. As illustrated, the distributed services level  includes one or more user terminals -. One or more of the user terminals - to collect and gather user input and send it to the agent level  over a network connection. Network connection may be a wired or wireless connection to a LAN, a Wide Area Network (WAN), a Metropolitan Area Network (MAN), an intranet, and\/or the Internet. Distributed services level terminals - include personal computers, notebook computers, personal digital assistants, telephones, and the like. According to one embodiment in which the network connection connects to the Internet, one or more of the user terminals - may include a Web browser (e.g., Internet Explorer or Netscape Navigator) to interface with the Internet.","According to one embodiment, the distributed services level  also includes management applications , such as a JMX-compliant management application, a JMX manager, and\/or a proprietary management application. The management applications  also include one or more graphical management applications, such as a visual administrator, operating to, for example, retrieve and display information received from the agent level  and\/or the instrumentation level .","The visual administrator includes a monitor viewer to display such and other information. The monitor viewer may be GUI-based or Web-based monitor viewer. Management applications  may include third party tools including a file system to store the information. The distributed services level  includes the CCMS system described above.","The agent level  includes one or more application servers -. An application server may refer to a computing device that performs data processing. The agent level  also includes a computing device (e.g., a dispatcher) to perform load balancing among application servers -. According to one embodiment in which the agent level  exchanges information with the distributed services level  via the Internet, one or more of the application servers - include a Web application server. According to one embodiment, the application servers - are implemented in accordance with J2EE v1.3, final release Sep. 24, 2001, published on Jul. 18, 2002 (the J2EE Standard). An update of J2EE v1.3 was recently released, on Nov. 24, 2003, as J2EE v1.4. In one embodiment, the management techniques described herein are used to manage resources within a \u201ccluster\u201d of server nodes. An exemplary cluster architecture is described below with respect to . However, the underlying principles of the invention are not limited to any particular application server architecture.","The applications servers - may include one or more dedicated Java Managed Bean (MBean or managed bean) servers having agent services. According to one embodiment, for and at each Java virtual machine (JVM) with managed resources, there may be one or more agents operating at the agent level . The one or more agents include one or more MBean servers, agent services, a set of MBeans, one or more connectors, and\/or one or more protocol adaptors. An MBean Server includes a registry for MBeans and acts as a single entry point for calling MBeans in a uniform fashion from management applications at other JVMs.","The instrumentation level  provides a data storage medium for the JMA . As illustrated, according to one embodiment, the instrumentation level  includes one or more database management systems (\u201cDBMS\u201d) - and data sources -. According to one embodiment, the data sources - may include databases and\/or other systems capable of providing a data store. Furthermore, the instrumentation level  includes one or more hosts including one or more resources having MBeans, such as instrumentation MBeans. The instrumentation level  may make Java objects available to management applications . The Java objects instrumented according to the JMX-standard may include MBeans. The resources represented by MBeans include managed resources , including a kernel, a server component, or the like. MBeans may expose a management interface including constructors, attributes, operations, and notifications.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 3","b":["300","314","304","306","328","340","342","300","314","304","306","350","350","314","304","306","348","320","306","348","324"]},"The J2EE containers - and the client application  are, directly or indirectly, in communication with the database , located at the Enterprise Information Systems (EIS) tier  of the multi-tiered J2EE architecture . The database  may include one or more database servers, EJB servers, old systems, and mySAP components. The client application  may include standard a J2EE application to help facilitate the running of applications in standalone JVMs. Furthermore, the clients may access one or more of the applications via standalone Java programs and programs that help access an application via, for example, using Internet Inter-Object Request Broker Protocol (IIOP)\/Common Object Request Broker Architecture (COBRA) written using any programming language (e.g., \u2212C, C, and C++).","The J2EE containers - in the middle tier  are associated with various J2EE services and APIs , examples of which, include Java Naming Directory Interface (JNDI), Java Database Connectivity (JDBC), J2EE connector Architecture (JCA), Remote Invocation (RMI), Java Transaction API (JTA), Java Transaction Service (JTS), Java Message Service (JMS), Java Mail, Java Cryptography Architecture (JCA), Java Cryptography Extension (JCE), and Java Authentication and Authorization Service (JAAS), and dbpool service. The J2EE services  further include EJB_service, servlet_JSP, application_client_service, connector_service to provide (J2EE containers -, namely) EJB containers, Web containers, application client containers, and connector containers, respectively. It is contemplated the client application  may also be associated with a set of J2EE services and APIs . However, each of the containers - may be associated with a different set of J2EE services. For example, on the client tier , the client application may be associated with different J2EE services  than the J2EE containers - associated with the J2EE services  on the server-side . Furthermore, the client-side  may or may not be J2EE-based.","According to one embodiment, as illustrated, the J2EE server  includes a non-J2EE container  and a set of non-J2EE services and interfaces . An example of a non-J2EE container  and non-J2EE services  may include an SAP container and a set of SAP services and APIs, respectively. The non-J2EE services  include Webdynpro service, log_configurator service, and monitoring service. According to one embodiment, non-J2EE components deployed in the non-J2EE container  may be used to assemble non-J2EE applications (e.g., SAP applications). In one embodiment, the management of the non-J2EE applications is performed during and after deployment, while the assembly of the non-J2EE applications is conducted prior to deployment. According to one embodiment, both the J2EE and non-J2EE containers -,  may have access to the J2EE and non-J2EE services -.","According to one embodiment, some of the non-J2EE services  may include parallel or similar services to the J2EE services . The container API may be used to facilitate registration, unregisteration, implementation, and management of not only the J2EE containers -, but also one or more non-J2EE containers  on the J2EE server . Using a common container API, both the standard J2EE containers - and the non-J2EE containers  may be deployed on the server-side , and the J2EE server , as whole, regards them as the same. Stated differently, when deploying a non-J2EE container , the specific details in the implementation and logic of the non-J2EE container  may be kept hidden from the J2EE server  so all J2EE and non-J2EE containers -,  are to be recognized and regarded the same way as part of the J2EE architecture .","The container API, according to one embodiment, is encapsulated in a service -. This is to, for example, expand the J2EE architecture  to provide a relatively easy implementation and deployment of services, interfaces, and libraries, and to provide one or more non-J2EE containers , which in turn can deploy any non-J2EE components with relative ease using the same infrastructure. The container API may be represented by an interface defined as a development component with the name, e.g., <container_api>. The implementation of container API may be performed using the deploy service.","According to one embodiment, the deploy service may be used as an entry point for extending the J2EE architecture  and for enhancing the functionality of the J2EE engine  by deploying the non-J2EE containers  along with the J2EE containers -. The deploy service may also be used for the deployment of applications, standalone modules (containing both J2EE and non-J2EE components), service, and libraries.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 4","b":["400","404","406","402","402","404","406","404","416","406","418","406","418"]},"The J2EE architecture  further includes connectors  to provide standard services and APIs to connect the J2EE server  and its elements with the rest of the J2EE architecture . The connectors  may be J2EE or non-J2EE based. The J2EE architecture  also includes a JVM  to process platform-independent bytecode into platform-specific native code or binary machine code at runtime. The binary machine codes is executed on a hardware  using an operating system . The operating system  may include Microsoft Windows\u00ae, Macintosh, Unix, Linux, and the like. The hardware  may include a computer processing unit, a storage device, a random access memory, and the like.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 5","b":["500","524","524","500","524","518","514","516","510","512","518"]},"Serving as an entry point for expanding and enhancing the J2EE architecture , the deploy service  is also used for correct distribution of the deployable entities to their services\/containers and a storage place. The storage place is retrieved from configuration manager in the database and the deploy service  is to facilitate the storage of all applications so that the containers - may rely on a consistent storage for the entire application. The application components - and standalone modules are managed by the containers -, the libraries, services, and interfaces are managed by server's deploy context, which is located at a deeper level in the core of the server because these deployable components are used by applications - found on a higher level in the J2EE architecture . Stated differently, deploy service  is used to manage an entire application -, the container - is used to manage the applications' components -, and the deploy context is used to manage the server components, such as the libraries, services and interfaces. According to one embodiment, the deploy service  may obtain the deploy context using its application service context.","According to one embodiment, the container API  provides a container interface  that is implemented by container services associated with the containers - (e.g., <com.sap.engine.services.deploy.container.ContainerInterface>). Such implementation is to facilitate the deploy service  to identify and process various actions on those containers - that are implemented according to a set of rules including the implementation of the container API  by container services. A container service may listen for the availability of the container interface by implementing a container event listener (e.g., <com.sap.engine.frame.container.event.ContainerEventListener>).","The container API  provides a container management for registration of containers - by container services when an event indicating the availability of the container API  (e.g., <container_api>) is received or listened to by a container service via the container event listener. The container service may then register the container - using container management. In contrast, when a container - is rendered not available that container - is unregistered using the container management (e.g., <com.sap.engine.services.deploy.container.ContainerManagement>). Stated differently, the container services are provided with an opportunity to register their corresponding containers - with the container API  and the deploy service  when the containers - become available and are ready to perform deployment operations. In contrast, the containers - may be unregistered when once they stop or become unavailable.","According to one embodiment, the container API  also includes deploy communicator  in combination with the container interface . The availability of the deploy communicator  allows the deploy service  and the containers - to communicate bi-directionally. Stated differently, using the container interface , the information flows from the deploy service  to the containers -. Each of the containers - may obtain an instance of the deploy communicator  during its registration to communicate back with the deploy service .","Using the deploy communicator , the information may flow from the containers to the deploy service . Such information may include information relating to the status, requesting runtime information, initiating operations from containers -, etc., flowing back to the deploy service . Such information allows the deploy service  to be more efficient by, for example, allowing the containers - to request to lock the application or changes that may occur due to some property changes in the container -, or by having the deploy service  request the changes by update. Another example includes allowing a container - to stop its deployed applications in the container service stop method, since applications are usually consisting of more than one component and the deploy service  may know the entire configuration of an application.","According to one embodiment, the instance of container information (e.g., <container info>) including information for identification of a container - may have a set of properties with set\/get methods. Some of the properties include: (1) determination of whether a container - is a J2EE container  (e.g., EJB, Web, application, client, resource adapter) or a non-J2EE container  (e.g., SAP container); (2) for J2EE containers , specification of the type of the components  deployed (e.g., String j2eeModuleName); (3) for non-J2EE containers , specification of the type of the components  deployed (e.g., String moduleName); (4) for specification of the priority of a container - (e.g., when an application is being deployed, stopped, and started), the deploy service  knows in what order to notify the concerned containers -. During deployment and start of an application, the containers - having higher priority are notified first, and during stop of an application the containers - with lower priority are first notified (e.g., int priority); (5) specification of a container's unique name (e.g., String name); (6) specification of a set of extensions of files which represents components - deployed on the respective containers - (e.g., String [ ] fileExtentions); (7) specification of a set of names of files which represent components - deployed on the respective containers - (e.g., String [ ] filenames); (8) specification of the name of the service that provides the container (e.g., String serviceName); (9) determination of whether the container - supports the operation \u201csingle file update\u201d (e.g., Boolean supportsSingleFileUpdate); and (10) specification of the kind of resource types that are supported by the container (e.g., String [ ] resourceTypes).","According to one embodiment, filenames and extensions may be used by the deploy service  for distribution of the deployable components - on the containers -. The deploy service  may include a mechanism for automatic recognition of the container - to which the corresponding deploying components - may be distributed, in accordance with the filenames and extensions contained in the <container info> of each of the containers -. For example, if a standalone module file has an extension Web ARchive (e.g., WAR or war) and the J2EE Web container has specified this extension in its <container info>, the deploy service  may distribute a WAR file to the Web container.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 6","b":["600","616","600","602","604","602","604","610","612","604","606","606","604"]},"In the illustrated embodiment, the client  initiates the request  for starting the execution of deploy service operations with the server  via a deploy service API . The client  may include a deployer for performing configuration and deploying of various J2EE and non-J2EE modules on a specific product. In one embodiment, the process of deployment may include: (1) configuration; (2) distribution; and (3) execution. To perform configuration, the client , as a deployer, may follow the assembly instructions provided, for example, by the application assembler and help resolve any external dependencies declared by the application component provider. For distribution, the application archive and the deployment configuration information may be installed on various servers in the clusters via the deployment API . The execution includes a request  made by the client  with the deploy service  at the server  to start or propagate the deployment process.","The server , in response to the initiation request  from the client , propagates the deploy service. According to one embodiment, the deploy service  includes a module to accept applications on the server , distribute various components of the applications to containers, help manage the containers, facilitate control of the application life cycles and to synchronize them with the component life cycles deployed in the containers. Stated differently, the deploy service  is referred to as the entry point for extending and enhancing the functionality of the deployed applications, containers of the deployment architecture , and to extent and enhance the J2EE architecture as a whole.",{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 7","b":["700","704","708","704","708","712","716","702","704","708","712","716","712","716","742","746","704","702","740","702","704","748","706","708","712","706","708","714","716","706","708","704","702","704","706","704","708","704","708","712","716","704","708","712","704"]},"According to one embodiment, the client  places a request  with a server  via a deploy service API, using a deploy tool , to start the deploy service operations. The submitting of the request  triggers the propagating  of the deploy service operations at the server . In one embodiment, a cluster communication  may start between various servers - initiating from the server  receiving the request  from the client . Such cluster communication  facilitates deploy service propagation - of the deploy service - at all server nodes -. There may be further communication between deploy services, such as between deploy services -, and between other elements of the J2EE architecture .","According to one embodiment, the deploy service - performs distribution of a deployed application - in the cluster. The deploy service ,  further performs distribution of the deployed application's ,  components - in the containers - of the corresponding server nodes , . The management of the deployed applications - by the deploy services - may include maintaining consistent state of the applications - in the cluster, maintaining consistent state of the application components -, performing life cycle or deploy operations of the applications - (e.g., deploy, start, stop, update, and remove), performing transactional operations over the applications -, using the deploy callback system to notify the deploy listeners of the status information and events relating to the deployed applications - and their components -, and resolving the application references to all other components.","A deploy service - may be implemented as a module and may serve as an entry point for extending and enhancing the functionality of the servers - and the J2EE architecture  by maintaining and facilitating the deployment of a set of online components to the server, such as the applications -, standalone modules, libraries, interfaces and services. The deploy service - is also responsible for distribution of these deployable entities to their runtime managers. For example, the application components - and standalone modules are managed by the containers - that are implemented using the container API. The libraries, interfaces, and services, regarded as kernel components -, are managed by deploy context - at a deeper level in the core of the server -. The kernel components - are used by the applications ,  at a higher level in the J2EE architecture .","Stated differently, the deploy service - helps manage the applications -, the containers - help manage the application components -, and the deploy context - facilitates the management of server or kernel components -, such as libraries, interfaces, and services. A part of the container API may be used to administer the containers - and may be implemented using the deploy service -. Furthermore, the deploy service  as a module is used to collect the active containers - as they are registered. Each of the components - managed by their containers - are associated with an application  . For standalone modules, they may be associated with dummy applications (e.g., empty wrappers).","The deploy service -, according to one embodiment, may perform a transaction-oriented management of the applications -. For example, the deploy service - may use a persistent storage or a database  for storing the deployment state or status information relating to the deployment of the applications -. The operations, such as the deploy operations, being performed over an application - are transactionally recorded on to the database  in parallel with the logical transaction of such operations. In one embodiment, the container operations are regarded as part of the deploy service - and each operation being performed in the deploy service - having an equivalent in the container API. An operation, such as start, is regarded successfully completed if the corresponding containers - have completed the operation. The transaction relating to the completed operation is then committed (e.g., recorded) in the database . If the operation is incomplete in any of the container and is regarded as incomplete and is rolled back to a previous state. The transaction relating to the incomplete operation may not be committed to the database .",{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 8","b":["804","808","802","812","804","812","804","814","806","828","806","804","828","830","802","806","804","802"]},"According to one embodiment, at server A, using the deploy service at server A , a determination of additional servers in the cluster  is made. If there are no more servers in the cluster, the deploy service operations continue at server A. If there are other servers in the cluster, a notification  regarding initiating the deploy service operations is made to other servers, such as to the deploy service at server B . If the notification fails, an error  regarding the failure is sent to the client . With successful notification, the deploy service at server B , as with the deploy service at server A , initiates the deploy service operations  by sending a message to the container at server B via the container API at server B . As with server A, if the initiation of the deploy service operations is unsuccessful, a notification error regarding the failure to initiate may be sent from the container via the container API at server B  to the deploy service at server B  and then to the client . The deploy service operations are initiated  at server B and as the operations progress, status information  is sent from the container via the container API at server B  to the deploy service at server B . Based on the status information  received, the status result of the successful operations (or a status exception if an operation has failed)  is sent to the client .",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 9","b":["902","904","906","908","902"]},"In one embodiment, if there are other servers in a cluster to be notified, the notification relating to the initiation of the deploy service operations is given to other servers in the cluster by the server receiving the request from the client at processing block . The notification may be given to the deploy services at other servers in the cluster (e.g., from the deploy service on one server to the deploy service on other servers). Furthermore, the notification may be given using a deploy callback system. It is contemplated, each of the servers may have a corresponding deploy service in communication with deploy services at other servers, or a single deploy service may be used for some or all of the servers residing at the cluster.","At decision block , a determination is made as to whether the notification sent to other servers in the cluster was successful. If the notification was not successful at any of the servers, an error message is sent to the client at processing block . Stated differently, due a failure of notification to one or more servers or even due to the failure of one or servers to initiate the deploy service operations, the process of performing the deploy service operations at other successful servers is not stopped. Instead, an error is sent to the client about the failure of one or more servers. Other servers in the cluster may not know about the failure or the notification error. At processing block , in case of a successful notification or\/and after notifying the client via an error, the process of performing the deploy service operations continues at successful servers until the process is completed as described with reference to processing block . Once the operations are completed, the server waits for another request from the client at processing block .",{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 10","b":["1002","1010","1004","1010","1004","1012","1008","1012","1004","1012","1012","1008","1004","1014"]},"The deploy service , upon receiving the return notification  from the container via the container API , prepares for deploying  of the application. For deployment preparation , the deploy service may use the following method: <public void prepareDeploy(String applicationName, Configuration appConfig) throws DeploymentException, WarningException>. If the deployment preparation  is successful, the container  communicates back with the deploy service  with a response or notification  indicating the success. In one embodiment, the notification  may be communicated from various containers at various servers, via their corresponding container APIs, to the deploy service  or to the deploy services at their corresponding servers.","According to one embodiment, upon receiving the notification , the successful deployment status relating to any or all of the deploy service operations is then committed  to the container via container API . The status may also be committed  to a database  for performing transactional commitment of the state of deployment in addition to the logical commitment . The commitment  regarding the application deployment is performed by the deploy service  using, for example, the following method: <public void commitDeploy(String applicationName) throws WarningException>. In one embodiment, if a deployment exception is thrown or an error of some kind has occurred at anytime during the beginning  of deployment and receiving of the notification , the deployment may be stopped and\/or rolled back to the previous step. In one embodiment, if the transaction is not committed, the rolling back of the transaction is performed using, for example, the following method: <public void rollbackDeploy(String applicationName) throws DeploymentException>.","The deploy service  then provides a result  for a successful transaction or state of the application deployment to the client . If the transaction is unsuccessful (e.g., a rollback occurred), an exception or error  is provided to the client . In one embodiment, the deploy service  provides a notification  regarding the state of the transaction to one or more deploy services at their corresponding servers, such as the deploy service at server B . The notification  is provided by invoking, for example, the following method: <public void notifyDeployedComponents(String applicationName, Properties props) throws WarningException>. Such notification  is communicated via the deploy service API corresponding to the deploy service at server A  and the deploy service API corresponding to the deploy service at server B .",{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 11","b":["1102","1104","1106"]},"At decision block , a determination is made as to whether a deployment exception was thrown due to an error in deploying. If the deployment exception has occurred, the transaction is stopped and rolled back to its previous step at processing block . It the deployment exception is not thrown, and the transaction is successful, it is committed to the corresponding container at processing block . The transaction is then committed to a database at processing block . Furthermore, once the transaction is committed, a notification is given to other servers or server nodes regarding the commitment of the transaction at processing block . Depending on whether the transaction was committed or rolled back, a result for the committed transaction or an exception for a rolled back transaction is provided back to the client at processing block .",{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 12","b":["1200","1220","1200","1204","1218","1218","1216","1218","1218","1218","1204","1218"]},"As illustrated, the J2EE connector architecture  includes a resource adapter , also referred to as a component, to provide connectivity to a specific EIS or EIS system . The resource adapters  are provided by various EIS vendors. The J2EE connector architecture  may also include various J2EE or non-J2EE products to allow the resources adapters  to be plugged in to the platform implementation. A resource adapter  may be stored in a Resource Adapter aRchive (RAR) file and deployed on a J2EE server, similar to an Enterprise ARchive (e.g., EAR or ear) file of a J2EE application. Also, an RAR file may reside in an EAR file or it may exist as a separate file.","According to one embodiment, a deploy service  communicates with various containers , each having application components , via a container API . The deploy service  facilitates the management of the container  and of the application assembled using the application component . The deploy service  and the container  communicate with the resource adapter  via application contracts or APIs -. The resource adapter  is then used by the deploy service  and the container  to communicate with the EIS . Similarly, the mangers and\/or services  are linked with the resource adapter  via an API or services contract  to link the EIS  with various services, such as security, transaction, and connectivity, managed by the server. The APIs - are implemented by the resource adapter .",{"@attributes":{"id":"p-0087","num":"0086"},"figref":["FIG. 13A","FIG. 13B"],"b":["1300","1300","1302","1304","1304","1306","1308","1310","1312","1314","1316","1318","1320","1322","1306","1306","1306","1306"]},{"@attributes":{"id":"p-0088","num":"0087"},"figref":["FIG. 13B","FIG. 13A"],"b":["1350","1350","1352","1354","1356","1318","1318","1320","1322","1320"]},"A system architecture according to one embodiment of the invention is illustrated in . The architecture includes a central services instance  and a plurality of application server instances , . As used herein, the application server instances,  and , each include a group of server nodes , ,  and , , , respectively, and a dispatcher, , , respectively. The central services instance  includes a locking service  and a messaging service  (described below). The combination of all of the application server instances ,  and the central services instance  is referred to herein as a \u201ccluster.\u201d Although the following description will focus solely on instance  for the purpose of explanation, the same principles apply to other instances such as instance .","The server nodes , ,  within instance  provide the business and\/or presentation logic for the network applications supported by the system. Each of the server nodes , ,  within a particular instance  may be configured with a redundant set of application logic and associated data. In one embodiment, the dispatcher  distributes service requests from clients to one or more of the server nodes , ,  based on the load on each of the servers. For example, in one embodiment, the dispatcher  implements a round-robin policy of distributing service requests.","The server nodes , ,  may be Java 2 Enterprise Edition (\u201cJ2EE\u201d) server nodes which support Enterprise Java Bean (\u201cEJB\u201d) components and EJB containers (at the business layer) and Servlets and Java Server Pages (\u201cJSP\u201d) (at the presentation layer). Of course, the embodiments of the invention described herein may be implemented in the context of various different software platforms including, by way of example, Microsoft .NET platforms and\/or the Advanced Business Application Programming (\u201cABAP\u201d) platforms developed by SAP AG, the assignee of the present application.","In one embodiment, communication and synchronization between each of the instances ,  is enabled via the central services instance . As illustrated in , the central services instance  includes a messaging service  and a locking service . The message service  allows each of the servers within each of the instances to communicate with one another via a message passing protocol. For example, messages from one server may be broadcast to all other servers within the cluster via the messaging service  (e.g., such as the cache configuration messages described below). Alternatively, messages may be addressed directly to specific servers within the cluster (i.e., rather than being broadcast to all servers).","In one embodiment, the locking service  disables access to (i.e., locks) certain specified portions of configuration data and\/or program code stored within a central database  or resources shared in the cluster by different services. The locking manager locks data on behalf of various system components which need to synchronize access to specific types of data and program code (e.g., such as the configuration managers , ). As described in detail below, the locking service enables a distributed caching architecture for caching copies of server\/dispatcher configuration data.","In one embodiment, the messaging service  and the locking service  are each implemented on dedicated servers. However, the messaging service  and the locking service  may be implemented on a single server or across multiple servers while still complying with the underlying principles of the invention.","As illustrated in , each server node (e.g., , ) includes a lock manager ,  for communicating with the locking service ; a cluster manager ,  for communicating with the messaging service ; and a configuration manager ,  for communicating with a central database  (e.g., to store\/retrieve configuration data as described herein). Although the lock manager , , cluster manager ,  and configuration manager ,  are illustrated only with respect to server nodes  and  in , each of the server nodes , ,  and  and\/or on the dispatchers ,  may be equipped with equivalent lock managers, cluster managers and configuration managers while still complying with the underlying principles of the invention.","Referring now to , in one embodiment, configuration data  defining the configuration of the central services instance  and\/or the server nodes and dispatchers within instances  and , is stored within the central database . By way of example, the configuration data may include an indication of the kernel, applications and libraries required by each dispatcher and server; network information related to each dispatcher and server (e.g., address\/port number); an indication of the binaries required during the boot process for each dispatcher and server, parameters defining the software and\/or hardware configuration of each dispatcher and server (e.g., defining cache size, memory allocation, . . . etc), and various other types of information related to the cluster. It should be noted, however, that the underlying principles of the invention are not limited to any particular set of configuration data.","In one embodiment of the invention, to improve the speed at which the various servers and dispatchers access the configuration data, the configuration managers ,  cache configuration data locally within configuration caches , . As such, to ensure that the configuration data within the configuration caches ,  remains up-to-date, the configuration managers ,  implement cache synchronization policies, as described herein.",{"@attributes":{"id":"p-0098","num":"0097"},"figref":"FIG. 16","b":["1600","1600","1602","1606","1602","1606","1602","1606","1612"]},"Processor bus , also known as the host bus or the front side bus, may be used to couple the processors - with the system interface . Processor bus  may include a control bus , an address bus , and a data bus . The control bus , the address bus , and the data bus  may be multidrop bi-directional buses, e.g., connected to three or more bus agents, as opposed to a point-to-point bus, which may be connected only between two bus agents.","System interface  (or chipset) may be connected to the processor bus  to interface other components of the system  with the processor bus . For example, system interface  may include a memory controller  for interfacing a main memory  with the processor bus . The main memory  typically includes one or more memory cards and a control circuit (not shown). System interface  may also include an input\/output (I\/O) interface  to interface one or more I\/O bridges or I\/O devices with the processor bus . For example, as illustrated, the I\/O interface  may interface an I\/O bridge  with the processor bus . I\/O bridge  may operate as a bus bridge to interface between the system interface  and an I\/O bus . One or more I\/O controllers and\/or I\/O devices may be connected with the I\/O bus , such as I\/O controller  and I\/O device , as illustrated. I\/O bus  may include a peripheral component interconnect (PCI) bus or other type of I\/O bus.","System  may include a dynamic storage device, referred to as main memory , a RAM, or other devices coupled to the processor bus  for storing information and instructions to be executed by the processors -. Main memory  also may be used for storing temporary variables or other intermediate information during execution of instructions by the processors -. System  may include a ROM and\/or other static storage device coupled to the I\/O bus  for storing static information and instructions for the processors -.","Main memory  or dynamic storage device may include a magnetic disk or an optical disc for storing information and instructions. I\/O device  may include a display device (not shown), such as a cathode ray tube (CRT) or liquid crystal display (LCD), for displaying information to an end user. For example, graphical and\/or textual indications of installation status, time remaining in the trial period, and other information may be presented to the prospective purchaser on the display device. I\/O device  may also include an input device (not shown), such as an alphanumeric input device, including alphanumeric and other keys for communicating information and\/or command selections to the processors -. Another type of user input device includes cursor control, such as a mouse, a trackball, or cursor direction keys for communicating direction information and command selections to the processors - and for controlling cursor movement on the display device.","System  may also include a communication device (not shown), such as a modem, a network interface card, or other well-known interface devices, such as those used for coupling to Ethernet, token ring, or other types of physical attachment for purposes of providing a communication link to support a local or wide area network, for example. Stated differently, the system  may be coupled with a number of clients and\/or servers via a conventional network infrastructure, such as a company's Intranet and\/or the Internet, for example.","It is appreciated that a lesser or more equipped system than the example described above may be desirable for certain implementations. Therefore, the configuration of system  may vary from implementation to implementation depending upon numerous factors, such as price constraints, performance requirements, technological improvements, and\/or other circumstances.","It should be noted that, while the embodiments described herein may be performed under the control of a programmed processor, such as processors -, in alternative embodiments, the embodiments may be fully or partially implemented by any programmable or hardcoded logic, such as field programmable gate arrays (FPGAs), TTL logic, or application specific integrated circuits (ASICs). Additionally, the embodiments of the present invention may be performed by any combination of programmed general-purpose computer components and\/or custom hardware components. Therefore, nothing disclosed herein should be construed as limiting the various embodiments of the present invention to a particular embodiment wherein the recited embodiments may be performed by a specific combination of hardware components.",{"@attributes":{"id":"p-0106","num":"0105"},"figref":["FIG. 17","FIG. 16","FIG. 16","FIG. 16"],"b":["1700","1700","1702","1602","1606","1704","1616","1706","1630","1708","1710","1712","1702","1704"]},"The J2EE architecture  may include a deploy service based on various J2EE and non-J2EE containers, components, resources, services, and interfaces. The J2EE and non-J2EE components may include executable content, control logic (e.g., ASIC, PLD, FPGA, etc.), firmware, or some combination thereof, in one embodiment of the present invention. In embodiments of the invention in which the J2EE architecture  may include executable content, it may be stored in the memory device  and executed by the control processor .","Memory devices  may encompass a wide variety of memory devices including ROM, EPROM, EEPROM, RAM, non-volatile random access memory (NVRAM), cache memory, flash memory, and other memory devices. Memory devices  may also include one or more hard disks, floppy disks, ZIP disks, compact disks (e.g., CD-ROM), digital versatile\/video disks (DVD), magnetic random access memory (MRAM) devices, and other system-readable media that store instructions and\/or data. Memory devices  may store program modules, such as routines, programs, objects, images, data structures, program data, and other program modules that perform particular tasks or implement particular abstract data types that facilitate system use.","The I\/O devices  may include hard disk drive interfaces, magnetic disk drive interfaces, optical drive interfaces, parallel ports, serial controllers or super I\/O controllers, serial ports, universal serial bus (USB) ports, display device interfaces (e.g., video adapters), network interface cards (NICs), sound cards, modems, and the like. System interconnect or network  may permit communication between the various elements of node . System interconnects  may include a wide variety of signal lines including one or more of memory buses, peripheral buses, local buses, host buses, and bridge, optical, electrical, acoustical, and other propagated signal lines.","It should be appreciated that reference throughout this specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Therefore, it is emphasized and should be appreciated that two or more references to \u201can embodiment\u201d or \u201cone embodiment\u201d or \u201can alternative embodiment\u201d in various portions of this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures or characteristics may be combined as suitable in one or more embodiments of the invention.","Similarly, it should be appreciated that in the foregoing description of exemplary embodiments of the invention, various features of the invention are sometimes grouped together in a single embodiment, figure, or description thereof for the purpose of streamlining the disclosure aiding in the understanding of one or more of the various inventive aspects. This method of disclosure, however, is not to be interpreted as reflecting an intention that the claimed invention requires more features than are expressly recited in each claim. Rather, as the following claims reflect, inventive aspects lie in less than all features of a single foregoing disclosed embodiment. Thus, the claims following the detailed description are hereby expressly incorporated into this detailed description, with each claim standing on its own as a separate embodiment of this invention.","While certain exemplary embodiments have been described and shown in the accompanying drawings, it is to be understood that such embodiments are merely illustrative of and not restrictive, and that the embodiments of the present invention are not to be limited to specific constructions and arrangements shown and described, since various other modifications may occur to those ordinarily skilled in the art upon studying this disclosure."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The appended claims set forth the features of the invention with particularity. The embodiments of the invention, together with its advantages, may be best understood from the following detailed description taken in conjunction with the accompanying drawings in which:",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1C"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 13A"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 13B"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 17"}]},"DETDESC":[{},{}]}
