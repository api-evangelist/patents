---
title: System and method for supporting new and existing extensions to application programming interfaces
abstract: A component, such as a Component Object Model (COM) object, operates as an intermediary between an Application Programming Interface (API) extension or plug-in and a driver. The component allows additional objects to be aggregated onto the component, and/or sets one or more setting values for a received request so that an I/O call associated with the request can be completed in a manner that is compatible with other I/O calls. The component may also return, in response to a particular request, a stream index associated with the component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07467392&OS=07467392&RS=07467392
owner: Microsoft Corporation
number: 07467392
owner_city: Redmod
owner_country: US
publication_date: 20040910
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND ","SUMMARY","DETAILED DESCRIPTION "],"p":["This invention relates to application programming interfaces, and particularly to systems and method for supporting new and existing extensions to application programming interfaces.","As computing technology has advanced, computers have become increasingly popular for use with a wide variety of applications, including multimedia applications. Multimedia applications offer a wide variety of functionality, including the recording, playback, storage, editing, and so forth of audio and\/or video data. Additional hardware is also available for computers, this additional hardware often being designed and\/or manufactured by a different person or company than that which designed and\/or manufactured the computer. This additional hardware, such as cameras, television capture devices, storage devices, and so forth provides different functionality for applications running on the computer. Furthermore, the same type of hardware (e.g., cameras) designed by different manufacturers may support different functionality.","The computer typically has an architecture that includes a program, referred to as a driver, that runs to allow the multimedia application on the computer to access and use particular hardware. A different driver is typically used for each different piece of hardware. An application running on the computer typically invokes one or more interfaces exposed by an Application Programming Interface (API) on the computer, which interacts with the driver for the particular piece of hardware in order for the commands of the multimedia application to be carried out. Different extensions or plug-ins can be added to the API to support the various functionality of the hardware and drivers. An example of one such API to which extensions can be added is the DirectShow\u00ae API available from Microsoft Corporation of Redmond, Wash.","One problem that exists with such architectures, however, arises when changes are made to the API to which the extensions can be added, particularly when significant changes are made to the API. Such changes can result in the situation where the API extensions have to be changed significantly in order to work with the new API. Such changes can require a significant amount of time to make, and may leave the changed API extension unusable with the previous version of the API. Thus, it would be beneficial to have a way to make changes to the API that reduce any necessary changes to the API extensions, and that allow the changed API extensions to be backwards compatible with the previous version of the API.","Systems and methods for supporting new and existing extensions to application programming interfaces are discussed herein.","In accordance with certain aspects, a request that is associated with an Input\/Output (I\/O) call is received from an API plug-in or extension. The API plug-in or extension includes one or more interfaces to allow an application to invoke functionality supported by a driver associated with the API plug-in or extension. One or more setting values are set, on behalf of the API plug-in or extension, for the request so that the request is compatible with requests associated with other I\/O calls. This setting may be, for example, setting of a flag in an event handle for the I\/O call, the flag indicating that an I\/O completion port is not to be signaled when the I\/O call is completed. After the setting value(s) are set, the driver is invoked to carry out the I\/O call.","In accordance with other aspects, a Component Object Model (COM) object sets the one or more setting values and invokes the driver to carry out the I\/O call. This COM object also aggregates, in response to a request, one or more additional API plug-ins or extensions in order to allow interfaces of the one or more additional API plug-ins or extensions to be exposed and invoked using I\/O calls.","In accordance with other aspects, a Component Object Model (COM) object is an intermediary between an Application Programming Interface (API) extension or plug-in and a driver. The COM object receives, from the API extension or plug-in, a request for a stream index associated with the COM object. In response to the request, the COM object returns the stream index associated with the COM object. In certain implementations, the request comprises a GetStreamIndex interface being invoked.","Systems and methods for supporting new and existing extensions to application programming interfaces are discussed herein. A component, referred to as a stub, operates as an intermediary between Application Programming Interface (API) extensions and device drivers. These API extensions can be used to extend the functionality available to both new and legacy applications. Functionality of the drivers can be invoked by the API extensions invoking an interface on the stub, which in turn invokes the desired driver. The stub can also be used as a basis for aggregation of objects, allowing multiple extensions to be added to the API.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","102","104","106","108","110","104","112","114","114","116","118","108","104","108","104","102","108","106","100","102","108","106"]},"Driver  is a set of instructions, oftentimes a relatively small computer program (relative to application ), that is associated with hardware . In certain embodiments, driver  is a kernel streaming driver that supports kernel-mode processing of streamed data. Streamed data is data that is received at system  by a process referred to as streaming. Streaming refers to the data for media content (e.g., data for audio content, data for video content, data for image content, etc.) being received at system  and playback of the media content at system  being allowed to begin before all of the media content is received at system . For example, if the media content is a song having a playback duration of three minutes, then playback of the song can begin after the first few seconds (e.g., ten or fifteen seconds) of the song have been received rather than delaying the start of playback of the song until all three minutes of the song are received.","Driver  allows other programs in system  to access the functionality of hardware . Hardware  can be any of a variety of different devices that can be connected to a computing device. Hardware  can refer to internal components (e.g., those that are internal to a computing device, such as cards that are physically plugged into a slot of the computing device) as well as external components (e.g., those that are external to a computing device, such as devices connecting to the computing device via a Universal Serial Bus (USB) or IEEE 1394 connection). Examples of hardware  include video and\/or audio capture devices (e.g., cameras, television capture devices, camcorders, microphones, etc.), video and\/or audio playback devices, storage devices, and so forth.","Property set  defines the format of communications that driver  understands. For example, in certain embodiments property set  defines a set of one or more messages that can be understood by driver . Each such message would include, for example, an identifier (e.g., a globally unique identifier (GUID), a name, etc.) of the message as well as zero or more parameters for the message. Any component, such as stub , that desires to communicate with driver  does so in accordance with the communication format(s), such as the different supported messages, defined in property set .","API  exposes one or more interfaces to application . API  includes a base API portion  and an API plug-in or extension portion . Base API portion  includes a basic set of API interfaces, such as those that are designed by the designer of OS . This basic set of API interfaces typically includes interfaces that support functionality of hardware that is oftentimes shipped with OS  and\/or oftentimes used with OS . For example, if a particular microphone (or other audio capture device) is typically used with OS , then a driver  for that microphone would typically be included in OS  and an interface that allows application  to capture audio data using that microphone would typically be included in base API .","API plug-in portion  includes one or more additional API interfaces that are typically designed by some third party that is different from the designer of OS . A particular API plug-in (also referred to as an API extension) is an object that includes one or more API interfaces designed to know how to communicate with an associated driver  (e.g., understands the communication formats described in property set  of the associated driver) and further to expose one or more interfaces to allow application  to invoke particular functions of driver  and hardware . As these interfaces in API plug-in portion  are added to API  and expand the functionality exposed by API , they are referred to as API extensions or plug-ins. For example, assume that a third party manufacturer designs a new web camera with new functionality. The third party manufacturer also designs an API plug-in that exposes one or more interfaces allowing application  to invoke the new functionality, and that communicates with driver  to perform the new functionality when invoked by application .","Stub  is a component that operates as an intermediary between API  and driver . Communications from interfaces of API  to driver  are passed through stub . In certain embodiments, stub  is a component object model (COM) object that exposes an interface referred to as IKsControl. Additional information regarding COM objects is available from Microsoft Corporation of Redmond, Wash.","The IKsControl interface includes a KsProperty method, a KsMethod method, and a KsEvent method. The KsProperty method allows for the setting of property information in, or retrieval of property information from, property set . The parameters for the KsProperty method are listed below in Table I.",{"@attributes":{"id":"p-0024","num":"0023"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE I"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Parameter","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Property","Pointer to a KSPROPERTY structure that describes a"]},{"entry":[{},"property and the request type of the property request."]},{"entry":["PropertyLength","Size, in bytes, of the buffer at Property."]},{"entry":["PropertyData","Pointer to a buffer that contains data for an operation,"]},{"entry":[{},"or buffer space that receives data for an operation."]},{"entry":["DataLength","Size, in bytes, of the buffer at PropertyData."]},{"entry":["BytesReturned","Pointer to a variable that receives the size, in bytes, of"]},{"entry":[{},"the data that the KsProperty method stores in the buffer"]},{"entry":[{},"at PropertyData. If no data is stored, the size is zero."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The KsMethod method sends a method to stub . This method sent to stub  is the request to carry out the I\/O call made by application . The parameters for the KsMethod method are listed below in Table II.",{"@attributes":{"id":"p-0026","num":"0025"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE II"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Parameter","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Method","Pointer to a KSMETHOD structure that describes a"]},{"entry":[{},"method and the request type of the method request."]},{"entry":["MethodLength","Size, in bytes, of the buffer at Method."]},{"entry":["MethodData","Pointer to a buffer that contains data and buffer space for"]},{"entry":[{},"an operation, or buffer space that receives data for an"]},{"entry":[{},"operation."]},{"entry":["DataLength","Size, in bytes, of the buffer at MethodData."]},{"entry":["BytesReturned","Pointer to a variable that receives the size, in bytes, of"]},{"entry":[{},"the data that the KsMethod method stores in the buffer at"]},{"entry":[{},"MethodData."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The KsEvent method enables or disables an event, allowing an interface of API  to request to be notified of, or no longer be notified of, particular events. The parameters for the KsEvent method are listed below in Table III.",{"@attributes":{"id":"p-0028","num":"0027"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE III"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Parameter","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Event","Pointer to a KSEVENT structure that describes an event"]},{"entry":[{},"to enable the event and NULL to disable the event."]},{"entry":["EventLength","Size, in bytes, of the buffer at Event when the event is"]},{"entry":[{},"enabled and zero when the event is disabled."]},{"entry":["EventData","Pointer to a KSEVENTDATA structure that contains"]},{"entry":[{},"data for the event and buffer space that receives data for"]},{"entry":[{},"the event."]},{"entry":["DataLength","Size, in bytes, of the buffer at EventData."]},{"entry":["BytesReturned","Pointer to a variable that receives the size, in bytes, of"]},{"entry":[{},"the data that the KsEvent method stores in the buffer at"]},{"entry":[{},"EventData."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Additional information regarding the IKsControl interface is available in the Driver Development Kit (DDK) for Windows\u00ae operating systems available from Microsoft Corporation.","API  communicates with or calls driver  by invoking a method on the interface exposed by stub . In response to the method being invoked, stub  invokes one or more functions of, or methods on interfaces that are exposed by, driver . In certain implementations, a DeviceIoControl function is exposed by driver . The DeviceIoControl function is a function that allows control code to be sent directly to driver , causing driver  and device  to perform a particular operation. This operation is the carrying out of the I\/O call made by application . Any parameters that are passed to stub  by API  can also passed to driver  by stub .","The parameters for the DeviceIoControl function are listed below in Table IV.",{"@attributes":{"id":"p-0032","num":"0031"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE IV"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Parameter","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["hDevice","[in] Handle to the device on which the operation is to"]},{"entry":[{},"be performed. To retrieve a device handle, the"]},{"entry":[{},"CreateFile function can be used."]},{"entry":["dwIoControlCode","[in] Control code for the operation. This value"]},{"entry":[{},"identifies the specific operation to be performed and"]},{"entry":[{},"the type of device on which to perform it."]},{"entry":["lpInBuffer","[in] Pointer to the input buffer that contains the data"]},{"entry":[{},"required to perform the operation. The format of this"]},{"entry":[{},"data depends on the value of the dwIoControlCode"]},{"entry":[{},"parameter. This parameter can be NULL if"]},{"entry":[{},"dwIoControlCode specifies an operation that does not"]},{"entry":[{},"require input data."]},{"entry":["nInBufferSize","[in] Size of the input buffer, in bytes."]},{"entry":["lpOutBuffer","[out] Pointer to the output buffer that is to receive the"]},{"entry":[{},"data returned by the operation. The format of this data"]},{"entry":[{},"depends on the value of the dwIoControlCode"]},{"entry":[{},"parameter. This parameter can be NULL if"]},{"entry":[{},"dwIoControlCode specifies an operation that"]},{"entry":[{},"does not return data."]},{"entry":["nOutBufferSize","[in] Size of the output buffer, in bytes."]},{"entry":["lpBytesReturned","[out] Pointer to a variable that receives the size"]},{"entry":[{},"of the data stored in the output buffer, in bytes."]},{"entry":[{},"If the output buffer is too small to receive any data, the"]},{"entry":[{},"call fails, an ERROR_INSUFFICIENT_BUFFER"]},{"entry":[{},"error is returned, and lpBytesReturned is zero."]},{"entry":[{},"If the output buffer is too small to hold all of the data"]},{"entry":[{},"but can hold some entries, some drivers will return as"]},{"entry":[{},"much data as fits. In this case, the call fails, an"]},{"entry":[{},"ERROR_MORE_DATA error is returned, and"]},{"entry":[{},"lpBytesReturned indicates the amount of data received."]},{"entry":[{},"If lpOverlapped is NULL, lpBytesReturned cannot be"]},{"entry":[{},"NULL. Even when an operation returns no output data"]},{"entry":[{},"and lpOutBuffer is NULL, the DeviceIoControl"]},{"entry":[{},"function makes use of lpBytesReturned. After"]},{"entry":[{},"such an operation, the value of lpBytesReturned"]},{"entry":[{},"is meaningless."]},{"entry":[{},"If lpOverlapped is not NULL, lpBytesReturned can be"]},{"entry":[{},"NULL. If this parameter is not NULL and the"]},{"entry":[{},"operation returns data, lpBytesReturned is"]},{"entry":[{},"meaningless until the overlapped operation"]},{"entry":[{},"has completed."]},{"entry":["lpOverlapped","[in] Pointer to an OVERLAPPED structure."]},{"entry":[{},"If hDevice was opened without specifying"]},{"entry":[{},"FILE_FLAG_OVERLAPPED,"]},{"entry":[{},"lpOverlapped is ignored."]},{"entry":[{},"If hDevice was opened with the"]},{"entry":[{},"FILE_FLAG_OVERLAPPED flag, the operation is"]},{"entry":[{},"performed as an overlapped (asynchronous) operation."]},{"entry":[{},"In this case, lpOverlapped points to a valid"]},{"entry":[{},"OVERLAPPED structure that contains a handle"]},{"entry":[{},"to an event object."]},{"entry":[{},"For overlapped operations, the DeviceIoControl"]},{"entry":[{},"function returns immediately, and the event object is"]},{"entry":[{},"signaled when the operation has been completed."]},{"entry":[{},"Otherwise, the function does not return until the"]},{"entry":[{},"operation has been completed or an error occurs."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Additional information regarding the DeviceIoControl function is available in the Platform Software Development Kit (SDK) for Windows\u00ae operating systems available from Microsoft Corporation.","The parameters of the DeviceIoControl function are provided to stub  as parameters when an IKsControl interface method is invoked, except for a device handle and the event handle as modified by compatibility module . When an event handle is being used, the event handle is received as a parameter when an IKsControl interface method is invoked, but then is modified by module  as discussed in more detail below. The device handle is an identifier associated with the hardware  and driver  that uniquely identifies hardware  in system . The device handle is obtained by stub  invoking a CreateFile function (e.g., a function of API  or OS ) with the name (or other identifier) of driver  and\/or the name (or other identifier) of hardware device . This name (or other identifier) or driver  and\/or hardware device  is known to the interface of API that is invoking a method of the IKsControl interface, and thus is passed to stub  as a parameter of the invoked method.","It should be noted that the methods of the IKsControl interface do not require as a parameter a device handle associated with the hardware  and driver . Thus, in invoking the methods of the IKsControl interface, the interfaces of API  do not need such a device handle. However, the DeviceIoControl function does use, as a parameter, a device handle associated with the hardware  and driver . Thus, the interfaces in portions  and  do not even need the device handle, and without such handle they would not be able to access hardware  and driver  directly using the DeviceIoControl function (they would have to access hardware  and driver  through stub ).","Application  often performs input\/output (I\/O or IO) calls to hardware . These I\/O calls input data from and\/or output data to hardware . During operation, when application  desires to invoke particular functionality of hardware  (e.g., capture audio data, capture video data, etc.), application  invokes the appropriate interface of API  for that functionality. This interface of API  could be part of base API  or API plug-in , depending on the particular functionality. The invoked interface of API  is designed to know how to communicate with driver , and formats an appropriate message for driver  to carry out the functionality requested by application . API  then invokes an interface of stub  (e.g., a method on the IKsControl interface exposed by stub ), passing to stub  any parameters to be included in order to carry out the functionality requested by application  (these parameters will be identified in the formats defined property set  of driver ). Stub  then invokes an interface exposed by driver  (e.g., a method on the DeviceIoControl function exposed by driver ), passing to driver  any parameters received from application . Driver  and hardware  then perform the desired function as requested by application . Results and\/or error information may optionally be returned by driver  through stub  and API  to application  (or alternatively by signaling an event or I\/O completion port, as discussed in more detail below).","Different applications  (or even the same application ) can perform I\/O calls using different techniques, even though the same interface on API  is invoked for all of these different techniques. In certain embodiments, the different techniques that can be used by application  to perform I\/O calls are referred to as overlapped I\/O and completion ports. Using overlapped I\/O, application  has an event handle associated with every I\/O call made invoking an interface of API . When the I\/O call is completed, the event (using that event handle) is signaled (e.g., by driver ). This signaling of the event allows application  to know that the I\/O call has been completed.","Using completion ports, however, a separate event handle is not used for each call. Rather, the hardware  and driver  are associated with a particular device handle (or other identifier), and this device handle is associated with an I\/O completion port. Whenever an I\/O call is completed, driver  signals the I\/O completion port associated with driver . The process of signaling the I\/O completion port includes identifying information of which I\/O call is completed (e.g., a pointer to a data structure that describes the I\/O call). Application  monitors this I\/O completion port, such as by having a separate thread that waits on the completion port and then analyzes each signaling of the I\/O completion port. This analysis includes identifying which I\/O call was completed, so application  knows when the I\/O call has been completed.","However, using overlapped I\/O and completion ports are not always compatible with one another. Each of these techniques can perform actions that make the other operate incorrectly, which can result in the operating system failing to operate correctly (e.g., crashing). This incompatibility results primarily from driver  signaling the I\/O completion port when an overlapped I\/O call is completed.","Stub  includes a compatibility module  that resolves the overlapped I\/O and completion ports techniques' incompatibilities by sending an indication to driver  that the I\/O completion port should not be signaled when an overlapped I\/O call is completed. This indication can be sent, for example, by setting a flag in the event handle associated with the overlapped I\/O call (e.g., setting the least significant or low-order bit of the event handle). When the I\/O call is completed, driver  recognizes that this flag has been set. In response to the flag being set, driver  will signal the event to indicate that the I\/O call is completed, but will not signal the I\/O completion port. By preventing the I\/O completion port from being signaled for overlapped I\/O calls, the incompatibility of the overlapped I\/O and completion ports techniques is resolved, allowing the two techniques to be used concurrently.","It is to be appreciated that, although setting the flag in the event handle is discussed as an example of making the I\/O completion ports and overlapped I\/O techniques compatible, stub  can similarly be used to set other values for I\/O calls to resolve the incompatibility between different techniques for making I\/O calls. The exact nature of such setting values will vary based on the particular incompatibilities between the techniques. However, because stub  is acting as an intermediary and because all of the I\/O calls will be passed through stub , stub  can set such values to resolve such incompatibilities.","By resolving the incompatibilities between different techniques for making I\/O calls, stub  creates a solution that allows extensions to APIs to be made that are independent of the underlying technology or techniques used for making the I\/O calls.","Resolving this incompatibility issue can be very useful, such as in situations where operating system  is being redesigned. For example, API  may be a new multimedia API that is designed to replace the DirectShow\u00ae API. This older or previous version of the API is also referred to as the legacy API or application. If the DirectShow\u00ae API is designed for applications  to use one technique (e.g., overlapped I\/O), while the new multimedia API is designed to use a different technique (e.g., I\/O completion ports), API extensions designed to work with the DirectShow\u00ae API and API extensions designed to work with the new multimedia API can both be used with stub . Very little, if any, changes need to be made to the API extensions designed to work with the DirectShow\u00ae API in order to work with stub  (e.g., they may need to be modified slightly to invoke the IKsControl interface of stub  rather than call the DeviceIoControl function of driver  themselves). This eases the transition process, allowing many of the legacy API extensions designed to be used with the DirectShow\u00ae API to be readily used with the new API  with little or no modification.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 2","FIG. 1","FIG. 1"],"b":["200","108","200","112"]},"Initially, a request is received from an API plug-in (act ). This can be received in a variety of different manners, such as by invocation by the API plug-in of a method of an IKsControl interface exposed by the stub. The request received in act  is made by the API plug-in in response to an I\/O call made by application  of . In response to the received request, the stub sets one or more values to make the request compatible with requests made using other I\/O call techniques (act ). This setting of values can be, for example, setting a flag in an event handle associated with the I\/O call so that an I\/O completion port is not signaled when the I\/O call is completed.","The driver associated with the plug-in is then invoked to carry out the I\/O call (act ), such as by invoking a DeviceIoControl function of the driver. Any values that were received from the API plug-in as part of the request in act  are also passed to the driver in act . Additionally, any values set in act  are passed as appropriate to the driver in act  (e.g., the event handle with the flag set can be passed to the driver).","Returning to , oftentimes the API plug-ins (e.g., plug-in portion ) are designed to be able to aggregate onto another object. Aggregation is a technique supported by objects (e.g., by COM objects) that allows interfaces from one or more objects to be exposed by one or more other objects as if they were part of those one or more other objects. Using aggregation, the various interfaces supported by the API plug-ins can be determined by invoking a Query Interface method on an exposed IUnknown interface of stub , resulting in pointers to the other interfaces exposed by stub  (including those having been aggregated onto stub ) being returned to the caller.","Stub  includes an object aggregation module . Object aggregation module  allows other objects to be aggregated onto stub . In order to aggregate an object onto stub , a CoCreateInstance call (which is defined by COM) is made by module , including as parameters a class ID to be used to create the object being aggregated onto stub  (e.g., a GUID that uniquely identifies the class), and an identifier of the interface to be used to communicate with the object (this will be an additional interface exposed by stub ). Once an object that is an API plug-in is aggregated onto stub , any interfaces exposed by that API plug-in are exposed by API .","The parameters for the CoCreateInstance call are obtained by object aggregation module . These parameters can be obtained, for example, by aggregation module  retrieving the parameters from some source, by an interface of API  passing the parameters to module , or alternatively by some other component or module of API  or OS  passing the parameters to module . These parameters can be obtained from different sources, such as an operating system registry (e.g., a Windows\u00ae operating system registry), provided by a designer of an API interface (e.g., hardcoded into a table of API ), etc.). In certain embodiments, these parameters are provided to the source when the driver  and\/or associated API plug-in are first installed on system . It should be noted that these parameters identify the object being aggregated onto stub , so identification of these parameters includes identification of the object to be aggregated onto stub .",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 3","b":["300","112","300","112"]},"Initially, the parameters for the object to be aggregated onto stub  are identified (act ). This identification can be performed at different times, such as when stub  is instantiated, or when a request to access an interface exposed by the object is made (e.g., by application ). As discussed above, these parameters can be retrieved by stub  or passed to stub . Given these parameters, a call is made to aggregate the object onto stub  (act ). This call is, for example, the CoCreateInstance COM call. If there are additional object(s) to be aggregated onto stub , acts  and  are repeated (act ).","Referring back to , in certain embodiments data flows into and out of driver  through one or more connection points referred to as \u201cpins\u201d. A different property set  can be associated with each of these pins, allowing properties to be changed and thus allowing the way hardware  operates to be changed for different pins. Additionally, a separate stub  is included in API  for each of the different pins of driver  and is associated with one of the pins (e.g., with each stub having a single associated pin). In some situations, in order to access the correct property set , application  may request an identifier of a particular pin of driver  from API . This identifier of a particular pin of driver  is also referred to as a stream index.","In order to support such requests for stream indexes, in certain embodiments stub  exposes an interface referred to as an IGetStreamIndex interface. The IGetStreamIndex interface has a method referred to as GetStreamIndex that retrieves the stream index for a particular stub , which is the pin of driver  that the particular stub  is associated with. An example of the IGetStreamIndex interface is listed in Table V.",{"@attributes":{"id":"p-0054","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE V"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"IGetStreamIndex::GetStreamIndex"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Syntax"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2009HRESULT GetStreamIndex("},{"entry":"\u2002ULONG* pStreamIndex"},{"entry":");"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Parameters"]},{"entry":[{},"pStreamIndex"]},{"entry":[{},"\u2003[out] The stream index associated with the Stub."]},{"entry":[{},"Return Values"]},{"entry":[{},"If the method succeeds, it returns S_OK. If pStreamIndex is"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"NULL it will return E_INVALIDARG. Other error codes may be"},{"entry":"returned."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Remarks"]},{"entry":[{},"Some property sets or extension methods require a Stream ID as one"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"of the parameters. This interface is a method of acquiring these Stream"},{"entry":"IDs."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 4","b":["400","400","400","400"]},"Computer environment  includes a general-purpose computing device in the form of a computer . Computer  can be, for example, a device on which system  of  can be implemented. The components of computer  can include, but are not limited to, one or more processors or processing units , a system memory , and a system bus  that couples various system components including the processor  to the system memory .","The system bus  represents one or more of any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. By way of example, such architectures can include an Industry Standard Architecture (ISA) bus, a Micro Channel Architecture (MCA) bus, an Enhanced ISA (EISA) bus, a Video Electronics Standards Association (VESA) local bus, and a Peripheral Component Interconnects (PCI) bus also known as a Mezzanine bus.","Computer  typically includes a variety of computer readable media. Such media can be any available media that is accessible by computer  and includes both volatile and non-volatile media, removable and non-removable media.","The system memory  includes computer readable media in the form of volatile memory, such as random access memory (RAM) , and\/or non-volatile memory, such as read only memory (ROM) . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within computer , such as during start-up, is stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently operated on by the processing unit .","Computer  may also include other removable\/non-removable, volatile\/non-volatile computer storage media. By way of example,  illustrates a hard disk drive  for reading from and writing to a non-removable, non-volatile magnetic media (not shown), a magnetic disk drive  for reading from and writing to a removable, non-volatile magnetic disk  (e.g., a \u201cfloppy disk\u201d), and an optical disk drive  for reading from and\/or writing to a removable, non-volatile optical disk  such as a CD-ROM, DVD-ROM, or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are each connected to the system bus  by one or more data media interfaces . Alternatively, the hard disk drive , magnetic disk drive , and optical disk drive  can be connected to the system bus  by one or more interfaces (not shown).","The disk drives and their associated computer-readable media provide non-volatile storage of computer readable instructions, data structures, program modules, and other data for computer . Although the example illustrates a hard disk , a removable magnetic disk , and a removable optical disk , it is to be appreciated that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes or other magnetic storage devices, flash memory cards, CD-ROM, digital versatile disks (DVD) or other optical storage, random access memories (RAM), read only memories (ROM), electrically erasable programmable read-only memory (EEPROM), and the like, can also be utilized to implement the exemplary computing system and environment.","Any number of program modules can be stored on the hard disk , magnetic disk , optical disk , ROM , and\/or RAM , including by way of example, an operating system , one or more application programs , other program modules , and program data . Each of such operating system , one or more application programs , other program modules , and program data  (or some combination thereof) may implement all or part of the resident components that support the distributed file system.","A user can enter commands and information into computer  via input devices such as a keyboard  and a pointing device  (e.g., a \u201cmouse\u201d). Other input devices  (not shown specifically) may include a microphone, joystick, game pad, satellite dish, serial port, scanner, and\/or the like. These and other input devices are connected to the processing unit  via input\/output interfaces  that are coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port, or a universal serial bus (USB).","A monitor  or other type of display device can also be connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , other output peripheral devices can include components such as speakers (not shown) and a printer  which can be connected to computer  via the input\/output interfaces .","Computer  can operate in a networked environment using logical connections to one or more remote computers, such as a remote computing device . By way of example, the remote computing device  can be a personal computer, portable computer, a server, a router, a network computer, a peer device or other common network node, and the like. The remote computing device  is illustrated as a portable computer that can include many or all of the elements and features described herein relative to computer .","Logical connections between computer  and the remote computer  are depicted as a local area network (LAN)  and a general wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet.","When implemented in a LAN networking environment, the computer  is connected to a local network  via a network interface or adapter . When implemented in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the wide network . The modem , which can be internal or external to computer , can be connected to the system bus  via the input\/output interfaces  or other appropriate mechanisms. It is to be appreciated that the illustrated network connections are exemplary and that other means of establishing communication link(s) between the computers  and  can be employed.","In a networked environment, such as that illustrated with computing environment , program modules depicted relative to the computer , or portions thereof, may be stored in a remote memory storage device. By way of example, remote application programs  reside on a memory device of remote computer . For purposes of illustration, application programs and other executable program components such as the operating system are illustrated herein as discrete blocks, although it is recognized that such programs and components reside at various times in different storage components of the computing device , and are executed by the data processor(s) of the computer.","Various modules and techniques may be described herein in the general context of computer-executable instructions, such as program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments.","An implementation of these modules and techniques may be stored on or transmitted across some form of computer readable media. Computer readable media can be any available media that can be accessed by a computer. By way of example, and not limitation, computer readable media may comprise \u201ccomputer storage media\u201d and \u201ccommunications media.\u201d","\u201cComputer storage media\u201d includes volatile and non-volatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules, or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by a computer.","\u201cCommunication media\u201d typically embodies computer readable instructions, data structures, program modules, or other data in a modulated data signal, such as carrier wave or other transport mechanism. Communication media also includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared, and other wireless media. Combinations of any of the above are also included within the scope of computer readable media.","Although the description above uses language that is specific to structural features and\/or methodological acts, it is to be understood that the invention defined in the appended claims is not limited to the specific features or acts described. Rather, the specific features and acts are disclosed as exemplary forms of implementing the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The same numbers are used throughout the document to reference like components and\/or features.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
