---
title: Shared namespace for storage clusters
abstract: Any client application uses a namespace application to resolve its pathname in order to reference a computer file. Computer files are stored in a fixed-content storage cluster and are accessed by retrieving a unique identifier for the computer file using the namespace application. Any type of pathname scheme from any client application is supported by the namespace. The namespace application uses a bindings table to record bindings between objects including the start date and end date for each binding, and direction and separator data used in the pathname scheme. An attribute table in the namespace keeps track of each attribute and its value for each object of the namespace including a start date and an end date for each attribute. The namespace provides syntactic generality in that any pathname scheme of a client application can be resolved to identify a unique computer file in the storage cluster. The namespace may be shared between applications because when one application modifies a file or its attributes using the namespace, another application using a different pathname scheme has access to the exact same data and modifications. The namespace provides a near instantaneous continuous backup for computer files in the storage cluster because of the use of start date and end dates for the bindings and attributes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08255430&OS=08255430&RS=08255430
owner: Caringo, Inc.
number: 08255430
owner_city: Austin
owner_country: US
publication_date: 20090824
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","A General Namespace","Namespace Application Programming Interface","API Write Operations","API Read Operations","API Locking Operations","API Garbage Collection","Namespace General Example","Date Effectivity","Modification Histories","Namespace Locks","Namespace Specific Example","Syntactic Generality of the Namespace","Namespace Shared Between Applications","Continuous Backup Feature of Namespace","Garbage Collection","Implementation on a RAIN","Computer System Embodiment"],"p":["This application claims priority of U.S. provisional patent application No. 61\/091,822 filed Aug. 26, 2008 entitled \u201cShared namespaces in RAIN Storage Clusters,\u201d which is hereby incorporated by reference.","The present invention relates generally to namespaces. More specifically, the present invention relates to a namespace that is shared between client applications accessing a storage cluster.","Prior art content-addressable storage applications return a unique identifier to the managing application (or user) in exchange for receiving and storing a digital object (such as a computer file). Typically, this unique identifier is the result of a hash function performed on the contents of the digital object (such as a lengthy hexadecimal string) or is a unique random number associated with that digital object. It is then up to the managing application (or user) to decide what to do with that unique identifier: where to store it, how to maintain it, and how to retrieve it when the digital object stored in the content-addressable storage must be retrieved.","Needless to say, keeping track of a 128-bit (for example) unique identifier can be difficult for a user and problematic for a managing application accustomed to using its own pathname scheme. Moreover, various applications may wish to reference digital objects in storage using different pathname schemes, but cannot. And, different applications desiring to share and access the same digital object cannot do so without each managing a lengthy hexadecimal string.","Furthermore, while many techniques exist for backing up computer files and reverting to prior states in a computer system, most only provide a prior state at discrete times. For example, the \u201cTime Machine\u201d feature available on computers from Apple, Inc. automatically makes incremental backups every hour\u2014copying just the files that have changed since the last backup. But, this type of backup is only available at discrete checkpoints (every hour); it is not possible to determine the state of the computer system between hours if files have been changing.","Currently, many specific namespaces exist such as: DNS that maps host names to IP addresses; file systems that map pathnames to individual files; e-mail systems that map e-mail addresses to individual electronic mailboxes; and Web servers that map Universal Resource Locators (URLs) and Universal Resource Identifiers (URIs) to Internet content. Unfortunately, none of these prior art namespaces address the problems identified above and an improved namespace and techniques are desired.","To achieve the foregoing, and in accordance with the purpose of the present invention, a namespace and associated methods are disclosed that address the above problems in the prior art.","The present invention provides the general capability to map a symbolic user-readable name to a unique identifier in fixed-content storage (for example) that identifies a digital object. In the context of a file system, this enables a user or managing application to refer to digital objects (such as files) by a symbolic name or by a pathname instead of by a 128-bit number. Thus, digital objects stored in the fixed-content storage can now be given more useful symbolic names and can be manipulated with a file system (for example). The present invention guarantees that a fully resolved pathname is unambiguous and refers to, at most, a single digital object in the fixed-content storage.","The namespace of the present invention is general enough that it can represent host names, URIs, URLs, hierarchical file names, e-mail addresses, and nearly any symbolic name, regardless of syntax. As with the file system example above, preferably the managing application guarantees that a pathname is unambiguous. Thus, the present invention provides a novel namespace with universal mapping capabilities: any client application (file system, e-mail program, etc.) can store and retrieve digital objects using its own special pathname scheme without needing to manage lengthy unique identifiers. The namespace supports file names from different file systems, URLs, e-mail addresses, etc., all of which use different formats for identifying digital objects, and thus provides syntactic generality.","The namespace of the present invention allows sharing of digital objects between any number of different systems and clients. Different types of software applications may access the same digital object in a storage cluster using their own special pathname and not only be assured that the correct digital object is being accessed, but also that other software applications can view any changes made to the metadata of the digital object (or to the digital object itself). A variety of clients and protocols are supported such as CIFS, NFS, FTP, HTTP-Web, etc.","The namespace also provides the capability to attach start date and end date values to each name binding and attribute. Each binding or attribute includes a \u201cstart date\u201d and an \u201cend date\u201d indicating when the object (or attribute) came into existence and when it was deleted or changed. With these values, once data is stored in a fixed-content RAIN cluster (for example) and the identifiers for the objects are stored in the namespace, manual backups are no longer required. Any user, not just an administrator, can roll the clock backward to see what a file, folder, or file system looked like at any moment in the past. Therefore, the namespace also provides the capability for a \u201ccontinuous backup\u201d of digital objects, unlike the prior art which only provides backup capabilities at discrete times in the past.","The namespace enforces certain constraints that collectively guarantee unambiguous fully qualified path names. Within a given name context, a simple name can only be used once in any given timescape to refer to a single digital object. This simple rule is sufficient to guarantee that a given fully-qualified path name will refer to at most one digital object in the present or at any moment in the past. However, a given digital object may have many, infinitely many perhaps, fully qualified path names that refer to it.","In general, any file system (or other collection of digital objects) can be implemented as a fixed-content storage cluster (such as a redundant array of independent nodes, or RAIN) plus the general namespace of the present invention. The namespace thus allows humans to assign symbolic, structured names to stored objects in a fixed-content cluster, and then retrieve the object later by name. For example, a Linux file system built as a combination of fixed-content storage and the namespace of the present invention may be used to hold hierarchical file names.","As mentioned above, the present invention applies to digital objects, i.e., any type of information represented in digital form. For example, the present invention is applicable to any electronic representation of information such as a computer file, a group of files, a group of file identifiers, or other collections of data or database information. Such other collections of data include frames or clips from digital audio or video streams, digital photographs, scanned paper documents, voice messages, CAD\/CAM designs, MRI or X-ray data, streams from message records or files, log entries from audits or status logs of systems, e-mail archives, check images, etc. The term \u201ccomputer file\u201d is often used herein to encompass any electronic representation of the aforementioned types of information.","As known in the art, a namespace is an environment created to hold a logical grouping of unique identifiers or symbols. Typically, computer storage devices and modern computer languages provide support for namespaces. Storage devices can use directories (or folders) as namespaces. This use allows two files with the same name to be stored on the device so long as they are stored in different directories. The present invention uses a namespace in conjunction with a fixed-content storage cluster as described below to achieve many advantages.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 1","b":["10","10","20","22","28","29","20","20"]},"In one embodiment, storage cluster  is implemented using the CAStor content storage software available from Caringo, Inc. of Austin, Tex., and any suitable computer hardware. In this embodiment, typically computer node  serves as a router for routing communication between nodes ,  and  which store the digital objects. In this embodiment, storage cluster  is fixed-content storage and each digital object is uniquely addressed within the cluster by a random number (a universally unique identifier, or UUID) that has been generated for that digital object using a random number generator. The contents of each digital object are verified using a hash function. A software application receives the UUID when storing a digital object in the cluster and retrieves that digital object by supplying the UUID to the cluster. Software applications communicate with a CAStor cluster (over communication links  and , for example) using standard HTTP 1.1, and more specifically, using a simplified subset of the standard called Simple Content Storage Protocol (SCSP). Using this standard interface, applications such as electronic mail, enterprise content management, health care applications, Web 2.0, etc., may access the CAStor storage cluster. Further, direct HTPP access is available for browsers, JAVA, Python, C++, and other software environment. Standard file access to the storage cluster is available through the Content File Server (CFS) software product also available from Caringo, Inc. CFS is a Linux file system that supports all the major file protocols such as CIFS, NFS, FTP, WebDAV, Macintosh, Linux, etc. Using HTTP 1.1, CFS supports these standard file protocols in storing and retrieving computer files to the storage cluster.","In another embodiment, storage cluster  is implemented using the Centera hardware and software available from EMC Corporation. In this embodiment, storage cluster  is fixed-content, content-addressable storage and each digital object is uniquely addressed within the cluster by a hash value (a universally unique identifier, or UUID) that has been calculated for that digital object using a hash function. A software application receives the UUID when storing a digital object in the cluster and retrieves that digital object by supplying the UUID to the cluster.","Computers ,  and  host client applications or server software that use the namespace server  to access storage cluster . Of course, computers  and  may also access storage cluster  without the use of namespace server  if desired. In this illustration, a software client application on computer  uses a namespace available on namespace server  in order to store a digital object within storage cluster , manage that digital object, and retrieve it using a pathname scheme preferred by that client application. Alternatively, a client application on computer  utilizes a server application on computer  in order to interface with the namespace server  for digital object storage, management and retrieval. Of course, a client application may be running on the same physical computer in which the namespace is running.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 2","b":["100","20","20","110","120","130","30","50","20","110","130","20","160","110","120","160","120","120","124","122","162","130","162","160","130","160","160","180","190","170","170","180"]},"In simplest terms, a namespace is a mapping of symbolic names (strings) to objects. Strictly speaking, the namespace does not concern itself with the structure, type, or other attributes of the objects themselves, only their fundamental identity, represented as an objectID (or serial number). All that is required by the namespace is that each distinct object in the namespace has its own objectID. In general, a given object has exactly one objectID, although that object may have many name bindings referring to it. Every simple name in the namespace, except for the root, is understood in the context of some object. Each object can serve as a naming context for additional names, and all names within a given context are constrained to be different from one another. A namespace is logically a collection of triples, (object, name, object), which means, within the context of object the given name refers to object. This is called a name binding.","One way to visualize the totality of name mappings in a namespace is to think of them as a directed graph. The simplest possible namespace is a naming relationship between two distinct objects. Viewed as a directed graph, it might look like . This figure is a graphical way of representing the following: in the context of the object u, the name \u201cA\u201d refers to object u. An object may have names for many other objects as shown in . And, those objects may have names for other objects as shown in . Nodes in a namespace graph are referred to as \u201cobjects\u201d and, as mentioned, the edges are referred to as \u201cname bindings\u201d or simply \u201cbindings.\u201d","This begins to look like a traditional file system directory hierarchy, and indeed that is the most important application of a namespace, to allow a file system to store and resolve file pathnames. Note, however, that file system directory structures are not strictly hierarchical. There are hard and soft links that allow the same object to have two or more names as shown in . In this namespace, the object u is named \u201cC\u201d in the context of u, but it is named \u201cA\u201d in the context of u. Note that individual names (e.g., \u201cA\u201d) need not be distinct across the entire namespace. Within a context, all the names are different. In namespaces, as in file systems, even cycles are allowed in the graphs. For example, the object u has a name for itself, \u201c.\u201d and u refers to its parent as \u201c..\u201d reminiscent of the Unix conventions as shown in .","A namespace has a single, distinguished root node from which all unqualified names are resolved. This, along with some syntactic delimiter, allows one to use fully qualified path names to identify any object in the namespace graph. Assuming u is the root node in the above graph of  and \u201c\/\u201d is the delimiter, the following path names would resolve as follows: B\/Du; B\/Cu; C\/Au; .\/.\/.\/B\/D\/..\/Cu.","Different client applications may use different parts of the namespace graph. For example, a file system implementation could mount a file system starting at \u201cfilesystems\/linux\/app1\u201d or \u201cfilesystems\\windows\\app2\u201d.","The namespace may be implemented by one or more computer servers in a way that allows for concurrent access by many client applications. Namespace locks (see below) are provided for the convenience of client applications. These locks, however, are completely optional with respect to the namespace itself because each of the primitive namespace operations listed above maintains the ACID properties (atomicity, consistency, isolation and durability) of the overall namespace at all times. In the API definitions below, it is understood that all path parameters are fully qualified path names, emanating from the root node of the namespace. Simple names are those of the objects in a given context. Path names are constructed from simple names by using the separator and pathdir of the various contexts along the path. The following atomic functions are implemented by the namespace.","namespace(name [,separator] [,pathdir])","This function constructs a new namespace and root node called name. The optional parameters separator and pathdir can be used as defaults when resolving and constructing path names. (See the description of pathnames below.) If no separator or path traversal direction parameters are provided, the namespace will use the separator \u201c\/\u201d and the path traversal direction \u201cleft\u201d by default.","bind(contextPath, name [,separator] [,pathdir])","This function creates a new name binding in a given context. It fails if: the contextPath does not exist, the (contextPath, name) pair already exists in the present timescape, or if the name contains the separator for this context.","unbind(path)","This function deletes a name binding in the present timescape. It fails if path does not exist.","alias(path, contextPath, name)","This function copies a binding to a new one. Future changes to either are completely independent. It fails if: source path does not exist, context does not exist, name already exists in context, the name contains the separator for this context, or if the source and destination paths are in different namespaces.","link(path, contextPath, name)","This function creates a link to an existing object. It has the same semantics as a Unix hard link. Any future modifications (e.g., the function setAttributes) to any link will also apply to all links. It fails if: source path does not exist, context does not exist, name already exists in context, the name contains the separator for this context, or if the source and destination paths are in different namespaces.","rebind(path, contextPath, name)","This function renames (moves) an existing name binding. This is essentially a link followed by an unbind of the source path. History is maintained across the rebind. It fails if: source path does not exist, context does not exist, name already exists in context, the name contains the separator for this context, or if the source and destination paths are in different namespaces.","setAttribute(path, key, value [,collectable])","This function sets or creates an attribute key\/value pair for a binding. If the optional Boolean parameter collectable is true (default is false), the garbage collector will notify an application when such attributes are no longer accessible (see discussion below). It fails if the path does not exist.","setAttributes(path, pairs)","This function sets or creates multiple attribute key\/value pairs for a binding. It fails if the path does not exist.","deleteAttribute(path, key)","This function deletes an attribute key\/value pair from a binding if it exists. It fails if the path does not exist.","resolve(path [,timescape])Boolean","This function resolves a pathname and returns whether it exists in this timescape. The timescape parameter is optional, and if omitted, the path name will be resolved by searching all bindings that are active at the current time. That is, the resolve function defaults to the present timescape. If, on the other hand, a date\/time value in the past is supplied for the timescape parameter, the path resolution will take place at the given date and time, and the function will return True only if the given path existed at that moment in the past.","list(path [,timescape] [,offset] [,limit]) {names}","This function returns all the name bindings in a context. Syntactically, this means return all the simple names for which path is a prefix. If a timescape parameter is used, the names returned are the ones that existed at the given date and time. The optional parameters offset and limit are used to access a potentially large list of names in manageable \u201cchunks.\u201d For example, if offset=1000 and limit=100, the procedure will return up to 100 names beginning with the 1000th. It fails if the path does not exist.","history(path [,timescape]) {changes}","This function returns the modification history of the object named by path in this timescape. The history is always a complete one, so it will generally include modifications made before and after timescape, if any. The optional parameters offset and limit are as above. It fails if the path does not exist.","getAttribute(path, key [,timescape]) value","This function returns the attribute value of the given key for the given path in this timescape.","getAttributes(path, [,prefix] [,timescape] [,offset] [,limit]){pairs}","This function returns all attributes for the given path in this timescape. If a prefix string is supplied, only those attributes whose keys begin with the prefix are returned. The optional parameters offset and limit are as above.","getAttributeKeys(path [,timescape] [,offset] [,limit]) {keys}","This function returns the keys of all the attributes for the given path in this timescape. The optional parameters offset and limit are as above.","getLinkCount(path, [,timescape])count","This function returns the number of links to the object named by path in this timescape. It fails if the path does not exist.","lock(path, type, pid, timeout)","This function requires a namespace lock on the name specified bypath. The type and pid parameters can be any strings. They are intended to represent the lock type (e.g., \u201cwrite\u201d) and the process identification of the acquirer. The namespace will automatically expire (release) the lock if it has not been explicitly released by timeout seconds. If the lock already exists and the pid is the same, the timeout value may be adjusted (a process can change the expiration time of its own locks if desired). It fails if the path does not exist or if there is an existing lock on path with the same type but with a different pid.","unlock(path, type, pid)","This function releases a namespace lock on the name specified by path. It fails if: the path does not exist, there is no existing lock with the given path and type, or if the lock belongs to a different pid.","garbage(namespace [,timescape] [,offset] [,limit]){pairs}","This function returns a list of collectable attributes (see discussion in setAttribute above) key\/value pairs that are no longer accessible via any name in the namespace, past, present or future. The optional parameters offset and limit are as above. It fails if namespace does not exist.","To further illustrate the intended semantics of the name binding methods above, here is a sequence of namespace calls along with the name graph transformations resulting from each.",{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0093","num":"0092"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0095","num":"0094"},"figref":"FIG. 11","b":"5"},{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 13"},"All operations listed in the namespace Write Operations section above operate on the current state of the namespace (the \u201cpresent timescape\u201d), as do the default variants of the namespace Read Operations. As modifications are made to the namespace, the state of each name binding is saved, after being time stamped with the modification date and time (the \u201cend date\u201d). Read operations can also be given a timescape parameter, a date\/time value in the past, to access information about name bindings as they once appeared. Each name binding has a start date, which is the date and time the binding first became effective, and possibly an end date, which is the date and time the binding was changed or deleted.","For example, suppose a new name binding for \u201cgreen\u201d is created in the context of object u at time t. The name binding for this might look like:","(u, \u201cgreen\u201d, u, start=t)","Any namespace operation that changes a binding will create a new copy of it and fill in the end date for the copy, thus making a historical record of the old binding. Suppose, for example, the above binding is updated using bind(\u201cgreen\u201d, u) at time t. A new binding will be made and the original will be modified as indicated in the bind( ) operation. The result will be two bindings, one current and one historical.","(u, \u201cgreen\u201d, u, start=t, end=t)","(u, \u201cgreen\u201d, u, start=t)","Now suppose the new binding is further modified using rebind(\u201cgreen\u201d, \u201cblue\u201d) to change its name at time t. A second historical binding will be created to record this event and the original will again be modified as the operation commands.","(u, \u201cgreen\u201d, u, start=t, end=t)","(u, \u201cgreen\u201d, u, start=t, end=t)","(u, \u201cblue\u201d, u, start=t)","It is preferred that the historical binding be a copy of the original, while the original is modified according to the namespace operations. This technique allows us to produce modification histories (see below) of a name binding.","Namespace read operations such as list( ) can obtain information about historical name bindings if the optional \u201cdatetime\u201d parameter is included. For example, the call list(\u201chome\/jim\u201d, datetime=t) would return all the name bindings emanating from home\/jim for which start>=t and end<t. Historical bindings that have been \u201cend-dated\u201d will be retained by the name space for some configurable period of time, and then they will be permanently deleted using garbage collection. In affect, it is possible to go back in time using this mechanism, but only up to a certain point.","In addition to being able to see name bindings as they existed in the past, it may be necessary to view all the changes made to a name, for example, to recover a previous revision of a document that has been updated several times and moved from one subdirectory to another. The history( ) method allows this. When a new name binding is created with either create( ), alias( ), or link( ), a unique binding identity is assigned to it, which we refer to as the \u201cbinding unique identifier\u201d or buid. Subsequent changes to the name binding using bind( ) (update), rebind( ) (rename), unbind( ) (delete), or setAttributes( ) will cause the binding to retain the original buid, while the new, end-dated, historical binding will also use the same buid. The history( )method simply returns all the bindings, past, current, or future, that have the same buid as the given name.","Strictly speaking, the namespace does not require a locking mechanism in order to ensure consistency of the name bindings, since all operations are atomic and stateless. The namespace, however, provides a general locking mechanism to support client applications, notably the CFS application, that do need to lock a name binding for certain purposes, for example, to implement write locks so that two processes cannot have the same file open for writing at the same time. The namespace itself doesn't assign any meaning to these locks, i.e., all namespace operations are always available to any client. Lock semantics and enforcement are strictly a matter of voluntary cooperation among client applications of the namespace.",{"@attributes":{"id":"p-0112","num":"0111"},"figref":["FIGS. 14-16","FIG. 14"],"b":["310","1","2","3","4","4","4","20","4"]},{"@attributes":{"id":"p-0113","num":"0112"},"figref":"FIG. 15","b":["320","160","320","310","322","324","326","328","330"]},"Column  refers to the path traversal direction used by the name in the context of the entire pathname. For example, file system path names generally are consistent in that as the name is traversed from left to right the location of the computer file becomes more specific (e.g., \u201chome\u201d followed by \u201cdocuments\u201d followed by \u201cbrochure.pdf\u201d). Other path name schemes become more specific as the name is traversed from right to left, e.g., johndoe@companyX.com. And some path names, such as URLs, combine a bit of both. Therefore, the \u201cdirection\u201d field of each binding row in the bindings table allows the namespace to specify in which direction is the \u201cname\u201d becoming more specific. For example, typical file names represented in the namespace would all have a direction of \u201cleft\u201d because they become more specific when traversed from left to right. Conversely, e-mail addresses will have a direction of \u201cright.\u201d Path names such as URLs referring to digital objects may have a combination of bindings of both \u201cleft\u201d and \u201cright.\u201d","Column  indicates the separator used between names in a particular path name scheme. For example, Apple file names typically use a \u201c\/\u201d as a separator between names in a path name for a computer file. Other commonly used separators are: \u201c\\\u201d used in Windows file systems, \u201c:\u201d used in some Apple Macintosh file systems, \u201c.\u201d used in IP addresses and to delineate top-level domain names, \u201c@\u201d used in email addresses, \u201c-\u201d used to separate the parts of telephone numbers, and others. The separator in a binding row refers to the separator used immediately preceding or immediately following the name in the path name of the digital object, depending on the direction of the separator.","There is no further pertinent information in the bindings table.","The first row of bindings table  indicates that the bind function has been used to bind object  to object  using a name of \u201cA.\u201d The binding was created on a particular date at 8:34 a.m. and 16 seconds. Although dates are not shown in this column for ease of explanation, typically column  includes the date and the time down to the nearest second. If object  does not exist when the bind function is called then the object is created at that time. The second and third rows illustrate the results of similar calls to bind. The fourth row shows the result of a link function call that links object  to the pre-existing object . The values for the \u201cend date\u201d column are set to a distant time in the future (such as year 4,000) to indicate that the binding is still in existence. Thus, it can be seen that rows in the bindings table are built up for a particular namespace as objects and links are added to the namespace. As explained below, a client application may then use an existing name graph, by referencing its bindings in the bindings table, to retrieve a digital object from storage cluster  using any of a wide variety of different path name schemes.",{"@attributes":{"id":"p-0118","num":"0117"},"figref":"FIG. 16","b":["360","160","4","20"]},"In the present implementation, the attribute named UUID is a universally unique identifier used by the CAStor software and its value is a randomly generated number having 128 bits. The second row indicates that object  has an attribute called \u201cmode\u201d and its value is the one stored in row  of the table.","Other attributes such as \u201cuser identifier\u201d and \u201cgroup identifier\u201d can be used to store arbitrary metadata about the digital object.","As with the bindings table, the attributes table provides a start date and an end date for each attribute of each object. These dates allow for timescape functionality identical to that described for bindings above. In particular, the namespace can provide a full set of attributes and their values for any digital object as some arbitrary date in the past. Attributes of objects are determined by the client application and any attributes and values may be stored depending upon the needs of the client application. For example, attributes may represent metadata associated with digital objects in storage cluster . As shown in , a useful attribute is the universally unique identifier that allows a client application to retrieve the digital object from the storage cluster.","One embodiment of the present invention stores a digital object in the storage cluster and creates a representation in the namespace that takes into account the preferred pathname scheme used by the client application. As discussed above, client applications use a variety of path name schemes for referring to digital objects. URLs are typically in the form of: \u201cwww.company.com\/folder\/blue\u201d (general to specific flows in different directions within this path). URIs are of the form: \u201cftp:\/\/\u201d or \u201cfile:\/\/home\/Fred\/file.txt\u201d. IP addresses have the form: \u201c192.168.1.1\u201d. Apple computers have file names of the form: \u201chome:green:blue,\u201d while computers running the Microsoft operating system have file names of the form: \u201c\\home\\green\\blue.\u201d Thus, path name schemes are different in that they use different syntax, but are similar in that they use certain delimiters to separate names within the path name, and, consistently progress from the general to the specific, from the specific to the general, or use a predictable mixture of both. Therefore, the present invention represents these names, delimiters and direction of specificity in a namespace to allow syntactic generality. In other words, any client application, no matter which pathname scheme it uses, will be allowed to store, manage and retrieve the same digital object to which another client application refers to using an entirely different pathname scheme.",{"@attributes":{"id":"p-0123","num":"0122"},"figref":"FIG. 17","b":["410","1","2","3","4","1","5","6","4","4","20"]},{"@attributes":{"id":"p-0124","num":"0123"},"figref":"FIG. 18","b":["422","110","120","60","1","426"]},"In step  the CFS (or the client application if accessing the namespace directly) calls the namespace with the bind function and the first name \u201chome,\u201d and the appropriate delimiter and direction, in order to create binding . New object  is also created at this time. In response, the namespace creates a row in the bindings table in order to represent this new binding. Similarly, steps  and  call the bind function with the names \u201cJohn\u201d and \u201cmyemail.txt\u201d in order to create objects  and , and the bindings  and , respectively. At this point, a name graph has been created with objects , ,  and , with object  uniquely representing the digital object \u201cmyemail.txt.\u201d Next, step  writes this file to the storage cluster and the storage cluster returns a unique identifier or a universally unique identifier. Finally, in step  the CFS creates an attribute \u201cUUID\u201d (for example) and sets this attribute equal to the returned unique identifier for object  in namespace . As mentioned above, the client application may create any suitable attribute for any object, although none are required. Consequently, the namespace now provides a path using a particular pathname scheme to object  that holds the unique identifier for the computer file stored in storage cluster .",{"@attributes":{"id":"p-0126","num":"0125"},"figref":"FIG. 19","b":["4","130"]},"In step  the client application  requests that the namespace create a new path using the pathname \u201cJohn@company.com,\u201d which is then linked to an existing object in step . The namespace link function links the newly formed pathname, \u201cJohn@ company.com\u201d to the exact same object that is currently named by the path \u201c\/home\/John\/myemail.txt,\u201d which in this example is object . A namespace link is similar in construction and use to a \u201chard link\u201d in Unix-like file systems.","Preferably, the client application parses the entire pathname in order to provide to the namespace each portion of the pathname (in increasing specificity) and the delimiter preceding each name. In this example, the client application parses the pathname to obtain the names in increasing specificity as follows: \u201ccom,\u201d \u201ccompany,\u201d and \u201cJohn.\u201d","In step  the client application calls the namespace with the bind function and the first name \u201ccom,\u201d and the appropriate delimiter and direction, in order to create binding . New object  is also created at this time. In response, the namespace creates a row in the bindings table in order to represent this new binding. Similarly, step  calls the bind function with the name \u201ccompany\u201d in order to create object  and the binding . Next, the client application calls the link function passing as arguments the existing path to object , the current path to object , and the name \u201cJohn\u201d in order to create binding . At this point, a new path has been created with objects , ,  and ; object  still uniquely represents the digital object \u201cmyemail.txt\u201d by virtue of this object holding the attribute UUID and its value. Therefore, two different client applications now each have a different path using a different pathname scheme to the same object within the namespace. This object  holds the attribute UUID that provides a unique identifier for the digital object within the storage cluster.","Of course, once a namespace has been built as discussed above (and one or more pathnames lead to a particular object holding the unique identifier for a particular file in the storage cluster), it is possible for any client application to retrieve that unique identifier using any of the various pathnames. Once the unique identifier is retrieved from the namespace, it may be used to access a particular digital object in the storage cluster. For example, a Unix client application that wishes to retrieve the computer file \u201cmyemail.txt\u201d may do so by calling a namespace function as follows:","GetAttr(UUID, \/home\/John\/myemail.txt).","This \u201cget attribute\u201d function will return the universally unique identifier based upon the Unix style pathname provided. The UUID may then be used to retrieve the computer file from the storage cluster. To execute this function call, the namespace receives the Unix pathname and walks down the left-hand side of name graph  (using the information in the bindings table) until it reaches object . Then, it accesses the attributes table for object  to retrieve the value for attribute name \u201cUUID.\u201d","Now consider an e-mail program client application that wishes to retrieve the same computer file but using its own different pathname. It would call the namespace function as follows:","GetAttr(UUID, John@company.com).","Note that the e-mail program is allowed to use its own pathname scheme but the end result is that it will retrieve the same universally unique identifier and will then be able to retrieve the same exact computer file from the storage cluster. To execute this function call, the namespace receives the e-mail pathname and walks down the right-hand side of name graph  (using the information in the bindings table) until it reaches object . Then, it accesses the attributes table for object  to retrieve the value for attribute name \u201cUUID.\u201d",{"@attributes":{"id":"p-0136","num":"0135"},"figref":["FIG. 20","FIG. 20"],"b":"6"},"Thus, the namespace is able to take an entire pathname of whatever kind used by the client application and, as long as a path according to that pathname scheme has previously been represented in the namespace, the namespace will return any desired attribute associated with any particular object. In this example, client applications are able to use their own pathname scheme in order to refer to the same digital object stored in a storage cluster.","As mentioned above, any client application, such as clients -, may access the namespace using its own particular pathname scheme, yet be assured each path refers to the same digital object. In the example of , two different pathnames from two different client applications both lead to object  which holds, for example, an attribute of UUID which has a universally unique identifier value that identifies a single digital object within storage cluster . As attributes table  holds all attributes for all objects, and is accessible to any client application wishing to read or set an attribute of a particular object, the namespace and its objects and attributes are essentially shared between all client applications. A client application changing a particular attribute for a particular object will have this change also viewable by any other client application. In the example used herein, where an object represents a digital object in the storage cluster (e.g., object  of  holds the UUID for the file \u201cmyemail.txt\u201d stored in the storage cluster), this means that digital objects and changes to digital objects (and their metadata) are also shared between all client applications.","For example, if one client application wishes to modify a computer file stored in the storage cluster and have all other client applications reference the modified file, it may do so. The client application first modifies the computer file, stores it in the storage cluster, receives a new UUID, and then executes the following namespace function: SetAttr(UUID, <path>, new UUID). The result is that this set attribute function will find the particular object specified by \u201cpath\u201d (e.g., object  via the left-hand pathname), and change the attribute UUID to be the new UUID value. Thus, any other client application referencing object  (e.g., a client application using the right-hand pathname) will retrieve the new UUID value when accessing the UUID attribute and will be able to retrieve the modified computer file in the storage cluster.","Of course, any attribute changed for a particular object will be seen by any of the client applications accessing that object. A client application may change the metadata for a particular digital object stored in the storage cluster by changing a particular attribute for object , for example. Examples of metadata that a client application may change include: modification date, permissions, access control lists, object size, keywords, and so on.","As mentioned above, implementation of the namespace of the present invention results in virtually a continuous backup of digital objects stored within a storage cluster and continuous backup of any of their associated attributes stored in the attributes table of the namespace. Of course, the storage cluster must ensure that all versions of digital objects are retained for a period of time over which a continuous backup is desired and the namespace must ensure that attributes and their values are retained during that period of time as well. The namespace is able to implement the continuous backup feature using a combination of particular function calls and use of the start date and end date field of the bindings and attributes tables.",{"@attributes":{"id":"p-0142","num":"0141"},"figref":["FIG. 21","FIG. 17","FIG. 19"],"b":["504","4","4"]},"Next, in step  the client application calls the namespace with the unbind function passing in the context, object , and the name of the binding to be removed \u201cJohn.\u201d In order to indicate that the file has been \u201cdeleted\u201d (at least as far as the e-mail program is concerned), in step  the namespace simply modifies a row in the bindings table to provide an \u201cend date\u201d for the binding \u201cJohn.\u201d For example, before deletion, the row in the bindings table might have appeared thus: \u201c6 John 4 1\/1\/2009:08:36:00 4,000.\u201d This row indicates that the binding  was created on Jan. 1, 2009 and, at the time of creation, it had an end date of more or less infinity (the direction and separator fields have been left off for clarity). Assuming that the client application deletes the configuration file at 10 a.m. on that date, the bindings row would appear as follows after deletion: \u201c6 John 4 1\/1\/2009:08:36:00 1\/1\/2009:10:00:00.\u201d Note that all that has happened is that an end date of 10 a.m. has been provided for this binding. The binding has not actually been removed from the namespace; object , and the configuration file, continue to exist in the namespace and in the storage cluster, respectively. Therefore, any client application having a path to object  (and thus to the configuration file) will continue to do so. The e-mail program previously using the pathname \u201cJohn@company.com\u201d will not be able to access the configuration file because the binding  has been effectively removed by providing an end date in the bindings table.","When accessing objects and bindings in the namespace the namespace will assume a time of the current time and will not recognize any binding for which the current time does not fall within the start date and the end date. For example, should the e-mail program attempt to access the configuration file at 11 a.m. on Jan. 1, 2009, such an access will fail because 11 a.m. is after the end date time for that binding of 10 a.m. By contrast, the e-mail program may access the configuration file as it existed in the past as long as it provides a past time parameter falling between the start date and the end date for binding . The namespace simply compares the input time parameter to the start date and end date. By default, the namespace assumes the time parameter is the current time. Of course, should the e-mail program attempt to access the configuration file in the past by providing a time before Jan. 1, 2009 at 8:36 a.m., such an access will also fail because the namespace will determine that the provided time in the past is before the start date time for that particular binding.","Note that during the process of  the attributes for object  stored in the attributes table do not change because it is only the binding  that is being provided with an end date in the bindings table; none of the attributes for object  are being changed or deleted. Attributes are not changed or deleted during this process because another client application may be using the object and because the attributes and their values should be retained for historical access to the configuration file as it existed in the past.",{"@attributes":{"id":"p-0146","num":"0145"},"figref":"FIG. 22"},"In step  a client application determines a particular computer file and an attribute of that file that it wishes to change. Preferably, the client application determines the pathname referencing that file in the namespace (previously set up) and the attribute that it wishes to change. In one example, the client simply wishes to modify a metadata attribute for a particular computer file without changing the file itself. Or, the client has modified the computer file and received a new UUID from the storage cluster referencing the new version of the file. Accordingly, this new UUID must be used to replace the old UUID attribute in the object in the namespace that represents the computer file.","In step  the client application calls the namespace with the set attribute function passing in the name of the attribute to be changed (such as UUID), the pathname to the desired object in the namespace, and the new value of the attribute to be changed. In step  the namespace attempts to find the object in the namespace using the provided pathname. It is possible that the object does not exist (never did exist or has been deleted). If not, in step  the process ends. If the object is found, in step  the attributes table is searched for a row corresponding to that particular object and the attribute name that has been passed in the set attribute function call. If the current time does not fall within the range of the start date and the end date for that particular attribute (the attribute is not \u201clive\u201d) then the process ends because the attribute for that object has previously been deleted and cannot be changed.","Once found, the \u201clive\u201d attribute row is copied in step  to produce an identical new row for that same object and attribute in the attributes table. In step  an end date for the original row is supplied (using the current time) indicating that the old value for the attribute has existed up until the current time when it has been changed. In step  the start date for the new row with the new value for the attribute is set to the current time, and the end date is set to an infinity value. Next, in step  the new value for the attribute is inserted into the value field for the new row. Accordingly, the old value for the attribute is retained in the attributes table and its time of existence is accurately reflected using the start date and end date in that original row. The new attribute value is reflected in its own row in the attributes table with a start date indicating when it came into existence. In this fashion, a client application may modify a file in the storage cluster and change the UUID attribute for the corresponding object in the namespace, thus indicating that the new file has come into existence at a particular time, yet still retaining the old value of the UUID should a client application desire to view the original version of the file at a time prior to its being changed. In other words, old versions of attributes are not deleted, but are retained with appropriate start and end dates.",{"@attributes":{"id":"p-0150","num":"0149"},"figref":"FIG. 23"},"In step  a client application determines a particular computer file and an attribute of that file that it wishes to retrieve. Preferably, the client application determines the pathname referencing that file in the namespace (previously set up) and the attribute it desires. In one example, the client simply wishes to retrieve a metadata attribute for a particular computer file without retrieving the file itself. Or, the client wishes to retrieve a version of the file as it existed at a particular point in the past and will need to retrieve the UUID attribute of that old version in order to retrieve the version from the storage cluster.","In step  the client application calls the namespace with the get attribute function passing in the name of the attribute to be retrieved (such as UUID), the pathname to the desired object in the namespace, and the time for when that attribute is believed to have existed. The time may be supplied down to the second, which provides virtually a continuous ability to retrieve files and attributes as they existed in the past.","In step  the namespace attempts to find the object in the namespace using the provided pathname. It is possible that the object never did exist in which case the desired path would not exist. If so, in step  process ends. The namespace traverses the name graph looking for each portion of the pathname in turn (using the bindings table) and ensuring that the time provided is between the start date and end date for each binding it is traversing. In the example of , the namespace would only reach object  if it is determined that bindings - were in existence during the time value provided. If so, the process moves to step  having found object , for example.","The attributes table is searched for a row corresponding to that particular object and the attribute name that has been passed in the get attribute function call. If the provided time value does not fall within the range of the start date and the end date for that particular attribute, this indicates that the desired attribute did not exist at that point in time in the past and the process ends. If the attribute did exist at that point in time, then its corresponding attribute value is returned to the client application in step . Optionally, if the attribute desired is a UUID for a digital object that existed at a particular time, then in step  the client application uses this identifier to access the storage cluster and retrieve the digital object as it is existed at that point in time.","In this fashion, a client application may retrieve a file in the storage cluster as it existed at any time in the past down to the nearest second. This embodiment thus provides near continuous backup capability without the need for the storage cluster or client application to provide discrete backups or discrete snapshots of the system at a particular time.","When unbind( ) is called on a name binding, we cannot immediately forget the ObjectID to which it refers because there may still be other names (aliases and links) to the same object. Even if there are no other names, we still cannot forget the ObjectID because the date effectivity mechanism will, in general, still allow historical access to the object through name bindings that are no longer current. Since the namespace does not assign any semantics to an ObjectID, there are really no resources associated with an object that needs to be released, except the name bindings that refer to it of course. Client applications, like the CFS application, will want to know when an object can no longer be accessed through the namespace in any way whatsoever, since knowing that would allow the clients to, for example, delete the object from the fixed-content storage cluster . This is generally called \u201cgarbage collection\u201d and there are several standard algorithms for dealing with it. Of course, the namespace does not really collect anything, it merely identifies a set of ObjectIDs that can no longer be named in any way. The garbage( ) method returns such a list and allows client applications to deal with the ObjectIDs in whatever way they wish.","The representation of the namespace also present advantages. As described and shown herein, a name graph of the namespace can be broken down into many different bindings i.e., tuples. This representation allows the namespace to be stored within a RAIN by replicating and spreading the bindings across different nodes of the RAIN. The bindings are simply broken apart, replicated and stored on different nodes. Symmetric, distributed algorithms put the pieces back together in order to resolve a pathname to a given object. In another embodiment, the namespace is implemented on a RAIN cluster, thus providing for the distribution of bindings across the cluster.",{"@attributes":{"id":"p-0158","num":"0157"},"figref":["FIGS. 24A and 24B","FIG. 24A"],"b":["900","900","902","904","906","908","910","912","914","900"]},{"@attributes":{"id":"p-0159","num":"0158"},"figref":"FIG. 24B","b":["900","920","922","924","924","926","922","926","926","924","914"]},"CPU  is also coupled to a variety of input\/output devices such as display , keyboard , mouse  and speakers . In general, an input\/output device may be any of: video displays, track balls, mice, keyboards, microphones, touch-sensitive displays, transducer card readers, magnetic or paper tape readers, tablets, styluses, voice or handwriting recognizers, biometrics readers, or other computers. CPU  optionally may be coupled to another computer or telecommunications network using network interface . With such a network interface, it is contemplated that the CPU might receive information from the network, or might output information to the network in the course of performing the above-described method steps. Furthermore, method embodiments of the present invention may execute solely upon CPU  or may execute over a network such as the Internet in conjunction with a remote CPU that shares a portion of the processing.","In addition, embodiments of the present invention further relate to computer storage products with a computer-readable medium that have computer code thereon for performing various computer-implemented operations. The media and computer code may be those specially designed and constructed for the purposes of the present invention, or they may be of the kind well known and available to those having skill in the computer software arts. Examples of computer-readable media include, but are not limited to: magnetic media such as hard disks, floppy disks, and magnetic tape; optical media such as CD-ROMs and holographic devices; magneto-optical media such as floptical disks; and hardware devices that are specially configured to store and execute program code, such as application-specific integrated circuits (ASICs), programmable logic devices (PLDs) and ROM and RAM devices. Examples of computer code include machine code, such as produced by a compiler, and files containing higher-level code that are executed by a computer using an interpreter.","Although the foregoing invention has been described in some detail for purposes of clarity of understanding, it will be apparent that certain changes and modifications may be practiced within the scope of the appended claims. Therefore, the described embodiments should be taken as illustrative and not restrictive, and the invention should not be limited to the details given herein but should be defined by the following claims and their full scope of equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention, together with further advantages thereof, may best be understood by reference to the following description taken in conjunction with the accompanying drawings in which:",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3","b":["1","2"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7","b":["1","5"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 11","b":"5"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIGS. 24A and 24B"}]},"DETDESC":[{},{}]}
