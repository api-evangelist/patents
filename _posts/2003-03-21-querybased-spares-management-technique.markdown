---
title: Query-based spares management technique
abstract: A query-based spares management technique enables a storage operating system of a storage system to select disks to be added to one or more RAID groups of a volume. The spares management technique includes an attributes-based disk selection procedure that is performed by the storage operating system in response to an operator-initiated request to add disks to the volume or in response to a demand-driven request resulting from a requirement imposed by the system to add disks to the volume. The disks that are added to the RAID groups of the volume are retrieved from one or more spare pools of disks maintained by the storage system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07664913&OS=07664913&RS=07664913
owner: NetApp, Inc.
number: 07664913
owner_city: Sunnyvale
owner_country: US
publication_date: 20030321
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"p":["CROSS-REFERENCE TO RELATED APPLICATION","The present invention is related to the following commonly assigned U.S. patent application Ser. No. 10\/394,810 titled, Technique for Managing Addition of Disks to a Volume of a Storage System, which was filed on even date herewith and is now issued as U.S. Pat. No. 7,424,637 on Sep. 9, 2008 and which application is hereby incorporated by reference as though fully set forth herein.","The present invention relates to storage systems and, more specifically, to a technique for managing the selection of disks for addition to a volume of a storage system.","A storage system typically comprises one or more storage devices into which data may be entered, and from which data may be obtained, as desired. The storage system includes a storage operating system that functionally organizes the system by, inter alia, invoking storage operations in support of a storage service implemented by the system. The storage system may be implemented in accordance with a variety of storage architectures including, but not limited to, a network-attached storage environment, a storage area network and a disk assembly directly attached to a client or host computer. The storage devices are typically disk drives organized as a disk array, wherein the term \u201cdisk\u201d commonly describes a self-contained rotating magnetic media storage device. The term disk in this context is synonymous with a hard disk drive (HDD), a direct access storage device (DASD) or a logical unit number (lun) in a storage device.","Storage of information on the disk array is preferably implemented as one or more storage \u201cvolumes\u201d, defining an overall logical arrangement of disk space. The disks within a volume are typically organized as one or more groups, wherein each group is operated as a Redundant Array of Independent (or Inexpensive) Disks (RAID). Most RAID implementations enhance the reliability\/integrity of data storage through the redundant writing of data \u201cstripes\u201d across a given number of physical disks in the RAID group, and the appropriate storing of redundant information with respect to the striped data. The redundant information may thereafter be retrieved to enable recovery of data lost when a storage device fails.","In the operation of a disk array, it is anticipated that a disk can fail. A goal of a high performance storage system is to make the mean time to data loss as long as possible, preferably much longer than the expected service life of the system. Data can be lost when one or more disks fail, making it impossible to recover data from the device. Typical schemes to avoid loss of data include mirroring, backup and parity protection. Mirroring stores the same data on two or more disks so that if one disk fails, the \u201cmirror\u201d disk(s) can be used to serve (e.g., read) data. Backup periodically copies data on one disk to another disk. Parity schemes are common because they provide a redundant encoding of the data that allows for loss of one or more disks without the loss of data, while requiring a minimal number of disk drives in the storage system.","Parity protection is often used in computer systems to protect against loss of data on a storage device, such as a disk. A parity value may be computed by summing (usually modulo 2) data of a particular word size (usually one bit) across a number of similar disks holding different data and then storing the results on the disk(s). That is, parity may be computed on 1-bit wide vectors, composed of bits in predetermined positions on each of the disks. Addition and subtraction on 1-bit vectors are an equivalent to exclusive-OR (XOR) logical operations; these addition and subtraction operations can thus be replaced by XOR operations. The data is then protected against the loss of any one of the disks, or of any portion of the data on any one of the disks. If the disk storing the parity is lost, the parity can be regenerated from the data. If one of the data disks is lost, the data can be regenerated by adding the contents of the surviving data disks together and then subtracting the result from the stored parity.","Typically, the disks are divided into parity groups, a common arrangement of which comprises one or more data disks and a parity disk. The disk space is divided into stripes, with each stripe containing one block from each disk. The blocks of a stripe are usually at equivalent locations on each disk in the parity group. Within a stripe, all but one block contain data (\u201cdata blocks\u201d) with the one block containing parity (\u201cparity block\u201d) computed by the XOR of all the data. If the parity blocks are all stored on one disk, thereby providing a single disk that contains all (and only) parity information, a RAID-4 level implementation is provided. If the parity blocks are contained within different disks in each stripe, usually in a rotating pattern, then the implementation is RAID-. The term \u201cRAID\u201d and its various implementations are well-known and disclosed in (RAID), by D. A. Patterson, G. A. Gibson and R. H. Katz, Proceedings of the International Conference on Management of Data (SIGMOD), June 1988.","Often other types of parity groupings are supported by a storage system. For example, a RAID-0 level implementation has a minimum of one data disk per parity group. However, a RAID 0 group provides no parity protection against disk failures, so loss of a single disk translates into loss of data in that group. A row-diagonal parity implementation has two parity disks per group for a minimum of three disks per group, i.e., one data and two parity disks. An example of a row-diagonal (RD) parity implementation is described in U.S. Pat. No. 6,993,701, issued on Jan. 31, 2006 titled, and filed Dec. 28, 2001. A RD parity group can survive the loss of up to two disks in the RAID group.","The storage operating system of the storage system typically includes a RAID subsystem that manages the storage and retrieval of information to and from the disks in accordance with input\/output (I\/O) operations. In addition, the storage operating system includes administrative interfaces, such as a user interface, that enable operators (system administrators) to access the system in order to implement, e.g., configuration management decisions. Configuration management in the RAID subsystem generally involves a defined set of modifications to the topology or attributes associated with a storage array, such as a disk, a RAID group, a volume or set of volumes. Examples of these modifications include, but are not limited to, disk failure handling, volume splitting, volume online\/offline, changes to (default) RAID group size or checksum mechanism and disk addition.","Typically, the configuration decisions are rendered through a user interface oriented towards operators that are knowledgeable about the underlying physical aspects of the system. That is, the interface is often adapted towards physical disk structures and management that the operators may manipulate in order to present a view of the storage system on behalf of a client. For example, in the case of adding disks to a volume, an operator may be prompted to specify (i) exactly which disks are to be added to a specified volume, or (ii) a count of the number of disks to add, leaving the responsibility for selecting disks up to the storage operating system.","A prior approach to selection of disks involves interrogation of all disks coupled to the storage system using the storage operating system. Broadly stated, the operating system issues a broadcast message to which each disk responds with its name, its location and its attributes, such as the size of the disk and supported checksum style and sector size. An ordered list of disk is then created based on the sequence in which the disks respond. Disks are thereafter allocated for disk selection in the order defined by the list, e.g., from top to bottom of a disk shelf. Moreover, selection of a disk is based only on size, checksum style and format block size considerations, without regard to physical locality of the disk for, e.g., fault isolation.","However, it may be desirable for the storage operating system to factor other issues into the selection of disks, based upon the disk attributes of sector size, selected checksum algorithm and disk size. For example, a mirrored volume requires the balanced addition of disks to each of the N-plexes of the mirror. The same number of disks, with the same sector size, selected checksum algorithm and disk size, must be added to each mirror plex simultaneously.","The present invention overcomes the disadvantages of the prior art by providing a query-based spares management technique that enables a storage operating system of a storage system to select disks to be added to one or more RAID groups of a volume. The spares management technique includes a disk addition (DISKADD) selection process that is implemented by the storage operating system in response to an operator-initiated request to add disks to the volume or in response to a demand-driven request resulting from a requirement imposed by the system to add disks to the volume. The disks that are added to the RAID groups of the volume are retrieved from one or more spare pools of disks maintained by the storage system.","In the illustrative embodiment, discovery and label assimilation processes are used to place disks into the spare pools. The DISKADD selection process determines a set of disks to add to one or more RAID groups of the volume. The DISKADD selection process cooperates with a select-query-allocate (SQA) application programming interface (API) and an associated SQA manager process to determine the set of disks to allocate, as well as to optimize the order in which the disk are allocated. These processes further utilize a policy mechanism with changeable fine-grained elements of policy to provide the query-based spares management technique of the present invention.","Specifically, the SQA API enables interaction between the spare pools and a configuration tree of a RAID subsystem having a plurality of objects representing the RAID groups of the volume. The SQA API is embodied as a layer of code between one or more objects (e.g., DISKADD object) of the configuration tree and one or more objects of the spare pools. The object of the spare pool is embodied as a spare disk manager (DMGR) object that is responsible for managing the disks in each spare pool. The SQA manager is responsible, in part, for the behavior of the DMGR object.","The DISKADD selection process forms attribute-based selection query requests based upon its evaluation of the configuration tree and policy that defines the sequence and criteria for disk selection. The DISKADD selection process utilizes the SQA API to forward the requests to the SQA manager in an attempt to \u201cnarrow down\u201d the choices of disks until it arrives at a point where it is prepared to make an allocation request. The SQA manager evaluates the attribute-based selection query requests, returns count-summary reports in response to the query requests and forwards allocation requests on behalf of the DISKDD object to the DMGR object.","According to the invention, an attribute set of the query-based spares management technique comprises a plurality of steps, each of which may have an associated element of policy. These elements of policy cooperate to produce a fine granularity of disk selection. One element of policy may be directed to priority ordering of disk attributes considered during disk selection. Another element of policy pertains to locality, wherein locality denotes electrical connectivity for purposes such as, but not limited to, fault isolation or increasing aggregate bandwidth to the volume through connections to the disks. Other elements of policy may pertain to disk selection and allocation attributes, including disk addition and disk replacement policies, each of which is associated with the volume (volume object of the configuration tree). Each volume (volume object) of the storage system may have an attribute set that is different from other volumes in the storage system.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 1","b":["100","120","130","160","120","122","124","126","128","125","120","200"]},"In the illustrative embodiment, the memory  comprises storage locations that are addressable by the processor and adapters for storing software program code and data structures associated with the present invention. The processor and adapters may, in turn, comprise processing elements and\/or logic circuitry configured to execute the software code and manipulate the data structures. Storage operating system , portions of which are typically resident in memory and executed by the processing elements, functionally organizes the system  by, inter alia, invoking storage operations executed by the storage system. It will be apparent to those skilled in the art that other processing and memory means, including various computer readable media, may be used for storing and executing program instructions pertaining to the inventive technique described herein.","The network adapter  comprises the mechanical, electrical and signaling circuitry needed to connect the storage system  to a client  over a computer network , which may comprise a point-to-point connection or a shared medium, such as a local area network. Illustratively, the computer network  may be embodied as an Ethernet network or a Fibre Channel (FC) network. The client  may communicate with the storage system over network  by exchanging discrete frames or packets of data according to pre-defined protocols, such as the Transmission Control Protocol\/Internet Protocol (TCP\/IP).","The client  may be a general-purpose computer configured to execute applications . Moreover, the client  may interact with the storage system  in accordance with a client\/server model of information delivery. That is, the client may request the services of the storage system, and the system may return the results of the services requested by the client, by exchanging packets  over the network . The clients may issue packets including file-based access protocols, such as the Common Internet File System (CIFS) protocol or Network File System (NFS) protocol, over TCP\/IP when accessing information in the form of files and directories. Alternatively, the client may issue packets including block-based access protocols, such as the Small Computer Systems Interface (SCSI) protocol encapsulated over TCP (iSCSI) and SCSI encapsulated over Fibre Channel (FCP), when accessing information in the form of blocks.","The storage adapter  cooperates with the storage operating system  executing on the system  to access information requested by a user (or client). The information may be stored on any type of attached array of writable storage device media such as video tape, optical, DVD, magnetic tape, bubble memory, electronic random access memory, micro-electro mechanical and any other similar media adapted to store information, including data and parity information. However, as illustratively described herein, the information is preferably stored on the disks , such as HDD and\/or DASD, of array . The storage adapter includes input\/output (I\/O) interface circuitry that couples to the disks over an I\/O interconnect arrangement, such as a conventional high-performance, FC serial link topology.","Storage of information on array  is preferably implemented as one or more storage \u201cvolumes\u201d that comprise a collection of physical storage disks  cooperating to define an overall logical arrangement of disk space on the volume(s). Each volume is generally, although not necessarily, associated with its own file system. The disks within a volume\/file system are typically organized as one or more groups, wherein each group is operated as a Redundant Array of Independent (or Inexpensive) Disks (RAID). Most RAID implementations, such as a RAID-4 level implementation, enhance the reliability\/integrity of data storage through the redundant writing of data \u201cstripes\u201d across a given number of physical disks in the RAID group, and the appropriate storing of parity information with respect to the striped data. Although a RAID-4 level implementation is illustratively described herein, it should be understood that other types and levels of RAID implementations may be used in accordance with the inventive principles described herein.","To facilitate access to the disks , the storage operating system  implements a write-anywhere file system that cooperates with virtualization modules to \u201cvirtualize\u201d the storage space provided by disks . The file system logically organizes the information as a hierarchical structure of named directories and files on the disks. Each \u201con-disk\u201d file may be implemented as set of disk blocks configured to store information, such as data, whereas the directory may be implemented as a specially formatted file in which names and links to other files and directories are stored. The virtualization modules allow the file system to further logically organize information as a hierarchical structure of blocks on the disks that are exported as named logical unit numbers (luns).","In the illustrative embodiment, the storage operating system is preferably the NetApp\u00ae Data ONTAP\u2122 operating system available from Network Appliance, Inc., Sunnyvale, Calif. that implements a Write Anywhere File Layout (WAFL\u2122) file system. However, it is expressly contemplated that any appropriate storage operating system including, for example, a write in-place file system, may be enhanced for use in accordance with the inventive principles described herein. As such, where the term \u201cWAFL\u201d is employed, it should be taken broadly to refer to any storage operating system that is otherwise adaptable to the teachings of this invention.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 2","b":["200","210","212","214","216","218","220","222","224","226","218"]},"An iSCSI driver layer  provides block protocol access over the TCP\/IP network protocol layers, while a FC driver layer  receives and transmits block access requests and responses to and from the storage system. The FC and iSCSI drivers provide FC-specific and iSCSI-specific access control to the blocks and, thus, manage exports of luns to either iSCSI or FCP or, alternatively, to both iSCSI and FCP when accessing the blocks on the storage system. In addition, the storage operating system includes a storage device manager embodied as a RAID subsystem  that manages the storage and retrieval of information to and from the volumes\/disks in accordance with I\/O operations, and a disk driver subsystem  that implements a disk access protocol such as, e.g., the SCSI protocol.","Bridging the disk software layers with the integrated network protocol stack layers is a virtualization system that is implemented by a file system  interacting with virtualization modules illustratively embodied as, e.g., vdisk module  and SCSI target module . The vdisk module  is layered on the file system  to enable access by administrative interfaces, such as a user interface (UI) , in response to a user (system administrator) issuing commands to the storage system. The SCSI target module  is disposed between the FC and iSCSI drivers ,  and the file system  to provide a translation layer of the virtualization system between the block (lun) space and the file system space, where luns are represented as blocks. The UI  is disposed over the storage operating system in a manner that enables administrative or user access to various layers and subsystems, such as the RAID subsystem .","The file system is illustratively a message-based system that provides volume management capabilities for use in access to the information stored on the storage devices, such as disks. That is, in addition to providing file system semantics, the file system  provides functions normally associated with a volume manager. These functions include (i) aggregation of the disks, (ii) aggregation of storage bandwidth of the disks, and (iii) reliability guarantees, such as mirroring and\/or parity (RAID). The file system  illustratively implements the WAFL file system having an on-disk format representation that is block-based using, e.g., 4 kilobyte (kB) blocks and using index nodes (\u201cinodes\u201d) to identify files and file attributes (such as creation time, access permissions, size, and block location). The file system uses files to store metadata describing the layout of its file system; these metadata files include, among others, an inode file. A file handle, i.e., an identifier that includes an inode number, is used to retrieve an inode from disk.","Operationally, a request from the client  is forwarded as a packet  over the computer network  and onto the storage system  where it is received at the network adapter . A network driver (of layer  or layer ) processes the packet and, if appropriate, passes it onto a network protocol and file access layer for additional processing prior to forwarding to the file system layer . Here, the file system generates operations to load (retrieve) the requested data from disk  if it is not resident \u201cincore\u201d, i.e., in the memory . If the information is not in memory, the file system  indexes into the inode file using the inode number to access an appropriate entry and retrieve a logical volume block number (VBN). The file system then passes a message structure including the logical VBN to the RAID subsystem , which maps that logical number to a disk block number (DBN) and sends the latter to an appropriate driver (e.g., SCSI) of the disk driver subsystem . The disk driver accesses the DBN from disk  and loads the requested data block(s) in memory  for processing by the storage system. Upon completion of the request, the storage system (and operating system) returns a reply to the client  over the network .","It should be noted that the software \u201cpath\u201d through the storage operating system layers described above needed to perform data storage access for the client request received at the storage system may alternatively be implemented in hardware. That is, in an alternate embodiment of the invention, a storage access request data path may be implemented as logic circuitry embodied within a field programmable gate array (FPGA) or an application specific integrated circuit (ASIC). This type of hardware implementation increases the performance of the storage service provided by storage system  in response to a request issued by client . Moreover, in another alternate embodiment of the invention, the processing elements of adapters ,  may be configured to offload some or all of the packet processing and storage access operations, respectively, from processor , to thereby increase the performance of the storage service provided by the system. It is expressly contemplated that the various processes, architectures and procedures described herein can be implemented in hardware, firmware or software.","As used herein, the term \u201cstorage operating system\u201d generally refers to the computer-executable code operable to perform a storage function in a storage system, e.g., that manages data access and may, in the case of a file server, implement file system semantics. In this sense, the ONTAP software is an example of such a storage operating system implemented as a microkernel and including the WAFL layer to implement the WAFL file system semantics and manage data access. The storage operating system can also be implemented as an application program operating over a general-purpose operating system, such as UNIX\u00ae or Windows NT\u00ae, or as a general-purpose operating system with configurable functionality, which is configured for storage applications as described herein.","In addition, it will be understood to those skilled in the art that the inventive technique described herein may apply to any type of special-purpose (e.g., file server or filer) or general-purpose computer, including a standalone computer or portion thereof, embodied as or including a storage system . Moreover, the teachings of this invention can be adapted to a variety of storage system architectures including, but not limited to, a network-attached storage environment, a storage area network and disk assembly directly-attached to a client or host computer. The term \u201cstorage system\u201d should therefore be taken broadly to include such arrangements in addition to any subsystems configured to perform a storage function and associated with other equipment or systems.","The present invention is implemented in the context of a configuration management framework used to implement the RAID subsystem  in the storage operating system . In a preferred embodiment, the configuration management framework provides an object-oriented approach to RAID configuration management, as described herein with respect to an implementation of the RAID subsystem.  is a schematic block diagram illustrating one or more modules or processes and threads of the RAID subsystem , wherein each process has, among other things, a (virtual) memory address space, executable code and data. A process is started with a single thread, but can create additional threads from any of its threads. The threads execute in the same memory address space and can therefore work concurrently on shared data. For example, an instantiator module implements a configuration (config) thread  adapted to maintain relationships among and invoke behaviors of decomposed software components (\u201cRAID objects\u201d) that collectively form the behaviors associated with a collection of (RAID) volumes on the storage system. In addition, an I\/O manager module implements an I\/O thread  configured to issue I\/O transaction requests from the RAID subsystem to the disk driver subsystem and, upon completion, process the results.","A finite state machine (FSM) module or engine  is used to arbitrate a set of events and states that a process or thread of the RAID subsystem may encounter. Transactional semantics isolate the behavior of state changes in the RAID subsystem from concurrent I\/O operations. The framework provides a two-phase commit procedure, coordinated with updates to on-disk configuration data (\u201clabels\u201d). Errors during disk label updates are handled by aborting the transaction, releasing partially committed data and unwinding any pending state transitions. A state notification mechanism integrated with the FSM engine  propagates state changes through the threads in order to provide a coordinated behavior.","According to the configuration management framework, a volume comprises the aggregate behavior of a number of RAID objects. Each RAID object (\u201cobject\u201d) comprises operational code and static state, such as configuration information, relating to the topology of the underlying physical storage devices, e.g., disks , contained in disk array . The objects are organized into a configuration tree with configuration interfaces defining a set of services provided by one or more processes of the RAID subsystem. Although the objects may be implemented in accordance with an object-oriented programming paradigm, the present invention is not limited to such an implementation. More broadly, the objects of the configuration tree refer to abstract entities representing a logical combination\/configuration of the disks. That is, the objects are used to present a view of the underlying topology of the storage array managed by the RAID subsystem.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 4","b":["400","400"]},"Objects have an associated type, with each object type providing its own implementation of the configuration interfaces. A volume is organized into a hierarchical configuration tree of objects that includes a tree object  responsible for coordinated behavior with the file system and a volume object  responsible for managing the RAID aspects of volume management. Specifically, the volume object  represents the (WAFL) file system at the highest level (i.e., root node) of the configuration tree . To that end, the volume object  stores metadata that describes a volume\/file system, wherein the metadata includes information such as the name of the volume and address range (in physical blocks) of the volume. The name of the volume resides in a volume namespace that is exported by the UI  of the storage operating system . The logical address space of the file system is mapped to the physical (block) address space in the RAID subsystem .","The configuration tree  and, in particular, the volume object  represent a logical disk that is presented to the file system by the RAID subsystem as a \u201ccontainer\u201d for the file system to store its data. That is, the objects of the configuration tree are organized to create an address space that resembles a single logical disk but, in reality, comprises a plurality of physical disks. In this context, the volume object  is equivalent to the tree object , wherein the tree object stores additional metadata about the logical volume that is presented to the file system. This additional metadata includes the type (level) of parity implementation configured for the particular volume (e.g., RAID-4, RAID-0, mirror_RAID-4, mirror_RAID-0, RD parity). Since the tree object is a one-to-one representation of the volume, the additional metadata stored in the tree object includes redundant information about the volume, such as its name and physical address\/block range.","A next object level comprises a mirror object  that is responsible for coordinating one or more copies of the volume (termed \u201cplexes\u201d) in support of data mirroring. In synchronous data mirroring, two \u201cmirror\u201d copies are provided that are at all times synchronized. That is, changes to the data in one mirrored copy are immediately reflected in the other mirrored copy. The two identical mirrored copies have matching address spaces that are within the volume address space and that provide identical synchronized full copies of the data in the volume.","A plex object  is responsible for managing an instance of a copy of volume data and thus represents each mirrored copy within another object level of the configuration tree. Whereas the mirror object  stores metadata that is used to coordinate one or more copies (or plexes) of the volume in support of data mirroring, each plex object  stores metadata that is used to manage an instance of a copy of volume data. The plex object may include an ordinal placement (e.g., 1, 2) indicating that, for example, a first part (1) of the address space is associated with a particular RAID group and that a second part (2) of the address space is associated with another RAID group. A next object level comprises one or more RAID group objects  per plex object. Each RAID group object  contains metadata that provides data protection and I\/O coordination over a set of disks. The metadata of the RAID group object includes information such as the number of disks within the RAID group and the address (block) range of each disk within the RAID group. In this context, a RAID group is defined as a number of disks and the address\/block space associated with those disks. Finally, there is another object level comprising one or more disk objects  per RAID group object, wherein each disk object  contains metadata that provides data access to the physical disks .","The configuration tree  is constructed in the memory  of the storage system  by a label assimilation process  of the RAID subsystem . According to the assimilation process, each disk associated with a volume includes a label that describes its placement and association with that volume. The on-disk label is, in essence, self-describing information for each disk that is actively attached to the storage system . The labels are used to dynamically assemble the disks into a volume and to construct an in core configuration tree  for that volume, starting from the disk object level up to the volume object level. Therefore, a label on a disk identifies that disk's participation in a RAID group and, furthermore, that group's association with plex, mirror and, ultimately, volume objects in the configuration tree. The label is located in a well-known location of the disk so that it can be queried by the RAID subsystem in accordance with, e.g., a discovery process during a boot operation. The discovery process illustratively implements a disk event thread  described herein.","Each object type instance of the configuration tree  comprises the following components: service interfaces, committed transactional state, pre-committed transactional state and non-transactional state. The service interfaces comprise an application programming interface (API) that the object exports to other software components. In the illustrative embodiment, the service interfaces include initialization and destruction, child object management (add, replace), online\/offline, transaction management (join, commit, abort, label I\/O, state change notify), virtual block management, and I\/O handling (context creation\/deletion, resource management, I\/O throttling). Each object type defines the commit, pre-committed, and non-transactional state that it holds. The transaction management interfaces are provided as a mechanism to create and modify transactional state in a manner that is coordinated across all objects in a volume.","The basic flow of control starts with a configuration management operation issued by, e.g., the file system  and received by the RAID subsystem . The file system passes the configuration management operation in the form of a message request that specifies a target volume- and defines a named operation with specific parameters. The configuration thread  of the RAID subsystem receives the request and determines the object (e.g., volume, RAID group) of the configuration tree  for the volume to which the request is directed. The configuration thread then locates the tree object  for the volume and invokes relevant configuration operations using service interfaces of the appropriate object. When a service interface is invoked, the object is transparently \u201cjoined\u201d to the request prior to activation of the interface. Joining of an object to a request results in copying of the currently committed state into a pre-committed state area (called the \u201ctrans\u201d area of the object). The trans area is a portion of memory that records changes to the object that are pending commitment. The service interface makes its changes to the trans area. If the changes to the object result in a change of the state of the object, the FSM engine  is invoked.","The FSM engine  provides a critical component in managing the interrelationship between objects in a RAID volume. Specifically, the FSM engine defines the state\/event pairs that are \u201clegal\u201d and, for each state\/event, provides a mechanism to implement the invocation and determine any subsequent state transitions. In addition, the FSM engine provides tracing mechanisms to track the set of transitions that have occurred and provides object notification for pre-committed and committed state transitions. More specifically, the FSM engine  is responsible for determining the new state of the object (based upon a per object type state\/event table) and invoking the state notification interface of its \u201csuperior\u201d object in the volume hierarchy. The FSM engine includes an upward notification mechanism (e.g., from child to parent object) to notify the parent object about a state change in the child object.","When the configuration request completes all service interface invocations, it requests a label commit operation to persistently store the modified state. The label commit \u201cpulls\u201d data from the trans area in order to construct its new version of the label data. Label commit is deemed to be successful only if all labels in a plex can be successfully written. Once all labels have been successfully written, each object that has been joined to the request is responsible for copying its trans area data back to the committed state portion of the object. If labels are not successfully written, the trans area is discarded, any disk failures are identified and resulting configuration changes are initiated, the successfully written labels are re-written with the previous state, and the original configuration request is retried.","The present invention relates to a query-based spares management technique that enables a storage operating system of a storage system to select disks to be added to one or more RAID groups of a volume. The spares management technique includes a disk addition (DISKADD) selection process that is implemented by the storage operating system in response to an operator-initiated request to add disks to the volume or in response to a demand-driven request resulting from a requirement imposed by the system to add disks to the volume. The disks that are added to the RAID groups of the volume are retrieved from one or more spare pools of disks maintained by the storage system.","In the illustrative embodiment, the storage system has one or more \u201cglobal\u201d spare pools that may be situated in various geographical locations.  is a schematic block diagram of a spare pool  as represented in the RAID subsystem by a spare disk manager (DMGR) object  having an associated disk container (child) object  that maintains various disk objects  contained in the spare pool. The DMGR object is a higher-level abstraction than that of the disk container object and is responsible for managing the disks in each spare pool. Each DMGR object  has a type, such as spare (denoting a pool of functioning spare disks), broken (denoting a pool of failed disks) and owner (denoting a pool of spare disks for exclusive write access). As a result, the DMGR object is further responsible for managing disks in a broken pool and in a list of orphan disks. An orphan disk is a disk that, according to its on-disk label, is associated with a configuration tree, but which currently does not participate in a consistency label set (CLS) algorithm for that tree.","The disk container object  provides a convenient way of grouping individual disks within a parent object, such as a DMGR object  or a DISKADD object. The DISKADD object is described in U.S. Pat. No. 7,424,637 titled, . Each disk container object  includes information such as the number of member disk objects  within the spare pool, along with a count of the number of those disks that have been prepared for volume addition. In a preferred embodiment, preparation includes a complete zeroing of the disk blocks used for RAID parity calculations.","The disk objects  contained in a disk container object are similar to the disk objects  in the configuration tree . These disk objects contain information such as the name of the disk, the size of the disk, the selected checksum algorithm and the sector size. The information contained in the disk objects is provided to the disk event thread  of the RAID subsystem by the disk driver subsystem . The label information associated with the CLS algorithm of the label assimilation process  determines whether a disk object is placed within the configuration tree  of a volume or in a spare pool . The CLS algorithm is described in U.S. Pat. No. 7,133,964, issued on Nov. 7, 2006 and titled , which patent application is hereby incorporated by reference as though fully set forth herein.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 6","b":["600","275","250","300","350","340","250","350","350","250","350"]},"In addition, the disk event thread  creates a RAID object representing the attributes and behaviors of the disk. The thread  then calls the label assimilation process  to initialize attributes associated with the RAID object. The label assimilation process reads the on-disk labels from the disks that are owned by the storage system. The label assimilation process  places disks that it determines to be spares (based upon those disk labels) into a spare pool  determined by the disk event thread . In a preferred embodiment, the disks in a spare pool do not share any single point of failure (with respect to connectivity) with the spare disks of another spare pool.","A plurality of methods is available for selecting disks, two of which are operator initiated. One example of such a method allows the operator to initiate selection of a specific disk for addition to a specific volume based upon, e.g., a name of the disk, wherein the name is based on a physical location of the disk in the system. The name of a disk may, for instance, be derived from an adapter number, a disk shelf identifier and a slot identifier within the disk shelf. Alternatively, the operator may merely request that one or more disks be added to a particular volume, without indicating the particular disks. An example of an operator-initiated request for selection of disks is described in co-pending U.S. Pat. No. 6,836,832, issued on Dec. 28, 2004 and titled , filed on Dec. 21, 2001, which application is hereby incorporated by reference as though fully set forth herein.","A third method for selecting a disk to add to a volume is a \u201cdemand-driven\u201d request that results from the imposed system requirement to add a disk to a RAID group. This method is generally similar to the alternative operator-initiated method in that no specific disk is identified for addition to the RAID group. As such, the selection is made by the storage operating system as opposed to the operator. An example of a demand-driven request is a request for a replacement disk during a reconstruction operation that occurs as a result of a RAID group transitioning into a degraded mode.","The present invention is directed to the alternative operator-initiated and demand-driven requests to add a disk to a volume, wherein the DISKADD selection process determines which disk \u201cbest suits\u201d the request based on a current configuration of the volume and RAID group and the current configuration of the spare pools, as well as elements of policy. That is, as opposed to object-based disk addition directed to integration\/placement of disks into RAID groups once the disks have been selected, the present invention is related to a technique for actually selecting and allocating spare disks for placement into RAID groups of the volume.","Spare disk selection and allocation may be performed in response to a user entering a CLI command at the UI , wherein the CLI command may comprise a vol add, vol create or vol mirror command, or if a disk fails and needs replacement. As described herein, the DISKADD selection process has a policy set associated therewith that defines the sequence and criteria surrounding disk selection and allocation. The policy set is illustratively implemented in a \u201cbackend\u201d (e.g., RAID subsystem) of the storage operating system executing on the storage system. However, it should be understood that the policy set may alternatively be implemented in a \u201cfront end\u201d (e.g., the user interface) of storage operating system.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 7","b":["700","0","1","710","710","0","1","0","0","1","1"]},"In the illustrative embodiment, the DISKADD selection process is embodied as a layer of the DISKADD object that determines a set of disks to add to one or more RAID groups of the volume. The DISKADD selection process cooperates with a select-query-allocate (SQA) application programming interface (API) and associated SQA manager process  to determine the set of disks to allocate, as well as to optimize the order in which the disk are allocated. These processes further utilize a policy mechanism with changeable fine-grained elements of policy to provide the query-based spares management technique of the present invention.","Specifically, a set of SQA APIs enables interaction between the spare pools and a configuration tree of a RAID subsystem having a plurality of objects representing the RAID groups of the volume. The SQA API is embodied as a layer of code between one or more objects (e.g., the DISKADD object) of the configuration tree and one or more objects (e.g., the DMGR objects) of the spare pools. The SQA manager  is illustratively disposed adjacent to the spare pools and is responsible, in part, for behaviors of the spare pool type of DMGR objects.","The DISKADD selection process forms attribute-based selection query requests based upon its evaluation of the configuration tree and policy that defines the sequence and criteria for disk selection. The DISKADD selection process utilizes the SQA API to forward the requests to the SQA manager in an attempt to \u201cnarrow down\u201d the choices of disks until it arrives at a point where it is prepared to make an allocation request. The SQA manager  evaluates the attribute-based selection query requests, returns count-summary reports in response to the query requests and forwards allocation requests on behalf of the DISKDD object to the DMGR object.","In the illustrative embodiment, one tuple of the selection query request expresses select-query attributes on which to search. Each select tuple includes an attribute type and value (e.g., disk size, 32 GB) and a binary operand (e.g., less-than, greater-than, equal-to, not-equal-to). A report format tuple expresses each attribute type to include in a count summary of disks with the particular attribute value that matched the select tuple. If no particular attribute is specified, then the default is to provide a total count of disks matching the specified select-query attributes tuple. An argument is provided to specify a sort order for the summary report, e.g., ascending or descending order.","Assume a data disk (d) of RAID group (rg) of plex (p) fails, representing a degraded RAID group situation, and a demand-driven request arises for disk selection. A notification is sent from disk object d to the RAID group object rg of plex p, notifying the RAID group object of the failure. As a result, the FSM engine  forces RAID group object rg into a degraded state. Upon entering the degraded state, the RAID group object attempts to reconstruct the failed disk by requesting a replacement disk from the DISKADD object. The DISKADD object forms a query request based on the configuration of the degraded RAID group and the appropriate policy. The query request contains attributes such as the minimum size of the disk that is required, the selected checksum algorithm, spare pool information and, perhaps, locality information as described further herein. The request is then sent to the SQA manager  via a select-query function call over a \u201cforward path\u201d  of the API layer  to select one or more disks from a spare pool.","Specifically, selection of a spare disk from a spare pool depends upon the SQA API, which enables interactions between the spare pool and the DISKADD object. The DISKADD object illustratively determines a spare pool from which to allocate disks. For example in the case of a mirrored volume, the DISKADD object determines the spare pool to target, based upon the plex to which the disks are added. Once the spare pool has been determined, the initial set of candidate disks for disk allocation includes all disks in the pool. The DISKADD selection process then forms a series of database style query requests that is sent to the SQA manager  through the select-query API in order to \u201cnarrow down\u201d the set of possible candidate spare disks until a set of candidates that meet the allocation request is determined.","More specifically, the DISKADD object evaluates the configuration tree  (or an object within the tree) for the volume and forms query requests with desired attributes for use by the SQA manager. That is, although the context for the evaluation is \u201cbroadly\u201d directed to the configuration tree, that context may be further directed to a RAID object (e.g., the RAID group object) within the configuration tree. In addition, for a mirror volume configuration, the context may be expanded to include fault isolation characteristics as well as pair-wise matching of disk characteristics, such as size and checksum algorithm. This, in turn, may require coordination between multiple spare pools to ensure that the response to the disk selection request satisfies pair-wise constraints associated with the mirror configuration.","According to an aspect of the invention, the SQA manager  utilizes the attributes in the query requests to select disks from the spare pools and returns, via select-query API function calls over a \u201cfeedback path\u201d  of the API layer , the count-summary reports to satisfy the series of database style query requests. If the manager  cannot satisfy a request, it returns an error and any available information. In response, the DISKADD object may form another query request. As a result, an iterative process is established wherein the DISKADD object queries the SQA manager with desired attributes of available spare disks and the manager  uses those attributes to select the best available disks per set policy.","In summary, the DISKADD object examines the configuration of the degraded RAID group to form the attributes-based query requests to select the best replacement disk. The SQA manager makes the selection as to which spare disk best satisfies the replacement request based on the attributes using the spares management technique described herein. For example, if examination of the RAID group configuration indicates that fault tolerant characteristics are important, then the technique strives for selection of a disk that can be co-located within a disk shelf containing other disks of the RAID group. If the selection cannot identify disks co-located with other disks in the RAID group, preference may be given to disks sharing loop and shelf attachments. Yet, if the configuration indicates that I\/O bandwidth\/throughput is important, then the technique attempts disk selection in a manner that \u201cspreads\u201d (balances) the disks (load) of the RAID group across many \u201cchannels\u201d (e.g., adapters) and disk shelves of the storage system.","In the case of load balancing as a determining criterion for disk replacement, assume that the storage system includes four (4) storage adapters , wherein each adapter is coupled to a disk shelf of disks. If each of the disks in the RAID group is coupled to a different adapter (adapters -) and the failed disk d is coupled to, e.g., adapter , then the spares management technique strives to select a replacement disk that is connected to adapter  so as to maintain the load balancing arrangement of that RAID group. Here, the physical locality of a disk shelf is not as important as maintaining the previous adapter connection. Note that load balancing is particularly important with respect to parity disks used in multiple RAID groups. That is, it is desirable to have the parity disk of each RAID group coupled to a different storage adapter  of the storage system  in an alternating arrangement to avoid a \u201chot spot\u201d of I\/O activity on one adapter.","Once the DISKADD object arrives at its final set of candidate disks, based upon responses from the SQA API, it makes a spares allocation request through the spares query\/allocation API layer . In response, the SQA manager  optimizes the order of the candidates to match the allocation request and returns (to the DISKADD object) the optimized order of candidate disks selected to replace the failed disk. The FSM engine  then transitions the RAID group into a reconstruct state. In this state, the RAID group object reconstructs the data on the failed disk using its constituent data\/parity disks of the RAID group. After the data is reconstructed, the FSM engine  transitions the RAID object to a normal state.","According to the present invention, the query-based spares management technique comprises an attribute-based disk selection procedure that includes an aspect of maintaining locality in RAID groups. Here, \u201clocality\u201d denotes physical locality in terms of electrical connectivity for purposes of fault isolation and\/or increasing aggregate bandwidth to the volume as represented by connections to individual disks.  is a schematic diagram illustrating the aspect of physical locality with respect to disks  coupled to the storage system , wherein each disk  has locality criteria associated with its physical and electrical connectivity to the storage system. In the case of a direct-attached disk configuration, the locality criteria are directed to adapter connectivity, e.g., a slot  on a backplane, such as a peripheral computer interconnect (PCI) backplane, of the system bus  that can accommodate two storage adapters, the storage adapter , a disk shelf  and a slot  on the shelf. For a switch-attached disk configuration, the locality criteria further include switch connectivity, e.g., a switch  coupled between the storage system and disk, along with a port  on the switch.","Yet, there are other attributes-based selection criteria that may be used in the process of disk selection, including disk size and checksum type. Locality can thus be generalized as one type of attribute that is considered when selecting disks from a spare pool. Another type of attribute is \u201cpolicy\u201d; the configuration tree has a policy associated with it such that, e.g., a mirrored volume implies pair-wise disk selection. Note that the mechanisms described herein work generally with N-way mirroring. Another policy consideration may be the type of RAID implementation, e.g., a RAID-4 level implementation. The policy attributes associated with a configuration tree, along with the locality attribute, cooperate to provide an attribute set that may be used to determine the disks selected in response to the select-query request to add disks to a RAID group of a volume.","To that end, the locality attribute may be further extended to the use of policies that enables identification of the spare pools from which disks are selected. In addition to adapter\/switch connectivity, these policies may include locality criteria such as the location of a disk shelf, e.g., a location that is remote from the storage system for disaster recovery purposes. If there is more than one spare pool in a storage system, it may be desirable to select disks from a spare pool that is \u201clocal\u201d to that plex. For example, in the case of a plex of a non-mirrored volume located in a particular geographical area, the technique attempts to select disks from a spare pool in that area. If another plex is added from another geographical area to create a mirrored volume, the technique attempts to select disks from a spare pool in that other area.",{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 9","b":["900","900","910","920","0","1","0"]},"A finer grouping of disks is by a \u201cchannel grouping\u201d layer , an example of which is a PCI slot on the backplane of the storage system. As noted, in the illustrative embodiment, a PCI slot  can support two storage adapters . Whereas a PCI slot is an example of a channel group in the direct-attached disk configuration, a switch is an example of the channel grouping in the switch-attached disk configuration. A yet finer grouping of disks is by a channel layer , which expresses a connection to the disk. In the case of a switch-attached disk, the channel refers to a port on the switch, whereas in the case of a direct-attached disk, the channel represents an adapter on the storage system. A last or inner layer  pertains to a shelf on which the disks are located.","The onion is used to progress towards a finer granularity with respect to the locality attribute in the determination of a disk selection decision. The layers of locality in the onion reflect the connectivity associated with disks in a storage system; if new interconnect technologies are used, the layers of locality in the onion may change. If a locality criterion represented by a layer of the onion is not achievable, then the novel technique progresses to a next outer layer of granularity in order to satisfy the disk request in a reasonable manner. Note also that some of these locality criteria may be included within various objects of the configuration tree as policies maintained by those objects. For example, the RAID group object may maintain a policy of locality criteria associated with the disks in its RAID group. However, for a mirrored volume, the policy associated with locality for replacement of a disk may be stored in a plex object, given the pair-wise selection constraint of a mirrored volume.","According to another aspect of the invention, the attribute set for the query-based spares management technique comprises a plurality of steps, each of which may have an associated element of policy. These elements of policy cooperate to produce a fine granularity of disk selection. One element of policy may be directed to priority ordering of disk attributes considered during disk selection. Another element of policy pertains to locality wherein, as noted, locality denotes electrical connectivity for purposes of fault isolation or increasing aggregate bandwidth to the volume through connections to the disks. Other elements of policy may pertain to disk selection and allocation attributes, including disk addition and disk replacement policies, each of which is associated with a volume (volume object of the configuration tree). Each volume (volume object) of the storage system may have an attribute set that is different from other volumes in the storage system. Moreover, the attribute set described herein is preferably \u201cdynamic\u201d and thus can change.",{"@attributes":{"id":"p-0089","num":"0088"},"figref":["FIG. 10","FIG. 7"],"b":["200","1000","1002","1004","0","0","1","1"]},"In accordance with selection priority ordering, the next elements of policy are not concerned with locality but rather with other disk attributes. For example, Step  illustrates a next element of policy directed to matching the checksum type of disks selected in accordance with the first two steps. The checksum type (,  blocks per sector) is metadata provided on a per volume basis. As a result of this step, only those disks that match the checksum type are selected. Step  of the technique pertains to selecting disks on the basis of disk capacity, which includes matching the capacity of disks already in the RAID group, along with a geometry constraint associated with pair-wise matching of disks with similar capacity to plexes of a mirrored volume.","In general, capacity matching involves matching the usable capacity of disks added to each plex, which may be accomplished through the use of \u201cdownsizing\u201d. The disk capacity policy may be manifested as a select-query request to the disk event thread  for a list of all disks at various sizes that have previously met the other criteria. The SQA manager  returns an ordered list of disks by size. The DISKADD object then determines whether a pair of similarly sized disks can be obtained from the list of those disks. As a result of this step, a finer selection of disks is achieved.","Step  of the sequence gives preference to disks that are prepared for immediate incorporation into a volume, such as pre-zeroed disks (versus disks that require zeroing or other pre-incorporation activity). It should be noted that after each Step -, the SQA manager generates a count summary report. If the report indicates that the number of remaining candidates matches or exceeds the DISKADD request, then the sequence proceeds to the next step. Otherwise, the sequence returns to a previous step and repeats with modified selection criteria.","Step  of the technique pertains to an element of locality related to topology optimization. This optimization step is performed by the SQA manager, based upon policy, such as a default locality or preferred locality associated with the volume or plex. The inner layers of the onion, contained with the spare pool layer, represent the locality criteria utilized for this optimization. In essence, this last step gives an ordering to the disks remaining after the iterative process based on optimizing for topology (connectivity). For example, the remaining disks may be ordered to effect an alternating storage adapter arrangement. Here, disks are allocated one RAID group at a time, with the goal of alternating the parity disk connectivity to the adapter across all RAID groups. In sum, the topology optimization is based on the onion  and is performed by, e.g., the configuration thread  prior to allocating the selected disks in response to the disk addition (vol add) command. The sequence then ends at Step  with disk allocation.","A preferred embodiment of the invention has been described herein with reference to a file server having a storage operating system with a file system layer and a RAID subsystem (among other components), which manages file semantics in order to access data organized in files. It should be understood, however, that the invention can be practiced in any system or device that selects disks to be added to one or more RAID groups of a volume. One type of system or device in which the invention can be embodied is designed to perform a data storage function, and if so, may perform data-related operations, e.g., in response to data access requests. Such requests may use file-based and\/or block-based semantics, depending on the implementation and, correspondingly, the system or device may organize data in files or in another manner. Moreover, such systems and devices may or may not incorporate features and functions described herein, such as, for example, a file system layer or a RAID subsystem, or may combine or otherwise modify their operation, without departing from the principles of the invention. Finally, the invention has been described herein using nomenclature such as \u201cDMGR\u201d which may appear to be specific to implementations of the invention providing RAID functionality; however, the invention in its broader sense is not so limited.","The foregoing description has been directed to specific embodiments of this invention. It will be apparent, however, that other variations and modifications may be made to the described embodiments, with the attainment of some or all of their advantages. For instance, it is expressly contemplated that the teachings of this invention can be implemented as software, including a computer-readable medium having program instructions executing on a computer, hardware, firmware, or a combination thereof. In addition, it is understood that the data structures described herein can include additional information while remaining within the scope of the present invention. Accordingly this description is to be taken only by way of example and not to otherwise limit the scope of the invention. Therefore, it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention."],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF AN ILLUSTRATIVE EMBODIMENT"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The above and further advantages of the invention may be better understood by referring to the following description in conjunction with the accompanying drawings in which like reference numerals indicate identical or functionally similar elements:",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 8","FIG. 1"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
