---
title: Method and apparatus for efficient HTTP streaming
abstract: A method and apparatus provide streaming delivery of data such as media data (video, audio) using a non-streaming delivery mechanism such as HTTP along with server-side pacing of the delivery. An initial portion of the media data is preloaded to a client buffer in a bursting manner to minimize latency. The method may include client request verification, support for client self-pacing, and support for catch-up pacing reductions. A proxy server apparatus may also be used which employs both server-side and client-side pacing and may include caching and both cache and client preloading for minimized latency. A similar proxy server apparatus may be used to provide an efficient alternative to client polling for data from a polled data service, such as stock quotes etc., using streaming updates. The method may include support for stream modification through persistent client requests.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08417828&OS=08417828&RS=08417828
owner: Azuki Systems, Inc.
number: 08417828
owner_city: Acton
owner_country: US
publication_date: 20110413
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This invention relates in general to streaming media and more specifically to streaming media using the HTTP protocol.","In data communications it is typically desirable to retrieve data as quickly as possible. This is not the case, however, for data which may be rendered over time (e.g. audio or video). The Hypertext Transfer Protocol (HTTP) is a popular Internet data retrieval protocol. In general HTTP requests are serviced as quickly as possible and HTTP does not take into account the possibility of rendering over time. The Real Time Streaming Protocol (RTSP), on the other hand, was designed to deliver data which may be rendered over time, in a just in time manner. RTSP is more complex, more computationally expensive, and less well supported than HTTP. Consequently, many still rely on HTTP for delivering audio and video content. The download as fast as possible paradigm, however, uses more bandwidth than is necessary, and requires that clients have buffer space to store the data, and encourages servers to use all available resources to send the data as quickly as possible. This is taxing for clients with limited resources (e.g. mobile devices). This also inhibits network and server scalability.","US Patent Application Publication 2008\/0114889A1 by Deshpande describes a method for pacing from an existing web server, by calculating a strict pacing schedule, based on the target bit rate and the offset from the beginning of the file. Deshpande also allows for client specified segment sizes and target bit rates. The implied architecture, however, does not specifically address server scalability issues, client intelligence, or rendering optimizations.","Other known mechanisms include those described in RFC 3448, \u201cTCP Friendly Rate Control (TFRC)\u201d, and in a paper by Wei et al. entitled \u201cTCP Pacing Revisited\u201d.","While the prior art includes basic concepts for paced output in other protocols, and an implementation for paced HTTP output, it does not address scalability of the servers which implement those protocols, or focus on the end user experience. The present invention includes architectural differences which allow for higher server scalability (e.g. segment size and pacing rate for range requests), as well as additional features for improving end user experience, specifically initial bursting for a client buffer preload, as well as support for client pacing.","In one embodiment, a computer system provides for streaming media data (e.g. an encoding of a video or audio) from a data file to a client over a network. A target bit rate is used for sending the data file. The target bit rate is calculated as a constant bit rate, given the file duration and file size (where \u201cduration\u201d refers to the length of time over which the media object represented by the media data is rendered, i.e., the playback time for a video or audio). The target bit rate is used to calculate a pacing delay. The pacing delay is used to insert delays between segments of data sent during a session in order to meet the target bit rate. In one embodiment, the segment size is determined by the TCP window size. In another embodiment, the segment size may be static. If the data requested is less than the segment size, but the session spans multiple requests, stateful information is maintained and delays are calculated using aggregate statistics including inter-request delay. In one embodiment, a catch up delay is also maintained, to keep track of the times that the pacing budget was missed. In such a case the time required to send the segment exceeded the pacing delay. This timing shortfall is accumulated and future pacing delays are discounted to make back the time.","A target burst size is also calculated, and the initial response to a request involves bursting an amount of data, greater than the segment size but not exceeding the target burst size, to preload the client buffer. The burst size may be calculated as a client buffer size in seconds multiplied by a constant bit rate which is the media data size divided by the duration. This reduces initial rendering latency for the client. The bursted data may be sent in batches to ensure fairness among different sessions for different clients, and a segment size for each batch may be calculated as a fixed percentage of the TCP window size.","One embodiment also verifies data requests to prevent unauthorized access, and to protect against denial of service. The verification information includes a user name (user ID) for authentication and an expiration timestamp. The user name and\/or expiration information is secured using a hash which includes a pre-shared secret key. In one embodiment, the URL for the media is generated by another server. That server generates the hash value, using a secret key known to both the server and the present invention.","In one embodiment, the computer system may send media data in response to both non-range requests and range requests which exceed a predetermined threshold in a paced manner. The media data may be sent in batches and include calculating a delay equal to a segment size divided by the pacing rate, minus the transmission time for the current segment and minus a catch-up amount from previous segments, with the delay being enforced to have a minimum of zero. A faster pacing rate may be used when bursting the initial file data. The segment size may be calculated for each batch as a fixed percentage of the TCP window size. A carry forward may be accumulated which is equal to the absolute value of the delay when the actual delay would be less than zero, and this accumulation may involve stateful accounting of carry forward delay across persistent HTTP requests. The technique may also support client self-pacing by not pacing range requests which do not exceed a predetermined threshold, and may support client seek functionality by supporting range requests.","In another aspect, a computer system is disclosed for streaming data over a network, using a proxy server to retrieve data from a backend server (e.g., an origin server) in a paced manner, cache the received data and asynchronously stream the data to a requestor (client) in a paced manner. The backend pacing rate for retrieving the data is faster than the front end (client-facing) pacing rate, to prevent underflow when simultaneously retrieving data from the backend and streaming data on the front end. The front end pacing rate is calculated from the file specified bit rate. In one embodiment, the backend pacing is performed explicitly, using TCP window size adjustments and delayed ACKs. In another embodiment, the backend pacing is performed implicitly, using delayed reads (e.g., delayed HTTP range requests) and taking advantage of the inherent TCP back pressuring, wherein the delays are calculated based on the backend pacing rate. The front end pacing is performed explicitly, using delayed sends, wherein the delays are calculated based on the front end pacing rate.","The media data retrieved from the backend may be stored in a cache. If the file already exists in the cache, the file is served directly from the cache. In one embodiment, files are expunged from the cache after a predetermined timeout. In another embodiment, files are not expunged unless explicitly deleted, via a management console for example. If the file does not yet exist in the cache, retrieval of the content is initiated on the backend. The initial portion of the file is retrieved as fast as possible, while the remainder of the file is retrieved at the back end pacing rate. In one embodiment, the front end is signaled once the initial portion of the file has been retrieved. In another embodiment, the front end is not signaled until the entire file has been retrieved and verified using a file hash. The front end, upon being signaled, bursts the initial portion of the file to the client, in order to preload the client's buffer, while the remainder of the file is sent at the front end pacing rate.","The backend request protocol may be HTTP, or another protocol such as RTSP or FTP. The file metadata, bit rate, and cache location may be stored in a database for use in servicing future client requests. The origin server may be co-located in the same data center as the proxy server, or it may be in a remote data center.","In another aspect, a computer system is disclosed for streaming periodic data updates over a network. Examples of such data updates include live sports scores, live stock quotes, live news updates, location and status information for an individual (e.g., from a GPS type of device carried by the individual), and RSS feeds.","The system uses a proxy to offload polling overhead from a client by streaming updates to the client on the front end while asynchronously polling for backend data updates from a polled data service, on behalf of the client. The client initiates a single persistent connection to the proxy, specifying the data to be polled, the rate at which to poll, and the rate at which to send updates. The periodic polling is scheduled and results are checked against previous results held in a cache. If new results differ from the previously cached results, the cache is updated and an update is sent to the client. In one embodiment, if the latest results match the previously cached results, no updates are sent to the client. In another embodiment, duplicate results are sent to the client at each pacing interval.","In one embodiment, the backend polling is done via HTTP persistent GETs, to minimize connection setup and tear down overhead. In another embodiment, the backend polling may use other protocols, and may use separate transactions for each polling request. In one embodiment, the polling rate is equal to the streamed update pacing rate, to minimize unnecessary polling. In another embodiment, the polling and pacing rates may differ, in order to provide for front end or backend connectivity verification and keep-alives.","In one embodiment, the front end streaming updates are sent using HTTP chunk transfer coding and one and only one update is sent per segment. The chunk boundaries provide natural delineation between updates. HTTP chunks specify a length for the segment and have an end of chunk delimiter. Those skilled in the art will see that this is sufficient for determining the boundaries for individual updates. In another embodiment, proprietary message encapsulation formats may be used, either in lieu of, or in conjunction with, HTTP chunk transfer coding.","The client may update the session polling and\/or streaming configuration using the persistent HTTP streaming connection. In one embodiment, the initial configuration is processed without receiving the entire HTTP request, using the information available in the currently available HTTP entity headers. The initial configuration is overridden by sending additional superseding headers as a continuation of the initial request. In another embodiment, persistent HTTP requests are processed immediately and the session configuration updated.","Query string parameters or custom entity headers may provide configuration information for the periodic updates. Examples of such configuration information and corresponding functions include specifying the data to be polled; specifying the polling rate; specifying the pacing rate; specifying user credentials for backend data polling; specifying the data format for the periodic updates; and specifying whether or not to send duplicate data if the data has not changed on the backend.","Persistent HTTP requests may be processed immediately, rather than pipelined, and in this case there may similarly be support for changing the data to be polled; changing the polling rate; changing the pacing rate; changing the user credentials for backend data polling; changing the data format for the periodic updates; halting periodic updates; and changing whether or not to send duplicate data, if there is no change on the backend.","The backend connection may be FTP, or it may be HTTP, in which case HTTP persistent requests may be used for polling for backend updates, and requests may be issued to the backend at a rate faster than the polling rate specified by the client, in order to keep the connection alive and verify the liveness of the connection.","Duplicate data may be issued if the pacing delay is exceeded and no update is available from the backend, and a previous update's data may be cached for use in sending such duplicate data. Alternatively, the proxy may refrain from sending any updates to the client if there are no updates available from the backend.","In the description herein for embodiments of the present invention, numerous specific details are provided, such as examples of components and\/or methods, to provide a thorough understanding of embodiments of the present invention. One skilled in the relevant art will recognize, however, that an embodiment of the invention can be practiced without one or more of the specific details, or with other apparatus, systems, assemblies, methods, components, materials, parts, and\/or the like. In other instances, well-known structures, materials, or operations are not specifically shown or described in detail to avoid obscuring aspects of embodiments of the present invention.","It will be appreciated that the disclosed techniques can be embodied as software executing for example on a general-purpose or special-purpose computer hardware including memory, input\/output circuitry, and instruction processing logic.","I. Streaming Media Server",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 1","b":["10","12","12","14","16","12","14"]},"In  the server  may be referred to as an \u201corigin server\u201d to reflect that it has direct access to the media content  which is to be delivered. For example, the media content may be stored on local storage of the server  or in a common data center. However, it will be apparent that various aspects of the server  may also be incorporated in a so-called \u201cproxy server\u201d which may be located between the client  and a separate origin server. Specifically, aspects pertaining to the delivery of the media content  to the client  may be utilized by such a proxy server. A configuration of this type is specifically described below.","Both the server computer  and client device  are computerized devices including one or more processors, memory, input\/output circuitry and local storage all connected together by one or more data buses, along with software executed by the processor(s) to perform certain functions as described herein. The client device  may be a mobile device such as a portable computer or personal digital assistant (PDA), or an advanced personal communications and data device such as an iPhone\u00ae, Blackberry\u00ae, etc. It is to be noted that the term \u201crequestor\u201d is used herein to refer to the source of a request. For present purposes any references to a requestor can be interpreted as referring to a client .",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 2","b":["18","10","20","22","24","26","18","28","30","32","34"]},"An Accept thread  accepts new socket connections and creates a session for each new connection. As long as the total number of active sessions in the system has not exceeded a predefined active session threshold, the new session is added to queue . If the number of active sessions exceeds the predefined threshold, the new session is queued to queue . Queue  may be realized as the \u201clisten queue\u201d in the TCP stack of the operating system, in which case all incoming TCP connections are in the queue  but they do not necessarily constitute sessions until they are accepted by Accept thread .","As active sessions are removed from the system, either because a session completes, is rejected, or some other condition occurs, new sessions are de-queued from queue  are placed on queue . A separate predefined threshold is used for the total number of socket connections allowed, wherein the number of sockets threshold should be higher than the number of active sessions threshold. The number of sockets threshold is enforced through listen and accept application programming interfaces (APIs) as well as by configurable limits of the underlying operating system of server .","A Parse\/Verify thread  is responsible for reading in requests, parsing the requests, and verifying the requests. Verifying the requests includes verifying the well formedness of the request, verifying the permissions for the user name provided, verifying that the expiration time has not been exceeded, and verifying that the request parameters have not been tampered with by verifying a hash token which is provided as part of the request. The hash requires a synchronized pre-shared secret and an MD5 or SHA1 hash. The pre-shared secret must be known to both the generator of the URL and the proxy processing the URL request, in this case, a server such as the server  of . Pre-shared secrets are typically shared out-of-band using one of many methods which should be well known to anyone skilled in the art. Other embodiments may choose to use other cryptographic methods for tamper proofing. Parse\/Verify thread  also verifies the availability of the file requested. If any of the verification steps fails, the session is rejected. If the request is verified, the session is queued to queue . If the request is not yet available or not yet complete, a delay is set using linear back-off and the session is requeued to queue . If the delay exceeds a predetermined threshold, the session is rejected. In other embodiments, a different algorithm for timing out request reception could be used.","A Header Send thread  is responsible for creating response headers and sending the response headers to the client . The response header values are determined based upon the request header values and the characteristics of the file being served. Once the response has been sent, the session is queued to queue . If sending the response has not yet completed, a delay is set using linear back-off and the session is requeued to queue . If the delay exceeds a predetermined threshold, the session is rejected. In other embodiments, a different algorithm for timing out response delivery could be used.","The support for multiple sessions in a single thread necessitates the use of non-blocking sockets. The timeouts allow for a level of prioritization for more active sessions and also allow for recovery from denial of service attacks. More aggressive timeout schemes may be used if denial of service is prevalent. In cases where client connections incur high latency or high loss, less aggressive timeout schemes prevent undue session rejection.","A Paced Send thread  is responsible for the bursting of initial data and the pacing of subsequent data delivered to the client  for each request. Each time a session is serviced, a fixed sized segment of data is sent. In one embodiment, the segment size is set to be one half the maximum TCP window size for the session. Using TCP window size, rather than client buffer size, for segment size determination allows TCP flow control to better manage the connection. It is also more optimal for internal DMA transfers. If the client buffer size is much less than the TCP window size, then the overhead of DMA becomes large. Otherwise, if the client buffer size is much larger than the TCP window size, then the DMAs will not be able to service the full segment size. In other embodiments, the segment size may be chosen based on other server bottlenecks.","If all the data for the current request has been sent and the session supports persistence, the session is queued to queue  to await the next persistent request. If all the data for the current request has been sent and the session does not support persistence, the session is closed. In one embodiment, if not all of the data for the current request has been sent, and the amount of data sent is still below the bursting threshold, or the request was a range request below the range pacing threshold, a predetermined minimum delay is set and the session is requeued to queue . The minimum delay ensures fairness for other queued sessions. In another embodiment no minimum delay is used, and the session is queued for immediate reservicing. Otherwise, if not all of the data for the current request has been sent out, and the session is pacing, a pacing delay is then calculated, discounting for any carry forward catch up delay discounts. If the delay is negative, the absolute value of the delay is accumulated into the carry forward delay and the delay is set to a predetermined minimum delay and the session is requeued to queue . The minimum delay ensures fairness for other queued sessions. In another embodiment no minimum delay is used, and the session is queued for immediate reservicing. If the delay is positive, then that delay is set and the session is requeued to queue .","For maximum scalability and fairness, the minimum delay should be enforced. Even in high end server hardware, where the server processing resources are not a bottleneck, most likely the network resources are a bottle neck, and processing at the maximum rate, when the system is stalled, waiting on the network, is wasteful of both energy and resources. For mobile clients  having limited resources, sending at a maximum rate may also cause unwanted sluggishness as the device resources will be overwhelmed processing the incoming data.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 3","FIG. 2"],"b":["35","20","36","38"]},"The Parse\/Verify thread  performs steps , , and , reading and parsing the request, verifying the request and rejecting if necessary, and extracting metadata required to calculate pacing rate and pacing delay. In step , the HTTP entity headers are parsed and metadata is extracted including the request method, request uniform resource identifier (URI), host request header, user agent request header, connection request headers and range request header. These headers are all specified in the HTTP 1.1 RFC and should be well known to those skilled in the art. In one embodiment, a single supported request method of GET is enforced and the file name, timestamp, user name, and hash value are extrapolated from the URI. The GET method should be sufficient for all client requests and all necessary request parameters should fit within the URL length limitations. In another embodiment, other request methods may be supported and the file name, timestamp, user name and hash value may be encoded using proprietary HTTP entity headers or the HTTP entity body for better clarity or to accommodate space limitations.","In step , the information extracted in step  is used to verify the request. The request and request headers are checked for well-formedness. The request method is checked for predetermined valid values. If the request method is not one of the predetermined valid values, the session is rejected (step ). The file name is used to check for the existence of the requested file. If the requested file does not exist, the session is rejected (step ). The user name is checked for predetermined valid values. If the user name is not one of the predetermined valid values, the session is rejected (step ). In one embodiment of the invention, the user agent may be used for further validation of the client device. If the user agent is not one of a predetermined set of valid values, the session may be rejected (step ). The user agent specifies basic device capabilities as well as a device identifier which can be used to look up additional device capabilities. If those capabilities do not meet the streaming requirements, then the session may be rejected (step ). The timestamp is checked for expiry. If the timestamp has expired the session is rejected (step ). The request host and URI are used to verify the hash value, using the pre-shared secret. The hash is regenerated using the request host and URI and pre-shared secret and checked against the hash provided in the request. If the hash value does not match, the session is rejected (step ). Next, metadata is extracted from the file specified, specifically: the file size, in bits, the file duration, in seconds, and the file mime-type. The file size and file duration are used to calculate the target client bit rate. The target client bit rate is checked to see if it would cause the system to exceed a predetermined maximum bandwidth threshold. If the predetermined maximum bandwidth would be exceeded by servicing this session, then the session is rejected (step ). If the range header was provided, the byte range is checked against the file size. If no range header was provided, the default range of 0 to (file size\u20141) is used. If the range of data requested would exceed the data available in the file, then the session is rejected (step ).","Once the request has been validated, step  uses the metadata to generate the HTTP response headers. The session is then queued to queue .","The Header Send thread  performs step , sending the HTTP response headers to the client . The response headers were created in step  by Parse\/Verify thread . If an error or timeout occurs in sending the response headers, the session is rejected. Otherwise, on completion of sending the response headers, the session is queued to queue .","The Paced Send thread  performs steps , , , and , bursting and pacing data delivery to the client . In step , a fixed size segment of data is read from the file, at the current offset, and sent to the client. In one embodiment, the fixed segment size is set to be half the maximum TCP window size. In other embodiments, the fixed segment size may be a different value. If a range was specified in the request, the initial file offset is determined by the beginning of the range specified by the HTTP request. If no range was specified in the request, the offset is set to the beginning of the file. After each segment send, the offset is updated with the actual amount of data sent. In step , the total number of bytes sent is compared with the total number of bytes requested. If the request has not been filled, then step  determines what level of pacing should occur, and processing from step  is repeated as shown. If the request has been filled or completed, then step  checks to see if the connection is persistent, as specified by the connection request header. If the connection is persistent, then the session is queued to queue  for processing of the next persistent request, and processing is repeated from step  as shown. Otherwise, if the connection is not persistent, then the session is complete and the session is closed (step ).","Pacing provides for the most efficient server resource usage, however, optimal server resource usage is not always optimal for the client experience. To decrease latency in initial rendering of the file, the initial portion of the file is bursted to the client  to preload its rendering buffer. In one embodiment, the client buffer size is determined from a user agent, where a direct correlation between device name and device capabilities is known. In other embodiments, the client buffer size may be inferred from other metadata or specified by the client  explicitly. The burst size, in bits, is determined by the client buffer size, in seconds, divided by the bit rate, in bits per second. If the amount of data sent has not yet exceeded the burst size, then the data is sent at a burst rate, where the burst rate is faster than or equal to the bit rate, but less than or equal to the maximum available bandwidth of the server. In most cases the maximum possible bandwidth available to the server will exceed the client's maximum available bandwidth, therefore it is inefficient to use the servers maximum bandwidth. In one embodiment, the burst rate should not be allowed to exceed a predetermined peak per session bandwidth, and if the burst rate would cause the maximum server bandwidth to be exceeded, the burst rate should be tempered. The burst rate is recalculated for each session, each time through step , so that fluctuations in the number of active sessions and number of actively bursting sessions can be dynamically accounted for. The burst rate is calculated from the total excess server bandwidth where the excess bandwidth is equal to the total bandwidth minus the non-bursting bandwidth required by all active sessions. The excess bandwidth is divided equally between all actively bursting sessions. In another embodiment, excess bandwidth may be assigned to sessions using a priority scheme, where priority is given to older sessions, or newer sessions, or higher priority users.","Another alternative to consider is client self-pacing. Without direct client feedback to the server , the client  may know better than the server  what its buffer capacity and needs are, for optimal rendering. In such a case, the client may employ range GETs so that it may more granularly control data retrieval. In such cases, server side pacing could cause underrun of the client buffer. Not all range requests imply that client self-pacing is occurring, however. In one embodiment, only consistent range requests whose size do not exceed a predetermined threshold, are inferred to be for client side pacing purposes. If persistent range requests are consistently below the predetermined threshold, then no server-side pacing should be performed. A minimum delay is still calculated to provide fairness to other sessions. This minimum delay is used as the pacing delay.","In step , the pacing delay is determined and the session is requeued to queue . If the minimum delay is being used for range pacing, then the pacing delay is set to the minimum delay. Otherwise, the pacing delay is calculated as the segment size, in bits, divided by the bit rate, or burst rate if bursting, in bits per second. The pacing delay is then compared to the amount of time since the last segment was sent. If the time since the last send is greater than the pacing delay, then the minimum delay is used, and the difference between the time since the last send and the pacing delay is accumulated into the carry forward catch up delay. If the time since the last send is less than the pacing delay, than the delay time is set to the difference between the pacing delay and the time since the last send. If there is a carry forward catch up delay, then the delay is discounted by the carry forward pacing delay. If the delay is greater than the carry forward catch up delay, then the delay is set to the difference between the delay and the carry forward catch up delay, and the carry forward catch up delay is reset. If the delay is less than the carry forward catch up delay, then the carry forward catch up delay is reduced by the delay amount. In either case, if the delay is less than the minimum delay, the delay is set to the minimum delay. The calculated delay value is set and the session is requeued to queue .","Pseudo code for calculating the pacing delay for step  and reinserting the session into the priority queue  is shown below. In the pseudo code, the value \u201coverhead\u201d refers to the time taken to transmit a segment or portion of a segment in the current interval:",{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"priority_queue pq;","\/\/ sorted by next send time"]},{"entry":[{},"struct session {",{}]},{"entry":[{},"\u2003integer catchup_delay;","\/\/ in seconds"]},{"entry":[{},"\u2003integer bit_rate;","\/\/ in bits per second"]},{"entry":[{},"\u2003integer segment_size;","\u2003\/\/ in bits"]},{"entry":[{},"\u2003integer bits_sent;","\/\/ in bits"]},{"entry":[{},"\u2003integer burst size;","\/\/ in bits"]},{"entry":[{},"\u2003integer last_send_time; ","\/\/ in offset of seconds from epoch"]},{"entry":[{},"\u2003integer next_send_time;","\/\/ in offset of seconds from epoch"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} s;"]},{"entry":[{},"send_start_time = Time( )"]},{"entry":[{},"actual_bits_sent = send_segment(offset = s.bits_sent, length ="]},{"entry":[{},"s.segment_size)"]},{"entry":[{},"s.bits_sent = s.bits_sent + actual_bits_sent"]},{"entry":[{},"send_end_time = Time( )"]},{"entry":[{},"if s.bits_sent < s.burst_"]},{"entry":[{},"\u2003delay = MIN_DELAY"]},{"entry":[{},"else"]},{"entry":[{},"\u2003overhead = send_end_time \u2212 send_start_time"]},{"entry":[{},"\u2003delay = (actual_bits_sent \/ s.bit_rate) \u2212 overhead"]},{"entry":[{},"\u2003if (s.catchup_delay >= delay)"]},{"entry":[{},"\u2003\u2003s.catchup_delay = s.catchup_delay \u2212 delay + MIN_DELAY"]},{"entry":[{},"\u2003\u2003delay = MIN_DELAY"]},{"entry":[{},"\u2003else"]},{"entry":[{},"\u2003\u2003s.catchup_delay = 0"]},{"entry":[{},"\u2003\u2003delay = delay \u2212 catchup_delay"]},{"entry":[{},"\u2003\u2003if delay < MIN_DELAY"]},{"entry":[{},"\u2003\u2003\u2003s.catchup_delay = MIN_DELAY \u2212 delay"]},{"entry":[{},"\u2003\u2003\u2003delay = MIN_DELAY"]},{"entry":[{},"\u2003\u2003endif"]},{"entry":[{},"\u2003endif"]},{"entry":[{},"endif"]},{"entry":[{},"s.last_send_time = Time( )"]},{"entry":[{},"s.next_send_time = Time( ) + delay"]},{"entry":[{},"pq.insert(session)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 4","b":["14","58","60","12","14","58","60","14","60","58"]},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 5","b":["58","60","16"]},"It will be appreciated that the proxy server  is also a computerized device such as described above for the server .",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 6","b":["62","58","70","64","66","68","70","14","70","66","74","70","68","66","70","64","70","72","70","74","66"]},"The client module  interfaces to the back-end origin server , and in response to the signaling from the server module  the client module  initiates a request for the file to the backend origin server . The client module  downloads the file and writes it to the cache module . The client module  downloads the initial portion of the file at a predetermined per session maximum rate, and then paces the download of the remainder of the file. Once the initial portion of the file is downloaded, the client module  extracts metadata from the file and writes it to the database module . The metadata should include, but not be limited to, the file name, the file size, the file duration, the file format and data encoding formats. The client module  then signals the server module , and the server module  reads the file metadata information for the file from the database module  and uses that information to calculate the pacing rate. The pacing rate is used to queue the streaming session in queue . The server module  then reads the initial portion of the file from the cache and sends it, at its maximum per session rate, to the requestor, to preload its buffer. The server module  then uses the calculated client pacing rate to stream the remaining file data to the requestor.","The client module  and the server module  are both implemented as individual threads within the single software organization . In another embodiment, each session in the client module  and\/or each session in the server module  could be serviced by its own thread or process. The single thread per module limits the number of threads required, which reduces the server resources required. The queues  and  allow each thread to manage and prioritize multiple sessions. Each queue is ordered based on absolute time. Sessions are inserted with a target time for next servicing. In the thread per session implementation, a simple delay may be used for pacing, however, to support multiple sessions in a single thread, the priority queue model allows the most immediate session to be identified and serviced first. The delay need only delay as long as is required by the most immediate session.","It will be appreciated that the streaming data proxy server  may employ one or multiple processors, and in the case of multiple processors they may be either tightly coupled or loosely coupled, such as the case of separate computer physical enclosures communicatively coupled by a network. The modules - in general may be distributed across multiple separate processors and employ any of various forms of inter-processor communications as generally known in the art.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIGS. 7A and 7B","FIGS. 4-6","FIG. 7A) and 77","FIG. 7B"],"b":["58","75","75","70","77","64","70","64","70","64","78","94","64","70","104","78","66","68","70","80","82","64","96","98"]},"In step , the server module  receives an HTTP streaming request and extracts the file name and location of the file being requested. Step  then checks to see if the file is already in the cache module  (cached) or has just been placed in the cache module  by the client module (signaled; see below for further description). Once the file is present in the cache module , then processing proceeds to step  where the server module  reads the file metadata from the database module . The metadata contains information used to create the HTTP response headers, as well as calculate the pacing rate for the file. The HTTP response headers are sent to the requestor and the session is added to the streaming priority queue . The priority queue  is processed by step  where a fixed size segment of file data is read from the cache module , from the current file offset, and sent to the client . The fixed sized segment is set to be a predetermined percentage of the maximum TCP buffer size. In one embodiment, the segment size is set to be one half the maximum TCP window size for the session. Using TCP window size for segment size determination allows TCP flow control to better manage the connection. It is also more optimal for internal DMA transfers. If the client buffer size is much less than the TCP window size, then the overhead of DMA becomes large. Otherwise, if the client buffer size is much larger than the TCP window size, then the DMAs will not be able to service the full segment size. In other embodiments, the segment size may be chosen based on other server bottlenecks.","In step , the session is checked to see if bursting or client pacing is being employed. During the initial file streaming stage, data is bursted at a higher rate than the pacing rate, in order to preload the requestor buffer, but less than or equal to the maximum available bandwidth of the server module . In most cases the maximum possible bandwidth available to the server module  will exceed the requestor's maximum available bandwidth, therefore it is inefficient to use the server module 's maximum bandwidth. The burst rate should not be allowed to exceed a predetermined peak per session bandwidth. If the burst rate would cause the maximum server bandwidth to be exceeded, the burst rate should be tempered.","Requestor based pacing is also supported through range requests, wherein the range request references an amount of data less than a predetermined threshold. The predetermined range request threshold is used to prevent degenerate range requests from taxing the resources of the server module . Without direct client feedback to the server , the client  may know better than the server  what its buffer capacity and needs are, for optimal rendering. In such a case, the client may employ range GETs so that it may more granularly control data retrieval. Not all range requests imply client side pacing, however. In one embodiment, only consistent range requests whose size does not exceed a predetermined threshold, are inferred to be for client side pacing purposes. If persistent range requests are consistently below the predetermined threshold, then no pacing should be performed. The threshold should be similar to the segment size selection, e.g. the TCP window size","If pacing is required, step  calculates the pacing delay, taking into account processing overhead and carry forward overhead and queues the session for servicing after that delay. Step  checks to see if the file has been streamed to completion. If the streaming is not complete, the session is requeued and processing proceeds back to step  for further streaming. If the streaming is complete, processing proceeds to step  where a persistence check is done. If the connection supports persistent HTTP requests, processing proceeds back to step  where the next request is processed. If persistent HTTP requests are not supported, then the server module processing is completed, the session is removed, and the connection is closed in step .","Referring to , if the check in step  of  fails and the file is not found in the cache module , then at step  the client module  is notified and a backend request to the origin server  is issued. The response data is processed and relevant file metadata is extracted in step . Metadata including the codecs, bit rates, file type, file duration, and file size are extracted and written to the database module . In step , file data is written to the cache module . To facilitate the bursting performed by the server module , the client module  preloads the initial portion of the file from the origin server . The amount of data to be preloaded should exceed the amount of data which is to be bursted to the client. The amount of data to be bursted to the client is determined by the bit rate of the file and the size of the client's buffer, wherein the buffer size in seconds, divided by the bit rate in bits per second, determines the number of bits to burst. The preload threshold is set at a fixed percentage, greater than 100, of the burst size. In step , the client module  checks to see whether preloading is complete. Preloading is complete if the total amount of data retrieved so far exceeds the preload threshold. If not, processing proceeds back to step  for further data retrieval, without pacing. A maximum retrieval rate for the session, less than the maximum retrieval rate of the client module , is enforced, to ensure fairness between backend sessions.","Once the back end preload is complete, processing proceeds to step  where the signaling check is performed. The first time through step , step  is processed which signals the server module  that the preloading is complete. This signal releases the server module  from step . With the initial portion of the file in the cache module , the server module  may begin servicing the request, in parallel with the remainder of the backend download. Once the server module  is signaled, processing proceeds to step , where the backend pacing delay is calculated, taking into account processing overhead and carry forward overhead, and the session is queued for servicing after that delay. The backend pacing delay is enforced to be less than the front end pacing delay to prevent underflow of the server module  through the cache module . In step , a check is done to see if the file download from the backend origin server  is complete. If the download is not yet complete, processing proceeds back to step  to continue downloading. If the download is complete, then the session is removed and the connection closed in step .","Pseudo code for calculating the pacing delay for steps  and  and reinserting the sessions into the priority queues  and  by the server module  and client module , respectively, is shown below. In the pseudo code, the value \u201coverhead\u201d refers to the time taken to receive or transmit a segment or portion of a segment in the current interval:",{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["priority_queue client_pq; ","\/\/ sorted by next send time"]},{"entry":["priority_queue server_pq;","\/\/ sorted by next send time"]},{"entry":["struct client_session {",{}]},{"entry":["\u2003integer catchup_delay;","\u2003\u2003\/\/ in microseconds"]},{"entry":["\u2003integer client_buffer_size;","\u2003\u2003\/\/ in seconds"]},{"entry":["\u2003integer file_duration;","\u2003\u2003\/\/ in seconds"]},{"entry":["\u2003integer file_size;","\u2003\u2003\/\/ in bits"]},{"entry":["\u2003integer segment_size;","\u2003\u2003\u2003\/\/ in bits"]},{"entry":["\u2003integer total_bits_retrieved;","\u2003\u2003\/\/ in bits"]},{"entry":["\u2003integer last_send_time; ","\/\/ in offset of seconds from epoch"]},{"entry":["\u2003integer next_send_time;","\/\/ in offset of seconds from epoch"]},{"entry":["} c;",{}]},{"entry":["struct server_session {",{}]},{"entry":["\u2003integer catchup_delay;","\u2003\/\/ in microseconds"]},{"entry":["\u2003integer client_buffer_size;","\u2003\/\/ in seconds"]},{"entry":["\u2003integer file_duration;","\u2003\/\/ in seconds"]},{"entry":["\u2003integer file_size;","\u2003\/\/ in bits"]},{"entry":["\u2003integer segment_size;","\u2003\u2003\/\/ in bits"]},{"entry":["\u2003integer total_bits_sent;","\u2003\/\/ in bits"]},{"entry":["\u2003integer last_send_time; ","\/\/ in offset of seconds from epoch"]},{"entry":["\u2003integer next_send_time; ","\/\/ in offset of seconds from epoch"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} s;"},{"entry":"client_module {"},{"entry":"\u2003loop"},{"entry":"\u2003\u2003s = client_pq->pop( )"},{"entry":"\u2003\u2003file_bit_rate = s.file_size \/ s.file_duration;"},{"entry":"\u2003\u2003burst_size = s.client_buffer_size \/ file_bit_rate;"},{"entry":"\u2003\u2003preload_threshold = s.burst_size * 1.1;"},{"entry":"\u2003\u2003backend_bit_rate = s.file_bit_rate * 1.1;"},{"entry":"\u2003\u2003retrieve_start_time = Time( );"},{"entry":"\u2003\u2003actual_bits_retrieved = read_to_buffer(offset ="},{"entry":"total_bits_received,"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003\u2003\u2003len = segment_size)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003write_buffer_to_cache(len = actual_bits_read)"},{"entry":"\u2003\u2003retrieve_end_time = Time( );"},{"entry":"\u2003\u2003s.total_bits_retrieved = s.total_bits_retrieved +"},{"entry":"actual_bits_read"},{"entry":"\u2003\u2003if s.total_bits_retrieved > preload_threshold"},{"entry":"\u2003\u2003\u2003overhead = retrieve_end_time \u2212 retrieve_start_time"},{"entry":"\u2003\u2003\u2003delay = (actual_bits_sent \/ backend_bit_rate) \u2212 overhead"},{"entry":"\u2003\u2003\u2003if (s.catchup_delay >= delay)"},{"entry":"\u2003\u2003\u2003\u2003s.catchup_delay = s.catchup_delay \u2212 delay + MIN_DELAY"},{"entry":"\u2003\u2003\u2003\u2003delay = MIN_DELAY"},{"entry":"\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003s.catchup_delay = 0"},{"entry":"\u2003\u2003\u2003\u2003delay = delay \u2212 catchup_delay"},{"entry":"\u2003\u2003\u2003\u2003if delay < MIN_DELAY"},{"entry":"\u2003\u2003\u2003\u2003\u2003s.catchup_delay = MIN_DELAY \u2212 delay"},{"entry":"\u2003\u2003\u2003\u2003\u2003delay = MIN_DELAY"},{"entry":"\u2003\u2003\u2003\u2003endif"},{"entry":"\u2003\u2003\u2003endif"},{"entry":"\u2003\u2003else"},{"entry":"\u2003\u2003\u2003delay = MIN_DELAY;"},{"entry":"\u2003\u2003endif"},{"entry":"\u2003\u2003s.last_send_time = Time( );"},{"entry":"\u2003\u2003s.next_send_time = Time( ) + delay;"},{"entry":"\u2003\u2003client_pq->push(s)"},{"entry":"\u2003\u2003s = client_pq->top( )"},{"entry":"\u2003\u2003delay(s.next_send_time \u2212 Time( ));"},{"entry":"\u2003endloop"},{"entry":"}"},{"entry":"server_module {"},{"entry":"\u2003loop"},{"entry":"\u2003\u2003s = server_pq->pop( )"},{"entry":"\u2003\u2003file_bit_rate = s.file_size \/ s.file_duration;"},{"entry":"\u2003\u2003burst_size = s.client_buffer_size \/ file_bit_rate;"},{"entry":"\u2003\u2003send_start_time = Time( );"},{"entry":"\u2003\u2003actual_bits_sent = send_from_file(offset = total_bits_sent,"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003\u2002len = segment_size)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003send_end_time = Time( );"},{"entry":"\u2003\u2003s.total_bits_sent = s.total_bits_sent + actual_bits_sent"},{"entry":"\u2003\u2003if s.total_bits_sent > burst_size"},{"entry":"\u2003\u2003\u2003overhead = send_end_time \u2212 send_start_time"},{"entry":"\u2003\u2003\u2003delay = (actual_bits_sent \/ file_bit_rate) \u2212 overhead"},{"entry":"\u2003\u2003\u2003if (s.catchup_delay >= delay)"},{"entry":"\u2003\u2003\u2003\u2003s.catchup_delay = s.catchup_delay \u2212 delay + MIN_DELAY"},{"entry":"\u2003\u2003\u2003\u2003delay = MIN_DELAY"},{"entry":"\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003s.catchup_delay = 0"},{"entry":"\u2003\u2003\u2003\u2003delay = delay \u2212 catchup_delay"},{"entry":"\u2003\u2003\u2003\u2003if delay < MIN_DELAY"},{"entry":"\u2003\u2003\u2003\u2003\u2003s.catchup_delay = MIN_DELAY \u2212 delay"},{"entry":"\u2003\u2003\u2003\u2003\u2003delay = MIN_DELAY"},{"entry":"\u2003\u2003\u2003\u2003endif"},{"entry":"\u2003\u2003\u2003endif"},{"entry":"\u2003\u2003else"},{"entry":"\u2003\u2003\u2003delay = MIN_DELAY;"},{"entry":"\u2003\u2003endif"},{"entry":"\u2003\u2003s.last_send_time = Time( );"},{"entry":"\u2003\u2003s.next_send_time = Time( ) + delay;"},{"entry":"\u2003\u2003s = server_pq->push( )"},{"entry":"\u2003\u2003s = server_pq->top( )"},{"entry":"\u2003\u2003delay(s.next_send_time \u2212 Time( ));"},{"entry":"\u2003endloop"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 8","b":["14","14","112","114","14","112","114","14"]},{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 9","FIG. 9"],"b":["112","116","120","118","122","124","116","120","116","120","122","124"]},"The streaming module  receives and processes requests from the client , for streaming of polled data. The streaming module  extracts the configuration information from the HTTP request and HTTP headers and writes the configuration information for the new session to the polling module . The polling module  is signaled by the streaming module , with the new session configuration, and a new periodic polling entry is inserted into the polling module's scheduler. Any updates to the session configuration, received by the streaming module , are written to the polling module  and recognized on subsequent polling requests. The polling module  maintains a scheduler which manages the polling delays for each session, through queue , and initiates the backend polling requests. Responses from those polling requests are written to the cache module . The cache module  maintains a current snapshot of polling results for all sessions. The contents of the cache module  are updated asynchronously, by the polling module . The streaming module  maintains a separate scheduler, through queue , which manages pacing of client updates for each session, and initiates front end paced responses to the client . The streaming module  monitors the cache module  for updates to the polled response data for each session. When the streaming module  scheduler determines it is time to service the next session in queue , the cache module  is checked, updates are formatted into an update segment and the update is sent to the client  over the existing TCP\/HTTP connection initiated by the client .","It will be appreciated that the streaming update proxy  may employ one or multiple processors, and in the case of multiple processors they may be either tightly coupled or loosely coupled, such as the case of separate computer physical enclosures communicatively coupled by a network. The modules - in general may be distributed across multiple separate processors and employ any of various forms of inter-processor communications as generally known in the art.",{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIGS. 10A and 10B","FIGS. 8-9","FIG. 10A","FIG. 10B"],"b":["120","126","128","116","120","130"]},"Client requests are received by the streaming module , in step , and the HTTP request and headers are parsed and the configuration extracted. The pacing configuration is stored for use in the paced sending to the client () as well as receive processing (), and the polling configuration is passed to the polling module  for its separate use in the back-end polling operation ().","The streaming function is handled in steps , , and . The pacing delay, configured by the client , is parsed in step  (and may be updated in step  as described below). The pacing delay is used in step  to calculate the next streaming time. The next streaming time is used to insert the pacing session into priority queue . The priority queue  manages which session should be serviced next, with streaming module  delaying until that session is to be service. The priority queue  is re-evaluated whenever new sessions are inserted by step  or when sessions are updated (step  described below). If the streaming module  is delaying at the time of the session update, the streaming module  is interrupted after the session configurations are updated and the streaming module  reevaluates queue  to determine the next session to be serviced and the delay until that session is to be serviced. Once a session comes due for processing, step  checks to see if new data is available. The cache module  is checked to see if the polled data for that session has been updated since the last update was sent for that session. In one embodiment, if no change has occurred, processing goes back to step , reinserting the session into priority queue  with an updated delay. If the cache module  has been updated since the last time the session was processed then processing proceeds to step . In another embodiment, even if no change has occurred in the cache module , processing proceeds to step  for duplicate data send. Data updates are sent to the client in step . In one embodiment, a new HTTP chunk is sent with XML formatted response data. In another embodiment, proprietary encoding may be used for the response data.","The receive processing is handled in steps , , , , and . The initial configuration is parsed in step , however, configuration updates are continuously accepted in step . The updates are parsed in step  and the updated configurations polling and pacing sessions are updated. In one embodiment, configuration updates are sent by the client  in additional HTTP entity headers. In another embodiment, configuration updates may be sent in additional HTTP entity body parameters. In another embodiment, configuration updates may be sent in additional pipelined requests, which are processed immediately. Step  checks to see if the connection has been closed. If the connection has not been closed, receive processing proceeds back to step , to wait for further configuration update processing. If the connection has been closed, processing proceeds to step  where the polling and pacing sessions are cleaned up. The polling and pacing sessions are removed from the polling module  and streaming module  queues  and , respectively, and the backend and front end connections are closed. Processing is then completed and the process finishes in step .","The polling function is handled in steps , , , , , and . The backend service information, configured by the client , is parsed in step  and updated in step . A connection to the backend service  is initiated in step . A connection is opened and a request for the polled data is issued. The response data is written to the cache module , in step .","The polling delay, configured by the client, is parsed in step  and updated in step . The polling delay is used in step  to calculate the next polling time. The next polling time is used to insert the polling session into priority queue . The priority queue  manages which session should be serviced next and the polling module  delays until that session is to be service. The priority queue  is re-evaluated whenever new sessions are inserted by step  or when sessions are updated by step . If the polling module  is delaying at the time of the session update, the polling module  is interrupted after the session configurations are updated and the polling module  reevaluates queue  to determine the next session to be serviced and the delay until that session is to be serviced. Once a session comes due for processing, step  checks to see if persistent HTTP requests should be used. In one embodiment, backend polling is performed over HTTP connections using persistent requests. As long as the backend service  which is to be polled for that session has not changed, persistent requests are used and processing proceeds to step . Otherwise, processing proceeds back to step , where a new backend connection is initiated to the new backend service to be polled. In another embodiment, the backend connection may use a protocol which does not support persistent connections, and processing always proceeds back to step  for new connection initiation. In step , the persistent request is issued to the backend service. In step , the response is checked against the existing response data in the cache module . If the data is the same then processing proceeds back to step , where the polling delay is recalculated and the session is reinserted into priority queue . If the data has changed, processing proceeds back to step , where the new data is written to the cache module , and then on to , where the polling delay is recalculated and the session is reinserted into priority queue .","While various embodiments of the invention have been particularly shown and described, it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the spirit and scope of the invention as defined by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing and other objects, features and advantages will be apparent from the following description of particular embodiments of the invention, as illustrated in the accompanying drawings in which like reference characters refer to the same parts throughout the different views. The drawings are not necessarily to scale, emphasis instead being placed upon illustrating the principles of various embodiments of the invention.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 7A and 7B"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIGS. 10A and 10B"}]},"DETDESC":[{},{}]}
