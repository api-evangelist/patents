---
title: Method and data structure for exchanging data
abstract: A method and system for exchanging at least one data value between a first device and at least one second device, including providing at least one data structure at the first device, the data structure including at least one descriptive field and an associated at least one data value field, the at least one data value field including the least one data value, the at least one descriptive field including a usage type field having usage type data to associate the at least one data value field with a data type, transmitting the at least one data structure from the first device to the at least one second device, and, based on at least the usage type data, at the at least one second device, extracting the at least one data value from the at least one data value field.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08484156&OS=08484156&RS=08484156
owner: Invensys Systems, Inc.
number: 08484156
owner_city: Foxboro
owner_country: US
publication_date: 20091214
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CLAIM OF PRIORITY","FIELD","BACKGROUND","SUMMARY","DESCRIPTION"],"p":["This application is a continuation of U.S. application Ser. No. 10\/403,687, filed Mar. 31, 2003, hereby incorporated herein by reference.","The disclosed methods and data structures relate to data transfer, and more particularly to data transmission between processors that may use separate address space.","In efforts to increase efficiencies, commercial and industrial process control may have become increasingly automated. A wide variety of sensors, actuators and other process monitoring and\/or control devices may monitor and adjust the commercial and\/or industrial process through one or more processors of the process system. For example, the sensors may monitor operating parameters for the process, or may evaluate process flow and may provide feedback data regarding the monitored parameters or process status. The feedback data may be provided to one or more of the processors, which may then store and use the data to generate system control signals that one or more actuators may use to adjust the process. To communicate with the process control devices, the processors may typically operate by an operating system, such as Windows NT, Solaris, OSE, or other known operating system, which enables the processor to communicate with the process control devices.","Commercially available software may also be employed to interface the process control devices with the operating system of the processors of the process control system. Such software may not directly integrate with some of the processor operating systems and thus may have to be customized for operation with the processor operating system by an experienced programmer. As an example, customization of process control device software designed to operate in a Windows NT environment, which can employ a machine architecture that orders bytes of data values in memory from least to most significant, may be required such that the process control device may communicate with the process control system that may be operating in a Solaris or OSE environment, where the bytes of data values can be ordered from most to least significant. Additionally, system upgrades, maintenance and\/or process control device changes may require reprogramming. Thus, the added costs associated with providing compatible processors and process control devices may substantially increase installation, operation, maintenance and upgrade costs for the automated process control system.","Data values may be sent between the processors and the applications and\/or between the processors themselves. Thus, it may be necessary to ensure that data structures are compatible among the processors and\/or process control devices. A mechanism to provide flexibility for applications to build and interpret data structures, such that the data values that may be contained within the data structures may be exchanged between processors and\/or process control devices may reduce the costs for providing compatibility between processors and\/or process control devices.","The disclosed methods and systems include a method of exchanging at least one data value between a first device and at least one second device, which include providing at least one data structure at the first device, the data structure including at least one descriptive field and an associated at least one data value field, the at least one data value field including the least one data value, the at least one descriptive field including a usage type field having usage type data to associate the at least one data value field with a data type, transmitting the at least one data structure from the first device to the at least one second device, and, based on at least the usage type data, at the at least one second device, extracting the at least one data value from the at least one data value field. The at least one data structure can include at least one header data structure and at least one non-header data structure, the at least one header data structure specifying a machine architecture associated with the first device.","The data structure(s) can include a value record, the at least one header data structure can be a header container, and the at least one non-header data structure can be at least one of: a single container, a double container, a bytegroup container, a string container, an array container, and a structured data container.","The data structure(s) can include a data structure version type field, a template field, and\/or a template identification field, where such fields can be part of the descriptive fields. The descriptive field(s) can include a pointer to at least one second data structure, the at least one second data structure including a descriptive field(s) and an associated data value field(s). Accordingly, extracting the data value(s) from the data structure(s) can include identifying a pointer to a second data structure(s), and, based on the pointer and a descriptive field(s) in the data structure(s), extracting the data value(s) from the data value field(s). Extracting can thus include iteratively identifying a pointer until the pointer value is NULL.","The disclosed methods and systems thus allow for an exchange of data values when the first device and at least one of the at least one second device have a different architecture. Different architecture can include processor architecture. Accordingly, as provided herein, fields can include a memory element or part thereof, and a data structure can be comprised of one or more memory elements and\/or fields. As provided herein, a data structure can include one or more data fields that include data to be transmitted, and one or more descriptive fields to describe or otherwise be associated with the data to be transmitted. The disclosed methods and systems can accordingly allow for a data structure that includes at least two data structure(s) that can have different usage type data, where usage type data can be: a signed short integer type, a signed long integer type, a character type, a signed real number type, an unsigned short integer type, an unsigned long integer type, a boolean type, an unsigned character type, a 64-bit real number type, a string type, and\/or an undetermined type.","In one embodiment, the methods and systems include determining from the descriptive field(s) that the data structure(s) is a template, and, based on whether the data structure(s) is a template, identifying a template identifier from the descriptive field(s), and, storing the template with the template identifier. The methods and system also include determining from the descriptive field(s) that the data structure(s) includes a data-only data structure(s), and, based on the determination, identifying a template identifier from the at least one descriptive field, retrieving a template associated with the template identifier, and extracting the data value(s) from the data structure(s) based at least on the template. The methods and systems can allow the template to be stored, retrieved, and\/or accessed via a wired and\/or wireless network, and\/or the template can reside locally. When a data value(s) is extracted based on a template, the data value(s) can be extracted based on at least one descriptive field of the retrieved template.","The methods and systems can facilitate methods and systems where the first device may use a first address space, and the second device(s) may use a second address space(s).","The disclosed methods and systems also include a method of exchanging data between a first device and at least one second device, including defining a data structure having at least one descriptive field and the data, where at least one descriptive field indicates the data structure is at least one of: a template structure, a data-only structure, and a complete structure; based on whether the data structure is a template structure and a data-only structure, providing at least one descriptive field to identify a template identification; providing at least one descriptive field to identify a data structure type; based on at least one of the template identification and the data structure type, assembling the at least one data structure; transmitting the at least one assembled data structure between the first device and the at least one second device; and, at the at least one second device, extracting the data based on at least one of whether the data structure is a template structure, a data-only structure, and a complete structure, and, the data structure type.","The method and systems include extracting the template identification as the data when the data structure is a template structure and\/or a data-only structure. In an embodiment, based on the data structure being a template structure, extracting the data can include storing the template and a template identification associated with the template structure. Accordingly, based on the data structure being a data-only structure, extracting can include retrieving a template based on a template identification, and based on the retrieved template and the descriptive fields in the retrieved template, extracting the data from the data-only structure.","In the disclosed methods and systems, extracting the data from the data structure(s) can include extracting based on a descriptive field associated with an architecture of the first device. Extracting can also be based on a descriptive field associated with a data type of the data structure(s).","As provided herein, records and containers can be understood to be data structures.","To provide an overall understanding, certain illustrative embodiments will now be described; however, it will be understood by one of ordinary skill in the art that the systems and methods described herein can be adapted and modified to provide systems and methods for other suitable applications and that other additions and modifications can be made without departing from the scope of the systems and methods described herein.","Unless otherwise specified, the illustrated embodiments can be understood as providing exemplary features of varying detail of certain embodiments, and therefore features, components, modules, and\/or aspects of the illustrations can be otherwise combined, separated, interchanged, and\/or rearranged without departing from the disclosed systems or methods. Additionally, the shapes and sizes of components are also exemplary, unless otherwise provided, and can be altered without affecting the disclosed systems or methods.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 1A","FIG. 1A"],"b":["12","14","12","12","14"]},"With reference to the  embodiment, the second device  can be a process control device that can monitor or adjust the process controlled by first device . The second device  can also include a processor that may control a part of the process controlled by the first device , or a related or separate process. Generally, data signals between the first and second devices ,  may affect the control of the process. It can be understood that the first and second devices ,  may also be connected to other devices, shown generally as devices A, with which they may exchange data signals over the network N.","With continued reference to , the network N can be one or more networks and\/or network connections that can include one or more wired and\/or wireless networks, intranets, the internet, and others. Accordingly, the network can include, for example, a network that can be implemented using Fieldbus, Nodebus, and\/or Ethernet communications protocols, although other wired and\/or wireless communications protocols and\/or standards can be implemented without departing from the scope of the disclosed methods and systems.","With reference to , the first device and\/or second device can include, for example, one or more of the workstations , , control processor(s) , and\/or I\/O modules . As provided previously herein, for example, the illustrated control processor(s)  may communicate one or more VRs  to, for example, the I\/O module(s)  and\/or one or more of the workstations ,  in such a way as to allow the transfer of data to be irrespective of the application running on the receiving device and\/or the processor\/machine type of the receiving device. For a network such as provided in , accordingly, one or more of the workstations  can be replaced with a different machine type, etc., and the disclosed methods and systems can facilitate or otherwise allow the illustrated control processor  to continue communications with such replacement without otherwise requiring the control processor  to reformat the VR data structure.","The  system can be representative of an I\/A Series\u00ae system from Invensys Systems, Inc. The I\/A Series\u00ae system can includes the illustrated I\/O Modules  such as FBM44 modules, wherein the I\/O Modules  can interface to a Fieldbus  and hence to a Control Processor  such as the I\/A Series\u00ae CP40B. Data from sensors  can be transferred to the I\/O modules  using a transmitter, wherein the I\/O Modules  can convert the sensor data to the Control Processor . In one embodiment of the system, the Control Processor  can include at least one processor that includes instructions for causing the processor to implement control algorithms. The Control Processor  can interface to Workstations  through an I\/A Series Nodebus  that can be compatible with Ethernet. The Workstations can be, for example, the VA Series system AW51E that or another system. The Workstations  can have access to one or more internal or external databases, and can allow for the display of data to allow a processor engineer, manufacturing personnel, etc., to monitor and\/or affect the controlled systems. The illustrated Workstations  can further interface to another Ethernet  that provides an interface to, for example, a corporate network that can be equipped with other Workstations , Personal Computers (PCs), etc., that can also have instructions for causing the display\/control to management or other entities.","Returning to the Control Processor , the Control Processor  can be equipped to transfer control data to, for example, the valves or sensors  via the I\/O Modules  to achieve specified control objectives. In one embodiment, the control objectives can be pre-programmed using a multivariable control system such as the Connisseur system provided by Invensys Systems, Inc., however in other embodiments, manufacturing or other process system adjustments can be made manually or through the I\/A Series Workstations . Accordingly, as indicated herein, the disclosed methods and systems can be applied to a system such as systems according to , where the various system elements may use different processors, different operating systems, different architectures, etc., and further, can be individually updated without respect for other system components.","As previously noted, the operating systems and\/or data structures of first and second devices ,  may not be compatible. To provide a common format for the exchange of data between first and second devices , , an Application Programming Interface (API)  may be provided to build and interpret data structures known herein as Value Records (VR's). For the illustrative diagram of , first device  can initiate API  to build a VR  for the data it wishes to exchange with second device . The second device  can then optionally use the API  to interpret the VR . Those of ordinary skill will understand that some embodiments may not employ the API , but may otherwise be configured with instructions for building and\/or interpreting a VR.","A VR  can thus include one or more data elements with information and\/or other data that can be used to identify, describe, and\/or otherwise organize the data element(s). As will provided herein, in some embodiments, the data used to identify, describe, etc., may be provided by another VR  (e.g., template).","A VR  as described herein can include one or more data structures known herein as containers that can be associated with data values or groups of values. A VR  can include data of various types that may be exchanged between devices, such as the first and second devices , , for various device architectures. A VR  can include status and other information that can describe the data value or group of values. A VR  may be constructed to be \u201cself-describing\u201d in that it can include the information needed by a receiving device (e.g., , ) to unpack and understand and\/or otherwise interpret the VR contents using the API . The VR  may be constructed by associating one or more data containers.","For the disclosed methods and systems, the first and second devices (e.g., , ) between which VRs are transmitted may use separate address spaces. Accordingly, the VR can include a self-referencing scheme that can employ an offset and a size for pieces of data within the VR. Unlike other data structures, a VR may not include an address pointer that could be invalid when copied to a different address space.","A VR  can include a \u2018header\u2019 container. A header container can include data to identify the VR to a receiving device. One or more additional containers can be appended to the header container for the data signals that can include data values or additional data, such as structured data, array data and\/or strings. The header container may thus include data and\/or information that can describe general characteristics of VR , such as its overall size, the source (e.g. processor) architecture used while constructing the VR , etc. A VR  size may not exceed a maximum integer value for the device architecture where the VR  and API  may be implemented. As an illustration, for the exemplary 32-bit implementation described herein, the size limit may be the maximum value that can be held in a 32-bit unsigned integer, or about 4.29 gigabytes. It will be understood that other implementations for other device architectures may have other size limits.","Table 1 shows one example of a header container with illustrative data format sizes, although those of ordinary skill will recognize such sizes and data items to be illustrative of one embodiment, and other embodiments can use other formats and fewer and\/or more data items and\/or with different data item names.",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Header Container"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Data",{},"Exemplary"]},{"entry":[{},"Item Name","Data Item Format","Usage\/Meaning"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Allocated size","32 bit unsigned integer","VR size (in bytes)"]},{"entry":[{},"Container","Bits 0-3 of a packed 8-","Type of container (e.g.,"]},{"entry":[{},"type","bit unsigned integer","header)"]},{"entry":[{},"Is_template","Bit 4 of a packed 8-bit","Binary value to indicate"]},{"entry":[{},{},"unsigned integer","whether this VR is a"]},{"entry":[{},{},{},"template."]},{"entry":[{},{},"Bits 5-7 of a packed 8-","The remaining bits of the"]},{"entry":[{},{},"bit unsigned integer","8-bit value. Available"]},{"entry":[{},{},{},"for custom uses."]},{"entry":[{},"Memory style","Bits 0-3 of a packed 8-","Indicates a memory"]},{"entry":[{},{},"bit unsigned integer","allocation scheme."]},{"entry":[{},"Machine_architecture","Bits 4-7 of a packed 8-","Indicates an architecture"]},{"entry":[{},{},"bit unsigned integer","or machine type"]},{"entry":[{},{},{},"corresponding to the"]},{"entry":[{},{},{},"processor on which this"]},{"entry":[{},{},{},"VR was built."]},{"entry":[{},"Version","8-bit unsigned integer","Indicates the availability"]},{"entry":[{},{},{},"of fields, (e.g., such that"]},{"entry":[{},{},{},"a version of VR can be"]},{"entry":[{},{},{},"backward-compatible.)"]},{"entry":[{},"Pad1","8-bit unsigned integer","Can allow for proper byte"]},{"entry":[{},{},{},"alignment. Available for"]},{"entry":[{},{},{},"future use."]},{"entry":[{},"Required_size","32 bit unsigned integer","Number of bytes in use"]},{"entry":[{},{},{},"in this VR (i.e., less than"]},{"entry":[{},{},{},"or equal to"]},{"entry":[{},{},{},"allocated_size)."]},{"entry":[{},"Template_id","32 bit unsigned integer","Identifier number if this"]},{"entry":[{},{},{},"is a template VR or a"]},{"entry":[{},{},{},"corresponding template"]},{"entry":[{},{},{},"exists for this \u2018complete\u2019"]},{"entry":[{},{},{},"VR, otherwise zero."]},{"entry":[{},"Data_only_size","32 bit unsigned integer","Size of a \u2018data-only\u2019"]},{"entry":[{},{},{},"container that"]},{"entry":[{},{},{},"corresponds to the"]},{"entry":[{},{},{},"\u2018complete\u2019 and \u2018template\u2019"]},{"entry":[{},{},{},"versions of this VR."]},{"entry":[{},{},{},"Zero if this VR has no"]},{"entry":[{},{},{},"template."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"Other containers can be appended to the header container, including generic containers, string containers, array containers, and structured data containers. A generic container can include data of some number of contiguous bytes, and can be a \u2018parent\u2019 container type to create container sub-types. Some illustrative sub-types can include \u2018single\u2019 containers (e.g., four bytes), \u2018double\u2019 containers (e.g., eight bytes), and \u2018bytegroup\u2019 containers (e.g., length in bytes as specified when the bytegroup container may be created). While single and double containers can be of fixed size, a bytegroup container may be limited by the \u2018parent\u2019 VR size. Table 2 includes one illustration of a generic container. Table 2, like Table 1 and other Tables herein, is illustrative to show one container for one embodiment, and fewer container elements can be used, and\/or more container elements (e.g., data items) can be used, with the data item formats being provided for illustration and not limitation.",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Generic Container"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Data",{},{}]},{"entry":["Item Name","Data Item Format","Usage"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Size","32 bit unsigned integer","Size of the container. In one"]},{"entry":[{},{},"example, the size can be \u201cn\u201d plus"]},{"entry":[{},{},"10 bytes, where n is the size"]},{"entry":[{},{},"allocated for the contents of the"]},{"entry":[{},{},"\u2018Value\u2019 field"]},{"entry":["Container","8 bit unsigned integer","Examples for the embodiment"]},{"entry":["type",{},"described herein can include"]},{"entry":[{},{},"\u201csingle\u201d, \u201cdouble\u201d, or \u201cbytegroup.\u201d"]},{"entry":["Usage type","8 bit unsigned integer","The data type of the value"]},{"entry":["Next","32 bit unsigned integer","Offset to the next data container"]},{"entry":[{},{},"packaged as part of the VR 18."]},{"entry":[{},{},"When this container is the last data"]},{"entry":[{},{},"container added to the VR 18, this"]},{"entry":[{},{},"value can be zero in one"]},{"entry":[{},{},"embodiment."]},{"entry":["Value","\u2018Size\u2019 less the 10 bytes","Contains the value data"]},{"entry":[{},"defined for the above"]},{"entry":[{},"fields"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"The value field can have an associated \u2018usage type\u2019 field that can be used to identify the data type of the value data item. For instance, a single character placed into the value field of a VR as a 32-bit unsigned integer may be given a corresponding usage type, or data type (e.g., a 32-bit signed integer, a 32-bit unsigned integer, a 32-bit real value, a 64-bit real, etc.) that can indicate a 32-bit unsigned integer. Accordingly, when building a VR , the data type and\/or usage type can be implicit and the user can be responsible for ensuring that the data value entered into the VR  corresponds to the data type that maps to the usage type.","A string container can include one NULL-terminated character string. The string container size, given by the number of characters in the string, can be specified at the time the container is added to the VR . The structure of the string container can be similar to that of the generic \u2018bytegroup\u2019 container, where the length varies per container, based on the string contained in the Value data item. A string container size generally cannot exceed its \u2018parent\u2019 VR size. Table 3 shows one illustrative structure for a string container:",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary \u2018string\u2019 Container"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Data",{},{}]},{"entry":["Item Name","Data Item Format","Usage"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Size","32 bit unsigned integer","Size of container in bytes"]},{"entry":["Container","8 bit unsigned integer","E.g., \u201cstring\u201d"]},{"entry":"type"},{"entry":["Usage type","8 bit unsigned integer","Contains data type \u2018string\u2019"]},{"entry":["Next","32 bit unsigned integer","Offset to the next data container"]},{"entry":[{},{},"packaged as part of the VR 18."]},{"entry":[{},{},"When this container is be the"]},{"entry":[{},{},"last data container added to the"]},{"entry":[{},{},"VR 18, this value may be zero."]},{"entry":["Value","length in bytes varies","Contains the actual string data,"]},{"entry":[{},"per container","including the NULL terminator."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"An array container can include an indexed group, or array of one or more data items, with members of the array being of the same usage type. The size of the items in a group can be, for example, 32- or 64-bits, except for a group of strings, which can be of varying lengths. The array container structure can be similar to that of the generic container, except that an unsigned integer data item \u201ccount\u201d may be added to indicate how many data members may be in the array. An array container size may not exceed that of its \u2018parent\u2019 VR. Table 4 shows one illustrative structure for an array container:",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary \u2018array\u2019 Container"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Data",{},{}]},{"entry":[{},"Item Name","Data Item Format","Usage"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Size","32 bit unsigned integer","Size of array container in bytes"]},{"entry":[{},"Container","8 bit unsigned integer","e.g., \u201carray\u201d."]},{"entry":[{},"type"]},{"entry":[{},"Usage type","8 bit unsigned integer","Data type of the value. Types"]},{"entry":[{},{},{},"may be the same as for a"]},{"entry":[{},{},{},"\u2018generic\u2019 or \u2018string\u2019 container"]},{"entry":[{},"Next","32 bit unsigned integer","Offset to the next data container"]},{"entry":[{},{},{},"packaged as part of the VR 18."]},{"entry":[{},{},{},"When this container is the last"]},{"entry":[{},{},{},"data container added to the VR"]},{"entry":[{},{},{},"18, this value may be zero."]},{"entry":[{},"Count","32 bit unsigned integer","Number of data members in this"]},{"entry":[{},{},{},"array"]},{"entry":[{},"Value[Count]","32- or 64-bit unspecified","Value data for members"]},{"entry":[{},{},"format, or a string"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"A structured data container can provide a means of packaging non-homogeneous data containers of varying types and in varying orders, including generic, string, and array container types, and other structured data containers. Structured data containers may thus be \u2018nested\u2019, e.g., one structured data container may be placed within (e.g., referenced by) another. The levels of nesting and\/or number of data containers added to a structured data container may not exceed the size of the \u2018parent\u2019 VR. Table 5 shows one illustrative structure for a structured data container.","When adding a container to a structured data container, the description information of the container may be added to the structured data container's description area, and\/or the descriptive fields, while the data fields of the added container may be added to the structured data container's data value area, and\/or data value field. The structured data container may include tables of offsets for the added container name, description, and data. Structured data containers may thus include description information and data information, and\/or may include description information only, or data information only. When the same data types and organization of data may be repeatedly communicated between first and second devices , , the structured data container can be used to transmit the description information to the destination once (or another limited number of times), while the data portion can be transmitted repeatedly.",{"@attributes":{"id":"p-0047","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 5"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Structured Data Container"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Data",{},{}]},{"entry":["Item Name","Data Item Format","Usage"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Size","32 bit unsigned integer","Size of this struct container in"]},{"entry":[{},{},"bytes"]},{"entry":["Container","8 bit unsigned integer","e.g., \u201cstruct\u201d"]},{"entry":"type"},{"entry":["Usage type","8 bit unsigned integer","Contains the data type of the"]},{"entry":[{},{},"value. Exemplary types are the"]},{"entry":[{},{},"same as for a \u2018generic\u2019 or"]},{"entry":[{},{},"\u2018string\u2019 container"]},{"entry":["Next","32 bit unsigned integer","Offset to the next data container"]},{"entry":[{},{},"packaged as part of the VR 18."]},{"entry":[{},{},"When this container is the last"]},{"entry":[{},{},"data container added to the VR"]},{"entry":[{},{},"18, this value may be zero"]},{"entry":["Member_count","32 bit unsigned integer","The number of container"]},{"entry":[{},{},"members in this struct"]},{"entry":["Parent","32 bit unsigned integer","Offset to the parent if this is a"]},{"entry":[{},{},"\u2018nested\u2019 struct. When this is the"]},{"entry":[{},{},"\u2018top-level\u2019 struct, this value"]},{"entry":[{},{},"may be zero."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"To build and interpret the VR containers described above, the first and second devices ,  may use external module\/function calls of API . The name of the module, the argument list, data type of respective arguments, and the return type for the module may be representative of an exemplary \u2018C\u2019-language implementation of the API , though it can be understood that implementations in other programming languages compatible with the first and second devices ,  may be contemplated.","VR creation can include a specifying, for example through the API, a memory allocation style, a size parameter corresponding with the memory allocation style, and a pointer to the returned VR container. In some embodiments, memory space can be allocated by choosing from among memory allocation styles, including auto, manual, and reuse. In one embodiment, the chosen memory allocation style can be used throughout the life of the VR, so as reduce errors that can result from mixing memory allocation styles. In an embodiment, bytes of space used to construct a VR can be initialized to NULL before being used.","For the exemplary embodiment, when the \u2018auto\u2019 memory allocation style is selected, the API  can allocate memory to build a VR , and the resultant VR  may be typically a \u2018right-sized\u2019 VR , since API  may allocate enough memory to fulfill the request. In \u2018auto\u2019 mode, the user can specify a size for the VR  to be built. If the VR  exceeds this size, an error can be returned and additional memory may not be automatically allocated. A \u2018size\u2019 of zero in auto mode can indicate no limit is specified for automatic memory allocation. For API , \u2018auto\u2019 may be the default memory allocation style.","When the \u2018manual\u2019 memory allocation style is selected, the user can specify an amount of memory to be allocated. The \u2018size\u2019 parameter can allocate the specified amount of space for the VR  (rounded up to the nearest block boundary). If this size is exceeded while building VR containers into this VR space, an error can be returned. In some embodiments, after such an error call, the user may use an enlarge module\/function call to specify an increase of the overall size of the VR  by some desired and\/or specified amount.","When the \u2018reuse\u2019 memory allocation style is selected, the user can allocate and free memory to build the VR  with the use of API  memory management calls as may be standard for the programming language being used and as provided in the device. The \u2018size\u2019 argument can include the size of the memory block previously allocated by the user. If this space is exceeded, an error can be returned, and the user can be responsible for determining how\/whether additional space should be allocated. For the \u2018reuse\u2019 memory allocation style, the pointer may be a pointer to the block of memory allocated by the user for reuse. In \u2018reuse,\u2019 a previously allocated memory area can be reformatted and used to build the VR .","When it may be time to discard a VR  built with \u2018auto\u2019 or \u2018manual\u2019 memory allocation, the user may use a delete API module\/function to free space. Parameters may include a pointer to an existing VR .","For one exemplary embodiment, the space and\/or memory provided for data in a VR can be 34 bits (e.g., a 20-bit \u2018header\u2019 and one 14-bit generic \u2018single\u2019 container). Use of a container of that size for transmitting a data item may be inefficient in cases when data items may be smaller than the exemplary 34 bits. For example, a group of data that includes 15 status bits and two characters may employ 17 discrete \u2018single\u2019 containers, where one container may be provided for a data item. Considering that the \u2018single\u2019 container can be 14 bytes in size, a total of (17*14)+20, or 258 bytes can be employed. In such cases, the user can provide subroutines that can write\/read these data items to\/from just a single 32-bit container. These routines may assign a unique data range for the data items within one 32-bit data space, fitting the data into the single container with one unused bit. This method may consume a total of 14 bytes for the one \u2018single\u2019 container.","While a VR  that may include data along with a description of itself can be a reliable mechanism, it may be inefficient in cases where the same data types are sent between the same source and destination. In such cases, if the description information is known at both the source and destination, then only the \u2018data\u2019 portion of the VR  can be transmitted. In these embodiments, the data portion of a VR  may be separated from the description portion into an independent container. A complete VR  may still be sent if desired, or the \u2018data-only\u2019 version of the VR  may be sent. Sending a \u2018data-only\u2019 VR  can reduce the size of the VR . Additionally, once the \u2018data-only\u2019 VR  is received at its destination, the description information can be determined more readily, since a single description can apply to the containers in the \u2018data-only\u2019 VR , rather than individual containers having their own descriptions.","The ability to send a \u2018data-only\u2019 VR  can indicate that the description information for the \u2018data-only\u2019 VR  be available to and\/or at the devices (, , A) on the network N, either directly or indirectly (e.g., via a wired or wireless network). The devices (, , A) may maintain and\/or have access to descriptions of the \u2018data-only\u2019 VR 's. The \u2018data-only\u2019 VR  may include a template_ID, such that the description information, or template to which the data in the \u2018data-only\u2019 VR  may be formatted, can be retrieved when a \u2018data-only\u2019 VR  may be received. It can be seen, however, that the devices (, , A) may have their own listings. On large networks N, with large numbers of devices, the size of the listings can exceed the available memory space in the device.","In one embodiment, a DataType server  may be connected to the network N. The DataType server  may include one or more processors accessible to the devices (, , A) via the network N. Server  can be responsible for providing, to a requesting device, the description \u2018template\u2019 for the \u2018data-only\u2019 VR . The description template can include some number of bytes, a numeric ID that can be unique, and an optional name associated with it. Predefined description templates may be loaded into server  at initial startup and additional templates may be created and added by the devices (, , A). When a \u2018data-only\u2019 VR  is received at a device, the device can query server  to obtain the description template.","A template may include of a copy of a VR , with description information and the size and byte order. Data fields and\/or areas may also be placed and sized within the template; however, the data value areas may not include valid data values. Instead, an indicator (e.g., \u2018is_template\u2019 flag, see Table 1) can be set to indicate that the VR  is a template. The data value area\/field for a container can store a pointer that can point to the data in the corresponding \u2018data-only\u2019 version of VR . For example, the first 4 bytes of the data value area\/field can be overloaded to include an unsigned long offset that can be used as the pointer. Other (e.g., unused) bytes of data value area\/field can be initialized to NULL. When a VR  exists with no corresponding template, the two fields \u2018template_ID\u2019 and \u2018data_only_size\u2019 in the header container can include a value of zero. At the time a template is created for VR , the appropriate values can be written into these fields in both the original VR  and the corresponding template VR.","Once the user builds a VR  from one or more containers, the user may use the VR  as a template for future data-only transmissions. The template VR  can reside on a server  accessible on the network, or may be propagated to devices (, , A) on the network that may have interest in receiving the data. API calls for operating with template and data-only VR 's can include calls to create a template, to create a \u2018data-only\u2019 VR , and to restore a \u2018data-only\u2019 VR  to an original VR .","In creating a template, the input and return parameters can include a pointer to a VR  that the template can be created from, a value for template ID, and a pointer to the created template. Once a template exists, the original VR  and its template can be supplied as an input argument to create a \u2018data-only\u2019 VR  from a complete VR . The \u2018data-only\u2019 VR  version can be sent across the network N. At the destination, at least some of the contents of the data-only VR  may not be accessed directly, as the data-only VR  can be queried for its template ID. If a copy of a template VR  containing the template ID can be found at the destination or at a server  on the network N, the template VR  and data-only VR  can be supplied as to produce a copy of the original VR  at the destination. A \u2018data-only\u2019 VR  can thus be restored to a complete VR  based on the template ID.","As noted previously, a VR  may begin with a header container to which one or more containers may be added or appended. In the illustrative \u2018auto\u2019 mode of memory allocation, a new pointer can be provided when a container is added to a VR .","A bytegroup may be some number of contiguous bytes. A bytegroup can be placed into, and retrieved from a VR , but the VR  may have no internal knowledge of this group of bytes. VR  may treat a bytegroup the same as another data value. In this case, VR  may not be completely \u2018self-describing\u2019, i.e., VR  may not have a query routine to examine the internal contents of a bytegroup. Accordingly, the user can provide routines to use or otherwise operate on the group of bytes. A bytegroup may be used to implement \u2018nested\u2019 VR 's. Typically VR  may keep \u2018header\u2019 information in a first container that can describe the internal construction of the VR  with respect to a first container. When nested, confusion may occur as more than one \u2018first\u2019 container can be discovered. By treating the \u2018nested\u2019 VR 's as a simple bytegroup, the VR's  can be nested to a desired level. Unused trailing bytes in the data can be nulled.","A structured data container, or struct, can be added or appended to an existing VR  via the API. Once the struct exists, the contents of the struct (containers or discrete values within the containers) can be filled before other containers are added to the VR . When the struct being added is not be the last container appended to the VR , an error can be generated. As previously described, the VR  may be a \u2018chain\u2019 of containers, where the containers have offset values pointing to the \u2018next\u2019 container in the VR . A container with a NULL value for \u2018next\u2019 can indicate the last container in the VR . A struct, with its non-homogeneous members, may be constructed much the same way.","Once the struct is complete, another container can be appended to the VR  following the struct. When a member container is added to a struct, the struct's total size may change, whereas most other containers, when created, can be fixed in size. The above error can occur when an attempt may be made to add another container (and therefore more space) to an existing struct that may be in the middle of the VR , i.e., with other containers having been appended after that struct. The error can thus prevent new space from being added to a VR  except at the end of the VR.","The API  can provide calls to retrieve the data within a VR . The input parameter for the retrieval, or get, calls may include a pointer to the existing VR , another container within the VR , a string, or a member of a struct container. The output may correspond to the data item name in the call, as shown in Table 2. For example, the output of a call to get the allocated size of the VR  can be the data item in the VR  corresponding to the allocated size. Such get calls can include calls to retrieve allocated size, required size, memory style, container type, usage type, data type, data values, string length, bytegroup, array elements and member names, struct members and member names, index values, member types and VR type, e.g., template, \u2018data-only\u2019, or complete.","API utility and access calls can allow a user to obtain a pointer to the next container within a VR , given a pointer to the previous container. Additional calls include obtaining the number of containers in a VR , and\/or a number of containers remaining between a specified container and the end of the VR . In some embodiments, containers at one level may be counted, e.g., struct containers at the current level, but containers within struct containers may not be counted.","An exemplary API can allow a user to obtain a count of elements in a VR . If the input pointer is to a struct within a VR , the user can be provided with a number of members in that struct. If the input is a pointer to an array within a VR , the user can be provided with a number of elements in that array. If the input is a pointer to a string container within a VR , the user can be provided with a size of the largest string this container can hold. Other utilities may provide a structured text of information extracted from a VR , including data types, sizes and current values of the containers within the VR  that can be used as a debugging tool.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":["FIGS. 2A","FIGS. 2A","FIG. 2A","FIG. 2A"],"b":["2","2","18","2","2","18","30","40","30","52","54","56","18"]},{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 2B","FIG. 2C","FIGS. 2B and 2C","FIG. 2B","FIG. 2C","FIG. 2B","FIG. 2B"],"b":["18","50","60","30","40","52","54","56","18","50","30","50","40","52","54","56","60","62","64","66","68","70","60","40","52","54","56","50","40","52","54","56","60","50"]},{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 3","FIGS. 2A"],"b":["100","18","102","18","104","106","16","2","2"]},"One or more additional containers can be appended  to the header and populated  to complete the VR . The VR  may then be sent and\/or transmitted from one device to another at . Upon receiving the VR , the API  of the receiving device may query the header container to interpret  the container information therein. Using the container information in the header, the data values in the appended containers can be extracted .",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 3","b":["18","110","18","18","118","18","110","112","18","120","20","118","18","122","18"]},"In interpreting a received VR at , the receiving device can determine whether the VR  is a complete, template, or data-only container. For a complete VR, the receiving device can proceed to extract the data values therein, as at . For a template VR, the template may be stored  with the associated template ID at the receiving device. For a data-only VR, the associated template can be retrieved  and applied () to the data-only VR to obtain the complete VR from which the data values can be extracted, as at . If the templates are stored at a device other than the receiving device, such as the server , the retrieval can include a call to that device for the template.","The implementation of the API  and VR  methods and systems may not be limited to particular hardware or software configurations, and may find applicability in many environments wherein data may be exchanged between devices. The methods can be implemented in one or more computer programs executing on one or more programmable computers that include a processor, such as first device , second device  and\/or other devices A, a storage medium readable by the processor, one or more input devices, and one or more output devices. In some embodiments, such as that shown in , the methods and systems may be configured and implemented for use in a network. User control for the systems and methods may be provided through known user interfaces.","The methods and systems described herein are not limited to a particular hardware or software configuration, and may find applicability in many computing or processing environments. The methods and systems can be implemented in hardware or software, or a combination of hardware and software. The methods and systems can be implemented in one or more computer programs, where a computer program can be understood to include one or more processor executable instructions. The computer program(s) can execute on one or more programmable processors, and can be stored on one or more storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), one or more input devices, and\/or one or more output devices. The processor thus can access one or more input devices to obtain input data, and can access one or more output devices to communicate output data. The input and\/or output devices can include one or more of the following: Random Access Memory (RAM), Redundant Array of Independent Disks (RAID), floppy drive, CD, DVD, magnetic disk, internal hard drive, external hard drive, memory stick, or other storage device capable of being accessed by a processor as provided herein, where such aforementioned examples are not exhaustive, and are for illustration and not limitation.","The computer program(s) can be implemented using one or more high level procedural or object-oriented programming languages to communicate with a computer system; however, the program(s) can be implemented in assembly or machine language, if desired. The language can be compiled or interpreted.","As provided herein, the processor(s) can thus be embedded in one or more devices that can be operated independently or together in a networked environment, where the network can include, for example, a Local Area Network (LAN), wide area network (WAN), and\/or can include an intranet and\/or the internet and\/or another network. The network(s) can be wired or wireless or a combination thereof and can use one or more communications protocols to facilitate communications between the different processors. The processors can be configured for distributed processing and can utilize, in some embodiments, a client-server model as needed. Accordingly, the methods and systems can utilize multiple processors and\/or processor devices, and the processor instructions can be divided amongst such single or multiple processor\/devices.","The device(s) or computer systems that integrate with the processor(s) can include, for example, a personal computer(s), workstation (e.g., Sun, HP), personal digital assistant (PDA), handheld device such as cellular telephone, laptop, handheld, or another device capable of being integrated with a processor(s) that can operate as provided herein. Accordingly, the devices provided herein are not exhaustive and are provided for illustration and not limitation.","References to \u201ca microprocessor\u201d and \u201ca processor\u201d, or \u201cthe microprocessor\u201d and \u201cthe processor,\u201d can be understood to include one or more microprocessors that can communicate in a stand-alone and\/or a distributed environment(s), and can thus can be configured to communicate via wired or wireless communications with other processors, where such one or more processor can be configured to operate on one or more processor-controlled devices that can be similar or different devices. Furthermore, references to memory, unless otherwise specified, can include one or more processor-readable and accessible memory elements and\/or components that can be internal to the processor-controlled device, external to the processor-controlled device, and can be accessed via a wired or wireless network using a variety of communications protocols, and unless otherwise specified, can be arranged to include a combination of external and internal memory devices, where such memory can be contiguous and\/or partitioned based on the application. Accordingly, references to a database can be understood to include one or more memory associations, where such references can include commercially available database products (e.g., SQL, Informix, Oracle) and also proprietary databases, and may also include other structures for associating memory such as links, queues, graphs, trees, with such structures provided for illustration and not limitation.","References to a network, unless provided otherwise, can include one or more intranets and\/or the internet. References herein to microprocessor instructions or microprocessor-executable instructions, in accordance with the above, can be understood to include programmable hardware.","While the method and systems have been disclosed in connection with the illustrated embodiments, various modifications and improvements thereon will become readily apparent to those skilled in the art. For example, the module\/function calls, container configurations, data, memory and\/or other components as may be described herein may be merely exemplary of the VR  and API , and can include one or more modules. Those with ordinary skill in the art will recognize that such functions, configurations and\/or structures may be merely for illustrative purposes, and can be varied in an internally consistent manner without departing from the scope of the disclosed methods and systems.","The aforementioned changes are also merely illustrative and not exhaustive, and other changes can be implemented without affecting the ability of the API  and VR  to facilitate communication among first device , second device  and\/or other devices A. Accordingly, many additional changes in the details and arrangement of parts, herein described and illustrated, can be made by those skilled in the art. It will thus be understood that the following claims are not to be limited to the embodiments disclosed herein, can include practices otherwise than specifically described, and are to be interpreted as broadly as allowed under the law."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 2C","FIG. 2B"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
