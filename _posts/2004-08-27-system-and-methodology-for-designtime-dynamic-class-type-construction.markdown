---
title: System and methodology for design-time dynamic class type construction
abstract: A system and methodology for design-time dynamic class type construction is described. In one embodiment, for example, in a form-based development system, a method is described for dynamically constructing a form under an object framework during development of an application by a user, the method comprises steps of: providing an ancestor class under an object framework, the ancestor class for representing a form in the development system; in response to user input, creating a descendant class inheriting from the ancestor class for representing a particular form to be included in the application; generating instructions for creating methods of the descendant class under the object framework; creating a type delegator for the descendant class, thereby enabling the descendant class to track changes made to the particular form during development of the application; creating an instance of the descendant class; and constructing the particular form in the development system based on the instance of the descendant class.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07665062&OS=07665062&RS=07665062
owner: Borland Software Corporation
number: 07665062
owner_city: Austin
owner_country: US
publication_date: 20040827
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","COPYRIGHT STATEMENT","APPENDIX DATA","BACKGROUND OF INVENTION","SUMMARY OF INVENTION","DETAILED DESCRIPTION OF A PREFERRED EMBODIMENT","Glossary","INTRODUCTION","DETAILED OPERATION"],"p":["The present application is related to and claims the benefit of priority of the following commonly-owned, provisional application(s): application Ser. No. 60\/521,791, filed Jul. 2, 2004, entitled \u201cSystem and Methodology for Design-Time Dynamic Class Type Construction\u201d, of which the present application is a non-provisional application thereof. The disclosure of the foregoing application is hereby incorporated by reference in its entirety, including any appendices or attachments thereof, for all purposes.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","Computer Program Listing Appendix under Sec. 1.52(e): This application includes a transmittal under 37 C.F.R. Sec. 1.52(e) of a Computer Program Listing Appendix. The Appendix, which comprises text file(s) that are IBM\u00ae-PC machine and Microsoft\u00ae Windows Operating System compatible, includes the below-listed file(s). All of the material disclosed in the Computer Program Listing Appendix can be found at the U.S. Patent and Trademark Office archives and is hereby incorporated by reference into the present application.","1. Field of the Invention","The present invention relates generally to information processing environments and, more particularly, to a system and methodology for design-time dynamic class type construction.","2. Description of the Background Art","Before a digital computer may accomplish a desired task, it must receive an appropriate set of instructions. Executed by the computer's microprocessor, these instructions, collectively referred to as a \u201ccomputer program\u201d, direct the operation of the computer. Expectedly, the computer must understand the instructions which it receives before it may undertake the specified activity.","Owing to their digital nature, computers essentially only understand \u201cmachine code\u201d, i.e., the low-level, minute instructions for performing specific tasks\u2014the sequence of ones and zeros that are interpreted as specific instructions by the computer's microprocessor. Since machine language or machine code is the only language computers actually understand, all other programming languages represent ways of structuring human language so that humans can get computers to perform specific tasks.","While it is possible for humans to compose meaningful programs in machine code, practically all software development today employs one or more of the available programming languages. The most widely used programming languages are the \u201chigh-level\u201d languages, such as C++, Pascal, Java\u00ae, and C#\u00ae. These languages allow data structures and algorithms to be expressed in a style of writing that is easily read and understood by fellow programmers.","A language \u201ccompiler\u201d is a program that takes human authored source code logic and transforms that into mechanical binary logic (machine code instructions) for a given target program. In a typical implementation, a compiler includes operational stages of scanning\/parsing the source code, tokenizing the source code, and recognizing symbols and language logic, for purposes of converting the source code into an internal representation. A modern day compiler will iterate over the internal representation to optimize the selection of machine code instructions. Ultimately, the compiler emits a sequence of machine code instructions which comprise the binary logic for the compiled source code. The ultimate output of the compiler is a compiled module such as a compiled C++ \u201cobject module\u201d, which includes instructions for execution ultimately by a target processor, or a compiled Java class, which includes bytecodes for execution ultimately by a Java virtual machine.","Although an object module includes code for instructing the operation of a computer, the object module itself is not usually in a form which may be directly executed by a computer. This binary logic is typically linked with other compiled modules to produce the ultimate executable program. Linking may be thought of as the general process of combining or linking together one or more compiled object modules or units to create an executable program. This task usually falls to a program called a \u201clinker.\u201d After resolving interconnecting references as needed, the linker constructs an executable image by organizing the object code from the modules of the program in a format understood by the operating system program loader. The end result of linking is executable code (typically an .EXE file) which, after testing and quality assurance, is passed to the user with appropriate installation and usage instructions.","Integrated development environments, such as Borland\u00ae Delphi\u2122, Borland\u00ae JBuilder\u00ae, and Borland\u00ae C# Builder\u00ae (all available from assignee Borland Software Corporation of Scotts Valley, Calif.), are the preferred application development environments for quickly creating production applications. Such environments are characterized by an integrated development environment (IDE) providing a form designer, a property getter\/setter manager (\u201cinspector\u201d), a project manager, a tool palette (with objects which the user can drag and drop on forms), an editor, a debugger, and a compiler. In general operation, the user \u201cpaints\u201d objects on one or more forms, using the form designer. Attributes and properties of the objects on the forms can be modified using the property manager or inspector. In conjunction with this operation, the user attaches or associates program code with particular objects on the screen (e.g., button object). Typically, code is generated by the IDE in response to user actions in the form designer and the user then manipulates the generated code using the editor. Changes made by the user to code in the editor are reflected in the form designer, and vice versa. After the program code has been developed, the compiler is used to generate object code for execution on a machine.","Today, most software development occurs within the context of a development framework. Microsoft's .NET framework is a new framework that has gained a lot of attention lately. The .NET framework is a collection of classes implemented on top of a Common Language Runtime (\u201cCLR\u201d) system providing containers, strings, components, interfaces, streams, and user interface control classes for use by programmers writing applications to run in the .NET execution environment (the .NET platform). The CLR is a program execution architecture which includes rich type information at runtime, an intermediate abstract machine instruction set that is compiled to native machine instructions at runtime, and a variety of system services to automate remote procedure calls over network connections, security checks, and garbage-collected memory management. The core infrastructure of CLR is defined in documents published by the ECMA standards body (Ecma International, a European association for standardizing information and communication systems). Technically, the .NET architecture can be implemented independently of Microsoft, such as illustrated by the Mono project by Novell, Inc. of Waltham, Mass.","With adoption of new development frameworks, such as Microsoft's .NET framework, a problem arises with efficiently migrating existing programs and tools to these new development frameworks. For example, the form designer used in the Borland\u00ae Delphi\u2122 IDE running on Microsoft Windows 32-bit operating systems (hereinafter \u201cWin-32\u201d) relies on being able to dynamically construct a new form class \u201con-the-fly\u201d. To dynamically construct a new form class, additional metadata is added to a class that describes its layout and structure based on what the compiler saw at compile-time. Things like the class name of the new form class as well as method names, method addresses, field names and field addresses, and the like are encoded into tables that are accessible at run-time. These tables are used by the property-based streaming system to allow persisting of any type of class. By generating these tables \u201con-the-fly\u201d, the layout and structure of a \u201cnew\u201d form class can be simulated as it is being constructed by the form designer. The property-based streaming system does not know the difference between the newly built class and a compiler-built class. Thus, when an instance of this new class is constructed it appears, for all intents and purposes, to be an instance of the new class type.","A problem arises however in attempting to use this same approach in conjunction with new development frameworks, such as the Microsoft .NET framework. In order to use Microsoft's .NET framework and the Common Language Runtime (hereinafter, the \u201c.NET framework\u201d), one must follow certain rules set forth by the .NET framework. In this environment it is not feasible to dynamically construct a new class on-the-fly by generating the class metadata as a function of in-memory tables of a certain structure. This approach is not permitted in a managed code environment such as that provided by the .NET framework.","From a user standpoint, however, the user that is developing an application for a new framework (e.g., the .NET framework) wants to be able to use the existing development tools and interfaces in the same manner as in the past. Although other form-based designers are available (e.g., Microsoft WinForm designer), it does not provide the same features or functionality and would require developers already familiar another designer (e.g., the Delphi form designer) to learn a new tool. The ability to use existing tools with which a developer\/user is familiar makes it easier to transition to a new framework. However, to provide the familiar development tools and interfaces (e.g., an IDE form designer) on the new framework requires modifications to the underlying infrastructure supporting the operation of these development tools because of the constraints imposed by the new framework (e.g., the .NET framework).","For example, the .NET framework imposes certain constraints which preclude directly accessing raw metadata information, including the metadata which describes the different classes and types in the system. In contrast, in the native Win-32 machine code generated environment, metadata information could be directly generated and manipulated (e.g., in the dynamic creation of forms by an IDE). For instance, in the Win-32 environment, the dynamic generation of forms by the Delphi form designer is implemented based on the ability to control the raw metadata information and perform direct manipulation of that information. Creating and regenerating forms in the form designer in this environment relies on this ability to directly manipulate metadata information. The Microsoft .NET framework environment, however, does not allow this type of direct metadata manipulation as it violates the tenets that the managed execution environment supports. Accordingly, in order to provide users (e.g., application developers) with the same development experience of the familiar form designer of existing development systems (e.g., the Delphi development system), the underlying infrastructure of the development system must be modified in order to provide this functionality in the managed execution environment provided by the .NET framework.","What is needed is a solution that enables a new class type to be dynamically constructed \u201con-the-fly\u201d at design time on a development framework, such as the .NET framework. The solution should, for instance, be able to persist the state of a form that is being visually designed in a development system without direct generation and manipulating of underlying metadata information. Also, the solution should be implemented in a manner that does not require the existing development environment in which the form designer is implemented to be completely rearchitected. Ideally, the ability to support dynamic generation of forms should be implemented in an isolated way that does not require wholescale modification of the entire development environment. The present invention provides a solution to these and other needs.","A system and methodology for design-time dynamic class type construction is described. In one embodiment, for example, in a form-based development system, a method of the present invention is described for dynamically constructing a form under an object framework during development of an application by a user, the method comprises steps of: providing an ancestor class under an object framework, the ancestor class for representing a form in the development system; in response to user input, creating a descendant class inheriting from the ancestor class for representing a particular form to be included in the application; generating instructions for creating methods of the descendant class under the object framework; creating a type delegator for the descendant class, thereby enabling the descendant class to track changes made to the particular form during development of the application; creating an instance of the descendant class; and constructing the particular form in the development system based on the instance of the descendant class.","In another embodiment, for example, a development system of the present invention for dynamically constructing a form responsive to user input under an object framework during development of an application is described that comprises: an ancestor class for representing the form under the object framework; a proxy module for creating a descendant class inheriting from the ancestor class in response to user input, dynamically generating methods of the descendant class, and constructing an instance of the descendant class under the object framework for representing a particular form in the development system; a type delegator for the descendant class for persisting user input on the particular form during development of the application; and a module for displaying the particular form in a user interface of the development system based on the descendant class and the persisted user input.","The following definitions are offered for purposes of illustration, not limitation, in order to assist with understanding the discussion that follows.","Assembly: An assembly is a primary building block of a .NET framework program. It is a collection of functionality that is built, versioned, and deployed as a single implementation unit containing one or more classes or files. Further description of the creation and use of assemblies is available in the \u201c.NET Framework Developer's Guide\u201d available from Microsoft Corporation of Redmond, Wash. A copy of this documentation is available via the Internet (e.g., currently at msdn.microsoft.com).","Common Language Runtime (CLR): A program execution architecture which includes rich type information at runtime, an intermediate abstract machine instruction set that is compiled to native machine instructions at runtime, and a variety of system services to automate remote procedure calls over network connections, security checks, and garbage-collected memory management.","Compiler: A compiler is a program which translates source code into object code to be executed by a computer. The compiler derives its name from the way it works, looking at the entire piece of source code and collecting and reorganizing the instructions. Thus, a compiler differs from an interpreter which analyzes and executes each line of code in succession, without looking at the entire program. A \u201cJava compiler\u201d translates source code written in the Java programming language into bytecode for the Java virtual machine.","Linker: A program that combines object code modules to form an executable program, including replacing symbolic addresses with real addresses.","Microsoft\u00ae .NET: A Microsoft platform that incorporates applications and a suite of tools and services.","Microsoft\u00ae .NET Framework: A collection of classes implemented on top of a CLR system providing containers, strings, components, interfaces, streams, and user interface control classes for use by programmers writing applications to run in the .NET execution environment (the .NET platform). Further description of the .NET Framework is available in the \u201c.NET Framework Developer's Guide\u201d available from Microsoft Corporation of Redmond, Wash., the disclosure of which is hereby incorporated by reference. A copy of this documentation is available via the Internet (e.g., currently at msdn.microsoft.com).","Referring to the figures, exemplary embodiments of the invention will now be described. The following description will focus on the presently preferred embodiment of the present invention, which is implemented in desktop and\/or server software (e.g., driver, application, or the like) operating in an Internet-connected environment running under an operating system, such as the Microsoft Windows\u00ae operating system. The present invention, however, is not limited to any one particular application or any particular environment. Instead, those skilled in the art will find that the system and methods of the present invention may be advantageously embodied on a variety of different platforms, including Macintosh\u00ae, Linux\u00ae, Solaris\u2122, UNIX\u00ae, FreeBSD\u00ae, and the like. Therefore, the description of the exemplary embodiments that follows is for purposes of illustration and not limitation. The exemplary embodiments are primarily described with reference to block diagrams or flowcharts. As to the flowcharts, each block within the flowcharts represents both a method step and an apparatus element for performing the method step. Depending upon the implementation, the corresponding apparatus element may be configured in hardware, software, firmware or combinations thereof.","Computer-Based Implementation","Basic System Hardware (e.g., for Desktop and Server Computers)","The present invention may be implemented on a conventional or general-purpose computer system, such as an IBM-compatible personal computer (PC) or server computer.  is a very general block diagram of a computer system (e.g., an IBM-compatible system) in which software-implemented processes of the present invention may be embodied. As shown, system  comprises a central processing unit(s) (CPU) or processor(s)  coupled to a random-access memory (RAM) , a read-only memory (ROM) , a keyboard , a printer , a pointing device , a display or video adapter  connected to a display device , a removable (mass) storage device  (e.g., floppy disk, CD-ROM, CD-R, CD-RW, DVD, or the like), a fixed (mass) storage device  (e.g., hard disk), a communication (COMM) port(s) or interface(s) , a modem , and a network interface card (NIC) or controller  (e.g., Ethernet). Although not shown separately, a real time system clock is included with the system , in a conventional manner.","CPU  comprises a processor of the Intel Pentium\u00ae family of microprocessors. However, any other suitable processor may be utilized for implementing the present invention. The CPU  communicates with other components of the system via a bi-directional system bus (including any necessary input\/output (I\/O) controller circuitry and other \u201cglue\u201d logic). The bus, which includes address lines for addressing system memory, provides data transfer between and among the various components. Description of Pentium-class microprocessors and their instruction set, bus architecture, and control lines is available from Intel Corporation of Santa Clara, Calif. Random-access memory  serves as the working memory for the CPU . In a typical configuration, RAM of sixty-four megabytes or more is employed. More or less memory may be used without departing from the scope of the present invention. The read-only memory (ROM)  contains the basic input\/output system code (BIOS)\u2014a set of low-level routines in the ROM that application programs and the operating systems can use to interact with the hardware, including reading characters from the keyboard, outputting characters to printers, and so forth.","Mass storage devices ,  provide persistent storage on fixed and removable media, such as magnetic, optical or magnetic-optical storage systems, flash memory, or any other available mass storage technology. The mass storage may be shared on a network, or it may be a dedicated mass storage. As shown in , fixed storage  stores a body of program and data for directing operation of the computer system, including an operating system, user application programs, driver and other support files, as well as other data files of all sorts. Typically, the fixed storage  serves as the main hard disk for the system.","In basic operation, program logic (including that which implements methodology of the present invention described below) is loaded from the removable storage  or fixed storage  into the main (RAM) memory , for execution by the CPU . During operation of the program logic, the system  accepts user input from a keyboard  and pointing device , as well as speech-based input from a voice recognition system (not shown). The keyboard  permits selection of application programs, entry of keyboard-based input or data, and selection and manipulation of individual data objects displayed on the screen or display device . Likewise, the pointing device , such as a mouse, track ball, pen device, or the like, permits selection and manipulation of objects on the display device. In this manner, these input devices support manual user input for any process running on the system.","The computer system  displays text and\/or graphic images and other data on the display device . The video adapter , which is interposed between the display  and the system's bus, drives the display device . The video adapter , which includes video memory accessible to the CPU , provides circuitry that converts pixel data stored in the video memory to a raster signal suitable for use by a cathode ray tube (CRT) raster or liquid crystal display (LCD) monitor. A hard copy of the displayed information, or other information within the system , may be obtained from the printer , or other output device. Printer  may include, for instance, an HP Laserjet printer (available from Hewlett Packard of Palo Alto, Calif.), for creating hard copy images of output of the system.","The system itself communicates with other devices (e.g., other computers) via the network interface card (NIC)  connected to a network (e.g., Ethernet network, Bluetooth wireless network, or the like), and\/or modem  (e.g., 56K baud, ISDN, DSL, or cable modem), examples of which are available from 3Com of Santa Clara, Calif. The system  may also communicate with local occasionally-connected devices (e.g., serial cable-linked devices) via the communication (COMM) interface , which may include a RS-232 serial port, a Universal Serial Bus (USB) interface, or the like. Devices that will be commonly connected locally to the interface  include laptop computers, handheld organizers, digital cameras, and the like.","IBM-compatible personal computers and server computers are available from a variety of vendors. Representative vendors include Dell Computers of Round Rock, Tex., Hewlett-Packard of Palo Alto, Calif., and IBM of Armonk, N.Y. Other suitable computers include Apple-compatible computers (e.g., Macintosh), which are available from Apple Computer of Cupertino, Calif., and Sun Solaris workstations, which are available from Sun Microsystems of Mountain View, Calif.","Basic System Software",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 2","b":["100","200","100","200","102","116","210","210","201","201","201","201","201","116","102","100","100"],"i":["a","b","c","d"]},"Software system  includes a graphical user interface (GUI) , for receiving user commands and data in a graphical (e.g., \u201cpoint-and-click\u201d) fashion. These inputs, in turn, may be acted upon by the system  in accordance with instructions from operating system , and\/or client application module(s) . The GUI  also serves to display the results of operation from the OS  and application(s) , whereupon the user may supply additional inputs or terminate the session. Typically, the OS  operates in conjunction with device drivers  (e.g., \u201cWinsock\u201d driver\u2014Windows' implementation of a TCP\/IP stack) and the system BIOS microcode  (i.e., ROM-based microcode), particularly when interfacing with peripheral devices. OS  can be provided by a conventional operating system, such as Microsoft\u00ae Windows 9x, Microsoft\u00ae Windows NT, Microsoft\u00ae Windows 2000, or Microsoft\u00ae Windows XP, all available from Microsoft Corporation of Redmond, Wash. Alternatively, OS  can also be an alternative operating system, such as the previously mentioned operating systems.","The above-described computer hardware and software are presented for purposes of illustrating the basic underlying desktop and server computer components that may be employed for implementing the present invention. For purposes of discussion, the following description will present examples in which of at least one computer running programs designed to run on the .NET platform. The present invention, however, is not limited to any particular environment or device configuration. In particular, the .NET platform is not necessary to the invention, but is used to provide a framework for discussion. Instead, the present invention may be implemented in any type of system architecture or processing environment capable of supporting the methodologies of the present invention presented in detail below.","Base Development System","Shown in detail in , a visual development system  of the present invention, hosted by software system , includes a compiler , a linker , and an interface . Through the interface , a developer user \u201cpaints\u201d forms  with objects and supplies source listings  to the compiler . The interface  includes both command-line driven  and Integrated Development Environment (IDE)  interfaces, the former accepting user commands through command-line parameters, the latter providing menuing equivalents thereof. From the source code or listings , forms , and headers\/includes files , the compiler  \u201ccompiles\u201d or generates object code module(s) or compiled \u201cunits\u201d . In turn, linker  \u201clinks\u201d or combines the units  with runtime libraries  (e.g., standard runtime library functions) to generate executable program(s) , which may be executed by a target processor (e.g., the processor of ). The runtime libraries  include previously-compiled standard routines, such as graphics, I\/O routines, startup code, math libraries and the like. A description of the general operation of development system  is provided in the manuals accompanying Borland Delphi\u2122 version 8, available from Borland Software Corporation of Scotts Valley, Calif. A copy of this document is available via the Internet (e.g., currently at www.borland.com\/products\/downloads\/download-delphi.html#).","General operation (i.e., \u201ccompilation\u201d) by a compiler, such as compiler , comprises two main components: a front end and a back end. The \u201cfront end\u201d of the compiler parses the source program and builds a parse tree\u2014a well known tree data structure representing parsed source code. The \u201cback end\u201d traverses the tree and generates code (if necessary) for each node of the tree, in a post-order fashion. For an introduction to the general construction and operation of compilers, see Fischer et al., \u201cCrafting a Compiler with C\u201d, Benjamin\/Cummings Publishing Company, Inc., 1991, the disclosure of which is hereby incorporated by reference for purposes of illustrating the state of the art. Additional description of a development system suitable for implementation of the present invention is available in the trade and patent literature. For example, the Delphi development system is described in commonly-owned U.S. Pat. Nos. 5,995,756, 6,002,867, 6,151,602, 6,185,728, and 6,002,867. The disclosures of each of the foregoing patents are hereby incorporated by reference for purposes of illustrating the state of the art.","The above-described computer hardware and software are presented for purposes of illustrating the basic underlying desktop and server computer components that may be employed for implementing the development environment of the present invention and deploying applications created therefrom. Although the present invention will typically be implemented in a client\/server environment, the present invention is perfectly suited for implementation on a stand-alone computing device. Further, the discussion which follows focuses on the currently preferred embodiment which employs the Borland Delphi development system and the Microsoft .NET framework as the development system and framework for implementation of the present invention. However, the invention is not tied to any particular framework and is well-suited for use with a variety of different object oriented frameworks. More particularly, the present invention may be implemented in any type of system architecture or processing environment capable of supporting the methodologies of the present invention presented in detail below. Additionally, some examples have been illustrated using the Delphi syntax. However, those skilled in the art will appreciate that the present invention may similarly be implemented in other programming languages (e.g., Java, C++, C#, or the like). The following description will focus on those features of the development system  which are helpful for understanding methods of the present invention for facilitating migration to new object frameworks.","Overview of Design-Time Dynamic Class Type Construction","Before describing the dynamic creation of forms by the system and methodology of the present invention, the operations used to generate forms in the Borland Delphi visual designer (form designer) for the Win-32 platform will be described. In versions of the Delphi development environment for Win-32 platforms, when a user (e.g., application developer) is designing a form using the system's form designer, what in effect happens is that behind the scenes a brand new class type is being created on-the-fly. The system cannot necessarily use the development system's compiler to build this new class type dynamically. Recall that although this is at \u201cdesign time\u201d for the user (e.g., developer) using the IDE to create an application, from the standpoint of the development environment itself it is essentially at runtime (i.e., the development environment itself is actually running as the user develops an application using it). Accordingly, there is a designer subsystem which actually constructs on-the-fly what looks to the rest of the system like a brand new class type by directly generating and manipulating metadata information.","In general terms, the way this is done on Win-32 is that the designer subsystem actually takes the raw class structure information that the compiler had generated from the \u201cancestor\u201d type (e.g., a base TForm type) and copies that information internally to a new block of memory. After copying the information, the system then modifies portions of this metadata. The modifications include, for example, the class name. In addition, the designer subsystem actually overrides and changes the addresses of certain other items of information, so that to the rest of the system it appears like it actually is a new class type, when, in fact, at this point it is what is called a \u201cproxy\u201d class. The proxy class is a proxy for representing a new form that the user is creating using the development system's form designer. As the user is designing a form in the form designer, the system builds this proxy class in such a way that when the compiler actually goes through and compiles the application source code, it will match exactly what was in memory before. In other words, the system does not really \u201csee\u201d the difference at that point. However, the above approach of generating and manipulating raw metadata information may not be possible if the development system is implemented on a new framework. For example, the above approach for dynamically generating forms is not possible in a .NET environment. The .NET framework does not permit one to take the raw metadata structures, copy them around in memory, and then expect the system to recognize them. Accordingly, given the constraints of the .NET environment a different way must be found to enable the IDE's form designer to generate the familiar forms.","The present invention, in its currently preferred embodiment, is implemented as part of the Borland Delphi development system for the .NET platform. As it is not possible to directly generate and manipulate metadata information in .NET, the approach of the present invention is to instead use a number of the metadata APIs that are available within .NET itself to construct the metadata through those APIs. For example, the system actually uses these APIs to indicate that a new class type is needed. These APIs are also used to generate intermediate language (or \u201cIL\u201d) constructions into the new class type that the execution environment will be able to execute. The present invention provides for actually generating methods on the new class at design time on-the-fly. Another \u201ctype descriptor\u201d class is then constructed that provides a sort of proxy \u201chook\u201d that is used by the system of the present invention as hereinafter described. A number of the low level functions and the low-level support that are needed to dynamically generate new class types on-the-fly are currently available in .NET. The system of the present invention is able to take those functions and assemble them and call them in such a way that enables the system to dynamically construct a new class type on-the-fly when needed.","As with the version of the development system for the Win-32 execution environment, in the user interface of the form designer and to the rest of the execution environment (e.g., the .NET execution environment in this case), the newly generated class type appears to be a \u201creal\u201d class that is live. In fact, on the .NET execution environment the newly-generated class type is actually much more \u201clive\u201d than the corresponding Win-32 version. While the new class is still referred to below as a \u201cproxy\u201d, for all intents and purposes it is actually a new class to the execution environment. It should be noted, however, that this new class only exists while the developer is designing\/developing an application. In other words, the class is dynamically constructed on-the-fly (e.g., in response to user input in the form designer). As soon as the developer is done designing it, the system persists what the user has done. After the information has been persisted, the new class itself is then essentially thrown away as it is no longer needed. Whenever the development system actually compiles the application source code, the \u201creal\u201d class is actually constructed at that point.","From a user standpoint, the present invention enables the user to see (and use) the exact same form designer interface that he or she is familiar with. The developer\/user sees a visual design surface (i.e., a form), which may be blank or which may already include items (e.g., components, etc.) if he or she opens an existing (previously designed) form. The components represent visual design elements that the user\/developer normally interacts with during the process of developing applications using the IDE. Examples of these components include edit controls, buttons, labels, and the like. To the user the design surface appears to be the same on Win-32 and on .NET. The developer does not \u201csee\u201d or need to be aware of the fact that behind the scenes the creation of forms using the visual design surface is different on different platforms.","The system of the present invention actually constructs a \u201cproxy\u201d class on-the-fly. This proxy class is modified and changed based on the user's input as the user develops an application in the IDE. To the user it appears on screen like he or she is adding fields to the class, adding new methods to the class, and so forth. The fields represent the different components that the developer places on the form (i.e., the visual design surface). The methods include the different event handlers that will, when the application being developed is completed, respond to various actions of the application end user (e.g., code that is invoked in response to button clicks and the like by the application end user). At design time, the developer\/user actually \u201csees\u201d source code being generated and modified. Behind the scenes the \u201cproxy\u201d class is also being modified in a corresponding fashion to make those modifications visible in the user interface of the IDE. These items have to be visible to the persistence mechanism so that the input by the user (application developer) may be persisted. The persistence mechanism takes and writes this information into a persisting format that can be read and reconstructed at runtime. The components and operations of the system will now be described in more detail.","System Components",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 4","b":["410","420","410","420","410","420"]},"Behind the scenes the form is actually being dealt with internally by the development system as a proxy class . The proxy class  maintains things like the class name (which visually matches the form name that the user is designing), the field definitions, the method definitions, and so forth. The proxy class  is included as part of an assembly (not separately shown at ), which is handed off as sort of a root component or root designer to the persisting mechanism . The persisting mechanism  persists the proxy class  based on certain properties of the proxy class and certain other components. The proxy class  exists as a container which may contain a number of components. The persisting mechanism  causes the proxy class  to iterate through its container recursively (as components may contain other components) and creates references to those components that are streamed out to the file . The proxy class  is the broad data structure that is used for both representing the form visually (e.g., in the form designer and code editor of the IDE) and also to the persisting system (and its streaming subsystem) which actually persist the form. As shown, the persisting mechanism  saves out the proxy class as a file  to persist the user's input on the form  open in the form designer.","Before the application executes at runtime, the source code  that is developed using the development system is compiled. The file  that was generated also gets linked in during the process of creating the executable application . Essentially, the components that were developed get put together at that point. When the class is constructed at runtime, the class knows that it has a persistence store behind it which describes all the components placed onto the form and how these components \u201cwire up\u201d with methods of the class and the like. The system knows to locate and collect the related pieces and then stream them back in and reconstruct them at runtime to generate the appearance and behavior implemented by the developer at design time.","The core design-time dynamic class type construction functionality of the present invention is currently implemented in a single module (file). Functions and procedures of this module are described below in greater detail. Some other modules play a supporting role. There is one internal class which is the proxy type itself, which is actually a descendant of a regular .NET type which is referred to herein as the \u201ctype delegator\u201d. The type delegator allows one to intercept (or \u201cget in the way\u201d) of the normal metadata API calls so that metadata can be manipulated to create class types on-the-fly. In effect, the proxies that are created intercept and use several metadata API calls. To the metadata APIs, the proxies are calling through type delegators and mechanisms that have constructed these new types on the fly as is they were the \u201creal\u201d types. The proxies make the calls into the metadata information and access the metadata information as if they were \u201creal\u201d types. However, for implementation on the .NET framework they have to do it indirectly through the APIs that are presented by .NET.","The present invention may be considered as constructing a type of \u201cshim\u201d or \u201cwedge\u201d that is placed into several different locations. This shim or wedge allows the system to observe certain metadata API calls as they are being made and make the appropriate redirections as needed (or vector them to the right types that are applicable). The system of the present invention actually constructs a new assembly internally in memory on-the-fly. The assembly contains a module, which in turn contains a type which is a class. This class is the proxy type which is constructed as described below in greater detail. The methodology of the present invention also provides for overriding certain methods as the proxy class is being generated. As the proxy class is created the system generates intermediate language (IL) code that allows \u201chooking\u201d the overridden methods. These operations are described below in greater detail.","The following description presents method steps that may be implemented using processor-executable instructions, for directing operation of a device under processor control. The processor-executable instructions may be stored on a computer-readable medium, such as CD, DVD, flash memory, or the like. The processor-executable instructions may also be stored as a set of downloadable processor-executable instructions, for example, for downloading and installation from an Internet location (e.g., Web server).","Creating Form on Visual Design Surface",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIGS. 5A-B","b":"500"},"At step , a developer that is developing an application using an IDE in which the present invention is embodied selects a form for display in the form designer. In response, the system of the present invention commences the process of dynamically constructing the form. At step , the system performs a name search to determine what the name of the form should be. During the process of constructing the form the IDE itself determines the name of the form and selects a name that is not already in use. For instance, a name such as \u201cTForm1\u201d may be selected for the new form. Before presenting a design surface to the developer\/user, the underlying \u201cproxy\u201d class which supports the form must be constructed. At this point, the system knows that the developer\/user wants to create a form that is a descendant of a TForm class. The TForm class is a stock (or base) class which is implemented under the VCL for .NET framework. VCL refers to the Visual Component Library which is a framework implemented on top of the CLR (Common Language Runtime) and the .NET framework and supported in the currently preferred embodiment of the present invention. Several of the classes and components referenced herein, such as TForm, are provided as part of the VCL for .NET framework.","At step , a proxy function is called to create a subclass of the TForm class. The TForm class is referred to as the \u201cancestor\u201d of the subclass that is being created. The subclass is referred to as a \u201cdescendant\u201d of the TForm class. In the case of a Win-32 implementation, the creation of a form would then involve locating the metadata block of memory that the compiler generated for the ancestor form (i.e., TForm), copying that metadata to a new block of memory, and then manipulating the copied metadata (e.g., modifying a few pointers\/locations), such that the new block of metadata now appeared to be a new class type. However, this is not permissible in the case of a .NET implementation, so the process of dynamically constructing the form proceeds as described below.","At step , a new assembly is constructed in memory and it is given a new name. In the currently preferred embodiment, some sort of \u201cproxy\u201d name is used for the new assembly. An assembly is a primary building block of a .NET framework program. It is a collection of functionality that is built, versioned, and deployed as a single implementation unit containing one or more classes or files. There are a number of .NET APIs that can be used for actually constructing this assembly. Further description of the creation and use of assemblies is available in the \u201c.NET Framework Developer's Guide\u201d available from Microsoft Corporation of Redmond, Wash. A copy of this documentation is available via the Internet (e.g., currently at msdn.microsoft.com).","At step , a class (i.e., subclass) is constructed which is a descendant of a class of the type that is being constructed (i.e., an ancestor class). In this example, the class that is constructed is a descendant of the TForm class. Although a new class (subclass) is being created at this point, it should be noted that this is done using the actual emit metadata APIs and the like provided by the .NET framework. For example, System.Reflection.Emit namespace of the .NET framework contains classes that allow a compiler or tool to emit metadata and Microsoft intermediate language (MSIL) and optionally generate a PE file on disk. Further description of the System.Reflection.Emit namespace is provided in the above-referenced \u201c.NET Framework Developer's Guide\u201d. As part of this construction process, the new class (subclass) is told what its ancestor is (i.e, TForm).","The new class must also be given a constructor because the .NET framework rules provide that all classes must have a constructor. At step , a constructor is built for the new class (subclass). It should be noted that this diverges significantly from the prior Win-32 approach because at this point as the constructor that is created actually includes \u201creal\u201d code. In creating the constructor, actual .NET intermediate language (IL) code is generated on-the-fly. Typically, the constructor may contain nothing more than a callback to its ancestor's constructor, but a constructor is created as it is a requirement for the class to have a constructor. After the constructor is created, at step  additional IL code is generated to override certain methods of the ancestor class (i.e., to override methods of the TForm class). The methods that are overridden include notification methods of the ancestor class. For implementation of the present invention, the system needs to know when components are added to (and deleted from) the form and so forth. When a developer\/user drops a component (e.g., a button object) onto a form (i.e., visual design surface), in a number of cases that component during its construction may actually construct other components. Accordingly, the present invention has to be able to track the creation, renaming, and deletion of components. To do so, the notification methods of the ancestor class are \u201chooked\u201d by generating a new method (using IL code) that is an override of the ancestor's notification method. The method that is generated is a virtual override of the base (ancestor) class.","After the \u201cproxy\u201d class has been constructed, at step  an instance of the class is created. Note that this is different than in the Win-32 environment which generally starts with an existing instance, constructs the class instance, and then changes its type on-the-fly. In the .NET environment, the type cannot actually be changed on-the-fly (i.e., dynamically). As a result, the methodology of the present invention provides for actually constructing the class, including the type information, prior to the creation of an instance of the class. At step , the system returns or constructs a type delegator which is a descendant of a TypeDelegator class provided by the .NET framework. The TypeDelegator class can be used to wrap a Type object and delegate all methods to that Type. Delegates are used for managed code objects to encapsulate method calls. They are used primarily in Event notifications and callbacks. Further description of the .NET TypeDelegator class is available in the above-described \u201c.NET Framework Developer's Guide\u201d. The type delegator allows for enumerating through the fields, methods, properties, and events of the class, and \u201chooking\u201d that information. At this point, a type delegator and a class instance have been created.","At step  the design surface (i.e., the form itself) is constructed based on the proxy class that has been created. The form then runs and is visible to the user (e.g., developer) in the interface of the development system. To the user it appears that the form has been actually constructed. To the execution environment and to the actual streaming system, however, it appears as a new class of type TForm1 (e.g., a new class derived from TForm). Although the new class is a \u201cproxy\u201d, for all intents and purposes it is a new instance of a new type that has now been constructed to represent the form. The class that is constructed is referred to as a proxy as it behaves to some extent as a proxy. However, because of the requirements of the .NET environment, the methodology of the present invention provides for actually constructing the new type.","It should be noted that the proxy class that is created above will change as the user interacts with the form in designing an application. For example, new fields may suddenly appear and the system of the present invention has to be able to add, or to appear to add, these new fields to the class (i.e., to the TForm1 class using this same example), without actually having to destroy or create a new class each time. Once the class is created, it is essentially done. Accordingly, the type delegator provides the functionality which is more similar to the traditional proxy. Rather than trying to modify the actual metadata that has been emitted in creating the class, the type delegator facilitates creating tables and other information that is used to track changes to the form as the user is designing the form. The operations of the system in response to user input in designing the form are described below.","Receiving User Input for Designing Form",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 6","b":"600"},"At step , the process commences when a developer\/user drops a new component onto a form open on the visual design surface of the IDE. For example, a user may drop a button component onto the form that was previously created as described above. In response to the act of dropping the component onto the form, at step  the application source code is updated to reflect the addition of the new component.","At step , the type delegator (or proxy) is informed that a component was dropped onto the form and is supplied with the component's name and its type. The type delegator (proxy) then constructs (or appears to construct) a field on the class that has the specified name (physical name) and type. For example, if the component dropped onto the form is a button, it might end up with a name \u201cButton1\u201d and a type of \u201cTButton\u201d. Subsequently, if one went back and actually queried the proxy class for a list of fields it will have \u201cButton1\u201d of type \u201cTButton\u201d. In other words, a reference to that component is added to the form. It should be noted that the component is added to the application code itself (e.g., code that is visible in the editor of the IDE), which is the code that the user will actually be interacting with. At this point there is just a field in the code that represents the button (Button1) on the form.","At step , the developer\/user writes (or has the system generate) the method (code) that will be executed in response to an application end user selecting (e.g., clicking on) the component (e.g., the button) when the application is running. The user typically activates the component and writes code or instructs the development system to generate the method (e.g., by double clicking on the button or going to the object in the object inspector of the IDE and selecting the event handler for the event that is to be handled). At step , a new method is then added to the proxy class. This involves a similar process to that described above in adding a new field to the class. The new method added to the class has a name and a list of parameters and their types. In the case of a button click, for example, \u201cButton1Click\u201d may be the name of the method. This Button1 Click method may be a procedure (which means that it does not have a function result type as it does not return anything), and have a single parameter which is a reference to the button itself (i.e., Button1 which sends the event). An object is added into the proxy with all of the appropriate metadata information that is needed by the persisting system to enable the persisting system to \u201cwire up\u201d the method (e.g., Button1 Click) and the corresponding component (e.g., Button1) at runtime.","At step , a special method class is returned to the form designer (proxy class) which is then assigned on the component (e.g., Button1). This is essentially a small \u201ccookie\u201d that represents the method (e.g., the Button1 Click method). It is not really an actual method at this point, but the system assigns it because it is assignment compatible at this point. By passing the \u201ccookie\u201d to the button, the streaming system thinks it has a method assigned on the button. The streaming system is able to take this \u201ccookie\u201d that is pointing to the method (e.g., \u201cButton1 Click\u201d) and use it for constructing the method when needed. Whenever the information is written out, the streaming system can write a reference to the method. It should be noted that the cookie can be passed around and the same cookie can be assigned to another button. It is not necessary to recreate a new version of the method. Generally, this cookie is retained until the method (e.g., Button1 Click) is actually deleted so that this particular method does not have to be reconstructed. The same process occurs for each method that is generated.","When the developer\/user is done dropping components on the form and adding associated methods, the user may terminate the design session. At step , when the design session is complete the proxy class is sent to the persistence layer which persists the form. The persistence layer (persistence mechanism) actually iterates through the components based on the live instances that it sees on the design surface. The process of persisting the form is described below.","Generally, the process of persisting the form commences with the \u201croot designer\u201d or \u201croot component\u201d, which is the root container of the system. The system typically has containers of containers, and at the root there is one root container that represents where things start. The root may be the base form, although other cases which do not involve forms operate in essentially the same manner. The persistence mechanism takes the root component and hands it off to the streaming system which then, using all of the metadata it finds, is able to go through and obtain all the properties for that component and then persist the property values out (e.g., write them out to a file). These values are written out in a particular format. Next, the persisting mechanism goes through and finds that the component contains or \u201cowns\u201d certain other components. It goes through the components that it owns and basically calls back through again in a recursive fashion. The persisting mechanism goes through the properties of these components and streams them out (e.g., writes them to a file). It is at the root that the proxy actually comes in to play so that the streaming system knows that it needs to persist out a reference to a method (based on looking at a cookie). By obtaining the above-described cookie, the streaming system is able to actually add a reference to the method (e.g., Button1 Click) in the actual persisted format. After all of the components have been written out, the form is closed off and persisted.","Visual Inheritance","In addition to providing for proxy classes that inherit from classes provided by the .NET framework, the present invention also supports a visual inheritance model. This visual inheritance model enables a developer to create descendants of forms that have already been designed. For example, a developer can create a TForm2 that is a descendant of a previously created TForm1. The descendant TForm2 will inherit the properties, components, and the like of its ancestor (i.e., TForm1). In this case, TForm2 would already include, when initially constructed, the Button1 component that was placed onto TForm1 as described above. The developer can then manipulate that button on the new form (TForm2) so as to make it different than its ancestor. It should be noted that this button cannot really be deleted on the new form (TForm2) as it exists in the ancestor. However, the developer can move it around, change its size, change its properties, hook a different method to it, and so forth. This basic visual inheritance methodology was first described in commonly owned U.S. Pat. No. 6,002,867 titled \u201cDevelopment System with Methods Providing Visual Form Inheritance\u201d. In accordance with the present invention, the technique is extended to support the design-time dynamic class type construction described herein. In order to support visual form inheritance, the proxy system provided by the present invention supports the creation of proxies of proxies.","The system of the present invention was generalized and constructed so that a proxy class that is constructed can (if necessary) be passed back through the system to create a new class that inherits from the first proxy class. The new class in this case is a subclass that inherits from an existing proxy class. This may include constructing proxies of proxies to N levels deep. To ensure that this visual inheritance functionality continues to be supported, the system of the present invention provides for constructing proxies of proxies without directly copying and manipulating metadata information. At a high-level, this is achieved by maintaining a layer between the metadata and the accessors that are manipulating metadata information. This layer also handles the translation so that the metadata is translated into the correct format.","Proxy Creation and Manipulation Routines","The following discussion describes certain of the core proxy class creation and manipulation routines in greater detail. As previously mentioned, the core functionality of the present invention is currently implemented in a single module (file). Other routines call into this module which performs the bulk of the work in creating a proxy class. The following is the class interface that represents how the functionality is presented to other modules of the system:",{"@attributes":{"id":"p-0087","num":"0086"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(1) \u200214: interface"},{"entry":"(2) \u200215:"},{"entry":"(3) \u200216: uses"},{"entry":"(4) \u200217: \u2002System.Collections, System.Reflection,"},{"entry":"\u2003\u2003\u2002System.Reflection.Emit,"},{"entry":"(5) \u200218: \u2002System.Globalization, TypInfo, Classes, SysUtils;"},{"entry":"(6) \u200219:"},{"entry":"(7) \u200220:"},{"entry":"(8) \u200221: \/\/!! APIs have changed quite a bit"},{"entry":"(9) \u200222: function CreateSubClass(AAncestor: TClass; const"},{"entry":"\u2003\u2003\u2002AClassName:"},{"entry":"(10) \u2009string;"},{"entry":"(11) 23: \u2002const AUnitName: string = \u2033): TClass;"},{"entry":"(12) 24: procedure DestroySubClass(AInstance: TObject); overload;"},{"entry":"(13) deprecated;"},{"entry":"(14) 25: procedure DestroySubClass(AClass: TClass); overload;"},{"entry":"(15) 26: procedure RenameSubClass(AInstance: TObject; const"},{"entry":"\u2003\u2003\u2002AClassName:"},{"entry":"(16) string;"},{"entry":"(17) 27: \u2002const AUnitName: string = \u2033); overload; deprecated;"},{"entry":"(18) 28: procedure RenameSubClass(AClass: TClass; const"},{"entry":"\u2003\u2003\u2002AClassName: string;"},{"entry":"(19) 29: \u2002const AUnitName: string = \u2033); overload;"},{"entry":"(20) 30:"},{"entry":"(21) 31: \/\/ TODO: ConstructSubClass - this should not be needed!"},{"entry":"(22) 32: function ConstructSubClass(AClass: TClass; AParams: array of"},{"entry":"(23) \u2009TObject): TObject;"},{"entry":"(24) 33: \/\/ TODO: ConstructComponent - this should not be needed!"},{"entry":"(25) 34: function ConstructComponent(AClass: TComponentClass;"},{"entry":"\u2003\u2003\u2002AOwner:"},{"entry":"(26) \u2009TComponent = nil): TComponent;"},{"entry":"(27) 35:"},{"entry":"(28) 36: function IsProxyClass(AInstance: TObject): Boolean; overload;"},{"entry":"(29) 37: function IsProxyClass(AClass: TCIass): Boolean; overload;"},{"entry":"(30) 38:"},{"entry":"(31) 39: \/\/ TODO: ChangeToProxyClass, this can't work like the"},{"entry":"\u2003\u2003\u2002old way"},{"entry":"(32) \u2009so will this do?"},{"entry":"(33) 40: procedure ChangeToProxyClass(AInstance: TObject{; TClass"},{"entry":"(34) argument}); overload; deprecated;"},{"entry":"(35) 41: procedure ChangeToProxyClass(AClass: TClass); overload;"},{"entry":"(36) 42:"},{"entry":"(37) 43: function CreateSubClassMethod(AInstance: TObject;"},{"entry":"(38) 44: \u2002const AMethodName: string): TMethodCode;"},{"entry":"(39) 45: procedure RenameSubClassMethod(AInstance: TObject;"},{"entry":"(40) 46: \u2002const AMethodCode: TMethodCode; const AMethodName:"},{"entry":"\u2003\u2003\u2002string);"},{"entry":"(41) 47: procedure DestroySubClassMethod(AInstance: TObject;"},{"entry":"(42) 48: \u2002const AMethodCode: TMethodCode);"},{"entry":"(43) 49:"},{"entry":"(44) 50: procedure HandleNotification(Sender: TObject; Acomponent:"},{"entry":"(45) \u2009TComponent; Operation: TOperation);"},{"entry":"(46) 51:"},{"entry":"(47) 52: procedure Savelt;"},{"entry":"(48) 53:"},{"entry":"(49) 54: type"},{"entry":"(50) 55: \u2002EProxyError = class(Exception);"},{"entry":"(51) 56:"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"As shown above, the interface includes a flat set of functions and procedures. Of particular interest, at line 22, is a CreateSubclass function which is the entry point to the core routines of the class. The CreateSubclass function receives an ancestor class as an input parameter. Note that this ancestor class is an actual class (e.g., the TForm class implemented under the .NET framework) and not an instance because the proxy class must be constructed before an instance of the class is created. As shown above at line 22, AAncestor is the parameter that refers to the ancestor class. AClassName is the desired class name for the new class. There is also an optional parameter for representing the unit name (e.g., Unit 1), which is used in most cases for representing the name of the source file (module) that the developer\/user is designing. The CreateSubclass function returns the new class type which is a proxy class.","To construct the proxy class requires that it be dynamically constructed. A \u201cCreateDesignComponent\u201d function (not shown above) is initially called. Because of some differences in the way these calls can be made in .NET (as compared to Win-32), the actual constructor must be dynamically invoked, which requires looking up the metadata, finding the constructor, constructing the list of parameters to it, and then calling an \u201cinvoke\u201d on it which invokes the actual construct. The call to CreateDesignComponent is necessary because in the .NET environment the act of constructing allocates the object and actually calls the constructor. Currently, there is no way to create a new instance without calling the constructor. Accordingly, the CreateDesignComponent routine is called to set up some global values that are needed during construction of the proxy class. The CreateDesignComponent function that is called is not specific to the creation of a proxy class. It is a function that is called for creation of various types of components.","The CreateSubClass function which is referenced in the above interface is as follows:",{"@attributes":{"id":"p-0091","num":"0090"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(1)\u2003905: function CreateSubClass(AAncestor: TClass; const"},{"entry":"\u2003\u2003\u2002AclassName:"},{"entry":"(2)\u2003\u2002string;"},{"entry":"(3)\u2003906: \u2002const AUnitName: string): TClass;"},{"entry":"(4)\u2003907: begin"},{"entry":"(5)\u2003908: \u2002Result :="},{"entry":"\u2003\u2003\u2002TClass(TProxyType.CreateSubType(AAncestor.ClassInfo,"},{"entry":"(6)\u2003\u2009AClassName, AUnitName));"},{"entry":"(7)\u2003909: end;"},{"entry":"(8)\u2003910:"},{"entry":"(9)\u2003911: resourcestring"},{"entry":"(10) 912: \u2002SNoValidConstructor = \u2018No valid constructor found for %s.\u2019;"},{"entry":"(11) 913:"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"As shown at line 908, the CreateSubClass method includes a call to a function of the TProxyType class type named CreateSubType.","The TProxyType class type is illustrated below:",{"@attributes":{"id":"p-0094","num":"0093"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(1) \u200277: \u2002\u2002TProxyType = class(TypeDelegator)"},{"entry":"(2) \u200278: \u2002\u2002strict private"},{"entry":"(3) \u200279: \u2002\u2002\u2002class var"},{"entry":"(4) \u200280: \u2002\u2002\u2002\u2002FAssemblyBuilder: AssemblyBuilder;"},{"entry":"(5) \u200281: \u2002\u2002\u2002\u2002FModuleBuilder: ModuleBuilder;"},{"entry":"(6) \u200282: \u2002\u2002\u2002\u2002FProxyTypeIndex: Integer;"},{"entry":"(7) \u200283: \u2002\u2002\u2002\u2002FProxyIntercept: TProxyIntercept;"},{"entry":"(8) \u200284: \u2002\u2002\u2002\u2002FRootMetaType: System.Type;"},{"entry":"(9) \u200285: \u2002\u2002\u2002\u2002FRootHandleField: FieldInfo;"},{"entry":"(10) 86: \u2002\u2002\u2002\u2002FRootParentField: FieldInfo;"},{"entry":"(11) 87: \u2002\u2002\u2002\u2002FProxyNotificationMethod: MethodInfo;"},{"entry":"(12) 88: \u2002\u2002\u2002\u2002FSendNotificationMethod: MethodInfo;"},{"entry":"(13) 89: \u2002\u2002\u2002\u2002FProxies: Hashtable;"},{"entry":"(14) 90: \u2002\u2002\u2002\u2002FInstances: Hashtable;"},{"entry":"(15) 91:"},{"entry":"(16) 92: \u2002\u2002\u2002var"},{"entry":"(17) 93: \u2002\u2002\u2002\u2002FClassName: string;"},{"entry":"(18) 94: \u2002\u2002\u2002\u2002FUnitName: string;"},{"entry":"(19) 95: \u2002\u2002\u2002\u2002FMethods: Hashtable;"},{"entry":"(20) 96:"},{"entry":"(21) 97: \u2002\u2002strict protected"},{"entry":"(22) 98: \u2002\u2002\u2002class procedure CreateBoolAttribute(ATypeBuilder:"},{"entry":"\u2003\u2003\u2002TypeBuilder;"},{"entry":"(23) 99: \u2002\u2002\u2002\u2002AAttribute: System.Type; AValue: Boolean = True);"},{"entry":"(24) 100: \u2002\u2002\u2002class function CreateMetaSubType(ABaseType, AType:"},{"entry":"\u2003\u2003\u2002System.Type;"},{"entry":"(25) 101: \u2002\u2002\u2002\u2002ATypeBuilder: TypeBuilder): System.Type;"},{"entry":"(26) 102: \u2002\u2002\u2002class procedure CodeGenConstructors(ABaseType:"},{"entry":"\u2003\u2003\u2002System.Type;"},{"entry":"(27) \u2002ATypeBuilder: TypeBuilder);"},{"entry":"(28) 103: \u2002\u2002\u2002class procedure CodeGenNotification(ABaseType:"},{"entry":"\u2003\u2003\u2002System.Type;"},{"entry":"(29) \u2002ATypeBuilder: TypeBuilder);"},{"entry":"(30) 104: \u2002\u2002\u2002class function FindRealType(var AType: System.Type):"},{"entry":"\u2003\u2003\u2002Boolean;"},{"entry":"(31) 105: \u2002\u2002public"},{"entry":"(32) 106: \u2002\u2002\u2002class constructor Create;"},{"entry":"(33) 107: \u2002\u2002\u2002constructor Create(Ancestor: System.Type; const"},{"entry":"\u2003\u2003\u2002AClassName,"},{"entry":"(34) \u2002AUnitName: string);"},{"entry":"(35) 108:"},{"entry":"(36) 109: \u2002\u2002\u2002\/\/ delegator work"},{"entry":"(37) 110: \u2002\u2002\u2002function get_FullName: string; override;"},{"entry":"(38) 111: \u2002\u2002\u2002function get_Name: string; override;"},{"entry":"(39) 112: \u2002\u2002\u2002function get_Namespace: string; override;"},{"entry":"(40) 113:"},{"entry":"(41) 114: \u2002\u2002\u2002\/\/ support for the public functions"},{"entry":"(42) 115: \u2002\u2002\u2002class function FindProxy(AInstance: TObject): TProxyType;"},{"entry":"(43) 116: \u2002\u2002\u2002function CreateMethod(const AMethodName: string):"},{"entry":"\u2003\u2003\u2002TMethodCode;"},{"entry":"(44) 117: \u2002\u2002\u2002procedure RenameMethod(const AMethodCode:"},{"entry":"\u2003\u2003\u2002TMethodCode; const"},{"entry":"(45) \u2002AMethodName: string);"},{"entry":"(46) 118: \u2002\u2002\u2002procedure DestroyMethod(const AMethodCode:"},{"entry":"\u2003\u2003\u2002TMethodCode);"},{"entry":"(47) 119:"},{"entry":"(48) 120: \u2002\u2002\u2002\/\/ type versions of the public functions"},{"entry":"(49) 121: \u2002\u2002\u2002class function IsSubTyped(AType: System.Type): Boolean;"},{"entry":"(50) 122: \u2002\u2002\u2002class function CreateSubType(ABaseType: System.Type;"},{"entry":"\u2003\u2003\u2002const"},{"entry":"(51) \u2002AClassName: string;"},{"entry":"(52) 123: \u2002\u2002\u2002\u2002const AUnitName: string = \u2033): System.Type;"},{"entry":"(53) 124: \u2002\u2002\u2002class procedure ChangeToProxyType(AType: System.Type);"},{"entry":"(54) 125: \u2002\u2002\u2002class procedure DestroySubType(AType: System.Type);"},{"entry":"(55) 126: \u2002\u2002\u2002class procedure RenameSubType(AType: System.Type;"},{"entry":"\u2003\u2003\u2002const"},{"entry":"(56) AClassName: string;"},{"entry":"(57) 127: \u2002\u2002\u2002\u2002const AUnitName: string = \u2033);"},{"entry":"(58) 128:"},{"entry":"(59) 129: \u2002\u2002\u2002\/\/ support functions for TProxyIntercept"},{"entry":"(60) 130: \u2002\u2002\u2002class function GetMethodAddress(AClass: TClass; const"},{"entry":"\u2003\u2003\u2002AName:"},{"entry":"(61) \u2002string; out ACode: TMethodCode): Boolean;"},{"entry":"(62) 131: \u2002\u2002\u2002class function GetMethodProp(AInstance: TObject;"},{"entry":"\u2003\u2003\u2002APropInfo:"},{"entry":"(63) \u2002TPropInfo; out AMethod: TMethod): Boolean;"},{"entry":"(64) 132: \u2002\u2002\u2002class function SetMethodProp(AInstance: TObject;"},{"entry":"\u2003\u2003\u2002APropInfo:"},{"entry":"(65) \u2002TPropInfo; const AMethod: TMethod): Boolean;"},{"entry":"(66) 133: \u2002\u2002\u2002class function GetUnitName(ATypeInfo: TTypeInfo; out"},{"entry":"(67) \u2002AUnitName: string): Boolean;"},{"entry":"(68) 134:"},{"entry":"(69) 135: \u2002\u2002\u2002class procedure HandleNotification(Sender: Tobject;"},{"entry":"(70) \u2002AComponent: TComponent; Operation: TOperation); static;"},{"entry":"(71) 136:"},{"entry":"(72) 137: \u2002\u2002\u2002\/\/ onetime snapshot of Proxies' scratch assembly"},{"entry":"(73) 138: \u2002\u2002\u2002\/\/ WARNING: once you \u2018Savelt\u2019; you can't create anymore"},{"entry":"\u2003\u2003\u2002proxy"},{"entry":"(74) \u2002classes\/types"},{"entry":"(75) 139: \u2002\u2002\u2002class procedure Savelt;"},{"entry":"(76) 140: \u2002\u2002end;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"As shown, the TProxyType is a .NET TypeDelegator type.","The CreateSubType function of the TProxyType class type is as follows:",{"@attributes":{"id":"p-0097","num":"0096"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(1) \u2002596: class function TProxyType.CreateSubType(ABaseType:"},{"entry":"\u2003\u2003\u2002System.Type;"},{"entry":"(2) \u2002597: \u2002\u2002const AClassName: string; const AUnitName: string = \u2033):"},{"entry":"(3) \u2002\u2002System.Type;"},{"entry":"(4) \u2002598: var"},{"entry":"(5) \u2002599: \u2002\u2002LTypeBuilder: TypeBuilder;"},{"entry":"(6) \u2002600: \u2002\u2002LMetaType: System.Type;"},{"entry":"(7) \u2002601: \u2002\u2002LMetaConstructor: ConstructorInfo;"},{"entry":"(8) \u2002602: \u2002\u2002LProxyType: TProxyType;"},{"entry":"(9) \u2002603: \u2002\u2002LNewType: System.Type;"},{"entry":"(10) 604: \u2002begin"},{"entry":"(11) 605: \u2002\u2002\/\/ find the real type . . . if we have been handed a proxytype,"},{"entry":"(12) \u2002instead of"},{"entry":"(13) 606: \u2002\u2002\/\/\u2002\u2002a \u2018realtype\u2019, then FindRealType will modify"},{"entry":"(14) \u2002ABaseType so that it"},{"entry":"(15) 607: \u2002\u2002\/\/\u2002\u2002points to the proxy's UnderlyingSystemType."},{"entry":"(16) 608: \u2002\u2002FindRealType(ABaseType);"},{"entry":"(17) 609:"},{"entry":"(18) 610: \u2002\u2002\/\/ create a type builder \u2002\u2002\u2002\u2002. . . remember each type must"},{"entry":"\u2003\u2003\u2002have"},{"entry":"(19) \u2002a unique name"},{"entry":"(20) 611: \u2002\u2002LTypeBuilder :="},{"entry":"\u2003\u2003\u2002FModuleBuilder. DefineType(Format(STestTypeName,"},{"entry":"(21) \u2002[FProxyTypeIndex]), TypeAttributes.Public, ABaseType);"},{"entry":"(22) 612: \u2002\u2002Inc(FProxyTypeIndex);"},{"entry":"(23) 613:"},{"entry":"(24) 614: \u2002\u2002\/\/ find the first ancestor class that has constructors and copy"},{"entry":"(25) \u2002them"},{"entry":"(26) 615: \u2002\u2002CodeGenConstructors(ABaseType, LTypeBuilder);"},{"entry":"(27) 616:"},{"entry":"(28) 617: \u2002\u2002\/\/ TODO: If the type is a TComponent desendent then we"},{"entry":"\u2003\u2003\u2002need to"},{"entry":"(29) \u2002hook notification"},{"entry":"(30) 618: \u2002\u2002CodeGenNotification(ABaseType, LTypeBuilder);"},{"entry":"(31) 619:"},{"entry":"(32) 620: \u2002\u2002\/\/ quick make the type before it slips away again :-)"},{"entry":"(33) 621: \u2002\u2002LNewType := LTypeBuilder.CreateType;"},{"entry":"(34) 622: \u2002\u2002LProxyType := TProxyType.Create(LNewType,"},{"entry":"\u2003\u2003\u2002AClassName, AUnitName);"},{"entry":"(35) 623:"},{"entry":"(36) 624: \u2002\u2002\/\/ make up a metaclass for the Delphi System unit"},{"entry":"(37) 625: \u2002\u2002LMetaType := CreateMetaSubType(ABaseType, LnewType,"},{"entry":"(38) \u2002LTypeBuilder);"},{"entry":"(39) 626: \u2002\u2002LMetaConstructor := LMetaType.GetConstructor([ ]);"},{"entry":"(40) 627: \u2002\u2002if LMetaConstructor = nil then"},{"entry":"(41) 628: \u2002\u2002\u2002raise EProxyError.Create(SCould NotFindMetaConstructor);"},{"entry":"(42) 629:"},{"entry":"(43) 630: \u2002\u2002\/\/ plug ourselves into the class delegator system so that our"},{"entry":"(44) \u2002proxy type will"},{"entry":"(45) 631: \u2002\u2002\/\/ be found when someone does a ClassInfo on this"},{"entry":"\u2003\u2003\u2002type\/metatype"},{"entry":"(46) 632: \u2002\u2002SetClassDelegator(LProxyType,"},{"entry":"\u2003\u2003\u2002LMetaConstructor.Invoke([ ]));"},{"entry":"(47) 633:"},{"entry":"(48) 634: \u2002\u2002\/\/ add it to the list of known \u2018live\u2019 proxies"},{"entry":"(49) 635: \u2002\u2002FProxies.Add(LNewType, LMetaType);"},{"entry":"(50) 636:"},{"entry":"(51) 637: \u2002\u2002\/\/ return the proxy type"},{"entry":"(52) 638: \u2002\u2002Result := LProxyType;"},{"entry":"(53) 639: end;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"If the CreateSubType function has been passed in a proxy type, it proceeds to find the real type as provided at line 608. Recall from the prior discussion that in some cases a proxy of a proxy may be created. If the above function is invoked with a proxy type, the FindRealType function at line 608 modifies the type (i.e., ABaseType) so that it points to the proxy's underlying type system.","The FindRealType function itself is as follows:",{"@attributes":{"id":"p-0100","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(1) \u2002586: class function TProxyType.FindRealType(var AType:"},{"entry":"\u2003\u2003\u2009System.Type):"},{"entry":"(2) \u2002\u2002Boolean;"},{"entry":"(3) \u2002587: begin"},{"entry":"(4) \u2002588:\u2002\u2002\/\/ just in case were given a proxy type lets find the real type"},{"entry":"(5) \u2002589:\u2002\u2002if AType is TProxyType then"},{"entry":"(6) \u2002590:\u2002\u2002\u2002AType := AType.UnderlyingSystemType;"},{"entry":"(7) \u2002591:"},{"entry":"(8) \u2002592:\u2002\u2002\/\/ see if we can find it in our list"},{"entry":"(9) \u2002593:\u2002\u2002Result := FProxies.Contains(AType);"},{"entry":"(10)\u2002594: end;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"As shown above at lines 589-590, if the type that is passed in is a proxy type (TProxyType), then the underlying system type is retrieved. Otherwise, the above-function attempts to find the type in a list of types.","Returning to the above-described CreateSubType function at lines 610-615, the type that is determined is defined via a DefineType function of an FModuleBuilder class as shown in the following portion of the CreateSubType function (which is repeated here for convenience):",{"@attributes":{"id":"p-0103","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(1) \u2002610: \u2002\/\/ create a type builder \u2002\u2002\u2002\u2002. . . remember each type must"},{"entry":"\u2003\u2003\u2002have"},{"entry":"(2) \u2002\u2002a unique name"},{"entry":"(3) \u2002611: \u2002LTypeBuilder :="},{"entry":"\u2003\u2003\u2002FModuleBuilder.DefineType(Format(STestTypeName,"},{"entry":"(4) \u2002\u2002[FProxyTypeIndex]), TypeAttributes.Public, ABaseType);"},{"entry":"(5) \u2002612: \u2002Inc(FProxyTypeIndex);"},{"entry":"(6) \u2002613:"},{"entry":"(7) \u2002614: \u2002\/\/ find the first ancestor class that has constructors and copy"},{"entry":"(8) \u2002\u2002them"},{"entry":"(9) \u2002615: \u2002CodeGenConstructors(ABaseType, LTypeBuilder);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The module that these types are going to be built into has already been defined. At this point a new type is being defined. Each type needs to have a unique name. It does not really matter what the name is at this point because the type delegator will enable the user to subsequently decide what name to use and rename it on-the-fly. Note that to a person accessing the type through the metadata the type is changing. However, to the .NET runtime environment it is actually some other arbitrary name that has been selected. More particularly, as shown at lines 611-612, the string type is replaced with an index (which is a numeric value, such as 12345).","The next step is to find an ancestor class that has constructors and generate a copy of the constructors for insertion in the proxy class. As shown at line 615, a CodeGenConstructors procedure is called to create the constructors. The CodeGenConstructors procedure is as follows:",{"@attributes":{"id":"p-0106","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(1) \u2002468: class procedure TProxyType.CodeGenConstructors(ABaseType:"},{"entry":"(2) \u2002\u2002System.Type; ATypeBuilder: TypeBuilder);"},{"entry":"(3) \u2002469: var"},{"entry":"(4) \u2002470: \u2002LConstructors: array of ConstructorInfo;"},{"entry":"(5) \u2002471: \u2002LParameters: array of ParameterInfo;"},{"entry":"(6) \u2002472: \u2002LParamTypes: array of System.Type;"},{"entry":"(7) \u2002473: \u2002LConstructorBaseType: System.Type;"},{"entry":"(8) \u2002474: \u2002LConstructorBuilder: ConstructorBuilder;"},{"entry":"(9) \u2002475: \u2002LILGenerator: ILGenerator;"},{"entry":"(10) 476: \u2002LConstructorNdx, LParameterNdx: Integer;"},{"entry":"(11) 477: begin"},{"entry":"(12) 478: \u2002LConstructorBaseType := ABaseType;"},{"entry":"(13) 479: \u2002while LConstructorBaseType <> nil do"},{"entry":"(14) 480: \u2002begin"},{"entry":"(15) 481:"},{"entry":"(16) 482: \u2002\u2002\/\/ see if it has any constructors"},{"entry":"(17) 483: \u2002\u2002LConstructors := LConstructorBaseType.GetConstructors;"},{"entry":"(18) 484: \u2002\u2002if Length(LConstructors) <> 0 then"},{"entry":"(19) 485: \u2002\u2002begin"},{"entry":"(20) 486: \u2002\u2002\u2002for LConstructorNdx := Low(LConstructors) to"},{"entry":"(21) \u2002High(LConstructors) do"},{"entry":"(22) 487: \u2002\u2002\u2002begin"},{"entry":"(23) 488: \u2002\u2002\u2002\u2002with LConstructors[LConstructorNdx] do"},{"entry":"(24) 489: \u2002\u2002\u2002\u2002begin"},{"entry":"(25) 490: \u2002\u2002\u2002\u2002\u2002\/\/ copy the param and in turn their types"},{"entry":"(26) 491: \u2002\u2002\u2002\u2002\u2002LParameters := GetParameters;"},{"entry":"(27) 492: \u2002\u2002\u2002\u2002\u2002SetLength(LParamTypes, Length(LParameters));"},{"entry":"(28) 493: \u2002\u2002\u2002\u2002\u2002for LParameterNdx := Low(LParameters) to High"},{"entry":"(29) \u2002(LParameters) do"},{"entry":"(30) 494: \u2002\u2002\u2002\u2002\u2002\u2002LParamTypes[LParameterNdx] :="},{"entry":"(31) \u2002LParameters[LParameterNdx].ParameterType;"},{"entry":"(32) 495:"},{"entry":"(33) 496: \u2002\u2002\u2002\u2002\u2002\/\/ construct a constructor builder"},{"entry":"(34) 497: \u2002\u2002\u2002\u2002\u2002\/\/ LConstructorBuilder :="},{"entry":"(35) \u2002ATypeBuilder.DefineConstructor(Attributes,"},{"entry":"(36) 498: \u2002\u2002\u2002\u2002\u2002\u2002CallingConvention, LParamTypes);"},{"entry":"(37) 499: \u2002\u2002\u2002\u2002end;"},{"entry":"(38) 500:"},{"entry":"(39) 501: \u2002\u2002\u2002\u2002\/\/ lets write some code"},{"entry":"(40) 502: \u2002\u2002\u2002\u2002LILGenerator := LConstructorBuilder.GetILGenerator;"},{"entry":"(41) 503: \u2002\u2002\u2002\u2002with LILGenerator, OpCodes do"},{"entry":"(42) 504: \u2002\u2002\u2002\u2002begin"},{"entry":"(43) 505: \u2002\u2002\u2002\u2002\u2002\/\/ CODE TO BE GENERATED"},{"entry":"(44) 506: \u2002\u2002\u2002\u2002\u2002\/\/ inherited Create({arg count depends on parentclass})"},{"entry":"(45) 507:"},{"entry":"(46) 508: \u2002\u2002\u2002\u2002\u2002Emit(Ldarg_0);\u2003\u2003\u2003\u2003\u2003\u2003\/\/"},{"entry":"(47) \u2002push instance"},{"entry":"(48) 509: \u2002\u2002\u2002\u2002\u2002for LParameterNdx := 1 to Length(LParameters) do"},{"entry":"(49) 510: \u2002\u2002\u2002\u2002\u2002\u2002Emit(Ldarg_S, LParameterNdx);"},{"entry":"(50) \u2002\/\/ push params"},{"entry":"(51) 511: \u2002\u2002\u2002\u2002\u2002Emit(Call, LConstructors[LConstructorNdx]);"},{"entry":"(52) \u2002\/\/ call the base ctr"},{"entry":"(53) 512:"},{"entry":"(54) 513: \u2002\u2002\u2002\u2002\u2002Emit(Ret);"},{"entry":"(55) \u2002\/\/ fini"},{"entry":"(56) 514: \u2002\u2002\u2002\u2002end;"},{"entry":"(57) 515: \u2002\u2002\u2002end;"},{"entry":"(58) 516:"},{"entry":"(59) 517: \u2002\u2002\u2002\/\/ done"},{"entry":"(60) 518: \u2002\u2002\u2002break;"},{"entry":"(61) 519: \u2002\u2002end;"},{"entry":"(62) 520:"},{"entry":"(63) 521: \u2002\u2002\/\/ move up a level"},{"entry":"(64) 522: \u2002\u2002LConstructorBaseType := LConstructorBaseType.BaseType;"},{"entry":"(65) 523: \u2002end;"},{"entry":"(66) 524: end;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The above CodeGenConstructors procedure constructs the metadata information and generates the IL code where that information is actually emitted. The metadata information is constructed as illustrated at lines 483-500.","After constructing the metadata information, some code has to be written into the proxy class. As shown commencing above at line 502, an IL generator is obtained to generate code. The code is then emitted to call the ancestor constructor. This is done recursively for the number of constructors that are needed. Once that is done, the function returns the new constructor(s) that have been generated.","Returning back to the CreateSubType function, a CodeGenNotification procedure is called to hook the notification methods of the ancestor class as illustrated in the below portion of the CreateSubType function (which is repeated for convenience):\n\n","As shown, the CodeGenNotification procedure is called at line 618.","The CodeGenNotification procedure that is called in the above portion of the CreateSubType function is as follows:",{"@attributes":{"id":"p-0112","num":"0114"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(1) \u2002526: class procedure TProxyType.CodeGenNotification(ABaseType:"},{"entry":"(2) \u2002\u2002System.Type; ATypeBuilder: TypeBuilder);"},{"entry":"(3) \u2002527: var"},{"entry":"(4) \u2002528: \u2002LParamTypes: array of System.Type;"},{"entry":"(5) \u2002529: \u2002LBaseNotificationMethod: MethodInfo;"},{"entry":"(6) \u2002530: \u2002LMethodBuilder: MethodBuilder;"},{"entry":"(7) \u2002531: \u2002LILGenerator: ILGenerator;"},{"entry":"(8) \u2002532: \u2002LLabel: System.Reflection.Emit.Label;"},{"entry":"(9) \u2002533: begin"},{"entry":"(10) 534: \u2002\/\/ get the param list ready"},{"entry":"(11) 535: \u2002SetLength(LParamTypes, 2);"},{"entry":"(12) 536: \u2002LParamTypes[0] := TypeOf(Classes.TComponent);"},{"entry":"(13) 537: \u2002LParamTypes[1] := TypeOf(Classes.TOperation);"},{"entry":"(14) 538:"},{"entry":"(15) 539: \u2002\/\/ see if we can find a notification method to call"},{"entry":"(16) 540: \u2002LBaseNotificationMethod :="},{"entry":"\u2003\u2003\u2002ABaseType.GetMethod(\u2018Notification\u2019,"},{"entry":"(17) 541: \u2002\u2002BindingFlags.Public or BindingFlags.NonPublic or"},{"entry":"(18) \u2002BindingFlags.Instance or"},{"entry":"(19) 542: \u2002\u2002BindingFlags.InvokeMethod, nil, LParamTypes, nil);"},{"entry":"(20) 543: \u2002if LBaseNotification Method <> nil then"},{"entry":"(21) 544: \u2002begin"},{"entry":"(22) 545:"},{"entry":"(23) 546: \u2002\u2002\/\/ create a builder"},{"entry":"(24) 547: \u2002\u2002with LBaseNotificationMethod do"},{"entry":"(25) 548: \u2002\u2002\u2002LMethod Builder := ATypeBuilder.DefineMethod(Name,"},{"entry":"(26) 549: \u2002\u2002\u2002\u2002MethodAttributes.FamORAssem or"},{"entry":"\u2003\u2003\u2002MethodAttributes.Virtual,"},{"entry":"(27) 550: \u2002\u2002\u2002\u2002CallingConvention, ReturnType, LParamTypes);"},{"entry":"(28) 551:"},{"entry":"(29) 552: \u2002\u2002\/\/ let's write some code!"},{"entry":"(30) 553: \u2002\u2002LILGenerator := LMethodBuilder.GetILGenerator;"},{"entry":"(31) 554: \u2002\u2002with LILGenerator, OpCodes do"},{"entry":"(32) 555: \u2002\u2002begin"},{"entry":"(33) 556: \u2002\u2002\u2002\/\/ CODE TO BE GENERATED"},{"entry":"(34) 557: \u2002\u2002\u2002\/\/ Borland.Vcl.Design.Proxies.HandleNotification(Self,"},{"entry":"(35) \u2002AComponent, AOperation);"},{"entry":"(36) 558: \u2002\u2002\u2002\/\/ if Borland.Vcl.Classes.SendNotification(Self,"},{"entry":"\u2003\u2003\u2002AComponent,"},{"entry":"(37) \u2002AOperation) then"},{"entry":"(38) 559: \u2002\u2002\u2002\/\/ \u2002inherited Notification(AComponent, AOperation);"},{"entry":"(39) 560:"},{"entry":"(40) 561: \u2002\u2002\u2002Emit(Ldarg_0);\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/"},{"entry":"(41) \u2002push instance"},{"entry":"(42) 562: \u2002\u2002\u2002Emit(Ldarg_1);\u2003\u2003\u2003\u2003\u2003\u2003\/\/ push"},{"entry":"(43) \u2002component reference"},{"entry":"(44) 563: \u2002\u2002\u2002Emit(Ldarg_2);\u2003\u2003\u2003\u2003\u2003\/\/ push what is"},{"entry":"(45) \u2002happening to it"},{"entry":"(46) 564: \u2002\u2002\u2002Emit(Call, FProxyNotificationMethod);\u2003\u2003\/\/ call the"},{"entry":"(47) \u2002proxy's notify-wedge"},{"entry":"(48) 565:"},{"entry":"(49) 566: \u2002\u2002\u2002Emit(Ldarg_0);\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/"},{"entry":"(50) \u2002push instance"},{"entry":"(51) 567: \u2002\u2002\u2002Emit(Ldarg_1);\u2003\u2003\u2003\u2003\u2003\u2003\/\/ push"},{"entry":"(52) \u2002component reference"},{"entry":"(53) 568: \u2002\u2002\u2002Emit(Ldarg_2);\u2003\u2003\u2003\u2003\u2003\u2003\/\/ push what is"},{"entry":"(54) \u2002happening to it"},{"entry":"(55) 569: \u2002\u2002\u2002Emit(Call, FSendNotificationMethod);\u2003\u2003\/\/ call classes'"},{"entry":"(56) sendnotification"},{"entry":"(57) 570:"},{"entry":"(58) 571: \u2002\u2002\u2002LLabel := DefineLabel;"},{"entry":"(59) 572: \u2002\u2002\u2002Emit(Brfalse_S, LLabel);\u2003\u2003\u2003\u2003\/\/ if result is"},{"entry":"(60) \u2002false then . . ."},{"entry":"(61) 573:"},{"entry":"(62) 574: \u2002\u2002\u2002Emit(Ldarg_0);\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/"},{"entry":"(63) \u2002push instance"},{"entry":"(64) 575: \u2002\u2002\u2002Emit(Ldarg_1);\u2003\u2003\u2003\u2003\u2003\u2003\/\/ push"},{"entry":"(65) \u2002component reference"},{"entry":"(66) 576: \u2002\u2002\u2002Emit(Ldarg_2);\u2003\u2003\u2003\u2003\u2003\/\/ push what is"},{"entry":"(67) \u2002happening to it"},{"entry":"(68) 577: \u2002\u2002\u2002Emit(Call, LBaseNotificationMethod);\u2003\u2003\u2003\/\/ call the"},{"entry":"(69) \u2002base's method"},{"entry":"(70) 578:"},{"entry":"(71) 579: \u2002\u2002\u2002MarkLabel(LLabel);\u2003\u2003\u2003\u2003\u2003\u2003\/\/"},{"entry":"(72) ..jump to here"},{"entry":"(73) 580:"},{"entry":"(74) 581: \u2002\u2002\u2002Emit(Ret);"},{"entry":"(75) \u2002\/\/ fini"},{"entry":"(76) 582: \u2002\u2002end;"},{"entry":"(77) 583: \u2002end;"},{"entry":"(78) 584: end;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The above routine is a little more complicated because it actually has to emit a call to another method. In other words, the above procedure has to make a \u201cside-band\u201d call to generate the metadata information for the method that is being overridden. The comment commencing at line 557 is essentially the code that is being generated as a result. What this does is override the notification method to call a send notification event method. The above routine generates IL code on-the-fly so that the execution environment will then see this code and translate it back to machine code at runtime (or whenever it is encountered which could be at design-time rather than at runtime) to provide for hooking the notification method of the ancestor.","After generating the IL code, the CreateSubType function continues with creating the proxy type as illustrated in the portion of the function commencing at line 620 (which is repeated below):",{"@attributes":{"id":"p-0115","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(1) \u2002620: \u2002\/\/ quick make the type before it slips away again :-)"},{"entry":"(2) \u2002621: \u2002LNewType := LTypeBuilder.CreateType;"},{"entry":"(3) \u2002622: \u2002LProxyType := TProxyType.Create(LNewType, AClassName,"},{"entry":"\u2003\u2003\u2002AUnitName);"},{"entry":"(4) \u2002623:"},{"entry":"(5) \u2002624: \u2002\/\/ make up a metaclass for the Delphi System unit"},{"entry":"(6) \u2002625: \u2002LMetaType := CreateMetaSubType(ABaseType, LnewType,"},{"entry":"(7) \u2002\u2002LTypeBuilder);"},{"entry":"(8) \u2002626: \u2002LMetaConstructor := LMetaType.GetConstructor([ ]);"},{"entry":"(9) \u2002627: \u2002if LMetaConstructor = nil then"},{"entry":"(10) 628: \u2002\u2002raise EProxyError.Create(SCouldNotFindMetaConstructor);"},{"entry":"(11) 629:"},{"entry":"(12) 630: \u2002\/\/ plug ourselves into the class delegator system so that our"},{"entry":"(13) \u2002proxy type will"},{"entry":"(14) 631: \u2002\/\/ be found when someone does a ClassInfo on this"},{"entry":"\u2003\u2003\u2002type\/metatype"},{"entry":"(15) 632: \u2002SetClassDelegator(LProxyType,"},{"entry":"\u2003\u2003\u2002LMetaConstructor.Invoke([ ]));"},{"entry":"(16) 633:"},{"entry":"(17) 634: \u2002\/\/ add it to the list of known \u2018live\u2019 proxies"},{"entry":"(18) 635: \u2002FProxies.Add(LNewType, LMetaType);"},{"entry":"(19) 636:"},{"entry":"(20) 637: \u2002\/\/ return the proxy type"},{"entry":"(21) 638: \u2002Result := LProxyType;"},{"entry":"(22) 639: end;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The type that is created is the actual proxy type. The actual proxy type is what the CreateSubType function ends up returning.","Before going in and setting the class delegator a metaclass is created. Metaclass information is generated that mimics what the compiler has generated for the ancestor. The metaclass information is extra information that the compiler generates when it is compiling (normal) code in order to allow certain language constructs. A similar process is performed here to allow those language constructs.","The class delegator is actually set though a call to SetClassDelegator at line 632. The present invention provides for dynamically constructing the proxy class and then setting the class delegator onto the class. As a result, whenever the metadata information is requested, the delegator is obtained instead. This provides access to the metadata information that can be hooked for implementing the methodology of the present invention.","At line 635 the proxy class that has been created is added to a list of known, \u201clive\u201d proxies that is maintained by the system. This enables the system to keep track of proxies that have been created. At line 638, the proxy type that has been constructed is returned. As previously mentioned, for all intents and purposes to the rest of the system this proxy type is a real .NET runtime type. However, because of the type delegator, it operates in a manner similar to a proxy.","After the proxy class is constructed as described above, an instance of the class is created. The instance that is created is an instance of that particular type and appears as an instance of that type in the .NET execution environment. The proxy class provides for the form to be visible in the user interface and enables it to be persisted and written out so that the design state of the component is maintained.","When the user wants to create a new component (e.g., drop a button onto the form created as described above), the system similarly constructs a \u201creal\u201d instance of the component. Assume, for example, that a developer drops a button component (e.g., \u201cButton \u201d) on the visual design surface (i.e., on the form). The developer then proceeds to create a method (e.g., a \u201cButton1 Click\u201d method) to handle the event (e.g., an application end user clicking on Button1).","Internally, when a method is created the IDE in which the present invention is embodied performs a validation and informs the code manager that a method will be generated. The code manager is given the method name and information about the method (e.g., a list of parameters). The code manager ensures that there is not a method that already has that name. The code for the method is then created (e.g., written by the developer or generated by the IDE).","After the code for the method is created, a CreateMethod function is called. The TProxyType.CreateMethod function which is called is as follows:",{"@attributes":{"id":"p-0124","num":"0126"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(1) \u2002704: function TProxyType.CreateMethod(const AMethodName:"},{"entry":"\u2003\u2003\u2002string):"},{"entry":"(2) \u2002TMethodCode;"},{"entry":"(3) \u2002705: var"},{"entry":"(4) \u2002706: \u2002LMethodCode: TMethodCode;"},{"entry":"(5) \u2002707: begin"},{"entry":"(6) \u2002708: \u2002LMethodCode := TMethodProxy(FMethods[AMethodName]);"},{"entry":"(7) \u2002709: \u2002if LMethodCode = nil then"},{"entry":"(8) \u2002710: \u2002begin"},{"entry":"(9) \u2002711: \u2002\u2002LMethodCode := TMethodProxy.Create(Self,"},{"entry":"\u2003\u2003\u2002AMethodName);"},{"entry":"(10) 712: \u2002\u2002FMethods.Add(AMethodName, LMethodCode);"},{"entry":"(11) 713: \u2002end;"},{"entry":"(12) 714: \u2002Result := LMethodCode;"},{"entry":"(13) 715: end;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The type delegator is applicable in this case. Because of the existence of the type delegator (which serves as a \u201cshim\u201d), a list of the methods on the actual proxy type that has been constructed is available. In this respect the type delegator serves as a proxy and provides access to the list of methods. In the currently preferred embodiment, the list of methods is based on the method name as there is only one method of a given name on a given class.","The type delegator finds the method name and essentially returns the \u201ccookie\u201d (as described earlier in this document) for that method. The proxy thereby has information that there is a certain method name associated with this class type. The method is not tied to a particular field (e.g., the Button1 object), but rather is tied to the actual class type that is being designed, which is the proxy class representing the form (i.e., the button references a method on its container).","The system of the present invention, in its currently preferred embodiment, also includes a RenameMethod function, a DestroyMethod function, and a GetMethodAddress function as follows:",{"@attributes":{"id":"p-0128","num":"0130"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(1) \u2002717: procedure TProxyType.RenameMethod(const AMethodCode:"},{"entry":"\u2003\u2003\u2002TMethodCode;"},{"entry":"(2) \u2002\u2002const AMethodName: string);"},{"entry":"(3) \u2002718: begin"},{"entry":"(4) \u2002719: \u2002\/\/ make sure it is a method proxy"},{"entry":"(5) \u2002720: \u2002if not (AMethodCode is TMethodProxy) then"},{"entry":"(6) \u2002721: \u2002\u2002raise EProxyError.Create(SMethodNotMethodProxy);"},{"entry":"(7) \u2002722:"},{"entry":"(8) \u2002723: \u2002\/\/ remove, rename and re-add"},{"entry":"(9) \u2002724: \u2002FMethods.Remove(AMethodCode.Name);"},{"entry":"(10) 725: \u2002TMethodProxy(AMethodCode).Rename(AMethodName);"},{"entry":"(11) 726: \u2002FMethods.Add(AMethodName, AMethodCode);"},{"entry":"(12) 727: end;"},{"entry":"(13) 728:"},{"entry":"(14) 729: procedure TProxyType.DestroyMethod(const"},{"entry":"\u2003\u2003\u2002AMethodCode: TMethodCode);"},{"entry":"(15) 730: begin"},{"entry":"(16) 731: \u2002\/\/ make sure it is a method proxy"},{"entry":"(17) 732: \u2002if not (AMethodCode is TMethodProxy) then"},{"entry":"(18) 733: \u2002\u2002raise EProxyError.Create(SMethodNotMethodProxy);"},{"entry":"(19) 734:"},{"entry":"(20) 735: \u2002\/\/ remove and clear"},{"entry":"(21) 736: \u2002FMethods.Remove(AMethodCode.Name);"},{"entry":"(22) 737: \u2002TMethodProxy(AMethodCode).Clear;"},{"entry":"(23) 738: end;"},{"entry":"(24) 739:"},{"entry":"(25) 740: class function TProxyType.GetMethodAddress(AClass: TClass;"},{"entry":"\u2003\u2003\u2002const"},{"entry":"(26) \u2002AName: string; out ACode: TMethodCode): Boolean;"},{"entry":"(27) 741: var"},{"entry":"(28) 742: \u2002LType: System.Type;"},{"entry":"(29) 743: begin"},{"entry":"(30) 744: \u2002\/\/ assume failure"},{"entry":"(31) 745: \u2002ACode := nil;"},{"entry":"(32) 746:"},{"entry":"(33) 747: \u2002\/\/ find the class' type"},{"entry":"(34) 748: \u2002LType := AClass.ClassInfo;"},{"entry":"(35) 749: \u2002Result := LType is TProxyType;"},{"entry":"(36) 750:"},{"entry":"(37) 751: \u2002\/\/ keep looking but only if the type is a TProxyType"},{"entry":"(38) 752: \u2002while LType is TProxyType do"},{"entry":"(39) 753: \u2002begin"},{"entry":"(40) 754:"},{"entry":"(41) 755: \u2002\u2002\/\/ see if there is a method"},{"entry":"(42) 756: \u2002\u2002ACode :="},{"entry":"\u2003\u2003\u2002TMethodCode(TProxyType(LType).FMethods.Item[AName]);"},{"entry":"(43) 757: \u2002\u2002if ACode <> nil then"},{"entry":"(44) 758: \u2002\u2002\u2002break;"},{"entry":"(45) 759:"},{"entry":"(46) 760: \u2002\u2002\/\/ still nothing? then look at the parent class"},{"entry":"(47) 761: \u2002\u2002AClass := AClass.ClassParent;"},{"entry":"(48) 762: \u2002\u2002LType := AClass.ClassInfo;"},{"entry":"(49) 763: \u2002end;"},{"entry":"(50) 764: end;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The CreateMethod, RenameMethod, and DestroyMethod functions illustrated above are the basic functions that enable a method to be created, renamed, and destroyed. For instance, if a developer renames a method (e.g., from \u201cButton1 Click\u201d to \u201cButtonSelect\u201d), the corresponding metadata also has to be renamed so that the streaming system can continue to find it. Otherwise, the streaming system might look for a method with a given name and not find it, which would cause an error. If all references to a function are deleted or if the method is removed from the application, the DestroyMethod function is used to pull it back out so that it does not exist anymore. The GetMethodAddress function returns the address of the method (i.e., indicates where the method exists) given a particular method name.","Modification of an Existing Form","The same general process is involved if the user wants to modify a form that has previously been created. For example, the user may complete a design session for a form (e.g., TForm1) and persist the form out through the streaming system. Subsequently, he or she may decide to add a new button to the form. When the persisted information is loaded back into system memory, the system still goes through the above process in order to construct the proxy that represents the form internally in the system. Even though technically that proxy has previously been created, it has to be recreated dynamically based on the information coming in from the persisted data (file). The same components initially created are again created during this reconstruction process. The proxy class is created as a subclass of an ancestor class. Additional information that is streamed in indicates that the form has certain components (e.g., Button1) and related methods (e.g., the Button1 Click method). The reconstructed proxy enables the user to continue to design the form where he or she left off.","The user may then proceed to make modifications to the form. For instance, he or she may add a second button to the form and then save (i.e., persist out) the modified form with two buttons. The system of the present invention operates in a symmetrical fashion. When persisted information (e.g., regarding a particular form) is streamed in, the proxy is recreated as if it were new. The modified version is then streamed back out with whatever changes that were made so that the modified version is persisted. This process can be repeated a number of times until the design of the form(s) and the application in which the form(s) is included is completed.","Descendants of a form that has been created may also be constructed in a similar fashion. The same process as described above will occur, but when looking up methods, one will actually see the ancestor's methods in the type information. For example, a developer may create a descendant of TForm1 that already includes one button. He or she can add a new button on the descendant form and have it call the ancestor's click method when it is invoked. The button on the new form can be bound to the ancestor's click method because it is visible to the descendant form.","Alternatively, the user can take the ancestor's button and assign it to a new method on the descendant form. The method on the descendant form would override the method of the ancestor in that case. It should be noted that this is not a virtual override in the sense that it is not a standard object-oriented programming (OOP) style override. Rather, it is a delegation override as Delphi, for the most part, operates on more of a delegation model rather than a pure inheritance model. One can actually assign an event that is a reference to an instance and to a method (which is what an event handler is). In contrast to normal inheritance provided by OOP languages (e.g., Java), this involves binding to a static method on a class. The delegation model involves delegating the behavior of the button click to some other object, but the button has no knowledge of the other object. All the object knows is that it can call a method on a class with certain parameters. As long as that class instance has a method that matches that signature, they can be bound together and the button can call the method.","While the invention is described in some detail with specific reference to a single-preferred embodiment and certain alternatives, there is no intent to limit the invention to that particular embodiment or those specific alternatives. For instance, those skilled in the art will appreciate that modifications may be made to the preferred embodiment without departing from the teachings of the present invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 5A-B"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
