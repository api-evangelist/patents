---
title: Pragmatic mapping specification, compilation and validation
abstract: Facilitating translation of data between object oriented programs and database storage tables. A method includes receiving user input from a user. The user input includes a plurality of parts. Each part includes a specification of a source (such as a type source), optionally a filter, and a projection. Each projection assigns values to table columns. Based on the plurality of parts received, the method includes generating one or more views. The one or more views describe relationships between model extents and database tables.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08739118&OS=08739118&RS=08739118
owner: Microsoft Corporation
number: 08739118
owner_city: Redmond
owner_country: US
publication_date: 20100408
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","Background and Relevant Art","BRIEF SUMMARY","DETAILED DESCRIPTION","Data Model","Mapping Specification","Sample API","Case Shorthand","Mapping Validation","View Generation","Propagation","Constraints"],"p":["Computers and computing systems have affected nearly every aspect of modern living. Computers are generally involved in work, recreation, healthcare, transportation, entertainment, household management, etc.","Information used by computers may be generated and stored in disparate ways. For example, computer applications often operate on objects in object oriented computer systems. In contrast, data is often stored, not in object format, but rather in relational databases and their corresponding tables. Thus, for an application to operate on data stored in the database, a mapping between a relational database representation and an object representation may be used.","Several different mapping specifications have been used. Three such mapping specifications include Table per Hierarchy (TPH), Table per Type (TPT) and Table per Class (TPC).","The table-per-hierarchy method uses one database table in storage to maintain data for all the types in an inheritance hierarchy.","The table-per-type method uses a separate table in storage to maintain data for each type in the inheritance hierarchy. For example, such a mapping may include a table for a base type with columns for properties and a key column. As such, new columns may be added if new properties are added. Sub-types have a new table with new properties and a key column. Types and sub-types can be correlated by using the same key in each of the columns. Thus for example, a table may exist for type \u201canimal\u201d, a table may exist for type \u201ccat\u201d and a table may exist for type \u201ccalico cat\u201d. A specific instance of a calico cat would have a row in all three tables, where each of the rows for the specific instance would have a matching key column entry.","The table per class method uses a separate table in storage to maintain data for each class.","Mapping specifications are used for an Object-Relational Mapping (or Conceptual-Relational\/Conceptual-Conceptual Mapping) system. Solutions tend to be ad-hoc and thus narrowly applicable, complex and hard to use, and\/or expensive and slow.","The subject matter claimed herein is not limited to embodiments that solve any disadvantages or that operate only in environments such as those described above. Rather, this background is only provided to illustrate one exemplary technology area where some embodiments described herein may be practiced.","One embodiment is directed to facilitating translation of data between object oriented programs and database storage tables. A method includes receiving user input from a user. The user input includes a plurality of parts. Each part includes a specification of a source (such as a type source), optionally a filter, and a projection. Each projection assigns values to table columns. Based on the plurality of parts received, the method includes generating one or more views. The one or more views describe relationships between model extents and database tables. These views can then be used for various data mapping and table update functions.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used as an aid in determining the scope of the claimed subject matter.","Additional features and advantages will be set forth in the description which follows, and in part will be obvious from the description, or may be learned by the practice of the teachings herein. Features and advantages of the invention may be realized and obtained by means of the instruments and combinations particularly pointed out in the appended claims. Features of the present invention will become more fully apparent from the following description and appended claims, or may be learned by the practice of the invention as set forth hereinafter.","Some embodiments described herein use a mapping specification language which allows a developer to have greater control over how mapping from objects to database tables are performed, compilation of the mapping specification language to efficient runtime transformation functions and\/or techniques for mapping validation. While the specification language is simple and intuitive, it is flexible enough to address a wide range of mapping patterns. Mappings describe a transformation of a function or query from entities or objects to database but tables. For example, mappings may be Table per Hierarchy (TPH), Table per Type (TPT) or Table per Class (TPC). Constraints on the operators available within the query allow compilation of the mapping specification into \u201cviews\u201d appropriate for runtime data and query transformations. Note that these views are not typical database views, but rather describe model extents as functions of database tables or describe database tables as functions of model extents. Details regarding views are illustrated below and more fully in U.S. patent application Ser. Nos. 11\/725,195 (Publication Number 20080228697) titled \u201cView Maintenance Rules For An Update Pipeline Of An Object-Relational Mapping (ORM) Platform\u201d, filed Mar. 16, 2007, Ser. No. 11\/725,206 (Publication Number 20070226196) titled \u201cMapping Architecture With Incremental View Maintenance\u201d, filed Mar. 16, 2007 and Ser. No. 11\/724,991 (Publication Number 20070226203) titled Generation of Query And Update Views For Object Relational Mapping\u201d, filed Mar. 16, 2007 each of which are incorporated herein by reference in its entirety. As a side-effect of describing the mapping, a storage data model can be inferred for the developer.","As used herein, the term \u201centity\u201d is used to describe an instance of a type in a user's application. An entity type is mapped to some target which is often a relational \u201ctable\u201d. The concepts described are relevant to mappings between other kinds of structure however. For instance, an \u2018entity\u2019 could be as simple as a collection of name-value pairs and a \u2018table\u2019 could be some arbitrary extent (for instance, another set of entities). An extent is generally a definable set with metes and bounds for inclusion in the set. For example, in an e-commerce enterprise relevant extents may be: the set of all customers; the set of all addresses; the set of all orders, etc.","A data model is typically defined in the user application, such as in an object oriented application. The data model typically includes one or more of an entity type, a root entity type, an association type, and\/or a complex type.","An entity type is a nominal type that optionally has a base type from which it derives (except in the case of a root entity type as will be described in more detail below). An entity type declares properties and inherits properties from its base type. The following illustrates categories of properties for an entity type. A primitive property is a property exposing an atomic or scalar value, for instance a string or a number. A complex property is a property returning an instance of a complex type. A navigation property is a property returning an instance or collection of entities. A navigation property is bound to a particular association type and end.","A root entity type is an entity type that does not have a base type, but itself may be a base type for other entity types. A base entity type declares one or more \u2018key\u2019 properties. Key properties are primitive properties uniquely defining an entity within an extent. For example, a key property may be a globally unique identifier (GUID), social security number, telephone number, or other unique identifier.","An association type defines a relationship between two entity types, referred to as \u2018ends\u2019 of the relationship. Each end has multiplicity of \u2018zero-or-one\u2019, \u2018one\u2019 or \u2018many\u2019, indicating the required number of related entities for the end. An association type may also define a referential constraint which indicates that two related entities share values for certain primitive properties. One end of the constraint is considered the \u2018principal\u2019 end and the other is the \u2018dependent\u2019 end. Constrained properties of the principal end are the key properties for that end.","A complex type is similar to an entity type, but with support for only primitive and complex properties and without support for type inheritance. A complex type does not have key properties.","A mapping is described as a function taking as arguments sets of entities and relationships and returning the contents of a table. Some embodiments may use a mapping specification language such that within an application, a separate mapping function is declared for each table. A mapping function comprises several \u201cparts\u201d each of which describes a source (e.g., \u201call entities of type X\u201d) and a range variable used to refer to instances of the entity (e.g., \u201ce\u201d); optionally a filter (e.g., \u201cwhere e.Y==1\u201d); and a projection (e.g., \u201cselect new {id=e.ID, y=e.Y}\u201d).","The source follows one of the following patterns: hierarchy type, single type, multiple type, or association. A hierarchy type indicates that the part applies to all entities that are instances of the given type or some type derived from the given type. A hierarchy type makes available a single range variable of the indicated type. A single type indicates that the part applies to all entities that are specifically instances of the given type, not derived from the given type. A single type makes available a single range variable of the indicated type. A multiple type indicates that the part applies to all entities implementing one of a set of types. A multiple type makes available a single range variable that is the most derived common ancestor for all of the types specified. An association indicates that the part applies to the given relationship. An association makes available two range variables, one for each side of the relationship.","A projection assigns values to table columns (zero or more assignments). Each assignment comprises a column name and a value, where the value follows one of the following patterns: a value literal, a property chain, a navigation key. A value literal indicates that for the given source and filter, the specified column has the given constant value. A property chain is a member access chain where the leaf is the entity or range variable, intermediate members are complex properties and ending with a primitive property. A navigation key is a member access chain comprising a navigation property on the range variable and a key property of the related end.","A filter (not available for relationship sources) is some function of the entity range variable returning a Boolean value and indicating the subset of the source to which the mapping part applies. The filter comprises logical operators (e.g. \u2018AND\u2019, \u2018OR\u2019, \u2018NOT\u2019 \u2018NAND\u2019, \u2018NOR\u2019, and \u2018XOR\u2019) and simple comparisons (e.g. >, >=, ==, <=, <) between property chains and value literals.","A relationship mapping permits \u2018simple\u2019 property chains comprising relationship end range variable and a key property for the corresponding end.","Notably, for an application, typically several mapping functions will be defined in a specification for the application. A mapping function can be, but is not necessarily, defined for each table in a database. Mapping functions can be defined for existing tables to facilitate the translation of data from applications to databases, or mappings can be defined for tables that should be created to accomplish the translation of data from applications to databases.","Embodiments may also be implemented whereby mapping functions are created for different kinds of data. However, mappings do not necessarily need to be defined in every embodiment. Rather, in some embodiments, a mapping specification may be deduced by deducing table and key constraints.","This section describes one embodiment of an application programming interface (API) realization of the mapping specification described above. This API specifically targets C#3.0 or VB 9.0, but is appropriate for any language with support for lambda expressions. A graphical representation of the API is illustrated in .","The mapping classes used in one embodiment are described below:",{"@attributes":{"id":"p-0032","num":"0031"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public abstract class Map"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"internal Map( );"]},{"entry":[{},"public static EntityMap OfType<TEntity>("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Expression<Func<TEntity, object>> propertyMap);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public static EntityMap OfTypeOnly<TEntity>("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Expression<Func<TEntity, object>> propertyMap);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public static HierarchyEntityMapGenerator<TEntity>"]},{"entry":[{},"OfType<TEntity>( );"]},{"entry":[{},"public static EntityMapGenerator<TEntity>"]},{"entry":[{},"OfTypeOnly<TEntity>( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/\/ Constructed by EntityConfiguration<TEntity>.MapNavigation"]},{"entry":[{},"public sealed class AssociationMap : Map"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"internal AssociationMap( );"]},{"entry":[{},"public override string ToString( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"public class EntityMap : Map"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"internal EntityMap( );"]},{"entry":[{},"\/\/ displays contents of mapping"]},{"entry":[{},"public override string ToString( );"]},{"entry":[{},"public EntityMap Union(EntityMap other);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/\/ exists only as a fluent \u2018bridge\u2019"]},{"entry":[{},"\/\/ (the user calls Select to use the mapping)"]},{"entry":[{},"public class EntityMapGenerator<TEntity>"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"internal EntityMapGenerator( );"]},{"entry":[{},"public EntityMap Select("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Expression<Func<TEntity, object>> propertyMap);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/\/ exists only as a fluent \u2018bridge\u2019"]},{"entry":[{},"\/\/ (the user calls Select or Case to use the mapping)"]},{"entry":[{},"public sealed class HierarchyEntityMapGenerator<TEntity> :"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"EntityMapGenerator<TEntity>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"internal HierarchyEntityMapGenerator( );"]},{"entry":[{},"public HierarchyEntityMap<TEntity> Case<TSub>("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Expression<Func<TSub, object>> propertyMap"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},") where TSub : TEntity;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"public sealed class HierarchyEntityMap<TEntity> : EntityMap"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"internal HierarchyEntityMap( ) { }"]},{"entry":[{},"public HierarchyEntityMap<TEntity> Case<TSub>("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Expression<Func<TSub, object>> propertyMap"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},") where TSub : TEntity;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"As illustrated above, the API includes a Case method. The Case method allows for a shorthand specification of Table Per Hierarchy (TPH) mappings, or other mappings where a single table is explicitly partitioned by type. The shorthand avoids the need to repeat mapping information for each type that is mapped to a table by allowing column mappings and conditions to be inherited. The following simple example is used as illustration:",{"@attributes":{"id":"p-0034","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class Toy { int ID; int Rating; }"},{"entry":"abstract class AnimalToy : Toy { string Name; }"},{"entry":"class SeaAnimalToy : AnimalToy { boolIsMammal; }"},{"entry":"class DeviceToy : Toy { boolisCar; }"},{"entry":"Map.OfType<Toy>( )"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},".Case<Toy>(t => new { tid = t.ID, rating = tRating, disc = \u201cToy\u201d })"]},{"entry":[{},".Case<AnimalToy>(t => new { tname = t.Name })"]},{"entry":[{},".Case<SeaAnimalToy>(t => new { ismammal = t.IsMammal,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"rating2 = t.Rating, disc = \u201cSeaAnimal\u201d })"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},".Case<DeviceToy>(t => new { iscar = t.IsCar, disc = \u201cIsCar\u201d });"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The Case specification is transformed into an explicit mapping function using the following process. First, an (initially empty) OfTypeOnlyfragment is created for every concrete type including a case statement, e.g.:",{"@attributes":{"id":"p-0036","num":"0035"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Map.OfTypeOnly<Toy>(...).Union("]},{"entry":[{},"Map.OfTypeOnly<SeaAnimalToy>(...)).Union("]},{"entry":[{},"Map.OfTypeOnly<DeviceToy>(...));"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Abstract types are not represented, since they only contribute to concrete partitions via inheritance. (An exception is thrown if there is a Case for an abstract type but no subtypes are included). Next each, partition is filled in to include mappings explicitly declared for the type. Consider the SeaAnimalToy type:",{"@attributes":{"id":"p-0038","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"..."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Map.OfTypeOnly<SeaAnimalToy>(t => new {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ismammal = t.IsMammal,"]},{"entry":[{},"rating2 = t.Rating,"]},{"entry":[{},"disc = \u201cSeaAnimal\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"})"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"..."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Code-Only then walks up the type hierarchy to find additional mapping information. The first type explored is the base type AnimalToy, which also includes a mapping detail:",{"@attributes":{"id":"p-0040","num":"0039"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"..."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"tname = t.Name,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"..."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Finally, the Toy mapping information is incorporated:",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"..."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"tid = t.ID,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"..."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Two elements of this last mapping are ignored because they have already been specified. The \u2018disc\u2019 column has been overridden in the SeaAnimalToy fragment, as has the \u2018Rating\u2019 property. Intuitively, the Case shorthand can be viewed as introducing inheritance of column and property mappings with overrides.","The following method overload is added to support this feature:",{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class EntityMap<TEntity>"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"..."]},{"entry":[{},"public EntityMap<TEntity>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Case<TDerived>(Expression<Func<TDerived, object>>propertyMap)"},{"entry":"where TDerived : TEntity;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The following discussion now discusses mapping validation. Two concepts discussed in this section are now described. The first is the notion of \u2018model profile\u2019. The second is the notion of \u2018table profile\u2019. In the simplest case, these concepts map to an \u2018extent\u2019 (i.e. a set of instances of a type) and a \u2018table\u2019 respectively. However, a particular mapping function part may be associated with a narrow \u2018model profile\u2019 or \u2018table profile\u2019.","The model profile is defined as follows: The set of types to which the part applies (a hierarchy part applies to all types within a given inheritance hierarchy, a single type part applies to a single type, and a multiple type part applies to a set of types). Type in {t, t, . . . }. Where the part includes a filter, the predicate is also incorporated into the profile. For every property path participating in a filter predicate, the domain of the property is discretized according to the values with which the path is compared (across all parts). For instance, given the filter clauses e.X==1 and e.X<2, the domain for e.X is discretized as follows: e.X in {\u2018.<1\u2019, \u20181\u2019, \u20181<.<2\u2019, \u20182\u2019, \u20182\u2019} and the filter clauses are rewritten as e.X in {\u20181\u2019} and e.X in {\u2018.<1\u2019, \u20181\u2019, \u20181<.<2\u2019}. This representation of the filter clauses facilitates validation logic. Note that some types have small domains (e.g., enums and Boolean). In such cases, the domain is already practically discrete and the intrinsic domain can be used.","The model profile for a part is therefore represented as a constraint expression, e.g.:",{"@attributes":{"id":"p-0049","num":"0048"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"builder.Entity<A>( ).MapSingleType(a => new { id = a.id, disc = \u201cA\u201d })"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},".Where(a =>a.Category == Category.Foo)"]},{"entry":[{},".ToTable(\u201cdbo.Foo\u201d)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"Type in {A} AND a.Category in {Category.Foo}","Each function part is also associated with a \u2018table profile\u2019 which captures the following information: (1) The table. (2) The range of possible values for each column in the table given the part. Where the column is assigned a literal, the range is C in {value}. For unmapped columns, the range is C in {null}. Where the column is assigned a nullable property, the range is C in Domain union {null}. Otherwise, the range is C in Domain.","The above example has the following table profile (assuming columns id, disc and x):",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Table in { \u201cdbo.Foo\u201d } AND id in Domain except { null } AND disc in {"},{"entry":"\u201cA\u201d } AND x in { null }"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Mapping validation may demonstrate the correctness (or \u201croundtrippability\u201d) of its mappings. Roundtripability refers to the ability to translate data and queries between object systems and table storage systems. This is further clarified below in the sections discussing view creation. Mapping validation demonstrates the correctness (or \u201croundtrippability\u201d) of its mappings by verifying one or more of the following: (1) Consistency of association mappings. This verification demonstrates consistency of relationship mappings. (2) Disjointness in the model. This verification demonstrates that each pair of function parts mapped to a particular table have disjoint model profiles. While this is not strictly necessary, it makes propagation and validation algorithms considerably simpler. (3) Disjointness in the table. This verification demonstrates that each pair of function parts mapped to a particular table have disjoint table profiles. While this is not strictly necessary, it makes propagation and validation algorithms considerably simpler. (4) Completeness of mapping. This verification ensures that each property (declared and inherited) of each concrete type is mapped for all possible model profiles over the type. This also implies verification that each concrete type is mapped. (5) Type roundtripping. This verification ensures that each concrete type has a unique set of table profiles.","These verifications can help to ensure that entity or relationship instances can be stored with full fidelity in the database. Each of these will now be discussed in more detail.","Consistency of Association Mappings","Inline Mappings","This section assumes that the model treats relationships as independent of entities. Where the relationship is part of the entity in the data model (i.e. the entity holds the key of a related entity) this step is unnecessary: the inline mapping can be treated like any other required property path.","In Code-Only, function parts may include column maps with navigation paths. Consider the following example:",{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"abstract class A { int ID; int X; D D; }"]},{"entry":[{},"class B : A { int Y; }"]},{"entry":[{},"class C : A { int Z; }"]},{"entry":[{},"class D { int ID; }"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0059","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"builder.Entity<B>( ).MapSingleType(b => new { b.ID, b.X, b.Y,"]},{"entry":[{},"DID ="]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"b.D.ID }).ToTable(\u201cdbo.A\u201d);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"builder.Entity<C>( ).MapSingleType(c => new { c.ID, c.X, c.Z,"]},{"entry":[{},"DID ="]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"c.D.ID }));"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"While these column maps are inline in the specification, the mapping is independent for the data access runtime. Some validation of navigation mappings is performed before they are transformed into association set mappings. For example, the following illustrates two validation constraints.","(1) Take the base declaring type for the navigation property that is being mapped inline. Each concrete type in the hierarchy for this declaring type includes an inline mapping for the navigation property. Note that a single hierarchy function part may satisfy this requirement for several types in the hierarchy.","(2) Each inline mapping of the navigation property includes all key properties of the target entity. In addition, each inline mapping is consistent with respect to the columns and tables into which those key values are projected.","Given these constraints, a single association mapping can be generated that holds for the entire entity type hierarchy.","Join Table Mappings","When the user specifies a relationship mapping function via Relationship.Map (in the example illustrated), embodiments may ensure that the join table is mapped only to the association.","Disjointness in the Model and the Table","For a particular table, this verification ensures that each entity function part is disjoint in the model. In particular, two parts cannot \u201ccontain\u201d the same concrete entity types. For instance, the following mapping using the classes defined above:",{"@attributes":{"id":"p-0066","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"builder.Entity<A>( ).MapHierarchy(a => { a.ID, a.X"]},{"entry":[{},"}).ToTable(\u201cdbo.same\u201d);"]},{"entry":[{},"builder.Entity<B>( ).MapSingleType(b => { b.ID, b.Y"]},{"entry":[{},"}).ToTable(\u201cdbo.same\u201d);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{},{},{}],"sub":["1 ","2","1","2 ","2","1 "],"in-line-formulae":[{},{},{},{},{},{}]},"Similarly, the parts have disjoint table profiles.","Completeness of Mapping","For completeness of mapping verification, every property of every concrete type in every entity set is mapped somewhere. Each part of a complex type property is mapped as well. For purposes of this check, some embodiments examine a flattened representation of the entity type where complex properties are expanded into their leaf, or \u2018primitive property\u2019, components. Embodiments then walk through each function part and aggregate a model profile for each property for each property as it is encountered. The pseudo-code is shown below:",{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"coverage \u2190map from each property path to null"]},{"entry":[{},"foreach (part in functionParts)"]},{"entry":[{},"foreach (propertyPath in GetPropertyPaths(part))"]},{"entry":[{},"existingProfile\u2190 coverage[propertyPath]"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"profile \u2190GetModelProfile(part)"]},{"entry":[{},"if (existingProfile == null)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"coverage[propertyPath] \u2190 profile"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"coverage[propertyPath] \u2190 profile OR existingProfile"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"At the end of this process, the profile for each property path covers the entire domain of possible values for the relevant type hierarchy. Coverage can be demonstrated using a logical entailment algorithm.","The following illustrates handling when incomplete mappings are detected. The above process can be used to determine which entity configurations (model profiles) are not supported by the mapping. Rather than rejecting the mapping, it is possible to add checks at runtime to ensure that a particular entity instance has a supported profile before attempting to save it to database tables.","Type Roundtripping","To perform type roundtripping verification, each concrete entity type is associated with a unique set of table profiles. This allows embodiments to reliably determine the type for data contained in the database.","This section describes method acts used to transform mapping function parts into mapping views. Two different views will be discussed: (1) query mapping views and update mapping views. As noted, the views are not views in the traditional database context. View mapping is described in detail in U.S. patent application Ser. Nos. 11\/725,195 (Publication Number 20080228697) titled \u201cView Maintenance Rules For An Update Pipeline Of An Object-Relational Mapping (ORM) Platform\u201d, filed Mar. 16, 2007, Ser. No. 11\/725,206 (Publication Number 20070226196) titled \u201cMapping Architecture With Incremental View Maintenance\u201d, filed Mar. 16, 2007 and Ser. No. 11\/724,991 (Publication Number 20070226203) titled Generation of Query And Update Views For Object Relational Mapping\u201d, filed Mar. 16, 2007, each of which is incorporated herein by reference in their entireties.","Query mapping views (QMV) describe model extents as functions of database tables. In particular, a QMV describes the construction of an extent, and in particular how to create an extent given the contents of tables. A QMV can be used to rewrite model queries as queries over tables. The process involves replacing extent references in a query with the corresponding QMV.","Update mapping views (UMV) describe database tables as functions of model extents. UMV can be used to rewrite update, delete and insert operations against model extents as operations against database tables. This process involves propagating \u201cdelta\u201d operations across the UMV using adapted incremental view maintenance algorithms. In particular, a UMV can be used to propagate modifications of extents to modifications to database tables.","The following illustrates an example algorithm that can be used to construct QMV given a collection of mapping function parts:",{"@attributes":{"id":"p-0077","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"GenerateQMV(extent)"},{"entry":"parts \u2190 all function parts for the extent"},{"entry":"qmvComponents \u2190 { }"},{"entry":"foreach table in all tables referenced in parts"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tableParts \u2190 all parts referencing table"]},{"entry":[{},"\/\/ Gather function parts related to an extent"]},{"entry":[{},"\/\/ Group function parts according to table targeted in"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"the database"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ From validation, it is known that all table parts are"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"disjoint."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ As such, the contribution of this table to the extent"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"is the concatenation"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ (UNION ALL in SQL) of those parts. A consistent"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"mapping of keys means that"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ this concatenation produces records including well-"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"known key fields."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ A reserved sentinel field is added indicating the"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"function part introducing"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ each element."]},{"entry":[{},"qmvComponents \u2190 qmvComponents + { concat all tableParts }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ From validation, it is known that each component has well-"},{"entry":"known key fields."},{"entry":"\/\/ Perform an outer join on key fields to gather together all"},{"entry":"contributing fields for"},{"entry":"\/\/ each entity as partitioned by key values."},{"entry":"viewData \u2190 full outer join of all qmvComponents"},{"entry":"\/\/ Using the sentinel fields, determine which type each row"},{"entry":"produces based on"},{"entry":"\/\/ the unique profiles for each type (uniquesness of profiles"},{"entry":"is ensured by validation)"},{"entry":"view \u2190 AddDiscriminatingProjection(viewData)"},{"entry":"return view"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The view is then simplified (turning full outer joins into joins where possible, lifting unions, etc.). The simplification process is disclosed in more detail in U.S. patent application Ser. Nos. 11\/725,195 (Publication Number 20080228697) titled \u201cView Maintenance Rules For An Update Pipeline Of An Object-Relational Mapping (ORM) Platform\u201d, filed Mar. 16, 2007, Ser. No. 11\/725,206 (Publication Number 20070226196) titled \u201cMapping Architecture With Incremental View Maintenance\u201d, filed Mar. 16, 2007 and Ser. No. 11\/724,991 (Publication Number 20070226203) titled Generation of Query And Update Views For Object Relational Mapping\u201d, filed Mar. 16, 2007 previously incorporated herein by reference in their entireties.","An algorithm is used to generate QMV for independent association extents. Since validation verifies that key properties of association ends are consistently mapped, the view is simply a projection of the relevant keys from the relevant table. A filter is sometimes used to filter out rows that do not contain a relationship, specifically a \u201cnot null\u201d filter where key columns may be null.","The following illustrates a sample algorithm that can be used to construct UMV given a collection of mapping function parts:",{"@attributes":{"id":"p-0081","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"GenerateUMV(table)"]},{"entry":[{},"parts \u2190 all function parts for the table"]},{"entry":[{},"extent \u2190 determine single extent mapped to the table (ensured"]},{"entry":[{},"by validation)"]},{"entry":[{},"\/\/ Within a table, each part is disjoint (ensured by"]},{"entry":[{},"validation). As a result, embodiments can"]},{"entry":[{},"\/\/ produce a switch that applies function part predicates to"]},{"entry":[{},"each element of the"]},{"entry":[{},"\/\/ extent and applies the corresponding projection for the"]},{"entry":[{},"first matching function"]},{"entry":[{},"\/\/ part."]},{"entry":[{},"switch \u2190 AddSwitchProjection(extent)"]},{"entry":[{},"return view"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Column Configuration","Table definitions are built up implicitly based on the model and mapping. Whenever a mapping part is processed it contributes to system knowledge of the table shape in the following ways: (1) Which columns exist in the table. Each part may introduce new columns (2) Type constraints\/facets. A property in the model may be decorated with various facets such as max length, encoding, etc. This information propagates to the columns to which the properties are mapped. Where a column is mapped to multiple properties, inconsistencies may arise (such as inconsistencies related to, encoding, data types or size) in which case an error is returned. In some cases, multiple contributing parts may \u2018widen\u2019 the allowed values for a column. For example, the physical structure of a column may be widened, such as the actual width of a column, or the types of data that may be entered into a column may be widened, such as for example by allowing floating points, integers, strings, etc in the same column, or by allowing different encodings.","Columns mapped to key properties become keys in the table. Inconsistent key mappings may result in errors. Foreign key constraints are introduced wherever the model and its mapping to the database implies a dependency. The following cases are handled: (1) Model profile constraints: each table has a particular model profile (the disjunction of all model profiles for function parts referring to the table). If one table has a model profile that is a proper subset of another table's profile (P\u2192Pand NOT (P\u2192P)), a primary key (PK) to primary key foreign key (FK) constraint can be added. (2) Relationship constraints: where a table includes a mapping for a relationship, an FK constraint can be added from each end in the mapping to the PKs of all tables where the end type is entirely contained in the profile. (3) Foreign key constraints: if the model includes a foreign key constraint, each column mapping the dependent property may also have a constraint to the PKs of all tables where the end type is entirely contained in the profile.","Constraints are \u2018pruned\u2019 so that a constraints that are redundant given two other constraints are removed. In one embodiment, this operation is performed using a proper subset graph over the tables. The vertices in the \u201csubset\u201d graph represent tables and a directed edge exists between two vertices whenever the first table maps a proper subset of the second table's entities. The graph is then pruned using the following algorithm:\n\n","The \u201cpruned\u201d graph can then be leveraged in a number of different ways. For example, \u201cModel profile constraints\u201d are only preserved when a corresponding edge appears in the \u201cpruned\u201d graph. Additionally The smallest set of parent\/referenced tables required to represent \u201crelationship constraints\u201d and \u201cforeign key constraints\u201d can be determined using the following simple algorithm:\n\n","The following discussion now refers to a number of methods and method acts that may be performed. Although the method acts may be discussed in a certain order or illustrated in a flow chart as occurring in a particular order, no particular ordering is required unless specifically stated, or required because an act is dependent on another act being completed prior to the act being performed.","One embodiment may be a method practiced in a computing environment. The method includes acts for facilitating translation of data between object oriented programs and database storage tables. The method includes receiving user input from a user, wherein the user input comprises a plurality of parts (act ). Each part includes a specification of a source, optionally a filter, and a projection. Each projection assigns values to table columns. Based on the plurality of parts received, the method  includes generating one or more views, wherein the one or more views describe relationships between model extents and database tables (act ).","Further, the methods may be practiced by a computer system including one or more processors and computer readable media such as computer memory. In particular, the computer memory may store computer executable instructions that when executed by one or more processors cause various functions to be performed, such as the acts recited in the embodiments.","Embodiments of the present invention may comprise or utilize a special purpose or general-purpose computer including computer hardware, as discussed in greater detail below. Embodiments within the scope of the present invention also include physical and other computer-readable media for carrying or storing computer-executable instructions and\/or data structures. Such computer-readable media can be any available media that can be accessed by a general purpose or special purpose computer system. Computer-readable media that store computer-executable instructions are physical storage media. Computer-readable media that carry computer-executable instructions are transmission media. Thus, by way of example, and not limitation, embodiments of the invention can comprise at least two distinctly different kinds of computer-readable media: physical computer readable storage media and transmission computer readable media.","Physical computer readable storage media includes RAM, ROM, EEPROM, CD-ROM or other optical disk storage (such as CDs, DVDs, etc), magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store desired program code means in the form of computer-executable instructions or data structures and which can be accessed by a general purpose or special purpose computer.","A \u201cnetwork\u201d is defined as one or more data links that enable the transport of electronic data between computer systems and\/or modules and\/or other electronic devices. When information is transferred or provided over a network or another communications connection (either hardwired, wireless, or a combination of hardwired or wireless) to a computer, the computer properly views the connection as a transmission medium. Transmissions media can include a network and\/or data links which can be used to carry or desired program code means in the form of computer-executable instructions or data structures and which can be accessed by a general purpose or special purpose computer. Combinations of the above are also included within the scope of computer-readable media.","Further, upon reaching various computer system components, program code means in the form of computer-executable instructions or data structures can be transferred automatically from transmission computer readable media to physical computer readable storage media (or vice versa). For example, computer-executable instructions or data structures received over a network or data link can be buffered in RAM within a network interface module (e.g., a \u201cNIC\u201d), and then eventually transferred to computer system RAM and\/or to less volatile computer readable physical storage media at a computer system. Thus, computer readable physical storage media can be included in computer system components that also (or even primarily) utilize transmission media.","Computer-executable instructions comprise, for example, instructions and data which cause a general purpose computer, special purpose computer, or special purpose processing device to perform a certain function or group of functions. The computer executable instructions may be, for example, binaries, intermediate format instructions such as assembly language, or even source code. Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the described features or acts described above. Rather, the described features and acts are disclosed as example forms of implementing the claims.","Those skilled in the art will appreciate that the invention may be practiced in network computing environments with many types of computer system configurations, including, personal computers, desktop computers, laptop computers, message processors, hand-held devices, multi-processor systems, microprocessor-based or programmable consumer electronics, network PCs, minicomputers, mainframe computers, mobile telephones, PDAs, pagers, routers, switches, and the like. The invention may also be practiced in distributed system environments where local and remote computer systems, which are linked (either by hardwired data links, wireless data links, or by a combination of hardwired and wireless data links) through a network, both perform tasks. In a distributed system environment, program modules may be located in both local and remote memory storage devices.","The present invention may be embodied in other specific forms without departing from its spirit or characteristics. The described embodiments are to be considered in all respects only as illustrative and not restrictive. The scope of the invention is, therefore, indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In order to describe the manner in which the above-recited and other advantages and features can be obtained, a more particular description of the subject matter briefly described above will be rendered by reference to specific embodiments which are illustrated in the appended drawings. Understanding that these drawings depict only typical embodiments and are not therefore to be considered to be limiting in scope, embodiments will be described and explained with additional specificity and detail through the use of the accompanying drawings in which:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"}]},"DETDESC":[{},{}]}
