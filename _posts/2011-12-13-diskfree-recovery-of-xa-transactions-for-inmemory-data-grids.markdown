---
title: Disk-free recovery of XA transactions for in-memory data grids
abstract: A data grid node that is hosted by a computing system receives a request to prepare transaction operations for a multi-operational transaction for a commit. The transaction operations are associated with other data grid nodes in the data grid. The data grid node stores transaction state data for the multi-operational transaction in local memory associated with the data grid node and identifies other data grid nodes in the data grid that manage the data pertaining to the transaction operations for the multi-operational transaction. The data grid node sends the transaction state data to the other data grid nodes and the other data grid nodes store the transaction state data in local memory associated with the corresponding data grid node.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08738964&OS=08738964&RS=08738964
owner: Red Hat, Inc.
number: 08738964
owner_city: Raleigh
owner_country: US
publication_date: 20111213
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","DETAILED DESCRIPTION"],"p":["Embodiments of the present invention relate to recovering data for XA transactions, and more specifically to disk-free recovery of XA transactions for in-memory data grids.","Cloud computing is a model for enabling on-demand network access to a shared pool of configurable computing resources (e.g., networks, servers, storage, applications, and services) that can be rapidly provisioned and released with minimal management effort or service provider interaction. Cloud computing providers may offer infrastructure as a service (IaaS) and platform as a service (PaaS). One service that has been challenging to move to the cloud computing model is managed data storage, which is conventionally performed by databases. Data storage is stateful, which makes data as a service (DaaS) more challenging than other categories of cloud computing. Traditional data storage uses databases such as structured query language (SQL) and not only SQL (NoSQL) databases. Databases support the XA (X\/Open XA) architecture and XA transactions, which are transactions that consist of multiple operations that access resources. For example, a banking application may conduct an XA transaction that consists of two operations (1) deduct money from a first bank account and (2) add the deducted money to a second bank account. Typically, either both of the operations relating to the XA transaction will be permanent, if successful, or none of them will occur, and the data in an in-memory data grid relating to the bank accounts can be rolled back to a previous state as if the transaction never occurred.","In traditional data storage systems, such as databases, consistency is usually achieved by logging information to disk. If a process fails after a transaction is prepared and before it is completed, then a recovery log is read in order to move the system into a consistent state. The conventional disk-based recovery-log approach is costly because it involves a disk write.","Traditional database data storage usually does not work for DaaS because databases do not scale. Databases tend to run on a single machine or a few machines running in a fixed cluster. Therefore, databases typically are not distributed by nature. This becomes a problem in the cloud because there is no guarantee in a cloud environment that a particular server will be available at any given time. The lack of distribution for databases hampers elasticity and high availability, two of the parameters for cloud computing services.","Distributed databases, also known as data grids and in-memory data grids, have been recognized as a better alternative to databases in clouds. Data grids can scale up to thousands of nodes. Data grid platforms also improve the scalability of non-cloud applications by removing database bottlenecks and single points of failure. Some data grids may support XA transactions, but not recovery of transaction state data in case the state data is lost.","Described herein are a method and apparatus for providing disk-free recovery of XA (X\/Open XA) transactions for in-memory data grids. In one embodiment, a data grid node that is hosted by a computing system receives a request to prepare transaction operations for a multi-operational transaction for a commit. The transaction operations are associated with other data grid nodes in the data grid. The data grid node stores transaction state data for the multi-operational transaction from the request in local memory that is coupled to the data grid node and identifies other data grid nodes in the data grid that manage the data pertaining to the transaction operations for the multi-operational transaction. The data grid node sends the transaction state data to the other data grid nodes and the other data grid nodes store the transaction state data in local memory that is coupled to the corresponding data grid node.","Embodiments of the present invention reduce costs to recover data and provide fast recovery of transaction state data by redundantly storing the transaction state data in-memory for a multi-operational transaction at multiple data grid nodes in an in-memory data grid.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["100","100","103","105","110","124"]},"Machines , , ,  may be hardware machines such as desktop computers, laptop computers, servers, or other computing devices. Each of the machines , , ,  may include an operating system that manages an allocation of resources of the computing device (e.g., by allocating memory, prioritizing system requests, controlling input and output devices, managing file systems, facilitating networking, etc.). In one embodiment, one or more of the machines , , ,  is a virtual machine. For example, one or more of the machines may be a virtual machine provided by a cloud provider. In some instances, some machines may be virtual machines running on the same computing device (e.g., sharing the same underlying hardware resources). In one embodiment, one or more of the machines , ,  is a Java Virtual Machine (JVM), which may run on a hardware machine or on another virtual machine.","Machines , ,  each include a data grid node A-C that runs on the machine. The data grid node A-C is an instance of a data grid application. Each data grid node A-C may act as a server to clients and as a peer to other data grid nodes A-C. The data grid nodes A-C may communicate via the network to form an in-memory data grid . This may include using peer-to-peer protocols to establish and manage membership of the in-memory data grid .","The in-memory data grid  is a data store that spans multiple machines , ,  that are joined in a distributed cluster. A distributed cluster enables the in-memory data grid  to scale linearly as more data grid nodes A-C are added to the cluster. In one embodiment, distribution makes use of a consistent hash algorithm to determine where in the cluster entries should be stored. The hashing algorithm may be configured to maintain a specified number of copies of each entry in the in-memory data grid . In one embodiment, the hashing algorithm is deterministic in locating entries without resorting to multicasting requests or maintaining expensive metadata. In one embodiment, the in-memory data grid  is a NoSQL based data store. The in-memory data grid  can be provided to clients using a DaaS model. An in-memory data grid  may rely on main memory for data storage. In-memory data grids  are faster than disk-optimized data grids since they execute fewer CPU instructions. For brevity and simplicity, an in-memory data grid  is used as an example of a data grid throughout this document.","The in-memory data grid  may include a volatile in-memory data structure such as a distributed cache. A data grid may also provide a persistent data structure (e.g., a data structure stored in non-volatile disk storage). In one embodiment, the in-memory data grid  provides a distributed cache with write through or write behind to persistent storage. In one embodiment, a key value based storage system is used to host the data for the in-memory data grid  as part of a cache store.","Unlike a database, the in-memory data grid  distributes stored data across multiple machines , , . The in-memory data grid  is elastic (can deal with new nodes being added and nodes being removed), scalable and highly available. The in-memory data grid  may also perform load balancing and failover of individual data grid nodes A-C. Therefore, the in-memory data grid  performs the functions normally provided by databases, but can provide these functions using a DaaS model.","In one embodiment, the in-memory data grid  operates in a client-server mode, in which the in-memory data grid  serves resources (e.g., a stateful data store such as a cache) to client applications . In one embodiment, a machine  is a client machine hosting one or more applications . An application  can be any type of application including, for example, a web application, a desktop application, a database management application, a browser application, etc. An application  can be hosted by one or more machines . In one embodiment, the in-memory data grid  acts as a shared storage tier for client applications . A separate memory space may be generated for each client application .","A data grid node A-D can include one or more processes ,. A process , is an operating system process (e.g., a Java virtual machine instance). In one embodiment, a client application  can run outside of the Java Virtual Machines of the data grid nodes A-C. In another embodiment, a client application  can run in the same Java Virtual Machine as a data grid node. One embodiment of a client application  running in the same virtual machine as a data grid node is described in greater detail below in conjunction with . In another embodiment, a client application  may not be a Java-based application and may not be executed by a Java Virtual Machine.","In one embodiment, the in-memory data grid  is indistinguishable from a database to users and client applications . Therefore, client applications  may use conventional database formats and protocols for communicating with the in-memory data grid .","Each data grid node A-C may act as a server for the data grid. Therefore, a client  may access any of the data grid nodes A-C to gain access to the entire data grid . New data grid nodes can be started and connected to the other data grid nodes without performing rehashing or state transfer.","In one embodiment, the in-memory data grid  provides a rich and powerful application programming interface (API) that looks and feels like a database. A client application  may communicate with any data grid node A-C of the in-memory data grid  to access data stored in the in-memory data grid . A data grid node A-C may receive database commands, such as commands to store objects, to retrieve objects, to perform searches, etc. When a data grid node A-D receives a command to store an object, the data grid node A-C divides the object into a collection of linked key value pairs. The data grid node A-C then stores some or all of these key value pairs. Additional data grid nodes A-C may also store some or all of the key value pairs. One embodiment of linking key value pairs is described in greater detail below in conjunction with . When any of the data grid nodes A-C receives a request for the stored object, that data grid node A-C gathers the key value pairs for that object, and reconstructs the object from the key value pairs. This may involve requesting the key value pairs from one or more other data grid nodes A-C. Once the object is reconstructed, the data grid node A-C returns the object to the client from which the request was received.","To use the in-memory data grid , a client application  acquires a session from the in-memory data grid , and sends commands to the in-memory data grid  as part of the session. Client application  may be a standalone application running on a single machine. A number of operations can be performed on the in-memory data grid . The data grid  can support multi-operational transactional access of the data grid nodes A-C. A multi-operational transaction can be an XA (X\/Open XA) transaction. For brevity and simplicity, an XA transaction is used as an example of a multi-operational transaction throughout this document. In the XA architecture, an XA transaction is a distributed transaction that consists of multiple operations that access one or more resources. A data grid node A-C can provide operations for a multi-operational transaction, for example, start, prepare, commit, rollback, and recover operations, to perform multi-operational transactional access on the in-memory data grid . Performing operations that pertain to multi-operational transactional access on data in the in-memory data grid  may be performed by calling the get, put, remove, replace, start, prepare, commit, rollback, and recover functions on an instance of the in-memory data grid .","The operations that pertain to an XA transaction are considered to be within the scope of an XA transaction. Some multi-operational transactional standards, such as the XA standard, use a two-phase commit (2PC) protocol to ensure that all resources enlisted within a transaction either commit or rollback any particular transaction consistently (all of the resources do the same). An XA transaction should succeed or fail as a complete unit. If any of the operations within the scope of an XA transaction are not successful, none of the operations within the scope of the XA transaction are committed to an in-memory data grid .","For example, a banking application  may wish to conduct a transaction that consists of two access operations: (1) deduct money from a first bank account and (2) add the deducted money to a second bank account. The bank accounts can have data in one or more data grid nodes A-C in the in-memory data grid . For example, the data for the first bank account is stored in data grid node A and the data for the second bank account in stored in data grid node B. The operations may be requests to change the dollar amount in each bank account. The banking application  can make requests for transactional access of the in-memory data grid  via the transaction manager  and XA resource implementer  in a transaction originator node. One embodiment of an application request for an XA transaction using the transaction manager and XA resource implementer is described in greater detail below in conjunction with . There can be a data grid node, such as node C, that is designated as a transaction originator data grid node for a particular XA transaction. When a client application  communicates with the data grid  for a particular XA transaction, the client application  can directly communicate with transaction originator data grid node that is managing that particular transaction (e.g., transaction originator node C). The transaction originator data grid node can pass along an operation request to one or more data grid nodes A,B in the cluster.","Before the operation that deducts money from the first bank account is committed to data grid node A in the in-memory data grid , the transaction originator data grid node C can first ensure that the operation made to add money to the second bank account in data grid node B is successful. The transaction originator data grid node C can make sure that either all of the operations within the scope of transaction successfully happen or none of them occur. For instance, there may be a system failure or an operation failure pertaining to one of the data grid node A-C with regard to deducting money from the first bank account and\/or adding money to the second bank account. In such a case, the banking application  may wish that the operations that deducted money from the first bank account and adding money to the second account, as well as any other operations performed within the scope of the transaction, rollback to a previous state.","When a process fails after an XA transaction is prepared and before the XA transaction is completed, the data in the data grid is in an inconsistent state. The data grid nodes A-C can include an XA recovery logger  and a recovery manager  to redundantly store the XA transaction state data for an XA transaction in the local in-memory container of multiple data grid nodes in the in-memory data grid. The XA recovery logger  and a recovery manager  components can be combined together or separated in further components, according to a particular embodiment. Examples of the XA transaction state data can include, and are not limited to, a key-value pair for each operation for the XA transaction, one or more cache names, an XA transaction identifier (XID) as provided by the XA compliant transaction manager  for the XA transaction, and an association between the XID and the operations. The XA recovery logger  and recovery manager  can backup the XA transaction state data for an XA transaction in memory of other data grid nodes A-C, such that if a data grid node A-C fails and is restarted, the XA recovery logger  of the failed node can recover the transaction state data from another node in the data grid.","An XA transaction that is prepared and not completed is also known as an in-doubt transaction. One embodiment of a system administrator process handling the state of the in-doubt transaction is described in greater detail below in conjunction with . The request can include the XA transaction identifier (XID) of an in-doubt transaction of interest. The system administrator process can use the XID to determine whether to force a commit or to force a rollback of the state of the transaction. A rollback command instructs the data grid nodes to cause any operation that was performed for a particular transaction to be returned to a previous state. A commit command instructs the data grid nodes to apply the change to allow other transactions that will read the data to read the changed data. The system administrator process can obtain an internal ID from a data grid node and can use the internal ID to execute a commit command or a rollback command.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 2","FIG. 1"],"b":["240","200","240","190","240","242","244","246","248","242","244","246","248","260","262","260","264","268","262","270","272"]},"The collection of key value pairs  includes a primary key value pair . The primary key value pair  has a key of \u201c4442191224\u201d that represents an account number, which a data grid node can use to retrieve the primary key value pair . The primary key value pair's values are pointers to key value pairs , , , . Key value pairs , ,  were generated from fields having primitive types. Therefore, the values of these key value pairs , ,  are the contents of those fields.","Key value pair  was generated for an internal object (complex field ). Therefore, key value pair  is a primary key value pair for the internal object. Key value pair  includes pointers to key value pairs , . Each of key value pairs ,  is a primary key value pair for an additional nested object. Key value pair  includes pointers to key value pairs , . Key value pair  includes pointers to key value pairs , . Due to the pointers linking the key value pairs, a data grid node can retrieve all of the key value pairs and use them to reconstruct the object based on the unique identifier \u201c4442191224.\u201d",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 3","FIG. 1"],"b":["300","300","151","125","103","105","110","300","301","303","305","307"]},"A data grid node that communicates with a transaction manager is a transaction originator node. An enlisted data grid node is a node in the data grid that manages data that relates to a transaction. Certain information for an XA transaction may be owned and managed by a particular node and other information for the XA transaction may be owned and managed by another node. For example, Owner Name data for an XA transaction may be owned by Node , and the Account Balance data for the XA transaction may be owned by Node . The transaction originator node can communicate with the enlisted data grid nodes in the data grid to manage the operations in the data grid pertaining to an XA transaction. For example, the transaction originator node is Node , and there are two enlisted data grid nodes in the data grid for the particular XA transaction, Node  and Node .","The operation module  can perform a requested operation (e.g., put, replace, prepare, rollback, commit) on the cache data that is coupled to the operation module . The operation-module  can receive a prepare request to prepare transaction operations for an XA transaction for a commit. A commit is to make a set of changes that were made to one or more caches for a particular XA transaction permanent. A prepare request can cause enlisted nodes that have performed operations relating to a particular XA transaction to take steps for ensuring that a future commit request will succeed. For example, an enlisted node can acquire a lock for any changed data. The prepare request can include the transaction state data for the XA transaction. Examples of the transaction state data can include, and are not limited to, a key-value pair for each operation for the XA transaction, one or more cache names, an XID for the multi-operational transaction, and an association between the XID and each operation.","When the XA recovery logger  is hosted by a transaction originator node, the prepare request which the operation module  receives may be from an XA compliant transaction manager (e.g., XA compliant transaction manager  in ) via an XA resource implementer (e.g., XA resource implementer  in ) that formats the request. The state data module  can send a record message to a recovery manager  (e.g., client  in ) that is coupled to the state data module . The record state message is a request for the recovery manager  to write the transaction state data  in the local in-memory container  (e.g., main memory) for the data grid node. The record state message can include the transaction state data  for the XA transaction. The recovery manager  can receive a record state message and can write the transaction state data  in the local in-memory container  (e.g., main memory) for the data grid node. The recovery manager  can send a response to the state data module  indicating that the transaction state data  is stored in the local in-memory container , and the state data module  can store tracking data  in a data store  that is coupled to the state data module  to track the responses that are received.","When the XA transaction state data module  is hosted by a transaction originator node, the state data module  can use a cache name and a key that is specified in the prepare request to identify which nodes are the enlisted nodes that have cache data associated with cache name and the key. The state data module  can send a prepare request and a copy of the transaction state data  to the enlisted data grid nodes. The prepare request that is sent to the enlisted nodes is a request to prepare operations for an XA transaction for a commit and a request to store the transaction state data  for the XA transaction in the in-memory container of the corresponding enlisted node. The state data module  can wait to receive a response from each of the enlisted data grid nodes indicating that the corresponding enlisted data grid node has stored the transaction state data  for the XA transaction in its local in-memory container. The state data module  store tracking data  to track the responses that are received. When the state data module  receives a successful response from the enlisted nodes, the state data manager module  can send a response to the transaction manager indicating that the multi-operational transaction is ready for commit.","When the XA transaction state data module  is hosted by an enlisted data grid node, the prepare request which the operation module  receives may be from the state data module of a transaction originator node, and the operation module  can prepare the operations for a commit. For example, the operation module  can acquire a lock for the changed data. The state data module  sends a record message to the recovery manager  to write the transaction state data  in the local in-memory container  (e.g., main memory). The state data module  can receive a response from the recovery manager  indicating that the transaction state data  is stored in the local in-memory container  and can send a message to the transaction originator node that the transaction state data  for the XA transaction is stored in its local in-memory container .","A data grid node (e.g., transaction originator node, enlisted node) may fail. When a data grid node fails and its operating system is rebooted, the data grid node may receive a recover message from a recovery manager . The recover message is a request for any information which the failed data grid node may have pertaining to an in-doubt transaction. The query module  can broadcast a message to other data grid nodes in the cluster to request information for any in-doubt transactions. An embodiment of a failed data grid node broadcasting a request for information for in-doubt transactions is described in greater detail below in conjunction with . The query module  can receive information about an in-doubt transaction and can send a response to the XA compliant transaction manager.","When a data grid node is a node that receives the broadcast message requesting information for any in-doubt transactions, the query module  can send an in-doubt transaction request to the recovery manager  that is coupled to the query module . The in-doubt transaction request is a request for the recovery manager  to provide information about in-doubt transactions it is aware of. The recovery manager  can search the in-memory container  for information about in-doubt transactions and provide a response to the query module . An embodiment of the recovery manager  providing information about in-doubt transactions is described in greater detail below in conjunction with . The query module  can receive the response from the recovery manager  and can provide the information about the in-doubt transaction to the data grid node that sent out the broadcast message.","An identifier mapping module  can generate an internal identifier (internal ID) that corresponds to an XA transaction identifier (XID), which was provided by an XA compliant transaction manager (e.g., XA compliant transaction manager  in ). The identifier mapping module  can create mapping information that maps the internal ID to an XID for an XA transaction. The internal ID can be used to communicate with data grid nodes to perform an operation, such as a commit operation and a rollback operation. An embodiment for using an internal ID is described in greater detail below in conjunction with .",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 4","FIG. 1"],"b":["400","400","400","151","125","110","401","403","405","407"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 5","FIG. 1"],"b":["500","500","500","151","125","103","105","501","503","505","507","509"]},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 6","b":["601","611","613","617","615","619","611","613","617","619","619","611","613","617","603","627","605","637","617","627","637","618","628","638"]},"A client application  can send () an XA compliant notification of the start of an XA transaction to a transaction manager . The transaction manager  can notify () the XA resource implementer  of the start of the XA transaction. The transaction originator node is the node where the client application  started the transaction. The transaction manager  can generate an XA compliant transaction identifier (XID) and provide the XID in the notification to the XA resource implementer , which can store the XID in a data store that is coupled to the XA resource implementer . The XA resource implementer  is notified it will associate all of the operations, for example, write a name Jane Doe in an Owner Name field and put a value of $0 in bank account 5552191234, for a current transaction.","The Node   can receive () a method call via an API from an application  requesting two operations to be performed on the data stored in the caches in the in-memory data grid for the XA transaction. For example, the first operation is to write a name Jane Doe in an Owner Name field and the second operation is to put a value of $0 in bank account 5552191234. In another example, the same transaction involving the two transactions (e.g., write Jane Doe, write value $0) is a distributed transaction that may involve interactions with other XA compliant resources (e.g., write an audit to a database). A distributed transaction is a transaction that spans more than one XA resource, such as a transactions that spans a data grid and a database.","Information for an XA transaction may be owned by a number of nodes , in the data grid other than the transaction originator node . For example, Owner Name data for a transaction may be owned by Node  , and Account Balance data for the transaction may be owned by Node  . In this example, the transaction originator node is Node  , and there are two enlisted data grid nodes in the data grid for the particular XID, Node   and Node  .","The nodes store mapping data of which caches are associated with which nodes. The data to node association is calculated using a consistent hashing algorithm to allow the transaction originator node  to identify the nodes that have cache data associated with a cache name. For example, Node   can use the data to node associations to determine that \u201cOwner Data is owned by Node   and that \u201cAccount Balance\u201d data is owned by Node  . The Node   can send the operation requests to the appropriate nodes in the data grid that contain a cache having the cache name and key. For example, the transaction originator node  sends (BA) the operation request to write a name \u2018Jane Doe\u2019 in an Owner Name field to Node   and sends (B) the operation request to put a value of \u2018$0\u2019 in bank account 5552191234 to Node  . The nodes , can access the data to perform the operations accordingly. For instance, Node   will use the value \u201cJane Doe\u201d to change the Owner Name data, and Node   will use the value \u201c$0\u201d to change the Account Balance data.","The client application  then sends () a message to the transaction manager  to commit the XA transaction. The commit message includes the XID for the XA transaction. The transaction manager  sends () a prepare message to transaction originator node  via the XA resource implementer  to initiate the two-phase commit protocol. The first phase is a prepare phase and the second phase is a commit phase. The prepare message instructs the transaction originator node  to prepare the XA transaction for a commit operation. Preparation can include, for example, and not limited to, one or more nodes in the data grid to acquire data locks for the particular data which the node is changing. The prepare message specifies the operations that are associated with XA transaction. The XA resource implementer  encodes the modifications performed in the transaction's scope (e.g, the account balance and owner data changes) into a proprietary format (e.g., Java serialization) and sends the formatted modifications to all of the nodes involved within the transaction (e.g., node , node ). The XA resource implementer  also stores the formatted modifications in its own local memory via its own XA recovery logger.","The XA recovery logger  in the transaction originator node  sends () a record state message to its XA recovery manager . A record state message can be a network call. The recovery manager  receives the record state message and stores transaction state data in memory that corresponds to the data grid node . The record state message can include the transaction state data. The transaction state data includes recovery information for all of the operations which are associated with a transaction. For example, the transaction state data includes the XID, the cache and key information for each transaction operation (e.g., write Owner Name operation and write Account Balance operation), the values for each operation, and an association between the XID and each operation. The recovery manager  receives the record state message and writes () the transaction state data in memory that corresponds to the data grid node .","The XA recovery logger  in the transaction originator node  sends (A,B) a prepare message via network calls over the network to all of the enlisted nodes (e.g., Node  , Node  ) to perform a prepare operation. The prepare message instructs the enlisted nodes to perform any operations for updating the request data (e.g., Owner Name, Account Balance) and to store the transaction state data in-memory. The prepare message can include the transaction state data for the XA transaction. An enlisted node performs the prepare operation in response to the request. For example, an enlisted node may acquire a lock for the changed value. For instance, Node  acquires a lock for changing the Owner Name data to Jane Doe, and Node  acquires a lock for changing the Account Balance data to \u201c$0\u201d. After an enlisted node has acquired a lock for an operation, the XA transaction state data module , in a respective enlisted node sends (A,B) a record state message to a corresponding recovery manager ,. A recovery manager , receives a record state message and writes (A,B) the transaction state data in memory that corresponds to the data grid node.","Each recovery manager , writes the transaction state data pertaining to the all of the operations for the XA transaction For example, Node   owns Owner Name data, but the recovery manager  writes the transaction state data for both Owner Name data and Account Balance data to the in-memory container that is coupled to Node  . In another example, Node   owns Account Balance data, but the recovery manager  writes the transaction state data for both Owner Name data and Account Balance data to the in-memory container that is coupled to Node  . Thus, the transaction state data for the XA transaction is stored redundantly.","Each enlisted node can send (A,B) a status response to the XA transaction state data module  in the transaction originator node  indicating whether or not the transaction state data has been successfully stored in-memory. If the XA recovery logger  in the transaction originator node  receives a failed response from one of the enlisted data grid nodes, the transaction originator node  can subsequently send an operation request to the nodes that attempted to prepare operations to now rollback the operations relating to the transaction identifier to a previous state. If the XA transaction state data module  in the transaction originator node  receives successful status responses from each of the enlisted data grid nodes, the XA recovery logger  can create and send () a ready to prepare message. The XA recovery logger  in the transaction originator node  keeps tracks of the response messages it receives from the various enlisted nodes (e.g., ,).","The XA recovery logger  in the transaction originator node  sends () a ready to prepare message to the transaction manager  via the client . The client  receives the ready to prepare message and formats the ready to prepare message in the proper protocol and sends () the formatted ready to prepare message to the transaction manager . The transaction manager  is notified via the ready to prepare message that if the transaction originator node  subsequently fails, the transaction state data for the particular XA transaction can be recovered from another data node (e.g., Node  , Node  ). Likewise, if any of the enlisted data grid nodes fails, the transaction state data for the particular XA transaction can be recovered from the other data nodes (e.g., Node   or Node  ) or the transaction originator node . The transaction state data is not recoverable when the transaction originator node and all enlisted nodes fail.","The transaction manager  sends () a commit message to transaction originator node  via the client  to initiate the second phase (e.g., commit phase) of the two-phase commit protocol. A commit operation applies the changes relating to the transaction data such that the change can be read for other subsequent transactions. The commit message specifies the operations that are associated with XA transaction. The client  receives the commit message and formats a commit message in the proper protocol (e.g., Hot Rod) and sends () the formatted commit message to the transaction originator node . The transaction originator node  sends (A,B) a commit request to the enlisted data grid nodes to make the set of changes made by an enlisted data grid node for the specific XA transaction permanent.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 7","FIG. 1","FIG. 8"],"b":["700","700","700","147","125","103","105","110","701","703","705","707"]},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 8","b":["801","813","817","815","819","813","815","817","819","803","827","805","837","817","827","837","818","828","838","819","829","839","895"]},"A node pertaining to an XA transaction, such as a transaction originator node and\/or an enlisted node, may fail. In this example, the transaction originator node  fails after returning a ready to commit message to a transaction manager. A node may fail, for example, due to a disk failure or a process crash. A system administrator process  for the data grid is notified and restarts A,B the XA recovery manager  in the failed node (e.g., transaction originator node ). A system administrator process  can be a process running in a virtual machine in the data grid. A failed data grid node can retain the node state data that corresponds to the node in its local memory, but does not retain information pertaining to any XA transactions which the failed node was involved with prior to the point of failure.","When the XA recovery manager  reboots, it sends () a recover message to the failed node  via the XA resource implementer  to determine whether the failed node has information of any in-doubt transactions. An in-doubt transaction is an XA transaction that was prepared, but not committed or rolled back. The XA resource implementer  receives the recover message from the XA recovery manager , formats the recover message into an appropriate protocol (e.g., Hot Rod), and sends () the formatted recover message to the XA recovery logger . The XA recovery logger  sends A,B a broadcast message to query all of the data grid nodes in the cluster associated with the failed node , such as Node   and Node  , to determine whether any node has information of an in-doubt transaction. The messages A and B can be broadcast in parallel.","The XA recovery logger , in a respective data grid node in the cluster can send a message to its corresponding recovery manager , to check the local in-memory for any information pertaining to an in-doubt transaction. A recovery manager , may locate an in-doubt transaction in the local memory of the data grid node and can provide the XID of the in-doubt transaction to the corresponding XA XA recovery logger  ,. For example, the XA XA recovery logger   in Node   receives the broadcast message and sends () a message to its recovery manager  to check the local memory of the node for an in-doubt transaction. The recovery manager  identifies () the an in-doubt transaction in-memory and provides () the XID to the XA transaction state data module . The XA recovery logger  in Node   sends () a response that includes the XID of the in-doubt transaction to the XA recovery logger  in the failed transaction originator node . The XA recovery logger  provides () the XID to the XA resource implementer , which formats a response that includes the XID and sends () the response to the recovery manager .","The recovery manager  compares the response(s) that are received from the nodes in the data grid with the transaction manager log and determines which transactions are in-doubt and can use recovery. The recovery manager  sends () a message that includes the XID of the in-doubt transaction to the system administrator process . The system administrator process  determines how to handle the in-doubt transaction. One embodiment of the system administrator process determining how to handle the in-doubt transaction is described in greater detail below in conjunction with . The system administrator process  can decide whether to apply the state of the transaction (e.g., commit) or to delete the transaction (e.g., rollback). The system administrator process  can use multiple JMX (Java Management Extension) tooling operations to handle the in-doubt transaction.","The recovery manager  can send a forget call that includes the XID to the transaction originator node . The forget call notifies the transaction originator node  that the transaction manager  is aware of the XID is for in-doubt transaction. In response to the forget call, the transaction originator node  can send a message to the enlisted nodes to no longer mark the XID as an in-doubt transaction. Subsequently, when a node is queried for in-doubt transactions, the node does not provide the particular XID.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 9","FIG. 1"],"b":["900","900","900","149","103","105","110","115"]},"At block , processing logic receives a message from a transaction manager that includes the XID of an in-doubt transaction of interest. The message is a request for processing logic to handle the state of the in-doubt transaction. For example, processing logic can use the XID to determine whether to force a commit or to force a rollback of the state of the in-doubt transaction. A rollback command instructs the data grid nodes to cause any operation that was performed for a particular transaction to be returned to a previous state. A commit command instructs the data grid nodes to apply the change to allow other transactions that will read the data to read the changed data.","At block , processing logic sends a request to any node in the cluster for information for the in-doubt transactions. The recovery manager in the node provides the information of the in-doubt transactions. For example, Node  is a transaction originator node and Node  and Node  are enlisted nodes. Node  is not an enlisted node, but is in the cluster of nodes as Node , Node , and Node . Node  fails and processing logic sends a request to Node  for the information for the in-doubt transactions. Node  receives the request and requests the information of the in-doubt transactions from Node  and Node . Node  receives and provides the information to the system administrator process.","At block , processing logic receives the information for the in-doubt transactions from the node. The information can be a list of the in-doubt transactions that includes the XID as generated by a transaction manager, an internal ID as generated by a recovery manager, and a status, for each in-doubt transaction in the list. The list is a map of the XID to the internal ID for each in-doubt transaction. The status can be a string describing the state of the transaction. For example, the status can be \u2018prepared\u2019 to indicate that the transaction is prepared on all nodes, but is a commit request has not been received. In another example, the status is \u2018heuristically committed\u2019 to indicate the transaction was committed on a subset of nodes, but not all of the nodes.","At block , processing logic locates the transaction having the XID that matches the XID received from the transaction manager in the information (e.g., list). At block , processing logic determines whether to perform a force commit operation or a force rollback operation based on the status of the matching in-doubt transaction. For example, if the status is \u2018prepared,\u2019 processing logic may force a commit. If the status is \u2018heuristically prepared,\u2019 processing logic may force a rollback. At block , processing logic identifies the internal ID that corresponds to the XID in the list and sends a command (e.g., commit command, rollback command) that includes the internal ID to any node in the cluster in the data grid to handle the in-doubt transaction at block . The node can relay the command to the appropriate nodes in the cluster to perform the operations (e.g., commit, rollback).",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 10","b":"1000"},"The machine may be a personal computer (PC), a tablet PC, a set-top box (STB), a Personal Digital Assistant (PDA), a cellular telephone, a web appliance, a server, a network router, a switch or bridge, or any machine capable of executing a set of instructions (sequential or otherwise) that specify actions to be taken by that machine. Further, while a single machine is illustrated, the term \u201cmachine\u201d shall also be taken to include any collection of machines that individually or jointly execute a set (or multiple sets) of instructions to perform any one or more of the methodologies discussed herein.","The exemplary computer system  includes a processing device , a main memory  (e.g., read-only memory (ROM), flash memory, dynamic random access memory (DRAM) such as synchronous DRAM (SDRAM) or DRAM (RDRAM), etc.), a static memory  (e.g., flash memory, static random access memory (SRAM), etc.), and a data storage device , which communicate with each other via a bus .","Processing device  represents one or more general-purpose processing devices such as a microprocessor, a central processing unit, or the like. More particularly, the processing device may be complex instruction set computing (CISC) microprocessor, reduced instruction set computing (RISC) microprocessor, very long instruction word (VLIW) microprocessor, or processor implementing other instruction sets, or processors implementing a combination of instruction sets. Processing device  may also be one or more special-purpose processing devices such as an application specific integrated circuit (ASIC), a field programmable gate array (FPGA), a digital signal processor (DSP), network processor, or the like. The processing device  is configured to execute instructions  for performing the operations and steps discussed herein.","The computer system  may further include a network interface device . The computer system  also may include a video display unit  (e.g., a liquid crystal display (LCD) or a cathode ray tube (CRT)), an alphanumeric input device  (e.g., a keyboard), a cursor control device  (e.g., a mouse), and a signal generation device  (e.g., a speaker).","The data storage device  may include a machine-readable storage medium  (also known as a computer-readable medium) on which is stored one or more sets of instructions or software  embodying any one or more of the methodologies or functions described herein. The instructions  may also reside, completely or at least partially, within the main memory  and\/or within the processing device  during execution thereof by the computer system , the main memory  and the processing device  also constituting machine-readable storage media.","In one embodiment, the instructions  include instructions for an XA transaction state data module (e.g., XA transaction state data module  of ) and\/or a software library containing methods that call a data grid node and\/or a proxy server. While the machine-readable storage medium  is shown in an exemplary embodiment to be a single medium, the term \u201cmachine-readable storage medium\u201d should be taken to include a single medium or multiple media (e.g., a centralized or distributed database, and\/or associated caches and servers) that store the one or more sets of instructions. The term \u201cmachine-readable storage medium\u201d shall also be taken to include any medium that is capable of storing or encoding a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention. The term \u201cmachine-readable storage medium\u201d shall accordingly be taken to include, but not be limited to, solid-state memories, optical media and magnetic media.","Some portions of the preceding detailed descriptions have been presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the ways used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.","It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion, it is appreciated that throughout the description, discussions utilizing terms such as \u201creceiving\u201d or \u201cstoring\u201d or \u201cidentifying\u201d or \u201csending\u201d or \u201cgenerating\u201d or \u201crestarting\u201d or \u201cproviding\u201d or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage devices.","The present invention also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the intended purposes, or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium, such as, but not limited to, any type of disk including floppy disks, optical disks, CD-ROMs, and magnetic-optical disks, read-only memories (ROMs), random access memories (RAMs), EPROMs, EEPROMs, magnetic or optical cards, or any type of media suitable for storing electronic instructions, each coupled to a computer system bus.","The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein, or it may prove convenient to construct a more specialized apparatus to perform the method. The structure for a variety of these systems will appear as set forth in the description below. In addition, the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.","The present invention may be provided as a computer program product, or software, that may include a machine-readable medium having stored thereon instructions, which may be used to program a computer system (or other electronic devices) to perform a process according to the present invention. A machine-readable medium includes any mechanism for storing information in a form read-able by a machine (e.g., a computer). For example, a machine-readable (e.g., computer-readable) medium includes a machine (e.g., a computer) readable storage medium such as a read only memory (\u201cROM\u201d), random access memory (\u201cRAM\u201d), magnetic disk storage media, optical storage media, flash memory devices, etc.","In the foregoing specification, embodiments of the invention have been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of embodiments of the invention as set forth in the following claims. The specification and drawings are, accordingly, to be regarded in an illustrative sense rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings and in which:",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
