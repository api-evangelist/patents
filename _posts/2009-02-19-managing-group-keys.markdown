---
title: Managing group keys
abstract: In an example, one or more cryptographic keys may be associated with a group. Any member of the group may use the key to encrypt and decrypt information, thereby allowing members of the group to share encrypted information. Domain controllers (DCs) maintain copies of the group's keys. The DCs may synchronize with each other, so that each DC may have a copy of the group's keys. Keys may have expiration dates, and any client connected to a DC may generate a new key when a key is nearing expiration. The various clients may create new keys at differing amounts of time before expiration on various DCs. DCs that store keys early thus may have time to propagate the newly-created keys through synchronization before other DCs are requested to store keys created by other clients. In this way, the creation of an excessive number of new keys may be avoided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08325924&OS=08325924&RS=08325924
owner: Microsoft Corporation
number: 08325924
owner_city: Redmond
owner_country: US
publication_date: 20090219
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Cryptographic keys may be used to protect data. Data may be encrypted with a key, which prevents anyone from reading the data unless they have access to the key. The key is managed in a way that prevents unauthorized entities from accessing the key. In addition to using keys to encrypt and decrypt data, keys may be used for other purposes, such as authentication, digital signatures, generation of pseudo-random numbers, or any other cryptographic computation that uses keys.","There are various mechanisms that bind a key to an entity. A specific user is an example of an entity to which a key may be bound. For example, the Data Protection Application Programming Interface (DPAPI) can associate a key with a particular user's logon credentials. With DPAPI, when a key is bound to a user, the key is accessible only when that user is logged into the machine on which access to the key is sought.","There are various scenarios in which it may make sense to bind a key to some target other than a specific user.","Cryptographic keys may be associated with a group, and may be stored by a mechanism that limits access to the keys to members of the group. For example, the ACTIVE DIRECTORY service may be used to associate a given item of data with a particular group. A group's cryptographic keys, the policies associated with the use of those keys, and other metadata, may be stored in a container maintained by the ACTIVE DIRECTORY service. When an entity runs an application that wants to encrypt or decrypt data that belongs to the group, that application may request the group's keys from the service. The service may provide the keys to the requesting application, or may decline to provide those keys, depending on whether the application is being run by a member of the group. The ACTIVE DIRECTORY service provides an example infrastructure that may be used to control access to data based on group membership, but any other mechanism could be used.","In one example model of key management, keys have a limited longevity, so they recurrently expire and get replaced. At any given time, the group may have one current key that is used for new encryption jobs (such as encryption of new data or re-encryption of old data), but older keys continue to be stored so that they may be used to decrypt any data that was encrypted before the current key was created. When the keys for the group are stored on replicated servers that synchronize with each other intermittently, there is a window of time when some servers will have the newest key and others will not. A client may create a new key if the particular server that it contacts provides an expired or near-expiring key. The client may then use the key for encryption, and may also store the key on the server for future use by the group. However, if each client creates a new key at a specific time relative to the current key's expiration, then an excessive number of keys may accumulate as different clients may create new keys before one client's replacement key has had a chance to propagate through the servers. To avoid this issue, different clients may create new keys at differing amounts of time before the current keys expires, which increases the likelihood that a server on which that client stores the key will propagate the key to other servers before other clients create new keys of their own. This technique reduces the likelihood that each client will create its own new key in anticipation of the current key's expiring, thereby reducing the accumulation of keys. Techniques are described herein that may be used to stagger the times at which different clients create new keys.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","There are various situations in which data are to be protected by encryption. For example, a user may have files, e-mails, credentials, etc., that are to be encrypted, and there may be reasons to ensure that the data can only be decrypted by the specific user who owns the data. Schemes exist that allow data to be encrypted in such a way that only a particular user can access the data. For example, DPAPI, which is provided with various versions of the MICROSOFT WINDOWS operating systems, allows data to be encrypted with logon secrets associated with the user, or with domain authentication secrets (in the case where the user's identity is managed as part of a domain). Mechanisms such as DPAPI are typically used to protect keys that applications or other programs use to encrypt\/decrypt data on the user's behalf. For example, an E-mail application could generate a symmetric key that is used to encrypt and decrypt a particular user's e-mail, and could use DPAPI to protect that key. When the user's e-mail is to be decrypted, the E-mail application calls on DPAPI to provide the key, and DPAPI will respond by providing the key if the user to whom that key has been sealed is presently logged in. (In addition to encryption and decryption, the keys may also be used for other cryptographic applications, such as authentication, digital signatures, pseudo-random number generation, etc.)","While these kinds of schemes can protect keys or other data for the benefit of one user, there are some situations where it makes sense to protect data for a group of users or machines. That is, there may be encrypted data that is to be accessed by members of a group. If a key for the data could be made accessible to a group of users and\/or machines, then all members of the group could use the key to encrypt and decrypt the data. But mechanisms like DPAPI can only protect data for a specific user's benefit, and thus are of little use in protecting an encryption\/decryption key (or other data) that is to be shared among group members.","The subject matter described herein provides a way to protect a key for the benefit of a group. There are existing mechanisms that recognize the concept of a group and that can control access to data in such a way that access to a particular piece of data is limited to the group. These existing mechanisms may be leveraged to limit access to a key (or access to a collection of keys) to a particular group. The ACTIVE DIRECTORY service is an example of a mechanism that recognizes the concept of a group and that can limit access to data to a particular group. It is noted that the subject matter herein may be implemented using the underlying functionality of the ACTIVE DIRECTORY service, and without making changes to that underlying functionality. However, the subject matter herein is not limited to the use of the ACTIVE DIRECTORY service. Any mechanism may be used that recognizes the concept of a group, and that can be configured to limit access to a piece of data to a specific group. For purposes of illustration, examples are described in which the group keys are used to encrypt and decrypt data for the group. However, it will be understood that the group keys could be used for any sort of cryptographic process or computation, such as those mentioned above (e.g., authentication, digital signatures, pseudo-random numbers, etc.).","Turning now to the drawings,  shows an example of groups, and of how sets of keys may be associated with groups.  shows entities , , , and . In order to illustrate the example, four entities - are shown, although there could be any number of entities that are members of groups. A given implementation of groups could allow any type of entities (or combination of types of entities) as being the members of a group. For example, one implementation of a group might allow specific users to be members of groups. Another implementation could allow specific machines to be members of the group. Yet another implementation might allow both types of entities to be members of groups, or might even allow groups to be members of other groups. The subject matter herein applies to any concept of a group, regardless of the types of entities (or combinations of entities) that may be members.","Entities , , and  are members of group . Entities  and  are members of group . As shown, group membership may overlap such that a given entity (e.g., entity ) is part of more than one group. Two example groups  and  are shown in , although any number of groups could be defined.","Each group may be associated with its own collection of keys. For example, group  is associated with set  of keys, which comprises keys , , and . Similarly, group  may also be associated with a set of keys (although to simplify the illustration of , group 's set of keys is not shown). A policy that governs the use of the keys may allow the keys to be provided to members of the group.","Keys may have expiration dates . The table in  that depicts set  shows the expiration dates for each of keys -. In one example, keys do not disappear on their expiration dates, but may cease to be used for new encryption when they expire or have been superseded by newer keys. Older keys (e.g., those that have expired and\/or have been superseded) may be stored so that they may be used by members of the group to decrypt data that was previously encrypted with that older key. (Application-enforced re-encryption policies may cause old data to be re-encrypted with new keys, thereby rendering the older keys obsolete. However, since the mechanism that maintains the groups keys may not know the applications' re-encryption policies, expired and superseded keys may be stored indefinitely so that data encrypted with those keys does not become inaccessible, even if the applications that use those keys have not chosen to re-encrypt data with new keys.)","In some applications, there may be reason to encrypt all data with a set of keys in a group by an encrypting entity, e.g., an automated or manually started computer service. The encrypted documents may be stored in a repository that the encrypting entity does not have access to or does not know about. When and if there is reason to destroy the encrypted documents, it may be difficult to find all copies of the documents and to delete them irretrievably. Instead, destroying the keys that encrypted the data provides a controlled and a convenient way of data destruction. The encrypted documents without the keys cannot be decrypted, where the difficulty of inaccessibility is defined by the strength of the cryptographic algorithms used to encrypt the document. This approach provides an easy document (or any data in general) destruction facility.","The creation of new keys may be controlled by a key update mechanism . Key update mechanism  may incorporate techniques that are described below. In general, key update mechanism  may allow keys to be updated without creating an excessive number of new keys, even when mirrored servers that generate the keys do not synchronize with each other very often. This issue, and techniques for addressing it, are further described below.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 2","FIG. 2","FIG. 2"]},"Structure  represents hierarchical relationship among data. At one level of the hierarchy is domain . Domain  represents a collection of computers that share access to a central directory database, such as one managed by the ACTIVE DIRECTORY service. Domain  may contain information such as user account information for users in the domain, information about security policies that apply to the domain, information about membership in groups, or other information about the domain. The various types of information about the domain may be stored within containers under the heading of domain . The containers may be nested an arbitrary number of levels deep. There may be several containers under domain , and there may be several levels of nesting of containers within containers. One example of a container that may exist at some level under domain  is key management container , in which associations between keys and groups may be stored. Key management container  may be any number of levels in the hierarchy below domain , as indicated by the diagonal ellipsis connecting domain  to key management container .","The associations between groups and keys may be organized under key management container, such that each group has its own container within key management container . For example, structure  shows containers for two groups  and , although there could be any number groups, each represented by its own container. The data within the containers for groups  and  might not contain the data that defines the existence of the groups themselves. The groups may be defined elsewhere in the hierarchy under domain . However, given some groups whose existence and membership has been defined somewhere, the containers representing groups  and  contain the keys associated with those groups.","There are various ways to store the association between a set of keys and the group to which the keys belong. However, an example way to store this association is shown in . Under the container for group , there are objects representing keys  and the metadata  that applies to the keys. As noted above, each group may contain several keys (although at any given time, one of those key may be designated as the current key to use for new encryption of data). Thus, the objects for keys  are shown as a plurality of folders, where each folder may represent one key. Within each of the key objects, various types of information may be stored. For example, each key object may store the key value , which contains (or implies) the actual data that may be provided to an encryption algorithm in order to encrypt or decrypt data. Each key object may also contain expiration and\/or aging information . Information  may describe the expiration date of the key in some manner\u2014e.g., by stating the actual expiration date, by stating the date on which the key was created along with its longevity, or through some other kind of information. In addition to the key value  and information , each key object could also contain any other data that pertains to a particular key.","Metadata  may also be stored under the container for group , and may contain various information concerning keys , such as a policy governing the use of the keys. For example, metadata  may indicate which of keys  is the current key to use for new encryption jobs (e.g., metadata  may point to the particular key object that represents the current key, as indicated at ). Metadata  may also indicate the specific encryption algorithm to be used with a key. Any other type of information relating to the keys  for group  may be stored in metadata .","Although not shown, group  (or any other group for which a set of keys is stored) may have similar containers. Thus, group  may have its own set of keys, and its own metadata relating to those keys.","The foregoing discusses an example way of organizing data that relates to groups and their keys, but other ways of organizing the data are also possible. For example, metadata  and keys  are shown as being in different containers, but some or all of the metadata could be stored with the keys. Thus, instead of having metadata  that applies to all of the keys in group , there could be some \u201cper key\u201d metadata that applies to a specific key, and that metadata could be stored with the key. (E.g., the specific encryption algorithm that is to be used with a key is an example of metadata that might be applied on a per-key basis.) Additionally, key management container  could have a container for \u201cglobal\u201d metadata . Global metadata  might apply to all keys, unless overridden by some per-group or per-key metadata. (Or, in greater generality, there could be a rule that resolves which metadata applies when two or more of global, per-group, and\/or per-key metadata are present.)","Typically, the domain is administered by several different domain controllers, which maintain mirrored copies of the information for that domain. Thus, domain , and the various information organized under domain , may exist on a plurality of domain controllers. The domain controllers may synchronize with each other so that they converge on maintaining copies of the same information for the various domains (although the synchronization may not occur continuously, so there may be a period of time when an update made on one domain controller has not yet been synchronized to another domain controller). During synchronization, two domain controllers may compare their respective information, and each may send the other any new information (e.g., new keys, new metadata, new group memberships, etc.) that the other does not have.  shows an example system in which a domain is administered by a collection of domain controllers.","Domain controllers , , and  collectively administer a domain. Each domain controller may, for example, be a server machine. Domain controllers may be located in physically separate locations separated by some physical distance, and they may be communicatively connected to each other by a network; however, domain controllers could be located anywhere, in any relative proximity to each other. In one example, domain controllers that are distant from each other (e.g., one in North America, one in Africa) may synchronize less frequently than domain controllers that are near each other, and thus, the techniques described herein may be used to prevent excessive accumulation of keys in view of the infrequent synchronization of these distant domain controllers. Each of domain controllers - may have a copy of the information that relates to that domain. For example, each of domain controllers may keep a copy of structure  (shown in ), and of the information stored therein. An example of the kind of information that each domain controller may store is the keys for each group, and any policies or other metadata associated with those keys. Thus, copies keys and metadata (indicated by numeral ) may be stored in each of domain controllers -.","Domain controllers may synchronize with each other (as shown by numeral ) so that the domain controllers converge on having the same information as each other.  shows domain controllers  and  synchronizing with each other, and also shows domain controllers  and  synchronizing with each other, although any combination of domain controllers could synchronize with each other.","In order to participate in a domain, clients interact with the domain controllers. One aspect of replicated domain controllers is that a client can perform domain-related actions (e.g., logging in, accessing data that is managed by domain controllers, etc.) without regard to which domain controller the client interacts with. For example, , shows three clients , , and , which perform various types of interactions with domain controllers - (as indicated by the double-ended arrows connecting various combinations of clients - with domain controllers -). When a client is requesting services from the domain controller, the particular domain controller with which the client connects may be chosen based on various factors. For example, domain controllers - may be in physically separate locations, and which domain controller the client connects to may be based on where the client is located. For example, a company with offices in several cities might maintain a domain controller in each office. An employee may use his or her laptop (which is an example of a client) to access the company's network in any one of the offices, where accessing the company's network, in this example, may involve authenticating the client to the domain controller. The network may be configured so that the client communicates with the domain controller for the office in which the client is located at the time of the communication. As another example, several domain controllers may exist for a high-traffic domain in order to allow the load to be spread among them, in which case the particular domain controller with which the laptop communicates may be chosen based on a load-balancing algorithm. Thus, a given client might be communicating with any one of several domain controllers, depending on the different domain controllers' respective loads. When plural domain controllers exist, synchronization of the domain controllers allows the client to receive basically the same data and functionality from a domain controller, regardless of which domain controller the client accesses.","Clients that are members of a group may share encrypted data using techniques that are described herein. Domain controllers, as noted above, may associate a set of keys with a group, so that any member of the group may access those keys to encrypt and decrypt data. In the example of , clients - are all members of group . Domain controllers - store a set of keys for group , and are aware that clients - are members of group . Thus, upon receiving an appropriate request from any of clients -, any of domain controllers - may provide the requestor with the keys for group . Clients - might issue these requests through an application that wants to encrypt or decrypt data. For example, an E-mail application might maintain a group inbox that is accessible to any member of group . In order to secure incoming e-mail so that it can be read by members of group  but not by others, when the E-mail application receives new messages, it may contact one of domain controllers - to get the current encryption key for that group (or may use a local copy of a non-expired encryption key that the client stores). The E-mail application may then encrypt the messages and may store them in shared data store , which is accessible to any of clients -. All of clients -, in this example, have access to shared data store . So, when one of clients - wants to read the E-mail, it contacts one of domain controllers - and requests the keys (or may use a local copy of the keys, if the client has a local copy). The client may then retrieve the E-mail from shared data store  and may decrypt the E-mail using the key.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 4","FIG. 4","FIG. 4","FIG. 5","FIGS. 1-3","FIG. 1-3","FIGS. 4 and 5"]},"At , a client may contact a domain controller with a request to provide the set of keys for that group. If the client is not a member of the group (as determined at ), then the domain controller does not provide the keys to the client (at ). If the client is a member of the group, then at  the domain controller provides one or more keys for the group (e.g., the current key to be used for encryption, or possibly the full historical set of keys).","When the domain controller provides the key(s), it may provide various information along with the key(s). One example kind of information is the key value  (i.e., a representation of the value that may be provided as the key input to an encryption and\/or decryption process, or data from which that value may be derived). Another example of the information that may be provided is the encryption algorithm to be used with the key (block ). A policy that governs the key may specify that a particular encryption algorithm is to be used with the key, and an identification of this algorithm may be provided with the key at block . Another example of information that may be provided with the key is an indication of the expiration date of the key (block ). The expiration date itself could be explicitly provided, or aging information that implies the expiration date of the key could be provided. (One example of information that implies the expiration date of a key is the creation date of the key together with its longevity.)","As noted above, the domain controller may provide the current group key, or may provide the full historical set of the group's keys. To elaborate on this point, data may still exist that has been encrypted with old keys\u2014even currently expired keys\u2014and thus a client may still make use of an old key. Keys may expire in the sense that one key (the current key) may supersede the use of other keys for new encryption (including re-encryption of old data), but since old data may exist that were encrypted with keys that are no longer current, the old keys are kept so that they may be used to decrypt old data (although, as noted above, a policy might call for something other than retaining all keys\u2014e.g., a policy might call for the disposal of old keys as a mechanism of data destruction). Since the domain controller may not know whether a client that requests the key intends to use the key to encrypt new data or to decrypt old data, the domain controller may provide all of the existing keys for the group. The domain controller may provide, to a requesting client, an indication of which key is the current key (or the client may follow a rule to determine which key is the current key\u2014e.g., the client might infer that the key with the latest expiration date is the current key).","At , the key may be used to perform a tangible action. For example, an application may use the current key to encrypt data, or may use the current key (or one of the older keys) to decrypt data. Other examples of tangible actions that may be performed with keys include authentication, seeding a pseudo-random number genitor, or any other use of keys.","When domain controllers synchronize with each other, an issue may arise due to the interaction of the facts that (a) keys expire and have to be replaced with new keys, and (b) synchronization may happen intermittently. Clients encrypting data with the current key may monitor keys for expiration and\u2014if a key is nearing expiration\u2014the client may create a new key, which will replace the current key when the current key expires. (Clients might monitor keys for expiration, or, alternatively, might be triggered to evaluate whether to create a new key when a group's key is requested by a client.) But if all clients discover at the same time that the key is nearly expired, then all of the clients might create new keys on different domain controllers in response to this discovery, because each client may be connected to a different domain controller. The creation of new keys by several different clients does not result in a conflict, since\u2014after synchronization occurs\u2014a rule can be applied to determine which (if any) of the two keys in the current key. However, while there is no conflict between the keys, this situation tends to lead to the unnecessary accumulation of keys. Suppose that keys have a longevity of sixty days, and further suppose that two clients, one connected to domain controller A and the other connected to the domain controller B, create new keys on Jan. 1, 2009 on both of domain controllers A and B. Eventually these domain controllers will synchronize, at which point each will have both of the keys. The keys may be timestamped, so that clients that retrieve the keys from the domain controllers can determine, at some level of granularity, which key was created latest and, therefore, which key will ultimately replace the expiring key as the current key. However, if one client had been aware that the other was already creating a replacement for the expiring key, then one of the clients might have avoided creating its own new key. But once each client has created its own new key, the possibility cannot be ruled out that the each of the keys has been used for some encryption job, and thus both keys are stored indefinitely so they can be used to decrypt whatever data might have been encrypted with either key. The problem of key management may be simplified if only one client had created its own new key\u2014e.g., if the client connected to domain controller A created a key, and then that key had a chance to propagate to other domain controllers so that the other client could receive it and realize that the expiring key had already been updated. Techniques that are described below may be used to reduce the number of new keys created by multiple clients and stored by mirrored domain controllers, even in an environment where domain controllers synchronize intermittently.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 5","FIG. 5"],"b":"500"},"Process  makes use of the following values:","N: a number that defines the average number of days before expiration that clients create new keys. In one example, N defines this average number of days in the sense that each client creates a new key 2N days before the key expires, plus or minus some randomization quantity, which is described below. (In lieu of days, any unit that represents an amount of time may be used.)","D: an arbitrarily-chosen number in [\u2212N,N]. Each client has its own value of D, which causes variance between clients as to how many days prior to expiration they will create a new key. Thus, each client creates a new key 2N+D days before the current key expires, so different clients may create keys on different days as long as they have different values of D. (Different clients could share the same value of D although, typically, if there are a plurality of clients and domain controllers for a domain, at least two of them will have different values of D so that at least two clients would have different key-creation days.) In this sense, different values of D may be chosen for different clients, although the same value of N may be used for the various clients.","The value of N may be the same for to the full set of clients that administer a domain, while each client may have its own value of D (although it is possible that two or more clients could be assigned the same value of D). Thus, at the start of process , the value of N is pre-chosen.","At , a value is chosen for D for a given client. As noted above, D is in the range [\u2212N,N], so \u2212N\u2266D\u2266N.","At , the client chooses how many days before expiration of the current key it will create a new key. As noted above, a client may calculate this number of days as a function of N and D\u2014e.g., 2N+D. Thus, in the example of , the client determines that it will create a new key if the current key has T or fewer days until it expires, where T is equal to 2N+D. As noted above, different values of D may be chosen for different clients. Thus, in order to determine the number of days in advance of expiration that each client creates a key, a first and second values are chosen for the first and second clients, respectively, and a third value is chosen which applies to all clients. (Two different values of D are examples of the first and second values, and 2N is an example of the third value.) The amount of time before expiration to create a new key is calculated (for the first domain controller) by adding the first value and the third value, and (for the second client) by adding the second value and the third value. In this way, different instances of T may be calculated for different clients; the client with the lower value of T concludes, closer to the expiration of the current key, that a new key is to be created\u2014by which time a new key may already have been created by the client with the higher value of T.","At , it is determined whether the current key expires in T days or less. There are various triggers that could cause the client to make this determination. For example, the determination may be triggered by a client's receiving a group's key (e.g., , at ), or the client might self-trigger the determination by monitoring keys that it stores in order to determine if those keys are nearing expiration.","If there are more than T days remaining before expiration, then process  does not create a new key (at ).","On the other hand, if the current key does expire in T days or less, then (at ) process  enumerates the keys for the group (i.e., keys 1-n, where Kis the name of the key with the latest expiration date, and Tis the expiration date of K).","Once it has been determine which key (T) for a group has the latest expiration date, it is determined (at ) whether that expiration date is within T days of the current time (i.e., whether T\u2266now+T, where \u201cnow\u201d is the current time). If the process find that (as of the time that the finding is made) there is a key with at least T days ahead until expiration, then the process continues to  without creating a new key. Even though it was determined at  that the current key has T days or less until expiration, there might be a key that has more than T days until expiration. A key may be created somewhat earlier than the policy governing use of the group's keys designates that key as the current key. Thus, it might be the case that Kis the current key (expiring in T days or less), but that another client has already created key K, which is not yet the current key but is available to replace Kwhen Kexpires. (Creating a new key before designating that key as the current key gives the key time to propagate to other domain controllers before it is used to encrypt data. If a client contacts a domain controller that does not yet have the new key, then the client will not be able to decrypt any data that was encrypted with the new key. By giving the key time to propagate before it is used, the chance that this type of decryption failure will occur is reduced.)","If it is determined at  that the key with the latest expiration date has T days or less until expiration, then the process continues to , where a new key is created. If Kis the existing key with the latest expiration date, then the new key to be created may be referred to as key K, and it has expiration date T. The new key may be stored in the key container  for the group to which the key applies.","Once  is reached (either from  or from ), it is determined whether the current key has expired. If the current key has not expired, then, in this example, the current key is not changed (at ). If the current key has expired, then the policy governing the use of the group's key is changed to reflect that the current key is key K(at ). This policy update may be stored in key container .",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 6"},"Computer  includes one or more processors  and one or more data remembrance components . Processor(s)  are typically microprocessors, such as those found in a personal desktop or laptop computer, a server, a handheld computer, or another kind of computing device. Data remembrance component(s)  are components that are capable of storing data for either the short or long term. Examples of data remembrance component(s)  include hard disks, removable disks (including optical and magnetic disks), volatile and non-volatile random-access memory (RAM), read-only memory (ROM), flash memory, magnetic tape, etc. Data remembrance component(s) are examples of computer-readable storage media. Computer  may comprise, or be associated with, display , which may be a cathode ray tube (CRT) monitor, a liquid crystal display (LCD) monitor, or any other type of monitor.","Software may be stored in the data remembrance component(s) , and may execute on the one or more processor(s) . An example of such software is group key management and\/or update software , which may implement some or all of the functionality described above in connection with , although any type of software could be used. Software  may be implemented, for example, through one or more components, which may be components in a distributed system, separate files, separate functions, separate objects, separate lines of code, etc. A computer (such as a server computer, acting as a domain controller) in which a program is stored on hard disk, loaded into RAM, and executed on the computer's processor(s) typifies the scenario depicted in , although the subject matter described herein is not limited to this example.","The subject matter described herein can be implemented as software that is stored in one or more of the data remembrance component(s)  and that executes on one or more of the processor(s) . As another example, the subject matter can be implemented as instructions that are stored on one or more computer-readable storage media. Such instructions, when executed by a computer or other machine, may cause the computer or other machine to perform one or more acts of a method. The instructions to perform the acts could be stored on one medium, or could be spread out across plural media, so that the instructions might appear collectively on the one or more computer-readable storage media, regardless of whether all of the instructions happen to be on the same medium.","Additionally, any acts described herein (whether or not shown in a diagram) may be performed by a processor (e.g., one or more of processors ) as part of a method. Thus, if the acts A, B, and C are described herein, then a method may be performed that comprises the acts of A, B, and C. Moreover, if the acts of A, B, and C are described herein, then a method may be performed that comprises using a processor to perform the acts of A, B, and C.","In one example environment, computer  may be communicatively connected to one or more other devices through network . Computer , which may be similar in structure to computer , is an example of a device that can be connected to computer , although other types of devices may also be so connected. Various devices (e.g., domain controllers -, shown in ) may communicate with each other over a network. The network may thus provide a mechanism through which synchronization is performed.","Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather, the specific features and acts described above are disclosed as example forms of implementing the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
