---
title: Incremental generation of managed assemblies
abstract: Concepts and technologies are described herein for incremental generation of managed assemblies. In accordance with some of the concepts and technologies disclosed herein, a compiler incrementally generates a managed assembly thereby facilitating a rapid application development environment in which changes to the assembly require recompilation of only a changed portion of the assembly instead of recompilation of the entire assembly.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08914780&OS=08914780&RS=08914780
owner: Microsoft Corporation
number: 08914780
owner_city: Redmond
owner_country: US
publication_date: 20110304
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The .NET framework is a common language infrastructure (CLI) framework that provides the compile time and run-time functions to build and run applications written in languages that conform to the common language specification (CLS). The .NET framework consists of two core components, a common language runtime (CLR) and a framework class library (FCL). The CLR is the execution environment of the .NET framework. The CLR provides a language-independent layer of abstraction between CLS-compliant programming languages and an operating system (OS) with a primary function of just-in-time (JIT) compilation of common intermediate language (CIL) code generated by a CLS-compliant language compiler into native code to the OS. During execution of an application, the CLR is responsible for memory management, thread execution, garbage collection, exception handling, common type system definition, code safety verification, and other system services. The FCL is a library of language-independent and type-safe reusable classes, interfaces, and value types that expedite and optimize the development process and provide access to system functionality.","Source code written in a CLS-compliant programming language is compiled into CIL code as a collection of types and resources called an assembly. Each assembly contains an assembly manifest and portable executable (PE) code. The assemblies can include one or more program files. The program files may be executable files stored in a PE file format as either process assemblies (.exe) or library assemblies (.dll). The PE code of an assembly may be stored in one or more code modules (e.g., net modules). In this case, the net module(s) are associated with an assembly manifest in an assembly to be executed by a JIT compiler. The assembly manifest contains a set of metadata with information that describes the assembly and its contents and may itself be stored in a PE file.",".NET assemblies are an immutable logical unit for managed languages such as C#, VB.NET, and C++\/CLI. If there is a change to source code, the entire source code needs to be recompiled to recreate the assembly. Recompilation is suitable when an assembly is small, or when build time is not an issue. However, for scenarios in which rapid application development is important and small changes are required to be quickly compiled (e.g., for testing purposes), the inability to incrementally generate assemblies results in reduced developer productivity.","It is with respect to these and other considerations that the disclosure made herein is presented.","Concepts and technologies are described herein for incremental generation of managed assemblies. In accordance with the concepts and technologies disclosed herein, a compiler incrementally generates a managed assembly thereby facilitating a rapid application development environment in which changes to the assembly require recompilation of only the changed portion of the assembly instead of recompilation of the entire assembly.","According to one aspect, a compiler generates an assembly including an assembly manifest and a plurality of code modules, each of which contains common intermediate language (CIL) code. If a type change occurs within the CIL code of any of the plurality of code modules, the compiler regenerates the code module in which the type change occurred to form a regenerated code module. The regenerated code module includes regenerated CIL code that replaces at least a portion of the CIL code of the code module. The compiler generates a temporary assembly including the regenerated code module. The compiler replaces the code module of the assembly with the regenerated code module of the temporary assembly and regenerates the assembly manifest.","According to another aspect, the compiler generates a master assembly comprising a plurality of types. If the compiled code introduces one or more changes to an existing type, the compiler generates a new assembly including a changed type reflecting the type change to the type. The compiler then replaces the type in the master assembly with the changed type from the new assembly.","According to yet another aspect, the compiler compiles source code written in a managed programming language into CIL code and metadata thereby generating an assembly. The assembly includes a dynamic-linked library (.dll) file containing an assembly manifest including metadata about the assembly and a plurality of code module files, each of which includes a portion of the CIL code. The plurality of code module files may be stored, for example, in a .netmodule file format. The assembly is represented in a first location of a file system.","If a type change occurs within one or more of the .netmodule files, the compiler regenerates the .netmodule file within which the type change was detected thereby forming a regenerated .netmodule file. The compiler generates a temporary assembly including the regenerated .netmodule file. The temporary assembly is represented in a second location of the file system. The compiler then copies the regenerated .netmodule file from the second location of the file system and replaces the .netmodule file in the first location of the file system with the regenerated .netmodule file copied from the second location of the file system. The compiler regenerates the .dll file containing the assembly manifest.","It should be appreciated that the above-described subject matter may be implemented as a computer-controlled apparatus, a computer process, a computing system, or as an article of manufacture such as a computer-readable storage medium. These and various other features will be apparent from a reading of the following Detailed Description and a review of the associated drawings.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended that this Summary be used to limit the scope of the claimed subject matter. Furthermore, the claimed subject matter is not limited to implementations that solve any or all disadvantages noted in any part of this disclosure.","The following detailed description is directed to concepts and technologies for incremental generation of managed assemblies. According to one aspect of the concepts and technologies described herein, a compiler generates an assembly including an assembly manifest and a plurality of code modules. If a type change occurs within the code of any of the plurality of code modules, the compiler regenerates the code module in which the type change occurred to form a regenerated code module. The regenerated code module includes regenerated CIL code that replaces at least a portion of the CIL code of the code module. The compiler generates a temporary assembly including the regenerated code module. The compiler then replaces the code module of the assembly with the regenerated code module of the temporary assembly and regenerates the assembly manifest.","According to another aspect of the concepts and technologies described herein, a compiler generates a master assembly comprising a plurality of types. If a type change occurs to a type, the compiler generates a new assembly including a changed type reflecting the type change to the type. The compiler then replaces the type in the master assembly with the changed type from the new assembly.","While the subject matter described herein is presented in the general context of program modules that execute in conjunction with the execution of an operating system and application programs on a computer system, those skilled in the art will recognize that other implementations may be performed in combination with other types of program modules. Generally, program modules include routines, programs, components, data structures, and other types of structures that perform particular tasks or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the subject matter described herein may be practiced with other computer system configurations, including hand-held devices, multiprocessor systems, microprocessor-based or programmable consumer electronics, minicomputers, mainframe computers, and the like.","In the following detailed description, references are made to the accompanying drawings that form a part hereof, and in which are shown by way of illustration specific embodiments or examples. Referring now to the drawings, in which like numerals represent like elements throughout the several figures, aspects of a computing system, computer-readable storage medium, and computer-implemented methodology for incremental generation of managed assemblies will be presented.","Referring now to , aspects of one operating environment  for various embodiments presented herein will be described. The operating environment  of  is illustrated and described in context of a software development framework, such as MICROSOFT .NET framework from Microsoft Corporation in Redmond, Wash., that provides compile time and runtime operations to build and execute software applications written in languages that conform to the common language specification (CLS). Although various aspects are disclosed in this particular context, those skilled in the art will appreciate the applicability of many of the disclosed aspects to other software development frameworks that function in a manner similar to the .NET framework or rely on concepts and\/or technologies that are similar to those embodied by the .NET framework. Moreover, the various aspects disclosed herein are applicable to any compiler that generates intermediate language (IL) code including, but not limited to, common intermediate language (CIL) code, that is executable by a language-independent runtime environment.","The operating environment  shown in  illustrates software components of a computing system for performing compile time functions to facilitate incremental generation of managed assemblies and runtime operations to execute the assemblies. The illustrated operating environment  includes source code  written in one or more source programming languages including, but not limited to, VB.NET, C#, C++\/CLI, and X++. The source code  is provided as input to one or more compilers  (hereinafter, \u201ccompiler\u201d). The compiler  is configured to read a software program written in the source code  and translate it into CIL code as a collection of files and metadata called an assembly for execution via a language-independent runtime environment provided by the .NET framework, as described in greater detail below.","The compiler  is logically divided into a front end  and a back end . The front end  includes a scanner  and a parser . The back end  includes a code generator . The scanner  receives the source code  as a character stream which it breaks down into groups of characters called tokens that are consumable by the parser . The parser  analyzes the tokens for proper syntax and builds a data structure, such as an abstract syntax tree (AST) or other abstract syntactic structure of the source code . The code generator  receives the AST from the parser  and converts and converts it into CIL code as an executable assembly . It should be understood that the compiler  may take multiple passes over the data structure before generating the CIL code. The code generator  uses libraries ,  provided by the Common Compiler Infrastructure (CCI) framework and the .NET framework, respectively, to generate and modify assembly code and metadata to facilitate incremental generation of the assembly  if changes occur to code within the assembly . Other libraries, such as the open source library CECIL, from the MONO PROJECT sponsored by NOVELL CORPORATION, could be utilized as an alternative or in addition to the CCI framework libraries. The CCI  and the .NET framework class library (FCL)  are described in greater detail below with reference to .","The assembly  contains an assembly manifest  and a plurality of code modules (module. . . module, where n is an integer) , . The assembly manifest  includes metadata about the assembly  including a description of the relationships and dependencies among the code modules , . In some embodiments, the assembly manifest  is stored in a portable executable (PE) file format as a library assembly in a dynamic-link library (.dll) file. The code modules ,  include CIL code compiled from the source code . The code module ,  are stored in individual files which, in some embodiments, are in a .netmodule file format.","The assembly  is executable by a common language runtime (CLR)  of the .NET framework. The CLR  functions like a virtual machine using a just-in-time (JIT) compiler  to convert the CIL code of the assembly  into native code  useable by the particular machine upon which the assembly  is executing. During execution of the assembly , the CLR  is responsible for memory management, thread execution, garbage collection, exception handling, common type system definition, code safety verification, and other system services.","If during development of the assembly , code within one or more of the code modules ,  is changed (e.g., by a developer), the code generator  can generate a temporary assembly  with new code modules (module. . . module, where n is an integer) ,  using the same filenames as the old code modules ,  from the assembly . The new code modules ,  include new CIL code replacing the code that changed within the code modules , . In some embodiments, the changed code is associated with a particular type used in the assembly . As used herein, a \u201ctype\u201d broadly refers to a set of values and the allowable operations on those values.","In the illustrated embodiment, the temporary assembly  also includes a temporary assembly manifest  that is regenerated by the compiler  using the CCI . In various embodiments, the compiler  also generates a debugging file, such as a program database (PDB) file, that includes debugging and project state information collectively for all code modules , , or individually for each code module ,  within the assembly .","Turning now to , aspects of another operating environment  for various embodiments presented herein will be described. The operating environment  includes many of the same software components illustrated and described above with reference to the operating environment  of . In particular, the operating environment  includes the compiler , the associated front end  and back end  components including the scanner , the parser , and the code generator , the CCI , the FCL , the CLR , and the JIT compiler .","In the operating environment , the code generator  receives the AST from the parser  and converts it into CIL code as the executable assembly . The code generator  uses the CCI  and the .NET FCL  to generate and modify assembly code and metadata to facilitate incremental generation of the assembly  if changes occur to code within the assembly .","The assembly  as illustrated includes a single PE file (e.g., a .dll file) containing all types  referenced in the assembly  and an assembly manifest . Although the illustrated embodiment references exemplary types, Type_A through Type_Z including up to twenty-six types, the types  may include any number of types. The assembly manifest  includes metadata about the assembly  including a description of the relationships and dependencies among the types . The assembly  is executable by the CLR . The CLR  uses the JIT compiler  to convert the CIL code of the assembly  into native code  useable by the particular machine upon which the assembly  is executing.","If during development of the assembly , a developer changes one or more of the types , the code generator  generates a temporary assembly  including only the changed types. In the illustrated embodiment, TYPE_A and TYPE_B have been changed in the assembly  and, accordingly, changed TYPE_A and changed TYPE_B, collectively changed types , are included in the temporary assembly . In some embodiments, one or more of the changed types  references one or more of the types  included in the assembly . For example, TYPE_A of the changed types  may reference TYPE_C of the types , and\/or TYPE_B of the changed types  may reference TYPE_D of the types . In any case, the code generator  uses the CCI  to replace TYPE_A and TYPE_B of the types  with TYPE_A and TYPE_B of the changed types . In some embodiments, any debugging files (e.g., PDBs) may also be modified and replaced in accordance with the type change.","Turning now to , aspects of a data structure  of exemplary libraries and classes used by the code generator  of the compiler  to incrementally generate a managed assembly for various embodiments presented herein will be described. As referenced above in the description of , the code generator  uses the CCI  and the FCL  to generate and modify assembly code and metadata to facilitate incremental generation of an assembly if changes occur to code (e.g., changes to types) within that assembly.","The FCL  is a library of classes, interfaces, and value types that provides access to system functionality and is designed as the foundational library upon which .NET framework applications, components, and controls are built. The FCL  provides a plurality of namespaces, each of which contains one or more classes, structures, interfaces, delegates, and\/or enumerations. For the embodiments disclosed herein, the code generator  relies on at least one such namespace called the System.Reflection.Emit namespace  to emit metadata and CIL code of the assemblies , , , , and others, described herein.","The System.Reflection.Emit namespace  as illustrated includes an AssemblyBuilder class , a ModuleBuilder class , a TypeBuilder class , a MethodBuilder class , a LocalBuilder class , an ILGenerator class , and an OpCodes class . The AssemblyBuilder class  includes various members for defining and representing an assembly. The ModuleBuilder class  includes various members for defining and representing modules within an assembly. The TypeBuilder class  includes various members for defining and generating new instances of classes during runtime. The MethodBuilder class  includes various members for defining and representing a method in a dynamic class. The LocalBuilder class  includes various members for representing a local variable within a method. The ILGenerator class  includes various members for generating CIL code. The OpCodes class  provides field representations of the CIL instructions for emission by the ILGenerator class  members. Although only the above classes are illustrated and described, the System.Reflection.Emit namespace  includes other classes that may or may not be relied upon by the compiler  to generate and\/or modify the assemblies , , , , and others, described herein.","The CCI  includes libraries and application programming interfaces (APIs) that can be used by the compiler  to perform incremental generation of assemblies. The CCI  supports interaction with PE files, such as assemblies and discrete code modules (e.g., the code modules ,  of ), and debugging files, such as PDBs. For the embodiments described herein, the CCI  is used as a rewriting tool to replace existing code within an assembly with modified code from a temporary assembly in accordance with the various embodiments presented herein.","The CCI  as illustrated includes a CCI metadata API  and a CCI code API . The compiler  can use the CCI metadata API  to modify metadata associated with an assembly, such as metadata included in an assembly manifest. The compiler  can use the CCI metadata API  and\/or the CCI code API  to modify CIL code of an assembly. In various embodiments, the compiler  also uses the CCI  in combination with the FCL  (particularly the ILGenerator class ) to generate CIL code of an assembly.","Turning now to , aspects of a method  for incrementally generating an assembly will be described in detail. It should be understood that the operations of the methods disclosed herein are not necessarily presented in any particular order and that performance of some or all of the operations in an alternative order(s) is possible and is contemplated. The operations have been presented in the demonstrated order for ease of description and illustration. Operations may be added, omitted, and\/or performed simultaneously, without departing from the scope of the appended claims.","It also should be understood that the illustrated methods can be ended at any time and need not be performed in their respective entireties. Some or all operations of the methods, and\/or substantially equivalent operations, can be performed by execution of computer-readable instructions included on a computer-storage media, as defined below. The term \u201ccomputer-readable instructions,\u201d and variants thereof, as used in the description and claims, is used expansively herein to include routines, applications, application modules, program modules, programs, components, data structures, algorithms, and the like. Computer-readable instructions can be implemented on various system configurations, including single-processor or multiprocessor systems, minicomputers, mainframe computers, personal computers, hand-held computing devices, processor-based, programmable consumer electronics, combinations thereof, and the like.","Thus, it should be appreciated that the logical operations described herein are implemented (1) as a sequence of computer-implemented acts or program modules running on a computing system and\/or (2) as interconnected machine logic circuits or circuit modules within the computing system. The implementation is a matter of choice dependent on the performance and other requirements of the computing system. Accordingly, the logical operations described herein are referred to variously as states, operations, structural devices, acts, or modules. These operations, structural devices, acts, and modules may be implemented in software, in firmware, in special purpose digital logic, and any combination thereof.","For purposes of illustrating and describing the concepts of the present disclosure, the methods disclosed herein are described as being performed by the compiler  and, in some instances, more particularly the code generator . It should be understood that these embodiments are exemplary, and should not be viewed as being limiting in any way. The method  is now described with reference to  and to  for further ease of description and illustration.","The method  begins at operation , wherein the compiler  generates an assembly  including an assembly manifest  and a plurality of code modules , , , , , . The assembly manifest  as illustrated is a single .dll file including metadata that describes the assembly  and the plurality of code modules , , , , ,  included in the assembly . The plurality of code modules , , , , ,  each include CIL code generated by the code generator . In the illustrated embodiment, this CIL code is stored in .netmodule files within the assembly, although other file types are contemplated. The plurality of code modules , , , , ,  may each be associated with a debugging file, illustrated as PDB files , , , , , , respectively.","From operation , the method  proceeds to operation , wherein the compiler  detects a type change within a particular code module  of the plurality of code modules , , , , , , . The type change may be detected, for example, when a developer recompiles code after making a modification to the particular code module . Although operation  describes the detection of a type change within a body of code, it is contemplated that the detected change may be any change to code that would traditionally require recompilation of the entire assembly .","From operation , the method  proceeds to operation , wherein the compiler  regenerates the particular code module  to form a regenerated code module  including new code reflecting the type change. In some embodiments, the particular code module  and the regenerated code module  are saved in different locations within a file system using the same filename. For example, in the illustrated embodiment, the particular code module  is stored in a first location of the file system under the exemplary filename, \u201cApplication.dll3.netmodule.\u201d Likewise, the regenerated code module  is stored in a second location of the file system under the same filename. The second location is illustrated as being within a \u201cTemp\\\u201d directory within the file system. Alternative filename and directory naming conventions are contemplated.","From operation , the method  proceeds to operation , wherein the compiler  generates a temporary assembly  including the regenerated code module . From operation , the method  proceeds to operation , wherein the compiler  replaces the particular code module  of the assembly  with the regenerated code module  from the temporary assembly . For example, the compiler  may copy the regenerated code module  from the temporary assembly  and replace the particular code module  of the assembly , as shown in the illustrated embodiment.","From operation , the method  proceeds to operation , wherein the compiler  regenerates the assembly manifest . In one embodiment, the compiler  replaces the assembly manifest  with a regenerated assembly manifest  of the temporary assembly . In this embodiment, the regenerated assembly manifest  may be generated including metadata associated with all code modules of the assembly  except the particular code module  and metadata associated with the regenerated code module . In another embodiment, the compiler  regenerates the assembly manifest  during recompilation when the particular code module  is replaced with the regenerated code module . In this embodiment, the regenerated assembly manifest  may include metadata only associated with the regenerated code module  which is then used in part to regenerate the assembly manifest . Alternatively, dummy metadata may be used as a placeholder for the temporary assembly . From operation , the method  proceeds to operation . The method  ends at operation .","Turning now to , aspects of a method  for incrementally generating an assembly will be described in detail. The method  begins at operation , wherein the compiler  generates a master assembly  including a plurality of types , , , . From operation , the method  proceeds to operation , wherein the compiler  detects a type change to one or more of the plurality of types , , , . The type change may be detected, for example, when a developer recompiles code after making a modification to one or more of the plurality of types , , , . Although the illustrated embodiment references exemplary types, TYPE_A through TYPE_C and TYPE_Z, any number of types may be included in the master assembly .","From operation , the method  proceeds to operation , wherein the compiler  generates a new assembly  including changed types, TYPE_B  and TYPE_C . Each changed type may reference one or more types from the master assembly  or include no references to any types from the master assembly  based upon the dependencies between changed types and original types. In the illustrated embodiment, TYPE_B  references TYPE_A  from the master assembly  and TYPE_B  references TYPE_Z  from the master assembly .","From operation , the method  proceeds to operation , wherein the compiler  replaces TYPE_B  and TYPE_C _in the master assembly  with changed types TYPE_B  and TYPE_C  from the new assembly . From operation , the method  proceeds to operation . The method  ends at operation .",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 8","FIG. 8"],"b":["800","800","800"]},"The computer architecture  illustrated in  includes a central processing unit  (\u201cCPU\u201d), a system memory , including a random access memory  (\u201cRAM\u201d) and a read-only memory (\u201cROM\u201d) , and a system bus  that couples the memory  to the CPU . A basic input\/output system containing the basic routines that help to transfer information between elements within the computer architecture , such as during startup, is stored in the ROM . The computer architecture  further includes a mass storage device  for storing an operating system , the CCI , the FCL , the CLR , and the compiler .","The mass storage device  is connected to the CPU  through a mass storage controller (not shown) connected to the bus . The mass storage device  and its associated computer-readable media provide non-volatile storage for the computer architecture . Although the description of computer-readable media contained herein refers to a mass storage device, such as a hard disk or CD-ROM drive, it should be appreciated by those skilled in the art that computer-readable media can be any available computer storage media or communication media that can be accessed by the computer architecture .","Communication media includes computer readable instructions, data structures, program modules, or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics changed or set in a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared, and other wireless media. Combinations of the any of the above should also be included within the scope of computer-readable media.","By way of example, and not limitation, computer storage media may include volatile and non-volatile, removable and non-removable media implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules, or other data. For example, computer media includes, but is not limited to, RAM, ROM, EPROM, EEPROM, flash memory or other solid state memory technology, CD-ROM, digital versatile disks (\u201cDVD\u201d), HD-DVD, BLU-RAY, or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by the computer architecture . For purposes of the claims, the phrase \u201ccomputer storage medium\u201d and variations thereof, does not include waves, signals, and\/or other transitory and\/or intangible communication media, per se.","According to various embodiments, the computer architecture  may operate in a networked environment using logical connections to remote computers through a network such as the network . The computer architecture  may connect to the network  through a network interface unit  connected to the bus . It should be appreciated that the network interface unit  also may be utilized to connect to other types of networks and remote computer systems. The computer architecture  also may include an input\/output controller  for receiving and processing input from a number of other devices, including a keyboard, mouse, electronic stylus, or other input device (not shown in ). Similarly, the input\/output controller  may provide output to a display screen, a printer, or other type of output device (also not shown in ).","It should be appreciated that the software components described herein may, when loaded into the CPU  and executed, transform the CPU  and the overall computer architecture  from a general-purpose computing system into a special-purpose computing system customized to facilitate the functionality presented herein. The CPU  may be constructed from any number of transistors or other discrete circuit elements, which may individually or collectively assume any number of states. More specifically, the CPU  may operate as a finite-state machine, in response to executable instructions contained within the software modules disclosed herein. These computer-executable instructions may transform the CPU  by specifying how the CPU  transitions between states, thereby transforming the transistors or other discrete hardware elements constituting the CPU .","Encoding the software modules presented herein also may transform the physical structure of the computer-readable media presented herein. The specific transformation of physical structure may depend on various factors, in different implementations of this description. Examples of such factors may include, but are not limited to, the technology used to implement the computer-readable media, whether the computer-readable media is characterized as primary or secondary storage, and the like. For example, if the computer-readable media is implemented as semiconductor-based memory, the software disclosed herein may be encoded on the computer-readable media by transforming the physical state of the semiconductor memory. For example, the software may transform the state of transistors, capacitors, or other discrete circuit elements constituting the semiconductor memory. The software also may transform the physical state of such components in order to store data thereupon.","As another example, the computer-readable media disclosed herein may be implemented using magnetic or optical technology. In such implementations, the software presented herein may transform the physical state of magnetic or optical media, when the software is encoded therein. These transformations may include altering the magnetic characteristics of particular locations within given magnetic media. These transformations also may include altering the physical features or characteristics of particular locations within given optical media, to change the optical characteristics of those locations. Other transformations of physical media are possible without departing from the scope and spirit of the present description, with the foregoing examples provided only to facilitate this discussion.","In light of the above, it should be appreciated that many types of physical transformations take place in the computer architecture  in order to store and execute the software components presented herein. It also should be appreciated that the computer architecture  may include other types of computing devices, including hand-held computers, embedded computer systems, personal digital assistants, and other types of computing devices known to those skilled in the art. It is also contemplated that the computer architecture  may not include all of the components shown in , may include other components that are not explicitly shown in , or may utilize an architecture completely different than that shown in .","Based on the foregoing, it should be appreciated that technologies for incremental generation of managed assemblies have been disclosed herein. Although the subject matter presented herein has been described in language specific to computer structural features, methodological and transformative acts, specific computing machinery, and computer readable media, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features, acts, or media described herein. Rather, the specific features, acts and mediums are disclosed as example forms of implementing the claims.","The subject matter described above is provided by way of illustration only and should not be construed as limiting. Various modifications and changes may be made to the subject matter described herein without following the example embodiments and applications illustrated and described, and without departing from the true spirit and scope of the present invention, which is set forth in the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
