---
title: Concurrency object classification
abstract: A method of automatically classifying a concurrency object includes intercepting a call that is configured to create the concurrency object. Concurrency type information for the concurrency object is identified based on the call. The type information indicates whether the concurrency object is a lock object or a synchronization object. The concurrency type information is associated with the concurrency object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08135690&OS=08135690&RS=08135690
owner: Microsoft Corporation
number: 08135690
owner_city: Redmond
owner_country: US
publication_date: 20090105
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["A large number of applications today are multi-threaded. Multi-threading allows the execution of a particular application or program to be divided into two or more separate threads. Each of these threads may then be executed in parallel on a multi-processor, or multi-core system. However, the use of multi-threading in multi-processor or multi-core settings increases the possibility and probability of concurrency errors, such as race conditions.","In a multithreaded program, a data race condition occurs when a shared memory location is accessed by two or more concurrent threads, with at least one of the accesses being a write, without proper synchronization to constrain the ordering of the accesses. The effects of the execution in such a case depend on the particular order in which the accesses take place. Race conditions often result in unexpected and undesirable program behavior, such as program crashes or incorrect results.","Some data race detection solutions monitor lock acquisition, synchronization operations, and memory accesses, computing an access pattern for each memory location and memory access. These solutions then analyze the access to memory location patterns to detect suspicious access patterns that may indicate a potential data race. An access pattern may be considered to be \u201csuspicious\u201d if a memory location is shared among multiple threads without a common lock that may be used by individual threads\/programs to govern access to the memory locations.","This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","It is useful for a race detection algorithm to know the kind or type of concurrency (e.g., locking versus synchronization) of a concurrency object. In some cases, the type of concurrency may be determined based on the specific application programming interface (API) being invoked, but in cases where the same API is used for both of these kinds of concurrency, the determination of the kind of concurrency can be more difficult.","One embodiment automatically classifies concurrency objects for a race detection process. In one embodiment, the classification of a concurrency object includes intercepting an API call that creates the concurrency object. Concurrency type information for the concurrency object is identified based on the call. The type information indicates whether the concurrency object is a lock object or a synchronization object. The concurrency type information is associated with the concurrency object. A race detection process is performed using the concurrency type information.","In the following Detailed Description, reference is made to the accompanying drawings, which form a part hereof, and in which is shown by way of illustration specific embodiments in which the invention may be practiced. It is to be understood that other embodiments may be utilized and structural or logical changes may be made without departing from the scope of the present invention. The following detailed description, therefore, is not to be taken in a limiting sense, and the scope of the present invention is defined by the appended claims.","One embodiment provides an application that classifies concurrency objects, but the technologies and techniques described herein also serve other purposes in addition to these.","A \u201cconcurrency object\u201d according to one embodiment refers to any object that is used to control concurrent executions, including lock objects and synchronization objects. A \u201csynchronization object\u201d according to one embodiment refers to an object that is used to enforce an ordering relationship between two execution contexts (e.g., threads). Examples of synchronization objects according to one embodiment are thread handles, condition variables, timers, and events (e.g., CreateThread, CreateSemaphore, CreateEvent, WakeConditionVariable, SetEvent, SetWaitableTimer). A \u201clock object\u201d according to one embodiment refers to an object that is used to enforce a locking protocol, without a specific ordering constraint (i.e., the lock may be acquired\/released in arbitrary order by the execution contexts). Examples of lock objects according to one embodiment are Mutex and CriticalSection (e.g., EnterCriticalSection and AcquireSRWLock are API invocations for acquiring a lock; and LeaveCriticalSection, ReleaseMutex, SleepConditionVariableCS, ReleaseSRWLock are API invocations for releasing a lock).","As mentioned above, in some cases, the specific API being invoked is sufficient to determine the kind or type of concurrency (e.g., locking versus synchronization), but in cases where the same API is used for both of these kinds of concurrency, the determination of the kind of concurrency can be more difficult. For example, a Wait API (e.g., WaitForSingleObject or WaitForMultipleObjects) may be used either to acquire a lock or to synchronize, and in the API, there is not a way to tell which one it is. When a Wait API is called, a handle to the concurrency object being waited on is provided. However, in the Windows operating system, the handle is opaque, so it cannot be determined from the handle whether the concurrency object is a lock object or synchronization object. The Wait API can map to a lock acquire when the object is a lock, or can establish a \u201chappens before\u201d relationship when the object is a synchronization object such as a thread. A \u201chappens before\u201d relationship is characterized by a synchronization event indicating an ordering between threads. Thus, the Wait API may be considered to be an \u201cambiguous\u201d Wait, since the type of concurrency for the Wait cannot be determined from the API.","One embodiment intercepts API calls that create concurrency objects and records, per object, concurrency object type information indicating whether the object is a synchronization object or a lock object, thereby classifying concurrency objects into two types. In one embodiment, the type of a concurrency object (e.g., synchronization or lock) is determined based on the API call used to create the object. In one embodiment, a shadow heap is used to store usage information for concurrency objects, and is also used to store the concurrency object type information. In one embodiment, each object being tracked has at least one associated 32-bit word of shadow memory, and two bits of this word are used to indicate the concurrency object type of the object.","When an ambiguous reference is later made to a concurrency object, such as waiting on the object using a Wait API call that does not identify whether the concurrency object is a synchronization object or a lock object, the recorded type information allows the system to distinguish between synchronization and lock objects. In the case where the ambiguous call is made before the recording of the type information, the object is assumed to be a lock object in one embodiment. This may happen in two cases: 1) If the developer is using a function pointer to call the creation API, the interception may not occur; or 2) if a new synchronization object creation API is introduced, the interception may not occur.","In one embodiment, a monitoring dynamic link library (DLL) is attached to the application being examined. When that DLL is loaded into a thread context, the Windows concurrency API's are intercepted to custom versions of those routines so that any usage made of the API's by routines on the thread can be examined. These custom routines take the appropriate action for the concurrency object that is either being created or passed. When the API being invoked creates a concurrency object of a specific type (e.g., synchronization or lock) that information is recorded, and associated with the address of the object. In one embodiment, when the API maps unambiguously to a lock acquire\/release semantic, the object type is a lock; otherwise the recorded type is used to make that discrimination.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["100","100","102","104","104"]},"Computing device  may also have additional features\/functionality. For example, computing device  may also include additional storage (removable and\/or non-removable) including, but not limited to, magnetic or optical disks or tape. Such additional storage is illustrated in  by removable storage  and non-removable storage . Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any suitable method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Memory , removable storage  and non-removable storage  are all examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium that can be used to store the desired information and that can be accessed by computing device . Any such computer storage media may be part of computing device .","Computing device  includes one or more communication connections  that allow computing device  to communicate with other computers\/applications . Computing device  may also include input device(s) , such as keyboard, pointing device (e.g., mouse), pen, voice input device, touch input device, etc. Computing device  may also include output device(s) , such as a display, speakers, printer, etc.","In one embodiment, computing device  includes APIs for locking and synchronization , and concurrency object classification application . In one embodiment, APIs  include logic for waiting on concurrency objects. Concurrency object classification application  is described in further detail below with reference to .",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 2","FIG. 1","FIG. 1"],"b":["200","100","200","100","200","200","104","115"]},"Concurrency object classification application  includes program logic , which is responsible for carrying out some or all of the techniques described herein. Program logic  includes logic  for intercepting application programming interface (API) calls; logic  for identifying concurrency type information for concurrency objects, wherein the type information indicates whether a concurrency object is a lock object or a synchronization object; logic  for associating concurrency type information with a concurrency object by storing the concurrency type information in a shadow data structure associated with the concurrency object; logic  for examining stored concurrency type information associated with a concurrency object to determine the concurrency type of the concurrency object; race detection logic  for detecting race conditions; and other logic  for operating the application.","Turning now to , techniques for implementing one or more embodiments of concurrency object classification application  are described in further detail. In some implementations, the techniques illustrated in  are at least partially implemented in the operating logic of computing device .",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3","b":["300","300","302","300","304","306","308","310","312"]},"In one embodiment, the concurrency object in method  is configured to control concurrent executions. In one embodiment of method , an indication that the concurrency object is a lock object indicates that the concurrency object is configured to enforce a locking protocol without a specific ordering constraint, and an indication that the concurrency object is a synchronization object indicates that the concurrency object is configured to enforce an ordering relationship between two execution contexts.","In one embodiment of method , the concurrency type information is associated with the concurrency object at  by storing the concurrency type information in a shadow data structure associated with the concurrency object. In one embodiment, the shadow data structure comprises a 32-bit shadow data word that includes usage information for the concurrency object, and wherein the concurrency type information is represented by two or less bits of the shadow data word.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 4","FIG. 4"],"b":["400","414"]},"At  in method , a synchronization object creation API is called to create a concurrency object of the synchronization type. At , the API call at  is intercepted, and the object type is recorded as a synchronization type object. In one embodiment, the object type is stored in a shadow data word associated with the object. At , the object is identified as a \u201chappens before\u201d event, and this information is provided to race detection algorithm . In one embodiment, the race detection algorithm  is a Microsoft RaceTrack\u2122 application from Microsoft Corporation, which uses a hybrid version of lockset and threadset algorithms to detect potential race conditions. In one embodiment, the race detection algorithm  detects concurrent accesses and identifies potential race conditions. An object is identified as being involved in a race in one embodiment if there is no happens before relationship, and there is no common lock. In one embodiment, concurrent references to a shared memory location will trigger a race condition unless one of the following conditions holds: (1) the memory location is protected by a lock object; or (2) the sequence of accesses from each of the threads is deterministically ordered (i.e., synchronized).","At , a lock object creation, acquisition, or release API is called to create, acquire, or release a concurrency object of the lock type. At , the API call at  is intercepted, and the object type is recorded as a lock type object. In one embodiment, the object type is stored in a shadow data word associated with the object. At , the object is identified as a lock create, acquire, or release event, and this information is provided to race detection algorithm .","At , an \u201cambiguous\u201d Wait API is called to wait on a concurrency object. The Wait API at  is referred to as \u201cambiguous\u201d according to one embodiment because the type of concurrency (e.g., synchronization versus lock) for the Wait cannot be determined from the Wait API. At , based on the information recorded at  or , it is determined whether the object type of the concurrency object to be waited on is a lock type object, a synchronization type object, or an undefined type object (i.e., no type information has been recorded for the object). If it is determined at  that the concurrency object is an undefined type object, the object type is assumed to be a lock and is recorded at  as a lock type object. The object is identified as a lock acquire event at , and this information is provided to race detection algorithm .","If it is determined at  that the concurrency object is a lock object, the object is identified as a lock acquire event at , and this information is provided to race detection algorithm . If it is determined at  that the concurrency object is a synchronization object, the object is identified as a \u201chappens before\u201d event at , and this information is provided to race detection algorithm .","The techniques described above may be applied to any set of concurrency-related APIs where there is at least one ambiguous API, but where there is sufficient information in the sequence of API invocation to deduce the concurrency type. For example, in some operating system or runtime there may be a single API for creating a concurrency object, and then its first usage (e.g., acquire, post, wait, etc) provides the disambiguation.","Although specific embodiments have been illustrated and described herein, it will be appreciated by those of ordinary skill in the art that a variety of alternate and\/or equivalent implementations may be substituted for the specific embodiments shown and described without departing from the scope of the present invention. This application is intended to cover any adaptations or variations of the specific embodiments discussed herein. Therefore, it is intended that this invention be limited only by the claims and the equivalents thereof."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings are included to provide a further understanding of embodiments and are incorporated in and constitute a part of this specification. The drawings illustrate embodiments and together with the description serve to explain principles of embodiments. Other embodiments and many of the intended advantages of embodiments will be readily appreciated, as they become better understood by reference to the following detailed description. The elements of the drawings are not necessarily to scale relative to each other. Like reference numerals designate corresponding similar parts.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
