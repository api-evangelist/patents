---
title: System and method for securely utilizing basic input and output system (BIOS) services
abstract: In accordance with one aspect of the current invention, the system comprises a memory for storing instruction sequences by which the processor-based system is processed, where the memory includes a physical memory and a virtual memory. The system also comprises a processor for executing the stored instruction sequences. The stored instruction sequences include process acts to cause the processor to: map a plurality of predetermined instruction sequences from the physical memory to the virtual memory, determine an offset to one of the plurality of predetermined instruction sequences in the virtual memory, receive an instruction to execute the one of the plurality of predetermined instruction sequences, transfer control to the one of the plurality of predetermined instruction sequences, and process the one of the plurality of predetermined instruction sequences from the virtual memory. In accordance with another aspect of the present invention, the system includes an access driver to generate a service request to utilize BIOS services such that the service request contains a service request signature created using a private key in a cryptographic key pair. The system also includes an interface to verify the service request signature using a public key in the cryptographic key pair to ensure integrity of the service request.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06892304&OS=06892304&RS=06892304
owner: Phoenix Technologies Ltd.
number: 06892304
owner_city: Milpitas
owner_country: US
publication_date: 20001003
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED INVENTION","Definitions","System Overview","Accessing and Executing Contents of Physical Memory From Virtual Memory","Secure Utilization of BIOS services"],"p":["This application is a division of Ser. No. 09\/336,889 filed Jun. 18, 1999 now U.S. Pat. No. 6,148,387 which is Continuation-In-Part of U.S. patent application Ser. No. 08\/947,990 filed on Oct. 9, 1997 now abandoned.","1. Field of the Invention","The present invention relates to a system and method for securely utilizing Basic Input and Output System (BIOS) services.","2. Description of the Related Art","In virtual memory subsystems, \u201cvirtual\u201d memory addressing is employed in which the memory addresses utilized in software programs are mapped indirectly to locations in physical memory. Translation to physical addresses is typically accomplished by the processor, and such physical addresses are inaccessible to user mode software and the Basic Input\/Output System (BIOS).","One example of such virtual memory subsystems is that used by Windows NT, which is manufactured and marketed by Microsoft, Inc. In particular, Windows NT incorporates a demand-paged virtual memory subsystem. The memory address space provided to a program running on the Windows NT operating system is safeguarded from other user mode programs just as other programs are protected from it. This ensures that user mode services and applications will not write over each other's memory, or execute each other's instructions. Kernel mode services and applications are protected in a similar way. If an attempt to access memory outside of a program's allocated virtual space occurs, the program is terminated and the user is notified. Virtual memory subsystems also prevent direct access by user mode software to physical memory addresses and to input\/output devices that are part of a computer system.","There is an increasing trend towards the use of input\/output devices on a computer system which are capable of executing operating systems using virtual memory subsystems. In such systems, there is no means for accessing memory outside of a program's virtual memory space, such as BIOS functions. One approach to this problem is to install a device driver which reads a file containing instructions for a device. The driver reads the file and writes (or downloads) these instructions into the device's memory. However, this type of device driver permits only limited addressing capability for memory and input\/output operations. In addition, it does not allow execution of the system's processor instructions in physical memory space.","Accordingly, there is a need in the technology for a system and method for accessing and executing the contents of physical memory from a virtual memory subsystem, which facilitates increased addressing capability for memory and input\/output operations, and which also allows execution of processor instructions directly from physical memory.","Furthermore, data stored on computer systems or platforms can be updated or configured. In certain cases, the data is extremely sensitive. A good example of configurable sensitive data is the Basic Input and Output System (BIOS) of a computer system. Typically stored in some form of non-volatile memory, the BIOS is machine code, usually part of an Operating System (OS), which allows the Central Processing Unit (CPU) to perform tasks such as initialization, diagnostics, loading the operating system kernel from mass storage, and routine input\/output (\u201cI\/O\u201d) functions. Upon power up, the CPU will \u201cboot up\u201d by fetching the instruction code residing in the BIOS. Without any security protection, the BIOS is vulnerable to attacks through capturing and replaying of service requests to invoke functions provided by the BIOS. These attacks may corrupt the BIOS and disable the computer system.","Accordingly, there is also need to provide a system and method to verify the integrity of service requests to access or modify data in the BIOS and to enforce proper authorization limits of those remote request messages.","The present invention provides a system and method for securely utilizing Basic Input and Output System (BIOS) services.","In accordance with one aspect of the current invention, the system comprises a memory for storing instruction sequences by which the processor-based system is processed, where the memory includes a physical memory and a virtual memory. The system also comprises a processor for executing the stored instruction sequences. The stored instruction sequences include process acts to cause the processor to: map a plurality of predetermined instruction sequences from the physical memory to the virtual memory, determine an offset to one of the plurality of predetermined instruction sequences in the virtual memory, receive an instruction to execute the one of the plurality of predetermined instruction sequences, transfer control to the one of the plurality of predetermined instruction sequences, and process the one of the plurality of predetermined instruction sequences from the virtual memory.","Another aspect of the system includes an access driver to generate a service request to utilize BIOS services such that the service request contains a service request signature created using a private key in a cryptographic key pair. The system also includes an interface to verify the service request signature using a public key in the cryptographic key pair to ensure integrity of the service request.","As discussed herein, a \u201ccomputer system\u201d is a product including circuitry capable of processing data. The computer system may include, but is not limited to, general purpose computer systems (e.g., server, laptop, desktop, palmtop, personal electronic devices, etc.), personal computers (PCs), hard copy equipment (e.g., printer, plotter, fax machine, etc.), banking equipment (e.g., an automated teller machine), and the like. An infomediary is a web site that provides information on behalf of producers of goods and services, supplying relevant information to businesses about products and\/or services offered by suppliers and other businesses. Content refers to application programs, driver programs, utility programs, the payload, etc., and combinations thereof, as well as graphics, informational material (such as articles, stock quotes, etc.) and the like, either singly or in any combination. In addition, a \u201ccommunication link\u201d refers to the medium or channel of communication. The communication link may include, but is not limited to, a telephone line, a modem connection, an Internet connection, an Integrated Services Digital Network (\u201cISDN\u201d) connection, an Asynchronous Transfer Mode (ATM) connection, a frame relay connection, an Ethernet connection, a coaxial connection, a fiber optic connection, satellite connections (e.g. Digital Satellite Services, etc.), wireless connections, radio frequency (RF) links, electromagnetic links, two way paging connections, etc., and combinations thereof. Power On Self Test (POST) refers to the instructions that are executed to configure and test the system hardware prior to loading an OS.","A description of an exemplary system, which incorporates embodiments of the present invention, is hereinafter described.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 1","b":["10","10"]},"In one embodiment, two software modules are used to implement various embodiments of the invention. One is resident on a user's system, and is used to access a predetermined web site. For example, in one embodiment, the operating system and Basic Input and Output System (BIOS) are pre-installed on a computer system, and when the computer system is subsequently first powered up, an application, referred to for discussion purposes as the first software module (in one embodiment, the first software module is the initial start-up application (ISUA), which will be described in the following sections), will allow the launching of one or more executable programs in the preboot environment. In one embodiment, the first software module facilitates the launching of one or more executable programs prior to the loading, booting, execution and\/or running of the OS. In one embodiment, the user is encouraged to select the use of such a program (i.e., the use of the first software module), and in alternative embodiments, the program is automatically launched. The program(s) contained in the first software module enables tools and utilities to run at an appropriate time, and with proper user authorization, also allow the user to download a second software module that includes drivers, applications and additional payloads through the Internet connection on the PC. The programs may also provide for remote management of the system if the OS fails to launch successfully.","Once the second software module has been delivered, it may become memory resident, and may disable the transferred copy of the first software module. The original copy of the first software module still residing in the system's non-volatile memory remains idle until the second software module fails to function, becomes corrupted or is deleted, upon which a copy of the original first software module is again transferred as described above. The second software module may include an application that connects the user to a specific server on the Internet and directs the user to a predetermined web site to seek authorization to down load further subscription material. The second software module may also include content that is the same or similar to the content of the first software module.","In one embodiment, the system may also include an initial payload that is stored in Read Only Memory BIOS (ROM BIOS). In one embodiment, the initial payload is part of the first software module (e.g., the ISUA). In an alternative embodiment, the initial payload is stored as a module in ROM BIOS, separate from the first software module. In one embodiment, the initial payload is launched from ROM BIOS and displayed on the screen after the Power On Self Test (POST) but prior to the booting, loading and\/or execution of the OS. This may occur at a predetermined time, such as when the system is being manufactured, assembled and tested, or when the end user first activates the system. In an alternate embodiment, this initial payload is copied to a predetermined location (such as the system's hard disk) at a predetermined time, such as when the system is being manufactured, assembled and tested, or when the end user first activates the system.","Once copied, the payload executes after POST but prior to operation of the OS, and may display graphics, advertisements, animation, Joint Photographic Experts Group (JPEG)\/Moving Picture Experts Group (MPEG) formatted material on the screen. When additional programs and\/or payloads are delivered (via the Internet or other outside connection), the display screen may be used to provide customized screens in the form of messages or graphics prior to and during booting of the OS. In addition, executable programs delivered in the first software module, as well as subsequent programs (such as the second software module) downloaded from the web site, may be used to survey the PC to determine various types of devices, drivers, and applications installed. In one embodiment, as described in co-pending U.S. patent application Ser. No. 09\/336,289, entitled \u201cMethod and Apparatus for Automatically Installing And Configuring Software on a Computer\u201d, filed Jun. 18, 1999, assigned to Phoenix Technologies Ltd., the contents of which are incorporated herein by reference, the first software module is used to identify and to automatically create shortcuts and\/or bookmarks for the user. The programs downloaded from the website may include software that collects and maintains a user profile based on the user's preferences. Such information may be provided to the infomediary, which subsequently forwards portions of the information and\/or compiled data based on the information to suppliers and other businesses to obtain updates or revisions of information provided by the suppliers and other businesses.","Referring to , the information distribution system  comprises a service center  that is connected over one or more communications links -to one or more user computer systems -(\u201c\u201d). The service center  includes one or more servers , one or more databases , and one or more computers -. The one or more computers -are capable of simultaneous access by a plurality of the user computer systems -. If a plurality of computers are used, then the computers -may be connected by a local area network (LAN) or any other similar connection technology. However, it is also possible for the service center  to have other configurations. For example, a smaller number of larger computers (i.e. a few mainframe, mini, etc. computers) with a number of internal programs or processes running on the larger computers capable of establishing communications links to the user computers.","The service center  may also be connected to a remote network  (e.g., the Internet) or a remote site (e.g., a satellite, which is not shown in FIG. ). The remote network  or remote site allows the service center  to provide a wider variety of computer software, content, etc. that could be stored at the service center . The one or more databases  connected to the service center computer(s), e.g., computer , are used to store database entries consisting of computer software available on the computer(s) . In one embodiment, each user computer -has its own secure database (not shown), that is not accessible by any other computer. The communication links -allow the one or more user computer systems -to simultaneously connect to the computer(s) -. The connections are managed by the server .","After a user computer system  establishes two-way communications with the information service computer , the content is sent to the user computer system  in a manner hereinafter described. The downloaded content includes an application that surveys the user and\/or the user computer system's hardware and\/or software to develop a user profile as well as a profile of the user's system. The information gathered from the user and\/or user's computer system is subsequently provided to the service center , which provides additional content to the user computer  based on the user and system profile. The database entries from the database connected to the service computer  contain information about computer software, hardware, and third party services and products that are available to a user. Based on the user and\/or system profile, the content is further sent to the user computer for display. The content may also include a summary of information such as the availability of patches and fixes for existing computer software, new versions of existing computer software, brand new computer software, new help files, etc. The content may further include information regarding availability of hardware and third party products and services that is of interest to the user. The user is then able to make one or more choices from the summary of available products and services, and request that the products be transferred from the service computer  to the user computer. Alternatively, the user may purchase the desired product or service from the summary of available products and services.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 2","b":["100","100","40","40","26","26","1"],"sub":["1","N ","1","M "]},"Referring to , the computer system  comprises a processor or a central processing unit (CPU) . The illustrated CPU  includes an Arithmetic Logic Unit (ALU) for performing computations, a collection of registers for temporary storage of data and instructions, and a control unit for controlling operation for the system . In one embodiment, the CPU  includes any one of the x86, Pentium\u2122, Pentium II\u2122, and Pentium Pro\u2122 microprocessors as marketed by Intel\u2122 Corporation, the K-6 microprocessor as marketed by AMD\u2122, or the 6\u00d786MX microprocessor as marketed by Cyrix\u2122 Corp. Further examples include the Alpha\u2122 processor as marketed by Digital Equipment Corporation\u2122, the 680\u00d70 processor as marketed by Motorola\u2122; or the Power PC\u2122 processor as marketed by IBM\u2122. In addition, any of a variety of other processors, including those from Sun Microsystems, MIPS, IBM, Motorola, NEC, Cyrix, AMD, Nexgen and others may be used for implementing CPU . The CPU  is not limited to microprocessor but may take on other forms such as microcontrollers, digital signal processors, reduced instruction set computers (RISC), application specific integrated circuits, and the like. Although shown with one CPU , computer system  may alternatively include multiple processing units.","The CPU  is coupled to a bus controller  by way of a CPU bus . The bus controller  includes a memory controller  integrated therein, though the memory controller  may be external to the bus controller . The memory controller  provides an interface for access by the CPU  or other devices to system memory  via memory bus . In one embodiment, the system memory  includes synchronous dynamic random access memory (SDRAM). System memory  may optionally include any additional or alternative high speed memory device or memory circuitry. The bus controller  is coupled to a system bus  that may be a peripheral component interconnect (PCI) bus, Industry Standard Architecture (ISA) bus, etc. Coupled to the system bus  are a graphics controller, a graphics engine or a video controller , a mass storage device , a communication interface device , one or more input\/output (I\/O) devices -, and an expansion bus controller . The video controller  is coupled to a video memory  (e.g., 8 Megabytes) and video BIOS , all of which may be integrated onto a single card or devices as designated by numeral . The video memory  is used to contain display data for displaying information on the display screen , and the video BIOS  includes code and video services for controlling the video controller . In another embodiment, the video controller  is coupled to the CPU  through an Advanced Graphics Port (AGP) bus.","The mass storage device  includes (but is not limited to) a hard disk, floppy disk, CD-ROM, DVD-ROM, tape, high density floppy, high capacity removable media, low capacity removable media, solid state memory device, etc., and combinations thereof. The mass storage device  may include any other mass storage medium. The communication interface device  includes a network card, a modem interface, etc. for accessing network  via communications link . The I\/O devices -include a keyboard, mouse, audio\/sound card, printer, and the like. The I\/O devices -may be a disk drive, such as a compact disk drive, a digital disk drive, a tape drive, a zip drive, a jazz drive, a digital video disk (DVD) drive, a solid state memory device, a magneto-optical disk drive, a high density floppy drive, a high capacity removable media drive, a low capacity media device, and\/or any combination thereof. The expansion bus controller  is coupled to nonvolatile memory  which includes system firmware . The system firmware  includes system BIOS , which is for controlling, among other things, hardware devices in the computer system . The system firmware  also includes ROM  and flash (or EEPROM) . The expansion bus controller  is also coupled to expansion memory  having RAM, ROM, and\/or flash memory (not shown). The system  may additionally include a memory module  that is coupled to the bus controller . In one embodiment, the memory module  comprises a ROM  and flash (or EEPROM) .","As is familiar to those skilled in the art, the computer system  further includes an operating system (OS) and at least one application program, which in one embodiment, are loaded into system memory  from mass storage device  and launched after POST. The OS may include any type of OS including, but not limited or restricted to, DOS, Windows\u2122 (e.g., Windows 95\u2122, Windows 98\u2122, Windows NT\u2122), Unix, Linux, OS\/2, OS\/9, Xenix, etc. The operating system is a set of one or more programs which control the computer system's operation and the allocation of resources. The application program is a set of one or more software programs that performs a task desired by the user.","In accordance with the practices of persons skilled in the art of computer programming, the present invention is described below with reference to symbolic representations of operations that are performed by computer system , unless indicated otherwise. Such operations are sometimes referred to as being computer-executed. It will be appreciated that operations that are symbolically represented include the manipulation by CPU  of electrical signals representing data bits and the maintenance of data bits at memory locations in system memory , as well as other processing of signals. The memory locations where data bits are maintained are physical locations that have particular electrical, magnetic, optical, or organic properties corresponding to the data bits.","When implemented in software, the elements of the present invention are essentially the code segments to perform the necessary tasks. The program or code segments can be stored in a processor readable medium or transmitted by a computer data signal embodied in a carrier wave over a transmission medium or communication link. The \u201cprocessor readable medium\u201d may include any medium that can store or transfer information. Examples of the processor readable medium include an electronic circuit, a semiconductor memory device, a ROM, a flash memory, an erasable ROM (EROM), a floppy diskette, a CD-ROM, an optical disk, a hard disk, a fiber optic medium, a radio frequency (RF) link, etc. The computer data signal may include any signal that can propagate over a transmission medium such as electronic network channels, optical fibers, air, electromagnetic, RF links, etc. The code segments may be downloaded via computer networks such as the Internet, Intranet, etc.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 3","FIGS. 2 and 3"],"b":["100","176","124","104","176","82","84","86","88","90","92","94","176","180","184","176","190","194","84","86","88","176","100","84","86","88"],"i":["a, ","a ","a "]},"RAPI  generally provides a secured interface between ROM application programs and system BIOS . One embodiment of RAPI  is described below in  and the accompanying text. One embodiment of ISUA  is described in co-pending U.S. patent application Ser. No. 09\/336,289, entitled \u201cMethod and Apparatus for Automatically Installing and Configuring Software on a Computer,\u201d filed on Jun. 18, 1999, assigned to Phoenix Technologies, Ltd., and which is incorporated herein by reference.","One aspect of the present invention is described with reference to an operating system installed on the processing system , shown in FIG. .  is an overall functional block diagram illustrating the architecture of a processing system utilizing the system and method of the present invention. The processing system  comprises an operating system  which supports application programs  and services , Basic Input\/Output System (\u201cBIOS\u201d)  and system hardware . The BIOS  is a collection of drivers, or software interfaces for hardware devices such as the console (keyboard and display), a generic printer, the auxiliary device (serial port), the computer's clock and the boot disk device. The BIOS  is typically embedded in programmable, read only memory (ROM). Often, the BIOS functions themselves are actually copied from ROM into physical memory, taking advantage of the faster access times of physical memory. This is known as \u201cshadowing\u201d the BIOS  because two copies of BIOS  results: one in ROM (which will no longer be used) and the other in physical memory. The portion of physical memory which stores the BIOS  is known as the BIOS shadow space. An operating system such as Windows NT makes no use of the BIOS  after the operating system has been booted and is running. The kernel level drivers in the Windows NT operating system interface directly with the system hardware. The present invention facilitates the use of the BIOS  as an interface between system hardware  and an operating system .","The operating system  includes a class driver  which interfaces with the application programs  and services , and an I\/O Manager . The I\/O Manager  converts I\/O requests from the application programs  and services  (made via the class driver ) into properly sequenced calls to various driver routines located in the kernel . In particular, when the I\/O Manager  receives an I\/O request, it uses the function codes of the request to call one of several dispatch routines in a driver located in the kernel . The kernel  provides hardware-independent functions, called system functions, that are accessed by means of a software interrupt. The functions provided by the kernel  include file and directory management, memory management, character device input\/output and time and date support, among others. In one embodiment, the operating system is the Windows NT operating system. In alternate embodiments, the operating system  includes the Solaris or the AIX operating systems or other operating systems based on demand-paged virtual memory subsystems.","The present invention provides an access driver , located within the kernel , which is responsible for accessing BIOS data located in the BIOS  or for accessing system hardware  data via the BIOS . The access driver  is also responsible for accessing the location of a BIOS function address, as well as executing the associated BIOS function. In one preferred embodiment, the access driver  comprises source code written in the C language. It is understood that other assembly languages may be utilized in implementing the functions of the access driver . The BIOS data and addresses are typically located in physical memory  and are accessed by the access driver  via a BIOS Interface . In one embodiment, the access driver  executes code in the BIOS shadow space, typically at physical addresses 0\u00d7000E0000 through 0\u00d7000FFFFF.","By way of example, if the access driver  needs to access BIOS functions located in physical memory at address 0\u00d700000000. It makes a call to the I\/O Manager , requesting it to map the memory space at physical address 0\u00d700000000 through 0\u00d700000FFF to its virtual memory space. The I\/O Manager  then returns a pointer to the virtual memory space of the access driver , for example, 0\u00d7fd268000. The access driver may now reference the address space at physical address 0\u00d700000000 by basing or referring its virtual addresses with 0\u00d7fd268000. Thus, to access a function located at physical address 0\u00d72400, the virtual address used would be 0\u00d7fd2682400.","In one preferred embodiment, a set of entry-points or function calls are available to the application programs , services  or class driver  which utilize the access driver . The access driver  can be opened, closed, and can receive input\/output (\u201cI\/O\u201d) control codes (\u201cIOCTLs\u201d) through these entry points. Table 1 illustrates the structure, entry points and applications for the access driver .",{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 5","FIG. 5"],"b":["246","246","246","260","62","250","264","250","270","272","74","246","232","2234","240","246","236","246","246","246"]},"In particular, the access driver , during initialization, locates the BIOS shadow area  and the BIOS data area  located in physical memory . The BIOS shadow area  and the BIOS data area  are mapped into the virtual address space of the access driver . Next, the access driver  performs a search for the BIOS Service Directory  header. Upon finding and validating the BIOS Service Directory , the access driver  obtains the virtual address of the BIOS Service Directory  header, which provides the offset of the BIOS Service Directory  header virtual address from the base virtual address of the BIOS shadow area .","In an alternate embodiment, the access driver, during initialization, locates the BIOS shadow area , the BIOS data area  and the BIOS ROM area located in physical memory . The BIOS shadow area , the BIOS data area  and the BIOS ROM area are mapped into the virtual address space of the access driver . Next, the access driver  performs a search for the BIOS Service Directory  header. Upon finding and validating the BIOS Service Directory , the access driver  obtains the virtual address of the BIOS Service Directory  header. In this alternate embodiment, the availability of the BIOS ROM area in the virtual memory space of the access driver  enables the access driver  to read and\/or write data in flash ROM. As a result, the BIOS ROM can be reflashed or rewritten. In addition, outside application programs which interface with hardware can access the BIOS ROM area through software mechanisms such as that described in the PhoenixPhlash NT specification provided in Appendix B.","Later, calls to an execution function in the access driver  will utilize the base virtual address of the BIOS shadow area  and the offset to invoke a requested entry point in the BIOS itself. It should be noted that an application program  or service  may cause execution of the BIOS function anywhere in the BIOS' virtual address space, and not only through the BIOS Service Directory .","In one embodiment, the execution function that is called to invoke a requested entry point in the BIOS is the IOCTL_BIOS_EXEC function, which is described in Table 1. The IOCTL_BIOS_EXEC function creates a register stack in a buffer (which is specified by the calling application program  or service ) located in main memory or DRAM. The contents of the stack are the desired register values at the time the BIOS function is invoked. The access driver  passes the register stack from the calling application program  or service . The procedure call itself is performed using a pointer to the function specified in the BIOS Service Directory . In one embodiment, the BIOS function called by IOCTL_BIOS_EXEC accepts a 4-byte signature as an argument and locates the BIOS function associated with the signature. Values passed back to the calling application program  or service  include the base virtual address of the BIOS function, and the offset from the base address of the service's entry point.","A general discussion of the structure, entry functions and applications for access driver  will now be provided.",{"@attributes":{"id":"p-0066","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Access Driver 246 Functions"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Function Name","Description","Remarks"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["DriverEntry","Kernel calls this function",{}]},{"entry":[{},"at load time to cause the"]},{"entry":[{},"driver to initialize itself."]},{"entry":["Access Driver CreateClose","Kernel calls this function"]},{"entry":[{},"to create or close out the"]},{"entry":[{},"driver's functionality."]},{"entry":["Access Driver Unload","Called by Kernel for"]},{"entry":[{},"Service Control Manager"]},{"entry":[{},"to unload the driver. This"]},{"entry":[{},"function frees all"]},{"entry":[{},"resources established at"]},{"entry":[{},"load time."]},{"entry":["IOCTL_Locate","Locates the BIOS 232-bit"]},{"entry":[{},"entry point using a string"]},{"entry":[{},"search. The entry point"]},{"entry":[{},"virtual address, the BIOS"]},{"entry":[{},"base virtual address and"]},{"entry":[{},"the BIOS data area"]},{"entry":[{},"virtual address are"]},{"entry":[{},"returned to the caller."]},{"entry":["IOCTL_BIOS_Read","Reads data from either"]},{"entry":[{},"the BIOS ROM, shadow"]},{"entry":[{},"or BIOS data area and"]},{"entry":[{},"returns it to the"]},{"entry":[{},"user's buffer."]},{"entry":["IOCTL_BIOS_Write","Writes data to either the"]},{"entry":[{},"BIOS ROM, shadow or"]},{"entry":[{},"BIOS data area from"]},{"entry":[{},"the user's buffer."]},{"entry":["IOCTL_BIOS_Exec","Passes execution to a"]},{"entry":[{},"BIOS entry point via the"]},{"entry":[{},"232-bit entry point"]},{"entry":["IOCTL_RTC_Read","Reads the real-time clock","Format of"]},{"entry":[{},"date and time and returns","returned data will"]},{"entry":[{},"these to the calling","match"]},{"entry":[{},"function.","SYSTEMTIME"]},{"entry":[{},{},"template."]},{"entry":["IOCTL_Version","Returns the version","Includes a bitmap"]},{"entry":[{},"number of the driver to","of currently"]},{"entry":[{},"the caller","implemented"]},{"entry":[{},{},"functions"]},{"entry":["Access Driver DriverReg","Registers the calling","The list of"]},{"entry":[{},"device by its object name","registered devices"]},{"entry":[{},"and canonical name.","will be used to"]},{"entry":[{},{},"resume and"]},{"entry":[{},{},"suspend."]},{"entry":["Access Driver DriverReg","Deregisters the calling","The device must"]},{"entry":[{},"device.","have registered"]},{"entry":[{},{},"already."]},{"entry":["IOCTL_PM_Suspend","The function sends"]},{"entry":[{},"Suspend IRP's to all"]},{"entry":[{},"registered devices."]},{"entry":["IOCTL_PM_Resume","The function sends"]},{"entry":[{},"Resume IRP's to all"]},{"entry":[{},"registered devices."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":"246"},"1. The \u201cDriverEntry\u201d function","This entry point causes the driver to initialize its variables, map in the BIOS shadow and data areas, and to allocate resources for its normal operation. As each resource or object is allocated, it is tabulated into the variable \u2018phResAndFlags\u2019; this allows a single function (\u2018freeResources\u2019) to free up resources used by the driver, no matter the reason for the driver being unloaded. The resources allocated or connected to are as follows:\n\n","In one embodiment, the device object name is \u2018Laptop\u2019, which is required in order to service the nexus functions required by the Microsoft OEM Adaptation Kit (OAK). The corresponding symbolic link name is \u2018PhoenixAD\u2019.","2. AccessDriverCreateClose","This function is used to inform the driver  when an application program  or service  makes a request to the system for a device handle, or when it closes a handle already obtained. The Access Driver  responds to this dispatch entry point by completing the request successfully, but changing no other state variable of the driver .","3. AccessDriverUnload","This dispatch entry point is called by the kernel on behalf of the Service Control Manager (SCM) or other application when it is necessary to remove the driver from the system (device close from (SCM)). The result of this function call is that all resources tabulated in \u2018phResAndFlags\u2019 are freed to the system and the request is completed successfully.","4. AccessDriverReg","The Access Driver  driver has the function of performing \u201cnexus processing\u201d for the power management model provided as part of the OEM Adaptation Kit (OAK). This function is integral to the emulation of power management for OEM and standard devices having knowledge of and a requirement to use the OAK control methods. The AccessDriverReg function registers devices into a linked list. It also selectively \u201cderegisters\u201d devices on request. Typically OAK compliant device drivers will make the call for registration when their DriverEntry function is executed (when they are first loaded). And as part of the DriverUnload function, each registered device must make the call to remove itself from Access Driver 's linked list of devices needing power management services.","5. IOCTL Functions","Every interface between the service or application layer and the BIOS is handled by an IOCTL function in the Access Driver  driver. Each IOCTL transfer is performed in Buffered Mode, so that the input data to the driver and its output data are transferred through a common system buffer. The pointer to this buffer space is given in the Input\/Output (I\/O) Request Packet as Irp>AssociatedIrp.SystemBuffer. Upon being given control, the IOCTL (within the driver) will get the system buffer address and use its contents to perform the request. The results of the IOCTL function's execution will be placed in the same system buffer as was used for input.","Each IOCTL that is implemented in the Access Driver  driver has a unique data format for IOCTL input data and for its output data. As the functions are described below, their data buffer formats and descriptions of each field are given. Buffer offsets are given in bytes. The minimum buffer size given for each function is a recommended malloc( ) size to use for the application program's user buffers. System buffer sizes will automatically be derived from the user buffers.","6. IOCTL Locate","The IOCTL_Locate function is the first dispatch entry point to be called by the application program  or service  after the driver  initializes. The function returns the addresses of the BIOS232 Service Interface, the base address of the BIOS shadow area, and the base address of the BIOS Data Area, in flat-model virtual address format (232 bit addresses). Note that the BIOS232 Service Interface is the single entry point for all BIOS functions executed from the driver level or kernel threads (see Appendix A). The BIOS232 Service Interface is the single entry point for all BIOS functions executed from the driver level or kernel threads (see Appendix A). These address spaces are guaranteed to be accessible to this driver (only) during the time the Access Driver  driver is loaded.",{"@attributes":{"id":"p-0081","num":"0088"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Input data:","None, do not rely on buffer contents"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Output data:","Offset 0:","PUCHAR -","BIOS Service Directory"]},{"entry":[{},{},{},"Offset into Shadow."]},{"entry":[{},"Offset 4:","PUCHAR -","BIOS Shadow Area Base"]},{"entry":[{},{},{},"Virtual Address."]},{"entry":[{},"Offset 8:","PUCHAR -","BIOS Data Area Base"]},{"entry":[{},{},{},"Virtual Address."]},{"entry":[{},"Offset 8:","PUCHAR -","BIOS Data Area Base"]},{"entry":[{},{},{},"Virtual Address."]},{"entry":[{},"Offset 12:","PUCHAR -","BIOS ROM Area Base"]},{"entry":[{},{},{},"Virtual Address."]},{"entry":["Min. Buffer Size:","16 bytes"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"7. IOCTL BIOS Read","The IOCTL BIOS Read function is a general purpose reader of either the BIOS ROM, shadow area, or the data area.",{"@attributes":{"id":"p-0084","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Input Data:","Offset 0:","ULONG -","Mode Flags"]},{"entry":[{},"Bit 0:","1 =","shadow area, 0 = data"]},{"entry":[{},{},{},"area."]},{"entry":[{},"Bit 2:","1 =","ROM area (overrides"]},{"entry":[{},{},{},"Bit 0)"]},{"entry":[{},"Offset 4:","PUCHAR -","Offset into the BIOS"]},{"entry":[{},{},{},"area to start the read"]},{"entry":[{},"Offset 8:","ULONG -","Length of the read in"]},{"entry":[{},{},{},"bytes."]},{"entry":["Output Data:","Offset 0:","ULONG -","Length of the actual"]},{"entry":[{},{},{},"read"]},{"entry":[{},"Offset 4:","UCHAR array -","the actual data read"]},{"entry":["Min. Buffer Size:","16 bytes"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"Note: If a \u2018short read\u2019 occurs because the offset into the BIOS area specified an overlap with the end of the mapped BIOS memory, no error is returned. Instead the \u2018actual data read\u2019 field accurately indicates how much of the data is valid in the system buffer.","8. IOCTL BIOS Write","The IOCTL_BIOS_Write function is a general purpose writer of either the BIOS ROM, shadow, or the data area.",{"@attributes":{"id":"p-0088","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Input Data:","Offset 0:","ULONG -","Mode Flags"]},{"entry":[{},"Bit 0:","1 =","shadow area, 0 = data"]},{"entry":[{},{},{},"area."]},{"entry":[{},"Bit 2:","1 =","ROM area (overrides"]},{"entry":[{},{},{},"Bit 0)"]},{"entry":[{},"Offset 4:","PUCHAR -","Offset into the BIOS"]},{"entry":[{},{},{},"area to start the write"]},{"entry":[{},"Offset 8:","ULONG -","Length of the write in"]},{"entry":[{},{},{},"bytes."]},{"entry":["Output Data:","Offset 0:","ULONG -","Length of the actual"]},{"entry":[{},{},{},"write (zero, or request"]},{"entry":[{},{},{},"size)"]},{"entry":[{},"Offset 4:","UCHAR array -","the actual data read"]},{"entry":["Min. Buffer Size:","16 bytes"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"Note: Short writes are not permitted due to the possibility of data corruption.","9. IOCTL BIOS Exec","The IOCTL_BIOS_Exec function is used to execute a BIOS function through the BIOS232 Service Interface. An activation record is passed by value in the system buffer. The AR determines the Base Architecture register contents upon invocation of the entry point to the BIOS. Upon successful completion, the AR contains the Base Architecture context that would normally have been returned to the BIOS caller.",{"@attributes":{"id":"p-0092","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Input Data:","Offset 0:","ULONG -","Function entry point virtual"]},{"entry":[{},{},{},"address."]},{"entry":[{},"Offset 4:","ULONG -","Flags Register"]},{"entry":[{},"Offset 8:","ULONG -","reserved"]},{"entry":[{},"Offset 12:","ULONG -","reserved"]},{"entry":[{},"Offset 16:","ULONG -","reserved"]},{"entry":[{},"Offset 20:","ULONG -","reserved"]},{"entry":[{},"Offset 24:","ULONG -","reserved"]},{"entry":[{},"Offset 28:","ULONG -","reserved"]},{"entry":[{},"Offset 232:","ULONG -","reserved"]},{"entry":[{},"Offset 236:","ULONG -","reserved"]},{"entry":[{},"Offset 240:","ULONG -","reserved"]},{"entry":[{},"Offset 244:","ULONG -","EBP Register"]},{"entry":[{},"Offset 48:","ULONG -","EDI Register"]},{"entry":[{},"Offset 52:","ULONG -","ESI Register"]},{"entry":[{},"Offset 56:","ULONG -","EDX Register"]},{"entry":[{},"Offset 260:","ULONG -","ECX Register"]},{"entry":[{},"Offset 64:","ULONG -","EBX Register"]},{"entry":[{},"Offset 68:","ULONG -","EAX Register"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Output Data:","Contents of the system buffer are identical in structure."]},{"entry":[{},"Register contents may have been influenced by the"]},{"entry":[{},"BIOS function requested."]},{"entry":["Min. Buffer Size:","80 bytes."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"100. IOCTL RTC Read","The IOCTL_RTC_Read function is used to read the contents of the RTC registers in the CMOS RAM. The data from this atomic read is formatted similarly to the SYSTEMTIME structure and returned to the user in the System Buffer.",{"@attributes":{"id":"p-0095","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Input Data:","None, do not rely on buffer contents"]},{"entry":["Output Data:","<uses SYSTEMTIME template as shown below>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Offset 0:","WORD","current year"]},{"entry":[{},"Offset 2:","WORD","current month (January = 1)"]},{"entry":[{},"Offset 4:","WORD","current day of week"]},{"entry":[{},{},{},"(Sunday = 0)"]},{"entry":[{},"Offset 6:","WORD","current day of month"]},{"entry":[{},{},{},"(calendar)"]},{"entry":[{},"Offset 8:","WORD","current hour"]},{"entry":[{},"Offset 100:","WORD","current minute"]},{"entry":[{},"Offset 12:","WORD","current second"]},{"entry":[{},"Offset 14:","WORD","current millisecond"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Min. Buffer Size:","32 bytes."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Note that the Year field in the RTC is 8 bits wide. The contents of the Year field in the RTC will be recalculated to a SYSTEMTIME.Year 16 bit field containing the entire value of the current year, AD. Examples: RTC=00, Year=1980; RTC=23, Year=2003. Also note that Legacy RTC devices do not provide the millisecond field in their register set. Because of this, the current millisecond field in the Output Data for this function will always be set to zero.","11. IOCTL VERSION","The IOCTL_Version function returns to the caller the major, an minor version of the Access Driver  driver. In addition, the functions implemented by this version of the driver are enumerated in a bitmap. The purpose of the bitmap is for services or higher level drivers to evaluate whether or not this version of the driver can be used for their purposes (at installation time, typically).",{"@attributes":{"id":"p-0099","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Input Data:","None, do not rely on buffer contents"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Output Data:","Offset 0:","WORD","Major Version (X.)"]},{"entry":[{},"Offset 2:","WORD","Minor Version (.x)"]},{"entry":[{},"Offset 4:","ULONG","Bitmap of implemented"]},{"entry":[{},{},{},"functions (see below)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Bit 31:","1 if IOCTL_Locate implemented"]},{"entry":[{},"Bit 230:","1 if IOCTL_BIOS_Read"]},{"entry":[{},{},"implemented"]},{"entry":[{},"Bit 29:","1 if IOCTL_BIOS_Write"]},{"entry":[{},{},"implemented"]},{"entry":[{},"Bit 28:","1 if IOCTL_BIOS_Exec"]},{"entry":[{},{},"implemented"]},{"entry":[{},"Bit 27:","reserved"]},{"entry":[{},"Bit 26:","reserved"]},{"entry":[{},"Bit 25:","reserved"]},{"entry":[{},"Bit 24:","1 if IOCTL_RTC_Read"]},{"entry":[{},{},"implemented"]},{"entry":[{},"Bit 23:","reserved"]},{"entry":[{},"Bit 22:","reserved for Phlash interlock"]},{"entry":[{},"Bit 21:","reserved for online setup"]},{"entry":[{},{},"(NVRAM writes)"]},{"entry":[{},"Bit 20-0:","reserved for future expansion"]},{"entry":[{},"Bit 230:","1 if IOCTL_BIOS_Read"]},{"entry":[{},{},"implemented"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Min. Buffer Size:","16 bytes"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"12. IOCTL PM Suspend","The IOCTL_PM_Suspend function causes IRP_MJ_PNP_POWER, IRP_MN_LT_SUSPEND IRP's to be sent to each device that has registered itself using the Access Driver DriverReg entry point.","Input Data: None, do not rely on buffer contents","Output Data: None, do not rely on buffer contents","13. IOCTL PM Resume","The IOCTL_PM_Resume function causes IRP_MJ_PNP_POWER, IRP_MN_LT_RESUME IRP's to be sent to each device that has registered itself using the Access Driver DriverReg entry point.",{"@attributes":{"id":"p-0106","num":"0113"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Input Data:","None, do not rely on buffer contents"]},{"entry":[{},"Output Data:","None, do not rely on buffer contents"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":"246"},"The following table defines the error status returned when an IRP is unsuccessfully or only partially completed. Conditions of termination of the functions are given as well. This table is necessary because there is not necessarily a one-to-one correspondence between NTSTATUS values known by the operating system and those used by the Access Driver  device driver. In order to reverse translate the codes back into strings usable by an applications writer or an end-user, it is mandatory that only NTSTATUS error codes be used.",{"@attributes":{"id":"p-0108","num":"0115"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"NTSTATUS Codes returned from Access Driver 246"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"Condition at"]},{"entry":["NTSTATUS","Function","Termination"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["STATUS_SUCCESS","All","Request"]},{"entry":[{},{},"succeeded"]},{"entry":["STATUS_SOME_NOT_MAPPED","DriverEntry","One or more of"]},{"entry":[{},{},"memory or I\/O"]},{"entry":[{},{},"areas could not"]},{"entry":[{},{},"be mapped in."]},{"entry":[{},{},"Driver load fails."]},{"entry":["STATUS_NOT_IMPLEMENTED","All","Requested"]},{"entry":[{},{},"function is not"]},{"entry":[{},{},"implemented in"]},{"entry":[{},{},"this driver."]},{"entry":["STATUS_ACCESS_DENIED","All IOCTL","Device is"]},{"entry":[{},"functions","unusable by caller"]},{"entry":[{},{},"because another"]},{"entry":[{},{},"service has"]},{"entry":[{},{},"exclusive access"]},{"entry":[{},{},"or because the"]},{"entry":[{},{},"BIOS Service"]},{"entry":[{},{},"Directory"]},{"entry":[{},{},"signature is not"]},{"entry":[{},{},"present."]},{"entry":["STATUS_MEDIA_CHECK","All IOCTL","Contents of BIOS"]},{"entry":[{},"functions","ROM may have"]},{"entry":[{},"- not","been changed."]},{"entry":[{},"implemented -","New call to"]},{"entry":[{},{},"IOCTL_Locate"]},{"entry":[{},{},"is required."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":"232"},"In order for IOCTL_Locate to find the entry point for the BIOS, the BIOS 232-bit Service Directory is used. A description of the BIOS 232-bit Service Directory is described in Appendix C. The signature that Access Driver  will use when locating and executing BIOS functions shall be \u201c32_\u201d.","If the WinntEntry (BIOS232 Service Directory) structure is not found subject to the conditions stated above, the Access Driver  driver will fail at load time, and DriverEntry will indicate that it was unable to initialize as per Table 2.","D. Real-Time Clock Hardware Access","In order to implement the IOCTL_RTC_Read function, it is necessary to define the RTC's registers and methods of access. The RTC registers are located in the CMOS RAM's I\/O address space. Only the RTC registers are shown in Table 3. The registers are accessed by outputting a CMOS physical memory address to port 0\u00d770, and then reading the subject 8 bit register at port 0\u00d771. The CMOS physical memory address is set to point to 0\u00d70D after all RTC register have been read.",{"@attributes":{"id":"p-0112","num":"0119"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"RTC Registers"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Register Name","CMOS Address, Comments"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Year","9 - years since 1980"]},{"entry":[{},"Month","8 - 1 = January"]},{"entry":[{},"Date","7"]},{"entry":[{},"Day of Week","6 - zero equals Sunday"]},{"entry":[{},"Hour","4"]},{"entry":[{},"Minute","2"]},{"entry":[{},"Seconds","0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0113","num":"0120"},"figref":["FIG. 6A","FIG. 4"],"b":["600","610","242","6100","6","600","620","246","260","62","250","264","250","246","270","272","274","246"]},"Process  then advances to block , where pointer initialization occurs. Details of block  are provided in FIG. C and the accompanying text. The process  then advances to block , where initialization ends. Process  then terminates.",{"@attributes":{"id":"p-0115","num":"0122"},"figref":"FIG. 6B","b":["610","610","612","242","610","614","242"]},{"@attributes":{"id":"p-0116","num":"0123"},"figref":"FIG. 6C","b":["630","6","232","234","632","246","272","634","272","246","272","272","270","630","232","234"]},{"@attributes":{"id":"p-0117","num":"0124"},"figref":"FIG. 7A","b":["700","710","246","700","720","246","242","4","700","730","246","246","246","700","740","246","700"]},{"@attributes":{"id":"p-0118","num":"0125"},"figref":"FIG. 7B","b":["740","7","740","742","246","242","730","744","246","740","746","242","740"]},"An example of the utilization of the IOCTL_BIOS_EXEC function in the access driver  will now be provided. Initially, the application program  or service  makes a call to the access driver  using the command IOCTL_Locate. The data returned by the access driver  includes the BIOS Shadow Area Base Virtual Address, the BIOS Service Directory offset from the BIOS Shadow Area Base Virtual Address, and the BIOS Data Area Base Virtual Address.","The following act is then utilized to determine the existence of a BIOS service, its entry point, length and address offset. A calling program from the I\/O Manager  first allocates memory for a register structure, such as IOC_EXEC and then fills in the biosFunction field of the structure with the virtual address given by the IOCTL_Locate function. The other register values are filled in as follows: a 4-byte ASCII string identifying the BIOS service is loaded into the eax register and a zero is loaded into the ebx register.","Next, the caller invokes the IOCTL_BIOS_Exec function of the access driver  with the contents of the IOC_EXEC structure copied into the system buffer for the IOCTL call. The BIOS function is then executed. The IOCTL_BIOS_Exec function of the access driver  returns, with register values for eax, ebx, ecx and edx each containing responses from the service directory. The calling program of the I\/O Manager  then takes the information returned from the service directory and creates a biosFunction entry point and a structure in the system buffer. It then calls the BIOS function using the IOCTL_BIOS_Exec function in the access driver . Returned data are passed in the same IOC_EXEC structure.","Examples of the processes shown in , B, A and B are illustrated in Appendices D-D. In particular, Appendix D illustrates exemplary source code for the application program , service  or class driver , used in calling a BIOS function through the class driver . Appendices D and D illustrate exemplary source code for the access driver . Appendix D illustrates exemplary source code for executing a BIOS function in the shadow area, while Appendix D illustrates exemplary source code for creating a register stack and for calling the entry point for executing the BIOS function.","Through the use of the present invention, a system and method for accessing and executing the contents of physical memory from a virtual memory subsystem is provided. The system and method facilitates increased addressing capability for memory and input\/output operations, and also allows execution of processor instructions in physical memory space.","Another aspect of the present invention includes a system and method for securely utilizing Basic Input and Output System (BIOS) services. In the following detailed description, the following terms are used to described the current invention:\n\n",{"@attributes":{"id":"p-0125","num":"0136"},"figref":"FIG. 8","b":["1500","1500","1505","1510","1515","1520","1525","1520","1520"]},"The operating system  includes a class driver  which interfaces with application programs  and services , and an I\/O Manager . The I\/O Manager  converts I\/O requests from application programs  and services  (made via class driver ) into properly sequenced calls to various driver routines located in the kernel . In particular, when the I\/O Manager  receives an I\/O request, it uses the function codes of the request to call one of several dispatch routines in a driver located in the kernel . The kernel  provides hardware-independent functions, called system functions, that are accessed by means of a software interrupt. The functions provided by the kernel  typically include file and directory management, memory management, character device input\/output and time and date support, among others. In one embodiment, the operating system  a Windows operating system. In alternate embodiments, the operating system  includes the Solaris or the AIX operating systems or other operating systems based on demand-paged virtual memory subsystems.","The present invention provides an access driver , located within the kernel , which is responsible for interfacing with the ROM Application Programming Interface (RAPI)  to access or update data located in BIOS  or access system hardware data via the BIOS. RAPI  generally provides an interface for securely utilizing BIOS services or functions. A more detailed description of RAPI is provided below.","In one preferred embodiment, the access driver  comprises source code written in the C language. It is understood that other assembly languages may be utilized in implementing the functions of access driver . In one preferred embodiment, a set of entry-points or functions calls are available to application programs , services  or class driver  which utilize access driver . The access driver  can be opened, closed, and can receive input\/output (\u201cI\/O\u201d) control codes (\u201cIOCTLs\u201d) through these entry points.",{"@attributes":{"id":"p-0129","num":"0140"},"figref":"FIG. 9","b":["1545","1550","1545","1550","1545","1550","550","1545","1605","1550","1610"]},"The format of one embodiment of a session request  is shown in FIG. . Each session request  includes a session operation code , a list of parameters , and a session signature . Session operation code  is a numerical value representing one type of session operation. Illustrative examples of session operations in one embodiment may include an operation to begin or establish a session and an operation to end or terminate the session. Each type of session operation may require a list of one or more parameters . In one embodiment, the list of parameters  may be a pointer to a memory location where the parameters reside. Each session request  also includes a session request signature  to prevent a foreign code segment, such as a computer virus, to capture and replay the request and corrupt the BIOS.",{"@attributes":{"id":"p-0131","num":"0142"},"figref":"FIG. 10","b":["1705","1710","1715","1720","1725","1715","1720","1725"]},"It is contemplated that the Digital Signature Algorithm (\u201cDSA\u201d) proposed by the National Institute of Standards and Technology may be used. It is also contemplated that the Rivest, Shamir, and Adleman (\u201cRSA\u201d) algorithm may be used. It should be noted, however, that other algorithms for generating digital signatures may also be employed in the present invention.","As shown in block  of , a session message is formed such that it contains the session operation code and the list of parameters. In block , a hash value for the session message is computed. It should be noted that algorithms to compute hash values are well known in the art. Those skilled in the art will recognize that a hash function suitable for use in embodiments of the present invention is one that can compute one-way and collision-free hash values. In block , a session request signature is generated by encrypting the computed hash value for the session message using a private key stored in a current authority certificate.","An authority certificate generally contains sufficient information to enable system components, such as access driver  and RAPI  (shown in FIG. ), to generate secured session or service requests and to verify the integrity of those requests.  shows the format of an authority certificate  in accordance with one embodiment of the current invention. The exemplary authority certificate includes at least the following fields: a public key , a private key , and a certificate signature . As described later, information stored in the authority certificate is used to enforce security limits of session and service requests.","Returning to block  in , RAPI  establishes a session as specified in the session request sent by access driver  in block . The acts required to establish a session are outlined in FIG. . In block , a message is constructed from the session operation code and list of parameters available in a session request received from the access driver. A hash value for the constructed message is computed (block ). The session request signature is extracted from the session request and decrypted using the public key included in RAPI's copy of the current authority certificate (block ). As shown later, RAPI is responsible for generating and supplying authority certificates to the access driver. RAPI, however, also maintains a copy of the most current authority certificates for its own use. In block , the decrypted session signature is compared to the computed hash value for the constructed message. If the computed hash value equals the decrypted session request signature, RAPI proceeds to start a session (block ).","Returning to , after it establishes a session, RAPI  generates a new authority certificate (block ). As stated above, RAPI  maintains a copy of the new authority certificate for its own use. RAPI  replaces the existing authority certificate with the new certificate. After the replacement, the new certificate becomes the most current certificate.",{"@attributes":{"id":"p-0137","num":"0148"},"figref":"FIG. 18","b":["2505","2510","2515","2520","2525","2530","2535"]},"Returning to , RAPI  sends the new authority certificate back to the access driver  (block ). Upon receiving the new authority certificate, access driver  updates the current authority certificate with information in the new certificate (block ). Accordingly, the information in the new authority certificate will be used to generate subsequent service requests. In block , access driver  generates a service request to invoke a function provided by RAPI .",{"@attributes":{"id":"p-0139","num":"0150"},"figref":"FIG. 13","b":["1000","1000","1005","1010","1015","1005","1000","1015"]},{"@attributes":{"id":"p-0140","num":"0151"},"figref":"FIG. 15","b":["1205","1210","1215","1220","1225","1230"]},"Returning to , access driver  sends the service request generated in block  to RAPI  (block ). Upon receiving the service request, RAPI  processes the request (block ).  shows the acts required in processing of a service request in accordance with one embodiment of the current invention. In block , a message is constructed from the service operation code and list of parameters available in the service request received from access driver. A hash value for the constructed message is computed (block ). The service request signature is extracted from the session request and decrypted using the public included in RAPI's copy of the current authority certificate (block ). In block , the decrypted session signature is compared to the computed hash value for the constructed message. If the computed hash value equals the decrypted session request signature, RAPI performs the service specified in the service request (block ). Otherwise, the specified service will not be performed.","Returning to , after it processes a service request, RAPI  generates a new authority certificate (block ). As described above,  shows the process of generating an authority certificate. RAPI  maintains a copy of the new authority certificate for its own use. RAPI  also sends a copy of the new authority certificate back to access driver .","Upon receiving the new authority certificate, access driver  updates the current authority certificate with information in the new certificate (block ). Accordingly, the information in the new authority certificate will be used to generate subsequent service requests. In block , access driver  generates a session request to request RAPI  to end the current session. As described above,  outlines the acts involved in generating a session request. Following the generation of a session request, access driver  sends the request to RAPI .","Upon receipt of the session request to end or terminate the session, RAPI  ends the session (block ).  shows the acts involved in ending the current session. In block , a message is constructed from the session operation code and list of parameters available in a session request received from the access driver. A hash value for the constructed message is computed (block ). The session request signature is extracted from the session request and decrypted using the public key included in RAPI's current authority certificate (block ). In block , the decrypted session signature is compared to the computed hash value for the constructed message. If the computed hash value equals the decrypted session request signature, RAPI proceeds to end the current session (block ).","Returning to , after it ends a session, RAPI  generates a new authority certificate (block ). As described above,  shows the process of generating an authority certificate. RAPI  then sends the new authority certificate back to the access driver  (block ). Upon receiving the new authority certificate, access driver  updates the current authority certificate with information in the new certificate (block ). Accordingly, the information in the new authority certificate will be used to generate requests in subsequent sessions.",{"@attributes":{"id":"p-0146","num":"0157"},"figref":"FIG. 9","b":"1550"},"In summary, the present invention requires the inclusion of a digital signature in session and service requests as a security measure to prevent components foreign to the system, such as viruses, to invoke BIOS functions or services. Furthermore, each successive session or service request includes a digital signature that is generated using a new private key to prevent foreign components from capturing and replaying the session and\/or service requests and causing adverse effects to the system. Thus, the security measure employed in the present invention ensures safe and secured utilization of BIOS functions.","Although the present invention has been described in terms of certain preferred embodiments, other embodiments apparent to those of ordinary skill in the art are also within the scope of this invention. Accordingly, the scope of the invention is intended to be defined only by the claims which follow."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5","b":"46"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6B","b":["610","6"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6C","b":["630","6"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7B","b":["640","7"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 18"}]},"DETDESC":[{},{}]}
