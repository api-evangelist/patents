---
title: Method and system for distributing access to group of objects based on round robin algorithm and only when the object is available
abstract: Object distribution systems and methods for controlling load distribution during access to objects resident on a plurality of computers attached to a communication network. Systems comprise client and server computers attached to a communication network. Client programs are resident on the client computer and objects are resident on the servers. Various objects are grouped together with other objects that perform similar functions into an object group. The methods involve receiving a request for a function performed by objects within the object group, using a distributor to select between the various objects within the object group, and providing a reference to the selected object to the client program.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07043731&OS=07043731&RS=07043731
owner: Qwest Communications International, Inc.
number: 07043731
owner_city: Denver
owner_country: US
publication_date: 20010712
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This invention relates in general to systems and methods for distributing and accessing replicated services across a computer network. More specifically, this invention relates to computer environment constructs and methods of using such which allow for calling and executing computer objects distributed across a network in a way that distributes work across the network and\/or across the objects.","Common Object Request Broker Architecture (CORBA) is a standard from the Object Management Group (OMG) for communicating between self-contained software modules which are distributed across a computer network. Such software modules are commonly referred to as objects. CORBA provides a software based mechanism for locating and accessing objects in a computer network. The basic function of CORBA involves a client program calling another program to perform a function supported by the called program, regardless of where the called program is located on a computer network.","Objects useful in relation to CORBA are defined by an Interface Definition Language (IDL) that describes the methods, or processes, that an object performs and the format of any data provided to or from the object. Such objects can be written in a variety of computer languages and executed by a variety of operating systems. By using an IDL common to two or more objects that provide similar functionality, any of the objects can be accessed to perform the supported function regardless of the language used to implement a particular object or even the platform executing the object. This allows access to objects from any portion of a computer network.","In operation, a client makes requests to a remote object supporting a CORBA IDL via an Object Request Broker (ORB). The ORB provides a proxy object in the client's address space, which creates an illusion that the remote object is local to the client. When the client calls a function of the object, the ORB sends a message to a server where the object is resident. The function is performed on the server and the results of the function are returned to the ORB. The ORB then converts the results to an object reply expected by the client.","Each server supporting CORBA compliant objects advertises the availability of such objects to the network through use of a naming service. Thus, by querying the naming service, a client can determine where on the network a particular CORBA compliant object resides. When a particular object is identified, its object reference can be requested by the client. While this operation allows for accessing objects across a network, it does not provide for distributing operational loads across the network and\/or the objects. Furthermore, it does not provide fault tolerance in a way which maintains a distributed load.","Additional deficiencies in the prior art, and improvements in the present invention, are described below and will be recognized by those of ordinary skill in the art.","This invention provides systems and methods for distributing and accessing replicated services across a computer network. In particular, this invention relates to accessing and distributing objects across a computer network. The distribution is provided in a way that work performed by individual objects and\/or servers on a network is evenly distributed.","The invention provides many advantages including, for example, uniform load distribution across servers and\/or objects. Such load distribution can include both coarse and fine grain load balancing. In addition, some embodiments include local caching of object references which provides for increased performance. Beyond increased performance, such caching can provide for fault tolerance. For example, in some embodiments, the caching functionality includes a periodic check of objects referenced from the cache to assure the objects are operational and available. Objects which are determined to be non-available are removed from the cache and no longer distributed. Such a dynamic approach to object distribution avoids reference to stale or unavailable objects.","In particular embodiments, distribution elements of the present invention can be interfaced with CORBA compliant infrastructures or systems. This standards based approach eliminates the need to comply with proprietary interfaces. Further, by providing for operation in conjunction with existing software services, the present invention provides a non-intrusive approach to object distribution and load balancing.","An embodiment of a system according to the present invention provides for distributing access to objects, where the objects reside on one or more computers attached to a network. The system includes a computer in communication with a network. The computer incorporates a client program, a distributor program, and at least two object proxies. The object proxies are associated with objects resident on servers attached to the network. Various of the objects are grouped into object groups comprising objects which perform similar functions. The distributor program selects between objects within an object group to perform functions for the client program.","Another embodiment of a system according to the present invention provides for controlling load distribution during access to objects resident on a plurality of computers attached to a communication network. The system includes a client computer including a client program and attached to the network. The system further includes a first server including a first object and a second server including a second object, where both the first and the second servers are attached to the communication network. A distributor program receives requests for a function provided by the first and second objects and selects one of the first and the second objects to perform the function for the client program.","An embodiment of a method according to the present invention provides for balancing object and\/or server loads across a communication network. The method includes receiving a request for a function from a requesting program; selecting an object to provide the function, such that the selection involves distributing requests for the function across a plurality of objects providing the function; and providing a reference to the selected object to the requesting program, where the requesting program can access the selected object to perform the function using the reference.","These and other embodiments of the present invention are described in more detail in conjunction with the text below and attached figures.","Referring to , a network environment  includes a communication network , clients  and , and servers  and . In some embodiments, network  is the Internet. In other embodiments, network  is a Wide Area Network. However, it will be appreciated by one of ordinary skill in the art that the present invention can be used in relation with a number of communication networks such as, for example, Local Area Networks (LAN) or Virtual Private Networks (VPN).","Servers ,  can be any computer or other type of machine capable of providing access to objects across network . In some embodiments, servers ,  are web servers capable of providing access to objects across the Internet.","Clients ,  can be any computer or other type of machine capable of communicating with network  and executing code which requests access to objects from servers ,  across network . In some embodiments, clients ,  are personal computers. Client  can include a keyboard , a display  and a database . Similarly, client  can include a keyboard , a display  and a database . It should be recognized that clients ,  can be other types of computers, such as, computers similar to servers , .",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2","b":["200","130","140","130","236","232","234","232","234","140","150","232","232","140","234","234","140","232","234","130"]},"Server  includes an Object Request Broker (ORB) , distributors  and , and object groups  and . Object groups  and  include a number of objects which perform the same function. For example, type one objects ,  may perform the function of monitoring a patients vital statistics and type two objects , ,  may perform the function of monitoring telephone usage. Of course, as the preceding functions are exemplary, one of ordinary skill in the art will appreciate that many different functions may be performed by any number of object groups similar to object groups , .","Objects , , , ,  can be any module of computer executable code. In some embodiments, objects , , , ,  are CORBA compliant. This compliance allows for use of existing CORBA facilities in relation to the objects. Each of objects , , , ,  performs a specified function, receives a specified input, and provides a specified output defined by an Interface Definition Language (IDL).","In some embodiments, a distributor ,  is instantiated by server  for each object group , . Each object group ,  comprises objects which use the same ID and perform the same function. Thus, each of the objects within a particular object group ,  rely on a common naming context. This allows interchangeability of the objects supported by distributors , . Thus, for example, all objects , ,  within object group  and supported by distributor  can provide an Order Service function with a common interface. In part because of this, objects within an object groups ,  can be created from different computer languages. For example, object group  can comprise object  written in the \u201cC++ and Pascal and\/or Java\u201d language and object  written in the \u201cPascal\u201d language. Thus, the actual names and implementation of objects , ,  can be irrelevant. For the purposes of client , either of objects ,  can serve to implement the function represented by object group .","Furthermore, objects within a particular object group ,  can be compiled for different operating environments. For example, object group  can comprise object  compiled for operation under 95\u2122 and object  compiled for operation under UNIX. Again, for the purposes of client , either of objects ,  can serve to implement the function represented by object group .","In operation, either client program one or two ,  requests a remote object supporting a CORBA IDL via a ORB . Via ORB , ORB  identifies the desired object on network  and provides a proxy object in the address space of client . The proxy object creates an illusion that the remote object is local to client . When client program one or two ,  calls a function of the requested object, ORB  sends a message to server  where the object is resident. The function is performed on server  and the results of the function are returned to ORB . ORB  converts the results to an object reply expected by client program one or two , . In some embodiments, this functionality is provided consistent with the CORBA standard. However, one of ordinary skill in the art will recognize other methods of performing the function.","As part of the operation, distributors ,  act to distribute the load of function calls across objects , , , ,  within a particular object group , . Thus, for example, when a function supported by object group  is requested, distributor  determines which of objects  or  will perform the requested function. In some embodiments, this load distribution is performed using a round-robin algorithm. However, it should be recognized by one of ordinary skill in the art that other load balancing algorithms can be used in accordance with the present invention. Further detail of distributor operation ,  is provided below.","In a typical CORBA environment, servers ,  supporting objects , , , ,  register the objects with a Naming Service (NS) . NS  can include names and locations of servers ,  supporting CORBA compliant objects, as well as names of the objects themselves. Thus, NS  provides a mechanism whereby calling programs can determine the location of particular objects on communication network . In an embodiment of the present invention consistent with , NS  includes CORBA compliant objects ,  listed as providing functionality of object group  and CORBA compliant objects , ,  as supporting functionality of object group . In embodiments involving objects dispersed across multiple servers, NS  can include a listing of object groups ,  including objects available on any or all of the other servers.","In some embodiments, distributors ,  rely on NS  to identify and locate objects , , , ,  on communication network . Thus, for example, on any given network, there may be many objects which provide a specific function. NS  provides a list of all such objects along with their locations. Distributors ,  can make calls to NS  to query the identity and location of objects supported by the particular distributor , . In some embodiments, calls by distributors ,  to NS  are CORBA compliant. From this query, distributors ,  can assemble object group , , which includes objects , , , ,  that perform the function supported by distributor  or .","Diagram  illustrates what can be a centralized approach of load distribution. In such a centralized approach, all objects can be accessed via ORB  and identified by NS . Distributor  is responsible for allocating access to all objects within object group , regardless of where the object resides on communication network  (i.e. on server  or any other server on communication network ). Similarly, distributor  is responsible for allocating access to all objects within object group , regardless of where the object resides on communication network .","Such a centralized approach involves instantiation of distributor ,  only on a single server , which simplifies access and development. In some instances, however, a centralized approach exhibits various drawbacks. For example, if distributor ,  fails or is otherwise unavailable, access to the load distribution features of the present invention can be limited. Furthermore, unavailability of distributor ,  can be more frequent because distributor ,  becomes a bottleneck for accessing objects , , , , .",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 3A","b":["301","200","242","244","301","150","130","140","110","150","256","274","276","275","150","140"]},"Distributor  controls access to object group , which comprises objects , , , . Thus, when a request for an object from object group  is received, distributor  can refer the requester to a particular object from one of objects , , ,  resident on either server  or server . Once referred, client  can request the particular object directly from server  or  depending upon the location of the particular object. As illustrated, this embodiment is supported by a single distributor  for object group . Thus, distributor  need only be instantiated on a single server  and implemented in a single programming language for operation in only one operating environment provided on server .",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 3B","b":["300","200","300","150","130","140","110","150","256","291","244","274","276","275","150","140"],"i":"a"},"Distributor is a mirror of distributor  and is responsible for allocating access to any objects , , ,  within object group . Thus, in this embodiment, client  requests an object providing the functionality represented by object group  via either ORB  resident on server  or ORB  resident on server . If this request is made via ORB , distributor  selects one of objects , , ,  to perform the requested function. Alternatively, if client  makes the request via ORB , distributor is responsible for selecting one of objects , , ,  to perform the function for client .","By creating mirror distributor functional on server , access to object group  is available when distributor  is unavailable. Furthermore, a bottleneck does not exist through distributor  to access object group . In some instances, this approach can involve generation of distributors ,  in different programming languages and\/or for different operating environments depending on the languages and operating environments provided on servers ,  where distributors , , will be instantiated. For example, distributor  may be written in the \u201cC plus-plus\u201d language and distributor is written in the \u201cjava\u201d language. Further, some overlap of functionality between distributor  and distributor occurs including, for example, maintaining knowledge of all objects , , ,  within object group . The aforementioned factors can result in a more complex runtime environment. Thus, as will be appreciated by one of ordinary skill in the art, both centralized and distributed embodiments of the present invention are possible depending on the desired results of the application.","Further, it should be recognized that NS  and NS  can provide duplicated functionality. Thus, in some embodiments, both NS  and NS  provide a list of all objects available on communication network . In such embodiments, where either NS  or NS  becomes non-functional, the other NS can be relied upon to identify objects on communication network . In alternate embodiments, NS  only lists objects available on server  and NS  only lists objects available on server . In such embodiments, distributors ,  are responsible for querying both NS  and NS  to assemble object groups , . In yet other embodiments, NS  and NS  are hierarchical where, for example, NS  provides a list of all objects , , , , , ,  on communication network  and NS  lists only objects ,  resident on server . In such embodiments, NS  can rely on NS  to identify all objects on server .","Another embodiment of the present invention-is illustrated as a functional diagram  in . Diagram  includes client  and servers ,  connected via network . Server  includes NS , ORB , and objects , , , , . Server  includes ORB  and objects  and . Objects ,  and  perform the same function and share a common IDL. Similarly, objects , ,  and  perform the same function and share a common IDL.","Client  includes ORB , distributors , , client programs , , and object proxies , , , , , , . Similar to groupings of objects , , , , , ,  described with reference to , object proxies , , , , , , are grouped into object groups , to include object proxies which share a common IDL and perform similar functions.","To client programs , , object proxies , , , , , , appear to be the objects they represent. Thus, for example, client program  requesting the functionality provided by objects represented as object group , can issue a call to object proxy . As far as client program  is concerned, object  represented as object proxy is local to client . In fact, object proxy is merely a shell incorporating a reference to object  on server . The same is true for the other object proxies.","In operation, either client program one or two ,  makes a requests for a particular function supported by one of object group , . Depending upon which object group , supports the requested function, the request is directed to either distributor  or . Thus, for example, if the request is for a function supported by object group , distributor  would allocate which object , , ,  will be accessed to provide the desired function.","In some embodiments, distributors ,  access NS  to identify and locate objects supported by the object group ,  represented by the particular distributor , . Thus, for example, when distributor  is instantiated on client , it queries NS  to identify and locate all objects performing the function represented by object group . From this query, distributor  instantiates object proxies , , and . Included with instantiating object proxies , , , , distributor  assembles a list indicating the location of objects , , ,  corresponding to the object proxies , , , . Thus, when client program ,  requests a function from object proxy group , distributor  returns a reference to a particular object , , ,  from object group. . The reference includes an indication of which server the referenced object resides on. Client program ,  can then access the particular object from the server where it resides.","The embodiment illustrated in diagram  is decentralized. Such a decentralized approach avoids bottlenecks without compromising functionality of distributors , . Thus, failure of client  does not result in the inability of other clients to access objects via distributors , . In such embodiments, the routing intelligence for selection of a specific object to perform a desired function is embedded in distributors , , which can exist in the same process as client programs , . In such embodiments, the failure of any distributor ,  will not effect the functionality of other client programs ,  and\/or other clients  or servers , . Furthermore, a decentralized approach also provides uniform load distribution in situations where clients generate differing loads, and also when clients generate variable loads.","In operation, distributors ,  can be initiated when servers ,  and\/or clients ,  start-up. During start-up, servers ,  and\/or clients , , instantiate distributors , . Referring now to FIG. ,the ongoing functionality of object distribution according to an embodiment of the present invention is described with reference to a flow diagram . Flow diagram  includes a step  in which objects , , , , , ,  are grouped by grouping function . Grouping function  serves to assemble object groups ,  together. Thus, for example, distributor  queries servers ,  to determine all objects providing the functionality of object group  and include a common IDL. Thus, as illustrated, grouping function  identifies objects , ,  for assembly into a common object group . Similarly, object group  is assembled by distributor . When distributor ,  is instantiated, all objects supported by the particular distributor are added as children of the distributor.","In various embodiments, grouping function  relies on NS . In such embodiments, server  first registers objects , , , ,  with NS  and server  registers objects ,  with NS . Distributors ,  can then identify objects for inclusion in object groups ,  through accessing NS . Once the objects are identified by accessing NS , each distributor ,  assembles and maintains a list of available objects. This is illustrated as a distribution function  performing step .","With object groups ,  assembled by grouping function , client  can invoke functions of distributors  and\/or  in step . Functions of distributors ,  are accessed via an Application Programming Interface (API) that defines access to distributors , . In step , client , at the request of one of the client programs , , requests the functionality of an object from distributor ,  overseeing an object group , , which includes objects to support the desired-functionality.","The request is executed by the distributor ,  by returning a reference to client program ,  for a particular object that performs the desired function. Distributor ,  selects a particular object to perform the requested function. Client requests are distributed across objects , ,  and  by distributor  and across objects , ,  by distributor . To do this, each of distributors ,  rotate access to the various objects. Such rotation can be based on a round robin or other distribution algorithm. In some embodiments, the distribution algorithm accounts for the amount of processing required by a particular object in an effort to evenly distribute requests on communication network . Other distribution algorithms include random with uniform distribution and random with Gaussian distribution.","As will be appreciated, distributors provide a parallel naming service such that if NS  becomes unavailable, client  is not affected since distributors ,  are capable of providing references to objects , , , , , , .","In some embodiments, distributors ,  maintain a memory cache listing objects and their availability. This cache is periodically refreshed to assure that a complete object listing is up to date. When a cache is refreshed, distributors ,  obtain a new list of objects , , , , , ,  from NS . In this way, objects recently registered with NS  become available for distribution by distributors , . In addition, objects which have been unregistered and are now unavailable are removed from the cache and references to the removed objects are no longer provided as references to client programs ,  by distributors , .","Also, in some embodiments, either as part of a cache refresh or as a stand alone process, distributors ,  validate objects included within object groups , , which are supported by the respective distributor. The objects , , , , , ,  can be validated by pinging an ORB  associated with the server ,  where the object is resident. In this way, distributors ,  can eliminate any objects , , , , , ,  that might be registered in NS , but that are not actually available. Such validation can be performed at a set time interval, which in some embodiments is user definable, or validation can occur based on a particular event, such as, for example, in response to trigger from a user or client program , . Thus, if one or more objects , , , , , ,  becomes unavailable, distributors ,  can automatically stop providing references to the unavailable object to client . This shields client  from otherwise unavoidable failures. It should be recognized that other tests can be performed to determine the functionality of a particular object. For example, a resource health test, load check, or traceroute test can be used according to the present invention.","In one particular embodiment, distributor ,  makes a call to org.omg.CORBA.Object.nonexistent( )to determine if the object exists and is available to handle requests. If the object is not available, reference to the unavailable object is automatically eliminated from the cache. This prevents distributors ,  from providing references to unavailable objects to requesting clients. By updating the cache in this way, damage related to an object becoming unavailable is reduced and even eliminated.","Where it is detected that NS  is no longer available, cache refreshes can be stopped. Additionally, it should be recognized by one of ordinary skill in the art that a number of cache and cache update schemes are possible. For example, to minimize the network traffic generated by distributors , , the cache refresh interval can be increased. Conversely, where the Mean Time Between Failure (MTBF) of objects , , , , , or servers ,  providing the objects is low, the cache update interval can be reduced to avoid providing references to unavailable objects. Alternatively, where the MTBF is high, and the number of clients is large, the refresh interval can be higher. Additional factors impacting cache refresh can include the number of clients, the number of objects accessed by the clients, and the fault resilience expected by clients , .","In some embodiments, distributor ,  is responsible for distributing multiple groups of objects. In other embodiments, distributor ,  is only responsible for distributing a single group of objects. In such embodiments, several groups of objects can be distributed by a distributor ,  which is instantiated for each particular object group. In this way, the complexity of distributor ,  can be reduced and the amount of memory and code involved in producing the distributor is minimized.","Objects can be requested from a distributor ,  as often as desired. For coarse grained distribution balancing, client  can get an object once, and then use the same object for the entire session. For fine grained distribution balancing across a set of stateless objects, a new object can be obtained every time a method is invoked on the service. A fine grain is defined as breaking down a work load into finer components. To illustrate, in the CORBA context, breaking down a load down to the operation invocation level is fine grained because that is the lowest level at which the load can be distributed. A slightly coarser grained approach would be to break it down to the transaction level. Transactions typically are a group of operations. Thus, chunks of operations are distributed instead of single operations. Finally, an even coarser grain load distribution would be to distribute load at the session level. A session is all the operations that a client invokes from the beginning of a session to the end of a session, and all the operations invoked in a session lasting potentially hours is treated as one chunk. This could amount to a pretty big chunk, but distributing a load in such big chunks is oftentimes more useful than not load balancing at all.","Stateful is defined as some state information on the object which is used across invocations. An example is a shopping cart object. If a customer adds something to their shopping cart, and then adds something again, they would like to be using the same cart across the two add operations. If the customer gets a new shopping cart each time, then the cart is fairly useless. The same concept applies to CORBA objects. If an operation is first invoked on an object, it is desired at the next invocation, a communication to the same object that was made previously. Even if there are two objects exposing the same CORBA IDL interface, the same object is desired each time. Accordingly, this is an example of a stateful situation. On the contrary, in a stateless service, it does not matter which specific object communication is made from invocation to invocation. For instance, an operation such as getCurrentInterestRate is typically stateless, since it can be called one object, and invoked on a different object the next time without any significance. Thus, if the server object is stateful, an object can be obtained and used for invocation of a series of functions that constitute a transaction. After the completion of a transaction, a new object can be obtained for a subsequent transaction.","Some embodiments of the present invention do not assume that all clients generate equal loads on a server. In such embodiments, distributors ,  account for the number of accesses to a particular server, not just the number of accesses to a particular object. Using this information, distributors ,  can distribute a load from client  across multiple servers. Where distributors ,  located across multiple clients  each distribute their load across multiple servers, the net effect is a balance of loads across servers on network .",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 6","b":["500","505","506","501","502","500","520","521","522","520","521","522","140","150","140","150","520","521","522","290","501","502","505","506","520","521","522","505","506","520","521","522","505","506","520","521","522","501","502","505","506","520","521","522","520","521","522","505","506","501","502","505","506"]},"There can be two or more types of refreshes performed when distributors ,  refresh their caches. One refresh type updates object identities from NS . Another refresh type involves examining each object , ,  to determine if the object is available and functional. In some embodiments, this second type of refresh is done by pinging objects , , . In other embodiments, this type of refresh is done by writing a particular message to the object and waiting for a returned message from the object. It should be recognized by one of ordinary skill in the art that a number of methods can be used to determine if an object is functional.","As illustrated in , in steps , , a grouping function  is performed by each of distributors , . Grouping function  involves locating and identifying objects , ,  providing type one functionality (steps , , ) and assembling references to each of the identified objects. The assembled references to objects , ,  are maintained in caches associated with distributors , . In steps , , , distributor  updates its cache by pinging, or otherwise determining the availability of objects , , . Similarly, in steps , , , distributor  updates its cache by individually determining the availability of objects , , . In steps , , clients ,  request functionality from objects , , .","From the foregoing one of skill in the art will appreciate many advantages of the present invention. As some examples, the present invention provides uniform load distribution including coarse and fine grain load balancing and local caching of object references which provides for increased performance. In some embodiments, the present invention can be interfaced with CORBA compliant structures. This standards based approach eliminates the need to comply with proprietary interfaces. The present invention also provides for fault tolerance. Yet further, the present invention offers a non-intrusive approach to object distribution and load balancing as the present invention can be used in conjunction with existing software services. The present invention also offers a dynamic approach to object distribution where stale or unavailable objects are periodically purged from caches and therefore no longer distributed.","A number of variations and modifications of the invention can also be used. For example, the distributors can be resident only on client machines, only on servers, or on a combination of servers and clients. Thus, although the invention is described with reference to specific embodiments thereof, the embodiments are merely illustrative, and not limiting, of the invention, the scope of which is to be determined solely by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A more complete understanding of the present invention may be derived by referring to the detailed description and claims when considered in connection the figures, wherein like reference numbers refer to similar items throughout the figures, and:",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 3A","FIG. 2"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 3B","FIG. 2"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
