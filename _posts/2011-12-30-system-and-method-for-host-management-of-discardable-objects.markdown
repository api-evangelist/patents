---
title: System and method for host management of discardable objects
abstract: A method and system of managing data in a storage device is provided. The method includes receiving a request to store content in a storage device. If the content is discardable content, the content is divided into a plurality of discardable data objects, each associated with at least one type of discarding priority data. The discardable data objects in the storage device are managed based on the discarding priority data associated with each discardable data object. Management of discardable objects may include selection and deletion of discardable objects based on discarding priority data, as well as further subdivision of existing discardable objects, to maintain a desired amount of free space on the storage device. The system may include a host having a processor and a storage device interface configured to execute the method, or a storage device having a processor configured to execute the disclosed methods.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09104686&OS=09104686&RS=09104686
owner: SanDisk Technologies Inc.
number: 09104686
owner_city: Plano
owner_country: US
publication_date: 20111230
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims the benefit of U.S. Provisional App. No. 61\/433,255, filed Jan. 16, 2011, and is a continuation-in-part of U.S. application Ser. No. 12\/720,006, filed Mar. 9, 2010, pending, which claims the benefit of both U.S. Provisional App. No. 61\/159,034, filed Mar. 10, 2009, and U.S. Provisional App. No. 61\/259,418, filed Nov. 9, 2009, and which is a continuation-in-part of U.S. application Ser. No. 12\/645,194, filed Dec. 22, 2009 now U.S. Pat. No. 8,849,856, which is a continuation of PCT App. No. PCT\/US2009\/65056, filed Nov. 19, 2009, which is a continuation-in-part of U.S. application Ser. No. 12\/336,089, filed Dec. 16, 2008 now abandoned, wherein the entirety of each of the above-noted applications are hereby incorporated herein by reference.","The present invention generally relates to a method and to a system for managing files in a storage device.","Non-volatile memory is typically involved in many purposes. Amongst these purposes: storing data, software, applications, operating systems, music, video, games, and more. Non-volatile memory may be embedded in a device or removable. Some storage devices with non-volatile memory are typically used to distribute content such as music, movies, videos and games. Nowadays it is typical that such distribution includes unsolicited content in addition to content intentionally acquired by the user. This type of distribution is not limited to optical storage such as CD, DVD and BD, but may also be included on memory cards such as microSD or USB sticks. These types of flash memory form factors allow for distribution of content for use in devices without an optical drive, such as mobile devices.","Rewritable non-volatile memory provides the advantage that the space used by unsolicited content could be reclaimed once such unsolicited content gets erased. Non-volatile memory can also be used to store additional content after the acquisition of the memory by the user. For example user-generated content could be added. Downloaded content is another example. The non-volatile memory could be used to cache network data in order to improve performance and to optimize the use of the network.","Content services are flourishing and a user can utilize these services to acquire additional content. Similar to the distribution of unsolicited content in non-volatile memory devices, many of these services are also making use of the non-volatile memory to stage unsolicited content. In some cases this unsolicited content is targeted for the user. Such unsolicited content is typically intended to increase the spending of the user and\/or to provide a better user experience. Locally stored content is no longer subject to connection delay, bandwidth limitation and network cost thus resulting in an instant-on user experience with unconstrained content quality.","However, unsolicited content uses storage space that could be needed by the user and may need to be discarded. Furthermore, even certain user-generated content may be unnecessarily taking up space in the memory and could benefit the user by being discarded. Therefore there is a need for a method and system that intelligently manages storage for the user.","In order to address the problem of the accumulation of discardable content, it would be advantageous to store such content for as long as the storage space required to accommodate the discardable content is not required for other data, and to selectively remove the discardable content from the non-volatile memory in order to guarantee a minimum amount of free storage space. Various embodiments designed to implement such file management are provided herein.","In order to address the above-identified need, a method for host management of a non-volatile memory is disclosed. The method includes, in a host to which a non-volatile memory is operatively coupled, receiving a request to store at least a portion of content in the non-volatile memory. The at least a portion of the content is divided into a plurality of discardable data objects that are each associated with respective discarding priority data. The method further includes managing the discardable data objects in the non-volatile memory based on the discarding priority data of each of the respective discardable data objects. Management of the discardable objects may include updating discarding priority data over time for the various discardable objects, further subdividing existing discardable objects into smaller discardable objects, and\/or discarding discardable objects to make room for other discardable or non-discardable content based on discarding priority data for the discardable objects.","According to another aspect, a method for host management of a non-volatile memory is disclosed. The method includes, in a host device to which a non-volatile memory is operatively coupled, receiving a request to store a new data and determining if sufficient space is available in the non-volatile memory. When sufficient space is not available, the method also includes selecting discardable objects to discard from the non-volatile memory. A largest of the selected discardable objects may be divided into smaller discardable objects and certain discardable objects from the selected discardable objects are discarded\/deleted based on discarding priority data associated with the selected discardable objects. Host systems for implementing the above-noted methods are also contemplated.","In another aspect, a host system for managing a non-volatile memory is disclosed. The host system may include a host processor and a non-volatile memory interface configured for communication with the non-volatile memory. The host processor is configured to receive a request to store at least a portion of content in the non-volatile memory. The host processor is further configured to determine if sufficient space is available in the non-volatile memory and select a set of discardable objects from a plurality of discardable objects in the non-volatile memory, where the host processor selects the set of discardable objects based on at least one type of dynamic discarding priority data. The host processor is then further configured to delete one or more of the discardable objects in the set based on at least one type of static discarding priority data.","In another aspect, a method for managing a memory system operatively coupled with a host is disclosed. The memory system includes a non-volatile memory and a processor in communication with non-volatile memory, where the processor receives a request to store at least a portion of content in the non-volatile memory. The processor of the memory system divides the at least a portion of the content into discardable data objects and associates each discardable data object with discarding priority data. The memory system processor then manages the discardable data objects in the non-volatile memory based on the discarding priority data of each of the respective discardable data objects. Management of the discardable objects may include the memory system updating discarding priority data over time for the various discardable objects, further subdividing existing discardable objects into smaller discardable objects, and\/or discarding discardable objects to make room for other discardable or non-discardable content based on discarding priority data for the discardable objects.","In yet another aspect, a method for managing discardable objects in a memory system includes, in processor of a memory system operatively coupled to a host, receiving a request to store new data in the non-volatile memory of the memory system, determining if sufficient space is available in the non-volatile memory and when sufficient space is not available, selecting discardable objects to discard from the non-volatile memory. The memory system processor may then divide one of the selected discardable objects into smaller discardable objects and then discard discardable objects from the selected discardable objects based on discarding priority data associated with the selected discardable objects. Memory systems, including Solid State Disk (SSD) and flash memory card format memory systems, for implementing the above-noted methods are also contemplated.","Discardable content may be of various types. In some cases it is in the form of unsolicited content. In other cases, it may be content that has been requested or generated by the user, but which has a copy or a backup and thus can be discarded when more storage space is needed. As discardable content may be of various types and origin, and may have different purposes, it is important to properly handle priorities in order to determine which data to discard first. The description that follows provides various details of exemplary embodiments. However, this description is not intended to limit the scope of the claims but instead to explain various principles of the invention and the manner of practicing it.","Setting Content as Discardable","There are different circumstances where content may be marked as discardable. By way of example, without limitation, the content source or the application on the host first receiving the content could mark the content with information indicating that it is discardable. In one example, before content may be handled as discardable, it should already be specified as such. Unsolicited content may already be marked as such when received and stored accordingly into discardable object. For example, the application that receives the content could be aware that this content should be marked discardable. A movie service application could check for promotional content and receive this content as discardable.","In another example, solicited content such as user generated data or content requested or owned by the user may be specified as discardable when a copy or backup has been created. The solicited content would be received by the system that handles discardable objects and treated as such. For example, the application that makes the copy or backup would then indicate the content is discardable or initiate the process or perform the steps to make it as such. In some embodiments, where discardable objects are implemented as files, the solicited content file once specified as discardable is then handled as discardable object(s). In other embodiments, the content is moved into discardable objects.","There are also some cases where the unsolicited content stored in discardable object(s) maybe converted to be non-discardable data and treated the same way as requested or user-generated content. For example, when the user purchases a promotional movie title that originally may have been pre-loaded or downloaded through no request of a user. In some implementations, such content could be copied into the user space and be changed back to discardable. In some other embodiments, purchasing or requesting unsolicited content will keep it stored as discardable when a copy exists online. However, the discarding priority data for that content could be updated because the user has specified this is of interest.","As described in greater detail below, the use of a file format is a one implementation of discardable objects. Discardable objects may be handled as individual files and the file system would permit to handle a directory of objects and to manage such objects. As such, creating a file from discardable content means creating a new discardable object and deleting a file mean deleting a discardable object. The file system would also permit discardable objects to be stored fragmented in the memory which allows for optimization of memory usage. Once set as discardable, the content is stored into one or more discardable objects.","Storing Data into a Discardable Object","Content that an application or a user wants to control and explicitly delete would not be stored in discardable objects and would instead be treated as normal content. Discardable objects store content that may be deleted automatically by an underlying system when needed to accommodate the storage of other later received content where the later received content may be additional discardable content for storage in discardable objects or normal data (e.g. non-discardable or solicited content). The underlying system that controls the management and creation of discardable objects is composed of a storage allocator that receives the data to store in discardable objects and that discards discardable objects as needed.  illustrate different scenarios of how the storage allocator may share the non-volatile memory with normal data.","In  A, a system A where discardable content is handled by a storage allocator A is shown. A first dedicated space, such as partition , has been reserved in the non-volatile memory A to store the discardable objects, while a second dedicated space, such as partition  is dedicated to normal (e.g. non-discardable) data. The configuration of , while illustrating one option for configuring the non-volatile memory A, may not permit certain host file systems to dynamically reclaim a reserved space (e.g. partition ).","In the alternative system B shown in , the storage allocator B monitors the available storage space in non-volatile memory . In some embodiments, a single file system is shared and the storage allocator B stores the discardable content as discardable objects and discards objects as needed to free additional space. The storage allocator B could also use a dedicated file system which may be embedded in the file system used for normal data. In such an embedded file system arrangement, the discardable objects may be hidden from normal files and the storage allocator monitors the non-volatile memory B to determine which discardable object has been overwritten by normal data. In the arrangement of  discardable objects are randomly discarded when normal data is written to the non-volatile storage . In the alternative embodiment of , the storage allocator C handles all storage on the non-volatile memory C and thus manages normal data and discardable objects. In this configuration, the discardable objects created by the storage allocator from discardable content may remain hidden from normal file operations while discardable objects may be selectively discarded as needed. The storage allocator C may be implemented on a host, for example as part of, or underneath, the host file system. The storage allocator C may alternatively be implemented in a storage device.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIGS. 2A and 2B","FIG. 2A","FIG. 2B"],"b":["200","202","204","200","202","204","200","204","202","204","204","202","202","207","200","200","207","204"]},"In other implementations, the storage allocator could be implemented partly on the host and partly on the storage device . For example, the host  may be configured to handle selection of discardable objects for deletion and the storage device  may be configured to manage the storage of discardable objects and the file system in a manner that keeps the discardable objects hidden to the file system . In an alternative embodiment, as discussed in greater detail below, the portion of the storage allocator on the storage device  may show all discardable objects as regular content, as if no discardable content were ever deleted from the storage device, and keep source information for tracking the location of all discardable objects so that any missing discardable objects that had been deleted by the storage allocator could be later fetched. This manner of maintaining a list of all discardable objects ever stored on the storage device, and the tracking information on where the discardable objects can be found from their original sources, may be extended to the point where no discardable content is actually stored on the storage device, but could be fetched using the saved file path or other tracking information maintained by the storage allocator on the storage device.","Host device  may be dedicated hardware or a general purpose computing platform having a processor  and a non-volatile memory interface . The host device  may receive content  from a content source, such as a remotely located content server, over a communication channel . In the embodiment of , where the storage allocator A resides on the host , the processor  may execute the storage allocator functions and communicate with the storage device  via the non-volatile memory interface . In the embodiment of , where the storage allocator B resides on the storage device , an API  on the host  allows the host access to discardable objects managed by the storage allocator B on the storage device . The storage allocator B in this implementation may be executed by a processor of the storage controller .","Storage device  includes a storage area  for storing various types of data (e.g., music files, video files, etc.). Storage device  also includes a storage controller  that manages storage area  via data and control lines . Storage controller  also communicates with the host device  via host interface  over a communication channel  that may be wired or wireless. Storage area  may be non-volatile memory, for example NAND flash. In different embodiments, the storage area  may be made up of one type of non-volatile memory or different types of non-volatile memory, for instance single level cell (SLC) and multi-level cell (MLS) flash memory, in various amounts and combinations. Storage controller  controls all of the data transfers to\/from storage area  and data transfers to\/from host device  by controlling, for example, \u201cread\u201d, \u201cwrite\u201d and \u201cerase\u201d operations, wear leveling, and so on, and by controlling communication with host . Storage area  may contain, for example, user data (user-generated) and discardable data objects, protected data that is allowed to be used only by authorized host devices, and security data that is used only internally by storage controller . In order to facilitate easy access to data files that are stored in storage device , storage device  is provided with a file system . Storage allocator  may be hardware, firmware, software executable by the processor of the storage controller  or any combination thereof. Information regarding discarding priority data assigned by the storage allocator  to discardable objects in the storage area  may be maintained in a discarding priority database  or other data structure. The discarding priority database  may be stored in the storage area  or elsewhere in the storage device .","The storage allocator  manages storage area  and the storage of normal (user-generated or solicited) data and discardable data. Managing storage area , or managing storage of data in storage area , may include, for example, generating discardable objects from received content  that is discardable, sub-dividing discardable objects into smaller discardable objects, and selectively removing one or more discardable data objects of one or more different discardable content to free up storage space, freeing a storage area by removing all files marked as discardable, and remapping clusters of a file to a lower-performance storage module. Managing storage area  or files stored therein may include managing other, additional, or alternative aspects of storage area  or files stored therein.","Discarding Priorities","Some content may be worth keeping longer than some other. For example, a daily news story can typically be discarded on a daily basis when the latest news is received. As such, it is important to use priorities to determine what is best to discard from the storage area  to accommodate a storage request, whether the storage request is for normal (solicited or user-generated) data or additional unsolicited content. The storage allocator  may assign discardable data a discarding priority.","Because some content may be worth keeping longer than other content, not all content will have equal discarding priorities and therefore discardable object(s) associated with a first content may not have the same discarding priority as discardable object(s) associated with a second content. Also, some parts of the same content might be of more interest for the user or host application than others, and thus discardable objects used for the same content could have different priorities.","For example, the discarding priority may be set by the storage allocator  according to discarding priority data such as content type (e.g. music files could be anticipated to be listen more times than a large movies file would be watched, so the discardable object or objects created for a large movie file may be assigned a discarding priority (overall or relative rank) that is greater than that of a music file such that the discardable object(s) for the large movie file would be more likely to be discarded than those of the music file). The determination of a discarding priority for a discardable object by the storage allocator could take in account any of a number of discarding priority data being tracked by the storage allocator, including the overall size of the content stored in one or more objects. For example, a larger file might be seen less than smaller content duration. By extension, in implementations where the size of the discardable objects is independent of the content, a discardable object that can fit an entire file should be discarded with lower priority. The discardable content could also be less discardable when the source is on the storage device as the copy may not be guaranteed.","The discarding priority could change as conditions change. For example, when content has expired it could become more discardable; for content that has just been activated (e.g. released from embargo) the discarding priority could be changed to reflect that the discardable object is now available; and content that has been purchased could be become less discardable as the user's interest in that particular content have changed. Accordingly, in some embodiments, the priority assigned or modified by the storage allocator  could also take into account whether the content has been solicited or has always been discardable.","The selection of discardable objects to discard may be based on the above type of information alone that is still somewhat static, but having a discard priority based on static information may not reflect the user's current interest in the discardable object. The relevance of discardable content could also take in account information that changes relative to the access of one discardable object in the entire set of discardable objects for the particular discardable content. This information allows selecting a discardable object relative to other discardable objects using dynamic information instead of, or in addition to, static information.","The discarding priority data used by the storage allocator to perform the selection of objects to discard could be based on the static information or the dynamic information or both. Static information is useful as it typically provides information about the content as a whole, such as a type of data (e.g. a temporary file) or an age of the discardable content as a whole (e.g. the original storage date on the storage device of the discardable content). Dynamic information refers to information on access to individual discardable objects within a particular discardable content and thus provides information on the user's interest in specific portions of the discardable content. The use of discarding priority data by the storage manager  to determine priorities or otherwise select discardable objects for deletion provides more flexibility than a simple first in first out arrangement typical of caching solutions. Furthermore, the discarding priority data permits decisions on discarding to be made at the level of discardable objects that may only contain part of a piece of content.","In one embodiment, the storage allocator  may first select a list of candidate object(s) to discard based on dynamic, or both dynamic and static, discarding priority data and then to use one or more types of static discarding priority data to determine which of the discardable objects in the selected candidate objects to discard. Information about the incoming data storage request could also be used to determine the best discardable object to discard. For example, the storage space needed to accommodate the request could be used as a criteria and a discardable object of the closest superior or equal size could be discarded in order to reduce the number of objects discarded to accommodate the incoming data storage request.","For example: dynamic information such as the last access date, the number of user accesses to all or a part of the discardable object(s) content, and the size of the discardable object could be used by the storage allocator to perform the selection of candidate eligible discardable objects to be discarded. Then the static information may be used to decide which one(s) of the selected discardable objects should be discarded. The selection criteria could also combine multiple parameters and also combine dynamic and static for the pre-selection or to determine which object to discard. One goal of the storage allocator  is to set discarding priorities that result in a maximum number of the most relevant discardable objects (those that the user or applications would likely most want to have access to) stored on the non-volatile memory.","It is also important to note that the discarding priority could be set explicitly. For example, if relevance of discardable objects is based on the last access date, discardable objects for content that has been activated (e.g. released from embargo or purchased) may have its discarding priority set by the storage allocator  as if just accessed in order to prevent the content to be deleted.","In some embodiments, the storage allocator  may store the discarding priority data in a database  in the storage area  or some other area on the storage device . The database  could be updated each time a discardable object is accessed and when the status of the content as a whole (from which the discardable object was created) changes. The database  may provide a versatile solution for handling the different types of discarding priority data and the many criteria used as discarding priority data could be tracked and updated.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIGS. 3-5","FIG. 3"],"b":["204","206","302","304","306","306","304"]},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 4","b":["204","402","404","406","404","406"]},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 5","b":["502","504","220"]},"In some other embodiments, rather than the storage allocator  storing discarding priority data on the discardable objects and\/or discarding priorities for the discardable objects in a discarding priority database  as noted above, the file system allocation table (FAT) itself could be used to store such information. For example, if the discardable objects are stored as files, storing discarding information may done in an unused portion of a file allocation table (FAT) entry associated with the file, by setting one or more unused bits. Because different file systems have different structures, marking files as non-discardable, or discardable data objects as discardable and assigning discarding levels, is adapted to the file system structure used. In a file system such as FAT32, the four uppermost bits in an entry are not used and some or all of these bits could be used on one side to recognize (mark) discardable content and on the other to set a priority state (e.g. based on content type). A file system file directory typically contains information about the size, creation date and last access date for all of its files. As discussed in greater detail below with respect to selection and deletion of discardable objects to make room for incoming data, this could be useful dynamic discarding priority data with which to perform a pre-selection of discardable objects (files), followed by use of the static discarding priority data stored in the uppermost bits of the file system to determine which file(s) of the pre-selected files to delete.","In some embodiments, some information useful for assessing priority is already available in the file system in the form of information such as last access, age, and etc., while the other discarding priority data is stored in a database or table. In one embodiment, information regarding static discarding priority data may be maintained separately from information regarding dynamic discarding priority data so that updates may be independent and making it easier to update dynamic information and to perform a pre-selection of discardable objects, as discussed below, based on static and\/or dynamic discarding priority data.","In one implementation, the file system could suffice to handle discarding priorities: information such as last access, size, and file extension already maintained in a typical file system may be used as some of the discarding priority criteria. Other discarding information could be encoded in the unused upper most bit of file system entries.  shows an example of using FAT32 upper most unused bits for storing discarding information.","Objectification Strategy (Creating Objects to Hold Content Data)","Having data stored locally, such as on a storage device , offers multiple advantages to a host device , such as a smart phone, tablet or other mobile host, including access without network latency and longer battery life because wireless communication may be reduced or eliminated at the time of user access to the already stored data. Local storage of data not only provides a better user experience, but also can reduce the amount of data that needs to be transferred over a cellular network, because the data may have been stored locally while the host was in communication with a Wi-Fi network or the data was transferred outside of peak network usage times, which is valuable to the network operator and to users with limited data plans. The benefits may be maximized when the data most relevant to the user is present locally. Therefore benefits are obtained (1) when the discardable object of least interest to a user is discarded first and (2) when the discardable objects retained in the storage device  store data from a maximum number of relevant content pieces. In order to maximize the number of different content that is represented, for example maximizing the number of different files (content pieces) represented, each of the different content may be stored in one or more discardable objects. Storing each of the different content pieces into multiple objects allows discarding the least relevant part or parts of a particular content piece while maximizing the number of different content pieces being represented, even if only partially. One should note that a user might not be interested in the content in its entirety. For example, the user can skip to a specific part of the movie (or skip a part of the movie); a game resource file might carry multiple levels that are not played anymore, etc. As the pattern of user access to a given piece of content is not necessarily linear, the part of the content being accessed might still be present even if the file or other type of content is not complete. By breaking discardable content into multiple discardable objects, and associating with the discardable object the position of the data in the overall content, the storage allocator  allows for identifying the missing parts for later retrieval.","Storing discardable content in multiple objects may avoid or reduce the impact of the following constraints and limitations:","The content has to be received in full. This could be a limitation when the file is downloaded using a progressive download as the download could be interrupted before the file is downloaded in its entirety. Requiring a complete download of the content could also be a limitation when receiving a stream. Keeping a discardable content piece in full, for example an entire file or an entire streamed movie, takes more space than keeping only the relevant portions and thus prevents maximizing the number of relevant content being present even if partially. Managing discardable content in full, for example discarding an entire file or an entire streamed movie in response to receiving additional data, may lead to freeing more space then actually needed for the received data. Therefore splitting the content such as a file or data stream into multiple discardable objects presents multiple advantages. As used herein, content or a content piece refers to a collection of related information, which in the context of a file may be a title (such as a music title) or in the context of streamed data may be a collection of related streamed content. In one embodiment, the storage allocator may be configured to favor maintaining a maximum number of different discardable content (content pieces) by adjusting determined priorities for discardable objects of each of the different discardable content such that a last discardable object for one content piece would be determined by the storage allocator to be less discardable than discardable objects for another content piece having multiple discardable objects in the storage device.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIGS. 7 and 8","FIG. 7","FIG. 8"],"b":["702","802","204","702","802","704","804","204","706","806","708","808","704","804","702","802"]},"The data for the discardable stream of data need not be received in order or even as a continuous chain. If the received discardable data pertains to a streamed\/progressive download video, where the user has skipped portions of the video being streamed, then those skipped parts would be missing to begin with and the order of data received would not conform with the order of data in the complete file. The storage allocator  stores the order the discardable objects are chained together in discardable content to ensure the order remains known. The storage allocator  keeps track of objects that have been discarded or which have not been received. Information on the order of a discardable object chain may be maintained in the discarding priority database or other data structure in non-volatile memory or elsewhere in the storage device. Content split into multiple discardable objects is still presented to the application and user as a single content piece, i.e., the storage allocator exposes content rather than objects.","Saving information about the parent content could be of importance for embodiments where the missing part could be fetched. For example when objects with that part have been discarded or the part was never stored in a discardable object. In that situation, keeping information about the chain of objects representing the content independently from when the part was received could be of importance in order to determine if a part is missing or not.","Also, discarding a discardable object that contains part of the content can be done not only according to the relevance of the object but also according to the entire content. For example, when the content has expired, the discarding priority for all the objects containing data from that content can be changed.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":["FIG. 9","FIG. 9"],"b":["902","904","906","904","906","908"]},"As noted above, one technique for managing discardable objects is for the storage allocator to use a discarding priority database . An alternative is for the storage allocator to use a file system. Discardable objects may be formed from a single piece of content and are tracked individually. A typical file system allows for creation of discardable objects of different sizes for deletion of individual discardable objects. Each discardable object may be associated with attributes such as static and dynamic discarding priority data, along with a discarding priority derived from the static and dynamic discarding priority data. Information about the source of the discardable content, such as file path or Universal Resource Identifier (URI) information, and position in the content of discardable data objects formed from the content, as discussed above, may also be kept. The file path (or URI) may be used to uniquely reference each discardable object. Although the discardable content may be in any of a number of formats, for ease of reference in the following example the content is referred to as a file (which may be a complete file or partial file) and the data objects created from the file referred to as file elements. Discarding an object would mean deleting the file element that represents the object. Creating an object would mean creating a new file element.","The content data , which may be a complete or partial piece of content (e.g. a complete file or a partial file) , is marked as \u201cdiscardable\u201d in a data structure , which may be a discarding priority database or part of the host file system, and divided up into a plurality of discardable data objects . Each data object  is associated with respective discarding priority data  so that the storage device  may manage individual discardable data objects  of the same discardable content  separately. The entire discardable file , now a collection of discardable data objects , may be optionally associated with discarding attributes  that contains additional information such as URI, expiration date, embargoed date, and etc. Each discardable data object , as discussed in greater detail below, is a portion of the discardable file and each discardable data object  may be of the same size or different sizes. All of a discardable file (or partial discardable file), or just certain discardable data objects of one or more of the discardable files (or partial discardable files) may be removed later to reclaim at least the free storage space required to maintain a desired amount of free space in the storage device or to make space for incoming data.","Because the likelihood of the user using the various discardable files may differ from one discardable file to another, each unsolicited file (i.e., each discardable file) may be assigned in advance a discarding priority level. In addition, each of the discardable data objects  of a discardable file  may be associated with discarding priority data  with which to determine a discarding priority level. The discarding priority level may be assigned based on one or more criteria such as the probability of using the file, the probable revenue associated with using the file, the file's size, the file's type, the file's location, the file's age, etc.","Additional information, such as file name and extension could be used to recognize the parent content (e.g. complete piece of content such as a complete movie, song or file) and the position of the object in the chain of discardable objects that make up the content. This may be accomplished in a similar way as done by applications such as those that create .zip files. The compression of a .zip process could be a benefit, but is not a requirement for discardable objects. Furthermore, the file elements created from the file may not be of identical size as typically done with spanning.","Recording information about the remote content URI (the source content URI and the URI of content backup\/copy) as part of a discarding attribute  allows the storage allocator  to fetch any missing parts. The URI could point to any type of data and could have extra information about the access protocol.","Extra information may be stored along with the URI, such as information to determine if the content has been changed since it was stored. For example, a hash of the content or a date stamp could be used to determine if the content has changed. Accordingly, in one embodiment, actions could be taken to update the local copy. For example, the host application or storage allocator may decide to update the content with the updated content it recognizes from the difference between the hash of what the content looked like at the time of acquisition and what the application sees the next time it accesses or checks over the source content.","Keeping track of the content URI may help the storage allocator  to keep track of all the content that has ever been stored, even partially, on the non-volatile memory . The information could be presented in a way for the user to easily re-access some of this content. For example, the content could be presented ordered by type, access date, cumulative number of accesses, etc. The user could also be asked to confirm when a connection is needed to acquire missing pieces, etc.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIGS. 10 and 11","FIG. 10","FIG. 10","FIG. 11","FIG. 11"],"b":["1002","1008","1004","1006","1008","1002","1106","1108","1110","1102","1102","1104","1106","1002","1102"]},"Determining Discardable Object Size","The amount of data that a discardable object holds may have a direct impact on performance and thus on the user experience. For example, allowing large discardable objects may limit the number of content pieces (i.e., different content such as different movies, songs, or other data) that may be represented in the non-volatile memory  of the storage device  which could have a direct impact on performance and user experience.","There are different ways for the storage allocator  to set the size of each discardable object:","a) All discardable objects could be created to have a same size and that size could be determined according to a percentage of the maximum possible capacity available for the discardable objects, where the maximum possible capacity for the discardable objects may be preset for a particular type of storage device ","b) All discardable objects could be of same size where the size is determined according to a maximum number of discardable objects that the system could handle. For example, this would be typical of using a file system where the maximum number of clusters determines the maximum number of entries.","c) Discardable objects of preset size may, however, result in a mediocre user experience for multimedia content that contains an index directory and\/or frames. If the information for of these sections (e.g., index directory or frames) is stored in more than one object, discarding a discardable objects with part of that type of information may result in the rest of the data for that content being unusable and thus requiring that the storage allocator fetch the missing parts. As such, in another embodiment, the storage allocator may split the discardable content into discardable objects that relate to the content specificities: for example matching the content index or storing an entire number of frame(s) in a single object.","d) The discardable content may also have information about the parts which are the most relevant for most users and thus these parts could be stored on one or more discardable objects only containing the most relevant information to permit the less relevant parts to be discarded at first. The discarding priority could also be set to recognize that these discardable objects are less discardable than other discardable objects for the same content. Information about the most interesting parts of particular discardable content may be provided by the server from which the content is received, or from the host, in order to determine how to split the content into multiple objects as well as the size of the size of each of the discardable objects.","e) Application resources could be split into discardable objects that relate to the application itself. For example, a game resource file which holds multiple levels could be split so that each level fits into one or more discardable objects only containing data for that level (i.e., no object having information from two different levels). For example, information about each level could be provided by the game application to the storage allocator and the resource file split accordingly. In some instances, the resource file could use a format that comes with different sections where each would be stored (at start) as an individual object.","f) In a more sophisticated implementation, the size of discardable objects could also vary during the lifetime in the storage device . Although the size of discardable objects created by the storage allocator, whether they are the same or different size with respect to each other, may remain the same during their lifetime, there may be instances where it is advantageous to change the size of an already existing discardable object. A discardable object may be split into smaller discardable objects over its lifetime. In order to facilitate this subdividing of existing discardable objects, the underlying system, for example the storage allocator  and discarding priorities database , tracks information about storage elements whose size is smaller or equal to the size of the discardable object. The splitting of a discardable object into smaller discardable objects may be accomplished by using dynamic information regarding the tracked storage elements within the discardable object. Thus, in selecting a discardable object to discard, the storage allocator could use such dynamic information and in the process the object could be split into smaller objects whose size is determined according to the dynamic information itself. The least relevant parts of the data in a particular discardable object could then be discarded first.","This approach of further splitting a discardable object is of particular interest as it allows optimizing the size of the objects without any particular knowledge of the content type. For example, it does not require parsing the content to identify the index and\/or the frames. In an alternative embodiment, the storage allocator  could initially store a piece of content into a single discardable object, rather than automatically creating a plurality of discardable objects upon receipt for that content, and then use the tracking of the storage elements within the initial discardable object to determine where to split the discardable object. For example, the object may be selected at first because it meets certain criteria such as a large size then the object gets split based on the tracked information of the storage elements within the discardable object. A new selection could be performed, or least relevant parts could be discarded at first. The split process could repeat itself multiple times and the content ends up being stored on one or more objects of smaller size. For example, when discardable objects are implemented with files, the tracked storage elements that are smaller than that the discardable object may be file system clusters that could be tracked to determine how to split a discardable object file.",{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 12","b":["1202","1204","1206","1202","1206","204","1206","1","2","3","4","1208","1210","1204","1206","1200","204","2012","1208","4","1202","1200","206"]},"Discarding Strategy","As noted above, a purpose of creating discardable objects is to provide flexibility in generating free space on a storage device for new non-discardable or discardable content, while maintaining discardable content most relevant to a user on the storage device. Before a discardable object gets discarded, it is important to perform a selection to determine which discardable object(s) should be discarded. In one embodiment, the selection of discardable objects for deletion may be based first on dynamic information tracked for the objects and then according to each discard priority for the selected discardable object(s).","One or more of the following types of dynamic information may be considered when selecting eligible discardable objects to discard: Last time of access; number of accesses (e.g. plays): cumulative or within a past time window including a present time; and expiration status. Other dynamic information considered may be the space needed to store the data (e.g. could be better to impact a single content than many) and object size. The above examples of dynamic information are examples only and other types of dynamic information are contemplated.","Other information such as content type, overall size, may be considered for setting the priority as it is state rather than usage dependent. Yet priority could change also as some states could change as well. For example, a copy of the content could have been created, making the locally stored content (and its associated discardable objects) more discardable; or previously discardable content has been activated (purchased or authorized) making the associated discardable objects less discardable or non-discardable; and so on.","The selection of discardable objects to discard from the non-volatile memory by the storage allocator  is typically done using a range rather than a point selection, where point selection refers to performing a selection that returns at first a single result. For example, a selection that would always return the least accessed object or the oldest object. Although point selection of discardable objects by the storage allocator is contemplated in some embodiments using one or a combination of types of the discarding priority data, using a range selection process is contemplated in other embodiments. Range selection takes advantage of the discard priority to refine the selection, otherwise the most discardable object from the selection using all criteria is always discarded at first. For example, the selection of a range of candidate discardable objects for further consideration for discarding could be based on dynamic discarding priority data such as all objects whose last access is older than one month, instead of the object with the oldest access time. As another example, the storage allocator  may base the selection on the 20 least accessed objects rather than the least accessed.","The selection process may also combine multiple parameters, for example starting with expiration status, then last time of access, then number of accesses. When the selection returns no result, the range could be enlarged to potentially include more objects and point selection could be done at the end. Once the selection of candidates has been made, the discardable object(s) to discard may be selected according to the space needed and to the priority level. The discardable objects set with a more discardable priority are discarded as needed. When multiple objects eligible to be discarded have the same priority then the largest could be discarded first.","Some embodiments for selecting and discarding discardable objects may take advantage of the pre-selection of a range of discardable objects to split the largest discardable object in the selected range and then refine the selection based on the updated group of discardable objects, and deleting the least valuable discardable object first.  illustrates a process  of discardable object selection and splitting for freeing space for new data. When a request to store new data (non-discardable) or discardable content is received (at ), the storage allocator determines whether there is a need for more storage space (at ) according to a pre-determined threshold or to available space. If sufficient space is available, the new non-discardable data is written to the non-volatile memory , or if the request was for storing discardable content, the storage allocator  stores the discardable content into one or more discardable objects in the non-volatile memory as discussed previously.","If the storage allocator  determines that there is insufficient available space, the storage allocator begins a process of selecting discardable objects to discard from non-volatile memory  (at ). A determination by the storage allocator as to whether there is sufficient space available for a request to write data may be based on a fixed or variable threshold amount of free space that the storage device is required to maintain, or on other criteria. In the embodiment of , the storage allocator preselects discardable objects based on discarding priority data, or priorities determined from the discarding priority data, and information in the discarding priority database  to determine the most discardable group of discardable objects (at ). Then, the largest object in the pre-selected discardable objects may be split as discussed above (at ). If all pre-selected discardable objects are of same size, the splitting step may be skipped. Next, at , the list of pre-selected discardable objects is updated to replace the split discardable object with the resulting smaller discardable objects. Each new discardable object is set with a discarding priority (or assigned discarding priority data) that could take in account the information used to split the object. The list of pre-selected discardable objects is rearranged according to discarding priorities including the priority of the new objects and one or more discardable objects from the list are discarded as needed (at , ) to free up the necessary space. Finally, the new data could be stored or new discardable content stored into one or more discardable objects (at ).","Discard Triggers","The memory available for the storage of discardable objects is typically not unlimited and at some point adding new discardable objects may require discarding objects already stored in a manner such as discussed above in . The memory limitation could be physical (i.e. not enough storage available) or specified (i.e., accommodating the request reaches a threshold such as remaining storage for discardable objects, available storage for other data or total number of discardable objects). As such, when the space available for the discardable objects cannot accommodate a request to store discardable data because of the limit, one or more discardable objects need to be discarded. In that case, the underlying system managing the discardable objects would select an object or objects to discard and discard as many as needed. The storage allocator may then store the discardable data into one or more discardable objects along with other needed information such as object reference, position in a chain, and priority. In certain instances, there might be a situation where the received discardable data is more discardable than the selected objects and thus the storage allocator would discard the new discardable content instead of any of the selected objects so that no new content would be placed in discardable objects and no change would be made to existing discardable objects.","In some embodiments, the memory used to store the discardable objects could also be shared with data which is not for discard and, in that case, the size of the memory available for discardable objects is variable and could change over time. When data not for discard is removed (deleted), more space is potentially available for discardable objects. On the other hand, when more data not for discard is stored, less space is potentially available for discardable objects. Embodiments of this type ensure that the user is not penalized by the presence of discardable objects and that the user's storage space remains available for user-generated or other non-discardable content.","Discardable objects may also be discarded independently from the need for more storage space triggered by receipt of new non-discardable data or discardable content for storage the non-volatile memory. For example, when the content is taken down\u2014for example when not authorized by the content owner\u2014objects that store this data should be discarded right away. The underlying system typically includes an API to allow explicit discarding of one or more discardable objects in such situations. For example, a host application could receive information that a content piece has been taken down and would use such an API to explicitly discard the objects used to store such content.","Implementation of Handling Discardable Objects","A host file system provides one way to manage discardable objects which could be stored as individual files and could be of various sizes (and could also support embodiments with objects of identical size). A discardable object in the form of a file could be created, split and deleted as needed thus providing support for various features of discardable objects discussed above. In one embodiment, a naming convention may be used to determine the chain of object. The naming may be accomplished in a similar way as done by applications such as ZIP applications, where compression could be a benefit but is not a requirement for discardable objects. A more sophisticated naming convention may be used to support splitting discardable objects. For example, the base name for a discardable object could be based on the hash of the URI of the content location. That base name could be appended with a number to define the chaining. Finally, splitting or re-splitting a discardable object could extend that naming with additional numbering. One example for naming discardable objects is provided in . In , the base name  for a discardable object may be a hash of the URI of the source of the discardable object. When the discardable object is split into three smaller discardable objects, the resulting discardable objects may have an extension number  (e.g. .001, .002 and .003) to the original name . A further splitting of the already split discardable object may add a further extension  to the name of the already split discardable object (here the .003 object was further split into .003-.001 and .003-.002). Subsequent splits may follow the same format as illustrated in . The naming approach discussed above, relating to using a hash of the URI of the discardable content, is not limited to use in the splitting of discardable objects and may be used generally to name discardable objects.","Implementation of Handling Priorities and Dynamic Information","Some implementations could use the file system to store the discarding priority data and take advantage of the file system for information such as age, last access and using the file extension to determine the file type.","Referring again to , an exemplary partial FAT32 table  is shown as a double-word (\u201cDWORD\u201d) array, and the values are hexadecimal values. Reference numeral  designates the type of device holding FAT32 table , where \u201cF8\u201d refers to a hard drive. FAT32 table  includes 23 clusters that are designated as cluster #1 (shown at ), cluster #2 (shown at ), . . . , and cluster #23 (shown at ). A cluster in FAT32 table  may be the first cluster of a file, or it may point to the next linked cluster of the file, or it may be an End-of-File (\u201cEOF\u201d) indication.","As shown in , first hypothetical file begins at cluster #2. The value of cluster #2 (i.e., the value \u201c000 0003\u201d) points (shown at ) at cluster #3, which is the next file's cluster. Likewise, the value of cluster #3 (i.e., \u201c0000 0004\u201d) points at cluster #4, which is the next file's cluster. Cluster #4 has the value \u201c0FFF FFFF\u201d (\u201cF\u201d is the hexadecimal digit that represents the decimal value \u201c15\u201d), where \u201cFFF FFFF\u201d (shown at ) denotes the file's EOF indication, and the zero value (shown at ) denotes discarding level 0. The hypothetical file, therefore, has associated with it three clusters (i.e., cluster #2, cluster #3, and cluster #4). In the example of  discarding level 0 may represent a non-discardable files and the most significant hexadecimal digit of each cluster of a particular file is set to the same discarding priority level. A discardable file that starts at cluster #5 and runs through cluster #12 may be assigned a discarding priority level other than 0, such \u201c1\u201d. Therefore, the most significant hexadecimal digit of each of clusters #5 through 12, which pertain to that file, has the value \u201c1\u201d (for example as shown at ). In this embodiment, the most significant hexadecimal digit or, equivalently, the four uppermost bits of the clusters associated with a particular discardable file are set to the same value corresponding to the discarding priority level assigned to the particular file. The number the uppermost bits used for indicating the discarding priority level may differ from four. The example of  is a simplified example of one of many options for tracking discarding priorities and information using a file system data structure. Although the ability of greater granularity in tracking discarding information using a separate discarding priority database  may be preferred in some embodiments, a file system data structure such as a FAT32 table  may store some or all of the discarding priority data in other embodiments.","In some embodiments, the discarding priority data could be stored as part of the file system as explained earlier. However, other implementations would favor storing the static and dynamic discarding priority data, along with any priority determined from the static and\/or dynamic discarding priority data, in a file which, to facilitate the selection of objects to discard, could be formatted to hold information in a table or a database such as the discarding priority database . Using such an approach could provide more granularities in tracking the criteria used to determine the discarding priority. Such a file could also store extra information such as URI of remote content location and URI for all matching objects stored locally. Every time a file with discardable data is accessed, the information associated with the file gets updated. A file system typically operates in a manner where a cluster is the smallest amount of information that maybe addressed directly. Accordingly, in some embodiments, access tracking maybe done at cluster level rather than file level. This method would permit the splitting of a discardable object (that is larger than a cluster) into smaller objects as discussed above. The underlying system could monitor the cluster information and when a certain threshold is reached, split a file into smaller files according to the relevance of its clusters as discussed with respect to  above. Other implementations could combine approaches, for example of using a FAT for static discarding priority data and a database for dynamic discarding priority data.","Implementations of the Storage Allocator","The storage allocator could be implemented in different ways. One approach is to implement the storage allocator as part of the file system API for example as illustrated in . As such, the storage allocator can transparently handle both the normal file as well as the files by the discardable objects. Such an implementation provides the best approach because it ensures that both types of content (non-discardable and discardable) can share the non-volatile memory without overlapping each other. Other implementations could be considered as well.","In some embodiments the storage allocator is an implementation of a file system that comes with extra features that permit it to handle discardable files and that takes care of selecting and discarding files when needed. In other embodiments, the storage allocator may be implemented on a host device using an API provided for a file system filter. As such, the storage allocator does not have to manage the file system but could intercept calls to a file system API and pass those intercepted calls to a file system filter when needed. Having the storage allocator as part of the file system's APIs could permit the storage allocator to hide a discardable object file from normal file operation, for example by having a file system filter in the file system API prevent the listing of discardable objects when a listing of data on the storage device is requested. In contrast, it could also permit the file system to expose content in response to a file system directory command which may be present only in part or no longer present on the storage device. Alternatively, the storage allocator could present a list of all the content that has ever been on the storage device, either in part or in full, even when all discardable objects related to such content have been discarded. In this latter implementation, the list would be associated with URI or other tracking information, maintained in the discarding priority database or other location in the storage device, can provide a link to the source of the information for later fetching. By extension, content that has never been on the storage device could also be listed. One way of marking a file as discardable may be to add a name extension to a file name that would be interpreted by the file system filter as requiring that information to be stored as discardable. Thus, the file system filter could be implemented as a part of the storage allocator (providing a portion of the functionality of the storage allocator as described herein).","Implementation of Split Storage Allocator","As explained earlier, in some embodiments the storage allocator is located in part or in whole in the storage device. In these embodiments, the file system API is typically managed on the host but the storage allocator handled by the storage device (e.g. the controller) can still manage the files or other type of discardable content adequately to enable discardable files by monitoring all incoming requests. Furthermore, a specific API maybe provided by the storage device for the host to use in order to create, access, delete and update discardable files.","Because the host has its own image of the file system, the storage allocator would have to operate underneath the host file system and be careful not to impact it. Flash storage devices typically use LBA (logical block addressing) to separate from actual PBA (physical block addressing). These devices typically use LBA to PBA conversion in order to reach the actual data. A similar approach could be used to ensure that normal files (non-discardable content) could share the storage space with discardable files (content).",{"@attributes":{"id":"p-0113","num":"0112"},"figref":"FIG. 15","b":["1502","1504","1506","1508","1510"]},"As the storage allocator is closely involved in managing the location of the discardable objects, such object files could be created preferably in areas where the memory would support a larger number of read\/write cycles. This could be important for non-volatile memory such as NAND flash where the physical limit of read\/write cycles could be reached in a limited amount of time with transient content.","In certain implementations, such as shown in , the storage allocator could be network ready and be capable of fetching missing data when needed. This capability opens the door for additional integration where the storage allocator could be integrated with the network stack in addition to the file system in order to provide some local proxy functions. Such integration could be done in the network stack or with a proxy locally installed on the storage device.","Systems and methods have been described for freeing space in a storage device by automatically deleting certain types of data referred to herein as discardable content. The discardable content may be partial or complete files, streamed data or other types of data that was unsolicited by a user or application, or that was generated or requested by a user but has become discardable because of subsequent activity such as the creation of a back-up copy that is readily accessible. The space used for discardable files may be released automatically on user need and based on user interest, which is different than setting aside some reserved storage which is a technique used in some applications such as Internet Explorer. Through the use of discarding priority, taking into account parameters that may be static and relating to whole content or content pieces, or dynamic and relating to access activity for discardable objects for content, or data elements within the discardable objects) or both, allows the discardable objects to be ranked. The most relevant of the discardable content may then be retained by deleting less relevant discardable data. The capability of retaining only the most relevant discardable data is further improved by breaking down discardable content into multiple discardable objects, and then further subdividing those discardable data objects when appropriate to allow a finer granularity of maintain only the most relevant portions of discardable content. Discardable objects for different content may be given preference to maximize the number of different content represented in the discardable objects that are retained in non-volatile memory. The systems and methods disclosed herein may also assist in providing copy protection for locally stored content through automated takedown procedures that may be initiated separate from receiving a request to store new data that triggers deletion of appropriate discardable content to free up space. Accordingly, a system and method for managing use of a non-volatile storage device as transient storage where data could be discarded to release space to store more relevant content to the user has been described."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIGS. 1A-1C"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 2B","FIG. 2A"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIGS. 3-5","FIG. 2"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 14","FIG. 13"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 15"}]},"DETDESC":[{},{}]}
