---
title: Scalable geometry processing within a checkerboard multi-GPU configuration
abstract: Systems, apparatus and methods are described including distributing batches of geometric objects to a multi-core system, at each processor core, performing vertex processing and geometry setup processing on the corresponding batch of geometric objects, storing the vertex processing results shared memory accessible to all of the cores, and storing the geometry setup processing results in local storage. Each particular core may then perform rasterization using geometry setup results obtained from local storage within the particular core and from local storage of at least one of the other processor cores.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09619855&OS=09619855&RS=09619855
owner: INTEL CORPORATION
number: 09619855
owner_city: Santa Clara
owner_country: US
publication_date: 20111118
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"p":["Delivering competitive processor graphics subsystem relies on an efficient and scalable graphics architecture. Scalability is needed to support a range of graphics performance points using a single architecture and limited design resources. Parallelizing the graphics workloads across multiple identical graphics cores typically provides such scalability.","One problem inherent in the architecture of parallel graphics pipelines is efficiently parallelizing both the geometry processing and rasterization stages of the pipeline. Parallelizing both stages is desirable given that either stage can become the performance bottleneck at different times during the processing of a single frame. Unfortunately, parallelizing geometry processing most naturally requires distribution of geometric objects across the graphics cores, while parallelizing rasterization most naturally requires distribution of image space (e.g., the frame buffer) across the graphics cores. However, the correlation between geometric objects and their image space footprint is not known a priori. In addition, geometric objects need to be rasterized in the same temporal order as they are submitted for geometry processing. Therefore a mechanism needs to assemble, reorder and distribute the results of parallel geometry processing across the parallel rasterization pipelines with high performance\/power and performance\/area characteristics, and in a fashion that does not require significant software intervention.","A conventional graphics system including multiple, parallel graphics cores and capable of distributed rasterization through use of CheckerBoard Rendering (CBR) schemes, may subdivide a target surface (e.g., the frame buffer) into small rectangular regions. Non-overlapping regular grid subsets of these regions may then be assigned to each graphics core such that all target surface pixels are assigned. Rasterization pipelines in the graphics cores may then operate in parallel such that, for each rasterized object, a rasterization pipeline will render only those pixels contained within its subset of the target surface pixels. In current CBR schemes, each graphic core performs geometry processing for all submitted geometric objects, passing the results to only its internal rasterization pipeline. Because geometry processing is replicated across the graphics cores in such conventional systems, there is no positive scaling of geometry processing rate with the number of graphics cores.","One or more embodiments or implementations are now described with reference to the enclosed figures. While specific configurations and arrangements are discussed, it should be understood that this is done for illustrative purposes only. Persons skilled in the relevant art will recognize that other configurations and arrangements may be employed without departing from the spirit and scope of the description. It will be apparent to those skilled in the relevant art that techniques and\/or arrangements described herein may also be employed in a variety of other systems and applications other than what is described herein.","While the following description sets forth various implementations that may be manifested in architectures such system-on-a-chip (SoC) architectures for example, implementation of the techniques and\/or arrangements described herein are not restricted to particular architectures and\/or computing systems and may be implemented by any architecture and\/or computing system for similar purposes. For instance, various architectures employing, for example, multiple integrated circuit (IC) chips and\/or packages, and\/or various computing devices and\/or consumer electronic (CE) devices such as set top boxes, smart phones, etc., may implement the techniques and\/or arrangements described herein. Further, while the following description may set forth numerous specific details such as logic implementations, types and interrelationships of system components, logic partitioning\/integration choices, etc., claimed subject matter may be practiced without such specific details. In other instances, some material such as, for example, control structures and full software instruction sequences, may not be shown in detail in order not to obscure the material disclosed herein.","The material disclosed herein may be implemented in hardware, firmware, software, or any combination thereof. The material disclosed herein may also be implemented as instructions stored on a machine-readable medium, which may be read and executed by one or more processors. A machine-readable medium may include any medium and\/or mechanism for storing or transmitting information in a form readable by a machine (e.g., a computing device). For example, a machine-readable medium may include read only memory (ROM); random access memory (RAM); magnetic disk storage media; optical storage media; flash memory devices; electrical, optical, acoustical or other forms of propagated signals (e.g., carrier waves, infrared signals, digital signals, etc.), and others.","References in the specification to \u201cone implementation\u201d, \u201can implementation\u201d, \u201can example implementation\u201d, etc., indicate that the implementation described may include a particular feature, structure, or characteristic, but every implementation may not necessarily include the particular feature, structure, or characteristic. Moreover, such phrases are not necessarily referring to the same implementation. Further, when a particular feature, structure, or characteristic is described in connection with an implementation, it is submitted that it is within the knowledge of one skilled in the art to effect such feature, structure, or characteristic in connection with other implementations whether or not explicitly described herein.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1","b":["100","100","102","104","106","108","108","102","104","102","104"]},"In various implementations, cores \/ may be configured to perform 3D graphics processing according to various application programming interfaces (APIs), standards, and\/or specifications, including, but not limited to, the OpenGL specification (see, e.g., \u201cThe OpenGL Graphics System: A Specification (Version 4.0 (Core Profile)\u2014Mar. 11, 2010)), or the Direct3D API (see, e.g., \u201cThe Direct3D 10 System\u201d ACM Transactions on Graphics (TOG)\u2014Proceedings of ACM SIGGRAPH, Volume 25 Issue 3, July 2006\u201d)(hereinafter the \u201cDirect3D API\u201d). In the interest of clarity, the various devices, systems and processes are described herein in the context of the Direct3D API although the present disclosure is not limited to any particular 3D graphics APIs, standards, and\/or specifications.","The internal components of graphics core  are illustrated in greater detail in  and include a 3D graphics pipeline  having an input processing module  (including batching logic ), a vertex processing module  communicatively coupled to input processing module  and to shared storage , a geometry setup module  communicatively coupled to vertex processing module , a local storage structure such as a First In First Out (FIFO) buffer  communicatively coupled to geometry setup module  and to shared bus , a crossbar multiplexer (MUX)  communicatively coupled to FIFO  and to shared bus , and a rasterization module  (including dereferencing logic ) communicatively coupled to crossbar MUX , shared storage , and shared bus . An interconnect  provided to each of cores \/ provides read and write access to shared memory . Each of parallel graphics cores  may include similar items. In various implementations, each of graphics cores  and  may be termed a graphics processing unit (GPU). Those of skill in the art may recognize that some components or modules of a 3D graphics pipeline, such as a pixel shader module, have been omitted from  in the interests of clarity.","As will be explained in greater detail below, system  may provide scalable geometry processing in accordance with the present disclosure where graphics cores  and  may be configured to undertake parallel rendering employing various checkerboard rasterization (CBR) schemes. For instance,  illustrates an example CBR scheme  where four identical graphics cores  (each similar to cores  and  of ) of a multi-core processor  have been mapped to target pixels of different regions  of frame buffer  to facilitate parallel rendering. As shown in this example, core () will render graphics data for target pixels in, portions of frame buffer  labeled \u201c1\u201d, core () will render graphics data for target pixels in portions of frame buffer  labeled \u201c2\u201d, and so forth. Once each region  has been rasterized, the contents of frame buffer  may be subjected to additional processing such as pixel shading, output merging and so forth prior to being provided for display on a display .","While the example scheme of  shows a total of four graphics cores  assigned to specific target pixel regions , the present disclosure is not limited to any particular number or types of graphics processing cores and\/or to any particular parallel rendering schemes. For example, any of various known CBR schemes for apportioning rendering of target pixels of a frame buffer may be employed (see, e.g., Carl Mueller, \u201cThe Sort-First Rendering Architecture for High-Performance Graphics\u201d, In Proceedings of the 1995 Symposium on Interactive 3D Graphics, pages 75-84 (1995)). Further, the present disclosure is not limited to any sizes and\/or arrangements of regions . Thus, for example, each of regions  may correspond to a 64\u00d764-pixel region of buffer , a 128\u00d7128-pixel region of buffer , and so forth. In addition, frame buffer  may have any pixel resolution or format and is not limited to a square format as illustrated. For example, frame buffer  may have various high-definition (HD) resolutions such as 1280\u00d7720 pixels, or 1920\u00d71080 pixels and so forth.","In accordance with the present disclosure, as will be explained in greater detail below, when processor  undertakes 3D graphics processing of a scene, each of the graphics cores may perform vertex and geometry processing on separate batches of graphics objects associated with the various target pixels assigned to the respective cores. For example, core () may perform vertex and geometry processing on graphics objects that span target pixels from regions  of frame buffer  labeled \u201c1\u201d, core () may perform vertex and geometry processing on graphics objects that span target pixels from regions  labeled \u201c2\u201d, and so forth.","Referring again to , in accordance with the present disclosure and as will also be explained in greater detail below, input processing module  may receive graphics data (e.g., primitives corresponding to triangles, line and points) corresponding to graphics objects and each of graphics cores  and  may use batching logic  to select the graphics data corresponding to various batches of graphics objects. Batching logic  in each core may act to subdivide, apportion or distribute incoming geometric objects into batches of consecutive objects provided to cores \/, and each graphics core may process its separate corresponding batches on a round-robin basis. In various implementations, batch sizes may be programmable and may vary by input topology.","In accordance with the present disclosure, each core may then, in parallel with the other cores, use module  to undertake vertex processing of vertices of the assigned objects and may store the vertex processing results in shared storage . The vertex processing may include various known functions such as vertex shading, tessellation, geometry shading, and the like. Thus, in accordance with the present disclosure, rather than copying each per-vertex result to all cores  and , the vertex processing results may be written to shared storage  by each core as it completes vertex processing, and may be later read from shared storage  by only those cores that need vertex processing results for a particular object when undertaking rasterization.","In accordance with the present disclosure, each core may then, in parallel with the other cores, use module  to undertake geometry setup processing of the assigned objects and may store the geometry setup results in FIFO . The geometry setup processing may operate on entire primitives and may include various known functions such as \u201cculling\u201d subfunctions including trivial rejection against clip boundaries, back-face culling, degenerate and zero-pixel object culling, and the like. As those of skill in the art may recognize, a large percentage of the geometry workload may be discarded during geometry setup. For example, primitives corresponding to entire batches of objects may be discarded as a result of geometry setup processing. Considering that each graphics core performs geometry setup processing (for different batches) in parallel, for cases where batches are discarded, system  may exhibit near-linear scaling for geometry processing.","The results of the geometry setup processing include determining which rasterization pipeline(s) each object spans based on the particular CBR scheme employed. This information, along with the results of the other setup subfunctions needed for rasterization, may be written to each graphics core's FIFO . Further, control information specifying batch demarcation may also be stored in FIFO .","In various implementations, FIFO  may be any type of FIFO data structure. Thus, in various non-limiting examples, FIFO  may be provided by data structures including but not limited to SRAM, flip-flops, latches or any other suitable form of storage structure. Further, FIFO  may include multiple sets of read and write pointers, as well as storage and control logic. For instance, as will be described in greater detail below, in various implementations, FIFO  may be a multi-port SRAM including two sets of read pointers: one set of read pointers  associated with internal objects, and one set of read pointers  associated with external objects.","In accordance with the present disclosure, using batch demarcation information received from all FIFOs  and subsequently transmitted over shared bus , the graphics cores may take turns submitting batch processing results for rasterization. When a specific graphics core takes its turn, its MUX  may select that core's internal objects from FIFO  for rasterization using module  while simultaneously outputting external objects within the batch from FIFO  over shared bus . The other graphics cores may select shared bus  as input to their rasterization modules . Once all objects (if any) for a current batch have been removed from FIFO  as a given core performs rasterization, that graphics core may signal batch demarcation over shared bus  and may then switch its MUX  to input external objects received from the other graphics core(s) over shared bus .","During rasterization, each graphics cores' rasterization module  may access vertex processing results by reading from shared storage  as needed. As vertex processing results are consumed by a given core, that core's rasterization module  may use dereferencing logic  to transmit dereference information back over shared bus  to the graphics core that generated the particular vertex processing results used in the rasterization. In this manner, batches of objects may be rasterized by system  in temporal order in a round-robin fashion.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIGS. 3 and 5","FIGS. 3 and 5","FIG. 1","FIG. 2"],"b":["300","300","302","322","300","100","200"]},"Process  may begin at block  where a graphics core may receive a batch of graphics objects. For example, in various implementations, core  may receive a batch of graphics objects at input processing module  where batching logic  may determine, from an input list of graphics objects (e.g., an input list of point primitives, line primitives, and so forth), those objects to be apportioned to core . For example, graphics core() may receive a batch of graphics objects at block  where the locations of the objects in terms of target surface (e.g., frame buffer) pixel locations lie, at least in part, within at least one of the regions  labeled () in frame buffer . Input processing module  may then provide primitives of the corresponding batch of objects to vertex processing module .","At block , vertex processing may be performed on the object primitives and the results may be stored in shared storage. For example, in various implementations, core  may use vertex processing module  to undertake vertex processing operations such as vertex shading, tessellation, geometry shading, and the like. The resulting per-vertex primitive data (such as intensity, color, depth, transparency and so forth) may be stored in shared storage  where it may be accessed by any of cores \/.","At block , geometry setup processing may be performed on the object primitives and the results may be stored in local storage. For example, in various implementations, core  may use geometry setup module  to undertake geometry setup operations such as trivial rejection against clip boundaries, back-face culling, degenerate and zero-pixel object culling, and the like. In addition, processing at block  also includes the determination of which rasterization pipeline(s) each object spans based on the checkerboard subdivision of the render target (e.g., information that may be used to determine which graphics cores \/ will be involved in rasterizing a given object). This batch control information, along with the results of the other setup subfunctions needed for rasterization, may be written to a FIFO . For instance, in accordance with the present disclosure, geometry setup module  may store batch information in FIFO  where the batch information classifies primitives by render target location (e.g., by which CBR region the data is associated with).","In various implementations, as a result of undertaking block , FIFO  may receive geometry setup results and batch control information that specifies how the corresponding objects map onto frame buffer locations. In this respect, graphics objects that map only to frame buffer locations associated with or assigned to the core undertaking process  may be designated as internal objects, while graphics objects that map to frame buffer locations that are not associated with or assigned to the core undertaking process  may be designated as external objects. In various implementations, a graphics object may be designated under both categories.","For example,  illustrates a portion  of frame buffer  of  in greater detail where, as a result of block , two objects  and  have been included in a batch of objects to be processed by core() of processor  at blocks  and . In this example, object  spans only frame buffer pixel position residing entirely within a region  assigned to core() and therefore batch control information may specify object  as an internal object when core () undertakes block  for region . By contrast, object  spans pixel positions within region  assigned to core() as well as in region  assigned to core(). Therefore control information may specify object  as both an internal object and as an external object when core () undertakes block  for region . In various implementations, FIFO  includes two sets of read pointers, one set of read pointers  for internal objects spanning target pixels allocated to the particular graphics core undertaking process , and a second set of read pointers  for external objects spanning target pixels allocated to other graphics core(s) in the subsystem.","In various implementations, blocks - may be undertaken in parallel by all graphics cores. For example, blocks - may be undertaken in parallel by cores  of processor  using objects apportioned among the cores by batching logic. As a result, vertex processing results corresponding to all pixel locations of frame buffer may be stored in shared storage  while geometry setup results for internal and external objects may be stored in the respective FIFOs of cores .","Process  may continue at block  where internal object setup results may be obtained from local storage, and at block  where external object setup results may be provided to other graphics cores over the shared bus. In various examples, block  may involve core  using MUX  and the control information stored in FIFO  to obtain data for internal objects from FIFO  and provide that data to rasterization module , while block  may involve core  using the control information stored in FIFO  to identify external objects and may then provide data for those external objects to cores  over shared bus . At block , vertex processing results for the internal objects may be obtained from shared storage. For instance, in various implementations, block  may involve core  obtaining vertex processing results for the internal objects from shared storage  using interconnect .","At block , rasterization of the internal objects may be performed. For example, core  may use rasterization module  to rasterize the internal objects within its assigned target pixel regions using well-known rasterization techniques. Process  may then continue at blocks  and  of .","At block , batch demarcation information may be provided over the shared bus. For example, having rasterized all internal objects, core  may use FIFO  to signal batch demarcation to cores  using shared bus . At block , external objects may be obtained from other graphics cores over the shared bus. For example, core  may use shared bus  to obtain geometry setup results for external objects from various ones of cores . For instance, referring again to the example of , block  may involve core() obtaining information pertaining to object  (having been subjected by core() to processing at blocks  and ) from core() via shared bus . To obtain external object data at block , core  may use external object read pointers associated with the FIFOs of the one or more of cores .","At block , vertex processing results for the external objects may be obtained from shared storage. For instance, in various implementations, block  may involve core  obtaining vertex processing results for the external objects (obtained at block ) from shared storage  using interconnect . At block , rasterization of the external objects may be performed. For example, core  may use rasterization module  to rasterize external objects obtained by it's own FIFO  and external objects obtained from the FIFOs of one or more of cores  using well-known rasterization techniques.","At block , dereferencing data may be provided to other cores over the shared bus. For example, in various implementations, block  may involve core  using dereferencing logic  to send dereferencing information to cores  over shared bus . The dereferencing information may inform the various cores that particular vertices have been rendered and that, therefore, corresponding vertex data may be erased from storage locations in shared storage .","At block , a determination may then be made as to whether process  shall continue. For instance, if a particular core has finished rasterizing all objects associated with it's target pixel regions, then process  may loop back to blocks \/ where processing as described above may be undertaken by another graphics core for all objects associated with that core's target pixel regions. In this manner, blocks - may be undertaken by other cores of a multi-core GPU system permitting rasterization of a frame buffer in temporal order. As these results are consumed, the consumer rasterization pipeline transmits dereference information back over a parallel shared dereference bus to the graphics core that generated the vertex processing results.","While implementation of example process , as illustrated in , may include the undertaking of all blocks shown in the order illustrated, the present disclosure is not limited in this regard and, in various examples, implementation of process  may include the undertaking only a subset of the blocks shown and\/or in a different order than illustrated. For example, a core's rasterization module may transmit dereferencing information over the shared bus when vertex processing results are consumed at blocks \/ and \/ rather than waiting until block  to do so.","In addition, any one or more of the blocks of  may be undertaken in response to instructions provided by one or more computer program products. Such program products may include signal bearing media providing instructions that, when executed by, for example, a processor, may provide the functionality described herein. The computer program products may be provided in any form of computer readable medium. Thus, for example, a processor including one or more processor core(s) may undertake one or more of the blocks shown in  in response to instructions conveyed to the processor by a computer readable medium.","As used in any implementation described herein, the term \u201cmodule\u201d refers to any combination of software, firmware and\/or hardware configured to provide the functionality described herein. The software may be embodied as a software package, code and\/or instruction set or instructions, and \u201chardware\u201d, as used in any implementation described herein, may include, for example, singly or in any combination, hardwired circuitry, programmable circuitry, state machine circuitry, and\/or firmware that stores instructions executed by programmable circuitry. The modules may, collectively or individually, be embodied as circuitry that forms part of a larger system, for example, an integrated circuit (IC), system on-chip (SoC), and so forth.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 6","b":["600","600","600","600"]},"Computer system  may include a host system , a bus , a display , a network interface , and an imaging device . Host system  may include a processor , a chipset , host memory , a graphics subsystem , and storage . Processor  may include one or more processor cores and may be any type of processor logic capable of executing software instructions and\/or processing data signals. In various examples, processor  may include Complex Instruction Set Computer (CISC) processor cores, Reduced Instruction Set Computer (RISC) microprocessor cores, Very Long Instruction Word (VLIW) microprocessor cores, and\/or any number of processor cores implementing any combination or types of instruction sets. In some implementations, processor  may be capable of digital signal processing and\/or microcontroller processing.","Processor  may include decoder logic that may be used for decoding instructions received by, e.g., chipset  and\/or a graphics subsystem , into control signals and\/or microcode entry points. Further, in response to control signals and\/or microcode entry points, chipset  and\/or graphics subsystem  may perform corresponding operations. In various implementations, processor  may be configured to undertake any of the processes described herein including the example processes described with respect to .","Chipset  may provide intercommunication among processor , host memory , storage , graphics subsystem , and bus . For example, chipset  may include a storage adapter (not depicted) capable of providing intercommunication with storage . For example, the storage adapter may be capable of communicating with storage  in conformance with any of a number of protocols, including, but not limited to, the Small Computer Systems Interface (SCSI), Fibre Channel (FC), and\/or Serial Advanced Technology Attachment (S-ATA) protocols. In various implementations, chipset  may include logic capable of transferring information within host memory , or between network interface  and host memory , or in general between any set of components in system . In various implementations, chipset  may include more than one IC.","Host memory  may be implemented as a volatile memory device such as but not limited to a Random Access Memory (RAM), Dynamic Random Access Memory (DRAM), or Static RAM (SRAM) and so forth. Storage  may be implemented as a non-volatile storage device such as but not limited to a magnetic disk drive, optical disk drive, tape drive, an internal storage device, an attached storage device, flash memory, battery backed-up SDRAM (synchronous DRAM), and\/or a network accessible storage device or the like.","Memory  may store instructions and\/or data represented by data signals that may be executed by processor  in undertaking any of the processes described herein including the example process described with respect to . For example, host memory  may store vertex processing results, target pixel regions and so forth. In some implementations, storage  may also store such items.","Graphics subsystem  may perform processing of images such as still or video images for display. For example, in some implementations, graphics subsystem  may perform 3D graphics processing. For example, graphics subsystem  may perform activities as described with regard to . An analog or digital interface may be used to communicatively couple graphics subsystem  and display . For example, the interface may be any of a High-Definition Multimedia Interface, DisplayPort, wireless HDMI, and\/or wireless HD compliant techniques. In various implementations, graphics subsystem  may be integrated into processor  or chipset . In some other implementations, graphics subsystem  may be a stand-alone card communicatively coupled to chipset .","Bus  may provide intercommunication among at least host system , network interface , imaging device  as well as other peripheral devices (not depicted) such as a keyboard, mouse, and the like. Bus  may support serial or parallel communications. Bus  may support node-to-node or node-to-multi-node communications. Bus  may at least be compatible with the Peripheral Component Interconnect (PCI) specification described for example at Peripheral Component Interconnect (PCI) Local Bus Specification, Revision 3.0, Feb. 2, 2004 available from the PCI Special Interest Group, Portland, Oreg., U.S.A. (as well as revisions thereof); PCI Express described in The PCI Express Base Specification of the PCI Special Interest Group, Revision 1.0a (as well as revisions thereof); PCI-x described in the PCI-X Specification Rev. 1.1. Mar. 28, 2005, available from the aforesaid PCI Special Interest Group, Portland, Oreg., U.S.A. (as well as revisions thereof); and\/or Universal Serial Bus (USB) (and related standards) as well as other interconnection standards.","Network interface  may be capable of providing intercommunication between host system  and a network in compliance with any applicable protocols such as wired or wireless techniques. For example, network interface  may comply with any variety of IEEE communications standards such as 802.3, 802.11, or 802.16. Network interface  may intercommunicate with host system  using bus . In some implementations, network interface  may be integrated into chipset .","The 3D graphics processing techniques described herein may be implemented in various hardware architectures. For example, 3D graphics functionality may be integrated within a chipset. Alternatively, a discrete graphics processor may be used. As still another implementation, the 3D graphics functions may be implemented by a general purpose processor, including a multi-core processor. In a further implementation, the functions may be implemented in a consumer electronics device.","Display  may be any type of display device and\/or panel. For example, display  may be a Liquid Crystal Display (LCD), a Plasma Display Panel (PDP), an Organic Light Emitting Diode (OLED) display, and so forth. In some implementations, display  may be a projection display (such as a pico projector display or the like), a micro display, etc. In various implementations, display  may be used to display images resulting from 3D graphics processing as described herein.","Imaging device  may be any type of imaging device such as a digital camera, cell phone camera, infra red (IR) camera, and the like. Imaging device  may include one or more image sensors (such as a Charge-Coupled Device (CCD) or Complimentary Metal-Oxide Semiconductor (CMOS) image sensor). Imaging device  may capture color or monochrome images. Imaging device  may capture input images (still or video) and provide those images, via bus  and chipset , to processor .","In some implementations, system  may communicate with various I\/O devices not shown in  via an I\/O bus (also not shown). Such I\/O devices may include but are not limited to, for example, a universal asynchronous receiver\/transmitter (UART) device, a USB device, an I\/O expansion interface or other I\/O devices. In various implementations, system  may represent at least portions of a system for undertaking mobile, network and\/or wireless communications.","While certain features set forth herein have been described with reference to various implementations, this description is not intended to be construed in a limiting sense. Hence, various modifications of the implementations described herein, as well as other implementations, which are apparent to persons skilled in the art to which the present disclosure pertains are deemed to lie within the spirit and scope of the present disclosure."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The material described herein is illustrated by way of example and not by way of limitation in the accompanying figures. For simplicity and clarity of illustration, elements illustrated in the figures are not necessarily drawn to scale. For example, the dimensions of some elements may be exaggerated relative to other elements for clarity. Further, where considered appropriate, reference labels have been repeated among the figures to indicate corresponding or analogous elements. In the figures:",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIGS. 3 and 5"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
