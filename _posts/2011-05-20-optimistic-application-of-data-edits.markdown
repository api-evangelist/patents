---
title: Optimistic application of data edits
abstract: A data representation that represents source data at a data source can be maintained. A request to perform an edit can be received from a client, and a request to make the edit to the source data can be sent to the data source. The edit can be optimistically applied to the data representation. Additionally, a change notification can be sent to the client. The change notification can indicate one or more changes to the data representation, where the change(s) resulted from the application of the edit to the data representation. A notification can be received from the data source after applying the edit to the data representation and after sending the change notification. The notification from the data source can indicate whether the edit to the source data succeeded.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08838533&OS=08838533&RS=08838533
owner: Microsoft Corporation
number: 08838533
owner_city: Redmond
owner_country: US
publication_date: 20110520
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Applications and\/or controls may act as clients of local and\/or remote data sources. For example, the clients may display data from the data sources, such as in the form of lists. As used herein, a list is an ordered sequence of items, and a client can be an application and\/or control. Some data sources, such as local data sources, can respond synchronously to requests for data, with the data source passing the requested data to the requester before the requester resumes execution. Such responses to data requests typically take less time than some response time threshold, such as a threshold that is low enough that a presentation of the response can appear to be in real time with the corresponding request. For example, such responses may take on the order of tens of milliseconds or less. Other data sources, such as remote data sources, may respond asynchronously, with the data requester resuming execution after the request and receiving the requested data from the data source at a later time. Such responses to data requests typically take more time than the response time threshold discussed above.","Some data sources are implemented as read-only data sources. However, in other implementations, clients may be allowed to submit edits to be made to the source data.","The tools and techniques described herein are directed to handling requests from a client to apply edits to data. In the case of a data source that responds asynchronously, the techniques can include applying optimistic edits to a data representation that represents the source data. For example, the source data may reside in a remote data source, while the data representation may reside in a local cache. As used herein, edits made \u201coptimistically\u201d to the data representation are done in a way that assumes the edits will eventually be successfully made to the data source. Thus, such optimistic edits can represent a state that the source data will be in after those edits are applied, even though the edits may not have been made to the source data yet.","In one embodiment, the tools and techniques can include maintaining a data representation that represents source data at a data source. A request to perform an edit can be received from a client, and a request to make the edit to the source data can be sent to the data source. The edit can be optimistically applied to the data representation. Additionally, a change notification can be sent to the client. The change notification can indicate one or more changes to the data representation, where the change(s) resulted from the application of the edit to the data representation. A notification can be received from the data source after applying the edit to the data representation and after sending the change notification. The notification from the data source can indicate whether the edit to the source data succeeded.","In another embodiment of the tools and techniques, a data representation that represents source data at a data source can be maintained. A request to perform an edit can be received from a client, and a request to make the edit to the source data can be sent to the data source. It can be determined whether the edit to the source data synchronously failed. This synchronous failure determination may not be made immediately upon receiving the request from the client. For example, this may not happen until the edit reaches a head of an edit queue. If the edit to the source data did synchronously fail, the client may be notified of this failure. If the edit did not synchronously fail, then the edit can be applied to the data representation, without waiting to be notified as to whether the edit to the source data succeeded. Additionally, a change notification can be sent to the client. The change notification can indicate one or more changes to the data representation resulting from the application of the edit to the data representation. This notification to the client can also be done without waiting to be notified as to whether the edit to the source data succeeded. Applying the edit or notifying the client \u201cwithout waiting\u201d does not preclude the possibility of waiting to be notified of success or failure of the edit after applying the edit to the data representation and\/or after notifying the client. For example, an items manager may not wait to be notified of success\/failure of the edit before applying the edit to the data representation, but may wait to be notified of success or failure of the edit before removing the edit from an edit queue. In some situations when an edit failure occurs at the data source, remaining edits in the edit queue may be undone. This undoing of edits in the edit queue may include sending additional change notifications to the client. These additional change notifications can represent changes that bring the data representation back to an earlier state.","This Summary is provided to introduce a selection of concepts in a simplified form. The concepts are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter. Similarly, the invention is not limited to implementations that address the particular techniques, tools, environments, disadvantages, or advantages discussed in the Background, the Detailed Description, or the attached drawings.","Embodiments described herein are directed to techniques and tools for improved handling of edit requests for source data. Such improvements may result from the use of various techniques and tools separately or in combination.","Such techniques and tools may include providing a re-usable component (an items manager) that presents to a client an interface that behaves as if edits to data items succeed immediately, even if the edits are applied to the underlying data source after a delay. The items manager can synchronously apply the edits optimistically to a data representation having data representation items. For example, the data representation may be stored in a local cache. The items manager can send change notifications back to the client when the edits are made to the data representation (even if the edits have not yet been made to the source data). The client can navigate through the data representation. The change notifications due to the edits requested by the client can have the same form as change notifications due to the data changing for other reasons (e.g., because of changes to the source data by third parties, etc.). This can make implementation of the client simpler. Even though the client may be aware that it caused an edit, the client can apply its own edits to its own data structures without needing a code path that is separate from a code path for other changes. Also, if changes to the data representation are to be undone, the client can be notified of this with these same types of change notifications, and the client can use its same code path for undoing the changes in its own data structures.","The items manager can also maintain a queue of outstanding edits. The items manager may use one of various different techniques for adding edits to the queue. For example, the items manager may add all the edits to the queue. Alternatively, if the queue were empty, the items manager could determine whether an edit completed synchronously, and only queue the edit if the edit did not complete synchronously. The items manager can send edits from the queue to the data source in sequence. When the items manager receives a notification of success back for an edit at the head of the queue, the items manager can dequeue that edit, and can send the next edit (which is now at the head of the queue) to the data source. By waiting for a success or failure notification from the data source for each edit before sending the next edit request to the data source, the edits can be applied to the source data in the same order in which they were received and entered in the queue. If an edit fails, the items manager can undo the queued edits (including the failing one) in the data representation in reverse order. The edits can also be removed from the queue. Such queuing operations can allow multiple edits to be applied to the data representation in rapid succession, even if it will take some time to apply the edits to the source data.","In the event of a loss of a connection to the data source, the items manager can notify the client of this incident, but can spare the client the details of reattempting the edits the next time the data is refreshed by the client. In the event of a deletion failure because the edit was no longer meaningful (as indicated by a notification from the data source), the items manager can continue with the other edits in the queue. In the event of other kinds of failures, the items manager can notify the client, undo the remaining edits (in reverse order) in the cache, and discard the edit queue. In the event of an edit that conflicts with a current state of the source data (for example, the items manager may conclude that a no-longer-meaningful type of notification from the data source is due to such a conflict), the items manager can conduct a generic refresh algorithm that generates change notifications to return the data representation to a state consistent with the source data. Also, when data fetched from the data source reveals an inconsistency between the data representation and the source data (as detected by the items manager), the items manager can attempt to complete queued edits before beginning the refresh operation.","Accordingly, one or more benefits may be realized from the data editing tools and techniques described herein. For example, the client may provide feedback to a user as soon as edits are attempted, rather than making a user wait for the network round trip to the data source, which at times can be quite long. In particular, because in most systems the vast majority of edits succeed, acting as if edits have succeeded immediately can allow multiple edits to be made naturally in rapid succession, even if the first edit has not yet been fully implemented in the network data source. In cases when an edit cannot be completed, the items manager can handle this well. In cases where a network connection is briefly lost, the items manager can re-attempt the edits autonomously, taking this burden off of the client.","The subject matter defined in the appended claims is not necessarily limited to the benefits described herein. A particular implementation of the invention may provide all, some, or none of the benefits described herein. Although operations for the various techniques are described herein in a particular, sequential order for the sake of presentation, it should be understood that this manner of description encompasses rearrangements in the order of operations, unless a particular ordering is required. For example, operations described sequentially may in some cases be rearranged or performed concurrently. Moreover, for the sake of simplicity, flowcharts may not show the various ways in which particular techniques can be used in conjunction with other techniques.","Techniques described herein may be used with one or more of the systems described herein and\/or with one or more other systems. For example, the various procedures described herein may be implemented with hardware or software, or a combination of both. For example, dedicated hardware implementations, such as application specific integrated circuits, programmable logic arrays and other hardware devices, can be constructed to implement at least a portion of one or more of the techniques described herein. Applications that may include the apparatus and systems of various embodiments can broadly include a variety of electronic and computer systems. Techniques may be implemented using two or more specific interconnected hardware modules or devices with related control and data signals that can be communicated between and through the modules, or as portions of an application-specific integrated circuit. Additionally, the techniques described herein may be implemented by software programs executable by a computer system. As an example, implementations can include distributed processing, component\/object distributed processing, and parallel processing. Moreover, virtual computer system processing can be constructed to implement one or more of the techniques or functionality, as described herein.","I. Exemplary Computing Environment",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1","b":"100"},"The computing environment () is not intended to suggest any limitation as to scope of use or functionality of the invention, as the present invention may be implemented in diverse general-purpose or special-purpose computing environments.","With reference to , the computing environment () includes at least one processing unit () and memory (). In , this most basic configuration () is included within a dashed line. The processing unit () executes computer-executable instructions and may be a real or a virtual processor. In a multi-processing system, multiple processing units execute computer-executable instructions to increase processing power. The memory () may be volatile memory (e.g., registers, cache, RAM), non-volatile memory (e.g., ROM, EEPROM, flash memory), or some combination of the two. The memory () stores software () implementing optimistic application of data edits.","Although the various blocks of  are shown with lines for the sake of clarity, in reality, delineating various components is not so clear and, metaphorically, the lines of  and the other figures discussed below would more accurately be grey and blurred. For example, one may consider a presentation component such as a display device to be an I\/O component. Also, processors have memory. The inventors hereof recognize that such is the nature of the art and reiterate that the diagram of  is merely illustrative of an exemplary computing device that can be used in connection with one or more embodiments of the present invention. Distinction is not made between such categories as \u201cworkstation,\u201d \u201cserver,\u201d \u201claptop,\u201d \u201chandheld device,\u201d etc., as all are contemplated within the scope of  and reference to \u201ccomputer,\u201d \u201ccomputing environment,\u201d or \u201ccomputing device.\u201d","A computing environment () may have additional features. In , the computing environment () includes storage (), one or more input devices (), one or more output devices (), and one or more communication connections (). An interconnection mechanism (not shown) such as a bus, controller, or network interconnects the components of the computing environment (). Typically, operating system software (not shown) provides an operating environment for other software executing in the computing environment (), and coordinates activities of the components of the computing environment ().","The storage () may be removable or non-removable, and may include computer-readable storage media such as magnetic disks, magnetic tapes or cassettes, CD-ROMs, CD-RWs, DVDs, or any other medium which can be used to store information and which can be accessed within the computing environment (). The storage () stores instructions for the software ().","The input device(s) () may be a touch input device such as a keyboard, mouse, pen, or trackball; a voice input device; a scanning device; a network adapter; a CD\/DVD reader; or another device that provides input to the computing environment (). The output device(s) () may be a display, printer, speaker, CD\/DVD-writer, network adapter, or another device that provides output from the computing environment ().","The communication connection(s) () enable communication over a communication medium to another computing entity. Thus, the computing environment () may operate in a networked environment using logical connections to one or more remote computing devices, such as a personal computer, a server, a router, a network PC, a peer device or another common network node. The communication medium conveys information such as data or computer-executable instructions or requests in a modulated data signal. A modulated data signal is a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media include wired or wireless techniques implemented with an electrical, optical, RF, infrared, acoustic, or other carrier.","The tools and techniques can be described in the general context of computer-readable media, which may be storage media or communication media. Computer-readable storage media are any available storage media that can be accessed within a computing environment, but the term computer-readable storage media does not refer to signals per se. By way of example, and not limitation, with the computing environment (), computer-readable storage media include memory (), storage (), and combinations of the above.","The tools and techniques can be described in the general context of computer-executable instructions, such as those included in program modules, being executed in a computing environment on a target real or virtual processor. Generally, program modules include routines, programs, libraries, objects, classes, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or split between program modules as desired in various embodiments. Computer-executable instructions for program modules may be executed within a local or distributed computing environment. In a distributed computing environment, program modules may be located in both local and remote computer storage media.","For the sake of presentation, the detailed description uses terms like \u201cdetermine,\u201d \u201cchoose,\u201d \u201cadjust,\u201d and \u201coperate\u201d to describe computer operations in a computing environment. These and other similar terms are high-level abstractions for operations performed by a computer, and should not be confused with acts performed by a human being, unless performance of an act by a human being (such as a \u201cuser\u201d) is explicitly noted. The actual computer operations corresponding to these terms vary depending on the implementation.","II. System and Environment for Optimistic Application of Edits","A. General System and Environment",{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 2","FIG. 2","FIG. 2"],"b":["200","200","210","210","220","230","232","230","210","210","230","240","210","242","245","210","220","100"]},"The items manager () can receive one or more data requests () from the client () for representation item(s) representing one or more items from the data source (), or one or more edit requests () for edits to be made to the local data representation () and the source data ().","B. Providing Data Representation Items to the Client","In response to a request to fetch data representation items, the items manager () can fetch the data representation items () from the data source () through the adapter () or from a local data representation () (if the requested data representation items have already been fetched from the data source ()). For example, the items manager () can send one or more requests to the data source (), and the data source () can return data representation items () to the items manager () through the adapter (). The data representation items () may change form as they are sent from the data source () to the client (). As just one example, the adapter () may convert the data representation items () to an array of ECMAScript objects and forward those objects to the items manager (). The items manager () may send the ECMAScript objects to an item renderer (), and the item renderer may return the data representation items () to the items manager as HTML Document Object Model elements, and the items manager () may forward those HTML Document Object Model elements to the client (). The data representation items () may take any of various other forms. For example, the items manager () may send un-rendered versions of the data representation items () to the client (), and the client () may use the data representation items () for uses other than display.","The items manager () may maintain the local data representation () that represents a subset of a larger data set maintained by the data source (). For example, the local data representation () may only include data representation items () for items that are currently displayed in a list (which could be displayed in various forms, such as in a vertically-extending list, in a grid, as thumbnails, etc.) by the client () and possibly some related data representation items (). For example, the local data representation () may also include data representation items () for neighbors of items that are currently displayed, items that have recently been displayed, etc. However, the items manager () may virtualize the local data representation () to make it seem to the client () as though the items manager () has downloaded the entire data set from the data source (). For example, the items manager () may fetch and provide the client () with information on a total number of items in the data set of the data source () so that the client () can take appropriate actions, such as sizing and locating a scroll bar appropriately for the overall data set of the data source ().","If the client () sends the items manager () a request () for a representation item that the items manager () has not yet retrieved from the data source (), the items manager () can return to the client () a placeholder () until the items manager () successfully fetches the representation item () from the data source (). The items manager () may also include the placeholder () in the local data representation (), where the placeholder () can be used for recordkeeping purposes, such as to be matched with a corresponding data representation item () when the data representation item () is returned from the data source (). Additionally, the client () may use the placeholder for various purposes such as recordkeeping and for displaying in lieu of the actual data representation item () until the data representation item () is returned.","A placeholder () can take any of various forms. For example, the placeholder(s) and the actual data representation items () in the local data representation () may be in the form of rendered HTML Document Object Model elements formed by the placeholder renderer () in response to requests from the items manager (). Alternatively, the placeholders () may take some other form, such as the form of opaque handles, or some other data type. Additionally, the placeholders () in the local data representation () may be in a different form from the placeholders () returned to the client () in response to requests () from the client ().","C. Optimistic Application of Edits","In addition to providing data representation items to the client (), the environment () can allow the client () to request edits. The edits can be made to the local data representation () and to the source data ().","The client () can send a request () for an edit. This may be done in any of various different ways, such as sending messages, making application programming interface calls, etc. In one implementation, the client () can send a request () for an edit by calling an interface of the items manager (), and passing the items manager () a callback function to call when the edit has been completed. The client () may also send batch notifications () to the items manager. For example, the client () may batch edit requests () by sending a \u201cbegin edits\u201d notification at the beginning of a batch of edit requests (), and by sending an \u201cend edits\u201d notification at the end of a batch. If the client () does not send such notifications, the items manager () may infer a begin edits notification before each edit request () and an end edits notification after each edit request ().","In response to a request () for an edit to be made, the items manager () can generate a reversible description of the edit (i.e., a sufficient description to allow the edit to be undone). For example, in the case of a deletion, in addition to storing an indication of which item is being deleted, the items manager () can store data for the item and can store indications of the adjacent items in the local data representation (). Accordingly, if at some later time the deletion edit is to be undone in the local data representation (), the items manager () can generate an insertion operation for a new item with the given data, between those items in the data representation. For different kinds of data structures, this reversible description may include different information, such as indications of whether parent or child relationships exist between items, etc.","A data structure representing the edit can be appended to a queue (). Appending such a data structure to the queue () is referred to herein as including the edit itself in the queue, for simplicity in the description. The data structure in the queue () can include, or link to, the reversible description discussed above. The queue () can be managed using a first-in-first-out (FIFO) technique so that edits can be done in the same order in which requests for the edits were received from the client ().","When the edit gets to a head of the queue so that the edit is now first in line (e.g., has been in the queue () the longest), or if the queue () contains just this one edit, the items manager () can attempt the edit. For example, the items manager () can call a method for the requested type of edit (insert, delete, move, change, replace, etc.) on a data source adapter object, which can in turn communicate the request to the underlying data source () via the data source adaptor ().","The items manager () can determine whether the edit has synchronously failed, or whether the edit will have some other outcome, such as where the edit succeeds synchronously or the request for the edit is to be handled asynchronously. For example, the items manager () can maintain a data structure for a particular edit, and a bit on that data structure can be set to true if the particular edit failed. As specified in the original calling code for the items manager (), after the items manager () passes the callback function to the adapter (), the items manager () can check the \u201cedit failed\u201d bit. If the \u201cedit failed\u201d bit is false (indicating that the edit already succeeded or the adapter () has not yet called back), then the items manager () can apply the edit to the local data representation (). Alternatively, the items manager () may determine whether the edit synchronously failed in some other manner, such as by being expressly informed of this by the adapter (). The items manager () can also send an appropriate notification () to the client. If this is the first edit in a batched sequence (as indicated by a begin edits notification from the client () or as inferred by the items manager ()), the items manager () can send a \u201cbegin notifications\u201d notification (). If there are no edits queued, the items manager () can complete the edit sequence, as discussed below.","As noted above, when the items manager () attempts an edit (such as by calling a method on the data source adapter ()), the items manager () can pass a callback function (which may be considered to be part of the items manager ()) to the adaptor ().","The callback function may be called synchronously or asynchronously. When the callback function is called, the function can perform different tasks depending on the outcome of the edit. For example, if the edit succeeded, the function can dequeue the edit from the edit queue (). Additionally, the callback function may update data for the key for a data item if such a key has been successfully assigned or changed by the data source (). If the connection to the data source () has been lost, the callback function can set a Boolean value indicating that the items manager () is to wait for the next refresh operation (discussed more below) before attempting more edits. Also, in this situation, the items manager () can send a status notification () to the client (), notifying the client () that the connection with the data source () is in a state of error. When the connection is restored, the items manager () can send the client () another status notification (), notifying the client that the connection with the data source is no longer in a state of error. The items manager () may send various different status notifications () to the client, notifying the client () of the current status. For example, the status notifications () can include notifications () for an outstanding edits status, an edits completed (or ready) status, and an error status. For example, the error status notification can be sent when an edit failed or network connectivity is lost. If the data source () reports that the edit is not permitted, then the edit queue may be discarded, as is discussed more below. In this situation, the items manager may also send the client () a status notification () indicating that there is a state of error.","If the data source () reports that the edit is no longer meaningful (e.g., due to another party editing the data source in a conflicting manner), the response by the callback function can depend on whether the edit was a deletion. If the edit was a deletion, then the callback function can dequeue the edit; otherwise, the callback function can discard the edit queue. Whether or not the edit was a deletion, the callback function can request a refresh, because the no longer meaningful failure indicates that the data representation () is now out of sync with the source data ().","After the callback function takes one of the above actions, if the Boolean value mentioned above has not been set, the next edit can be attempted. To attempt the next edit, the items manager () can determine whether there is at least one edit in the queue (), and if so, the items manager can attempt the edit at the head of the queue (). The items manager () can also determine whether that edit completed synchronously. If so, the items manager can attempt the next edit after the one that just completed.","To complete a batched edit sequence (when the items manager () has inferred or been sent an end edits notification), the items manager () can update the indices of all items in the data representation () and send appropriate notifications to the client. Updating indices can be done more efficiently for the whole batched sequence than if the indices are updated after each edit in the sequence. The items manager () can send an \u201cend notifications\u201d notification () to the client (). This \u201cend notifications\u201d notification () and the corresponding \u201cbegin notifications\u201d notification () noted above can define a beginning and end of a batch of notifications. A client, which is to alter its state in response to changes in the data, can process the known outstanding changes at one time. In other words, the client may postpone various internal changes to its data structures until the latest changes (the changes in the batch) have been taken into account. Also, the items manager () can determine whether a refresh operation has been requested, and if so, then the items manager () can start a refresh operation, as discussed below.","To discard the edit queue (), the items manager () can walk through the edit queue () from the last queued edit to the first queued edit (i.e., walk through the edits in reverse order), and undo the queued edits. The items manager () can also discard the queued data structures. Additionally, the items manager () can execute the code to complete an edit sequence, as discussed above.","This data editing feature can also benefit from some acts in the refresh operation discussed below. For example, if the Boolean value discussed above has been set, it can be cleared when the refresh operation is performed. Also, if there are edits in the queue (), the next edit in the queue () can be attempted (as discussed above) before the refresh operation proceeds. Additionally, if there are edits in the queue () when the refresh operation is called, the refresh operation can be aborted and tried again when the edit sequence is completed and the queue has no more edits.","Referring now to , an example of adding edits to an edit queue will be discussed with reference to , followed by an example of processing and removing the edits from that same queue with reference to . Edits can be processed and removed from a queue at the same time as or between other edits being added to the queue, but these two acts are separated in  for the sake of simplicity and clarity in the figures and in this description.","The left side of  illustrates a data representation () (actually a portion of the data representation in the form of a list) with triangles illustrating data representation items. The right side of  illustrates edits in a queue () as edits are added to the queue () and optimistically applied in the data representation (), which can be before it is known whether the edits will be successfully applied in corresponding source data (not shown).","An original data representation () includes data representation items in the following order in a list: F, G, H, J, K. The queue () can receive an edit to insert item X between items J and K. This insertion can be applied to the data representation (), resulting in a data representation () after the insertion of item X that is ordered as follows: F, G, H, J, X, K.","The queue () can then receive an edit to delete item G. This deletion can be applied to the data representation (), resulting in the data representation () after the deletion of item G. The queue () can then receive an edit to move item H between items X and K. This deletion can be applied to the data representation (), resulting in the data representation () after the move of item H, ordered as follows: F, J, X, H, K. Finally, the queue () can receive an edit to delete item J. This deletion can be applied to the data representation (), resulting in the data representation () after the deletion of item J. Accordingly, all these edits in the queue () have been applied optimistically, assuming that the edits will be successfully applied at the data source. The result is the data representation () with the following item order: F, X, H, K. The edits can be applied to the data representation () even though the edits are still in the queue, and no confirmation has been received from the data source for those edits.","Referring now to , the data representation () is again illustrated on the left side, while the queue () is illustrated on the right side, similar to . However,  illustrates the data representation () and the queue () being processed as notifications are received back from the data source, indicating whether the edits were successfully applied to the source data.","The data representation () after the insertion of X succeeds is the same as before the insertion succeeded. This is because this edit was already optimistically applied to the data representation (), as discussed above. However, the edit (\u201cINSERT X BETWEEN J, K\u201d) is removed from the queue ().","Moreover, the data representation () after the deletion of G failed as no longer meaningful also remains unchanged. This is because a no longer meaningful failure of the deletion of an item can indicate that the item is no longer present in the source data. Accordingly, the item need not be inserted back into the data representation (). The G deletion edit can be removed from the queue (), and the other edits can remain in the queue (). If the deletion of G had failed because it was not permitted, the edits in the queue (), including the deletion of G, could be undone in reverse order.","The bottom row of  depicts the result of processing after receiving a notice from the data source that the move of H failed. Because of this failure, the edits in the queue (), including the move of H, can be undone in reverse order. Accordingly, the deletion of J can be undone, and then the move of H can be undone. Undoing these edits can result in the data representation () after the H move fails, with items in the following order: F, H, J, X, and K. Additionally, the edits in the queue can be discarded, as illustrated by the bottom illustration of the queue () in  not listing any edits.","D. Data Representation Refresh Operations","As noted above, refresh operations can be performed in some situations, such as where a connection has been lost or a no longer meaningful failure notice is received. Accordingly, an example of conducting such a refresh operation will now be described. Referring back to , the items manager () can initiate a refresh operation that can generate a set of change notifications when data representation items are updated. To begin the refresh operation, an updated representation of an updated set of source data () in the data source () can be fetched by the items manager (). A change notification set can be generated by comparing the updated representation with an original representation. The change notification set can represent a possible set of changes that yield the updated representation when starting with the original representation. The possible set of changes can include fewer changes than an alternative set of changes that would, for example, represent deletion of all items in the original set of data and insertion of all items in the updated set of data. The change notification set can be sent to the client ().","The refresh operation may be done in three main steps to be performed by the items manager (): detecting that the current local data representation () is out of date compared to the source data () in the data source (), fetching an updated representation in the form of data representation items () to replace all or part of the local data representation (), and comparing the original and updated versions of the updated local data representation () to generate the change notifications. Each of these will be discussed below.","1. Detecting Out-of-Date Local Data Representation","Detecting that the local data representation () is out of date may be bypassed if a refresh operation (i.e., fetching an updated representation in the form of data representation items () to replace all or part of the local data representation (), and comparing the original and updated versions of the updated local data representation () to generate change notifications ()) is requested, such as by the client (). The client () can request a refresh operation via the items manager interface, such as by calling a method (e.g., by calling \u201cvoid refresh( )\u201d). For example, the client () may be configured to periodically request a refresh operation, or a refresh operation may be requested by user input. Additionally, the items manager () or the adapter () can initiate a refresh operation autonomously, such as when the items manager () or the adapter () has detected that the local data representation () is out of date.","An out-of-date local data representation () may be detected when the client () requests additional data representation items (). The items manager () may request an overlapping portion of the already-fetched local data representation () in addition to requesting the new data items () requested by the client (). The items manager () can process batches of data items () when they arrive from the data source (). Each time a batch arrives, the items manager () can compare overlap, if any, with data representation items () representing previously-returned data items () for consistency. For example, if a data representation item K was previously after an item J, but now it is after an item H, something has changed, even if the client's most recent request was for item K only. If indices are provided for data items () in a list, a change in a data item's index can also indicate a change to one or more other data items () in the source data (). Additionally, the data source's response to an edit request may indicate on out-of-date local data representation (), such as when the data source () returns a no longer meaningful failure notice in response to a request for an edit to be made to the source data ().","The items manager () may attempt to determine what has changed and fetch a subset of the new data that is determined to have changed. Alternatively, all the data representation items () that are in the local data representation () (which may be all the data representation items () that the client () is currently maintaining handles to) can be re-fetched by the items manager (). A discussion of this fetching follows.","2. Fetching Updated Data Representation","When fetching an updated data representation as part of a refresh operation, the items manager () can enter a different mode of operation. In this mode, the items manager () can ignore data items () that arrive due to requests that were sent before this mode was entered. Additionally, while in this mode, the items manager () may communicate with the data source () to fetch batches of data until the items manager () has a consistent \u201csnapshot\u201d, i.e., a complete updated local data representation () of the portion of the data () in the data source () that corresponds to the original local data representation () (i.e., the local data representation already available to the items manager ()). Various heuristics could be used by the items manager () to obtain such a snapshot. In one implementation, which can be used for lists of data representation items, attempts to re-obtain an instantiated sub-list in as few requests as possible can be performed, and the items manager () can examine each batch of results to see what still needs to be requested. In this approach, a data representation item () in the original local data representation () may be considered deleted if a request for that specific item fails, but until such a failure occurs or the data representation item () is successfully re-fetched, the item can be considered an item that is still to be fetched in the refresh operation.","If the items manager () finds a contradiction between batches of received data items (), the fetching process can begin anew and data items () for all the data representation items () in the local data representation () can be requested once again. For example, this may occur if source data () changes in the data source () between times when different batches of data items () are sent.","While the items manager () is in its refresh mode, it can discontinue requesting new data items () from the data source (). However, the items manager () can continue to process requests from the client () by returning placeholders () in response to the requests. Alternatively, the items manager () may fulfill some client requests if the fulfillment of those requests is accounted for in the process of performing the refresh operation.","3. Compare Representations and Generate Change Notifications","Generating the change notifications may be done in any of various ways. For example, the set of change notifications could represent the deletion of all the data representation items () in the original local data representation () and the insertion of all the data representation items () in the updated local data representation (). However, such a set of change notifications may not provide the client () with enough information to communicate the changes to users in helpful ways.","Alternatively, the items manager () can generate a set of change notifications representing a set of changes that is plausible even if the true sequence of changes to the data set in the data source () is unknown to the items manager (). This may be done by the items manager () using techniques that can decrease the number of changes represented by the change notifications, so that the number of changes is less than other potential sets of changes, such as if the changes included the deletion of all the data representation items () in the original local data representation () and the insertion of all the data representation items () in the updated local data representation (). The client () can use such a set of change notifications to communicate the changes to users in various ways. For example, the client () may provide animations to highlight the changes. Additionally, the client () can communicate the changes in other ways. For example, if an item that happened to be displayed at the top of a screen showing a list of data representation items () is moved to another part of the data set in the data source (), the client can leave the visible window scrolled to its original location (and show all the subsequent data representation items ()), rather than scrolling the window just to keep that one item at the top of the screen.","Following is a description of one implementation of a technique that the items manager () can use to generate the change notifications. Overall, this technique can gradually alter the original local data representation () until it matches the updated local data representation (). This technique will be described with reference to , which illustrates a specific example of a portion of an original local data representation (), received updated data items () that were fetched in a refresh operation, and a resulting portion of an updated local data representation () after the list generation technique has been run.","In , as in  above, items are listed in their order in the representation, which may also be in order of the items' indices, as illustrated. In , triangles with question marks illustrate placeholders, triangles with capital letters illustrate data representation items that have been requested by the client and instantiated (e.g., rendered as UI descriptions that are sent to the client), and boxes with letters illustrate data representation items that have been returned from the data source but not requested by the client and not yet instantiated. The numbers below the question marks or capital letters indicate the index numbers for the items in the overall data set in the data source. Additionally, the capital letters can represent keys for the data representation items.","The original data representation () is illustrated as including two placeholders with indices  and  (representing items that had been requested by the client but not yet returned by the items manager), followed by instantiated data representation items D, E, F, and G with respective indices , , , and , and then followed by unrequested data items H and J, with respective indices  and . The received updated data items () include items C, D, Q, G, E, and R with respective indices , , , , , and . The received updated data items () can be compared to the original local data representation () to generate change notifications to be sent to the client. A technique for generating those change notifications will now be described.","In the technique, items that appear in the original local data representation (), but not in the received updated data items (), can be found. Remove-type change notifications can be sent for such items, and the items can be removed. For example, a remove-type notification for item F can be sent to the client, and item F can be removed from the local data representation. During this operation, access of the client can be limited so that the client is not permitted to observe indices on the items because such indices may be inconsistent. Alternatively, a client may be permitted to see such indices if the indices are changed and the client is informed of the index changes when other changes are made that may affect the indices. As yet another alternative, a client may be allowed to see indices even if the indices are inconsistent.","The technique can further include finding placeholders generated for items requested by index, and matching those placeholders to those items. For example, if the placeholders with indices  and  in the original local data representation were requested by index, this could include matching the placeholder having an index of  in the original local data representation () with the item C having the index  in the received updated data items (). This can be done before moving placeholders in the data representation to prevent placeholders for items requested by index from moving, because such movements of index-requested placeholders could result in a placeholder being matched with an item having an index other than the one requested.","While not illustrated in , the received updated data items () may be spread across multiple non-contiguous ranges. For example, this may occur because the client may be allowed to retain handles to non-contiguous ranges, so the original local data representation () may include multiple non-contiguous ranges of representation items requested by the client. Additionally, the items manager may request only a limited range around each item in the original local data representation (). The technique can include determining a match for each range in the received updated data items. For example, the match can include a range in the original local data representation () that shares the most individual items with the matching range in the received updated data items (). In some cases, ranges in the original local data representation () may be merged if the merged range maps to a range in the received updated data items ().","In the received updated data items (), boundaries of each range outside which all items do not appear in the original local data representation () can be marked. For example, this can include marking a boundary between items E and R in and between items C and D in the received updated data items (). These boundaries can distinguish between items that appear to have simply not been observed yet (e.g., items C and R) and items that have been inserted into the data set in the data source (e.g., item Q).","Of the items that appear in each range of the received updated data items () and its matched range in the original local data representation, a set of items that do not need to be moved relative to one another can be identified and marked as being stationary. This can be done in such a way that the number of such stationary items is increased and accordingly the number of move-type change notifications can be decreased. For example, with a list this can include assigning ordinals to the items in the original local data representation (), and then finding the \u201clongest ordered subsequence\u201d of those ordinals in the received updated data items. As an example, this can be done using a portion of the known \u201cpatience sorting\u201d technique. In the illustrated example of , this can result in identifying D and G as stationary, where D and G form the longest ordered subsequence. (Alternatively, the technique could have identified D and E as stationary with the same size ordered subsequence.)","If there are placeholders inside the marked boundaries discussed above, attempts can be made to match these placeholders to items in the received updated data items () that do not appear in the original local data representation (), based on neighbors that appear in both data sets. For example, if the placeholder with index  had not already been matched with item C because of matching index values, that placeholder could be matched with item C because item C and the placeholder have the same neighbor (item D).","The technique may include sending a move-type change notification for the non-stationary items that are in both the received updated data items () and the original local data representation (). The moves can be performed in the local data representation. For example, this can include sending a move-type notification for item E and moving item E to be after item G in the local data representation. When generating and sending these notifications, the client's access can be limited. For example, the client may be allowed to observe the neighbors of an item, but not the indices for the items.","The technique can further include finding new items that appear in the received updated data items (), but not the original local data representation (). These new items can be added to the local data representation, and corresponding inserted-type change notifications can be sent to the client. For example, in , item Q can be inserted after item D and an inserted-type change notification can be sent to the client. As with moves, the client's access can be limited when performing insertions. For example, the client can be allowed to observe the neighbors of any item, but not indices for items.","Additionally, the technique can include comparing contents of items that appear in both the original local data representation () and the updated local data representation (). For items whose contents have changed, the items can be updated in the local data representation and changed-type change notifications can be sent to the client. Again, the client's access can be limited during this operation, so that anything except indices can be observed by the client.","The technique can further identify items that appear in the original local data representation () and the updated local data representation () whose indices have changed. For example, in the example of , indices for items E and G can be changed and index changed-type change notifications can be sent to the client. During this operation, the client's access can be limited so that it can observe the old and new index of the changing item, but no other indices.","The technique can also include matching placeholders, which have not yet been matched to an item and are on the periphery of ranges in the original local data representation () to items outside the marked boundaries of the received updated data items (). Indices of placeholders from the original local data representation () can be updated based on the items they are matched to, or their adjacency to instantiated items or other placeholders. After this is done, limits on the client's access can be removed, and the client can be allowed to access the local data representation in the client's usual manner.","Placeholders that are matched to items in the received updated data items () can be instantiated with the matched items in the local data representation, and \u201citem available\u201d notifications can be sent. Additionally, if the overall count of items in the data set in the data source has changed (per information on the overall count being sent from the data source to the items manager or the data source returning the last data item in the data source list), then a count changed-type change notification can be sent to the client to indicate this change.","In the example of , the operations of the refresh technique discussed above can result in the original local data representation () at the top of  being updated to the updated local data representation () illustrated at the bottom of , and in appropriate change notifications being sent to the client. Other techniques could be used to do this in other ways that would be logical for the change notifications being sent at the time. For example, the order of the operations in the techniques discussed above could be changed so long as they still resulted in an orderly generation of the change notifications that can be properly processed by the client.","After the refresh operation has completed, the fetching of requested items for which there are still placeholders in the local data representation can resume. Such placeholders may have been present in the original local data representation (), and\/or they may have been inserted due to client requests for data during the refresh technique discussed above. For example, in the example of , this can result in fetching an item corresponding to the placeholder in the updated local data representation (). Accordingly, items can be fetched properly even if results from requests to the data source initiated prior to the refresh operation are ignored to simplify keeping the local data representation consistent at the end of the refresh technique.","III. Techniques for Optimistic Application of Data Edits","Several techniques for optimistic application of data edits will now be discussed. Each of these techniques can be performed in a computing environment. For example, each technique may be performed in a computer system that includes at least one processor and memory including instructions stored thereon that when executed by at least one processor cause at least one processor to perform the technique (memory stores instructions (e.g., object code), and when the processor(s) execute(s) those instructions, the processor(s) perform(s) the technique). Similarly, one or more computer-readable storage media may have computer-executable instructions embodied thereon that, when executed by at least one processor, cause at least one processor to perform the technique.","Referring to , a technique for optimistic application of data edits will be described. The technique can include maintaining () a data representation that represents source data at a data source. A request to perform an edit can be received () from a client, and a request can be sent () to the data source to make the edit to the source data. The edit can be optimistically applied () to the data representation. The technique can include sending () a change notification to the client. The change notification can indicate one or more changes to the data representation. The change(s) can be change(s) resulting from applying () the edit to the data representation. Additionally, a notification can be received () from the data source after applying () the edit to the data representation and after sending () the change notification. The notification from the data source can indicate whether the edit to the source data succeeded. The requests and notifications with the client may be made using various different types of communication types, such as application programming interface calls, cross-process messages, etc.","The technique can further include maintaining a queue of edits to be made to the source data. Maintaining the queue may also include removing an entry for the edit from the queue after receiving a notification that the edit was successfully made to the source data. The technique may include receiving from the data source a notification that the edit failed, undoing edits made to the data representation from edits in the queue, and discarding the edits in the queue. Alternatively, subsequent edits in the queue that depended on the failed edit could be identified, and those edits could be dequeued, without dequeueing other edits in the queue. Where the edit is a deletion edit, the failed edit may be discarded from the queue, and the edits in the queue other than the failed edit may continue to be processed.","The technique of  may include detecting an inconsistency between the data representation and the source data, and conducting a refresh operation for the data representation after attempting to complete edits in the edit queue.","The technique of  may include sending an edit result notification to the client after receiving the notification from the data source. The edit result notification can indicate whether the edit to the data source succeeded. The technique of  may also include sending a status notification to the client. For example, the status notification may indicate whether there are outstanding edits to the source data that are not yet completed. As another example, the status notification may indicate whether there is currently a state of error in editing the source data. A connection to the data source may be lost while edits to the data source are in an edit queue. If so, the status notification can indicate a state of error in editing the source data, and the technique can further include requesting that the data source apply the edits in the queue after the connection to the data source is restored. Such request(s) to the data source may be done without the client re-requesting the edits.","A conflict between the edit and a current state of the source data may be detected. Such a conflicting edit is one that does not make sense in light of a current state of the source data. For example, the edit may be asking for an item that no longer exists to be deleted, moved, etc. In such situations, a no longer meaningful notification may be received back from the data source. In response to detecting that the edit conflicts with the current state of the source data, the data representation can be refreshed to synchronize the data representation with the current state of the source data.","Referring now to , another technique for optimistic application of data edits will be described. The technique can include maintaining () a data representation representing source data at a data source. The technique can further include maintaining () a queue of edits to be made to the source data. A request to perform an edit can be received () from a client, and a request to make the edit to the source data represented by the data representation can be sent () to the data source. It can be determined () whether the edit to the source data synchronously failed. If not, then the edit can be applied () to the data representation, and a change notification can be sent () to the client, without waiting to be notified as to whether the edit to the source data succeeded. The change notification can indicate one or more changes to the data representation resulting from the application () of the edit to the data representation.","The technique of  may include refraining () from applying the edit to the data representation if the edit to the source data synchronously failed. Also, maintaining () edits can include removing an entry for the edit from the queue after receiving a notification that the edit was successfully made to the source data. The technique may include receiving from the data source a notification that the edit failed, undoing edits made to the data representation from edits in the edit queue, and discarding the edits in the edit queue.","Also, it can be determined () whether an edit conflicted with the source data (e.g., the edit is attempting to move an item that no longer exists, the edit is attempting to modify an item that no longer exists, etc.). If so, then a change notification can be sent () to the client to undo the conflicting edit and the data representation may be refreshed ().","The  technique may further include sending () a status notification to the client, where the status notification indicates whether there are outstanding edits to the source data that are not yet completed and\/or whether there is currently a state of error in editing the source data. When a connection to the data source is lost while edits to the data source are in an edit queue, the status notification can indicate a state of error in editing the source data, and the technique may further include requesting that the data source perform the edits in the queue after the connection to the data source is restored, without the client re-requesting the edits.","Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather, the specific features and acts described above are disclosed as example forms of implementing the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
