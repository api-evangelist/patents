---
title: Evaluating programmer efficiency in maintaining software systems
abstract: Quality of modularization of source code is tested using different perspectives such as a structural modularity perspective, an architectural modularity perspective, a size perspective, and a similarity of purpose perspective. A history of changes in modularization may be kept such that the degree to which given source code is well-modularized can be determined over time. The changes made to the code by individual programmers may be kept, such that the degree to which their coding enhanced or harmed modularization may be tracked.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08713513&OS=08713513&RS=08713513
owner: Infosys Limited
number: 08713513
owner_city: Bangalore
owner_country: IN
publication_date: 20061213
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["COPYRIGHT AUTHORIZATION","FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Overview of Technologies","Example 1","Exemplary System for Producing Modularization Quality Evaluation","Example 2","Exemplary Method for Producing Modularization Quality Evaluation","Example 3","Exemplary Modularization Quality Evaluation Results","Example 4","Exemplary System for Using a Modularization Evaluator in Conjunction with Source Code, and an Architectural Description of the Source Code to Determine Modularization Quality Evaluation Results","Example 5","Exemplary Method for Evaluating Source Code and an Architectural Description of the Source Code to Determine Modularization Quality Evaluation Results","Example 6","Exemplary System to Evaluate Modularization Quality of the Source Code Using a Model of the Source Code","Example 7","Exemplary Method to Evaluate Modularization Quality of the Source Code Using a Model of the Source Code","Example 8","Exemplary Component to Evaluate Modularization Quality of Source Code Using Different Modularization Perspectives","Example 9","Exemplary Method to Evaluate Modularization Quality of Source Code Using Different Modularization Perspectives","Example 10","Exemplary Modularization Quality Evaluator Component to Produce a Normalized Index","Example 11","Exemplary Method to Produce Modularization Quality Evaluation Results","Example 12","Exemplary Normalization","Example 13","Exemplary Notation Usage","Example 14","Exemplary API Function Identification","Example 15","Exemplary System to Evaluate Modularization Quality of System Source Code Using a Structural Perspective","Example 16","Exemplary Method to Evaluate Modularization Quality of System Source Code from a Structural Perspective","Example 17","Exemplary System to Evaluate Modularization Quality of System Source Code from an Architectural Perspective","Example 18","Exemplary Method to Evaluate Modularization Quality of System Source Code from an Architectural Perspective","Example 19","Exemplary System to Evaluate Modularization Quality of System Source Code from a Size Perspective","Example 20","Exemplary Method to Evaluate Modularization Quality of System Source Code from a Size Perspective","Example 21","Exemplary System to Evaluate Modularization Quality of System Source Code from a Similarity of Purpose Perspective","Example 22","Exemplary Method to Evaluate Modularization Quality of System Source Code from a Similarity of Purpose Perspective","Example 23","Exemplary System to Extract Concepts for Use in Similarity of Purpose Perspectives","Example 24","Exemplary Method to Extract Concepts for Use in Similarity of Purpose Perspectives","Example 25","Exemplary Source Code Modification History","Example 26","Exemplary System to Determine Programmer History","Example 27","Exemplary Method to Determine Programmer History","Example 28","Exemplary System to Determine Programmer Modularization Preservation","Example 29","Exemplary Method to Determine the Degree of Modularization Preservation by a Programmer","Example 30","Exemplary System to Generate Modularization Quality Evaluation Results and Degree of Modularization Preservation by Programmers Results","Example 31","Exemplary Method to Generate Modularization Quality Evaluation Results and Programmer Modularization Preservation Results","Example 32","Exemplary System to Generate Modularization Quality Evaluation Results","Example 33","Exemplary Method to Generate Modularization Quality Evaluation Results","Example 34","Exemplary System to Generate Modularization Quality Evaluation Results","Example 35","Exemplary Method to Generate Modularization Quality Evaluation Results","Example 36","Exemplary System to Determine which Changes in Source Code Produced a Modularity Change","Example 37","Exemplary Modularization Quality Report Overview","Example 38","Exemplary System Level Metric Report","Example 39","Exemplary Module-Level Metric Report Format for a Given Metric","Example 40","Exemplary Modularity Detail Report Format","Example 41","Exemplary Modularity Detail Report Format for a Given Module","Modularity Details for Module Modules\/Module3 Report","Example 42","Exemplary Method to Determine which Changes in Source Code Produced a Modularity Change","Example 43","Exemplary System to Determine Programmer Evaluation Results","Example 44","Exemplary Method to Determine Programmer Evaluation Results","Example 45","Exemplary Experimental Results Demonstrating the Difference Between Human and Random Modularization","Example 46","Exemplary Modularization Results Demonstrating the Difference Between Modularization of Different Versions of the Same Software","Example 47","Exemplary Concept Frequency Distribution for Both Human Modularization and Random Modularization Across a Module of Two Commercial Software Systems","Example 48","Exemplary Concept Frequency Distribution for Both Human Modularization and Random Modularization Across Multiple Modules of Two Commercial Software Systems","Example 49","Exemplary Programmer Performance Snapshot","Example 50","Exemplary Programmer Comparison Snapshot","Example 51","Exemplary Experimental Results Using Methods Taught Herein","Example 52","Exemplary Programmer Evaluation Experimental Result","Example 53","Exemplary Computing Environment","Example 54","Methods in Computer-Readable Media","Example 55","Exemplary Alternatives"],"p":["A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by any one of the patent disclosure, as it appears in the United States Patent and Trademark Office patent files or records, but otherwise reserves all copyright rights whatsoever. Portions copyright IEEE (IEEE Transactions on Software Engineering, 2007), used with permission.","The field relates generally to developing metrics to determine software quality. More particularly, the field relates to metrics developed to determine level of modularization of a software program.","Large software systems are generally developed systematically using structured development methodology. One common aspect is to organize the software into logical modules. Modules, ideally, are logical groupings of functions and related data structures that together offer a well-defined service. Correct module use promotes encapsulation. That is, implementation details are hidden, and interaction details with other modules (and the rest of the world) are consistently implemented through a set of published application programming interface (API) functions.","Modules themselves may be organized in layers. Layers, typically, are organized hierarchically such that modules in a given layer are only allowed to call modules in lower layers. Systems which are well modularized and which use layers properly are easier to understand as each change to the system only affects a small portion of the overall system. Thus, changes have less overall effect. For example, it takes less time to add new functionality, change existing functionality, and test and release the resulting modified modules even by those who are not conversant with the software.","Various measures of modularization have been proposed to determine modularization quality, such as cohesion metrics, coupling metrics, and combined cohesion\/coupling metrics. Cohesion measures how self-contained code is, that is, how well the code in a module works together to provide a specific piece of functionality without the need for assistance from other modules. For example, cohesion can be measured as the ratio of the number of internal function-call dependencies that actually exist to the maximum possible internal dependencies.","Coupling measures the dependency of different code groupings; that is, within a module, to what degree changes in one function may affect other. Low coupling usually implies high cohesion, and vice versa. Ideally modules should have high cohesion (be self-contained) and low coupling (be relatively independent of other modules.)","One common metric, Modularization Quality (MQ), is a combined cohesion\/coupling metric, and is calculated as the difference between the average cohesion and the average coupling.","Variations on the MQ which have been developed include a modified MQ which is the sum of modularization factors (MF) for clusters. For a given cluster, MF can be calculated as",{"@attributes":{"id":"p-0010","num":"0009"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mi":"i","mrow":{"mi":"i","mo":"+","mrow":{"mrow":{"mn":["1","2"],"mo":"\/"},"mo":"*","mi":"j"}}},"mo":","}}},"br":{}},"Metrics have also been derived from a relational graph representation of software artifacts such as functions, data types, variable, etc. Relations such as function-call dependencies, type declaration of variables, macro definitions, and so on are mapped between modules. This class of metrics measures the degree of association between a module and other modules.","Other metrics include measures of how many methods are packed into classes, the depth of inheritance trees, inheritance fan-out, and measures of the degree of couplings between objects, where couplings are created by one object invoking a method on another object.","Tools which have been developed for software clustering have also, albeit indirectly, proposed modularization metrics. Software clustering tools may be used to determine, or more usually, recover the underlying architecture of, a software system after some catastrophic event. These tools attempt to partition a software system into logical, cohesive subsystems. For example, automated software-partitioning tools have been developed which quantitatively characterize modules by the degree to which the functions packaged within the same module contain shared information, such as by determining the degree of commonality of the names of data objects within the functions. Modules can also be characterized on the basis of function-call dependencies, such that if a function A calls a function B, then functions A and B are presumed to belong to the same module. Other metrics have also been proposed. These include quantitatively characterizing the degree to which functions packaged within the same module contain shared information. Functions may share information, for example, on the commonality of the names of data objects.","Structural information, such as shared name substrings for functions and variables, function-call dependencies, and so on can also be used to determine modularization. Another approach is to try to isolate \u201comnipresent objects,\u201d which are heavily-used object and functions. Analyses, such as those described earlier, relating to cohesion and coupling are then performed. This is done with the belief that omnipresent objects, unless specially categorized, distort the coupling\/cohesion analysis.","However, these complexity metrics do not analyze the software from a coherent set of perspectives that together give an overall impression of how well the system is modularized from a variety of perspectives. That is, they do not analyze a system at large in terms of their modules, the cohesiveness of the modules, the interactions between modules, and how well the system has been divided into layers\u2014super-modules. Furthermore, even the best-designed system can have its modularity degrade as the system ages and is maintained.","Even though a legacy application development can begin as a well modularized system with a layered architecture, it gradually degrades over a period of time as the system is maintained. The degradation in modularity can happen due to ad-hoc bug fixes and enhancements which disregard modularity design principles, such as have been discussed. Such degradation in modularity can cause a formerly robust system to become rigid and fragile.","In such a scenario, a manager who has responsibility for maintenance and enhancement of a legacy application, is not in a position to take appropriate corrective measures in spite of realizing the gradual degradation of the maintainability of the system if he or she has no way to accurately measure the type and location of the degradation or who, specifically, is causing the degradation. Because there is currently no good way to measure this degradation, there is similarly no good way to determine when the degradation occurs, or who or what is the likely cause of such degradation.","As the deterioration of modularity is not recognized, there is no reason for programmers, unaware of the problem, to concentrate on fixing the problem. Furthermore, there is no way to measure how well an individual programmer may be preserving or degrading the modularity of the system.","Thus, there is a need for systems and methods to measure system modularity that is, modularization quality.","In an exemplary embodiment, a modularization evaluator may be used to determine the quality and\/or the degree of modularization of a portion of software source code. This modularization evaluator may have a number of modules.","Modularization quality of modules may be evaluated using a structural modularity perspective which measures function-call traffic through an Applications Programming Interface (API) of at least one module. This metric may be calculated by one or more of the following indices: a model interaction index, an implicit dependency index, a non-API function closedness index, and an API function usage index.","Modularization quality of modules may be evaluated using an architectural modularity perspective that measures organization of modules into hierarchical partitions. This metric may be calculated by one or more of the following indices: a layer organization index, a cyclic dependency index, a model interaction stability index, and a testability index.","Modularization quality of modules may be evaluated using a size perspective that measures uniformity of module sizes in relation to total size of the source code, and which may have one or more of the following indices: a module size uniformity index and a module size boundedness index.","Modularization quality of modules may be evaluated using a similarity of purpose perspective that measures similarity of purpose of groupings within the source code, and which may have one or more of the following indices: a concept domination metric, and a coherency metric.","A history of changes in modularization as reflected in the source code may be kept such that the degree to which given source code is well-modularized can be determined over time. The changes made to the code by individual programmers may be kept, such that the degree to which their coding enhanced or harmed modularization may be tracked.","The foregoing and other objects, features, and advantages of the invention will become more apparent from the following detailed description, which proceeds with reference to the accompanying figures.","The technologies described herein can be used in any of a variety of scenarios in which accurate determination of modularization of a software system or a portion of a software system is useful. For example, owners of software systems consisting of legacy code (which may consist of a million lines or more) may need to know whether the code should be automatically or semi-automatically modularized. To make this determination, the current degree of modularization must be understood. Furthermore, once such code is modularized, the success of the modularization can be determined by applying any of the techniques taught herein.","As another example, a company wishing to maintain existing code with a high degree of modularization can use the systems and methods herein to measure the quality of code at different times and thus take steps to ensure that the code's modularization does not degrade over time.","As a further example, a company can track the changes made by specific programmers to code, which may be legacy code, and by applying the modularization metrics taught herein, can determine the degree to which various programmers inadvertently introduced changes into the given body of software that has led to deterioration of the system modularity.","Source code includes any computer programming files that are human-readable, but that can be converted to machine-readable form. The type of source code used is not a limitation on the embodiments described herein. For example, and without limitation, the source code can be written in one, or more than one programming languages, thousands of which exist. Examples of possible source code programming languages include, but are not limited to, COBOL, C, C++, and Java.","A module is a logically cohesive unit of code. This may include files, functions, data structures, variables, and the like. For example, it may be a group of related classes (in object-oriented programming), may be substantially all the code in a single file, may be a group of related files, or the modules may be organized in a different fashion.","The word function here indicates any software grouping with input-output functions, such that procedures, subprograms, etc., are included.",{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 1","b":["100","170","110","110","150","170","150"]},{"@attributes":{"id":"p-0086","num":"0085"},"figref":["FIG. 2","FIG. 1"],"b":["200","100","200"]},"At  source code (e.g., the source code  of ) representing at least a portion of a software program is received. At , the modularization of the source code  is evaluated. As described in the examples, modularization can be evaluated by a variety of metrics, including but not limited to: coupling-based structural metrics, size-based metrics, architectural metrics, metrics based on similarity of purpose, and the individual metrics contained therein.","At , the results (e.g., the modularization quality evaluation results ) of the evaluation of the modularization of the source code is generated using the output of the source code evaluation .","In any of the examples herein, the exemplary modularization quality evaluation results can comprise any one or more of the modularization metrics described herein.","The degree and quality of modularization can be observed from various perspectives which guide, but do not drive, the specifics of the various modularization metrics. Each of the modularization metrics embodiments discussed in any of the examples may incorporate one or more of the following modularization principles, discussed below.","Principles Related to Similarity of Purpose.","A module, ideally, groups a set of data structures and functions that together offer a well-defined service\u2014similarity of purpose. The following principles can be used to determine if individual modules have a similar purpose:\n\n","Principles Related to Module Encapsulation.","Encapsulating the implementation code of a module and requiring that the external world interact with the module through its published API's is a widely accepted design practice. The following modularization principles can be used to capture these notions:\n\n","Principle Related to Module Extendibility.","One of the most significant reasons for object-oriented software development is that the classes (subclassing) can be easily extended whenever one desires a more specialized functionality. Extending object-oriented software through the notion of subclassing allows for a more organized approach to software development and maintenance since it allows for easier demarcation of code authorship and responsibility. While module-level compartmentalization of code does not lend itself to the types of software extension rules that are easy to enforce in object-oriented approaches, one nonetheless wishes for the modules to exhibit similar properties when it comes to code extension and enhancement. The following principle captures these aspects of code modularization:\n\n","Principle Related to Module Testability.","Testing is a major part of software development. A common form of testing, requirements-based testing, ensures that, at a minimum, the software conforms to chosen standards and protocols. Testing must also ensure that the software behaves as expected for a full range of inputs, both correct and incorrect, from users and processes, at the level of program logic in the individual functions and at the module interaction level. Furthermore, testing must take into account the full range of competencies of other agents that are allowed to interact with the software. Testing procedures can easily run into combinatorial problems when modules cannot be tested independently. For example, if each module is to be tested for N inputs, the two interdependent modules must be tested for Ninputs. Modularization must therefore strive to fulfill the following principle:\n\n","Cyclic dependencies between modules of a body of software should be minimized. Cyclic dependencies exist when two or more modules depend on each other. This leads to combinatorial problems when testing, difficulty in testing modules separately, and, most troublingly, the requirement that modules must be aware of the evolution of internal details of other modules\u2014defeating the purpose of modularity. Cyclic dependencies becomes even more of a problem when modules are organized in horizontal layers, as often happens in reasonably-sized, reasonably-designed software systems. Layering serves an important organizational function; modules in one layer can, optimally, only seek the services of the layers below it. When modules in one layer require the services of higher layers (as indicated by cyclic dependencies) the purpose of layering is defeated. Therefore, modularization should follow the principle:\n\n","Principles Related to Module Size.","It is believed that modules of a large software system should be roughly the same size. As is intuitively plausible, the number of defects in a module goes up with the size of the module. But, counterintuitively, the overall number of defects in a large software system also rises when the individual modules are too small. Therefore, modularization should follow the principles:\n\n","The modularization metrics embodiments taught herein relate to at least one of the principles enumerated in this example.",{"@attributes":{"id":"p-0102","num":"0111"},"figref":"FIG. 3","b":["300","370","310","320","350","370"]},"Modern software engineering dictates that software should generally be organized along a set of modules. One way of thinking about modules is that they capture a set of design decisions which are hidden from other modules. Furthermore, the interaction between modules should primarily be through module interfaces. A module can also be thought of as grouping a set of functions and data structures. This often leads to a specific module implementing one or more business concepts. This grouping may take place, for example, on the basis of similarity of purpose or on the basis of commonality of goal. The difference between the two is subtle but important. As example of a module that represents the first type of grouping is the java.util package of the Java platform. The different classes of this package provide different types of containers for storing and manipulating objects. A module such as the java.net package is designed to provide support for networking\u2014commonality of goal. The asymmetry between modules may be exemplified by the fact that you are likely to use a java.util class in a java.net based program, but much less likely to do so the other way around.","In either case, modules promote encapsulation (information hiding) by separating the module's interface from its implementation. The module interface expresses the elements that are provided by the module for use by other modules. In a well-organized system, the interface elements are visible to other modules, while the implementation, hidden from other modules, contains the working code that corresponds to the elements declared in the interface. Such a module interface is known as its Application Programming Interface (API). It is widely accepted that the overall quality of software is generally enhanced when interactions between modules are restricted to take place through the published API's for the module.","The architectural description of the source code  is a description of how the source code is partitioned into modules; that is, what portion of the code belongs to which module. This description  may also include a description of how the modules are organized into layers. This organization description may be in the form of original design documents, or the organization description may be built into the source code itself, in which case there are markers of some kind in the code that indicate which portions of the code belong to which modules and to which layers. Modularization of code may be determined by someone of skill in the art, and may be entered by hand, either in part, or for the entire system being evaluated, into a user interface of the modularization evaluator. The architectural description  may be derived from modularization results received from an automatic modularizer, in which case, the output of the automatic modularizer is used, either as is, or converted to a form that the modularization evaluator  can read.",{"@attributes":{"id":"p-0106","num":"0115"},"figref":["FIG. 4","FIG. 2","FIG. 3","FIG. 3"],"b":["400","200","410","310","415","320","410","415","420","320","310","430"]},"In any of the examples herein describing evaluating source code, a model of the source code can be evaluated instead of or in addition to the source code.  shows an exemplary system  to evaluate modularization quality of the source code using a model of the source code. Source code  (e.g. the source code  of ) is received. A source code model extractor  parses the source code  and derives a high level model of the source code . This high-level model  can be used for the source code  in any of the examples given herein.","The high level model can comprise file information, function information, function dependency information, global variable information, data structure information, dependency between global variables and functions, data structures and functions, and other programming constructs. In one embodiment, the source code information is stored in an SQL (Structured Query Language) database.",{"@attributes":{"id":"p-0109","num":"0118"},"figref":["FIG. 6","FIG. 5","FIG. 5"],"b":["600","500","610","615","510","610","615","620"]},{"@attributes":{"id":"p-0110","num":"0119"},"figref":"FIG. 7","b":["700","752","754","756","758","150"]},"Source code  (e.g. the source code  of ) is received. This source code is used as input for any of the evaluators , , ,  shown.","The structural perspective modularity evaluator  evaluates the source code  from a coupling-based structural perspective that provides various measures of the function-call traffic through the API's of the modules in relation to the overall function-call traffic producing modularization quality evaluation results .","The architectural perspective modularity evaluator  evaluates the source code  by determining how well modules within the source code are organized into higher-level structures, with an emphasis on the horizontally layered structures. The architectural perspective modularity evaluator  produces modularization quality evaluation results .","The similarity of purpose modularity evaluator  evaluates the source code  based on clues provided within the source code on the purposes of the modules and their constituent parts. In software, it is frequently the case that either the name of a function, the names of variables within a function, words within the comments of a function, etc., hold some clue as to the purpose of the function inside the module and to the purpose of the module itself. The developers of complex software often leave behind clues as they name variables, comment code, write debugging routines, and the like. These clues can be thought of as \u201cconcepts.\u201d For example, given the case of a module devoted to interest calculations in banking software, a concept might be the word \u201cinterest\u201d, which is likely to show up in various artifacts of the module either in its full or an abbreviated form. With regard to software characterization, such concepts may then be used by the similarity of purpose modularity evaluator  to assess whether or not the software adheres to the principles that are based on the semantics of the module contents. The similarity of purpose modularity evaluator  produces modularization quality evaluation results .","The size perspective modularity evaluator  evaluates whether the modules within the software code  are approximately equal in size, and whether the average module size is appropriate for the software code  as a whole. The size perspective modularity evaluator  produces modularization quality evaluation results .",{"@attributes":{"id":"p-0116","num":"0125"},"figref":["FIG. 8","FIG. 3"],"b":["800","350","810","820","830","840","810","820","830","840"]},"At , modularization quality is evaluated via a structural perspective. At , modularization quality is evaluated via an architectural perspective. At  modularization quality is evaluated via a testability perspective. At , modularization quality is evaluated via a size perspective. At , modularization quality results are generated based on the one or more perspective evaluations.",{"@attributes":{"id":"p-0118","num":"0127"},"figref":["FIG. 9","FIG. 1","FIG. 5","FIG. 3"],"b":["900","902","110","510","950","350","902","962"]},"Any of the modularization indices discussed, for example, in connection with example 8, may be used for the evaluation by the modularization results evaluator . This metric index  may be any number at any scale. A metric index normalizer  then normalizes the metric index  to produce a normalized index  such that its value lies between 0 and 1, with 0 being the lowest, worst, score\u2014poor modularization, and 1 indicating the highest score possible\u2014the best possible modularization. The normalized index can then be used as the entire, or as a portion of, any of the modularization quality evaluation results described herein, such as the modularization quality evaluation results  ().",{"@attributes":{"id":"p-0120","num":"0129"},"figref":["FIG. 10","FIG. 9","FIG. 1","FIG. 5"],"b":["1000","950","1010","110","510","1032","1036"]},"In any of the examples herein, normalization can normalize an index so that it falls within a range (e.g., 0-1, 0-11, and the like).","In any of the examples herein, the notation that follows can be used.","If M denotes a set of elements, |M| denotes its cardinality; that is the total count of the elements in the set.","S, the source code, will be considered to consist of M modules {m, m, . . . , m}.","All of the functions in S will be denoted by the set F={\u0192, \u0192, . . . , \u0192}. These are assumed to be distributed over the M modules.","An API function for a given module is denoted as \u0192.","A non-API function for a given module is denoted as \u0192.","The notation L denotes the set of layers {L, L, . . . , L} into which the modules have been organized.","K(\u0192) denotes the total number of calls made to a function \u0192 belonging to a module m. Of these, K(\u0192) denotes the number of calls arriving from other modules, and K(\u0192) indicates the number of calls from within the same modules. It follows, therefore, that K(\u0192)=K(\u0192)+K(\u0192).","{circumflex over (K)} (\u0192) denotes the total calls made by a function f.","For a module m, K(\u0192), K(\u0192)\u2266K(\u0192) denotes the external calls made to function f in the module m from the module m.","K(m) denotes the total number of external function calls made to the module m. If m has \u0192. . . \u0192functions, then",{"@attributes":{"id":"p-0133","num":"0142"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":["K","ext"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}},{"munder":{"mo":"\u2211","mrow":{"mi":"f","mo":"\u2208","mrow":{"mo":["{","}"],"mrow":{"msub":[{"mi":"f","mn":"1"},{"mi":["f","n"]}],"mo":["\u2062","\u2062","\u2062"],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}}}}},"mo":"\u2062","mrow":{"mrow":{"msub":{"mi":["K","ext"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"f"}},"mo":"."}}],"mo":"="}}}},"In any of the examples herein, API functions (as opposed to non-API functions) can be identified using the heuristic that an ideal API function is called, generally, by functions belonging to other modules. Similarly, an ideal non-API function is never exposed; that is, it is never called by functions from other modules. Using this heuristic, a function can be declared to be API or non-API depending on the relative frequency of the function being called from other modules versus the frequency the function is called by its home module. Two threshold parameters, \u03b1, and \u03b2 are defined. For a function f in a module m, having K(F) number of calls made to it, where K(F) are the external calls made to it and K(F) are the internal calls made to it. If K(F)>\u03b1\u00b7K(F), f is considered to be an API function for m. Similarly, a function f\u2032 in the module m is treated as a non-API function if K(f\u2032)>\u03b2\u00b7K(F).",{"@attributes":{"id":"p-0135","num":"0144"},"figref":["FIG. 11","FIG. 7"],"b":["1100","11102","1142","752","1153","1155","1157","1159","11170"]},"It should be noted that each of the structural indices , , , and  are expressed as normalized values, with the worst value being 0 and the highest being 1. Other equally valid indices with a different range of values are also envisioned, following the teachings here.","Module Interaction Index","The module interaction index  (abbreviated MII) calculates how effectively a module's API functions have been used by the other modules in the system. The total number of function calls (or close to the total) made through modules is calculated. This can be calculated in any fashion as known to someone of skill in the art. The total number of API functions made through modules is also calculated.","Assume that a module m has n functions {\u0192. . . . \u0192}, out of which, there are n1 API functions {\u0192. . . \u0192}. Also assume that the system \u03a3 has m. . . m, modules. Then, the model interaction index (MII) , for modules calculated, becomes the total number of function calls made through the API in the module, as calculated, divided by the total number of function calls made in any fashion within the module, as calculated. Expressed using the notation described in example 12, this becomes:",{"@attributes":{"id":"p-0139","num":"0148"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"MII","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}},"mo":"=","mfrac":{"mrow":[{"munder":{"mo":"\u2211","mrow":{"msup":{"mi":["f","a"]},"mo":"\u2208","mrow":{"mo":["{","}"],"mrow":{"msubsup":[{"mi":["f","a"],"mn":"1"},{"mi":["f","a"],"mrow":{"mi":"n","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}],"mo":["\u2062","\u2062","\u2062"],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}}}}},"mo":"\u2062","mrow":{"msub":{"mi":["K","ext"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["f","a"]}}}},{"msub":{"mi":["K","ext"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}]}}}},"br":{}},"For the entire system, the MII  is the sum of individual MII module values divided by the total number of modules, or:",{"@attributes":{"id":"p-0141","num":"0150"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"MII","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"S"}},{"mfrac":{"mn":"1","mi":"M"},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"M"},"mo":"\u2062","mrow":{"mi":"MII","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["m","i"]}}}}}],"mo":"="}}}},"As an alternative formulation of the module interaction index , K(\u0192) and K(\u0192) can be calculated as a weighted sum of the number of times the function \u0192 and \u0192are called externally. For example, if a function \u0192 in a module m is called 5 times from module mand 7 times from module m, rather than K(\u0192)=5+1, as in the previous calculation, K(\u0192), =(w*5)+(w*7). Each module would be weighted depending on its relative importance with relation to module m. The weights, generally, would be values between 0 and 1. If both weights equal 1, the formula reduces to the previous version of MII. Similarly, MII(S)  can be a simple average, a weighted average, a median value, etc.","The module interaction index  measures if a given software system adheres to the module encapsulation principle discussed with reference to example 3. Recall, that this principle suggests that a well designed module should expose a set of API functions through which other modules would interact. The API functions can be thought of as the service that the module has to offer. Since these API functions are meant to be used by the other modules, the internal functions of a module typically do not call API functions of the module. Therefore, to the maximum extent possible, a non-API function of a module should not receive any external calls.","It may be observed, that in the first equation, above,",{"@attributes":{"id":"p-0145","num":"0154"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"munder":{"mo":"\u2211","mrow":{"msup":{"mi":["f","a"]},"mo":"\u2208","mrow":{"mo":["{","}"],"mrow":{"msubsup":[{"mi":["f","a"],"mn":"1"},{"mi":["f","a"],"mrow":{"mi":"n","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}],"mo":["\u2062","\u2062","\u2062"],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}}}}},"mo":"\u2062","mrow":{"msub":{"mi":["K","ext"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["f","a"]}}}},"mo":","}}},"br":{}},"Certain types of modules, such as driver modules, are used in some systems to orchestrate the other modules. For these driver modules, MII(m) may be very close to 0. In such cases, it should still be understood that the overall goal of a modularization effort should be to achieve a large MII for those modules in which such a measurement makes sense.","Implicit Dependency Index","The implicit dependency index  (abbreviated IDI) measures the number of functions that write to global entities in modules other than the ones they reside in. An insidious form of dependency between modules comes into existence when a function in one module writes to a global variable that is read by a function in another module. The same dependence occurs when a function in one module writes to a file whose contents are important to the execution of another function in a different module, such as when modules interact with one another through shared database files. Such dependencies can be thought of as implicit dependencies.","Detecting implicit dependencies often requires a dynamic runtime usage scenario analysis of the software. Such analysis is both time-consuming and difficult, and becomes more so the larger the size of the system under consideration. An easier metric is proposed here. The Implicit Dependency Index (IDI)  is constructed by recording, for modules, the number of functions that write to global entities (such as variables, files, databases), when the global entities are also accessed by functions in other modules. This is done on the belief that the larger this count is in relation to the total inter-module traffic, the more implicit dependencies exist.","To calculate the IDI , some new notation must first be defined. D(m, m), i\u2260j denotes the number of dependencies created when a function in mwrites to a global entity that is subsequently accessed by some function in m. Let D(m, m), i\u2260j denote the number of explicit calls made by functions in mto functions in m. C(m) is the set of modules that depend on mby having at least one implicit dependency. This metric assumes that the larger Dis in relation to D, the worse the modularization of the software. The metric IDI  is defined as follows:",{"@attributes":{"id":"p-0150","num":"0159"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":"IDI","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}},"mo":"=","mfrac":{"mrow":[{"munder":{"mo":"\u2211","mrow":{"msub":{"mi":["m","j"]},"mo":"\u2208","mrow":{"mi":"C","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}}},"mo":"\u2062","mrow":{"msub":{"mi":["D","f"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"m","mo":",","msub":{"mi":["m","j"]}}}}},{"munder":{"mo":"\u2211","mrow":{"msub":{"mi":["m","j"]},"mo":"\u2208","mrow":{"mi":"C","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}}},"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"msub":{"mi":["D","f"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"m","mo":",","msub":{"mi":["m","j"]}}}},{"msub":{"mi":["D","f"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"m","mo":",","msub":{"mi":["m","j"]}}}}],"mo":"+"}}}]}}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"when","mrow":{"mi":"C","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}},"mo":"=","mi":"\u2205"}}}},{"mtd":{"mrow":{"mrow":[{"mi":"IDI","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"S"}},{"mfrac":{"mn":"1","mi":"M"},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"M"},"mo":"\u2062","mrow":{"mi":"IDI","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["m","i"]}}}}}],"mo":"="}}}]}}}},"As an alternative formulation of APIU(m), modules m\u2122C(m) that have indirect dependencies with m can be weighted. Using the same notation as the previous metrics, IDI(m) can be generalized as:",{"@attributes":{"id":"p-0152","num":"0161"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"IDI","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}},{"mfrac":{"mrow":[{"munder":{"mo":"\u2211","mrow":{"msub":{"mi":["m","j"]},"mo":"\u2208","mrow":{"mi":"C","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}}},"mo":"\u2062","mrow":{"mrow":[{"msubsup":{"mi":["w","m","f"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["m","j"]}}},{"msub":{"mi":["D","f"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"m","mo":",","msub":{"mi":["m","j"]}}}}],"mo":"*"}},{"munder":{"mo":"\u2211","mrow":{"msub":{"mi":["m","j"]},"mo":"\u2208","mrow":{"mi":"C","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}}},"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mrow":[{"msubsup":{"mi":["w","m","d"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["m","j"]}}},{"msub":{"mi":["D","g"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"m","mo":",","msub":{"mi":["m","j"]}}}}],"mo":"*"},{"mrow":[{"msubsup":{"mi":["w","m","f"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["m","f"]}}},{"msub":{"mi":["D","f"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"m","mo":",","msub":{"mi":["m","j"]}}}}],"mo":"*"}],"mo":"+"}}}]},"mo":"."}],"mo":"="}}},"br":{},"sup":["d ","f "]},"With regard to where this metric belongs in the landscape of principles presented in example 3, ideally, all interaction between modules should be through published API functions, implying that the number of implicit dependencies must be few and far between. Therefore, in an ideal API-based system the IDI  would be equal to one. This is in conformance with the principle of module encapsulation which requires a minimum of such implicit, non-API-based communications.","The IDI  is then used as a modularization quality evaluation result .","Non-API Function Closedness Index","The non-API function closedness index  (abbreviated NC) calculates how effectively a module's non-API functions are used. Ideally, the non-API functions of a module should not bypass the API, that is they should not expose themselves to the external world. In reality, however, a module may exist in a semi-modularized state where inter-module calls are made outside the APIs. This is especially true in large legacy systems that have been only partially modularized. In this intermediate state, functions may exist that participate both in inter-module and intra-module call traffic. The extent of this traffic is measured using the non-API function closedness index .","Extending the notation presented in example 13, let Frepresent the set of functions within a module m; Frepresent the set of API functions within module m, and Frepresent the non-API functions within module m. Ideally, F=F+F. However, it is difficult enough to categorize a function with enough particularity to determine whether it is an API function or a non-API function, so it is understood that the theoretical ideal will most likely not be met.","In any case, NC  is measured, for a specific module, by dividing the number of non-API functions by the sum of the total number of functions minus the API functions. In the notation we have defined, this becomes:",{"@attributes":{"id":"p-0158","num":"0167"},"maths":{"@attributes":{"id":"MATH-US-00008","num":"00008"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"NC","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}},"mo":"=","mfrac":{"mrow":[{"mo":["\uf603","\uf604"],"msubsup":{"mi":["F","m","na"]}},{"mrow":[{"mo":["\uf603","\uf604"],"msub":{"mi":["F","m"]}},{"mo":["\uf603","\uf604"],"msubsup":{"mi":["F","m","a"]}}],"mo":"-"}]}}}}},"If there are no non-API functions in a given module, it can be seen that NC(m) equals 0.","For the system NC , the index is the total of the individual module indices divided by the total number of modules, or:",{"@attributes":{"id":"p-0161","num":"0170"},"maths":{"@attributes":{"id":"MATH-US-00009","num":"00009"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"NC","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"S"}},{"mfrac":{"mn":"1","mi":"M"},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"M"},"mo":"\u2062","mrow":{"mi":"NC","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["m","i"]}}}}}],"mo":"="}}}},"As an alternative formulation of NC(m) user-defined weights can be introduced for each, or some of the sets of functions, such that:",{"@attributes":{"id":"p-0163","num":"0172"},"maths":{"@attributes":{"id":"MATH-US-00010","num":"00010"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"NC","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}},{"mfrac":{"mrow":[{"msub":{"mi":"w","mn":"1"},"mo":"*","mrow":{"mo":["\uf603","\uf604"],"msubsup":{"mi":["F","m","na"]}}},{"mrow":[{"msub":{"mi":"w","mn":"2"},"mo":"*","mrow":{"mo":["\uf603","\uf604"],"msub":{"mi":["F","m"]}}},{"msub":{"mi":"w","mn":"3"},"mo":"*","mrow":{"mo":["\uf603","\uf604"],"msubsup":{"mi":["F","m","a"]}}}],"mo":"-"}]},"mo":"."}],"mo":"="}}}},"Similarly, NC(s) can be calculated as a simple average (as is shown above), a weighted average, a median value, etc.","As a well-designed module does not expose the non-API functions to the external world, and assuming we correctly categorize functions as either API functions or non-API functions, F-Fshould be equal to F. Therefore, NC(m)=1 for an ideal module, with NC(m)=0 for a module where non-API functions are exposed.","API Function Usage Index","The API function usage index  (abbreviated APIU) determines what fraction of the API functions exposed by a module are being used by the other modules. When a big, monolithic module presents a large and versatile collection of API functions offering many different services, any one of the modules with which it interfaces may need only a fraction of its services. That is, any single module interacts with it may only use a small portion of its API. This indicates improper module design and suggests that the module does not have a coherent purpose. It is considered a better design for such modules to be split into smaller (or at least different) modules which offers a set of services, the bulk of which will be used by most of the modules that access it.","To calculate this metric, suppose that m has n API functions, and that nnumber of the API functions are called by a module m. Also suppose that there are k modules m. . . mthat call one or more of the API function of module m. The APIU  for a single module is equal to the sum of the number of API functions in m called by each module that interfaces with m divided by the quantity equal to the total number of modules that interface with m multiplied by the number of functions in m. Mathematically, this can be written as:",{"@attributes":{"id":"p-0168","num":"0177"},"maths":{"@attributes":{"id":"MATH-US-00011","num":"00011"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"APIU","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}},"mo":"=","mfrac":{"mrow":[{"munderover":{"mo":"\u2211","mrow":{"mi":"j","mo":"=","mn":"1"},"mi":"k"},"mo":"\u2062","msub":{"mi":["n","j"]}},{"mi":["n","k"],"mo":"*"}]}}}}},"It can be seen that APIU(m) equals 0 if m has no API functions, or if there are no other modules that interact with m.","The APIU  of a system E is the sum of the APIU's of individual modules divided by the number of modules with a non-zero number of APIU functions, which can be expressed as:",{"@attributes":{"id":"p-0171","num":"0180"},"maths":{"@attributes":{"id":"MATH-US-00012","num":"00012"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"APIU","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"S"}},{"mfrac":{"mn":"1","msub":{"mi":["M","apiu"]}},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"msub":{"mi":["M","apiu"]}},"mo":"\u2062","mrow":{"mi":"APIU","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["m","i"]}}}}}],"mo":"="}}}},"As an alternative formulation of APIU(m), each module m. . . mwhich calls one or more of the API function of module m may be assigned an importance for their interaction with m. This importance is modeled as w(m) and can be a number between 0 and 1. The alternate formula for APIU(m) then becomes:",{"@attributes":{"id":"p-0173","num":"0182"},"maths":{"@attributes":{"id":"MATH-US-00013","num":"00013"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"APIU","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}},"mo":"=","mfrac":{"mrow":[{"munderover":{"mo":"\u2211","mrow":{"mi":"j","mo":"=","mn":"1"},"mi":"k"},"mo":"\u2062","mrow":{"mrow":{"msub":{"mi":["w","m"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["m","j"]}}},"mo":"*","msub":{"mi":["n","j"]}}},{"mi":["n","k"],"mo":"*"}]}}}}},"When the weights are equal to 1, the formula reduces to the previous version of APIU. Furthermore, APIU(S) can be processed a simple average as shown above, a weighted average, a median value, etc.","This metric characterizes the software, albeit indirectly and partially, in accordance with the similarity of purpose principles. For example, maximizing module coherence on the basis of commonality of goals requires that the modules not be monolithic pieces of code which provide disparate services. Making modules focused with regard to the nature of their services should push the APIU metric  at least closer to its maximum value, 1. However, it should be noted that this metric does not actually analyze the specificity of the API functions, but is merely an artifact that occurs when such specificity exists. Therefore, this APIU metric  can be considered in conjunction with the other metrics for its full benefit.",{"@attributes":{"id":"p-0176","num":"0185"},"figref":["FIG. 12","FIG. 11","FIG. 11"],"b":["1200","1150","1252","1254","1256","1258","1252","1254","1256","1258","1153","1155","1157","1159"]},"At , module interaction is calculated. This can produce a module interaction index  (). In an exemplary embodiment, to calculate the module interaction index, for each module the total number of external function calls made through APIs for that specific module are calculated. Also, the total number of external calls to each module is calculated. At , results can be generated using the module interaction index .","At , the implicit dependency of a module is calculated. This can produce an implicit dependency index  ().","At , the non-API function closedness index is calculated. This can produce a non-API function closedness index  ().","At , the API function usage index is calculated. This can produce an API function usage index  ().","At , after one or more structural performance module evaluations have been calculated, results can be generated from the one or more calculated indices.",{"@attributes":{"id":"p-0182","num":"0191"},"figref":["FIG. 13","FIG. 7"],"b":["1302","1344","754","1353","1355","1357","1359","1370"]},"Architecture here can mean an organization of modules into higher-level structures, especially the horizontally-layered structures. Generally, good software design requires that modules in any one layer are only allowed to call modules in layers below them. This keeps the lower modules, which should have more basic functionality, more stable with respect to any future changes. However, imposing (or preserving) such layering on modules is complicated by the presence of cyclic dependencies between modules. The metrics here relate the layered organization of modules in the presence of possible cyclic dependencies.","It should be noted that each of the architectural modularity indices , , , and  are expressed as normalized values, with the worst value being 0 and the highest being 1. Other equally valid indices with a different range of values are also envisioned, following the teachings here.","The Cyclic Dependency Index","The Cyclic Dependency Index , abbreviated \u201cCyclic,\u201d measures the extent of cyclic dependencies between the modules of a system. This metric is based on the notion of strongly connected components, abbreviated SCC, in a directed module dependency graph MDG=<M,E>, where M represents the nodes corresponding to the modules, and E represents the arcs between nodes\u2014indicating pairwise dependencies between modules. An arc connecting two nodes indicates that the two modules corresponding to the nodes are either explicitly or implicitly dependent on each other. As mentioned with reference to the implicit dependency index  () discussed with reference to example 15, implicit dependencies come into play when a function in one module calls a function in another module. Implicit dependencies appear through shared global variables, such as when a function in one module writes into a file that is read by another module.","An SCC in the graph MDG is a maximal set of vertices (i.e., modules) in which there exists a path from all or substantially all vertices (in the SCC set) to all or substantially all other vertices in the same set. With this definition, the SCC has the property of being able to capture multiple cycles. Thus an SCC of 1 indicates the maximum number of cycles, in that nodes (modules) are connected. As the number of cyclic dependencies decrease, the SCC increases, with the maximum value being the number of modules being measured. This is because an SCC has the property that if the module dependency graph (MDG) contains no cycles, then the number of strongly connected components (SCC) is exactly equal to the number of nodes (modules) in the graph. In such a case, for every SCC, |SCC|=1.","A cyclic dependency metric can now be formed by comparing the sum of the cardinalities of SCC's with cardinality of the module dependency graph itself, as shown below:",{"@attributes":{"id":"p-0188","num":"0197"},"maths":{"@attributes":{"id":"MATH-US-00014","num":"00014"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"Cyclic","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mrow":{"mo":["(",")"],"mi":"\u2133"}},"mo":"=","mfrac":{"mrow":[{"mi":["number","of","SCC","in","\u2133"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},{"mo":["\uf603","\uf604"],"mi":"\u2133"}]}}}}},"This metric is aligned with the principle \u201cminimization of cyclic dependencies among modules.\u201d The value of Cyclic (M) equals 1 for a system having no cycles, with the value of a system where every module is connected to every other module being 1 divided by the number of modules.","The Layer Organization Index","The layer organization index  (abbreviated LOI) measures how well the layers only call modules from layers at the same level or below them. A layer can be thought of as a horizontal partitioning of a system. There are, generally, two types of layering. The first type of layering is \u201cclosed.\u201d Here, a function in layer Lcan only make calls to the functions in the immediately lower layer L. The second type of layering is \u201copen.\u201d With it, a function in layer Lcan make calls to functions in any lower layer.","Calculating the layer organization index  can be performed as follows. Suppose that L denotes an assignment of a set of modules M to a set of layers {L. . . L}, where Lis the first layer, Lthe second, etc., in which modules have been organized. Thus, (m) is the layer where m resides. The notation  indicates that calls from possible layers are considered except for the layer L.",{"@attributes":{"id":"p-0192","num":"0201"},"maths":{"@attributes":{"id":"MATH-US-00015","num":"00015"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msubsup":{"mi":["K","ext"],"mover":{"msub":{"mi":["L","i"]},"mi":"_"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}}},"br":{},"sub":["i","i","ext","i","i\u22121"],"sup":["L",{"sub2":"i\u22121"}]},"The Layer Organization Index (LOI)  for the layer Lis defined as the number of calls to modules in the layer Lfrom the immediate upper layer divided by total number of calls to the modules in the layer, excluding inter-layer calls. This can be written as:",{"@attributes":{"id":"p-0194","num":"0203"},"maths":{"@attributes":{"id":"MATH-US-00016","num":"00016"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"LOI","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["L","i"]}}},"mo":"=","mfrac":{"mrow":[{"munder":{"mo":"\u2211","mrow":{"mo":"\u2200","mrow":{"mi":"m","mo":"\u2208","msub":{"mi":["L","i"]}}}},"mo":"\u2062","mrow":{"msubsup":{"mi":["K","est"],"msub":{"mi":"L","mrow":{"mi":"i","mo":"-","mn":"1"}}},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}},{"munder":{"mo":"\u2211","mrow":{"mo":"\u2200","mrow":{"mi":"m","mo":"\u2208","msub":{"mi":["L","i"]}}}},"mo":"\u2062","mrow":{"msubsup":{"mi":["K","est"],"mover":{"msub":{"mi":["L","i"]},"mi":"_"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}}]}}}},"br":{},"sub":"1"},"The above metric will now be extended to the entire system. When measuring the system level metric, the cycles that exist among the modules and the cycles that exist across layers are explicitly addressed. Often, peer modules collaborate heavily among themselves to perform a complex business workflow. Such collaboration can result in cycles. Such cycles among peer modules are generally acceptable when, and only when, all such modules are in the same layer. It is not acceptable, but rather, is highly undesirable for such modules to engage in cyclic dependencies across a layer, violating the layering principle.","The LOI metric presented next is forgiving of cyclic dependencies within a given layer, but penalizes any cyclic dependencies across layers. Let us assume that the system consists of q number of strongly connected components (SCCs) where number of modules in an SCC is \u22671, i.e., |SCC|\u22671, which indicates that cyclic dependencies exist between modules in different layers. When the module graph is acyclic, q=|M|; that is, every module has its own independent SCC. Conversely, when the module graph is completely cyclic, q=1, as only a single SCC is needed, as it contains every module.","Next, let L(SCC) be the set of layers which have dependencies in SCC. That is, a module in a Layer L is a node in SCC. This can be written L(SCC)={L(m)|m\u03b5SCC}. As discussed earlier, cyclic dependencies can exist within modules of the same layer, that is, |L(SCC)|=1; but the opposite case, where cycles are formed by modules in multiple layers, i.e., |L(SCC)|>1, is heavily discouraged. The following index calculation, the Desirability Property Formula, returns an index which measures the amount of cycles formed by modules in multiple layers, where p is the number of layers in the system, and where M>1 is the total number of modules in the system organized in p layers.",{"@attributes":{"id":"p-0198","num":"0207"},"maths":{"@attributes":{"id":"MATH-US-00017","num":"00017"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mn":"1","mo":"-","mfrac":{"mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"q"},"mo":"\u2062","msup":{"mrow":[{"mo":["(",")"],"mrow":{"mrow":{"mo":["\uf603","\uf604"],"msub":{"mi":["SCC","i"]}},"mo":"-","mn":"1"}},{"mo":["\uf603","\uf604"],"mrow":{"mi":"\u2112","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["SCC","i"]}}}}]}},"msup":{"mrow":{"mo":["(",")"],"mrow":{"mi":"M","mo":"-","mn":"1"}},"mi":"p"}}}}}},"This formula has the following characteristics:\n\n","With these observations the system level LOI  can be defined as follows:",{"@attributes":{"id":"p-0201","num":"0213"},"maths":{"@attributes":{"id":"MATH-US-00018","num":"00018"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"LOI","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"S"}},{"mrow":[{"mo":["(",")"],"mrow":{"mfrac":{"mn":"1","mrow":{"mi":"p","mo":"-","mn":"1"}},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"2"},"mi":"p"},"mo":"\u2062","mrow":{"mi":"LOI","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["L","i"]}}}}}},{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","mfrac":{"mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"q"},"mo":"\u2062","msup":{"mrow":[{"mo":["(",")"],"mrow":{"mo":["\uf603","\uf604"],"mrow":{"msub":{"mi":["SCC","i"]},"mo":"-","mn":"1"}}},{"mo":["\uf603","\uf604"],"mrow":{"mi":"L","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["SCC","i"]}}}}]}},"msup":{"mrow":{"mo":["(",")"],"mrow":{"mi":"M","mo":"-","mn":"1"}},"mi":"p"}}}}],"mo":"*"}],"mo":"="}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mrow":{"mn":"0","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["if","p"]},"mo":"<=","mn":"2"}}}}]}}}},"Observe that the system level LOI  is impacted both by inter-layer calls, and by the number of layers within each SCC, that is, how many layers participate in each cycle.","As an alternative formulation, the Desirability Property Formula can be calculated as follows:",{"@attributes":{"id":"p-0204","num":"0216"},"maths":{"@attributes":{"id":"MATH-US-00019","num":"00019"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mn":"1","mo":"-","mfrac":{"mrow":[{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"q"},"mo":"\u2062","mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mrow":{"mo":["\uf603","\uf604"],"msub":{"mi":["SCC","i"]}},"mo":"-","mn":"1"}},{"mo":["\uf603","\uf604"],"mrow":{"mi":"\u2112","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["SCC","i"]}}}}],"mo":"\u00d7"}},{"mrow":{"mo":["(",")"],"mrow":{"mi":"M","mo":"-","mn":"1"}},"mo":"\u00d7","mi":"p"}]}}}}},"Also, as another alternate formulation, the system level LOI  can be weighted, such that wand ware any two user-defined numbers whose values add up to 1. This gives the following formula:",{"@attributes":{"id":"p-0206","num":"0218"},"maths":{"@attributes":{"id":"MATH-US-00020","num":"00020"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"LOI","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"S"}},{"mrow":[{"msub":{"mi":"w","mn":"1"},"mo":"*","mrow":{"mo":["(",")"],"mrow":{"mfrac":{"mn":"1","mrow":{"mi":"p","mo":"-","mn":"1"}},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"2"},"mi":"p"},"mo":"\u2062","mrow":{"mi":"LOI","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["L","i"]}}}}}}},{"msub":{"mi":"w","mn":"2"},"mo":"*"}],"mo":"+"}],"mo":"="}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mrow":{"mn":"0","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["if","p"]},"mo":"\u2264","mn":"2."}}}}]},"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","mfrac":{"mrow":[{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"q"},"mo":"\u2062","msup":{"mrow":[{"mo":["(",")"],"mrow":{"mo":["\uf603","\uf604"],"mrow":{"msub":{"mi":["SCC","i"]},"mo":"-","mn":"1"}}},{"mo":["\uf603","\uf604"],"mrow":{"mi":"L","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["SCC","i"]}}}}]}},{"mrow":{"mo":["(",")"],"mrow":{"mi":"M","mo":"-","mn":"1"}},"mo":"\u00d7","mi":"p"}]}}}}}}},"This metric models, and attempts to maximize, the unidirectionality of control flow in layered architectures and also strongly penalizes cycles across multiple layers. Therefore the metric LOI  conforms to the acyclic dependency principle.","Module Interaction Stability Index","The module interaction stability index  (abbreviated MISI) is designed to measure the degree to which modules in lower layers are more stable than modules in upper layers.","Software of any serious complexity is often ordered, at a minimum, into layers. In such architectures, the modules in the lower layers should be more stable than the modules in the upper layers, such that the most changes made to the overall software should be, ideally, in the upper layers, with the fewest changes in the lowest layers. This means, among other things, that changes to the upper layers should not impact the lower layers.","However, measuring such characteristics is challenging, as it is difficult to anticipate when and to what degree a given module will be changed, as such changes often depend on unpredictable external situations such as market pressure and customer requests. Therefore, the module interaction stability index  measures, not the degree to which modules change, but rather, the degree to which a change in a given module will affect the surrounding modules.","Following the notation already developed within this example, let L:M\u2192{L1 . . . Lp} be the assignment of the modules to different layers and (m) be the layer where module m resides. In the stack of layers, let Land Lbe the uppermost and lowermost layers, respectively. The layers are now rank-ordered, with the \u2266operator defined as:\n\nand iff 1\u2266& \n","For a given module m, let fanin(m) be the set of modules that depend on m, and let fanout(m) be the set of modules that m depends on. This notion of dependencies is discussed with relation to the implicit dependency index  () mentioned with reference to example 15. The instability I(m) of a module m is defined as:",{"@attributes":{"id":"p-0213","num":"0225"},"maths":{"@attributes":{"id":"MATH-US-00021","num":"00021"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"I","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}},"mo":"=","mfrac":{"mrow":[{"mo":["\uf603","\uf604"],"mrow":{"mi":"fanout","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}},{"mrow":[{"mo":["\uf603","\uf604"],"mrow":{"mi":"fanin","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}},{"mo":["\uf603","\uf604"],"mrow":{"mi":"fanout","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}}],"mo":"+"}]}}}}},"A stable module, defined as SD(m), is defined as a module that m depends on, that has a lower instability I than m, and that resides in either the same layer or a lower layer than m. This can be expressed as follows:","Let SD(m)fanout(m) be the set of stable modules with respect to m, defined as\n\n()={\u03b5fanout(m)|()>()&()\u2266()}\n\nfor a module m can now be defined as the stability of m, SD(m), divided by the fanout of m. This is expressed:\n",{"@attributes":{"id":"p-0216","num":"0228"},"maths":{"@attributes":{"id":"MATH-US-00022","num":"00022"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":"MISI","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}},"mo":"=","mfrac":{"mrow":[{"mrow":{"mo":"\u2758","mrow":{"mi":"SD","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}},"mo":"\uf604"},{"mo":["\uf603","\uf604"],"mrow":{"mi":"fanout","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}}]}}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"when","mrow":{"mi":"fanout","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}}}}},{"mtd":{"mrow":{"mo":"=","mi":"\u2205"}}}]}}}},"The system MISI  is the average of the MISI for modules within the system, as follows:",{"@attributes":{"id":"p-0218","num":"0230"},"maths":{"@attributes":{"id":"MATH-US-00023","num":"00023"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"MISI","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"S"}},{"mfrac":{"mn":"1","mi":"M"},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"M"},"mo":"\u2062","mrow":{"mi":"MISI","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["m","i"]}}}}}],"mo":"="}}}},"For a well-modularized system, modules should depend on modules that are more stable and that reside in lower layers. Hence, |SD(m)|\u2248|fanout(m)| and MISI(m)\u21921. If a system has a high MISI index  then any changes or extensions made to the system will affect only a small number of modules in the upper layers of the system.","In the definition if MISI, above, the formula for stability is based on the fan-in and fan-out dependencies of modules. Alternatively, instability of a module can be based on the probability the module will be changed in the next release (or revision, etc.) of the software. This probability can be calculated based on the past module history. In such a case, the following equations can be used to determine the instability I(m) of a module m as shown.","Let Rev be the set of revisions {r, . . . , r} of the given software, and let Chg: M\u2192Rev be the assignment of modules to the set of revisions in which the modules were changed. The instability I(m) of m can now be defined as:",{"@attributes":{"id":"p-0222","num":"0234"},"maths":{"@attributes":{"id":"MATH-US-00024","num":"00024"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"I","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}},"mo":"=","mfrac":{"mrow":[{"mo":["\uf603","\uf604"],"mrow":{"mi":"Chg","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}},{"mo":["\uf603","\uf604"],"mi":"Rev"}]}}}}},"With this definition of I(m), SD(m), and MISI(m) are defined as above. Furthermore, the system level MISI can be generalized like the previously-defined metrics.","As another alternative, MISI(S) can be calculated as a simple average (as shown above), a weighted average, a median value, etc.","This metric caters to the principle of module extendibility.","Testability Index","The testability index  (also called the normalized testability-dependency metric, NTDM) determines the testability dependence of modules, that is, the degree to which modules rely on the input or output of other modules. A module that has few dependencies on other modules is easier to test. A testability dependence is created if the assessment of the correctness of the input-output relationships during the testing of a module depends on the correctness of the input-output relationships of another module. That is, if the testing of module mrequires another module mto produce intermediate results that are then used in m, then there is a testability dependence between the two modules. The extent of such testability dependencies are measured with the normalized testability-dependency metric, as explained below.","Let dep(m) be the number of modules on which a given module mhas a testability dependence. The testability-dependence count (TDC) is defined as the sum of the testability dependencies dep(m) for substantially all modules in the system, written as:",{"@attributes":{"id":"p-0229","num":"0241"},"maths":{"@attributes":{"id":"MATH-US-00025","num":"00025"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"TDC","mo":"=","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"M"},"mo":"\u2062","mrow":{"mi":"dep","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["m","i"]}}}}}}},"br":{}},"The NTDM metric index  is the normalized ratio of TDC (the sum of the testability dependencies for all (or substantially all) modules) to the total number of modules, to wit:",{"@attributes":{"id":"p-0231","num":"0243"},"maths":{"@attributes":{"id":"MATH-US-00026","num":"00026"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"NTDM","mo":"=","mrow":{"mn":"1","mo":"-","mfrac":{"mi":"TDC","mrow":{"mi":"M","mo":"\u00d7","mrow":{"mo":["(",")"],"mrow":{"mi":"M","mo":"-","mn":"1"}}}}}}}}},"Note that TDC varies from 0 to M*(M\u22121) depending on the testability dependencies between the modules. The upper limit is reached when a module has a testable dependency on every other module, (i.e., M\u22121), while the lower limit is reached when a module has no testable dependencies on other modules. The value of NTDM  will be 1 when the modules are independently testable (i.e. when dep(m)=0), and 0 when every module is testably dependent on every other module.","The NTDM formulation shown above is based on the count of testability dependent modules. As an alterative formulation, the strength of the testability dependence can also be measured.","As above, let MDG be the module dependency graph where the nodes of the graph represent modules in the system and of the graph represent the pairwise dependence between the modules. Let path (m, m) no be the length of the shortest path from mto m. As before, let dep(m) be the set of modules that a given module mis testably-dependent upon. An alternate definition of the Testability Dependency can be defined as:",{"@attributes":{"id":"p-0235","num":"0247"},"maths":{"@attributes":{"id":"MATH-US-00027","num":"00027"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"TDC","mo":"=","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"M"},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":[{"mi":"j","mo":"=","mn":"1"},{"mo":["\uf603","\uf604"],"mrow":{"mi":"dep","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["m","i"]}}}}]},"mo":"\u2062","mrow":{"mi":"path","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["m","i"]},{"mi":["m","j"]}],"mo":","}}}}}}}}},"where M is the total number of modules in the system. The NTDM metric is defined as above.","This metric characterizes software according to the principle of maximization of the stand-alone testability of modules.",{"@attributes":{"id":"p-0238","num":"0250"},"figref":["FIG. 14","FIG. 13","FIG. 13"],"b":["1400","1344","1452","1454","1456","1458","1456","1452","1454","1458","1353","1355","1357","1359"]},"At , a layer organization of given source code, such as the source code  (), can be calculated. This can produce an index, such as the layer organization index  of .","At , cyclic dependency of given source code, such as the source code  (), can be calculated. This can produce an index, such as the cyclic dependency index  of .","At , model interaction stability of given source code, such as the source code  (), can be calculated. This can produce an index, such as the model interaction stability index  of .","At , testability of given source code, such as the source code  (), can be calculated. This can produce an index, such as the testability index  of .","At , after one or more architectural modularity evaluations have been calculated, results can be generated from the one or more calculated indices.",{"@attributes":{"id":"p-0244","num":"0256"},"figref":["FIG. 15","FIG. 7"],"b":["1500","1502","1544","758","1553","1555","1570"]},"Module Size Uniformity Index","The module size uniformity index  (abbreviated MSUI) measures how similar in size each module is within a specified portion of source code. Within reason, modules generally should be roughly equal in size. A strong deviation from this uniform size constraint generally is indicative of poor modularization. The indices calculated using size perspective possess a bias towards making the modules as equal in size as possible, subject to other modularization constraints. The size constraint can be expressed in terms of the average size \u03bc of the modules and the standard deviation a from the average associated with the module sizes. The module size uniformity index can be defined as the ratio of the absolute values of average size minus the standard deviation divided by the average size plus the standard deviation. This can be expressed as:",{"@attributes":{"id":"p-0246","num":"0258"},"maths":{"@attributes":{"id":"MATH-US-00028","num":"00028"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"MSUI","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"S"}},"mo":"=","mfrac":{"mrow":[{"mo":["\uf603","\uf604"],"mrow":{"mi":["\u03bc","\u03c3"],"mo":"-"}},{"mi":["\u03bc","\u03c3"],"mo":"+"}]}}}}},"The closer this index is to 1, the greater uniformity of module sizes. As an aside, this formula assumes that the standard deviation and the average size value are not equal, which will lead to an incorrect 0 value of the metric, as the numerator of the ratio will equal zero. Calculation of this metric should take measures to check for this disallowed value.","As an alternate formulation, MSUI(S) can be calculated as:",{"@attributes":{"id":"p-0249","num":"0261"},"maths":{"@attributes":{"id":"MATH-US-00029","num":"00029"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"MSUI","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"S"}},"mo":"=","mfrac":{"mrow":[{"msub":{"mi":"w","mn":"1"},"mo":"*","mi":"\u03bc"},{"mrow":[{"msub":{"mi":"w","mn":"1"},"mo":"*","mi":"\u03bc"},{"msub":{"mi":"w","mn":"2"},"mo":"*","mi":"\u03c3"}],"mo":"+"}]}}}},"br":{},"sub":["1 ","2 "]},"It is evident that MSUI  increases as the standard deviation of the average module size decreases. This adheres to the module size principle, and aims to measure the maximum of module size uniformity, as discussed in example 3.","Module Size Boundedness Index","The module size boundedness index  attempts to determine a correct size for a module. Even if modules are all approximately the same size, the size could, itself, either too small or too large. It is often recommended that, ideally, no module should significantly exceed some recommended particular size, generally expressed in terms of the number of lines of code. Assuming that this \u201cmagic number\u201d is \u0393, the average deviation in module length from this magic number is first calculated by \u03b4=|Sz\u2212\u0393|, where Szis the number of lines of module m. Further, let \u03b4=max{\u03b4} Ideally, \u2200,\u03b4=0, and a histogram of \u03b4values will have a single bar of height M (the number of modules) at \u03b4=0. However, in practice, a histogram of \u03b4's could be spread over the range [0, \u03b4] of values.","The module size boundedness index is a measure as to what extent the deviations depart from the ideal.","A rationale based on the Lullback-Leiber (KL) divergence for measuring the \u201cdistance\u201d between two probability distributions is used. If it could be assumed that every measured size deviation between 0 and max has a non-zero probability of occurrence, then it can be shown that the KL \u201cdistance\u201d between the ideal and the actual distributions for the deviations would be \u2212log(prob{\u03b4=0}) where prob{\u03b4=0} is proportional to the actual number of modules whose size deviations from the magic size are zero. This measure can be weighted, in some embodiments, by \u03b4\/\u0393 because as \u03b4becomes a negligible fraction of \u0393, it is unimportant how the deviations are distributed in the range [0, \u03b4] as they are too small to care about. Therefore, the following formula can be used to measure the extent to which the distribution of the actual size deviations differs from the ideal distribution:",{"@attributes":{"id":"p-0254","num":"0266"},"maths":{"@attributes":{"id":"MATH-US-00030","num":"00030"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":"d","mo":"=","mrow":{"mrow":[{"mo":"-","mfrac":{"msub":{"mi":["\u03b4","max"]},"mi":"\u0393"}},{"mi":"log","mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mrow":{"mo":["\uf603","\uf604"],"mrow":{"mo":["{","}"],"mrow":{"msub":{"mi":["\u03b4","i"]},"mo":";","mrow":{"msub":{"mi":["\u03b4","i"]},"mo":"<","mi":"\u03c4"}}}},"mi":"M"}}}],"mo":"\u00d7"}},"mo":"\u2062","mstyle":{"mspace":{"@attributes":{"width":"1.1em","height":"1.1ex"}}}}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mn":"0","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"when","msub":{"mi":["\u03b4","max"]}}}}},{"mtd":{"mrow":{"mo":"=","mn":"0"}}}]}}},"br":{},"sub":["i","i","i","max"]},"In some embodiments, d is converted into a properly normalized metric using the following equation:\n\n()=\n","It is evident from the module size uniformity index  equation that module size uniformity increases as the standard deviation of the module sizes from the average module size decreases. This addresses the principle related to module size. Similarly, the MSBI equation, above measures the extent to which the module size bound as specified by \u0393 is honored by the individual modules. This metric also addresses the principle \u201cObservance of Module Size Bounds.\u201d","As an alternate module size boundedness index, the following formula can be used. Recall that a \u201cmagic number\u201d can be defined at the ideal size of a module for a system, expressed in lines of code. Assuming that this \u201cmagic number\u201d is \u0393, the average deviation in module length from this magic number can first be calculated, as shown below:",{"@attributes":{"id":"p-0258","num":"0270"},"maths":{"@attributes":{"id":"MATH-US-00031","num":"00031"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["\u03b4","av"]},"mo":"=","mrow":{"mfrac":{"mn":"1","mi":"M"},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"M"},"mo":"\u2062","mrow":{"mo":["\uf603","\uf604"],"mrow":{"msub":{"mi":["L","i"]},"mo":"-","mi":"\u0393"}}}}}}},"br":{},"sub":"i "},"As a fraction of the largest of either the magic length, \u0393, or of any of the module lengths, this deviation can be re-expressed as:",{"@attributes":{"id":"p-0260","num":"0272"},"maths":{"@attributes":{"id":"MATH-US-00032","num":"00032"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["\u03b4","fav"]},"mo":"=","mrow":{"mfrac":{"msub":{"mi":["\u03b4","av"]},"mrow":{"mi":"max","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["L","i"]},"mo":",","mi":"\u0393"}}}},"mo":"."}}}},"br":[{},{}],"in-line-formulae":[{},{}],"i":["MSBI","S"],"sub":"\u0192av "},"This alternate MSBI  measures the extent to which the module size bound specified by \u0393 has been honored during the design of individual modules. It also adheres to the module size principle, specifically, to the observance of the module size bounds, as discussed in example 3.","As another alternative MSBI , a variation of the original formula can be used to calculate d. For example,",{"@attributes":{"id":"p-0263","num":"0275"},"maths":{"@attributes":{"id":"MATH-US-00033","num":"00033"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"d","mo":"=","mrow":{"mrow":[{"mo":"-","mfrac":{"msub":{"mi":["\u03b4","max"]},"mi":"X"}},{"mi":"log","mo":["(",")"],"mfrac":{"mrow":{"mo":["\uf603","\uf604"],"mrow":{"mo":["{","}"],"mrow":{"mrow":{"msub":[{"mi":["\u03b4","i"]},{"mi":["\u03b4","i"]}],"mo":"\u00b7"},"mo":"<","mi":"\u03c4"}}},"mi":"M"}}],"mo":"\u00d7"}}}},"br":{},"sup":"\u00b7d "},{"@attributes":{"id":"p-0264","num":"0276"},"figref":["FIG. 16","FIG. 15","FIG. 15"],"b":["1600","1542","1652","1654","1654","1652","1553","1355"]},"At , module size uniformity of given source code, such as the source code  (), can be calculated. This can produce an index, such as the module size uniformity index  of .","At , module size boundedness can be calculated. This can produce an index, such as the module size uniformity index  of .","At , after one or more size performance module evaluations have been calculated, results can be generated from the one or more calculated indices.",{"@attributes":{"id":"p-0268","num":"0280"},"figref":["FIG. 17","FIG. 7"],"b":["1700","1702","1744","756","1753","1755"]},"The English language constructs used to build a program, such as words used in comments, variable names, function names, and so on, can be used to give clues to the purposes of functions, modules, layers, and other software groupings. These clues can be referred to as concepts. The metrics in this example exploit these concepts to determine if the software groupings (functions, modules, etc.) have a similar purpose.","To determine any of the metrics in this example, a concept set, that is, a set of words that may appear as keywords, and\/or synonyms, and\/or abbreviations of those words, can be made accessible. This concept set may be assembled by hand by a person familiar with the source code , may be partially assembled by hand and partially automated, or may be assembled in another way.","Definitions that will be used for the indices described in this example are now described. Let C={c, . . . , c} denote a set of N concepts for a given system S. Also let F={\u0192, . . . , \u0192} indicate the set of functions distributed over M modules {m, . . . , m} The word \u201cfunction\u201d here indicates any software grouping with input-output functions, such that procedures, subprograms, etc., are included, as previously mentioned. For this example, the symbol mindicates the set of functions that are in m. For functions, the number of occurrences of concepts, (which may include its synonyms, abbreviations, etc., and which may be found in the concept set) are searched in the function signature and the function body. The concept frequency H(c) is denoted as the frequency of occurrences of the concept c\u03b5C for a given function \u0192\u03b5F.","As an illustration of the concept content of a body of software, the Apache httpd 2.0.53 is analyzed for the concept set {authentication, caching protocol, logging}. Table 1, below, shows the frequencies of these concepts and their synonyms in the software. In this example, H(authentication)=3.",{"@attributes":{"id":"p-0273","num":"0285"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":{"entry":"TABLE I"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CONCEPT FREQUENCY TABLE"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Function","authentication","platform","caching","protocol","logging"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["allow_cmd","3","0","0","0","0"]},{"entry":["check_dir_access","4","0","0","5","3"]},{"entry":["create_access_dir_config","3","0","0","0","0"]},{"entry":["authenticatebasicuser","21","0","0","3","6"]},{"entry":["checkuseraccess","29","0","0","5","6"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}}},"The frequency distribution of these concepts, in an exemplary embodiment, is then normalized. A particular concept may occur more frequently than other concepts, across all (or substantially all) functions, typically a concept associated with the overall purpose of the software code . To avoid such a concept skewing the overall distribution, substantially each concept frequency, in an exemplary embodiment, is normalized by its global maximum. As an example, let H(c)=max{H(c),\u2200\u0192\u03b5F}. Frequencies can be normalized as follows:",{"@attributes":{"id":"p-0275","num":"0287"},"maths":{"@attributes":{"id":"MATH-US-00034","num":"00034"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mover":{"mi":"\u210b","mo":"^"},"mi":"f"},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"c"}},{"mfrac":{"mrow":[{"msub":{"mi":["\u210b","f"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"c"}},{"msup":{"mi":["\u210b","max"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"c"}}]},"mo":"."}],"mo":"="}}}},"The concept domination metric , and\/or the coherency metric , after calculation, can then be used as modularization quality evaluation results .","The Concept Domination Metric","The concept domination metric  (abbreviated CDM) determines if the concepts in the module have a non-uniform probability distribution. If a module is highly purpose-focused, a probability distribution of the concepts in the module will be highly peaked at the concept corresponding to the purpose of the module. Therefore, the more non-uniform the probability distribution of the concepts in a module, the more likely that the module conforms to singularity of purpose. The CDM  can give a measure of the non-uniformity of the probability distribution of the concepts. In the worst case, all concepts will be evenly distributed, which gives a CDM  of zero, in an exemplary embodiment. Other CDMs  produce a worst case with a different value. As an example, in an exemplary CDM, concepts (which may be words selected beforehand, abbreviations, portions of words, and so forth) are determined. This determination may comprise counting the occurrences of the concepts, estimating the occurrences, or may be done some other way. The number of (or a portion of) the concepts that occur in each (or some) of the modules is then determined.","As another example, to create an exemplary CDM, a normalized concept frequency is created. This can be created as follows: for a given module m, the frequency of occurrences of a concept ccan be obtained from the normalized concept frequency of functions that constitute a module. This can be expressed as:",{"@attributes":{"id":"p-0280","num":"0292"},"maths":{"@attributes":{"id":"MATH-US-00035","num":"00035"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mover":{"mi":"\u210b","mo":"^"},"mi":"m"},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["c","i"]}}},{"munder":{"mo":"\u2211","mrow":{"mo":"\u2200","mrow":{"mi":["f","m"],"mo":"\u2208"}}},"mo":"\u2062","mrow":{"msub":{"mover":{"mi":"\u210b","mo":"^"},"mi":"f"},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["c","i"]}}}}],"mo":"="}}}},"The concept Cis then found that maximizes\n\n()\n\nfor each module m, i.e.,\n\n()=max()\n\nNext, the normalized frequency is converted into a discrete probability measure:\n",{"@attributes":{"id":"p-0282","num":"0294"},"maths":{"@attributes":{"id":"MATH-US-00036","num":"00036"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"msub":{"mi":["g","m"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["c","i"]}}},"mo":"=","mfrac":{"mrow":[{"msub":{"mover":{"mi":"\u210b","mo":"^"},"mi":"m"},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["c","i"]}}},{"munderover":{"mo":"\u2211","mrow":{"mi":"j","mo":"=","mn":"1"},"mi":"N"},"mo":"\u2062","mrow":{"msub":{"mover":{"mi":"\u210b","mo":"^"},"mi":"m"},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["c","j"]}}}}]}}}},"br":{}},"The Kullback-Leibler divergence of a uniform probability distribution, is then measured from the probability distribution g, in an equation known as the divergence equation:",{"@attributes":{"id":"p-0284","num":"0296"},"maths":{"@attributes":{"id":"MATH-US-00037","num":"00037"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"KL","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["g","m"]}}},{"mrow":[{"mi":["log","N"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"N"},"mo":"\u2062","mrow":{"mrow":[{"msub":{"mi":["g","m"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["c","i"]}}},{"mi":"log","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["g","m"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["c","i"]}}}}}],"mo":"\u00d7"}}],"mo":"+"}],"mo":"="}}},"br":{},"b":"2"},"The dispersion of the concepts in any given module m is defined relative to concepts whose normalized frequencies of occurrence are within a predefined threshold: \u03b8 of g(c). This permits the purpose of a module to be stated in terms of not just one dominating concept, but by a set of concepts that are more or less equally important. The following rule partitions the set X of concepts for a specific module m into two subsets, Cand C.",{"@attributes":{"id":"p-0286","num":"0298"},"maths":{"@attributes":{"id":"MATH-US-00038","num":"00038"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msubsup":{"mi":["c","m"],"mn":"1"},"mo":"=","mrow":{"mo":"{","mrow":{"mrow":[{"mtable":{"mtr":[{"mtd":[{"mrow":{"mrow":{"mo":["{","}"],"mrow":{"msub":{"mi":["c","i"]},"mo":"\u2758","mrow":{"mrow":[{"msub":{"mi":["g","m"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["c","i"]}}},{"mi":"\u03b8","mo":"\u00b7","mrow":{"msub":{"mi":["g","m"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msubsup":{"mi":["c","max","m"]}}}}],"mo":">"}}},"mo":","}},{"mrow":{"mrow":{"mi":"KL","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["g","m"]}}},"mo":">","mi":"\u03a8"}}]},{"mtd":[{"mrow":{"mi":"\u2205","mo":","}},{"mi":"otherwise"}]}]},"mo":["\u2062","\u2062"],"mstyle":{"mtext":{}},"msubsup":{"mi":["c","m"],"mn":"2"}},{"mi":"c","mo":"-","msubsup":{"mi":["c","m"],"mn":"1"}}],"mo":"="}}}}}},"Note that the existence of Cis predicated on divergence, which may be KL-divergence, exceeding a certain threshold. If the KL-divergence does not exceed the threshold, the concept distribution is too uniform to allow for the partitioning of C into a subset Cof dominating concepts.","The following lemma establishes at least some desirable properties for the divergence and the concept subsets Cand C.","Lemma: When the total number of concepts satisfies N=2, the KL(g) divergence of the divergence equation, above, is bounded by [0, k]. When a module contains only one concept, the KL(g) distance becomes maximum, i.e., equal to k. Proof: Being non-negative, the divergence KL(g) is bounded on the low side by 0. KL(g) becomes zero when the discrete probability distribution gis uniform. At the other extreme, when a module m contains only one concept c\u03b5C, g(c)=1 and for all (or substantially all) other c\u2032\u03b5C, g(c\u2032)=0. In which case, KL(g)=log N+log1; which is equal to k.","The dispersion Dfor a module m, with respect to the concept cand other almost equally frequently occurring concepts in Cis defined by:",{"@attributes":{"id":"p-0291","num":"0303"},"maths":{"@attributes":{"id":"MATH-US-00039","num":"00039"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["D","m"]},"mo":"=","mfrac":{"mrow":[{"munder":{"mo":"\u2211","mrow":{"msub":{"mi":["c","i"]},"mo":"\u2208","msubsup":{"mi":["C","m"],"mn":"1"}}},"mo":"\u2062","mrow":{"msub":{"mi":["g","m"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["c","i"]}}}},{"mrow":[{"munder":{"mo":"\u2211","mrow":{"msub":{"mi":["c","i"]},"mo":"\u2208","msubsup":{"mi":["C","m"],"mn":"1"}}},"mo":"\u2062","mrow":{"msub":{"mi":["g","m"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["c","i"]}}}},{"munder":{"mo":"\u2211","mrow":{"msub":{"mi":["c","i"]},"mo":"\u2208","msubsup":{"mi":["C","m"],"mn":"2"}}},"mo":"\u2062","mrow":{"msub":{"mi":["g","m"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["c","i"]}}}}],"mo":"+"}]}}}}},"The value of Dwill always be close to 1 when Cis of low cardinality and has the maximum concept frequency. Note that when Cis not zero, its cardinality is always low. Furthermore, then Chas maximum concept frequencies, the following equation holds:",{"@attributes":{"id":"p-0293","num":"0305"},"maths":{"@attributes":{"id":"MATH-US-00040","num":"00040"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"munder":{"mo":"\u2211","mrow":{"msub":{"mi":["c","i"]},"mo":"\u2208","msubsup":{"mi":["C","m"],"mn":"1"}}},"mo":"\u2062","mrow":{"msub":{"mi":["g","m"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["c","i"]}}}},{"munder":{"mo":"\u2211","mrow":{"msub":{"mi":["c","i"]},"mo":"\u2208","msubsup":{"mi":["C","m"],"mn":"2"}}},"mo":"\u2062","mrow":{"msub":{"mi":["g","m"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["c","i"]}}}}],"mo":"\u2aa2"}}}},"This, in turn, results in Dapproaching 1.","The concept domination metric (CDM)  for a system can now be defined:",{"@attributes":{"id":"p-0296","num":"0308"},"maths":{"@attributes":{"id":"MATH-US-00041","num":"00041"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"\ud835\udc9f","mo":"=","mrow":{"mfrac":{"mn":"1","mi":"M"},"mo":"\u2062","mrow":{"munder":{"mo":"\u2211","mrow":{"mi":["m","\u2133"],"mo":"\u2208"}},"mo":"\u2062","msub":{"mi":["\ud835\udc9f","m"]}}}}}},"br":{}},"As an alternate formulation of the CDM metric , the dispersion \u0394m can be calculated using weights, where wand ware two numbers between 0 and 1 which sum to 1, using the formula shown below:",{"@attributes":{"id":"p-0298","num":"0310"},"maths":{"@attributes":{"id":"MATH-US-00042","num":"00042"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["D","m"]},"mo":"=","mfrac":{"mrow":[{"msub":{"mi":"w","mn":"1"},"mo":"*","mrow":{"munder":{"mo":"\u2211","mrow":{"msub":{"mi":["c","i"]},"mo":"\u2208","msubsup":{"mi":["C","m"],"mn":"1"}}},"mo":"\u2062","mrow":{"msub":{"mi":["g","m"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["c","i"]}}}}},{"mrow":[{"msub":{"mi":"w","mn":"1"},"mo":"*","mrow":{"munder":{"mo":"\u2211","mrow":{"msub":{"mi":["c","i"]},"mo":"\u2208","msubsup":{"mi":["C","m"],"mn":"1"}}},"mo":"\u2062","mrow":{"msub":{"mi":["g","m"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["c","i"]}}}}},{"msub":{"mi":"w","mn":"2"},"mo":"*","mrow":{"munder":{"mo":"\u2211","mrow":{"msub":{"mi":["c","i"]},"mo":"\u2208","msubsup":{"mi":["C","m"],"mn":"2"}}},"mo":"\u2062","mrow":{"msub":{"mi":["g","m"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["c","i"]}}}}}],"mo":"+"}]}}}}},"As another alternate formulation, D, the concept domination metric, can be calculated as either a weighted average or a median value, rather than the simple average shown above.","This CDM metric  measures the extent to which modules in a software system are cohesive with respect to concepts (words, etc.) that contain the largest number of clues within modules. This metric corresponds to the principle \u201cmaximization of module coherence on the basis of similarity and singularity of purpose.\u201d As the CDM metric  also measures the dispersion of concepts in that its value increases as the dispersion increases, the CDM metric  also corresponds to the principle \u201cminimization of purpose dispersion.\u201d","Concept Coherency Metric","The concept coherency metric  measures mutual information existing between a concept and a module. If a concept is central to the services offered by a module, then the mutual information between the module and the concept should be high. Such mutual information becomes high when each is able to predict the likelihood of the other with some probability. If a concept is orthogonal to the services offered by a module, neither concept nor module can tell much about the likelihood of the occurrence of the other\u2014the mutual information between the two will be close to zero.","To formulate the concept coherency metric , let C be a random variable whose value can be any element in the set C of defined concepts, as discussed earlier in this example. Similarly, let M be a random variable that can take on any value from the set M of modules. The mutual information between the concepts and the modules is then given by:\n\n()=()\u2212()\n\nwhere H(C) denotes the entropy associated with concepts in the system, and H(C|M) denotes the conditional entropy of the concepts in terms of the modules. The entropy H(C) can be expressed by:\n",{"@attributes":{"id":"p-0304","num":"0316"},"maths":{"@attributes":{"id":"MATH-US-00043","num":"00043"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"H","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"C"}},{"mo":"-","mrow":{"munder":{"mo":"\u2211","mrow":{"mi":["e","C"],"mo":"\u2208"}},"mo":"\u2062","mrow":{"mrow":[{"mi":"\u03c1","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"c"}},{"mi":"\u03c1","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"c"}}],"mo":["\u2062","\u2062","\u2062"],"mi":"log","mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}}],"mo":"="}}},"br":{}},{"@attributes":{"id":"p-0305","num":"0317"},"maths":{"@attributes":{"id":"MATH-US-00044","num":"00044"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"H","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["C","M"],"mo":["\u2062","\u2062"],"mstyle":{"mtext":"\u2758"}}}},{"mo":"-","mrow":{"munder":{"mo":"\u2211","mrow":{"mi":["m","\u2133"],"mo":"\u2208"}},"mo":"\u2062","mrow":{"mrow":[{"mi":"\u03c1","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}},{"munder":{"mo":"\u2211","mrow":{"mi":["c","C"],"mo":"\u2208"}},"mo":"\u2062","mrow":{"mrow":[{"msub":{"mi":["g","m"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"c"}},{"msub":{"mi":["g","m"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"c"}}],"mo":["\u2062","\u2062","\u2062"],"mi":"log","mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}}}],"mo":"\u2062"}}}],"mo":"="}}},"br":{}},{"@attributes":{"id":"p-0306","num":"0318"},"maths":{"@attributes":{"id":"MATH-US-00045","num":"00045"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"H","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["C","M"],"mo":["\u2062","\u2062"],"mstyle":{"mtext":"\u2758"}}}},{"mo":"-","mrow":{"munder":{"mo":"\u2211","mrow":{"mi":["c","C"],"mo":"\u2208"}},"mo":"\u2062","mrow":{"mrow":[{"msub":{"mi":["g","m"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"c"}},{"msub":{"mi":["g","m"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"c"}}],"mo":["\u2062","\u2062","\u2062"],"mi":"log","mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}}}}],"mo":"="}}}},"The concept coherency metric  (CCM) can now be defined as:",{"@attributes":{"id":"p-0308","num":"0320"},"maths":{"@attributes":{"id":"MATH-US-00046","num":"00046"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"CCM","mo":"=","mfrac":{"mrow":[{"mi":"I","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["C","M"],"mo":";"}}},{"mi":"log","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mrow":{"mo":["(",")"],"mrow":{"mo":["\uf603","\uf604"],"mi":"C"}}}]}}}},"br":{},"b":"1755"},"It may be further observed that, in the worst case, all of the software may be in a single module; that is, a monolithic system having |M|=1. Here, the I(C;M) becomes 0, as shown below:",{"@attributes":{"id":"p-0310","num":"0322"},"maths":{"@attributes":{"id":"MATH-US-00047","num":"00047"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mrow":{"mi":"I","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["C","M"],"mo":";"}}},"mo":"\u2062","msub":{"mo":"\u2758","mrow":{"mrow":{"mo":["\uf603","\uf604"],"mi":"\u2133"},"mo":"=","mn":"1"}}},{"mrow":[{"mi":"H","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"C"}},{"mi":"H","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["C","M"],"mo":["\u2062","\u2062"],"mstyle":{"mtext":"\u2758"}}}}],"mo":"-"}],"mo":"="}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mrow":[{"mi":"H","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"M"}},{"mi":"H","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["M","C"],"mo":["\u2062","\u2062"],"mstyle":{"mtext":"\u2758"}}}}],"mo":"-"}}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mrow":[{"mo":"-","mrow":{"munder":{"mo":"\u2211","mrow":{"mi":["m","\u2133"],"mo":"\u2208"}},"mo":"\u2062","mrow":{"mrow":[{"mi":"\u03c1","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}},{"mi":"\u03c1","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":"log"}}},{"munder":{"mo":"\u2211","mrow":{"mi":["c","C"],"mo":"\u2208"}},"mo":"\u2062","mrow":{"mrow":[{"mi":"\u03c1","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"c"}},{"munder":{"mo":"\u2211","mrow":{"mi":["m","\u2133"],"mo":"\u2208"}},"mo":"\u2062","mrow":{"mrow":[{"mi":"\u03c1","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["m","c"],"mo":["\u2062","\u2062"],"mstyle":{"mtext":"\u2758"}}}},{"mi":"log","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"\u03c1","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["m","c"],"mo":["\u2062","\u2062"],"mstyle":{"mtext":"\u2758"}}}}}}],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}],"mo":"\u2062"}}],"mo":"+"}}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mn":"0","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"since","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mrow":{"mi":"\u03c1","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}},{"mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"and","mrow":{"mi":"\u03c1","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["m","c"],"mo":["\u2062","\u2062"],"mstyle":{"mtext":"|"}}}}},"mo":"=","mn":"1"}],"mo":"="}}}}}}]}}}},"Similarly to the concept domination metric , the concept cohesion metric  adopts an information-theoretic approach to measure the extent to which modules in a given system, consisting of source code (such as the source code ), are cohesive with respect to the main concepts embodied in the modules. Like the concept domination metric , this metric  also corresponds to the principle \u201cmaximization of module coherence on the basis of similarity and singularity of purpose\u201d as discussed with reference to example 3.",{"@attributes":{"id":"p-0312","num":"0324"},"figref":["FIG. 18","FIG. 17","FIG. 17"],"b":["1800","1742","1852","1854","1852","1854","1753","1755"]},"At , concept domination of given source code, such as the source code  (), can be calculated. This can produce an index, such as the concept domination metric  of .","At , coherency of given source code, such as the source code  (), can be calculated. This can produce an index, such as the concept domination metric  () and\/or the coherency metric  ().","At , after one or more similarity of purpose modularity evaluations have been calculated, results can be generated from the one or more calculated indices.",{"@attributes":{"id":"p-0316","num":"0328"},"figref":["FIG. 19","FIG. 17","FIG. 17","FIG. 17"],"b":["1900","1742","1753","1753"]},"At , source code is received. This source code may be the source code  of . At , a concept-term map is received. This concept term map  may be a concept set as discussed with reference to example 19. For example, it may be an input file containing a set of business concept names and the associated terms, keywords, and abbreviations, that can be used to identify a business concept. This concept term map may be created manually, automatically, or by some combination of the two.","A keyword extractor  then extracts concept terms received from the concept-term map  from the source code , producing a concept frequency distribution . The keyword extractor  may input the keywords from the concept-term map  as regular expressions and then may compute a concept frequency distribution for functions by counting the occurrences of the keywords in the function signature, return types, and data structures used by the function. Function calls need not be considered in the counting process as they can skew the concept distribution frequencies. For example, suppose that a customer-update functions \u0192calls an account-handling function \u0192several times. If the concept account is looked for in the function call \u0192(called by the customer \u0192), several occurrences of the concept account will be found, without the concept otherwise being mentioned in the function. If the number of occurrences is sufficiently high account might appear (incorrectly) as the dominating concept in \u0192.","This concept frequency distribution  can, in an exemplary embodiment, be stored in a metadata database . A metric calculator , such as the similarity of purpose metric calculator  can then use, at least, the concept frequency distribution , with other inputs, to produce, at a minimum, the concept domination metric  and the coherency metric . Similarly, an evaluator  may be used to aid in the calculations of the concept domination metric  () and\/or the coherency metric  () or other indices as described in the examples herein.",{"@attributes":{"id":"p-0320","num":"0332"},"figref":["FIG. 20","FIG. 19","FIG. 19"],"b":["2000","1900","2010","1910"]},"At , occurrences of the concepts are counted in the source code. At , results of the concept extraction\u2014the concept counts\u2014are generated. The concept count results may be a listing of how may of the concepts appear within various functions, modules, layers, etc; may be an analysis of the concept counts, and so forth.",{"@attributes":{"id":"p-0322","num":"0334"},"figref":"FIG. 21","b":["2100","2110","2120","2130","2140","2150"]},"For instance, programmer PI  may have modified a file F  whose version is 0.1 . Modifications are stored in D  with new version of file being 0.2 . The modifications can be those modifications that are generally tracked in version control software. The following modifications are typically stored: modification in file details, modification in function details, modification in global variable details, modification in data structure details, modification in function dependency, modification in dependency between global variables and functions, and changes in dependency between data structures and functions.",{"@attributes":{"id":"p-0324","num":"0336"},"figref":["FIG. 22","FIG. 100","FIG. 21","FIG. 100"],"b":["2200","2226","2226","110","2100","2228","110","2230"]},"In one embodiment of the present technique, the programmer code modification history extractor  parses the source code modification history data (source code modification history  of ) and stores the programmer, file and version information and the exact changes in a secondary storage such as the \u201ccode modification history store.\u201d In another embodiment, the secondary storage can be a conventional relational database. The programmer code modification history extractor  can extract at least some portion of the following information (or other information) from the modification history data: name of the programmer, name of the file (source code) the programmer has modified, the version of the file and date of creation, the nature of the change in the file with respect to its previous version.","In one embodiment, the changes with respect to the previous version that can be retrieved include: the functions that have been added\/modified\/deleted, the data structures\/global variables that have been added\/modified\/deleted, which function dependencies, global variable-function dependencies, data structure-function dependencies have been added\/modified\/deleted. In one embodiment, the above information can be stored various database tables.",{"@attributes":{"id":"p-0327","num":"0339"},"figref":["FIG. 23","FIG. 22"],"b":["2300","2200"]},"At , the source code modification history is received. At , the programmer coding history is extracted from the source code modification history. At , the programmer coding history results are generated using, at least in part the programmer coding history .",{"@attributes":{"id":"p-0329","num":"0341"},"figref":["FIG. 24","FIG. 3","FIG. 3","FIG. 22"],"b":["2400","2410","310","2420","320","2430","2230","2450","2480"]},{"@attributes":{"id":"p-0330","num":"0342"},"figref":["FIG. 25","FIG. 24","FIG. 24","FIG. 24","FIG. 24"],"b":["2500","2400","2510","2410","2420","2430","2520"]},{"@attributes":{"id":"p-0331","num":"0343"},"figref":["FIG. 26","FIG. 1"],"b":["2600","2650","110","2480","2655","2655","2665","2670","2680"]},{"@attributes":{"id":"p-0332","num":"0344"},"figref":["FIG. 27","FIG. 26","FIG. 26"],"b":["2700","2600","2710","2720","2655","2730"]},{"@attributes":{"id":"p-0333","num":"0345"},"figref":["FIG. 28","FIG. 1"],"b":["2800","2810","110","2824","2826","2826","2828","2826","2836"]},"A programmer history , such as the programmer history  of , is used by a history parser , which reads the parsed programmer history (not shown) into the metadata database . A module analyzer  is also present, which, in an exemplary embodiment, accepts as input an architectural description of the source code  (), outputs a module analysis (not shown) and stores it in the metadata database . A metrics calculator , which may be a modularization evaluator  (), then uses information stored in the metadata database , to produce modularization quality evaluation results .",{"@attributes":{"id":"p-0335","num":"0347"},"figref":["FIG. 29","FIG. 28"],"b":["2900","2800","2910","2920","2930","2910"]},{"@attributes":{"id":"p-0336","num":"0348"},"figref":["FIG. 30","FIG. 21"],"b":["3000","3015","3010","3018","3018","2100"]},"A model extractor  takes as input source code , which may be source code  of . The model extractor  then extracts a source code model  which then may be stored in a source code database, which may be a stand-alone database, or may be a portion of a larger database. A modules list , which may be an architectural description  (), may be used by the module extractor  to produce the source code model .","A series of perspective evaluators, A, B . . . N, may then take as input the programming coder history , the source code model , and the modules list  to evaluate the quality of modularization of the software, producing modularization metrics. Examples of such metrics include but are not limited to: structural metrics, (described with reference to examples 15 and 16), architectural metrics (described with reference to examples 15 and 16), size-based metrics (described with reference to examples 17 and 18), and similarity of purpose metrics (described with reference to examples 19 and 20).","In at least one embodiment, at least one of these metrics is calculated using a \u201cbefore and after\u201d technique. For example, prior to a code change by one or more programmers, and subsequent (e.g., immediately subsequent) to the code change. The definition of \u201ccode change\u201d is meant to be very flexible, and embraces any sort of change or changes that are desired to be measured. Calculation of the metrics can be triggered based on a threshold amount of time that has passed (i.e., every week, month, quarter, etc.) or based on a threshold number of lines of code written, and so forth.","In such a case, the change in the modularization metric values indicates whether the programmer's change decreased the modularity of the system, increased the modularity of the system or maintained the modularity unchanged.","The metrics generated can then be stored in a programmer performance information repository . Changes in metric values can be aggregated to arrive at the overall effect of the change, which, in turn, can represent the performance of the programmer for that given change.","A user interface  can be used to specify report parameters for a report generator . The report generator  can pull information from, for example, the user interface  and the programmer performance information repository  to generate a programmer performance report .","The programmer performance report may indicate a series of modularization metrics for one or more programmers. The change in the modularization metric values can indicate whether the programmer's change decreased the modularity of the system, increased the modularity of the system or maintained the modularity unchanged.","In another embodiment, a final performance score for respective programmers is calculated based on the performance for each, or a set of, individual changes, number of changes made and consistency of performance. In another embodiment, based on the modularity metric scores, programmers who have caused deterioration (low scores) of the system are identified. In another embodiment, for identified low-scoring programmers, the source-code changes made by them are analyzed and the type of changes which caused maximum damage is derived.","In another embodiment, analysis on the source code changes made by poor scoring programmers is performed to determine the modularity principles that were not followed. In another embodiment, the programmer performance report  is generated based on the metric values for the final version of the system for programmers. In another embodiment of the present technique, refactoring solutions for improving the modularity of the system are presented.",{"@attributes":{"id":"p-0346","num":"0358"},"figref":["FIG. 31","FIG. 30","FIG. 30"],"b":["3100","3000","3110","3120","3010","3130","3140"]},{"@attributes":{"id":"p-0347","num":"0359"},"figref":["FIG. 32","FIG. 1","FIG. 1","FIG. 1"],"b":["3200","3210","110","3250","150","3270","170","3250","3210","3240","3210","3215","3250","3270"]},"A source code change determiner , which may be a commercially available version control software, then determines the difference between the source code  and the changed source code , to produce source code modularization changes , which may be source code modularization results. By looking at the modularization results  generated by the source code  and the different modularization results generated from the changed source code , in some embodiments, the source code change determiner  can then determine which changes led to the differences in the modularization results .","Examples of changes that lead to difference in modularization include but are not limited to: addition or deletion of functions, introduction of unwanted dependencies between functions in different modules, a function using a global element used by a function in another module, failure to use the API properly, ad-hoc function calls, calling functions in a higher layer from a lower layer, and so on.","An exemplary report format that provides a diagnostic report related to the modularity of a system is described here; an example report for the system \u201cSlim Tool\u201d is shown in example 38. The report may have three parts, described below.","Part A gives a system level overview of the metrics which will be reported on.","Part B gives a more detailed description of each metric with respect to the Structural, Information, Size and Architecture viewpoints, in some embodiments. In an exemplary embodiment, if the user clicks any one of the metric links (e.g. MII\u2014Module Interaction Index link), a detailed report for that particular metric is shown. An exemplary report for the MII metric has been shown in Example 39.","Part C gives analysis of modules from various design principles, for example, categorizing modules depending on whether or not they obey one of the design principle taught herein. For instance, under the design principle \u201cAll inter-module interactions should only be through API functions\u201d, there are various categories of modules which violate and obey the design principle.","Individual modules may also have reports. Example 41 shows an exemplary model analysis report containing a detailed analysis with respect to a given module and functions inside the module. The sections shown in this report are easily extendible for other type of metrics as and when they are introduced.","A sample system metric report is shown below. The system metric may have a system health overview chart which charts a selection of the system metric values that have been produced for a system using embodiments taught herein. For example,  shows a System Health View Chart  that can be used to give an overall view of how well a system has been modularized.","System Metrics",{"@attributes":{"id":"p-0356","num":"0368"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["S. No","Metric Name","Metric Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","MII","0.7"]},{"entry":["2","NC","0.878"]},{"entry":["3","APIU","0.513"]},{"entry":["4","IDI","0.643"]},{"entry":["5","MSUI","0.712"]},{"entry":["6","MSBI","0.363"]},{"entry":["7","CDI","0.875"]},{"entry":["8","LOI","0.657"]},{"entry":["9","MISI","0.725"]},{"entry":["10","NTDM","0.56"]},{"entry":["11","CCM","0.45"]},{"entry":["12","CDM","0.55"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"These metrics measure the function call traffic through the API functions of modules in relation to the overall function call traffic","1. MII\u2014Module Interaction Index","This metric can calculate how effectively a module's API functions have been used by the other modules in the system.","Example index values used for this report are shown below.",{"@attributes":{"id":"p-0360","num":"0372"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["MII->1","This is the ideal case where all intermodule calls are"]},{"entry":[{},"routed only through API functions"]},{"entry":["MII->0","This is not a desirable case and indicates that all external"]},{"entry":[{},"calls are made to the non-API functions of a module"]},{"entry":["MII = NA","Modules to which no external calls are made"]},{"entry":[{},"(typically driver modules) - the MII value is not applicable"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"This metric is based on the principle that the non-API functions of a module should not be exposed to the other modules. This metric measures the extent to which non-API functions are being accessed by the other modules.","Example index values used for this report are shown below.",{"@attributes":{"id":"p-0363","num":"0375"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["NC->1","This is the ideal case where no intermodule calls are routed"]},{"entry":[{},"through non-APIs"]},{"entry":["NC->0","This indicates that there are no non-API (functions that"]},{"entry":[{},"internal) functions in the module"]},{"entry":["NC = NA","This indicates that no external calls are made to the module."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"This index can determine what fraction of the API functions exposed by a module is being used by other modules. The intent of this index is to discourage the formation of large monolithic modules offering disparate services and encourage modules that offer specific functionalities. Any module A that depends on a module B should utilize some portion of the functionality offered by module B. Multiple modules should not depend on module B for varied functionality unless Module B is a utility module.","Example index values used for this report are shown below.",{"@attributes":{"id":"p-0366","num":"0378"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["APIU->1","This is the ideal case where all the API functions of the"]},{"entry":[{},"module are utilized by other Modules"]},{"entry":["APIU->0","This indicates that there are no API functions in the module"]},{"entry":[{},"and all the calls are made to non-API functions."]},{"entry":["APIU = NA","This indicates that this module is not accessed"]},{"entry":[{},"by other modules"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"This index can measure the number of implicit dependencies that are created when the given module writes into global variables, with assumption being that any global variable that is written into may be accessed by another module. This index discourages the use of global variables for transfer of data across modules. Ideally, inter-module interaction should be through function calls (preferably through API functions).","Example index values used for this report are shown below.",{"@attributes":{"id":"p-0369","num":"0381"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["IDI->1","All intermodule interaction is only through API functions."]},{"entry":["IDI->0","All intermodule interaction is only through implicit"]},{"entry":[{},"dependencies"]},{"entry":["IDI = NA","There are no function calls made from this module and this"]},{"entry":[{},"module does not create any implicit dependencies"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"This class of metrics attempts to measure how modular the system is in terms of the individual module's sizes. These metrics need not be applicable at Module level. The computed values are at system level.","1. MSUI\u2014Module Size Uniformity Index","This index can measure the extent to which all the module sizes are similar.","Example index values used for this report are shown below.",{"@attributes":{"id":"p-0373","num":"0385"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"MSUI->1","All modules are of similar size"]},{"entry":[{},"MSUI->0","There is a very high deviation in module sizes"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"This can index measure how similar the module sizes are with respect to a magic (optimal) size which can be provided by a subject matter expert.","Example index values used for this report are shown below.",{"@attributes":{"id":"p-0376","num":"0388"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"MSBI->1","All module sizes are the same as the magic size"]},{"entry":[{},"MSBI->0","All module sizes are very different from the magic size"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"These metrics measure the extent of organization of the modules into higher level structures, especially the horizontal layered structures. The assumption behind these metrics is that not all of the modules exist in the same level of utility and that there exists some hierarchy.","1. CDI\u2014Cyclic Dependency Index","This index measures the number of cyclic dependencies that exist across modules within a system. Modules A, B and C are said to be in a cycle when A depends on B, B depends on C and C depends on A. This metric need not be applicable at Module level.","Example index values used for this report are shown below.",{"@attributes":{"id":"p-0380","num":"0392"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CDI->1","There are no cyclic dependencies across modules in the system"]},{"entry":["CDI->0","All the modules of the system are cyclically dependent"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"A module is assumed to be well layered when calls that are made to modules in a given layer are made from modules in the layer immediately above them. This index can measure the extent to which this principles in followed. This metric need not be applicable at Module level.","Example index values used for this report are shown below.",{"@attributes":{"id":"p-0383","num":"0395"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LOI->1","All the external calls to modules in any layer are"]},{"entry":[{},{},"made only from modules in the immediate upper layer."]},{"entry":[{},"LOI->0","None of the external calls to modules in any layer"]},{"entry":[{},{},"are made from modules in the immediate upper layer."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"This index can measure the stability of intermodule dependencies. Assuming that large software systems are organized into horizontal layers, a desirable property of this architecture may be that the modules in the lower layer be more stable in relation to the modules in the upper layers. Thus, changes made to the overall software should be concentrated to the upper layers. Also, to the extent possible, the changes should not impact the lower layers. This metric is based on the assumption that each module should depend on other modules that are in the same or lower layers. The value of this metric may indicate the changeability of the system.","Example index values used for this report are shown below.",{"@attributes":{"id":"p-0386","num":"0398"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["MISI->1","This indicates that the module depends only on modules"]},{"entry":[{},"that are more stable than itself and hence is"]},{"entry":[{},"easily changeable."]},{"entry":["MISI->0","This indicates that the module depends only on modules"]},{"entry":[{},"that are more unstable than itself and hence is not an easily"]},{"entry":[{},"changeable system."]},{"entry":["MISI = NA","This indicates that the module is not dependent on"]},{"entry":[{},"other modules."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Testability dependence can be created if the assessment of the correctness of the input-output relationships during the testing of a module depends on the correctness of the input-output relationship of another module. That is, if the testing of module m1 requires another module m2 to produce intermediate results that then are used in module m1, there is a testability-dependence between the two modules. This metric is based on the principle that every module should be dependent for testability on as few modules as possible.","Example index values used for this report are shown below.",{"@attributes":{"id":"p-0389","num":"0401"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["NTDM->1","The module is testability dependent on no other module"]},{"entry":["NTDM->0","The module is testability dependent on all of the other"]},{"entry":[{},"system modules"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"These metrics can be based on the assumption that the purpose of any module is to provide a specific service and clues as to what that service is, is provided by the variable names, function names etc. that are used in the code. These keywords themselves are only a manifestation of the concept which is representative of the service that the module tries to provide.","Example index values used for this report are shown below.","1. CDM\u2014Concept Domination Metric","This index measures the dominant concepts in a module. In a modularized system, ideally, each module should have only one dominant concept. A high number of dominant concepts in a module can indicate that the module provides different types of services.","Example index values used for this report are shown below.",{"@attributes":{"id":"p-0394","num":"0406"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CDM->1","Only one concept is dominant in the module"]},{"entry":[{},"CDM->0","All concepts are dominant in the module."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"This metric is based on the notion that if a concept is central to the services offered by a module, then the mutual information between the module and the concept should be high. Mutual information between a concept and a module becomes high when each is able to predict the likelihood of the occurrence of the other with a high probability. This metric need not be measured at module level.","Example index values used for this report are shown below.",{"@attributes":{"id":"p-0397","num":"0409"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CCM->1","Each concept is unique to a module"]},{"entry":[{},"CCM->0","The concepts are distributed across all modules."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The various dimensions along which the quality of the software is improved by the encapsulation provided by modularization include understandability, testability, changeability, analyzability, and maintainability. Listed below are the Design Principles which when adhered to can ensure good modularization. These principles have been derived based on Research Literature as well as experience. For each of the below mentioned principles we list the modules that grossly violate the principles and provide details about the same, so that corresponding changes can be made so as to improve the modularity of the system.","All Inter-module interactions should only be through API functions","Modules that expose a large percentage of their non-API functions to other modules are:","modules\/module2","modules\/module3","Modules that have a high percentage of implicit dependencies (through global variables) with other modules are:","modules\/module1","Any Module A that depends on a Module B should utilize all or most of the API functions of Module B","Modules with a large percentage of unutilized API functions are:","modules\/module4","modules\/module5","Modules that do not provide a complete service (No other module utilizes ALL of the API functions of the given module) are:","modules\/module2","modules\/module3","Modules that provide disparate services (API functions are utilized by a majority of the other system modules) are:","modules\/module1","Module should more or less be of uniform size (this uniform size is a magic size that is decided upon by a domain expert)","Module size is much larger than the average module size:","modules\/module 1","Module size is much smaller than the average module size:","modules\/module2","modules\/module5","Module size is much larger than the magic module size:","modules\/module 1","Module size is much smaller than the magic module size:","modules\/module2","modules\/module5","Modules should not be cyclically dependent (Cyclic dependencies occur when there is a sequence of function calls between modules that starts and ends at the same module). Modules that are in a cycle and make back calls to upper layers are:","modules\/module2","modules\/module3","Module should be independently testable","Modules that are testability dependent on most of the other system modules are:","modules\/module1","modules\/module3","Module dependencies should be unidirectional. Modules should only depend on modules in the immediate lower layers.","Modules that call other modules in upper layers are:","modules\/module4","modules\/module5","Modules that call other modules in lower layers that are not the immediate lower layer:","modules\/module1","modules\/module3","Modules should be dependent only on other modules that more stable than them (Typically modules in a lower level of call hierarchy should be more stable) Modules with the most unstable dependencies are:","modules\/module2","modules\/module4","Each module should provide a distinct service.","The service that is provided by a module can be determined by considering the concepts that the module encapsulates. A (business) concept is the functionality or the idea that a module encapsulates; e.g. in a banking application the concepts would be loans, interest, term deposits etc. It is often recommended that a module be centered around one\/two concepts. For example, a module may implement the concept \u201cloan.\u201d It is not necessary that a concept is implemented by only one module. For instance, various services around the business concept \u201cloan\u201d can be implemented by several modules. But, it is not recommended that one module implements many concepts. That is, one should not implement a module that implements \u201cloan\u201d, \u201ccredit card\u201d and \u201ccalendar.\u201d","Modules which have no concepts are:","modules\/module2","modules\/module3","Modules which have no dominant concepts are:","modules\/module2","modules\/module3","Modules that have a high dominance of a majority of concepts are:","modules\/module2","modules\/module3","Concepts that are not dominant in most of the modules are:","Concept3","Concept4","Concepts that are dominant in most of the modules are:","Concept5","Concept6","An exemplary metric report for a system with five modules reporting on the Model Interaction Index (MII) is shown below. The MII is discussed in greater detail with reference to example 15. The MII value in use here has been normalized such that the value ranges from 0 (worst) to 1 (best). A chart  which shows MII distribution across system modules is shown with reference to . Even though not shown, similar charts for other indexes, such as the non-API Function Closedness Index, the API Function Usage Index, the Implicit Dependency Index, can also be included.","Module Level Metric Values for MII Metric",{"@attributes":{"id":"p-0436","num":"0448"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["S.NO","Module Name","MII Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","modules\/module1","NA"]},{"entry":["2","modules\/module2","0.1"]},{"entry":["3","modules\/module3","0.2"]},{"entry":["4","modules\/module4","0.6"]},{"entry":["5","modules\/module5","0.98"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"An exemplary detailed report for a system level metric is shown below: Module-level diagnosis need not be provided for all metrics. For example, Size based metrics, Layering, Cyclic Dependencies, Domain Concept distribution in the system are reported only at the module level within these reports.","Details of Module Sizes in the System","With reference to , a Module size chart  displays actual module sizes for a given set of modules in KLOC (Thousands of lines of code\u2014not including blank\/comment lines), the average size, and the Magic size of modules as received from, for example, a domain expert. Very large or very small modules tend to be prone to a larger number of errors and hence often require higher maintenance. Good modules should more or less be of similar size and should not be particularly deviant from the magic module size. The chart below gives the actual number of lines of code (in KLOC) for a selected set of modules.",{"@attributes":{"id":"p-0439","num":"0451"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Module Name","Module Size(KLOC)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"module 1","500"]},{"entry":[{},"module 2",". . ."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The table below indicates the layers to which a module belongs and the Layer organization index (LOI) of a particular layer. \u201cNo. of back calls from layer\u201d are the number of module dependencies that layer has with modules in upper layers. \u201cNo. of skip calls from layer\u201d measure the number of calls that are made to layers below which are not the immediately adjacent layers.",{"@attributes":{"id":"p-0441","num":"0453"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Layer",{},"No. of back calls","No. of skip calls"]},{"entry":["Name","Module Name","from layer","from layer"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Layer 1","Module 1, Module 2,","13","21"]},{"entry":[{},"Module 3"]},{"entry":["Layer 2",". . .","11","17"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The \u201cCyclic Dependencies\u201d table shows the number of cycles in the system and the participating modules in each of the cycles. Cyclic dependencies occur when there is a sequence of function calls between modules that starts and ends at the same module. The largest cycle is reported for each module. Cycles within cycles are not reported. If there are four modules M1, M2, M3 and M4, and M1 has a function call to M2, M2 has a function call to M3, M3 calls M4 and M4 has a function call back to M1, then M1, M2, M3 and M4 are in a cycle, which would most likely be reported. However, the cycles within this cycle would not be reported, such as a cycle consisting of M1, M2 and M3.","Cycles whose modules are in different layers are assumed to be instances of bad modularization.",{"@attributes":{"id":"p-0444","num":"0456"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Cycle Name","Module Name","Cycle across layers"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Cycle 1","Module 1, Module 2, Module 3","Yes"]},{"entry":["Cycle 2",". . .",". . ."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0445","num":"0457"},"figref":"FIG. 36","b":"3600"},"Concepts that are not Dominant in any Module",{"@attributes":{"id":"p-0446","num":"0458"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Concept Name","Module Name","Dominance Measure"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Concept 1","Module 1","0.21"]},{"entry":[{},"Concept 2",". . .",". . ."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0447","num":"0459"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Concept Name","Module Name","Dominance Measure"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Concept 3","Module 1","0.76"]},{"entry":[{},"Concept 2",". . .",". . ."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"An exemplary modularity detail report is shown below for an exemplary module, module3. The report has, among other features, a detailed analysis for a given module and for the functions inside the module. The report refers to \u201cfunctions\u201d, but the term should be understood to mean any named block of code that performs a task, such that it encompasses functions, procedures, methods, and the like.","Details of Types of Functions in the Module","The functions implemented in the module have been classified as API (these should be the only functions that expose the functionality of the module to other modules), INTERNAL (these functions are typically not accessed by other modules), BAD (these are the non-API functions of the module that are accessed by other modules) and DEAD (These may be functions that are neither accessed by nor access other modules)",{"@attributes":{"id":"p-0451","num":"0463"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Classification","Number of Functions"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"API","6"]},{"entry":[{},"INTERNAL","12"]},{"entry":[{},"DEAD","60"]},{"entry":[{},"BAD","4"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Details of BAD Functions in the Module\n\n",{"@attributes":{"id":"p-0453","num":"0466"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Bad Function","Bad File","Calling",{},{}]},{"entry":["name","Name","Module","Calling function","Calling file"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["bad function1","bad file1","calling","calling function1","calling file1"]},{"entry":[{},{},"module1"]},{"entry":["bad function2","bad file2","calling","calling function2","calling file2"]},{"entry":[{},{},"module2"]},{"entry":[". . .",". . .",". . .",". . .",". . ."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"Details of API Function Usage by Other Modules\n\n",{"@attributes":{"id":"p-0455","num":"0471"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},{},"Calling","Calling",{}]},{"entry":["API function","API file","module","function","Calling file"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["api function1","dir1\/apifile1","module3","function3","dir3\/calling file3"]},{"entry":["api function1","dir1\/apifile1","module4","function4","dir4\/calling file4"]},{"entry":["api function2","dir2\/apifile2","not utilized","not","not utilized"]},{"entry":[{},{},{},"utilized"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"Global Variables that are Written to by the Module.\n\n",{"@attributes":{"id":"p-0457","num":"0474"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Function name","File Name","Global variable"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[". . .",". . .",". . ."]},{"entry":[". . .",". . .",". . ."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Module Size Details\n\n","Details of Calls Made to Modules that are not in the Immediate Lower Layer\n\n",{"@attributes":{"id":"p-0460","num":"0480"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":["Calling",{},{},"Called","Called",{}]},{"entry":["function","Calling file","Called layer","module","function","Called file"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[". . .",". . .",". . .",". . .",". . .",". . ."]},{"entry":[". . .",". . .",". . .",". . .",". . .",". . ."]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}}}},"Unstable Dependencies\n\n","Instability Index for the module is 0.45",{"@attributes":{"id":"p-0463","num":"0484"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Depends on Module","InStability index"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},". . .",". . ."]},{"entry":[{},". . .",". . ."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Cyclically Dependent Modules\n\n","Testability Dependence\n\n","Details of Concept Distribution in Module\n\n",{"@attributes":{"id":"p-0467","num":"0492"},"figref":["FIG. 39","FIG. 32"],"b":["3900","3200","3910","3210","3920","3930"]},{"@attributes":{"id":"p-0468","num":"0493"},"figref":["FIG. 40","FIG. 30","FIG. 30"],"b":["4000","4002","3020","4018","3018","4019","4021","4088"]},"The programmer modified code  is then used by a perspective evaluator  (which may be any of the perspective evaluators A . . . N (), and which may return one or more of the modularization indices (or metrics) discussed herein. This index (or indices) may then be used a portion or as the entire programmer evaluation results , such as the programmer evaluation results  ()","In an exemplary embodiment, the change in at least one the metric value indicates whether the programmer's change decreased the modularity of the system, increased the modularity of the system or maintained unchanged. Change in each of the metric values can be aggregated to arrive at the overall effect of the change (or changes) to the system made by the programmer which, in turn, represents the performance of the programmer for that given change or set of changes.","In another embodiment, a final performance score for a programmer is calculated based on the performance for each individual change, number of changes made and consistency of performance.",{"@attributes":{"id":"p-0472","num":"0497"},"figref":["FIG. 41","FIG. 40","FIG. 40","FIG. 30"],"b":["4100","4100","4000","4110","4002","4120","3018","4130"]},"At , the portion(s) of the source code that has been modified by the programmer is evaluated using at least one modularization metric. These modularization metrics may be any of the perspective evaluators A . . . N, any of the modularization metrics discussed in any of the examples, and so on. This may generate programmer evaluation results, such as the programmer evaluation results  ().","At , which is optional, the programmer is ranked based on the programmer evaluation results against other programmers. This evaluation may be with other programmers working on the same source code, programmers working on other source code in the same system, programmers working on different systems, and so forth.","Once programmer evaluation results are known, corrective action can be taken to improve the overall quality of service of the maintenance by providing specific feedback to the programmers who have caused significant degradation of the software. As the specific portions of the software which were changed have been identified, the changes that the programmer made that caused the degradation in modularization can be identified and fixed. Thus, programmers will be much less likely to perform such activities in the future which cause modularity degradation. This, in turn, will keep the software more modular and maintainable.",{"@attributes":{"id":"p-0476","num":"0501"},"figref":"FIG. 42"},"This randomization very roughly simulated what can happen over time as a large system is maintained\u2014new features are added, and the software generally evolves to meet changing hardware and functional requirements.","For four systems, Linux (shown in ), Mozilla (shown in ), Postgresql (shown in ), and Apache (shown in ), each system is analyzed using the metrics described herein twice. First, the system with its modularization intact as originally designed by humans is analyzed. Second, the original modular structure of the software is destroyed by randomly assigning functions and files to modules, breaking the internal coherence of the module\u2014the random modularization as shown in . Then, the broken systems are analyzed using the same metrics.","The graphs, , , , and , show the result of this analysis. As can be seen, the metrics, other than the size-based metrics, take a turn for the worse with random modularization. However, the size-based metrics, especially the MSUI metric, do not show large variation when moving from the human-supplied to the randomized modularization. The reason for this is not difficult to understand. Since the randomization mechanism is based on a uniform random number generator, the functions are more-or-less equally distributed across modules, resulting in a small standard deviation in module size.","The IDI metric also does not show major variation between human and random variation. Recall that the IDI of a module is the ratio of external function call count to the inter-module dependency count, using both functions and global variables. The randomization process randomly assigns functions to modules. However, the function-global variable dependency, obtained by static analysis of the source code, is not changed by the randomization process. As a result, the inter-module dependency count (through the unchanged global variables) is unchanged, for the large part. Furthermore, the random assignment of functions to modules, in many cases, does not have significant impact on the total count of external function calls.","These observations regarding the relative values of the various metrics speaks to the fact quality of modularization is best understood through a variety of metrics.",{"@attributes":{"id":"p-0482","num":"0507"},"figref":"FIG. 43","b":"4302"},"The graph  shows a comparison of modularization results between two different Mozilla versions: mozilla-19980408 and mozilla-19981211. Previously-published reports indicate that mozilla-19981211 is better modularized than mozilla-19980408, borne out by this analysis.",{"@attributes":{"id":"p-0484","num":"0509"},"figref":"FIG. 44","b":["4402","4406","4404","4408"]},"To analyze how concepts might be dispersed and concentrated across modules in a system, the frequency distribution for the concepts were examined. If a module had roughly equal occurrences of multiple concepts it is difficult if not impossible to determine a dominating concept for the module, and, thus difficult to attribute a similarity of purpose for the module. As shown at , the module os\/beos is dominated by the concept platform On the contrary, both randomly modularized systems show no such concept domination\u2014as is to be expected, as functions assigned randomly to a module would have few dominating concepts.",{"@attributes":{"id":"p-0486","num":"0511"},"figref":"FIG. 45","b":["4502","4504","4502","4504"]},"The graph  shows the frequency that the concept \u201cparser\u201d occurred in multiple modules of the source code for mysql. The graph  shows the frequency concept \u201cparser\u201d occurred in multiple modules of the source code for mysql, after the modules had been randomized. Similar to the results for httpd, above, as can be seen, the concept \u201cparser\u201d occurs in just a small number of modules in the human-modularized version , but occurs in almost all modules in the random modularization .",{"@attributes":{"id":"p-0488","num":"0513"},"figref":["FIG. 46","FIG. 30"],"b":["4600","4600","3082"]},{"@attributes":{"id":"p-0489","num":"0514"},"figref":["FIG. 47","FIG. 30"],"b":["4700","4700","3082"]},"This example documents experiments performed using methods taught herein. The open-source application Apache httpd web-server was used for the experiments documented herein. To evaluate the maintenance scenario shown in  the source code was modified to add additional functions and to modify the function calling patterns. To analyze the capability of the tool to evaluate programmer, multiple versions of the system were created, as shown in . Each version then had its source code altered. In both cases, neither the inherent structure of the modules was not changed; nor was the overall architecture of system.",{"@attributes":{"id":"p-0491","num":"0516"},"figref":"FIG. 48"},{"@attributes":{"id":"p-0492","num":"0517"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Main( ) => make_worker( )"]},{"entry":[{},"Main( ) => ap_start_restart( )"]},{"entry":[{},"main( ) => tell_workers_to_exit( )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The type of deterioration that is introduced into the system through these changes is quantified using MII (module interaction index, shown at  in ) and APIU (API function usage index, shown at  in ) metrics. A comparison of the MII and APIU values before and after deterioration is shown below, and in  at .","Original: MII(Server\/mpm\/beos)=1",{"@attributes":{"id":"p-0494","num":"0000"},"ul":{"@attributes":{"id":"ul0033","list-style":"none"},"li":{"@attributes":{"id":"ul0033-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0034","list-style":"none"},"li":["APIU(Server\/mpm\/beos)=1\n\nPost-Deterioration: MII(Server\/mpm\/beos)=0.5\n","APIU(Server\/mpm\/beos)=0.66"]}}}},"Similarly, the chart at  shows the system level deterioration in modularization as shown by decrease in the LOI (layer organization index, shown at ), NTDM (testability index, shown at  in ), IDI (implicit dependency index, shown at  in ), and CDM (Concept domination metric, shown at  in ).","To analyze the characteristics of layer organization index, specifically with respect to the code deterioration, consider the httpd-2.0.53 system module dependencies. An analysis of the module dependencies between modules of httpd-2.0.53 reveal that there exists a set of modules that are mutually dependent on each other. These modules are listed below.",{"@attributes":{"id":"p-0497","num":"0523"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"server"]},{"entry":[{},"server\/mpm\/beos"]},{"entry":[{},"server\/mpm\/experimental\/leader"]},{"entry":[{},"server\/mpm\/mpmt_os2"]},{"entry":[{},"server\/mpm\/prefork"]},{"entry":[{},"server\/mpm\/winnt"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"One of the modularity deterioration patterns is the addition of a new module dependency that creates a set of mutually dependent modules or that increases the number of modules that are mutually dependent. This code deterioration is created by adding a new dependency of module srclib\/apr\/threadproc\/netware on module server\/mpm\/beos. i.e.: srclib\/apr\/threadproc\/netware\u2192server\/mpm\/beos","This type of deterioration is quantified using the metrics: LOI and NTDM. A comparison of the metric values before and after modification is as shown below and in .",{"@attributes":{"id":"p-0500","num":"0526"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Original:","system LOI: 0.429"]},{"entry":[{},{},"system NTDM: 0.9254"]},{"entry":[{},"post deterioration:","system LOI: 0.308"]},{"entry":[{},{},"system NTDM: 0.8806"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"According to the principle of module interaction, interaction between modules should be explicit (i.e. through function calls) and not through global variables (i.e. Implicit). To simulate a deterioration of modularity by violating this principle new implicit dependencies between modules server and aaa have been added. The deterioration is quantified using the Implicit Dependency Index (IDI) metric. A comparison of the metric values before and after the deterioration is shown below, and in .","Pre deterioration System IDI=0.201432530120482","Post deterioration System IDI=0.199","Module aaa handles authentication, and only authentication, in httpd. The deterioration in modularity of aaa is simulated by mixing in disparate concepts: \u2018server\u2019, and \u2018proxy\u2019. This is achieved by randomly adding 50 functions from module server and 30 functions from module proxy to module aaa.","This type of modularity deterioration is measured using the CDM metric. A comparison of pre and post deterioration metric values are as follows and shown in .",{"@attributes":{"id":"p-0504","num":"0530"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Original","CDM: 0.56121333395175"]},{"entry":[{},"Post deterioration","CDM: 0.397525672555241"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0505","num":"0531"},"figref":"FIG. 50"},"Experiment Details: Version 0-Version1","Version 0 depicts the original snapshot of modules srclib\/apr\/memory\/unix, server\/mpm\/experimental\/leader and their interactions.","The module srclib\/apr\/memory\/unix has two internal functions run_child_cleanups and cleanup pool_for_exec. Programmer 1 adds a new function dependency from module srclib\/apr\/misc\/netware to these two internal functions, thereby violating the module interaction principle.","The change in MII metric values from version 0 to version 1 as a result of the code change by programmer 1 is as follows:","Pre MII(srclib\/apr\/memory\/unix)=1;","Post MII(srclib\/apr\/memory\/unix)=0.33;","Experiment Details: Version 1-Version2","Programmer p2 adds some of the server and proxy functionality in module \u2018aaa,\u2019 an authentication module. This change violates the similarity of purpose principle. The change in CDM metric value from version1 to version2 is as follows:","CDM pre: 0.5612","CDM Post: 0.397","Experiment Details: Version 2-Version3","In the module server\/mpm\/experimental\/leader, interaction with other modules violated the MII principle in version 2. The functions process_socket( ) and make_child( ) were invoked by srclib\/apr\/misc\/network even though they were internal functions within a different module.","In version3, as part of the refactoring exercise, programmer 3 introduced a new api function process_api that exposed the functionality of the two internal functions to the external modules, with process-api directly calling those two internal functions. The change in the MII metric from version 2 to version 3 was as follows:","Pre MII(server\/mpm\/experimental\/leader)=0.33","Post MII(server\/mpm\/experimental\/leader)=1","Experiment Details: Programmer Evaluation.",{"@attributes":{"id":"p-0512","num":"0538"},"figref":"FIG. 51","b":["1","2","3"]},{"@attributes":{"id":"p-0513","num":"0539"},"figref":["FIG. 52","FIG. 1"],"b":"150"},{"@attributes":{"id":"p-0514","num":"0540"},"figref":"FIG. 52","b":["5200","5200"]},"With reference to , the computing environment  includes at least one central processing unit  and memory . In , this most basic configuration  is included within a dashed line. The central processing unit  executes computer-executable instructions and may be a real or a virtual processor. In a multi-processing system, multiple processing units execute computer-executable instructions to increase processing power and as such, multiple processors can be running simultaneously. The computing environment  may also include a graphics processing unit (GPU) , which assists in creating or speeding up graphics processing and display. Memory  may be volatile memory (e.g., registers, cache, RAM), non-volatile memory (e.g., ROM, EEPROM, flash memory, etc.), or some combination of the two. The memory  stores software  implementing the described methods for measuring quality of software modularization. A computing environment may have additional features. For example, the computing environment  includes storage , one or more input devices , one or more output devices , and one or more communication connections . An interconnection mechanism (not shown) such as a bus, a controller, or a network, interconnects the components of the computing environment . Typically, operating system software (not shown) provides an operating environment for other software executing in the computing environment , and coordinates activities of the components of the computing environment .","The storage  may be removable or non-removable, and includes magnetic disks, magnetic tapes or cassettes, CD-ROMs, CD-RWs, DVDs, or any other medium which can be used to store information and which can be accessed within the computing environment . The storage  stores instructions for the software  implementing methods for measuring quality of software modularization.","The input device(s)  may be a touch input device, such as a keyboard, mouse, pen, or trackball, a voice input device, a scanning device, or another device, that provides input to the computing environment . For audio, the input device(s)  may be a sound card or similar device that accepts audio input in analog or digital form, or a CD-ROM reader that provides audio samples to the computing environment . The output device(s)  may be a display, printer, speaker, CD-writer, or another device that provides output from the computing environment .","The communication connection(s)  enable communication over a communication medium to another computing entity. The communication medium conveys information such as computer-executable instructions, compressed graphics information, or other data in a modulated data signal.","Computer-readable media are any available media that can be accessed within a computing environment . By way of example, and not limitation, with the computing environment , computer-readable media include memory , storage , communication media (not shown), and combinations of any of the above.","Any of the methods described herein can be performed via one or more computer-readable media (e.g., storage media) having computer-executable instructions for performing such methods.","The technologies of any example described herein can be combined with the technologies of any one or more other examples described herein.","In view of the many possible embodiments to which the principles of the disclosed technology may be applied, it should be recognized that the illustrated embodiments are only examples of the technology and should not be taken as limiting the scope of the following claims. We, therefore, claim as our invention all that comes within the scope and spirit of these claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 37"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 38"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 39"},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 40"},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 41"},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 42"},{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 43"},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 44"},{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 45"},{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 46"},{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 47"},{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 48"},{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 49"},{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 50"},{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 51","FIG. 50"]},{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 52"}]},"DETDESC":[{},{}]}
