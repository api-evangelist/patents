---
title: Integrated graphics processing unit with antialiasing
abstract: A graphics pipeline system and method are provided for graphics processing. Such system includes a transform module adapted for receiving graphics data. The transform module serves to transform the graphics data from a first space to a second space. Coupled to the transform module is a lighting module which is positioned on the single semiconductor platform for performing lighting operations on the graphics data received from the transform module. Also included is a rasterizer coupled to the lighting module and positioned on the single semiconductor platform for rendering the graphics data received from the lighting module. During use, an antialiasing feature is implemented on the single semiconductor platform to improve a quality of the graphics rendering.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06992669&OS=06992669&RS=06992669
owner: NVIDIA Corporation
number: 06992669
owner_city: Santa Clara
owner_country: US
publication_date: 20020717
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","DISCLOSURE OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["The present application is a continuation of an application filed Nov. 27, 2000 now U.S. Pat. No. 6,452,595 under Ser. No. 09\/724,206 which, in turn, was a continuation-in-part of an application filed Dec. 6, 1999 now U.S. Pat. No. 6,198,488 under Ser. No. 09\/454,516; which are each incorporated herein by reference in their entirety.","The present invention relates generally to antialiasing and, more particularly, to graphics pipeline systems with antialiasing capabilities.","A general system that implements a graphics pipeline system is illustrated in Prior Art . In this system, data source  generates a stream of expanded vertices defining primitives. These vertices are passed one at a time, through pipelined graphic system  via vertex memory  for storage purposes. Once the expanded vertices are received from the vertex memory  into the pipelined graphic system , the vertices are transformed and lit by a transformation module  and a lighting module , respectively, and further clipped and set-up for rendering by a rasterizer , thus generating rendered primitives that are displayed on display device .","During operation, the transform module  may be used to perform scaling, rotation, and projection of a set of three dimensional vertices from their local or model coordinates to the two dimensional window that will be used to display the rendered object. The lighting module  sets the color and appearance of a vertex based on various lighting schemes, light locations, ambient light levels, materials, and so forth. The rasterization module  rasterizes or renders vertices that have previously been transformed and\/or lit. The rasterization module  renders the object to a rendering target which can be a display device or intermediate hardware or software structure that in turn moves the rendered data to a display device.","Antialiasing is a method for improving the realism of an image by removing jagged edges during rendering. Such jagged edges appear because a computer monitor has discrete pixels, that cannot adequately display image features that are finer than pixel resolution.  illustrates an image  that is subject to aliasing.","If one puts a grid over the image  of  and only colors those squares that are entirely within the circle, aliasing occurs.  illustrates the image  of  subject to aliasing . The \u201cblockiness\u201d that is shown is the result of aliasing, and is exactly what happens when you try to display a circle on a computer screen.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIGS. 1A\u20133","b":["14","14","14"]},"Because of the digital nature of computers, it is not possible to completely eliminate aliasing. However, it is possible to minimize its effects. One solution involves treating each pixel as a finite square area, rather than as a mere point on the screen. Either by computing the color at many points within a pixel, or by keeping track of multiple primitives' partial coverage overlapping a pixel, the final pixel color can be a weighted average of all relevant portions. By capturing information from many points within a pixel, details too fine to be expressed by one-per-pixel sampling make an appropriate contribution.","Continuing with the image  of  though A\u2013, the antialiased circle might then be represented with reference to .  illustrates the manner in which antialiasing  helps eliminate jagged edges, thus making an image seem more realistic.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIGS. 1B\u20131","b":["20","22","20","24","26","20","24"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIGS. 1B\u20132","b":["26","22"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIGS. 1B-3","b":["30","20"]},"Thus, the incorporation of antialiasing in a non-integrated graphics system implementation suffers from a lack of efficient utilization of memory bandwidth (See ), and further requires expensive additional logic (See ).","Generally, integration is often limited by the cost of implementing and manufacturing multiple processing modules on a single chip. In the realm of graphics processing, attempts to integrate modules to increase speed can make costs prohibitive, since the cost of an integrated circuit increases rapidly as die size increases. High performance transform and lighting engines alone require significant area and are thus expensive to implement on-chip. Additional on-chip logic for additional functionality compounds the size and can raise the die cost to prohibitive levels.","There is therefore a need for a cost-effective computer graphics pipeline integration which overcomes the shortcomings inherent to antialiasing on a non-integrated platform.","A graphics pipeline system and method are provided for graphics processing. Such system includes a transform module adapted for receiving graphics data. The transform module serves to transform the graphics data from a first space to a second space. Coupled to the transform module is a lighting module which is positioned on the single semiconductor platform for performing lighting operations on the graphics data received from the transform module. Also included is a rasterizer coupled to the lighting module and positioned on the single semiconductor platform for rendering the graphics data received from the lighting module. During use, an antialiasing feature is implemented on the single semiconductor platform to improve a quality of the graphics rendering.","These and other advantages of the present invention will become apparent upon reading the following detailed description and studying the various figures of the drawings.","FIGS.  through B- show the prior art.  is a flow diagram illustrating the various components of one embodiment of the present invention. As shown, the present invention is divided into a plurality of modules including a vertex attribute buffer (VAB) , a transform module , a lighting module , and a rasterization module  with a set-up module . In one embodiment, each of the foregoing modules is situated on a single semiconductor platform in a manner that will be described hereinafter in greater detail. In the present description, the single semiconductor platform may refer to a sole unitary semiconductor-based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi-chip modules with increased connectivity which simulate on-chip operation, and make substantial improvements over utilizing a conventional CPU and bus implementation.","During operation, the VAB  is included for gathering and maintaining a plurality of vertex attribute states such as position, normal, colors, texture coordinates, etc. Completed vertices are processed by the transform module  and then sent to the lighting module . The transform module  generates vectors for the lighting module  to light. The output of the lighting module  is screen space data suitable for the set-up module which, in turn, sets up primitives. Thereafter, rasterization module  carries out rasterization of the primitives. It should be noted that the transform and lighting modules  and  might only stall on the command level such that a command is always finished once started. Further information regarding the foregoing components will be set forth hereinafter in greater detail.","With the foregoing integration, improved performance is achieved thus overcoming many of the shortcomings of non-integrated systems. Applications may take advantage of the various hardware features of the present invention by invoking such features via a standard interface.","Such an interface may give developers a single set of APIs (application programming interfaces) that provides such developers with improved access to the features of the hardware set forth herein. This may be accomplished by the use of a hardware abstraction layer that uses software drivers to communicate between application software and the various hardware features set forth in the present description. As a result, developers can write a single version of a product that utilizes the interface without worrying about the specifics of the various hardware features of the present invention.","The interface may further provide developers with tools that take advantage of the various hardware features set forth in the present description. It may automatically determine the hardware capabilities, and set the parameters of the application to match. Still yet, the interface may contain a library of components that developers can draw on to create the underlying elements of an application. This library simplifies the development process by giving programmers a large group of pre-existing interfaces and elements to use in their products.","The components that make up the interface thus provide a flexible platform that is designed to get the most out of advances in technology. An example of such components includes special drivers that can be generated in association with the hardware of the present invention, and which ensure that one gets the most out of the advances set forth herein. A further example includes an antialiasing feature, or any other type of enhancement to graphics processing.","As such, a standardized programming interface is provided for application developers to interface with the various hardware features set forth in the present description. Further, a method is thereby provided to expose the functionality of the hardware to application developers in a standardized way. Such standardized programming interface may provide a more unified and readily supportable way for making applications and hardware work together. One example of an interface with features similar to those set forth hereinabove includes Microsoft\u00ae Direct X\u00ae.","In one embodiment, the present invention includes a hardware implementation that at least partially employs Open Graphics Library (OpenGL\u00ae) and D3D\u2122 transform and lighting pipelines. OpenGL\u00ae is the computer industry's standard application program interface (API) for defining 2-D and 3-D graphic images. With OpenGL\u00ae, an application can create the same effects in any operating system using any OpenGL\u00ae-adhering graphics adapter. OpenGL\u00ae specifies a set of commands or immediately executed functions. Each command directs a drawing action or causes special effects.","The various features associated with the modules shown in  will now be set forth.  is a schematic diagram of VAB  in accordance with one embodiment of the present invention. As shown, VAB  passes command bits  while storing data bits  representative of attributes of a vertex and mode bits . In use VAB  receives the data bits  of vertices and drains the same.","The VAB  is adapted for receiving and storing a plurality of possible vertex attribute states via the data bits . In use after such data bits , or vertex data, is received and stored in VAB , the vertex data is outputted from VAB  to a graphics-processing module, namely the transform module . Further, the command bits  are passed by VAB  for determining a manner in which the vertex data is inputted to VAB  in addition to other processing which will be described in greater detail with reference to . Such command bits  are received from a command bit source such as a microcontroller, CPU, data source or any other type of source which is capable of generating command bits .","Further, mode bits  are passed which are indicative of the status of a plurality of modes of process operations. As such, mode bits  are adapted for determining a manner in which the vertex data is processed in the subsequent graphics-processing modules. Such mode bits  are received from a command bit source such as a microcontroller, CPU, data source or any other type of source which is capable of generating mode bits .","It should be noted that the various functions associated with VAB  may be governed by way of dedicated hardware, software or any other type of logic. In various embodiments, 64, 128, 256 or any other number of mode bits  may be employed.","The VAB  also functions as a gathering point for the 64 bit data that needs to be converted into a 128-bit format. The VAB  input is 64 bits\/cycle and the output is 128 bits\/cycle. In other embodiments, VAB  may function as a gathering point for 128-bit data, and VAB  input may be 128 bits\/cycle or any other combination. The VAB  further has reserved slots for a plurality of vertex attributes that are all IEEE 32 bit floats. The number of such slots may vary per the desires of the user. Table 1 illustrates exemplary vertex attributes employed by the present invention.",{"@attributes":{"id":"p-0094","num":"0093"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Position:","x,y,z,w"]},{"entry":[{},"Diffuse Color:","r,g,b,a"]},{"entry":[{},"Specular Color:","r,g,b"]},{"entry":[{},"Fog:","f"]},{"entry":[{},"Texture0:","s,t,r,q"]},{"entry":[{},"Texture1:","s,t,r,q"]},{"entry":[{},"Normal:","nx,ny,nz"]},{"entry":[{},"Skin Weight:","w"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"During operation, VAB  may operate assuming that the x,y data pair is written before the z,w data pair since this allows for defaulting the z,w pair to (0.0,1.0) at the time of the x,y write. This may be important for default components in OpenGL\u00ae and D3D\u2122. It should be noted that the position, texture0, and texture1 slots default the third and fourth components to (0.0,1.0). Further, the diffuse color slot defaults the fourth component to (1.0) and the texture slots default the second component to (0.0).","The VAB  includes still another slot  used for assembling the data bits  that may be passed into or through the transform and lighting module  and , respectively, without disturbing the data bits . The data bits  in the slot  can be in a floating point or integer format. As mentioned earlier, the data bits  of each vertex has an associated set of mode bits  representative of the modes affecting the processing of the data bits . These mode bits  are passed with the data bits  through the transform and lighting modules  and , respectively, for purposes that will be set forth hereinafter in greater detail.","In one embodiment, there may be 18 valid VAB, transform, and lighting commands received by VAB .  is a chart illustrating the various commands that may be received by VAB  in accordance with one embodiment of the present invention. It should be understood that all load and read context commands, and the passthrough command shown in the chart of  transfer one data word of up to 128 bits or any other size.","Each command of  may contain control information dictating whether each set of data bits  is to be written into a high double word or low double word of one VAB address. In addition, a 2-bit write mask may be employed for providing control to the word level. Further, there may be a launch bit that informs VAB controller that all of the data bits  are present for a current command to be executed.","Each command has an associated stall field that allows a look-up to find information on whether the command is a read command in that it reads context memory or is a write command in that it writes context memory. By using the stall field of currently executing commands, the new command may be either held off in case of conflict or allowed to proceed.","In operation, VAB  can accept one input data word up to 128 bits (or any other size) per cycle and output one data word up to 128 bits (or any other size) per cycle. For the load commands, this means that it may take two cycles to load the data into VAB  to create a 128-bit quad-word and one cycle to drain it. For the scalar memories in the lighting module , it is not necessary to accumulate a full quad-word, and these can be loaded in one cycle\/address. For one vertex, it can take up to 14 cycles to load the 7 VAB slots while it only takes 7 cycles to drain them. It should be noted, however, that it is only necessary to update the vertex state that changes between executing vertex commands. This means that, in one case, the vertex position may be updated taking 2 cycles, while the draining of the vertex data takes 7 cycles. It should be noted that only 1 cycle may be required in the case of the x,y position.",{"@attributes":{"id":"p-0101","num":"0100"},"figref":"FIG. 2B","b":["50","210","50"]},"In use the vertex attributes are stored in VAB  upon the receipt thereof in operation . Further, each set of stored vertex attributes is transferred to a corresponding one of a plurality of input buffers of the transform module . The received set of vertex attributes is also monitored in order to determine whether a received vertex attribute has a corresponding vertex attribute of a different set currently stored in VAB , as indicated in operation .","Upon it being determined that a stored vertex attribute corresponds to the received vertex attribute in decision , the stored vertex attribute is outputted to the corresponding input buffer of the transform module  out of order. See operation . Immediately upon the stored vertex attribute being outputted, the corresponding incoming vertex attribute may take its place in VAB . If no correspondence is found, however, each set of the stored vertex attributes may be transferred to the corresponding input buffer of the transform module  in accordance with a regular predetermined sequence. Note operation .","It should be noted that the stored vertex attribute might not be transferred in the aforementioned manner if it has an associated launch command. Further, in order for the foregoing method to work properly, the bandwidth of an output of VAB  must be at least the bandwidth of an input of VAB .",{"@attributes":{"id":"p-0105","num":"0104"},"figref":["FIG. 2C","FIG. 2B"],"b":["50","230","204","50"]},"Also included is a first multiplexer  having an output coupled to the read address terminal of VAB  and a second clock-controlled buffer . A first input of the first multiplexer  is coupled to the write address terminal of VAB  while a second input of the first multiplexer  is coupled to an output of a second multiplexer . A logic module  is coupled between the first and second multiplexers  and , the write address terminal of VAB , and an output of the second clock-controlled buffer .","In use the logic module  serves to determine whether an incoming vertex attribute is pending to drain in VAB . In one embodiment, this determination may be facilitated by monitoring a bit register that indicates whether a vertex attribute is pending or not. If it is determined that the incoming vertex attribute does have a match currently in VAB , the logic module  controls the first multiplexer  in order to drain the matching vertex attribute so that the incoming vertex attribute may be immediately stored in its place. On the other hand, if it is determined that the incoming vertex attribute does not have a match currently in VAB , the logic module  controls the first multiplexer  such that VAB  is drained and the incoming vertex attribute is loaded sequentially or in some other predetermined order, per the input of the second multiplexer  which may be updated by the logic module .","As a result, there is no requirement for VAB  to drain multiple vertex attributes before a new incoming vertex attribute may be loaded. The pending vertex attribute forces out the corresponding VAB counterpart if possible, thus allowing it to proceed. As a result, VAB  can drain in an arbitrary order. Without this capability, it would take 7 cycles to drain VAB  and possibly 14 more cycles to load it. By overlapping the loading and draining, higher performance is achieved. It should be noted that this is only possible if an input buffer is empty and VAB  can drain into input buffers of the transform module .",{"@attributes":{"id":"p-0109","num":"0108"},"figref":"FIG. 3","b":["50","202","202","52","54","202","202"]},"In one embodiment, the active light bits (LIS) of  may be contiguous. Further, the pass-through bit (VPAS) is unique in that when it is turned on, the vertex data is passed through with scale and bias, and no transforms or lighting is done. Possible mode bits  used when VPAS is true are the texture divide bits (TDV0,1), and foggen bits (used to extract fog value in D3D\u2122). VPAS is thus used for pre-transformed data, and TDV0,1 are used to deal with a cylindrical wrap mode in the context of D3D\u2122.",{"@attributes":{"id":"p-0111","num":"0110"},"figref":"FIG. 4","b":["52","50","400","400","400","400","50"]},"In one embodiment, a bit might be designated for each attribute of each input buffer  to indicate whether data has changed since the previous instance that the input buffer  was loaded. By this design, each input buffer  might be loaded only with changed data.","The transform module  is further connected to 6 output vertex buffers  in the lighting module . The output buffers include a first buffer , a second buffer , and a third buffer . As will become apparent hereinafter, the contents, i.e. position, texture coordinate data, etc., of the third buffer  are not used in the lighting module . The first buffer  and second buffer  are both, however, used for inputting lighting and color data to the lighting module . Two buffers are employed since the lighting module is adapted to handle two read inputs. It should be noted that the data might be arranged so as to avoid any problems with read conflicts, etc.","Further coupled to the transform module  is context memory  and micro-code ROM memory . The transform module  serves to convert object space vertex data into screen space, and to generate any vectors required by the lighting module . The transform module  also does processes skinning and texture coordinates. In one embodiment, the transform module  might be a 128-bit design processing 4 floats in parallel, and might be optimized for doing 4 term dot products.",{"@attributes":{"id":"p-0115","num":"0114"},"figref":"FIG. 4A","b":["52","52","410","202"]},"As shown in , the method of executing multiple threads includes determining a current thread to be executed in operation . This determination might be made by identifying a number of cycles that a graphics-processing module requires for completion of an operation, and tracking the cycles. By tracking the cycles, each thread can be assigned to a cycle, thus allowing determination of the current thread based on the current cycle. It should be noted, however, that such determination might be made in any desired manner that is deemed effective.","Next, in operation , an instruction associated with a thread to be executed during a current cycle is retrieved using a corresponding program counter number. Thereafter, the instruction is executed on the graphics-processing module in operation .","In one example of use, the instant method includes first accessing a first instruction, or code segment, per a first program counter. As mentioned earlier, such program counter is associated with a first execution thread. Next, the first code segment is executed in the graphics-processing module. As will soon become apparent, such graphics-processing module might take the form of an adder, a multiplier, or any other functional unit or combination thereof.","Since the graphics-processing module requires more than one clock cycle to complete the execution, a second code segment might be accessed per a second program counter immediately one clock cycle after the execution of the first code segment. The second program counter is associated with a second execution thread, wherein each of the execution threads process a unique vertex.","To this end, the second code segment might begin execution in the graphics-processing module prior to the completion of the execution of the first code segment in the graphics-processing module. In use the graphics-processing module requires a predetermined number of cycles for every thread to generate an output. Thus, the various steps of the present example might be repeated for every predetermined number of cycles.","This technique offers numerous advantages over the prior art. Of course, the functional units of the present invention are used more efficiently. Further, the governing code might be written more efficiently when the multiple threading scheme is assumed to be used.","For example, in the case where the graphics-processing module includes a multiplier that requires three clock cycles to output an answer, it would be necessary to include two no operation commands between subsequent operations such as a=b*c and d=e*a, since \u201ca\u201d would not be available until after the three clock cycles. In the present embodiment, however, the code might simply call d=e*a immediately subsequent a=b*c, because it can be assumed that such code will be executed as one of three execution threads that are called once every three clock cycles.",{"@attributes":{"id":"p-0123","num":"0122"},"figref":["FIG. 4B","FIG. 4A"],"b":["450","452","456","454","459"]},"In order to accommodate a situation where at least two of the foregoing processing modules are used in tandem, at least one code segment delay  is employed between the graphics-processing modules. In the case where a three-thread framework is employed, a three-clock cycle code segment delay  is used. In one embodiment, the code segment delay  is used when a multiplication instruction is followed by an addition instruction. In such case, the addition instruction is not executed until three clock cycles after the execution of the multiplication instruction in order to ensure that time has elapsed which is sufficient for the multiplier  to generate an output.","After the execution of each instruction, the program counter  of the current execution thread is updated and the program counter of the next execution thread is called by module  in a round robin sequence to access an associated instruction. It should be noted that the program counters might be used in any fashion including, but not limited to incrementing, jumping, calling and returning, performing a table jump, and\/or dispatching. Dispatching refers to determining a starting point of code segment execution based on a received parameter. Further, it important to understand that the principles associated with the present multiple thread execution framework might also be applied to the lighting module  of the graphics-processing pipeline of the present invention.","In the case where a three-thread framework is employed, each thread is allocated one input buffer and one output buffer at any one time. This allows loading of three more commands with data while processing three commands. The input buffers and output buffers are assigned in a round robin sequence in a manner that will be discussed later with reference to .","The execution threads are thus temporally and functionally interleaved. This means that each function unit is pipelined into three stages and each thread occupies one stage at any one time. In one embodiment, the three-threads might be set to always execute in the same sequence, i.e. zero then one then three. Conceptually, the threads enter a function unit at t=clock modulo three. Once a function unit starts work, it takes three cycles to deliver the result (except the ILU that takes six), at which time the same thread is again active.",{"@attributes":{"id":"p-0128","num":"0127"},"figref":["FIG. 5","FIG. 4"],"b":["52","400","50"]},"A memory logic unit (MLU)  has a first input coupled to an output of input buffers . As an option, the output of MLU  might have a feedback loop  coupled to the first input thereof.","Also provided is an arithmetic logic unit (ALU)  having a first input coupled to an output of MLU . The output of ALU  further has a feedback loop  connected to the second input thereof. Such feedback loop  may further have a delay  coupled thereto. Coupled to an output of ALU  is an input of a register unit . It should be noted that the output of register unit  is coupled to the first and second inputs of MLU .","An inverse logic unit (ILU)  is provided including an input coupled to the output of ALU  for performing an inverse or an inverse square root operation. In an alternate embodiment, ILU  might include an input coupled to the output of register unit .","Further included is a conversion, or smearing, module  coupled between an output of ILU  and a second input of MLU . In use the conversion module  serves to convert scalar vertex data to vector vertex data. This is accomplished by multiplying the scalar data by a vector so that the vector operators such as the multiplier and\/or adder may process it. For example, a scalar A, after conversion, may become a vector (A,A,A,A). In an alternate embodiment, the smearing module  might be incorporated into the multiplexers associated with MLU , or any other component of the present invention. As an option, a register  might be coupled between the output of ILU  and an input of the conversion unit . Further, such register  might be threaded.","Memory  is coupled to the second input of MLU  and the output of ALU . In particular, memory  has a read terminal coupled to the second input of MLU . Further, memory  has a write terminal coupled to the output of ALU .","The memory  has stored therein a plurality of constants and variables for being used in conjunction with the input buffer , MLU , ALU , register unit , ILU , and the conversion module  for processing the vertex data. Such processing might include transforming object space vertex data into screen space vertex data, generating vectors, etc.","Finally, an output converter  is coupled to the output of ALU . The output converter  serves for being coupled to a lighting module  via output buffers  to output the processed vertex data thereto. All data paths except for the ILU might be designed to be 128 bits wide or other data path widths may be used.",{"@attributes":{"id":"p-0136","num":"0135"},"figref":["FIG. 6","FIG. 5"],"b":["500","52","500","52","600"]},"MLU  of transform module  is capable of multiplying two four component vectors in three different ways, or pass one four component vector. MLU  is capable of performing multiple operations. Table 2 illustrates such operations associated with MLU  of transform module .",{"@attributes":{"id":"p-0138","num":"0137"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CMLUMULT","o[0] = a[0]*b[0], o[1] = a[1]*b[1], o[2] = a[2]*b[2],"]},{"entry":[{},"o[3] = a[3]*b[3]"]},{"entry":["CMLUMULA","o[0] = a[0]*b[0], o[1] = a[1]*b[1], o[2] = a[2]*b[2],"]},{"entry":[{},"o[3] = a[3]"]},{"entry":["CMLUMULB","o[0] = a[0]*b[0], o[1] = a[1]*b[1], o[2] = a[2]*b[2],"]},{"entry":[{},"o[3] = b[3]"]},{"entry":["CMLUPASA","o[0] = a[0], o[1] = a[1], o[2] = a[2], o[3] = a[3]"]},{"entry":["CMLUPASB","o[0] = b[0], o[1] = b[1], o[2] = b[2], o[3] = b[3]"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Possible A and B inputs are shown in Table 3.",{"@attributes":{"id":"p-0140","num":"0139"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"MAM","MLU"]},{"entry":[{},"MAV","Input Buffer"]},{"entry":[{},"MAR","RLU (shared with MBR)"]},{"entry":[{},"MBI","ILU"]},{"entry":[{},"MBC","Context Memory"]},{"entry":[{},"MBR","RLU (shared with MAR)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Table 4 illustrates a vector rotate option capable of being used for cross products.",{"@attributes":{"id":"p-0142","num":"0141"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 4"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"MRNONE","No change"]},{"entry":[{},"MRALBR","Rotate A[XYZ] vector left, B[XYZ] vector right"]},{"entry":[{},"MRARBL","Rotate A[XYZ] vector right, B[XYZ] vector left"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0143","num":"0142"},"figref":["FIG. 7","FIG. 5"],"b":["504","52","504","52","700","504","52","504","52"]},{"@attributes":{"id":"p-0144","num":"0143"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CALUADDA","o[0] = a[0] + b[0], o[1] = a[1] + b[1] , o[2] ="]},{"entry":[{},"a[2] + b[2], [o3] = a[3]"]},{"entry":["CALUADDB","o[0] = a[0] + b[0], o[1] = a[1] + b[1] , o[2] ="]},{"entry":[{},"a[2] + b[2], o[3] = b[3]"]},{"entry":["CALUSUM3B","o[0123] = b[0] + b[1] + b[2]"]},{"entry":["CALUSUM4B","o[0123] = b[0] + b[1] + b[2] + [3]"]},{"entry":["CALUSMRB0","o[0123] = b[0]"]},{"entry":["CALUSMRB1","o[0123] = b[1]"]},{"entry":["CALUSMRB2","o[0123] = b[2]"]},{"entry":["CALUSMRB3","o[0123] = b[3]"]},{"entry":["CALUPASA","o[0] = a[0], o[1] = a[1], o[2] = a[2], o[3] = a[3]"]},{"entry":["CALUPASB","o[0] = b[0], o[1] = b[1], o[2] = b[2], o[3] = b[3]"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Table 6 illustrates the A and B inputs of ALU  of transform module .",{"@attributes":{"id":"p-0146","num":"0145"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 6"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"AAA","ALU (one instruction delay)"]},{"entry":[{},"AAC","Context Memory"]},{"entry":[{},"ABM","MLU"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"It is also possible to modify the sign bits of the A and B input by effecting no change, negation of B, negation of A, absolute value A,B. It should be noted that when ALU  outputs scalar vertex data, this scalar vertex data is smeared across the output in the sense that each output represents the scalar vertex data. The pass control signals of MLU  and ALU  are each capable of disabling all special value handling during operation.",{"@attributes":{"id":"p-0148","num":"0147"},"figref":["FIG. 8","FIG. 5"],"b":["510","52","510","800","802","802"]},"In one embodiment of the present invention, the vector register file  is threaded. That is, there are three copies of the vector register file  and each thread has its own copy. In one embodiment, each copy contains eight registers, each of which might be 128 bits in size and store four floats. The vector register file  is written from ALU  and the output is fed back to MLU . The vector register file  has one write and one read per cycle.","In operation, it is also possible to individually mask a write operation to each register component. The vector register file  exhibits zero latency when the write address is the same as the read address due to a bypass path  from the input to the output. In this case, unmasked components would be taken from the registers and masked components would be bypassed. The vector register file  is thus very useful for building up vectors component by component, or for changing the order of vector components in conjunction with the ALU SMR operations (See Table 5). Temporary results might be also stored in the vector register file .",{"@attributes":{"id":"p-0151","num":"0150"},"figref":["FIG. 9","FIG. 5"],"b":["512","52","512","52"]},{"@attributes":{"id":"p-0152","num":"0151"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Reciprocal (1\/D)","Reciprocal Square-root (1\/DA (\u00bd))"]},{"entry":[{},"x+ 1 = x(2 \u2212 x*D)","x= (\u00bd)*x(3 \u2212 x*D)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1)","table look up for x(seed)","table look up for x, (seed)"]},{"entry":[{},"x","x*x"]},{"entry":["2)","1iteration: multiply-add","1iteration: multiply-add"]},{"entry":[{},"2 \u2212 x*D","3 \u2212 x*D"]},{"entry":["3)","1iteration: multiply","1iteration: multiply"]},{"entry":[{},"x(2 \u2212 x*D)","(1\/2)*x(3 \u2212 x*D)"]},{"entry":["4)","2iteration: no-op","2iteration: square"]},{"entry":[{},"pass x+ 1","x"]},{"entry":["5)","2iteration multiply-add","2iteration: multiply-add"]},{"entry":[{},"2 \u2212 x*D","3 \u2212 x*D"]},{"entry":["6)","2iteration: multiply","2iteration: multiply"]},{"entry":[{},"x(2 \u2212 x*D)","(\u00bd)*x(3 \u2212 x*D)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"As shown, the two processes are similar, affording a straightforward design. It should be noted that the iterations might be repeated until a threshold precision is met.","In operation, ILU  performs two basic operations including an inverse operation and inverse square root operation. Unlike the other units, it requires six cycles to generate the output. The input is a scalar, and so is the output. As set forth earlier, the threaded holding register  at ILU  output is relied upon to latch the result until the next time a valid result is generated. Further, the scalar output is smeared into a vector before being fed into MLU . The inverse unit  uses look-up tables and a two pass Newton-Raphson iteration to generate IEEE (Institute of Electrical and Electronics Engineers) outputs accurate to within about 22 mantissa bits. Table 7 illustrates the various operations that might be performed by ILU  of transform module .",{"@attributes":{"id":"p-0155","num":"0154"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 7"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CILU INV","o = 1.0\/a"]},{"entry":[{},"CILU ISQ","o = 1.0\/sqrt(a)"]},{"entry":[{},"CILU CINV","o = 1.0\/a (with range clamp)"]},{"entry":[{},"CILU NOP","no output"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The foregoing range clamp inversion operation of Table 7 might be used to allow clipping operations to be handled by rasterization module . Coordinates are transformed directly into screen space that can result in problems when the homogeneous clip space w is near 0.0. To avoid multiplying by 1.0\/0.0 in the perspective divide, the 1\/w calculation is clamped to a minimum and a maximum exponent.","In use the context memory  as shown in  reads and writes only using quad-words. The memory can be read by MLU  or ALU  each cycle, and can be written by ALU . Only one memory read is allowed per cycle. If a read is necessary, it is done at the start of an instruction and then pipelined down to ALU  three cycles later. Context memory  need not necessarily be threaded.",{"@attributes":{"id":"p-0158","num":"0157"},"figref":["FIG. 10","FIG. 5","FIG. 4"],"b":["518","52","518","54","402","54"]},"Data swizzling is useful when generating vectors. Such technique allows the generation of a distance vector (1,d,d*d) without penalty when producing a vector. The distance vector is used for fog, point parameter and light attenuation. This is done with an eye vector and light direction vectors. Table 8 illustrates the various operations associated with such vectors. It should be noted that, in the following table, squaring the vector refers to d=dot[(x,y,z), (x,y,z)], and storing din the w component of (x,y,z).",{"@attributes":{"id":"p-0160","num":"0159"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","Square the vector","(x,y,z,d*d) (output d*d to"]},{"entry":[{},{},"VBUF, 1.0 to VBUF)"]},{"entry":["2.","Generate inverse sqrt of"]},{"entry":[{},"d*d (1\/d)"]},{"entry":["3.","Normalize vector","(x\/d,y\/d,z\/d,d) (output x\/d,y\/d,z\/d to"]},{"entry":[{},{},"WBUF, d to VBUF)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"It should be noted that the math carried out in the present invention might not always be IEEE compliant. For example, it might be assumed that \u201c0\u201d multiplied by any number renders \u201c0.\u201d This is particularly beneficial when dealing with the equations such as d=d*1\/(d), where d=0. Without making the foregoing assumption, such equation would afford an error, thus causing problems in making related computations.",{"@attributes":{"id":"p-0162","num":"0161"},"figref":["FIG. 11","FIG. 5"],"b":["52","500"]},{"@attributes":{"id":"p-0163","num":"0162"},"figref":["FIG. 12","FIG. 5","FIG. 12"],"b":["1200","52","1200","52","1202","50"]},"Also included is memory  capable of storing code segments that each are adapted to carry out the process operations in accordance with the status of the modes. A sequencing module  is coupled between memory  and a control vector module  which is in turn coupled to buffer  for identifying a plurality of addresses in memory  based on a control vector derived from mode bits . The sequencing module  is further adapted for accessing the addresses in memory  for retrieving the code segments that might be used to operate transform module  to transfer data to an output buffer .",{"@attributes":{"id":"p-0165","num":"0164"},"figref":["FIG. 13","FIG. 12"],"b":["1200","52","1200","1320","202","202"]},"Then, in operation , pluralities of addresses are then identified in memory based on mode bits . Such addresses are then accessed in the memory in operation  for retrieving code segments that each are adapted to carry out the process operations in accordance with the status of the modes. The code segments are subsequently executed with a transform or lighting module for processing vertex data. Note operation .",{"@attributes":{"id":"p-0167","num":"0166"},"figref":["FIG. 14","FIG. 12","FIGS. 4A and 4B"],"b":["1206","1200","52","1430","202","1430"]},"Once the current execution thread is selected, a corresponding group of mode bits  are decoded in operation . Upon mode bits  being decoded in operation , a control vector is afforded which includes a plurality of bits each of which indicate whether a particular code segment is to be accessed in ROM  for processing the corresponding vertex data.","Upon determining whether a code segment should be accessed in ROM  and executed, a pointer operation  increments the current thread pointer to start the next execution thread to obtain a second group mode bits  to continue a similar operation. This might be continued for each of the threads in a round robin sequence.","Once the control vector has been formed for a particular group of mode bits , a priority encoder operation  determines, or identifies, a next \u201c1\u201d or enabled, bit of the control vector. If such a bit is found, the priority encoder operation  produces an address in ROM  corresponding to the enabled bit of the control vector for execution purposes.","Upon returning to the initial group of mode bits  after handling the remaining threads, and after the mode bits have been decoded and the control vector is again available, a masking operation  might be used to mask the previous \u201c1\u201d, or enabled, bit that was identified earlier. This allows analysis of all remaining bits after mask operation .","The foregoing process might be illustrated using the following tables. Table 9 shows a plurality of equations that might be executed on subject vertex data.",{"@attributes":{"id":"p-0173","num":"0172"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 9"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"R =\u2003\u2003(a \u2003\u2003\u2003\u2003)"]},{"entry":[{},"R =\u2003\u2003(a +\u2003\u2003d*e \u2003\u2003)"]},{"entry":[{},"R =\u2003\u2003(a + b*c +\u2003\u2003f)"]},{"entry":[{},"R =\u2003\u2003(a + b*c + d*e \u2003\u2003)"]},{"entry":[{},"R = 1.0\/(a \u2003\u2003\u2003\u2003)"]},{"entry":[{},"R = 1.0\/(a +\u2003\u2003d*e \u2003\u2003)"]},{"entry":[{},"R = 1.0\/(a + b*c +\u2003\u2003f)"]},{"entry":[{},"R = 1.0\/(a + b*c + d*e \u2003\u2003)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As shown, there are four possibilities of products that might be summed in addition to an inverse operation (a, b*c, d*e, f, and 1\/x). Next, mode fields might be defined. Table 10 illustrates a pair of mode fields, mode.y and mode.z, each having assigned thereto a predetermined set of the operations of Table 9.",{"@attributes":{"id":"p-0175","num":"0174"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 10"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"mode.y[4]","0: R = a"]},{"entry":[{},{},"1: R = a + d*e"]},{"entry":[{},{},"2: R = a + b*c + f"]},{"entry":[{},{},"3: R = a + b*c + d*e"]},{"entry":[{},"mode.z[2]","0: R = R"]},{"entry":[{},{},"1: R = 1.0\/R"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Thereafter, each of the operations might be positioned in memory with an associated address. Table 11 illustrates a plurality of memory addresses each having an associated operation. Also shown is a set of control vector definitions.",{"@attributes":{"id":"p-0177","num":"0176"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ROM[0]: R = a"]},{"entry":[{},"ROM[1]: R = R + b*c"]},{"entry":[{},"ROM[2]: R = R + d*e"]},{"entry":[{},"ROM[3]: R = R + f"]},{"entry":[{},"ROM[4]: R = 1.0\/R"]},{"entry":[{},"cv[0] = 1;"]},{"entry":[{},"cv[1] = (mode.y==2 \u2225 mode.y==3) ? 1 : 0;"]},{"entry":[{},"cv[2] = (mode.y==1 \u2225 mode.y==3) ? 1 : 0;"]},{"entry":[{},"cv[3] = (mode.y==2) ? 1 : 0;"]},{"entry":[{},"cv[4] = (mode.z==1) ? 1 : 0;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Table 12 illustrates the execution of an example.",{"@attributes":{"id":"p-0179","num":"0178"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 12"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"R = a + d*e corresponds to:"]},{"entry":[{},"\u2003\u2003\u2003mode.y = 1;"]},{"entry":[{},"\u2003\u2003\u2003mode.z = 0;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["which in turn affords the following control vector:\n        \n        ","execution","first cycle:\n        \n        ","second cycle:\n        \n        "]}}}},"As such, sequencer  of transform module  steps through a threaded control vector which is derived from threaded mode bits , and executes every ROM address whose corresponding control vector bit is set to \u201cTRUE\u201d. The control vector has the same length as the ROM. The sequencer  is capable of stepping through an arbitrary control vector at the rate of one \u201c1\u201d, or enabled bit per a predetermined number of cycles. Commands that do not use mode bits  might be executed by on-the-fly micro-code generation due to the simplicity thereof.","By representing such statuses by way of a unique string of mode bits , it is unnecessary to execute a plurality of if-then clauses in the graphics-processing hardware to determine the statuses of the various operations. Improved performance is thereby afforded. Conceptually, it is as if the if clauses in a program language had been moved to sequencer  which in turn instantly skips instructions with a \u201cFALSE\u201d condition, as indicated by mode bits .","As indicated earlier, code segments are stored in the ROM which are capable of handling the various statuses of the operations identified by the mode bits. In one embodiment a separate code segment might be retrieved for handling each operation indicated by the mode bits. In the alternative, a single comprehensive code segment might be written for handling each or some combinations of operations that are possible. It should be noted, however, that generating such large code segments for each combination of operations requires additional code space, and it therefore might be beneficial to modularize the code segments for only commonly used combinations of operations.","Since mode bits  do not change once the vertex commences execution, the control vector generation might only have to be done once per vertex before entering the sequencer. Exceptions to this might arise in some cases, however, such as lighting where operations might be repeated. When the last vertex instruction is found, an end of sequence (EOS) signal might be asserted. This in turn might be used to change the status of the input and output buffers, and to allow the start of the next command in a manner that will be set forth during reference to . It should be noted that the EOS signal is pipeline delayed for release of the destination buffer similar to the manner in which the instructions are handled. See .",{"@attributes":{"id":"p-0184","num":"0196"},"figref":"FIG. 14A","b":["1440","1442"]},"In yet another functional aspect , vector vertex data is masked, thereby converted to scalar vertex data, after which it is stored in memory, i.e. register logic unit, for the purpose of generating vector vertex data. In still yet another functional aspect , scalar vertex data is extracted by a vector processing module, i.e. adder, multiplier, etc., which in turn is processed by a scalar processing module, i.e. inverse logic unit, which renders scalar vertex data. This scalar vertex data is converted again into vector vertex data.",{"@attributes":{"id":"p-0186","num":"0198"},"figref":["FIG. 14B","FIG. 14A","FIG. 5","FIG. 4B","FIG. 14C","FIG. 14A"],"b":["1451","52","1444","1446","1453"]},"Multiplexers might accomplish the extraction of the scalar vertex data from the vector vertex data in the functional modules of . Such multiplexers might also be responsible for any data swizzling that might be required before processing by the various functional modules. In one embodiment, the multiplexers might be capable of passing and rotating vector vertex data, and rely on other graphics-processing modules such as an ALU for other processing. In yet another embodiment, the multiplexers might be capable of arbitrarily rearranging attributes independently without penalty.",{"@attributes":{"id":"p-0188","num":"0200"},"figref":"FIG. 14D","b":"1470"},"Subsequently, in operation , a sum of a plurality of products is then calculated with each product being calculated by the multiplication of the vertex data, one of the matrices and the weight corresponding to the matrix. Such sum of products is then outputted in operation  for additional processing.","In summary, the following sum of products might be calculated:\n\nfor 1 \u2003\u2003Equation #1\n\n","It should be noted that there are many ways to represent the weights wset forth hereinabove. For example, in Equations #1 and #2 above, it might be said that i=1 . . . (x\u22121), leaving w(wwhere i=x) to be calculated by the equation 1\u2212\u03a3w. By representing the weights win this way, it is ensured that all of the weights w sum to 1.","In one embodiment, the matrices might include model view matrices (M), and the sum of products (v\u2032) might be outputted for additional processing by a lighting operation. See Equation #1. This sum of products (v\u2032) might also be used to generate another sum of products (v) for display purposes by using a composite matrix (C). See Equation #3. Still yet, the matrices might include inverse matrices (I) and the vertex data might include normal vector data (n). In such case, the additional processing might include a lighting operation. See Equation #2.",{"@attributes":{"id":"p-0193","num":"0222"},"figref":"FIG. 15","b":["54","54","402","52","408","54","1501","54","1500","1502"]},"The lighting module  is adapted for handling lighting in addition to fog and point parameters. In use lighting module  controls the buffer bypass pathway , and calculates the diffuse, point size, and specular output colors as well as the fog value. It should be noted that lighting module  employs the same mode bits  as transform module .","The lighting module  further requires less precision with respect to transform module , and therefore processes 22 bit floating point values (1.8.13 format) organized in tri-words. Since the data of third buffer  is 128 bits, it utilizes bypass pathway  around lighting module . The lighting module  is event driven and simultaneously executes three threads in a manner similar to transform module  as was set forth earlier with reference to . It should be noted that lighting module  might require command launch approval from an outside source.",{"@attributes":{"id":"p-0196","num":"0225"},"figref":["FIG. 16","FIG. 15"],"b":["54","402","402","404","406","408","404","406","408","52","408","54","1608"]},"Further included is a MLU  having a first input coupled to an output of first input buffer  and a second input coupled to an output of second input buffer . The output of MLU  has a feedback loop  coupled to the second input thereof. An arithmetic logic unit (ALU)  has a first input coupled to an output of second input buffer . ALU  further has a second input coupled to an output of MLU . An output of ALU  is coupled to the output of lighting module . It should be noted that the output of ALU  and the output of the third input buffer  are coupled to the output of lighting module  by way of multiplexer .","Next provided is a first register unit  having an input coupled to the output of ALU  and an output coupled to the first input of ALU . A second register unit  has an input coupled to the output of ALU . Also, such second register  has an output coupled to the first input and the second input of MLU .","A lighting logic unit (LLU)  is also provided having a first input coupled to the output of ALU , a second input coupled to the output of the first input buffer , and an output coupled to the first input of MLU . It should be noted that the second input of LLU  is coupled to the output of the first input buffer  via a delay . Further, the output of LLU  is coupled to the first input of MLU  via a first-in first-out register unit . As shown in , the output of LLU  is also coupled to the first input of MLU  via a conversion module . In operation, such conversion module  is adapted for converting scalar vertex data to vector vertex data in a manner similar to that of transform module .","Finally, memory  is coupled to at least one of the inputs of MLU  and the output of arithmetic logic unit . In particular, memory  has a read terminal coupled to the first and the second input of MLU . Further, memory  has a write terminal coupled to the output of ALU .","The memory has stored therein a plurality of constants and variables for being used in conjunction with input buffers , MLU , ALU , first register unit , second register unit , and LLU  for processing the vertex data.",{"@attributes":{"id":"p-0202","num":"0231"},"figref":["FIG. 17","FIG. 16"],"b":["1610","54","1610","54","1700","1610","1610","54"]},{"@attributes":{"id":"p-0203","num":"0232"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ZMLUMULT","o[0] = a[0]*b[0], o[1] = a[1]*b[1], o[2] = a[2]*b[2]"]},{"entry":["ZMLUPASA","o[0] = a[0], o[1] = a[1], o[2] = a[2]"]},{"entry":["ZMLUPASB","o[0] = b[0], o[1] = b[1], o[2] = b[2]"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Table 14 illustrates the possible A and B inputs of MLU  of lighting module .",{"@attributes":{"id":"p-0205","num":"0234"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 14"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"MAV","VBUFFER"]},{"entry":[{},"MAL","LLU"]},{"entry":[{},"MAR","RLU[2,3] (shared with MBR)"]},{"entry":[{},"MAC","Context memory (shared with MBC)"]},{"entry":[{},"MBM","MLU"]},{"entry":[{},"MBW","WBUFFER"]},{"entry":[{},"MBR","RLU[2,3] (shared with MAR)"]},{"entry":[{},"MBC","Context memory (shared with MAC)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0206","num":"0235"},"figref":["FIG. 18","FIG. 16"],"b":["1614","54","1614","1800","1614","1614","54"]},{"@attributes":{"id":"p-0207","num":"0236"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 15"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ZALUADD","o[0] = a[0] + b[0], o[1] = a[1] + b[1], o[2] ="]},{"entry":[{},"a[2] + b[2]"]},{"entry":["ZALUSUM3B","o[012] = b[0] + b[1] + b[2]"]},{"entry":["ZALUPASA","o[0] = a[0], o[1] = a[1], o[2] = a[2]"]},{"entry":["ZALUPASB","o[0] = b[0], o[1] = b[1], o[2] = b[2]"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Table 16 illustrates the possible A and B inputs to ALU  of lighting module .",{"@attributes":{"id":"p-0209","num":"0238"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 16"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"AAW","WBUFFER"]},{"entry":[{},"AAR","RLU[0,1]"]},{"entry":[{},"ABM","MLU"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0210","num":"0239"},"figref":["FIG. 19","FIG. 16"],"b":["1618","1620","54","1618","1620","1900","1902","1902"]},"Register units  and  of lighting module  are split into two registers for ALU  and two registers for MLU . In one embodiment, the registers are threaded. The register units  and  exhibit zero latency when a write address is the same as a read address due to a bypass path from the input to the outputs.",{"@attributes":{"id":"p-0212","num":"0241"},"figref":["FIG. 20","FIG. 16"],"b":["1622","54","1622","54","1622"]},"The flag register is used to implement the conditional parts of the lighting equations. The outputs are an ambient, diffuse, and specular coefficient. The scalar memories contain variables used for the specular approximations and constants. The first location of each memory contains 1.0 (for ctx0 and ctx2) and 0.0 (for ctx1 and ctx3). In one embodiment, these are hardwired and do not need to be loaded.","In use LLU  fundamentally implements the equation: (x+L)\/(M*x+N). This equation is used to approximate a specular lighting term. The inputs to LLU  are from ALU  of lighting module  and are the dot products used in the lighting equations. As set forth earlier, with respect to , there is an output FIFO  between LLU  and MLU  which buffers coefficients until MLU  needs them. In one embodiment, such FIFO  might be threaded along with delays  and , and registers  and . Due to possible color material processing, it is unknown when the diffuse and specular outputs are consumed by MLU .","There is specially adapted hardware for dealing with the diffuse output alpha component since lighting module  only deals with R,G,B components. Such specially adapted hardware is capable of outputting two types of alpha components, namely vtx color\u00f8\u03b1[Tbuffer], and stored ctx \u03b1[Ctx store]. The choice between the foregoing alpha components is governed by mode bits .","In operation, LLU  calculates ambient (Ca), diffuse (Cde), and specular (Cs) coefficients of lighting. These coefficients are then multiplied with the ambient, diffuse, and specular colors to generate a light's contribution to the vertex color. Table 16A includes a list of inputs received by LLU  and the calculations carried out to generate the ambient (Ca), diffuse (Cde), and specular (Cs) coefficients of lighting. It should be noted that any desired hardware configuration might be employed to implement LLU . In one embodiment, the specific configuration shown in  might be employed.",{"@attributes":{"id":"p-0217","num":"0246"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 16A"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Input definitions:"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["n = normal vector","(from transform engine)"]},{"entry":["e = normalized eye vector","(from transform engine)"]},{"entry":["l = normalized light vector","(from transform engine)"]},{"entry":["s = spotlight vector*light vector","(from transform engine)"]},{"entry":["D = distance vector \u2003\u2003\u2003(1,d,d*d)","(from transform engine)"]},{"entry":["h = half angle vector","(from lighting engine)"]},{"entry":["K = attenuation constant vector (K0, K1 ,K2)","(from context memory)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"ul":{"@attributes":{"id":"ul0011","list-style":"none"},"li":{"@attributes":{"id":"ul0011-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0012","list-style":"none"},"li":["The LLU might receive the following scalar data in carrying out its calculations:\n        \n        ","Infinite Light","LLU Calculations:\n        \n        ","Local Light","LLU Calculations:\n        \n        ","Spot Light","LLU Calculations:\n        \n        "]}}}},"As set forth above, the mode bits controlling the vertex sequencer might not necessarily be changed by the vertex data itself or by any results derived from vertex data. To allow vertex data to modify vertex processing, LLU  employs a flag register  is provided. Setting bits to TRUE in this flag register allows clamping to 0.0 of calculation results if a flag is specified in the output control of the calculation. Another use of the flag register  would be in setting a write mask for register writes.","The flag register  is provided in LLU  for performing the if\/then\/else clamping to 0.0 in the lighting equations at no performance penalty. The sign bit of various operands might set the flags. Table 16B illustrates the manner in which the flags in flag register  are set and the resulting clamping.",{"@attributes":{"id":"p-0220","num":"0275"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 16B"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Infinite Light"]},{"entry":[{},"LLU Calculations:"]},{"entry":[{},"Dflag = sign bit of (n*l)"]},{"entry":[{},"Sflag = sign bit of (n*h)"]},{"entry":[{},"Clamp:"]},{"entry":[{},"Ca = (0 \u2003\u2003\u2003) ? 0 : Ca;"]},{"entry":[{},"Cd = (Dflag \u2003\u2003) ? 0 : Cd;"]},{"entry":[{},"Cs = (Dflagl | Sflag) ? 0 : Cs;"]},{"entry":[{},"Local Light"]},{"entry":[{},"LLU Calculations:"]},{"entry":[{},"Rflag = sign bit of (range-d)"]},{"entry":[{},"Dflag = sign bit of (n*l)"]},{"entry":[{},"Sflag = sign bit of (n*h)"]},{"entry":[{},"Clamp:"]},{"entry":[{},"Ca = (Rflag \u2003\u2003\u2003\u2003) ? 0 : Ca;"]},{"entry":[{},"Cd = (Rflag | Dflag \u2003\u2003) ? 0 : Cd;"]},{"entry":[{},"Cs = (Rflag | Dflag | Sflag) ? 0 : Cs;"]},{"entry":[{},"Spot Light"]},{"entry":[{},"LLU Calculations:"]},{"entry":[{},"Cflag = sign bit of (s-cutoff)"]},{"entry":[{},"Rflag = sign bit of (range-d)"]},{"entry":[{},"Dflag = sign bit of (n*l)"]},{"entry":[{},"Sflag = sign bit of (n*h)"]},{"entry":[{},"Clamp:"]},{"entry":[{},"Ca = (Cflag | Rflag \u2003\u2003\u2003\u2003) ? 0 : Ca;"]},{"entry":[{},"Cd = (Cflag | Rflag | Dflag \u2003\u2003) ? 0 : Cd;"]},{"entry":[{},"Cs = (Cflag | Rflag | Dflag | Sflag) ? 0 : Cs;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0221","num":"0276"},"figref":["FIG. 21","FIG. 16"],"b":["1623","54","1623"]},"When LLU  outputs a scalar value to MLU  where it gets smeared into a tri-word, it specifies a mask for the flag register. If the register & mask is true, 0.0 replaces the output. Table 17 illustrates the various flags of  to be used in outputting ambient, diffuse, and specular attributes.",{"@attributes":{"id":"p-0223","num":"0278"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 17"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Ambient Mask:","C,R, U"]},{"entry":[{},"Diffuse Mask:","D, C,R, U"]},{"entry":[{},"Specular Mask:","D,S,C,R,T,U"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The approximation used for the specular term can go negative where the actual cos (theta)**n would go to 0.0. As a result, it is necessary to perform a clamping operation. For this, the T, U flags are used. Table 18 illustrates various operations of which a functional logic unit(FLU)  of LLU  is capable. Note .",{"@attributes":{"id":"p-0225","num":"0280"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 18"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ZFLUINV","o = 1\/a \u2003\u2003\u2003\u2003(mantissa accuracy-12 bits)"]},{"entry":[{},"ZFLUISQ","o = 1\/sqrt(a) \u2003(mantissa accuracy-6 bits)"]},{"entry":[{},"ZFLUPASS","o = a"]},{"entry":[{},"ZFLUPASS1","o = 1.0"]},{"entry":[{},"ZFLUMIN1","o = (a < 1.0) ? a : 1.0"]},{"entry":[{},"ZFLUNOP","o = 0.0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0226","num":"0281"},"figref":["FIG. 22","FIG. 16"],"b":["54","54"]},{"@attributes":{"id":"p-0227","num":"0282"},"figref":["FIG. 23","FIG. 16"],"b":["2300","54","2300","54","2302","202","1502"]},"A sequencing module  is coupled between memory  and buffer  for identifying a plurality of addresses in memory  based on a control vector  derived from the mode bits. The sequencing module  is further adapted for accessing the addresses in memory  for retrieving the code segments that might be used to operate lighting module .","The sequencer  of lighting module  is similar to that of transform module . In operation, sequencer  of lighting module  steps through a threaded control vector that is derived from threaded mode bits  and executes every ROM address whose corresponding control vector bit is set to \u201c1\u201d. The control vector has the same number of bits as the ROM has words. The sequencer  can step through an arbitrary control vector at the rate of a single \u201c1\u201d or enabled bit per a predetermined number of cycles for every thread. Commands that do not use mode bits  are executed by on-the-fly micro-code generation. The main difference between sequencer  of lighting module  and sequencer  of transform module  is that sequencer  of lighting module  can loop back and execute the lighting code up to eight times.","The sequencer  of lighting module  has a light counter that starts at zero for each new vertex and increments by one at the end of the micro-code sequence. If the LIS field of mode bits  contains a \u201c1\u201d in the matching bit field, sequencer  goes back and starts over at the beginning of the lighting micro-code block. This continues until a zero is found in the LIS field or eight lights have been done. Color accumulation is done by incrementing (per light) the ALU registers that store the diffuse and specular color. Automatic memory address indexing is done using the light counter to fetch the correct parameters for each light.",{"@attributes":{"id":"p-0231","num":"0286"},"figref":"FIG. 24","b":["52","54","2420"]},"Subsequently, in operation , an empty buffer of a second set of buffers is identified also based on a round robin sequence. The transform module  is coupled between the first set of buffers and the second set of buffers. When the empty buffer of the second set of buffers is identified, the vertex data is processed in transform module and outputted from transform module to the identified empty buffer of the second set of buffers. Note operations  and .","Similarly, an empty buffer of a third set of buffers, or slots or spaces in memory, are identified based on a round robin sequence in operation . The lighting module  is coupled between the second set of buffers and the third set of buffers. When the empty buffer of the third set of buffers is identified, the vertex data is processed in the lighting module, as indicated in operation . The vertex data is subsequently outputted from lighting module  to the identified empty buffer of the third set of buffers. See operation . It should be noted that the number of buffers, or slots in memory, is flexible and might be changed.",{"@attributes":{"id":"p-0234","num":"0289"},"figref":["FIG. 25","FIG. 24"],"b":["52","54","400","52","404","406","404","406","54","2550"]},"In order carry out the method set forth in , the slots of memory  and the buffers of the first and second set are each assigned a unique identifier upon initially receiving vertex data. Further, a current state of each buffer is tracked. Such state might include an allocated state, a valid state, an active state, or a done state.","The allocated state indicates that a buffer\/slot is already allocated to receive an output of the previous graphics-processing module, i.e. transform module or lighting module. When a write pointer is scanning the buffers\/slots in the round robin sequence, a buffer\/slot in the allocated state cause such write pointer to increment to the next buffer or slot.","If a buffer\/slot is in the valid state, the buffer\/slot is available for receiving vertex data. On the other hand, the active state indicates that a buffer\/slot is currently in an execution state, or receiving vertex data. This active status is maintained until a thread is done after which a read pointer increments, thus placing the buffer\/slot back in the valid state. It should be noted that the first set of buffers  are only capable of being in the valid state since there is no previous graphics-processing module to allocate them.","An example of a sequence of states will now be set forth. Upon receiving vertex data in one of the first set of buffers  and a new set of command bits , such buffer is placed in the valid state, after which one of the second set of buffers ,  is placed in the allocated state in anticipation of the output of transform module .","If none of the second set of buffers ,  is available for allocation, the vertex data in the buffer of the first set  can not be processed. Further, a check might be done to determine whether the code segments to be executed will interfere with any other code segments that are to be simultaneously run. If so, the vertex data in the buffer of the first set  will not be processed and a stall condition initiated.","After one of the second set of buffers ,  is placed in the allocated state, the buffer of the first set  is placed in the active state. When transform module  is finished execution, the buffer of the second set ,  is read and then placed in the valid state. These state changes are similarly executed during the transfer of vertex data between the second set ,  and the slots of memory .",{"@attributes":{"id":"p-0241","num":"0296"},"figref":"FIG. 25B","b":["56","57","58","56","56"]},{"@attributes":{"id":"p-0242","num":"0297"},"figref":"FIG. 26","b":["57","56","57","61","62","64"]},"With continuing reference to , output formatting section  handles converting the internal floating point format of edge slopes and edge values into integer formats suitable for the rasterizer since the rasterizer operates only with integer values. Of course, in alternate embodiments, the rasterizer might use a floating point thus obviating the need for output formatting section .","In operation, output formatting section  executes a block floating point conversion. As is well known, with a given number, i.e. 2.34 e, floating point format tracks a mantissa (2.34) and an exponent (10) thereof. Block floating point conversion essentially manipulates the decimal place of the mantissas of incoming data such that the exponents are the same. To this end, the exponent need not be handled in rasterizer module .",{"@attributes":{"id":"p-0245","num":"0300"},"figref":["FIG. 26A","FIG. 25B"],"b":["57","56","56","2600","57","2601","2600","2602","2604"]},"The slopes  are used to generate coefficients for line equations of the edges of the primitive  to be used during rasterization. The slopes  might, for example, be calculated by using equations #4 and #5 shown below.\n\nslope\n\nslope\u2003\u2003Equations #4 and #5\n\n","It should be noted that the slopes might also be calculated using the coordinates of the vertices by employing a simple rotation operation or the like.","The starting position  indicates a starting point for area rasterization that will be set forth hereinafter in greater detail. The starting value  is equal to the area of the shaded triangle shown in  and is also used during the area-based rasterization process. Such starting value  is selected so that stepping the raster position about the screen while adding the slope at each step will equal zero exactly when the raster position is on the edge. Calculation of the starting value  might be accomplished using Equation #6 below:\n\nstartingvalue=slope*()+slope*()\u2003\u2003Equation #6\n\n","It should be understood that the foregoing values might also be calculated for other types of primitives. For example, in the case of a line, an extra slope must be calculated for the four-sided bounding box. Such slope can be easily calculated by taking the reciprocal of the slope of an opposite side of the bounding box. In addition to the extra slope calculation, it is noted that another starting value needs to be calculated in the case of the line primitive.",{"@attributes":{"id":"p-0250","num":"0309"},"figref":["FIG. 27","FIG. 26A"],"b":["56","57","56","2700","2601"]},"Thereafter, in operation , the line equation coefficients are modified if any primitive vertex(es) has a negative W-coordinate. Additional information regarding this process will be set forth hereinafter in greater detail with reference to .","It should be noted that set-up module  of rasterizer module  also computes a bounding box of the primitive. For most triangles, the bounding box includes the minimum and maximum values of the three vertexes. For lines, the four parallelogram corners of the bounding box are calculated. For triangles or lines that have a vertex with a negative W-coordinate, an area that is to be drawn extends beyond the convex hull of the vertices.","One of the commands of OpenGL\u00ae is a scissor rectangle which defines a boundary outside of which is not to be drawn. The set-up module  of rasterizer module  calculates the intersection of the bounding box and the scissor rectangle. Since the scissor rectangle is a rectangle, four additional line equations are afforded. It should be noted that the line equations associated with the scissor rectangle have a trivial form, i.e. horizontal or vertical.","Furthermore, in 3-D space, the near plane and far plane are parallel and at right angles to the line of sight. In the case of the primitive being a triangle, three vertexes are included which define a plane that might have any orientation. The intersections of the plane of the primitive and the near and far planes include two lines with two associated line equations.","Accordingly, each primitive has a total of nine or ten line equations depending on whether it takes the form of a triangle or a line, respectively. Again, in the case of the triangle, such line equations include the three line equations which define the triangle, the four line equations defining the bounding box and the two line equations which define the intersections of the plane in which the primitive resides, and near and far planes.","With continuing reference to , the process progresses in operation  by positioning a plurality of points on or near the primitive. The starting position  dictates such positioning, as shown in . Such points define an enclosed convex region and reside at corners of the convex region.  illustrates such sense points  that enclose convex region , e.g. a rectangle. In one embodiment, such rectangle might be 8\u00d72 pixels in size. Further, the points might be initially positioned to enclose a top vertex of the primitive. As an option, this might be accomplished using truncation.","Once the primitive is positioned, the process is continued by traversal module  which begins in operation  by processing rows of the primitive in a manner set forth below. After the processing of each row, it is determined whether a jump position has been found in decision . A jump position is a starting position for processing the next row and will be described hereinafter in greater detail. If it is determined in decision  that a jump position has been found, the sense points that define the convex region are moved thereto in operation . If, however, it is determined that a jump position has not been found, the process is ended. It should be noted that, in an alternate embodiment, columns, diagonals or any other type of string might be processed in operation  instead of rows.",{"@attributes":{"id":"p-0258","num":"0317"},"figref":["FIG. 28","FIG. 27"],"b":["2706","2800","2801","2802","2802"]},"Next, the line equations are evaluated at the points of the convex region, e.g. rectangle, in operation . The evaluation includes determining if the points reside in the primitive. Such determination as to whether the points reside in the primitive might include determining whether the evaluation of each of the line equations renders a positive value or a negative value at each of the sense points.","The line equations can be formulated to be positive inside the primitive and negative outside. Inclusive edges, for which pixels that lie exactly on the edge should be drawn, evaluate to zero and might be treated as positive. Exclusive edges, which should not be drawn, can be made negative by initially subtracting a value of one from the starting line equation value. Thus pixels on exclusive edges evaluate to a negative value (\u22121) instead of a positive zero. This permits the sense point interpretation to ignore the inclusive\/exclusive policy and just test the line equation sign.","After the line equations are evaluated at the points, it is determined whether a current position of the sense points constitutes a jump position in decision . It should be noted that a jump position is stored only if the two bottom sense points are not both outside an edge. If it is determined in decision  that a jump position has been found, the jump position is calculated and stored (or replaces a previously stored jump position if existent) in operation . If not, however, operation  is skipped.","With continuing reference to , it is then determined in decision  whether leftmost sense points are both outside an edge of the primitive. Again, this process entails determining whether the evaluation of the line equations at both of the leftmost sense points renders positive or negative values. In particular, upon computation of the coefficients of the nine or ten edge equations at the pertinent sense points, nine or ten values are rendered that have nine or ten sign bits. To determine if the current side is completely outside any edge, for example, the present invention AND's the ten sign bits from the two sense points together. If any bit(s) survive, then both points are outside that edge.","If it is determined that the leftmost sense points are not both outside an edge of the primitive, it is concluded that there still remains further portions of the primitive to be considered in the leftward direction, and the sense points are moved left in operation . If it is determined in decision  that both leftmost sense points are indeed outside the edge of the primitive, it is concluded that there no longer remains further portions of the primitive to be considered in the leftward direction. Next, in decision , it is determined whether there is a snap location that resulted from operation .","If it is determined in decision  that a snap location does not exist, the process is done. If, however, a snap location does exist, the sense points are moved to the snap location in operation . Thereafter, operations similar to those of operations \u2013 are executed to map a right side of the primitive. This begins in operation  by the line equations being evaluated at the points of the convex region.","After the line equations are evaluated at the points, it is determined whether a current position of the sense points constitutes a jump position in decision . If it is determined in decision  that a jump position has been found, the jump position is calculated and stored in operation . If not, however, operation  is skipped. With continuing reference to , it is then determined in decision  whether rightmost sense points are both outside an edge of the primitive. If it is determined that the rightmost sense points are not both outside an edge of the primitive, it is concluded that there still remains further portions of the primitive in the rightward direction to be considered, and the sense points are moved right in operation . If it is determined in decision  that both rightmost sense points are outside the edge of the primitive, it is concluded that there no longer remains further portions of the primitive to be considered in the rightward direction, and the instant process is done.",{"@attributes":{"id":"p-0266","num":"0325"},"figref":"FIGS. 28A and 28B","b":["2850","2800"]},"To avoid stepping in a repeating loop, the present invention thus employs an overall direction of movement during rasterization. The initial implementation proceeds top-down, visiting every convex region on a row before stepping down to the next. By processing rows top-down as well as never stepping right then left or left then right, loops are thus avoided.","An example of the foregoing process might be shown with reference to the polygon-defining points, P, P, P and P of . In operation, pairs of adjacent sense points can be examined to determine whether stepping in their direction would be productive. For example, if both P and P in  were outside of an edge of a polygon, but P and\/or P are not, then clearly the drawable inside region lies to the left, not to the right. Thus the sense points should not move right. Conversely, if both P and P are inside all the edges, then there is a drawable area just beyond P and P, and stepping right is appropriate. Indeed, if P and P were not outside the same edge or edges, stepping right would be productive. This same logic applies to stepping upwards guided by P and P, or stepping left guided by P and P, or stepping downwards based on P and P.","The foregoing process thus moves, or steps, the convex region defined by the points around the inside of the primitive, using sense points as a guide. Since the convex region defined by the points might be large, many pixels might be tested simultaneously. During use, if all sense points are inside all edges of the primitive, then all the enclosed pixels must be drawable (assuming a convex primitive). A significant advantage is afforded by testing the corners, namely the ability of proving an arbitrary area of the primitive is inside, outside or split. Only in the latter case do the individual pixels in the convex region defined by the points need to be tested. In such case, the pixels in the convex region defined by the points might be tested one-by-one or by another method in order to determine whether they reside in the primitive. Furthermore, the sense points might reduce the amount of further testing required by defining which edges(s) split the area and which do not.",{"@attributes":{"id":"p-0270","num":"0329"},"figref":["FIG. 29","FIG. 27","FIG. 28"],"b":["2706","2900","2900","2902","2804"]},"With continuing reference to , it is subsequently determined in decision  as to whether sense points of a first side of the rectangle are both outside an edge of the primitive. If not, the sense points are moved or stepped in the first direction in operation . Upon it being determined that the sense points of the first side of the rectangle are both outside an edge of the primitive, it is then determined in decision  whether the points can be moved downwardly or, in other words, whether the current position constitutes a jump position. If so, a jump position is calculated and stored in operation  after which the process is done.","On the other hand, if it is determined in decision  that the previous movement was in a first direction, operations similar to those of operation \u2013 are carried out. In particular, the line equations are evaluated at the points of the convex region, e.g. a rectangle, in operation . It is then determined in decision  as to whether sense points of a second side of the rectangle are both outside an edge of the primitive. If not, the sense points are moved or stepped in the second direction in operation . Upon it being determined that the sense points of the second side of the rectangle are both outside an edge of the primitive, it is then determined in decision  whether the points can be moved downwardly or, in other words, whether the current position constitutes a jump position. If so, a jump position is calculated and stored in operation  after which the process is done.",{"@attributes":{"id":"p-0273","num":"0332"},"figref":["FIG. 29A","FIG. 29"]},"Generating pixels that are near recently previously generated pixels is important when recent groups of pixels and\/or their corresponding texture values are kept in memories of a limited size. The boustrophedonic sequence more often finds the pixels or texture values already loaded into such memories, and therefore repeating the memory load occurs less often.","As an option, at least one boundary might be used which divides the primitive into a plurality of portions prior to rasterization. In operation, the points might be moved in each of the portions separately. Further, the points might be moved through an entirety of a first one of the portions before being moved in a second one of the portions.",{"@attributes":{"id":"p-0276","num":"0335"},"figref":["FIG. 30","FIG. 30","FIG. 27"],"b":"3000"},"With continuing reference to , an additional decision  follows the completion of every portion of the primitive. In particular, it is determined in decision  whether a start position of an adjacent portion was found in operation . If so, the convex region defined by the sense points is moved to a start position of an adjacent portion of the primitive in operation  and operations \u2013 are repeated for the new portion of the primitive. Further information relating to the determination of the start position in operation  will be set forth in greater detail during reference to .",{"@attributes":{"id":"p-0278","num":"0337"},"figref":["FIG. 31A","FIG. 30"]},{"@attributes":{"id":"p-0279","num":"0338"},"figref":["FIG. 31","FIG. 30","FIG. 29"],"b":["3006","3118","3121","3118","3120"]},"In operations  and , starting positions of adjacent portions of the primitive are sought and stored when it is determined in decisions  and  that any sense points of the convex region have passed any boundary, respectively. As shown in , such starting positions  are each defined as being the topmost point of a portion of the primitive existent beyond a boundary. By storing this position, a starting point is provided when the process is repeated for the adjacent boundary-defined portion of the primitive.","It should be noted that operations  and  are both performed while processing the first portion of the primitive. While not expressly shown in , only a first one of such operations is performed when processing portions to the left of the first portion, while only a second one of such operation is performed when processing portions to the right of the first portion. In other words, when processing portions to the left of the first portion, starting positions are only determined when a leftmost boundary of the currently processed portion has been exceeded. Similarly, when processing portions to the right of the first portion, starting positions are only determined when a rightmost boundary of the currently processed portion has been exceeded.","Using boundaries during rasterization solves a very critical problem during pipeline processing. If a primitive is very wide, the storage associated with the pixels of a single row might not fit in a limited-size memory. Rasterization with boundaries divides the triangle into limited-width rows (or columns), and generates all the pixels within such a portion before moving on to the next portion.","For example, even if a triangle is 100 pixels wide, a limited-size pixel or texture memory might only hold information for the previous 20 pixels. Constraining the pixel sequence to stay within ten-pixel-wide vertical portions allows all the pixels on the previous and current rows to fit in the memory. This means that a boustrophedonic sequence within a boundary-defined portion would always have the previous pixel on the current row (if any) in the memory, as well as the pixels in the row above (if any) in the memory as well.","Most underlying memory systems transfer blocks of data with a certain overhead per block. Small accesses to the memory system are penalized heavily by this overhead. In order to be efficient, larger accesses are employed and the rest of the block is maintained in case it might be used next. Beyond that, a cache memory system keeps a plurality of these recent blocks, increasing the probability that memory accesses can be avoided.","The boustrophedonic sequence of the present invention exploits the single-retained-block concept when it reverses and handles pixels immediately below one end of the current line. Further, the boustrophedonic sequence exploits cache when it limits rasterization to portions of a particular size. Specifically, two scanlines within a portion should fit in the cache, so throughout the second scanline, benefits might be incurred from cache storage of the first scanline.","There is no constraint on the sequence or number of boundary-defined portions. Although the present description uses the example of vertical portions and a horizontal boustrophedonic pattern, similar principles might extend to horizontal portions, vertical boustrophedonic patterns or even to diagonal portions and patterns. In one embodiment, the length of the strings (e.g. rows, columns, diagonals, etc.) might be each limited to be less than a dimension of the primitive along which the string resides.",{"@attributes":{"id":"p-0287","num":"0346"},"figref":["FIG. 32","FIG. 27"],"b":"2702"},"As shown in , a primitive is first received that is defined by a plurality of vertices. Each of such vertices includes a W-value. Upon the receipt of the primitive, the set-up module serves to define lines that characterize the primitive based on the vertices. Note operation .","The W-values are then analyzed in decision . As shown, if one of the W-values is negative, a line equation for a line opposite the vertex having the negative value is flipped in operation . In other words, the coefficients of the line equation are multiplied by \u22121. Further, if two of the W-values are negative, line equations for lines connecting the vertex having a positive W-value and each of the vertexes having negative W-values are flipped in operation . If three of the W-values are negative, a cull condition  occurs where the present invention culls the triangle. Still yet, if none of the W-values are negative, no additional action is taken.",{"@attributes":{"id":"p-0290","num":"0349"},"figref":["FIGS. 32A\u201332C","FIG. 32A"]},{"@attributes":{"id":"p-0291","num":"0350"},"figref":"FIG. 32B"},{"@attributes":{"id":"p-0292","num":"0351"},"figref":["FIG. 32C","FIGS. 27\u201332"]},"The present invention is thus capable of handling all three of the foregoing cases. If part of the triangle is beyond the near and\/or far plane, it draws only the portion within those planes. If the triangle has one or two negative Z vertexes, only the correct +Z portion is drawn.","Even if all vertexes are off-screen, and the triangle extends from behind the eye to beyond the far plane, whatever pixels are inside the triangle and on the screen and have Z between the near and far limits. The present invention ensures that little time is wasted exploring bad pixels. This is possible because all clipping, by screen edge or the near or far plane, always results in a convex region on-screen which can be explored easily.","A problem sometimes arises when the starting point is not inside the area to be filled. This can occur if the top vertex is off-screen or is clipped by the near or far plane. In this case, the traversal stage must search for the top point of the drawn region, starting from above. It can do this efficiently by being guided by the signs of the triangle edge slopes and the Z slope. It can test the triangle line equations to discover it is outside the drawn region and why. When it knows what edge(s) and\/or Z limit it is outside of, it knows what direction(s) to step that brings it closer to that edge or limit. By moving horizontally in preference to vertically (when there is a choice), searching for the drawn region guarantees it finds the top drawable pixel if there is one. This problem also occurs with external (\u2212W) triangles that open up. In this case, the drawn area extends above all three vertexes.","In one embodiment of the present invention, traversal proceeds from top to bottom of the triangle. The starting point is the top vertex of the triangle if none have a negative W-value and the top vertex is in the scissor rectangle. Otherwise, a point on the top of the scissor rectangle is chosen. Since traversal always begins within the scissor rectangle and never ventures out of it, only the portion of the triangle within the scissor rectangle is ever drawn, even if the area enclosed by the edges extends far beyond the scissor rectangle. In this way, simple scissor rectangle-edge clipping is effected.",{"@attributes":{"id":"p-0297","num":"0356"},"figref":"FIG. 33","b":["3300","3302","3304","3300","3302","3304"]},"In one embodiment of the present invention, filtering operations may be performed at several stages in the graphics pipeline. Displacement maps may be accessed and filtered to provide vertex displacements, texture may be filtered for pixel shading, antialiasing samples may be filtered to produce a pixel color, and pixels may be filtered for video display. As such, the need for separate filtering logic and memory access of  may be obviated. It should be noted that any other functions such as rescaling of the pixels for video displays, video resampling, etc. may reuse filtering hardware of the graphics pipeline.","It should be noted that the antialiasing feature of the present embodiment may take many forms, and may be varied per the desires of the user. Examples of such variations will now be described. It should be understood that such variations are optional and for illustrative purposes only. As such, the following examples should not be construed as limiting.","Supersampling","One antialiasing technique is supersampling. Supersampling involves taking more samples of an image than there are pixels to be displayed. Such samples are taken at subpixel positions within each pixel. The color and intensity displayed for each pixel comes from combining the subpixel samples.","The quality of the antialiasing obtained by supersampling is affected by the number and position of subpixel samples. Generally, the more subpixel samples per pixel, the better is the antialiasing effect. Samples may be placed on a regular subpixel grid, for example, 2\u00d72, 4\u00d74, or 8\u00d78 subpixel samples per pixel. Samples may also be placed in an irregular or jittered pattern, which has been found to produce more pleasing visual results for a given number of subpixel samples.","Supersampling is thus an antialiasing technique that increases the spatial quantization of the display's array by increasing the number of data samples that are taken at or around each pixel location corresponding to a portion of the image to be displayed, and then combining the resulting values of these multiple data samples to obtain a final display value for each pixel location. Each supersample typically includes both a color-value (for either color or grey-scale systems) and a Z-value (a representation of the depth of a pixel which is used to perform hidden surface removal) relating to a reference point (one reference point per supersample) within the pixel.","In accordance with the operation of known supersampling techniques, the color value and Z-value for each reference \u201csample\u201d point within a pixel are first sent to a processor which computes the color-value for each sample and compares the Z-value of each covered sample against any previously stored value. The color value for each newly covered sample is then updated accordingly.","An advantage of supersampling relative to other forms of antialiasing is that points, lines, and polygons can be drawn into a supersampled buffer in any order to produce the same final image.","Multisampling","Multisampling is similar to supersampling in that it provides storage for multiple subpixel samples per pixel. It differs from supersampling, in that, as objects are rendered, a single color is computed per pixel and used for all covered subpixel samples, rather than computing an independent color per sample.",{"@attributes":{"id":"p-0306","num":"0365"},"figref":"FIG. 34","b":["3400","3401","3404","3402"]},"For more information regarding multisampling, reference may be made to: Akeley, Kurt; RealityEngine Graphics. 1993, August 1993, Pages 109\u2013116; and John S. Montrym, Daniel R. Baum, David L. Dignam and Christopher J. Migdal; InfiniteReality: a real-time graphics system. 24& 1997, Pages 293\u2013302; which are each incorporated herein by reference in their entirety.","Fragment-based antialiasing (\u201cA-buffer antialiasing\u201d)","A third antialiasing approach stores multiple fragments per pixel. A fragment is the contribution of a surface to a pixel, typically consisting of a color, a depth value (possibly including slopes), and information describing what portion of the pixel is covered. Fragment-based approaches keep track of surfaces that are fully or partially visible at each pixel and compute a final pixel color as a weighted average of these fragment colors.","One problem inherent to fragment-based approaches is how to represent coverage. Keeping track of a coverage fraction per fragment is an inexpensive method, but makes it difficult to distinguish the effect of two triangles that abut in the vicinity of a pixel versus the effect of two triangles that obscure the same subregion of a pixel. For example, if triangle A covers 35% and triangle B covers 50% of a given pixel, it is not known whether triangle B covers the same 35% as triangle A plus 15%, if the 50% coverage of triangle B is totally different from the 35% coverage of triangle A, or if the coverage falls somewhere in-between. It is often difficult to compute coverage fractions for pixels near the vertices of a single triangle, where the coverage values of two edges interact.","A more robust but expensive method of handling coverage involves a mask. The mask comprises a number of bits which can correspond to specific subpixel sample locations, or to subregions of a pixel.","When mask bits correspond to subregions, the number of bits set in the mask is roughly proportional to fragment coverage. For example, if the fragment covers 52% of the pixel, and the mask comprises a total of 16 bits, then 9 of the bits might be set while 7 bits are cleared. Those bits whose subregions most closely correspond to the pixel area that is covered by the fragment are selected to be set.","Typical methods that make use of pixel masks include the A-buffer algorithm (see \u201cThe A-buffer: an Anti-alisased Hidden Surface Method,\u201d by Loren Carpenter, Siggraph, 1984, pp103\u2013108, which is incorporated herein by reference). However, according to this method, a pixel bit mask is generated in a software process, which entails slow speed. Another method using a pixel mask is a method using a look-up table (see \u201cA New Simple and Efficient Antialiasing with Subpixel mask,\u201d by Andreas Schilling, Siggraph, 1991, pp133\u2013141, which is incorporated herein by reference). In such look-up table method, all possible pixel mask shapes, which can be generated depending on the slope (de) of a triangle's edge and the distance (e) from pixel center to its edge, are prestored in a look-up table. Here, the pixel-mask is generated by indexing the look-up table with the above two pieces of information which are calculated when performing a triangle traversal operation, by a method proposed by Juan Pineda (see \u201cA Parallel Algorithm for Polygon Rasterizations,\u201d Siggraph, 1988, pp17\u201320, which is incorporated herein by reference).","All these antialiasing schemes attempt to capture the color and Z information for all the primitives that overlap a pixel, including identifying which portion of the pixel is covered by each. All these schemes require a filtering operation (i.e., a weighed average of the color contributions) to determine the final pixel color. This filtering may be done whenever the pixel is written, or on demand when the color is read.","For more information on such algorithms, reference may be made to: Stephanie Winner, Mike Kelley, Brent Pease, Bill Rivard and Alex Yen; Hardware accelerated rendering of antialiasing using a modified a-buffer algorithm.","PROCEEDINGS OF THE 24TH ANNUAL CONFERENCE ON COMPUTER GRAPHICS & INTERACTIVE TECHNIQUES, 1997, Pages 307\u2013316, which is incorporated herein by reference.","In fragment-based methods, a single Z value can be retained per fragment. The Z value can be the value of the surface Z plane sampled at the center of the pixel. It can also be computed at the fragment centroid. More sophisticated methods store Z slope values as well, allowing more accurate depth comparisons of subpixel geometry. Other variants store multiple Z values at a number of sample locations.","Hybrid antialiasing algorithms, which combine aspects of supersampling, multisampling, and fragment-based schemes, are also possible.","Antialiasing may further be applied to all objects in a scene, or independently enabled for particular objects. Edge antialiasing can be combined with full-scene antialiasing, for example, to render antialiased lines in a scene with polygonal objects.","Antialiasing algorithms can further be used to simulate motion blur, depth-of-field, and partial transparency, by manipulating sample coverage or fragment mask values.","While various embodiments have been described above, it should be understood that they have been presented by way of example only, and not limitation. Thus, the breadth and scope of a preferred embodiment should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing and other aspects and advantages are better understood from the following detailed description of a preferred embodiment of the invention with reference to the drawings, in which:",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 1A\u20131"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIGS. 1A\u20132","FIGS. 1A\u20131"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIGS. 1A\u20133"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIGS. 1A\u20134"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 1B\u20131"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 1B\u20132"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 1B\u20133"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 1C"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 2C","FIG. 2B"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 4B","FIG. 4A"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 7","FIG. 5"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 8","FIG. 5"]},{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 9","FIG. 5"]},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 10","FIG. 5"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 11","FIG. 5"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 12","FIG. 5"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 13","FIG. 12"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 14","FIG. 12"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 14A"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 14B","FIG. 14A","FIG. 5"],"b":"1451"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 14C","FIG. 14A"],"b":"1453"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 14D","FIG. 12"]},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 16","FIG. 15"]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 17","FIG. 16"]},{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 18","FIG. 16"]},{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIG. 19","FIG. 16"]},{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 20","FIG. 16"]},{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 21","FIG. 16"]},{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 22","FIG. 16"]},{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 23","FIG. 16"]},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 25","FIG. 24"]},{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIG. 25B","FIG. 1B"]},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 26A","FIG. 26"]},{"@attributes":{"id":"p-0065","num":"0064"},"figref":["FIG. 27","FIG. 26"]},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 27A"},{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIG. 28","FIG. 27"],"b":"2706"},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 28A"},{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 28B"},{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 29","FIG. 27"],"b":"2706"},{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 29A","FIG. 29"]},{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0073","num":"0072"},"figref":["FIG. 31","FIG. 30"],"b":"3006"},{"@attributes":{"id":"p-0074","num":"0073"},"figref":["FIG. 31A","FIGS. 30 and 31"]},{"@attributes":{"id":"p-0075","num":"0074"},"figref":["FIG. 32","FIG. 27"],"b":"2702"},{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 32A","FIG. 32"]},{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 32B","FIG. 32"]},{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 32C","FIG. 32"]},{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 34"}]},"DETDESC":[{},{}]}
