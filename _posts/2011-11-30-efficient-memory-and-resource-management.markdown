---
title: Efficient memory and resource management
abstract: The present system enables passing a pointer, associated with accessing data in a memory, to an input/output (I/O) device via an input/output memory management unit (IOMMU). The I/O device accesses the data in the memory via the IOMMU without copying the data into a local I/O device memory. The I/O device can perform an operation on the data in the memory based on the pointer, such that I/O device accesses the memory without expensive copies.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08719464&OS=08719464&RS=08719464
owner: Advanced Micro Device, Inc.
number: 08719464
owner_city: Sunnyvale
owner_country: US
publication_date: 20111130
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION"],"p":["1. Field of the Invention","The present invention is generally directed to computing systems. More particularly, the present invention is directed to the sharing of a virtual address space within a computing system.","2. Background Art","The desire to use a graphics processing unit (GPU) for general computation has become much more pronounced recently due to the GPU's exemplary performance per unit power and\/or cost. The computational capabilities for GPUs, generally, have grown at a rate exceeding that of the corresponding central processing unit (CPU) platforms. This growth, coupled with the explosion of the mobile computing market and its necessary supporting server\/enterprise systems, has been used to provide a specified quality of desired user experience. Consequently, the combined use of CPUs and GPUs for executing workloads with data parallel content is becoming a volume technology.","However, GPUs have traditionally operated in a constrained programming environment, available only for the acceleration of graphics. These constraints arose from the fact that GPUs did not have as rich a programming ecosystem as CPUs. Their use, therefore, has been mostly limited to two dimensional (2D) and three dimensional (3D) graphics and a few leading edge multimedia applications, which are already accustomed to dealing with graphics and video application programming interfaces (APIs).","With the advent of multi-vendor supported OpenCL\u00ae and DirectCompute\u00ae, standard APIs and supporting tools, the limitations of the GPUs in traditional applications has been extended beyond traditional graphics. Although OpenCL and DirectCompute are a promising start, there are many hurdles remaining to creating an environment and ecosystem that allows the combination of the CPU and CPU to be used as fluidly as the CPU for most programming tasks.","Existing computing systems often include multiple processing devices. For example, some computing systems include both a CPU and a GPU on separate chips (e.g., the CPU might be located on a motherboard and the GPU might be located on a graphics card) or in a single chip package. Both of these arrangements, however, still include significant challenges associated with (i) efficient scheduling, (ii) providing quality of service (QoS) guarantees between processes, (iii) programming model, (iv) compiling to multiple target instruction set architectures (ISAs), and (v) separate memory systems,\u2014all while minimizing power consumption.","For example, the discrete chip arrangement forces system and software architects to utilize chip to chip interfaces for each processor to access memory. While these external interfaces (e.g., chip to chip) negatively affect memory latency and power consumption for cooperating heterogeneous processors, the separate memory systems (i.e., separate address spaces) and driver managed shared memory create overhead that becomes unacceptable for fine grain offload.","In another example, some images stored in memory accessed by multiple processors may not be stored at a desired level of quality. For example, picture quality, contrast, orientation (e.g., rotation), etc. of the images may be incorrect. Typically, if there is image data residing in memory that needs manipulation prior to being displayed, this image data has to be copied to the I\/O device's memory where it can be manipulated, and then copied back to memory so that they can be printed. This process is time-consuming and, for example, can reduce the quality of stored image data.","Therefore, what is needed is an efficient manner to store for multiple processors to access data stored in a shared memory.","Although GPUs, accelerated processing units (APUs), and general purpose use of the graphics processing unit (GPGPU) are commonly used terms in this field, the expression \u201caccelerated processing device (APD)\u201d is considered to be a broader expression. For example, APD refers to any cooperating collection of hardware and\/or software that performs those functions and computations associated with accelerating graphics processing tasks, data parallel tasks, or nested data parallel tasks in an accelerated manner with respect to resources such as conventional CPUs, conventional GPUs, and\/or combinations thereof.","More specifically, embodiments of the present invention relate to methods, systems, and computer readable media for IOMMU efficient memory and resource management. In one embodiment, a pointer associated with accessing data in a memory, is passed to an input\/output (I\/O) device via an input\/output memory management unit (IOMMU). The I\/O device accesses the data in the memory via the IOMMU without copying the data into a local I\/O device memory. The I\/O device performs an operation on the data in the memory based on the pointer.","Further features and advantages of the invention, as well as the structure and operation of various embodiments of the invention, are described in detail below with reference to the accompanying drawings. It is noted that the invention is not limited to the specific embodiments described herein. Such embodiments are presented herein for illustrative purposes only. Additional embodiments will be apparent to persons skilled in the relevant art(s) based on the teachings contained herein.","In the detailed description that follows, references to \u201cone embodiment,\u201d \u201can embodiment,\u201d \u201can example embodiment,\u201d etc., indicate that the embodiment described may include a particular feature, structure, or characteristic, but every embodiment may not necessarily include the particular feature, structure, or characteristic. Moreover, such phrases are not necessarily referring to the same embodiment. Further, when a particular feature, structure, or characteristic is described in connection with an embodiment, it is submitted that it is within the knowledge of one skilled in the art to affect such feature, structure, or characteristic in connection with other embodiments whether or not explicitly described.","The term \u201cembodiments of the invention\u201d does not require that all embodiments of the invention include the discussed feature, advantage or mode of operation. Alternate embodiments may be devised without departing from the scope of the invention, and well-known elements of the invention may not be described in detail or may be omitted so as not to obscure the relevant details of the invention. In addition, the terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. For example, as used herein, the singular forms \u201ca\u201d, \u201can\u201d and \u201cthe\u201d are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms \u201ccomprises,\u201d \u201ccomprising,\u201d \u201cincludes\u201d and\/or \u201cincluding,\u201d when used herein, specify the presence of stated features, integers, steps, operations, elements, and\/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and\/or groups thereof.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1","b":["100","102","104","102","100","102","104","104","102","102","104"]},"In one example, system  also includes a memory , an operating system (OS) , and a communication infrastructure . The OS  and the communication infrastructure  are discussed in greater detail below.","The system  also includes a kernel mode driver (KMD) , a software scheduler (SWS) , and a memory management unit , such as input\/output memory management unit (IOMMU). Components of system  can be implemented as hardware, firmware, software, or any combination thereof. A person of ordinary skill in the art will appreciate that system  may include one or more software, hardware, and firmware components in addition to, or different from, that shown in the embodiment shown in .","In one example, a driver, such as KMD , typically communicates with a device through a computer bus or communications subsystem to which the hardware connects. When a calling program invokes a routine in the driver, the driver issues commands to the device. Once the device sends data back to the driver, the driver may invoke routines in the original calling program. In one example, drivers are hardware-dependent and operating-system-specific. They usually provide the interrupt handling required for any necessary asynchronous time-dependent hardware interface. Device drivers, particularly on modern Windows platforms, can run in kernel-mode (Ring 0) or in user-mode (Ring 3). The primary benefit of running a driver in user mode is improved stability, since a poorly written user mode device driver cannot crash the system by overwriting kernel memory. On the other hand, user\/kernel-mode transitions usually impose a considerable performance overhead, thereby prohibiting user mode-drivers for low latency and high throughput requirements. Kernel space can be accessed by user modules only through the use of system calls. End user programs like the UNIX shell or other GUI based applications are part of the user space. These applications interact with hardware through kernel supported functions.","CPU  can include (not shown) one or more of a control processor, field programmable gate array (FPGA), application specific integrated circuit (ASIC), or digital signal processor (DSP). CPU , for example, executes the control logic, including the OS , KMD , SWS , and applications , that control the operation of computing system . In this illustrative embodiment, CPU , according to one embodiment, initiates and controls the execution of applications  by, for example, distributing the processing associated with that application across the CPU  and other processing resources, such as the APD .","APD , among other things, executes commands and programs for selected functions, such as graphics operations and other operations that may be, for example, particularly suited for parallel processing. In general, APD  can be frequently used for executing graphics pipeline operations, such as pixel operations, geometric computations, and rendering an image to a display. In various embodiments of the present invention, APD  can also execute compute processing operations, based on commands or instructions received from CPU .","For example, commands can be considered a special instruction that is not defined in the instruction set architecture (ISA) and usually accomplished by a set of instructions from a given ISA or a unique piece of hardware. A command may be executed by a special processor such as a dispatch processor, command processor, or network controller. On the other hand, instructions can be considered, e.g., a single operation of a processor within a computer architecture. In one example, when using two sets of ISAs, some instructions are used to execute x86 programs and some instructions are used to execute kernels on APD\/GPU compute unit.","In an illustrative embodiment, CPU  transmits selected commands to APD . These selected commands can include graphics commands and other commands amenable to parallel execution. These selected commands, that can also include compute processing commands, can be executed substantially independently from CPU .","APD  can include its own compute units (not shown), such as, but not limited to, one or more single instruction multiple data (SIMD) processing cores. As referred to herein, a SIMD is a math pipeline, or programming model, where a kernel is executed concurrently on multiple processing elements each with its own data and a shared program counter. All processing elements execute a strictly identical set of instructions. The use of predication enables work-items to participate or not for each issued command.","In one example, each APD  compute unit can include one or more scalar and\/or vector floating-point units and\/or arithmetic and logic units (ALUs). The APD compute unit can also include special purpose processing units (not shown), such as inverse-square root units and sine\/cosine units. In one example, the APD compute units are referred to herein collectively as shader core .","Having one or more SIMDs, in general, makes APD  ideally suited for execution of data-parallel tasks such as are common in graphics processing.","Some graphics pipeline operations, such as pixel processing, and other parallel computation operations, can require that the same command stream or compute kernel be performed on streams or collections of input data elements. Respective instantiations of the same compute kernel can be executed concurrently on multiple compute units in shader core  in order to process such data elements in parallel. As referred to herein, for example, a compute kernel is a function containing instructions declared in a program and executed on an APD\/GPU compute unit. This function is also referred to as a kernel, a shader, a shader program, or a program.","In one illustrative embodiment, each compute unit (e.g., SIMD processing core) can execute a respective instantiation of a particular work-item to process incoming data. A work-item is one of a collection of parallel executions of a kernel invoked on a device by a command. A work-item can be executed by one or more processing elements as part of a work-group executing on a compute unit.","A work-item is distinguished from other executions within the collection by its global ID and local ID. In one example, a subset of work-items in a workgroup that execute simultaneously together on a single SIMD engine can be referred to as a wavefront . The width of a wavefront is a characteristic of the hardware SIMD engine. As referred to herein, a workgroup is a collection of related work-items that execute on a single compute unit. The work-items in the group execute the same kernel and share local memory and work-group barriers.","All wavefronts from a workgroup are processed on the same SIMD engine. Instructions across a wavefront are issued one at a time, and when all work-items follow the same control flow, each work-item executes the same program. An execution mask and work-item predication are used to enable divergent control flow within a wavefront, where each individual work-item can actually take a unique code path through the kernel. Partially populated wavefronts can be processed when a full set of work-items is not available at wavefront start time. Wavefronts can also be referred to as warps, vectors, or threads.","Commands can be issued one at a time for the wavefront. When all work-items follow the same control flow, each work-item can execute the same program. In one example, an execution mask and work-item predication are used to enable divergent control flow where each individual work-item can actually take a unique code path through a kernel driver. Partial wavefronts can be processed when a full set of work-items is not available at start time. For example, shader core  can simultaneously execute a predetermined number of wavefronts , each wavefront  comprising a predetermined number of work-items.","Within the system , APD  includes its own memory, such as graphics memory . Graphics memory  provides a local memory for use during computations in APD . Individual compute units (not shown) within shader core  can have their own local data store (not shown). In one embodiment, APD  includes access to local graphics memory , as well as access to the memory . In another embodiment, APD  can include access to dynamic random access memory (DRAM) or other such memories (not shown) attached directly to the APD  and separately from memory .","In the example shown, APD  also includes one or (n) number of command processors (CPs) . CP  controls the processing within APD . CP  also retrieves commands to be executed from command buffers  in memory  and coordinates the execution of those commands on APD .","In one example, CPU  inputs commands based on applications  into appropriate command buffers . As referred to herein, an application is the combination of the program parts that will execute on the compute units within the CPU and APD.","A plurality of command buffers  can be maintained with each process scheduled for execution on the APD .","CP  can be implemented in hardware, firmware, or software, or a combination thereof. In one embodiment, CP  is implemented as a reduced instruction set computer (RISC) engine with microcode for implementing logic including scheduling logic.","APD  also includes one or (n) number of dispatch controllers (DCs) . In the present application, the term dispatch refers to a command executed by a dispatch controller that uses the context state to initiate the start of the execution of a kernel for a set of workgroups on a set of compute units. DC  includes logic to initiate workgroups in the shader core . In some embodiments, DC  can be implemented as part of CP .","System  also includes a hardware scheduler (HWS)  for selecting a process from a run list  for execution on APD . HWS  can select processes from run list  using round robin methodology, priority level, or based on other scheduling policies. The priority level, for example, can be dynamically determined. HWS  can also include functionality to manage the run list , for example, by adding new processes and by deleting existing processes from run-list . The run list management logic of HWS  is sometimes referred to as a run list controller (RLC).","In various embodiments of the present invention, when HWS  initiates the execution of a process from RLC , CP  begins retrieving and executing commands from the corresponding command buffer . In some instances, CP  can generate one or more commands to be executed within APD , which correspond with commands received from CPU . In one embodiment, CP , together with other components, implements a prioritizing and scheduling of commands on APD  in a manner that improves or maximizes the utilization of the resources of APD  and\/or system .","APD  can have access to, or may include, an interrupt generator . Interrupt generator  can be configured by APD  to interrupt the OS  when interrupt events, such as page faults, are encountered by APD . For example, APD  can rely on interrupt generation logic within IOMMU  to create the page fault interrupts noted above.","APD  can also include preemption and context switch logic  for preempting a process currently running within shader core . Context switch logic , for example, includes functionality to stop the process and save its current state (e.g., shader core  state, and CP  state).","As referred to herein, the term state can include an initial state, an intermediate state, and a final state. An initial state is a starting point for a machine to process an input data set according to a program in order to create an output set of data. There is an intermediate state, for example, that needs to be stored at several points to enable the processing to make forward progress. This intermediate state is sometimes stored to allow a continuation of execution at a later time when interrupted by some other process. There is also final state that can be recorded as part of the output data set","Preemption and context switch logic  can also include logic to context switch another process into the APD . The functionality to context switch another process into running on the APD  may include instantiating the process, for example, through the CP  and DC  to run on APD , restoring any previously saved state for that process, and starting its execution.","Memory  can include non-persistent memory such as DRAM (not shown). Memory  can store, e.g., processing logic instructions, constant values, and variable values during execution of portions of applications or other processing logic. For example, in one embodiment, parts of control logic to perform one or more operations on CPU  can reside within memory  during execution of the respective portions of the operation by CPU . The term \u201cprocessing logic\u201d or \u201clogic,\u201d as used herein, refers to control flow commands, commands for performing computations, and commands for associated access to resources.","During execution, respective applications, OS functions, processing logic commands, and system software can reside in memory . Control logic commands fundamental to OS  will generally reside in memory  during execution. Other software commands, including, for example, KMD  and software scheduler  can also reside in memory  during execution of system .","in this example, memory  includes command buffers  that are used by CPU  to send commands to APD . Memory  also contains process lists and process information (e.g., active list  and process control blocks ). These lists, as well as the information, are used by scheduling software executing on CPU  to communicate scheduling information to APD  and\/or related scheduling hardware. Access to memory  can be managed by a memory controller , which is coupled to memory . For example, requests from CPU , or from other devices, for reading from or for writing to memory  are managed by the memory controller .","Referring back to other aspects of system , IOMMU  is a multi-context memory management unit.","As used herein, context (sometimes referred to as process) can be considered the environment within which the kernels execute and the domain in which synchronization and memory management is defined. The context includes a set of devices, the memory accessible to those devices, the corresponding memory properties and one or more command-queues used to schedule execution of a kernel(s) or operations on memory objects. On the other hand, process can be considered the execution of a program for an application will create a process that runs on a computer. The OS can create data records and virtual memory address spaces for the program to execute. The memory and current state of the execution of the program can be called a process. The OS will schedule tasks for the process to operate on the memory from an initial to final state.","Referring back to the example shown in , IOMMU  includes logic to perform virtual to physical address translation for memory page access for devices including APD . IOMMU  may also include logic to generate interrupts, for example, when a page access by a device such as APD  results in a page fault. IOMMU  may also include, or have access to, a translation lookaside buffer (TLB) . TLB , as an example, can be implemented in a content addressable memory (CAM) to accelerate translation of logical (i.e., virtual) memory addresses to physical memory addresses for requests made by APD  for data in memory .","In the example shown, communication infrastructure  interconnects the components of system  as needed. Communication infrastructure  can include (not shown) one or more of a peripheral component interconnect (PCI) bus, extended PCI (PCI-E) bus, advanced microcontroller bus architecture (AMBA) bus, accelerated graphics port (AGP), or such communication infrastructure. Communications infrastructure  can also include an Ethernet, or similar network, or any suitable physical communications infrastructure that satisfies an application's data transfer rate requirements. Communication infrastructure  includes the functionality to interconnect components including components of computing system .","In this example, OS  includes functionality to manage the hardware components of system  and to provide common services. In various embodiments, OS  can execute on CPU  and provide common services. These common services can include, for example, scheduling applications for execution within CPU , fault management, interrupt service, as well as processing the input and output of other applications.","In some embodiments, based on interrupts generated by an interrupt controller, such as interrupt controller , OS  invokes an appropriate interrupt handling routine. For example, upon detecting a page fault interrupt, OS  may invoke an interrupt handler to initiate loading of the relevant page into memory  and to update corresponding page tables.","OS  may also include functionality to protect system  by ensuring that access to hardware components is mediated through OS managed kernel functionality. In effect, OS  ensures that applications, such as applications , run on CPU  in user space. OS  also ensures that applications  invoke kernel functionality provided by the OS to access hardware and\/or input\/output functionality.","By way of example, applications  include various programs or commands to perform user computations that are also executed on CPU . The unification concepts can allow CPU  to seamlessly send selected commands for processing on the APD . Under this unified APD\/CPU framework, input\/output requests from applications  will be processed through corresponding OS functionality.","In one example, KMD  implements an application program interface (API) through which CPU , or applications executing on CPU  or other logic, can invoke APD  functionality. For example, KMD  can enqueue commands from CPU  to command buffers  from which APD  will subsequently retrieve the commands. Additionally, KMD  can, together with SWS , perform scheduling of processes to be executed on APD . SWS , for example, can include logic to maintain a prioritized list of processes to be executed on the APD.","In other embodiments of the present invention, applications executing on CPU  can entirely bypass KMD  when enqueuing commands.","In some embodiments, SWS  maintains an active list  in memory  of processes to be executed on APD . SWS  also selects a subset of the processes in active list  to be managed by HWS  in the hardware. Information relevant for running each process on APD  is communicated from CPU  to APD  through process control blocks (PCB) .","Processing logic for applications, OS, and system software can include commands specified in a programming language such as C and\/or in a hardware description language such as Verilog, RTL, or netlists, to enable ultimately configuring a manufacturing process through the generation of maskworks\/photomasks to generate a hardware device embodying aspects of the invention described herein.","A person of skill in the art will understand, upon reading this description, that computing system  can include more or fewer components than shown in . For example, computing system  can include one or more input interfaces, non-volatile storage, one or more output interfaces, network interfaces, and one or more displays or display interfaces.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 2","FIG. 1","FIG. 2","FIG. 2"],"b":["200","202","206","206","216","250","252","254","278","216","216"]},"Generally, an IOMMU can be connected to its own respective bus and I\/O device(s). In , a bus  may be any type of bus used in computer systems, including a PCI bus, an AGP bus, a PCI-E bus (which is more accurately a point-to-point interconnect), or any other type of bus or communications channel whether presently available or developed in future. Bus  may further interconnect interrupt controller , KMD , SWS , applications , and OS  with other components in system . Further, interconnect interrupt controller , KMD , SWS , applications , and OS  are substantially similar to interconnect interrupt controller , KMD , SWS , applications , and OS , as described herein, and are not described again.","The I\/O devices which may be connected to IOMMU  are further illustrated in . The I\/O devices interfacing architecture includes I\/O devices A, B, and C, represented by element numbers , , and . The I\/O device C also includes memory management I\/O (MMIO) maps and host data path (HDP)  device processing complex , private MMU , IOTLB , address translation service (ATS)\/peripheral request interface (PRI) request block , local memory , local memory protection map , and multiplexers , , , and .","The I\/O devices A, B, and C are representative of many types of I\/O devices including but not limited to APDs, expansion cards, peripheral cards, network interface controller (NIC) cards with extensive off-load capabilities, WAN interface cards, voice interface cards, and network monitoring cards. More than one I\/O device may be connected to each IOMMU through various bus configurations.","The system  illustrates high level functionality of the system, and the actual physical implementation may take many forms. For example, the MMU  is commonly integrated into each processor . The example illustrated in  may be based on the HyperTransport\u2122 (HT) coherent fabric between processor 's nodes and an HT I\/O link between processor 's nodes and I\/O device , , and  or any I\/O hubs (not shown) that bridge to other I\/O devices' interconnects.","Alternatively, any other coherent interconnect may be used between processor 's nodes and\/or any other I\/O interconnect may be used between processor nodes and the I\/O devices. Furthermore, another example may include processor  coupled to a northbridge, which is further coupled to memory  and one or more I\/O interconnects, in a traditional PC design.","Any of I\/O devices , , and  may issue a DMA operation (i.e. interrupt) that flows upwards through the IOMMU  where the DMA operation gets processed. Then the flow continues to the processor  which can include the memory controller  embedded therein.","At the time of connection of an I\/O device, if the IOMMU  is detected, software initiates a process of establishing the necessary control and data structures. For example, when IOMMU  is set up, the IOMMU  can include device table base register (DTBR) , command buffers base register (CBBR) , event log base register (ELBR) , control logic , and peripheral page request register (PPRR) . Further, during initial set-up, the IOMMU  can include an operator  for selecting the appropriate guest page table's base pointer register table. The base pointer register table can be, for example, a control register 3 (CR3) which is used by an x86 microprocessor process to translate physical addresses from virtual addresses by locating both the page directory and page tables for current tasks.","A guest CR3 (GCR3) change can establish a new set of translations and therefore the processor may automatically invalidate TLB  entries associated with the previous context. The GCR3 register operates to commence I\/O page table walker , if necessary, as discussed in U.S. Patent Application No. 61\/423,062, entitled \u201cInput\/Output Memory Management Unit Two-Layer Addressing,\u201d which is hereby incorporated by reference in its entirety. Also, the IOMMU  can be associated with one or more TLBs  for caching address translations that are used for fulfilling subsequent translations without needing to perform a page table walk. Addresses from a device table can be communicated to IOMMU  via bus .","Once the data structures are set up, the IOMMU  may begin to control DMA operation access, interrupt remapping, and address translation.","The IOMMU  can use memory management I\/O (MMIO) to indicate two-level translation is supported. When two-level translation is determined to be supported, the two-level translation is activated by programming the appropriate device table entries (DTE).","In nested paging, transactions associated with the DTE can include page table root pointers which point to the root of the data structures for I\/O page tables  in memory .","Accordingly, the IOMMU  can use a mapped guest pointer to access I\/O page tables by extending the device table entry to include GVA-to-GPA address translations. The GVA-to-GPA translation may be managed by the guest OS (hereinafter, \u201cL1\u201d translation).","Further, the IOMMU  may use a mapped system pointer to access I\/O page tables to perform GPA-to-SPA translations. The GPA-to-SPA translation can be managed by the hypervisor  (hereinafter, \u201cL2\u201d translation).","Accordingly a DTE comprising both types of pointers may be used to perform two layers of cascaded address translation walks.","The nested address space created by the L2 and L1 translation process allows for advance computation architectures in virtualization systems such as compute offload, user-level I\/O, and accelerated I\/O devices.","As illustrated in , IOMMU  is connected between memory  and I\/O devices , , and . Further, IOMMU  can be located on a separate chip from the memory , memory controller , and I\/O devices , , and . The IOMMU  may be designed to manage major system resources and can use I\/O page tables  to provide permission checking and address translation on memory accessed by I\/O devices. Also, I\/O page tables may be designed in the AMD64 Long format. The device tables  allow I\/O devices to be assigned to specific domains. The I\/O page tables  also may be configured to include pointers to the I\/O devices' page tables.","IOMMU  can be configured to thwart malicious DMA requests as a security and permission checking measure by remapping the unpermitted DMA requests. Further, regarding interrupt remapping, IOMMU  can also be configured to (i) redirect DMA requests to the correct memory locations and (ii) redirect DMA requests to the correct virtual or physical CPUs running the guest VMs. The IOMMU  also efficiently manages secure direct assignment of I\/O devices. The IOMMU  further uses interrupt remapping tables to provide permission checking and interrupt remapping for I\/O device interrupts","In one embodiment, the IOMMU  includes a guest virtual advanced programmable interrupt controller (APIC) construct (not shown). Another embodiment includes an IOMMU having architectural features designed to support the virtualized guest APIC.","The IOMMU  supports the delivery of interrupts directly to one or more concurrently running guests (e.g. guest VMs) without hypervisor intervention. In other words, the IOMMU  can provide translation services without the need of hypervisor . An exemplary IOMMU  signals interrupts using standard PCI INTx, MSI, or MSI-X interrupts.","System  also includes memory , which includes additional memory blocks (not shown). A memory controller  can be on a separate chip or can be integrated in the processor  silicon. Memory  is configured such that DMA and processor activity communicate with memory controller .","Memory  includes I\/O page tables , device tables , interrupt remapping table (IRT) , command buffers , event logs , and a host translation module such as hypervisor . Memory  can also include one or more guest OSs running concurrently, such as guest OS , represented by numeral , and guest OS  (). Hypervisor  and guest OSs  and  are software constructs that work to virtualize the system.","The guest Oss, such as guest OS  and guest OS , are more directly connected to I\/O devices such as I\/O devices , , and  in the system  because the IOMMU , a hardware device, is permitted to do the work that the hyper visor , under traditional approaches, would otherwise have to do.","Further, the IOMMU  and the memory  may be initialized such that DTBR  points to the starting index of device table . Further, CBBR  is associated with the starting index of command buffers  such that the IOMMU  can read and consume commands stored in the command buffer . The ELBR  points to the starting index of event logs . PPRR  points to the starting index of peripheral page service request (PPSR) tables .","The IOMMU  uses memory-based queues for exchanging command and status information between the IOMMU  and the system processor(s), such as CPU . The command queue is represented by command buffers  in . The command buffer  and event logs  are implemented by each active IOMMU . Also, each IOMMU  may implement an I\/O page service request queue.","When enabled, the IOMMU  intercepts requests arriving from downstream devices (which may be communicated using, for example, HyperTransport\u2122 link or PCI-based communications), performs permission checks and address translation on the requests, and sends translated versions upstream via the HyperTransport\u2122 link to memory  space. Other requests may be passed through unaltered.","The IOMMU  can read from tables in memory  to perform its permission checks, interrupt remapping, and address translations. To ensure deadlock free operation, memory accesses for device tables , I\/O page tables , and interrupt remapping tables  by the IOMMU  use an isochronous virtual channel and may only reference addresses in memory .","Other memory reads originated by the IOMMU  to command buffers , event log entries , and optional request queue entries (not shown) can use the normal virtual channel.","System performance may be substantially diminished if the IOMMU  performs the full table lookup process for every device request it handles. Implementations of the IOMMU  are therefore expected to maintain internal caches for the contents of the IOMMU 's in-memory tables. During operation, IOMMU  can use system software to send appropriate invalidation commands as it updates table entries that were cached by the IOMMU .","The IOMMU  writes to the event logs  in memory  with the ability to use the normal virtual channel. The IOMMU  can optionally write to a peripheral page service request queue  in memory . Writes to a peripheral page service request queue  in memory also can use the normal virtual channel.","The IOMMU  provides for a request queue in memory to service peripheral page requests while the system processor CPU  uses a fault mechanism. Any of I\/O devices , , and  can request a translation from the IOMMU  and the IOMMU  may respond with a successful translation or with a page fault.","In embodiments of the present invention, the IOMMU  can support two-level address translation for nested page tables, which are managed according the page tables. Example guest translations are directly compatible with AMD64 long page tables supporting 4 K byte, 2 M byte, and 1 G byte pages.","The IOMMU  handles requests for memory access and is implemented such that memory protections permit the IOMMU  to share translation table data. This translation table date can include nested page table data used by the IOMMU  and\/or MMU . IOMMU  can also be implemented such that sharing of translation tables is not permitted between the IOMMU  and the MMU .","Host OSs may also perform translations for I\/O device-initiated accesses. While the IOMMU  translates memory addresses accessed by I\/O devices, a host OS may set up its own page tables by constructing I\/O page tables that specify the desired translation. The host OS may make an entry in the device table pointing to the newly constructed I\/O page tables and can notify the IOMMU of the newly updated device entry. At this point, the corresponding IOMMU I\/O tables (e.g., from graphics or other I\/O devices) and the host OS I\/O tables may be mapped to the same tables.","Any changes the host OS performs on the page protection or translation may be updated in both the processor I\/O page tables and the memory I\/O page tables.","The IOMMU  is configured to perform I\/O tasks traditionally performed by exemplary hypervisor . This arrangement eliminates the need for hypervisor intervention for protection, isolation, interrupt remapping, and address translation. However, when page faults occur that cannot be handled by IOMMU , IOMMU  may request intervention by hypervisor  for resolution. However, once the conflict is resolved, the IOMMU  can continue with the original tasks, again without hypervisor intervention.","Hypervisor , also known as virtual machine monitor (VMM), uses the nested translation layer to separate and isolate guest VMs  and . I\/O devices such as I\/O devices , , and  can be directly assigned to any of the concurrently running guest VMs such that I\/O devices , , and  are contained to the memory space of any one of the respective VMs. Further, I\/O devices, such as I\/O devices , , and  are unable to corrupt or inspect memory or other I\/O devices belonging to the hypervisor  or another VM. Within a guest VM, there is a kernel address space and several process (user) address spaces. Using nested translation information, without using the guest translation layer, an I\/O device can be granted kernel privileges so that it has relatively free access to the entire contents of the guest VM memory.","To enable user-level (process) I\/O and advanced computation models, the guest translation layer is implemented for separation and isolation of guest processes and I\/O. Using guest translation in the IOMMU , any of the I\/O devices can be directly assigned to a process in a guest VM or an I\/O device, such as APD  or I\/O devices , , and , and can run computations in the same address space as a user process. The process address space can be identified to the IOMMU  so that the proper translation tables will be used. That is, each memory transaction can be tagged with a process address space ID (PASID). More specifically, an example PASID may be used to identify the application address space within an x86-canonical guest VM. The PASID can be used on an I\/O device, such as I\/O devices , , and , to isolate concurrent contexts residing in shared local memory .","A device ID can be used by IOMMU  to select the nested mapping tables for an address translation or interrupt remapping operation. Together, PASID and device ID are used to uniquely identify an application address space.","In a system that connects an I\/O device using an I\/O bus, a bus protocol can be extended to carry the originating PASID as well as device ID, address, and access type. In a PCI-SIG PCI-E specification, a PASID transaction layer packet (TLP) prefix of the bus packet carries the PASID information which can then used by the IOMMU  to select the appropriate guest CR3 GCR3 table, as represented by element number , and as discussed in the aforementioned U.S. Patent Application No. 61\/423,062. This ensures memory isolation among processes and VMs.","In systems that integrate I\/O devices onto the processor die, it is unnecessary to use an I\/O bus to connect I\/O devices to memory. In these cases, the PASID can simply be carried on wires or as a tag between the integrated I\/O devices and the integrated IOMMU. For software compatibility, it is recommended that integrated I\/O devices emulate ATS behavior and semantics. In either case, memory isolation is ensured among process and VMs.","Sophisticated, multi-context I\/O devices that include local memory, such as local memory  for performance or security, may offer the same memory isolation and separation guarantees provided by the IOMMU .","For the general architecture of such a device, reference is again made to , illustrating the system element CPU  and the IOMMU . Many parts of the I\/O devices are optional so multiplexers , , , and  are shown where functions may be by-passed. For example, an access to the system address space may either flow through an IOTLB  working with an ATS\/PRI unit , or it may flow directly to an IOMMU  for service. The device processing complex  may represent a general purpose APD, such as APD , I\/O devices such as I\/O devices , , and , or other specialized computational engine, as discussed herein.","In embodiment of the present invention, data access can originate with the CPU  or with the device processing complex . Data access can terminate in a local memory access from local memory  or in a system access from memory . In an exemplary implementation, IOTLB  functionality can be added that uses ATS for translation efficiency. PPR\/PRI support can be added for advanced function and efficiency. The ATS\/PRI advanced functionality is represented by element number . A peripheral may provide a private MMU such as private MMU  function for custom address translation and access control.","By way of example, implementation of peripheral local memory  can be unique to each device. Generally, however, this implementation desirably ensures that each device will preserve the following system properties:","1. Accesses from the device processing complex  to memory  are processed by the private MMU  or by the IOMMU  to enforce the policy required of the guest translation.","2. Accesses from the device processing complex  to memory  are processed by the IOTLB  (which may use ATS and\/or PRI requests ) or by the IOMMU  to enforce the policy required of the nested translation.","3. Accesses to peripheral local memory  from the CPU  or the device processing complex  are processed by the private MMU  to enforce the policy required of the guest translation.","4. Accesses to peripheral local memory  from the CPU  or the device processing complex  are processed by the local memory protection Map  to enforce the policy required of the nested translation.",{"@attributes":{"id":"p-0119","num":"0118"},"figref":["FIGS. 3A and 3B","FIG. 2"],"b":["314","312","314","312","224","331"]},"A GVA may be provided by an I\/O device issuing an address translation transaction (e.g., a request for ATS). Ultimately, the GVA may be translated to an SPA associated with accessing data byte .","The GCR3 table entry  includes a page-map level-4 (PML4) table address . Although the PML4 table address  corresponds to a root page table pointer , the PML4 table address  is in a format of a GPA. The systems  and  function together to perform a nested walk  to convert the PML4 table address  from the GPA format to the SPA format. The SPA corresponds to the system physical address of a root of the level-4 page table . Thus, the heavy black lines associated with, e.g., the root page table pointer , may represent an SPA obtained using a nested walk .","The level-4 page table  is identified using root page table pointer , and entries of the level-4 page table  are indexed using a page-map level-4 (PML4) offset . The PML4 offset  is associated with bits - of a GVA  that is to be translated. Accordingly, PML4 entry (PML4E)  is located using the root page table pointer , the level-4 page table , and the PML4 offset . When a guest attempts to reference memory using the GVA , because PML4E  is a GPA, systems  and  work together to convert PML4E  to an SPA using the nested walk .","To complete the nested walk , system  can be implemented using I\/O page table  structures set up in memory  to perform GPA-to-SPA conversions for each of the GPAs from the guest address translation table structure . For example, a GPA  may be loaded with the PML4E  for conversion to obtain a corresponding SPA for a root page table pointer . The GPA  includes offsets used to index the various tables of the system address translation table structure .","The nested walk  uses an nCR3  associated with a PML4E  to locate a root of page-map level-4 (PML4) table . A PML4 offset  (bits - of GPA ) is used to index into the PML4 table  and obtain the entry nPML4E . The nPML4E  points to a root of page directory pointer (PDP) table , and a PDP offset  (bits - of GPA ) is used to index into the PDP table  and obtain an entry nPDPE .","The nPDPE  points to the root of a page directory (PD) table , and a PD offset  (bits - of GPA ) is used to index into the PD table  and obtain an entry nPDE . The nPDE  points to a root of page table , and a PT offset  (bits - of GPA ) is used to index into the page table  and obtain an entry nPTE . The nPTE  points to the root of guest 4 KB memory page , and a physical page offset  (bits - of GPA ) is used to index into guest 4 KB memory page  and obtain an entry gPML4E . The gPML4E  is an SPA value corresponding to the GPA PML4E  and used by a root page table pointer  to locate a level-3 page table  in the guest address translation table structure .","The level-3 page table  is indexed using a PDP offset  to obtain a PDPE  (GPA format). The nested walk  is used to convert the GPA PDPE  into an SPA value corresponding to a root page table pointer . The root page table pointer  is used to locate a level-2 page table , which is indexed using a page-directory offset  (bits - of GVA ) to obtain a PDE  (GPA format). The nested walk  is used to convert the GPA PDE  into an SPA value corresponding to a root page table pointer .","In embodiments of the present invention, root page table pointer  is used to locate a level-1 page table , which is indexed using a page-table offset  (bits - of GVA ) to obtain a PTE  (GPA format). The nested walk  is used to convert the GPA PTE  into an SPA value corresponding to a root page table pointer . The root page table pointer  is used to locate the 4 Kbyte physical page , which is indexed using a physical page offset  (bits - of GVA ) to obtain the data byte .","Thus, systems  and  use nested cascades of page table walks to perform two-layer GVA-to-GPA and GPA-to-SPA address translations. Although two layers of nested address translation are shown, additional layers may be implemented using similar nested\/recursive calls. The translations associated with system address translation table structure  and guest address translation table structure  may be implemented in hardware. One set of hardware may be used for both sets of translations, although separate hardware may be provided for each set of the guest\/system translations.","As noted above, one of the challenges associated with conventional multiple processing device computing systems is the overhead associated with maintaining separate memory systems and\/or driver management related to shared memory systems. One example of this overhead in conventional multiple processing device systems is the requirement to accommodate two or more copy commands when sharing a single set of data between the multiple processing devices.",{"@attributes":{"id":"p-0130","num":"0129"},"figref":"FIG. 4","b":["400","402","406","206","104","250","252","254"]},"In addition to address translation, the IOMMU  provides access protection on DMA transfers by I\/O devices. Further, IOMMU  provides for secure user-level application to select I\/O devices. Also, IOMMU  provides for secure VMVM guest OS access to select I\/O devices.","The requirement to perform multiple copy commands, as illustrated in , creates unnecessary system overhead. For example, a separate bounce buffer, which can be viewed as a software construct, is usually required to accommodate multiple copy commands. Traditionally, bounce buffers are located in low system memory for DMA traffic for devices that do not support 64-bit addressing. The OS may copy DMA data to or from the bounce buffer to an actual buffer in high memory used by the I\/O driver. In an example, this technique requires system memory to copy data (e.g., image data), received from one processing device, to another processing device (or local I\/O device) memory  where it can be manipulated. Copying to local device memory  is represented by numeral . Numeral  represents an operation (e.g., computations, subroutine execution, or some functions) performed on the image data. As represented by numeral , when the operation is completed, the image data must then be copied back to system memory .","The IOMMU  may enable significant enhancements to system level software. For example, one enhancement provides for legacy 32-bit I\/O device support on 64 bit systems. This enhancement does not require bounce buffers and expensive memory copies. Thus, overhead associated with copy commands is reduced.",{"@attributes":{"id":"p-0134","num":"0133"},"figref":["FIG. 5","FIG. 4"],"b":"500"},"In , IOMMU , memory , guest OSs  and , and hypervisor  are each substantially similar to the IOMMU , memory , guest OSs  and , and hypervisor , respectively. Further, I\/O devices , , and  are substantially similar to APD  or other I\/O devices , , and . Thus, for convenience, the descriptions of similar elements in  will not be repeated.","Also in , numerals , , and  represent DMA requests sent by exemplary I\/O devices , , and , respectively. The nested paging transactions provided by IOMMU  provide for the exemplary I\/O devices , , and  to take some element of an operation (e.g., computations, subroutine execution, or some functions) and permit the system to efficiently accommodate the operation through direct manipulation.","In one exemplary embodiment, through direct manipulation the APD, or other I\/O device(s), can directly manipulate memory , which may contain the image data, while the image data is still in memory . This direct manipulation of memory  enables the memory , and the I\/O devices , , and  to operate out of the same guest virtual address space. In this example, IOMMU  can use mapped guest pointers to facilitate direct access to memory  by I\/O devices , , and . This eliminates the need for the memory  to first copy data (e.g., image data) to the I\/O devices , , and , prior to data manipulation or after completion of any operation on the data. Eliminating these additional copy maneuvers via direct memory manipulation, and other enhancements described herein, enables improved efficiency and reduction of overhead associated with data copies.",{"@attributes":{"id":"p-0138","num":"0137"},"figref":"FIG. 6","b":["600","600","606","616","687","206","216","254"]},"In one example, memory  includes event logs , command buffers , I\/O page tables , device tables , PPSR queue , interrupt remapping tables , guest OS , guest OS , and hypervisor . These elements are similar to those described in . An ATS request , ATS response , PRI request , and PRI response  are more detailed illustrations of ATS\/PRI , introduced in accordance with exemplary . Peripheral  can be configured to evaluate ATS responses as represented by numeral  and can be configured to evaluate PRI responses, as represented by numeral .","Another aspect of the present invention provides for an ATS used by peripheral  to translate a GPA to an SPA. In , an ATS provides secure, device-initiated address translations for virtualization. To translate a GPA to an SPA, a PCI-E-connected peripheral  issues an ATS request  (a PCI SIG Specification) with or without a PASID TLP prefix recognized by the IOMMU . IOMMU  evaluates access privileges using cached information from IOTLB  and\/or by walking the page tables using table walker , when required. The IOMMU  is configured to determine  the result of an ATS  request and the resulting access privileges are returned in the ATS response  without requiring intervention by the processor and\/or hypervisor .","Further, address translation services can be requested by peripheral  to translate a GVA or GPA to an SPA. To translate a GVA to an SPA, peripheral  connected by PCIe issues an ATS request  containing a valid PASID to present flags (e.g. access and dirty bit status) and a canonical virtual address. An integrated peripheral  may use means other than the ATS protocol to present flags and the virtual address, such as wire signals. The IOMMU  evaluates access privileges using IOTLB  cached information for efficiency, and can walk the page tables using table walker , when required. To match AMD64 semantics, the IOMMU can rewalk the guest page tables, I\/O Page Tables , if previously cached information indicates insufficient privileges for the access. The resulting access privileges are returned  in the ATS response . To carry the additional information for a guest address, the IOMMU  uses a PCIe TLP prefix containing a valid PASID.","The IOMMU  must update the accessed and dirty bits (not shown) in the GVA page table, I\/O page tables , while servicing an ATS request  as if the peripheral  had actually accessed memory. For the purpose of evaluating GVA accessed and dirty bits, the IOMMU  can use the access level indicated in the ATS packet (not shown) of ATS request . An ATS request  for read-only access can determine the accessed bit setting and an ATS request  for read-write access can determine the dirty bit setting. When processing a GPA, the IOMMU  can treat the page tables as read-only.","Further, software issues an INVALIDATE_IOTLB_PAGES command to cause the IOMMU  to generate an invalidation request to peripheral . An invalidation request sent downstream to the peripheral  lacks a valid PASID prefix when the contents are a GPA. An invalidation request sent downstream to peripheral  has a valid PASID prefix when the contents are a GVA and the PASID is in the PASID TLP prefix.","The conditions under which peripheral  with an IOTLB  must invalidate a cached translation entry that caused an insufficient-privilege failure and obtain a fresh translation using ATS are now explained.","Peripheral  can use address translation information from the IOTLB  or obtained via ATS to determine access privileges for a nested (host) access. As an AMD extension, peripheral , with IOTLB , can invalidate a cached entry causing an insufficient-privilege failure when both the access bit and the dirty bit are set to \u201c1\u201d in the IOTLB entry for a guest access. Peripheral  must then request the guest translation information using ATS and retry the access. If the revised privileges are insufficient for the retry, peripheral  must take appropriate action to abandon the access or issue a PCI-E PRI request  for escalated privileges.","In the case of ATS, the IOMMU  has all the information needed to determine  a result to send back in an ATS response . However, in the case of PRI, the PRI request is passed on to the guest OSs  and , the hypervisor , and\/or software (SW) to assist in determining  a result for PRI response . For example, PRI request  requires software policy decisions to be made by the guest OSs  and , and\/or the hypervisor . PRI, a PCI-Sig specification, allows peripheral  to request memory management services from exemplary VM block  (e.g., software).","Further, the IOMMU  optionally supports PRI specification as a complement to the PCI-SIG ATS specification. PRI offers peripheral page fault support in conjunction with ATS. The IOMMU  support for PRI is the PPR service.","In traditional systems, the OS is required to pin the memory pages used for I\/O. Pinned memory refers to memory pages that are to be maintained in real memory all the time. Pinning a memory page prohibits the pager from stealing the memory page for other uses. A memory page must typically be pinned before DMA starts and may be unpinned when DMA completes. The pinned pages are often allocated from a separate memory pool of limited capacity.","ATS and PRI can be used together to enable peripheral  to use unpinned pages for I\/O. When processing ATS requests , the IOMMU  does not signal errors when insufficient access privileges or not-present pages are detected. Instead, IOMMU  returns the permissions calculated from the I\/O page tables . Peripheral  examines the PRI response  to determine an appropriate action (e.g., use PRI to request system software to service a page table entry in I\/O page tables ). Use of peripheral page request service (PPR)\/PRI allows peripheral  to request the OS to change the access privileges of the I\/O page table  page. Use of ATS with PPR can allow a system to operate efficiently in a reduced memory footprint.","In exemplary operation of the present invention, IOMMU  is implemented to provide memory to peripheral  when no memory  is physically available to service a DMA job request. For example, if peripheral  sends ATS request  and the memory is not physically available in memory , typically a page fault may result. The page fault may be represented by a signal from command buffers  to IOMMU  in response to a memory access attempt via ATS_Calc .","Also, if peripheral  is ATS-capable, peripheral  can issue PRI requests  to IOMMU . PRI request  is received by the IOMMU , which sends signal  to system block  including the guest OS , guest OS , and hypervisor  in response to the PRI Request  since software policy  is needed to calculate the PRI Response . Hypervisor  takes priority over guest OSs  and  for handling IOMMU signal PRI_Calc , and has the first right of refusal to process PRI_Calc , prior to passing processing of PRI_Calc  over to the Guest OSs  and . If peripheral  sends PRI request  and the memory is not physically available in memory , typically a page may fault result. The page fault may be represented by a signal from command buffers  to IOMMU  in response to a memory access attempt via PRI_Calc .","If a page fault results, IOMMU  is configured to send ATS_Calc  or PRI_Calc  to the PPSR tables  (e.g. PPR Queue). This is because when the IOMMU  receives a valid PRI request , it creates a PPR message to request changes to the virtual address space. Software policies in place in the VM block  may resolve page fault issues by swapping in a page, allocating new pages, rejecting the request, upgrading security privileges, providing copy-on-write operations, or by any other accommodation for preventing a definitive page fault.","An IOMMU  that supports PPR may report PPI requests to the host software  by means of a shared circular buffer (not shown) in memory . The IOMMU  may write the I\/O device's PPR records into the buffer when enabled. The host software  increments the IOMMU 's PPR request log head pointer (not shown) to indicate to the IOMMU  that the host software  has exhausted PPR request log entries. When software  has completed processing the PPR requests , PPR queue  uses an IOMMU job completion command to inform the I\/O device  of the results.","When an IOMMU 's request to memory  for more memory is honored, one of the guest OSs  or  in virtual block  may copy a disk page (i.e. physical memory) into the memory  only if an attempt is made to access a page in memory  that is not physically present in memory  (i.e. an I\/O page table  page has not yet been loaded by the OS).","Generally, when an application  begins to process, none of its pages are in memory. It follows, many page faults may occur before the application 's essential pages necessary to carry out the DMA operation are loaded into memory  in connection with the PRI response . When the virtual memory block  operates to load only the necessary pages for the DMA operation, it follows that more processes in the virtual block  are permitted to be loaded as a consequence. When more processes are allowed to be loaded in virtual block , the amount of time needed for loading a GCR3 register, as discussed in the aforementioned U.S. Patent Application No. 61\/423,062, entitled \u201cInput\/Output Memory Management Unit Two-Layer Addressing,\u201d is reduced.","Once software policy  has been instituted by VM block , the command buffers  notify the IOMMU  as represented by arrow . The IOMMU  transmits an ATS response  or PRI response  to the IOMMU . Peripheral  evaluates the resulting ATS response  and PRI response , as represented by numerals  and , respectively. Or, the IOMMU  may write to the event logs  if there is no resolution, resulting in a definitive page fault.",{"@attributes":{"id":"p-0157","num":"0156"},"figref":"FIG. 7","b":["700","700","702","402","406","216"]},"Step  illustrates performing, by the I\/O device, an operation on the data in the memory based on the pointer. The IOMMU  can control the I\/O device  based on the pointers passed by the IOMMU . The I\/O device  accesses memory . This operation does not need to perform a copy operation  of data in the memory  into I\/O device 's local memory . There is also no need for a copy operation  of the data operated on  to be copied back to memory .","The Summary and Abstract sections may set forth one or more but not all exemplary embodiments of the present invention as contemplated by the inventor(s), and thus, are not intended to limit the present invention and the appended claims in any way.","The present invention has been described above with the aid of functional building blocks illustrating the implementation of specified functions and relationships thereof. The boundaries of these functional building blocks have been arbitrarily defined herein for the convenience of the description. Alternate boundaries can be defined so long as the specified functions and relationships thereof are appropriately performed.","The foregoing description of the specific embodiments will so fully reveal the general nature of the invention that others can, by applying knowledge within the skill of the art, readily modify and\/or adapt for various applications such specific embodiments, without undue experimentation, without departing from the general concept of the present invention. Therefore, such adaptations and modifications are intended to be within the meaning and range of equivalents of the disclosed embodiments, based on the teaching and guidance presented herein. It is to be understood that the phraseology or terminology herein is for the purpose of description and not of limitation, such that the terminology or phraseology of the present specification is to be interpreted by the skilled artisan in light of the teachings and guidance.","The breadth and scope of the present invention should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS\/FIGURES","p":["The accompanying drawings, which are incorporated herein and form part of the specification, illustrate the present invention and, together with the description, further serve to explain the principles of the invention and to enable a person skilled in the pertinent art to make and use the invention. Various embodiments of the present invention are described below with reference to the drawings, wherein like reference numerals are used to refer to like elements throughout.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
