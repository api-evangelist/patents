---
title: Cache regions
abstract: A cache region can be created in a cache in response to receiving a cache region creation request from an application. A storage request from the application can identify the cache region and one or more objects to be stored in the cache region. Those objects can be stored in the cache region in response to receiving the storage request.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08176256&OS=08176256&RS=08176256
owner: Microsoft Corporation
number: 08176256
owner_city: Redmond
owner_country: US
publication_date: 20090514
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application is a continuation-in-part of U.S. application Ser. No. 12\/363,505 filed on Jan. 30, 2009 entitled \u201cDISTRIBUTED CACHE ARRANGEMENT,\u201d and the entirety of that application is hereby incorporated by reference. This application also claims the benefit of U.S. Provisional Application No. 61\/061,017 filed on Jun. 12, 2008 entitled \u201cDISTRIBUTED CACHE\u201d, and the entirety of that application is hereby incorporated by reference.","A continuing problem in computer systems remains handling the growing amount of available information or data. The sheer amount of information being stored on disks or other storage media for databases in some form has been increasing dramatically. While files and disks were measured in thousands of bytes a few decades ago\u2014at that time being millions of bytes (megabytes), followed by billions of bytes (gigabytes)\u2014now databases of a million megabytes (terabytes) and even billions of megabytes are being created and employed in day-to-day activities.","With the costs of memory going down, considerably large caches can be configured on the desktop and server machines. In addition, in a world where hundreds of gigabytes of storage is the norm, the ability to work with most data in large caches can increase productivity and efficiency because the caches can be configured to retrieve data more quickly than the same data can be retrieved from many mass data stores. A cache is a collection of data that duplicates original value(s) stored elsewhere or computed earlier, where the cached data can be read from the cache in lieu of reading the original value(s). A cache is typically implemented where it is more efficient to read the cached data than to read the original value(s) so that use of the cache can increase the overall efficiency of computing systems.","In an effort to scale the size of caches in an organized manner, some caches are structured as distributed partitioned caches. A distributed cache is a cache that is distributed across one or more cache nodes. Typically, a distributed cache is distributed across one or more physical or virtual computing machines. A distributed partitioned cache is a cache that is partitioned across multiple cache nodes. As used herein, a node refers to a storage process in a cache storage system. A node may be on a single machine or spread across multiple physical machines, and a single physical machine may include multiple storage nodes, such as where a single physical machine hosts multiple virtual machine processes. Thus, the distributed partitioned cache is spread over multiple storage processes, so that the entire set of primary cache data to be read is not stored on a single process, and typically is not stored on a single machine. As used herein, the term \u201cprimary\u201d cache data indicates the data that is currently set up to be accessed, such as to be read from the cache, as opposed to secondary or replicated data that is currently being stored as a backup. The primary data may also be replicated from other data outside the data store. For example, in a distributed cache the primary data may be replicated from more authoritative data that is stored in long-term mass storage. The term \u201cprimary\u201d is similarly used to refer to a primary region, which is a region currently set up to be accessed, as opposed to a replica of the primary region. The term \u201cprimary\u201d can also be used to refer to a primary node, which is a node that stores the primary cache data, such as a primary region. Note, however, that a cache node can be a primary node for one set of cache data and a secondary node for another set of cache data. A distributed partitioned cache system is a system that is configured to implement distributed partitioned caches.","Whatever the advantages of previous caching tools and techniques, they have neither recognized the cache region tools and techniques described and claimed herein, nor the advantages produced by such tools and techniques.","In one embodiment, the tools and techniques can include receiving a cache region creation request at a distributed partitioned cache system that includes a distributed partitioned cache. A cache region of the cache can be created in response to receiving the request. The cache can be spread over a plurality of cache nodes, but the entire cache region can be stored in one of the nodes.","In another embodiment of the tools and techniques, a cache region can be created in a cache in response to receiving a cache region creation request from an application. A storage request from the application can identify the cache region and one or more objects to be stored in the cache region. Those objects can be stored in the cache region in response to receiving the storage request.","In yet another embodiment of the tools and techniques, a cache can be created in a cache system, and a cache region can be created in the cache. A plurality of cache items can be stored in the cache region. In response to receiving a cache region operation request that identifies the cache region, the cache system can operate on the cache region.","This Summary is provided to introduce a selection of concepts in a simplified form. The concepts are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter. Similarly, the invention is not limited to implementations that address the particular techniques, tools, environments, disadvantages, or advantages discussed in the Background, the Detailed Description, or the attached drawings.","Described embodiments are directed to techniques and tools for improved caching of computer information. Such improvements may result from the use of various techniques and tools separately or in combination.","The techniques and tools described herein can include using cache regions in a cache system, such as a distributed partitioned cache system. A cache region can include one or more cache items (also referred to herein as a cache object). A cache item includes a value, which is the data to be stored in the cache, and at least one associated identifier, such as a hash key, which can be used to identify the item. A region may also include an associated identifier, such as a hash key, to identify the region. The regions can be nested so that a region can include one or more cache items and\/or one or more sub-regions, and the sub-regions can in turn include one or more cache items and\/or one or more sub-regions. A cache can include one or more regions, and a cache system can include one or more caches. Each cache can include an associated identifier, such as a cache name. Each cache, cache region, and cache item may include associated metadata in addition to an associated identifier, such as tags or other metadata specifying how the corresponding cache, region, or item is to be handled by the cache system.","The use of such cache regions can provide increased efficiency in implementing and managing caches, such as distributed partitioned caches. For example, an application may want to store information for an on-line shopping cart in the cache. It can be useful to operate on single items in the shopping cart, such as representations of purchase items that have been selected by an on-line user. For example, a user may want to add or remove a single item from the shopping cart, and it can be more efficient to remove or add a single item than to replace the entire shopping cart in the cache. However, some operations on the shopping cart can be more efficient they are applied to the entire shopping cart. For example, at the end of an on-line session, it may be useful to delete the entire shopping cart from the cache. The shopping cart can be stored as a shopping cart cache region, and the shopping cart items can be stored as cache items in that region. Accordingly, operations can be done on the shopping cart items by making calls to operate on the particular corresponding cache items (e.g., create, read, update, delete). In addition, operations can be done on the entire shopping cart by making calls to operate on the shopping cart region as a whole (e.g., create, read, update, delete), rather making a separate call for each item in the shopping cart. Accordingly, the use of cache regions can provide increased efficiency and flexibility. However, neither the claims below nor the techniques discussed herein are limited to increased efficiency, flexibility, or other benefits described herein.","I. General Information Storage and Caching","Increasing advances in computer technology (e.g., microprocessor speed, memory capacity, data transfer bandwidth, software functionality, and the like) have generally contributed to increased computer use in various industries. Ever more powerful server systems, which are often configured as an array of servers, are often provided to service requests originating from external sources such as the World Wide Web, for example.","Various forms of storage devices allow information to be held over relatively a long period without information degradation. A common storage medium is flash memory; specifically, flash memory is a non-volatile form of storage that retains information without drawing upon a constant source of power. Such type of memory is often employed in a variety of consumer electronic devices such as memory cards, universal serial bus (USB), flash drives, personal data assistants (PDAs), digital audio players, digital cameras, mobile phones, and so forth.","Another common type of non-volatile storage medium is a magnetic disk, which enables information to be recorded according to a magnetization pattern. Similar to other storage media, magnetic disks can be configured in a variety of manners (e.g., Magneto resistive Random Access Memory) as well as employed in many different applications. This type of storage device is commonly used in connection with databases and analog recordings. Likewise, volatile forms of storage media exist that provide certain benefits that may also be accompanied by particular disadvantages. For example, retrieval times for volatile media are generally faster than that for non-volatile media, and many operations have increased uniformity due to well-established standards.","Moreover, today applications run on different tiers, in different service boundaries, and on different platforms (e.g. server, desktop, devices). For example, in a typical web application, many applications reside on a server supporting a large number of users; however, some client components of the application may run on desktops, mobile devices, and web browsers, and the like. Furthermore, advances in connectivity and cheap storage, combined with the complexity of software management, facilitate on-line services and software-as-a-service. In such services models, applications (and associated data) are typically hosted in central data centers (also sometimes referred to as the \u201ccloud\u201d) and are accessible and shared over the web.","The distributed applications may be accompanied by a large number of users, high performance, high throughput and fast response time. With such services orientation it may be desirable for the cost of service to be low, thereby making low-cost scalability and performance desirable as well.","A further challenge in implementing storage systems is support for distribution and heterogeneity of data and applications. Applications are composing (e.g. mashups) data and business logic from sources that can be local, federated, or cloud-based. Composite applications may use aggregated data that is shaped in a form that is most suitable for the application. Data and logic sharing is also a feature of many composite applications.","As explained earlier, data and applications can reside in different tiers with different semantics and access patterns. For example, data in back-end servers\/clusters or in the cloud tends to be authoritative; data on the wire is message oriented; data in the mid-tier is either cached data for performance or application session data; data on the devices could be local data or data cached from back-end sources. With the costs of memory going down, considerably large caches can be configured on the desktop and server machines. With the maturity of 64-bit hardware, 64-bit CPUs are becoming mainstream for client and server machines. True 64-bit architectures support 64-bit CPUs, data or address buses, virtual addressability and dramatically increase memory limits (to bytes). Operating systems (e.g. Windows, Linux) are also upgraded to support and take advantage of 64 bit address-space and large memories. For example, desktops can be configured with 16 GB RAM, and servers can be configured with up to 2 TB of RAM. Large memory caches can allow for data to be located close to the application, thereby providing significant performance benefits to applications. In addition, in a world where hundreds of gigabytes of storage is the norm, the ability to work with most data in memory (large caches) and easily shift from tables to trees to graphs of objects can be beneficial for programmer productivity for next generation applications.","II. General Cache Layering Arrangement","The memory capacity of multiple computers or processes can be aggregated into a single unified cache, which can be scalable (e.g., a dynamic scaling) to a plurality of machines via a layering arrangement. Such layering arrangement can cache serializable Common Language Runtime (CLR) objects and provide access through a simple cache application programming interface (API). The layering arrangement can include a data manager component, an object manager component and a distributed object manager component, which can be implemented in a modular fashion. In one aspect, the data manager component supplies basic data functions (e.g., hash functions), and the object manager component implements object facade thereon including cache objects\u2014while the distributed object manager provides distribution of the data in the distributed cache.","As such, the object manager component can map regions to containers and manage data eviction thresholds and supply policy management for cached data. Such regions can represent cache containers that typically guarantee co-locations of the object placed\/inserted in the container (e.g., co-locations of objects in same node). Additionally, the object manager component can raise notifications (e.g., due to changes made to cached data) for various regions or objects of the distributed cache. Likewise, the distributed object manager component can dispatch requests to various nodes associated with different regions of the distributed cache.","Moreover, the distributed object manager can interface with partition maps of the distributed cache for a given request, and can facilitate abstraction of the aggregated cache in the distributed environment, to a single unified cache. In one aspect, the distributed object manager component is positioned on top of the object manager component, which itself is placed on top of the data manager component. Moreover, tight integration can be provided with ASP.NET to enable cache ASP.NET session data in the cache without having to write it to source databases, for example.","These components can provide pluggable features that can readily adapt to a user's preferences (e.g., replacing a data manger component with another type thereof, based on user preferences). Likewise, the object manager component can be replaced with another object manager component, wherein plugging different models in the layering arrangement is enabled by enabling a call back mechanism with holding locks during call back throughout the stack.","In a related aspect, the layering arrangement can provide for a modular arrangement that facilitates operation on different levels and communication substrates (e.g., TCP\/IP), and which can be implemented in two topology models, namely as an independent separate tier model or an embedded application model. In the independent and separate tier model, the caching layer can function as an independent separate tier by itself (which can be positioned between application servers and data servers). For example, in such a configuration the distributed cache can run as a service hosted either by Windows Activation Services (WAS) or windows service, and can run separate from the application. The applications can either employ the client stubs provided by the distributed cache to talk thereto, or can communicate through a representational state transfer (REST) API directly into the service.","Alternatively, in the embedded application model the cache can be embedded within the application itself (e.g., connecting the applications together to form a cluster\u2014such as embedding caches in ASP.net instances to form a cluster of ASP.net machines, wherein upon storing an item in a local cache it can be viewed from other machines.) This embedding can further enable tagging and Language Integrated Query (LINQ) queries on the objects from a functionality perspective. LINQ queries can then be run natively on stored objects, and can be embedded in .Net applications.","The various aspects of the described tools and techniques will now be described with reference to the annexed drawings, wherein like numerals refer to like or corresponding elements throughout. However, the drawings and detailed description relating thereto are not intended to limit the claimed subject matter to the particular form disclosed. Rather, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the claimed subject matter. For example, cache regions may be implemented in an arrangement other than the disclosed layering arrangement.","III. Cache System & Tools","A. Cache Layering",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","131","133","100","110","112","114","114","112","110","110","112","114","112","110","114"]},"Moreover, a clustering substrate () can establish clustering protocols among a plurality of nodes that form a single unified cache. For example, when a node is to join or leave the cluster, requisite operations for adding or leaving the cluster can be managed, wherein a distributed components availability substrate () can employ such information to manage operations (e.g., monitoring health of nodes, managing life cycles of nodes, creating a primary node on another machine). In addition, for each node, each of the components forming the layering arrangement can be pluggable based on user preferences, system features, and the like.","As explained earlier, the data manager component () (e.g., in memory) can provide primitive high performance data structures such as hash tables, Btrees, and the like. Since the data manager component () can be memory bound and all operations of the distributed cache can be atomic, the data manager component () can typically implement highly concurrent hash tables. The data manager component () and the hash table structures can further facilitate creating the infrastructure for supplying containers and indexes on containers. In addition, the data manager component () can provide simple eviction and expiration on these hash structures. Due to pluggable features supplied by the layering arrangement (), users can plug in different types of data managers tailored to users' preferences, such as a transaction data manager or a disk paged data manager, or the like. Likewise, the object manager component () can provide object abstraction and can implement the concept of named caches and regions by employing data structures provided by the data manager component ().","Similarly, the distributed object manager component () can employ the local object manager component () and integrate with the distributed components availability substrate () to provide the abstraction of the distributed cache. The distributed components availability substrate () can provide the transport and data consistency operations to make the system scalable and available. The distributed object manager component () can optionally be implemented as part of a client tier to facilitate dispatching requests (e.g., directly) to the nodes associated with the single unified cache.","In one particular aspect, the distributed object manager component () can further include a dispatch manager component () and a distributed manager component (). The dispatch manager component () can further look up the routing table to dispatch the requests to a primary node (e.g., where a primary region is located) as part of a dynamically scalable distributed cache. Moreover, the dispatch manager component () can also be present in the client so that the client can directly dispatch requests to the primary node. For example, the distributed object manager component () on the receiving node can interact with a partition map to check if the node is indeed designated as the primary node as part of a plurality of nodes associated with the distributed cache, and can call the object manager component () to perform the operation. In the case of write operations, the distributed object manager component () can also communicate with a replicator to replicate the data to the secondary nodes. The distributed object manager component () can also interact with failover manager systems (not shown) to clone regions to create new secondary or primary nodes during reconfiguration procedures subsequent to possible failures.","The object manager component () can further include a notification management component () that can track changes to regions and objects, and can relay notifications to delegates listening to those events. Moreover, applications can also register delegates for notifications on any node which may be different from the primary node on which the object resides. The distributed object manager component () can further manage the propagation of notifications in a distributed fashion including providing high availability for such notifications when the primary node fails. For example, this can be handled by maintaining a local lookup table indexed by delegate id on the node where the application registers the delegate. The primary node that stores the object can maintain the delegate id and the originating node information. When an object changes, the distributed object manager component () of the primary node can notify all the originating nodes, passing along the delegate id.","Similarly, the distributed object manager component () associated with the receiver can employ the lookup table to call the appropriate delegate, thus providing the change information to the application in a distributed fashion. For example, notifications can be asynchronous and can further be backed up using the same secondary nodes. Accordingly, in the event of failures, the secondary nodes can attempt to deliver the pending notifications, wherein in the event of primary node failure, notifications can be resent because the primary node may not have synchronized the information regarding the delivered notifications before failure. Since all notifications can carry the region, key and version information, the application can use the version to ignore duplicate notifications. Following are some examples of callback syntax.","Example\u2014Region Level Callback",{"@attributes":{"id":"p-0051","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public delegate CacheCallback"]},{"entry":[{},"elec_cbk = new CacheCallback( myclass.handler );"]},{"entry":[{},"catalog.addCallback(\u201cElectronicsRegion\u201d, elec_cbk);"]},{"entry":[{},"Callback called for any updates to region"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Example\u2014Object Level Callback",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public delegate CacheItemRemovedCallback"},{"entry":"elec_cbk = new CacheItemRemovedCallback( );"},{"entry":"\/\/ Add the callback to the object ; the elec_cbk delegate will be called"},{"entry":"\/\/ whenever the object changes regardless of where the object is present"},{"entry":"catalog.Add(\u201cElectronicsRegion\u201d, \u201ckey\u201d, object, elec_cbk);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The availability substrate () can provide scalability and availability to systems that contain a storage component associated with the distributed cache. For example, the availability substrate can include load balancers, fail over managers, replicators and the like. A communication substrate () can provide for failure detection of nodes and reliable message delivery between nodes. The communication substrate () can interact with the availability substrate (). Moreover, the communication substrate () can also provide the communication channels and cluster management. The communication substrate () can provide callbacks whenever a new node joins the cluster or when a node dies or fails to respond to exchanged messages (e.g., heart beat messages). Moreover, the communication substrate () can provide efficient point-to-point and multicast delivery channels, and can further provide reliable message delivery for implementing replication protocols. For example, the communication substrate () can support notifications by maintaining delegate information in cache items and triggering the notification when items are modified. The communication substrate () can also trigger eviction based on policies defined at the region or named cache level.","B. Cache Topology",{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 2","FIG. 3","FIG. 2"],"b":["220","201","203","205"]},"Alternatively, in the embedded application model the cache system can be embedded within the application itself as illustrated in . Such can occur by connecting the applications (, , ) (1 to k, k being an integer) together to form a cluster; for instance as embedding caches in ASP.net instances to form a cluster of ASP.net machines, wherein upon storing an item in a local cache it can be viewed from other machines. For example, the distributed cache runtime dills can be compiled with the application and the application can act as the cache host for the distributed cache runtime. All the thread pools and memory can come from the application's container.","In a related aspect, a Load Balancer () can dynamically redistribute load across the cluster in the event that one or more nodes are inundated. For example, data can be repartitioned to spread it to nodes that have less loads. All such nodes can periodically send their load status as part of the configuration metadata. The load balancer () can also periodically query the configuration to determine which nodes are overloaded and can be balanced. For example, distributing the load may include repartitioning the overloaded partition of data on a primary node and spreading the overloaded partition to one (or more) of its secondary nodes. This may involve only a change in the configuration data (partition map) and no data movement (since the secondary nodes already have the data). In other scenarios, the data may be distributed to other non-secondary nodes since the secondary nodes themselves might be loaded and cannot handle the additional load. In such cases, either the data partitions on the secondary nodes (for which this node is the primary) can be further load balanced; or non-secondary nodes can be chosen to distribute the load, in which case in addition to the changes in the partition map, data can be moved.","C. Distributed Cache Structure with Regions",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 4","b":["400","410","411","412","410","411","412","422","423","410","411","412","433","433"]},"The following is a code example that shows the creation of a named cache and region.",{"@attributes":{"id":"p-0062","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ CacheFactory class provides methods to return cache objects"]},{"entry":[{},"\/\/ Create instance of cachefactory (reads appconfig)"]},{"entry":[{},"DataCacheFactory fac = new DataCacheFactory( );"]},{"entry":[{},"\/\/ Get a named cache from the factory"]},{"entry":[{},"DataCache catalog = fac.GetCache(\u201ccatalogcache\u201d);"]},{"entry":[{},"\/\/-------------------------------------------------------"]},{"entry":[{},"\/\/ Simple Get\/Put"]},{"entry":[{},"catalog.Put(\u201ctoy-101\u201d, new Toy(\u201cthomas\u201d, .,.));"]},{"entry":[{},"\/\/ From the same or a different client"]},{"entry":[{},"Toy toyObj = (Toy)catalog.Get(\u201ctoy-101\u201d);"]},{"entry":[{},"\/\/ ------------------------------------------------------"]},{"entry":[{},"\/\/ Region based Get\/Put"]},{"entry":[{},"catalog.CreateRegion(\u201ctoyRegion\u201d);"]},{"entry":[{},"\/\/ Both toy and toyparts are put in the same region"]},{"entry":[{},"catalog.Put(\u201ctoy-101\u201d, new Toy( .,.), \u201ctoyRegion\u201d);"]},{"entry":[{},"catalog.Put(\u201ctoypart-100\u201d, new ToyParts(...), \u201ctoyRegion\u201d);"]},{"entry":[{},"Toy toyObj = (Toy)catalog.Get(\u201ctoy-101\u201d, \u201ctoyRegion\u201d);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Each cache region () can include one or more cache items (). Each cache item can include an identifier such as a key (), a value or payload (), and one or more tags (). Cache regions may also be nested so that a cache region may include one or more other cache regions () and\/or one or more cache items ().","IV. Cache Layering Techniques",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 5","FIG. 5"],"b":"500"},"In the methodology (), cache available to the system can be identified (), wherein the cache can be scalable to a plurality of machines via a layering arrangement (e.g., dynamic scaling by adding new nodes). The cache can be aggregated () into a single unified cache, as presented to a user thereof. Applications\/data can be distributed () throughout the aggregated cache. In addition, the aggregated cache can be scaled () depending on the changing characteristics of the applications and\/or data.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 6","b":["600","610"]},"The data manager component can be employed () to supply basic data functions (e.g., hash functions). Likewise, the object manager component can be employed () as an object facade thereon including cache objects, with the distributed object manager component providing the distribution. As such, the object manager component and data manager component can act as local entities, wherein the distribution manager can perform () the distributions.","V. Unified Cache System & Data Types",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 7","b":["700","720","730","740","700","720"]},"A. Reference Data","Reference data is a version of the authoritative data. It is either a direct copy (version) of the original data or aggregated and transformed from multiple data sources. Reference data is practically immutable\u2014changing the reference data (or the corresponding authoritative data) creates a new version of the reference data. That is, every reference data version can be different from other reference data versions. Reference data is a candidate for caching; as the reference data typically does not change, it can be shared across multiple applications (users), thereby increasing the scale and performance.","For example, a product catalog application aggregating product information across multiple backend application and data sources can be considered. Most common operation on the catalog data is the read operation (or browse); a typical catalog browse operation iterates over a large amount of product data, filters it, personalizes it, and then presents the selected data to the users. Key based and query based access is a common form of operation. Caching can be beneficial for catalog access. If not cached, operations against such an aggregate catalog may include the operations to be decomposed into operations on the underlying sources, to invoke the underlying operations, to collect responses, and to aggregate the results into cohesive responses. Accessing the large sets of backend data for every catalog operation can be expensive, and can significantly impact the response time and throughput of the application. Caching the backend product data closer to the catalog application can significantly improve the performance and the scalability of the application. Similarly, aggregated flight schedules are another example of reference data.","Referenced data can be refreshed periodically, usually at configured intervals, from its sources, or refreshed when the authoritative data sources change. Access to reference data, though shared, is mostly read. Local updates are often performed for tagging (to help organize the data). To support large scale, reference data can be replicated in multiple caches on different machines in a cluster. As mentioned above, reference data can be readily cached, and can provide high scalability.","B. Activity Data","Activity data is generated by the currently executing activity. For example, the activity may be a business transaction. The activity data can originate as part of the business transaction, and at the close of the business transaction, the activity data can be retired to the backend data source as historical (or log) information. For example, the shopping cart data in an online buying application can be considered. There is one shopping cart, which is exclusive, for each online buying session. During the buying session, the shopping cart is cached and updated with products purchased, wherein the shopping cart is visible and accessible only to the buying transaction. Upon checkout, once the payment is applied, the shopping cart is retired (from the cache) to a backend application for further processing. Once the business transaction is processed by the backend application, the shopping cart information is logged for auditing (and historical) purposes.","While the buying session is active, the shopping cart is accessed both for read and write; however, it is not shared. This exclusive access nature of the activity data makes it suitable for distributed caching. To support large scalability of the buying application, the shipping carts can be distributed across the cluster of caches. Since the shopping carts are not shared, the set of shopping carts can be partitioned across the distributed cache. By dynamically configuring the distributed cache, the degree of scale can be controlled.","C. Resource Data","Both reference (shared read) and activity (exclusive write) data can be cached. It is to be appreciated that not all application data falls into these two categories. There is data that is shared, concurrently read and written into, and accessed by large number of transactions. For example, considering inventory management application, the inventory of an item has the description of the item and the current quantity. The quantity information is authoritative, volatile, and concurrently accessed by large number of users for read\/write. Such data is known as the resource data; the business logic (e.g. the order application logic) runs close to the resource data (e.g. quantity data). The resource data is typically stored in the backend data stores. However, for performance reasons it can be cached in the application tier. While caching the quantity data in memory on a single machine can provide performance improvements, a single cache typically cannot provide availability or scale when the order volume is high. Accordingly, the quantity data can be replicated in multiple caches across the distributed cache system.","VI. Distributed Cache with Artificial Intelligence Component",{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 8","b":["830","800","830"]},"The AI component () can employ any of a variety of suitable AI-based schemes as described supra in connection with facilitating various aspects of the herein described tools and techniques. For example, a process for learning explicitly or implicitly how or what candidates are of interest, can be facilitated via an automatic classification system and process. Classification can employ a probabilistic and\/or statistical-based analysis (e.g., factoring into the analysis utilities and costs) to prognose or infer an action that a user desires to be automatically performed. For example, a support vector machine (SVM) classifier can be employed. Other classification approaches include Bayesian networks, decision trees, and probabilistic classification models providing different patterns of independence can be employed. Classification as used herein also is inclusive of statistical regression that is utilized to develop models of priority.","As will be readily appreciated from the subject specification, classifiers can be explicitly trained (e.g., via a generic training data) as well as implicitly trained (e.g., via observing user behavior, receiving extrinsic information) so that the classifier can be used to automatically determine according to a predetermined criteria which answer to return to a question. For example, with respect to SVM's that are well understood, SVM's are configured via a learning or training phase within a classifier constructor and feature selection module. A classifier is a function that maps an input attribute vector, x=(x, x, x, x, xn), to a confidence that the input belongs to a class\u2014that is, f(x)=confidence(class). Moreover, a rule based mechanism can further be employed for interaction of a routing manager and a routing layer associated therewith (e.g., load balancing, memory allocation and the like).","VII. Suitable Computing Environment","The word \u201cexemplary\u201d is used herein to mean serving as an example, instance or illustration. Any aspect or design described herein as \u201cexemplary\u201d is not necessarily to be construed as preferred or advantageous over other aspects or designs. Similarly, examples are provided herein solely for purposes of clarity and understanding and are not meant to limit the subject innovation or a portion thereof in any manner. It is to be appreciated that a myriad of additional or alternate examples could have been presented, but have been omitted for purposes of brevity.","Furthermore, all or portions of the described tools and techniques can be implemented as a system, method, apparatus, or article of manufacture using standard programming and\/or engineering techniques to produce software, firmware, hardware or any combination thereof to control a computer to implement the disclosed tools and techniques. For example, computer readable storage media can include but are not limited to magnetic storage devices (e.g., hard disk, floppy disk, magnetic strips . . . ), optical disks (e.g., compact disk (CD), digital versatile disk (DVD) . . . ), smart cards, and flash memory devices (e.g., card, stick, key drive . . . ). Additionally a carrier wave can be employed to carry computer-readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network (LAN). Of course, those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.","In order to provide a context for the various aspects of the disclosed subject matter,  as well as the following discussion are intended to provide a brief, general description of a suitable environment in which the various aspects of the disclosed subject matter may be implemented. While the subject matter has been described above in the general context of computer-executable instructions of a computer program that runs on a computer and\/or computers, those skilled in the art will recognize that the tools and techniques also may be implemented in combination with other program modules.","As used in this application, the terms \u201ccomponent\u201d, \u201csystem\u201d, and \u201cengine\u201d are intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component can be, but is not limited to being, a process running on a processor, a processor, an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a server and the server can be a component. One or more components can reside within a process and\/or thread of execution, and a component can be localized on one computer and\/or distributed between two or more computers.","Generally, program modules include routines, programs, components, data structures, and the like, which perform particular tasks and\/or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the innovative methods can be practiced with other computer system configurations, including single-processor or multiprocessor computer systems, mini-computing devices, mainframe computers, as well as personal computers, hand-held computing devices (e.g., personal digital assistant (PDA), phone, watch . . . ), microprocessor-based or programmable consumer or industrial electronics, and the like. The illustrated aspects may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. However, some, if not all aspects of the tools and techniques can be practiced on stand-alone computers. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","With reference to , an exemplary environment () for implementing various aspects of the described tools and techniques is described that includes a computer (). The computer () can include a processing unit (), a system memory (), and a system bus (). The system bus () can couple system components including, but not limited to, the system memory () to the processing unit (). The processing unit () can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit ().","The system bus () can be any of several types of bus structure(s) including the memory bus or memory controller, a peripheral bus or external bus, and\/or a local bus using any variety of available bus architectures including, but not limited to, 11-bit bus, Industrial Standard Architecture (ISA), Micro-Channel Architecture (MSA), Extended ISA (EISA), Intelligent Drive Electronics (IDE), VESA Local Bus (VLB), Peripheral Component Interconnect (PCI), Universal Serial Bus (USB), Advanced Graphics Port (AGP), Personal Computer Memory Card International Association bus (PCMCIA), and Small Computer Systems Interface (SCSI).","The system memory () can include volatile memory () and\/or nonvolatile memory (). The basic input\/output system (BIOS), containing the basic routines to transfer information between elements within the computer (), such as during startup, can be stored in nonvolatile memory (). By way of illustration, and not limitation, the nonvolatile memory () can include read only memory (ROM), programmable ROM (PROM), electrically programmable ROM (EPROM), electrically erasable ROM (EEPROM), or flash memory. The volatile memory () can include random access memory (RAM), which can act as external cache memory. By way of illustration and not limitation, RAM is available in many forms such as synchronous RAM (SRAM), dynamic RAM (DRAM), synchronous DRAM (SDRAM), double data rate SDRAM (DDR SDRAM), enhanced SDRAM (ESDRAM), Synchlink DRAM (SLDRAM), and direct Rambus RAM (DRRAM).","Computer () can also includes removable\/non-removable, volatile\/nonvolatile computer storage media.  illustrates a disk storage (), wherein such disk storage () can include, but is not limited to, devices like a magnetic disk drive, floppy disk drive, tape drive, Jaz drive, Zip drive, LS-60 drive, flash memory card, or memory stick. In addition, disk storage () can include storage media separately or in combination with other storage media including, but not limited to, an optical disk drive such as a compact disk ROM device (CD-ROM), CD recordable drive (CD-R Drive), CD rewritable drive (CD-RW Drive) or a digital versatile disk ROM drive (DVD-ROM). To facilitate connection of the disk storage () to the system bus (), a removable or non-removable interface is typically used, such as interface ().","It is to be appreciated that  describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment (). Such software can include an operating system (). The operating system (), which can be stored on disk storage (), can act to control and allocate resources of the computer (). System applications () can take advantage of the management of resources by operating system () through program modules () and program data () stored either in system memory () or on disk storage (). It is to be appreciated that various components described herein can be implemented with various operating systems or combinations of operating systems.","A user can enter commands or information into the computer () through input device(s) (). Input devices () include, but are not limited to, a pointing device such as a mouse, trackball, stylus, touch pad, keyboard, microphone, joystick, game pad, satellite dish, scanner, TV tuner card, digital camera, digital video camera, web camera, and the like. These and other input devices connect to the processing unit () through the system bus () via interface port(s) (). Interface port(s) () include, for example, a serial port, a parallel port, a game port, and a universal serial bus (USB). Output device(s) () use some of the same type of ports as input device(s) (). Thus, for example, a USB port may be used to provide input to computer (), and to output information from computer () to an output device (). Output adapter () is provided to illustrate that there are some output devices () like monitors, speakers, and printers, among other output devices () that utilize such adapters. The output adapters () include, by way of illustration and not limitation, video and sound cards that provide a means of connection between the output device () and the system bus (). Other devices and\/or systems of devices provide both input and output capabilities such as remote computer(s) ().","Computer () can operate in a networked environment using logical connections to one or more remote computers, such as remote computer(s) (). The remote computer(s) () can be a personal computer, a server, a router, a network PC, a workstation, a microprocessor based appliance, a peer device or other common network node and the like, and typically includes many or all of the elements described relative to the computer (). For purposes of brevity, only a memory storage device () is illustrated with remote computer(s) (). Remote computer(s) () is logically connected to the computer () through a network interface () and then physically connected via a communication connection (). The network interface () encompasses communication networks such as local-area networks (LAN) and widearea networks (WAN). LAN technologies include Fiber Distributed Data Interface (FDDI), Copper Distributed Data Interface (CDDI), Ethernet\/IEEE 802.3, Token Ring\/IEEE 802.5 and the like. WAN technologies include, but are not limited to, point-to-point links, circuit switching networks like Integrated Services Digital Networks (ISDN) and variations thereon, packet switching networks, and Digital Subscriber Lines (DSL).","A communication connection(s) () refers to the hardware\/software employed to connect the network interface () to the bus (). While the communication connection () is shown for illustrative clarity inside computer (), it can also be external to the computer (). The hardware\/software for connection to the network interface () includes, for exemplary purposes only, internal and external technologies such as, modems including regular telephone grade modems, cable modems and DSL modems, ISDN adapters, and Ethernet cards.",{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIG. 10","b":["1000","1000","1010","1010","1000","1030","1030","1030","1010","1030","1000","1050","1010","1030","1010","1060","1010","1030","1040","1030"]},"VIII. Cache Regions","Cache regions and various uses for cache regions in a cache system will now be discussed in more detail.","A. Cache Region Mapping","Referring now to , a cache region mapping technique will be discussed. In the technique, cache item metadata () can include an item key () for each item. The item key () can be an item name, a numerical key, or some other type of identifier corresponding to the item. Additionally, the item metadata () for each item can include a region key (), which can be a name of the corresponding region. The item metadata can be provided by an application that is outside the cache system, such as one of the applications (, , , , , or ) discussed above. For example, the application can make a put API call to a cache manager in the cache system, such as one of the examples discussed above: catalog.Put(\u201ctoyRegion\u201d, \u201ctoy-\u201d, new Toy(.,.)). This API call requests that the cache system put, or store, the cache item sent with the call in the cache region having a region key \u201ctoyRegion\u201d in the cache named \u201ccatalog\u201d. The API call also specifies the item key \u201ctoy-\u201d corresponding to the cache item to be stored.","The region may have been created previously in an express region creation request, such as the one discussed above: catalog.CreateRegion(\u201ctoyRegion\u201d). Alternatively, a region can be created in response to an implicit region creation request. For example, if a region having a region key \u201ctoyRegion\u201d had not yet been created in the \u201ccatalog\u201d cache, then the API call \u201ccatalog.Put(\u201ctoyRegion\u201d, \u201ctoy-\u201d, new Toy(.,.))\u201d could be interpreted by the cache system as a request to create a new region with the region key \u201ctoyRegion\u201d in the \u201ccatalog\u201d cache, and to put the item corresponding to the key \u201ctoy-\u201d in the new region.","As discussed above, in some instances an application may not specify a region for an item to be stored in a cache, even if the cache system is capable of utilizing regions. For example, an application may make an API call as follows: catalog.Put(\u201ccust-\u201d, new Toy(.,.)), requesting the cache system to put the \u201ccust-\u201d cache item in the \u201ccatalog\u201d cache, but not specifying a region. Even if a region is not specified by an application, the cache system may still store an item specified by the application in a region, such as a default region. Alternatively, the cache system may only place items in regions if the regions are specified in a put request.","Referring still to , for items that are to be stored in regions, the cache system can bucketize () the corresponding item keys () into the corresponding cache regions specified by cache region keys (), such as cache region names. In other words, the cache system can assign the item keys () to corresponding region keys (), such as in a table. In some situations, regions may be empty, having been created but not yet having items assigned to them. In other situations, regions may include one or more cache items. In addition, regions may be nested, so that a region can include one or more cache items and\/or one or more cache regions.","In the example illustrated in , the item keys \u201cCUST-\u201d \u201cCUST-\u201d and \u201cCUST-\u201d have no specified region, but are bucketized () into a region having a region key \u201cDEFAULT REGION \u201d, and the keys \u201cCUST-\u201d and \u201cCUST-\u201d are bucketized () into a region having a region key \u201cDEFAULT REGION .\u201d The item keys \u201cTOY-\u201d and \u201cTOY-\u201d correspond to region key () \u201cTOYREGION\u201d and they are bucketized () into the \u201cTOYREGION\u201d region. Likewise, the item key \u201cBOX-\u201d has a corresponding region key () \u201cBOXREGION\u201d and it is bucketized () into the \u201cBOXREGION\u201d region.","The region names or keys can be hashed () into region identifiers or hash keys (), and partitions of the partitioned distributed cache can be specified as ranges () of those hash keys (). Hashing () can be done with a standard hashing function that will produce hash keys suitable for arranging in ranges. The partition region hash key ranges () can each be mapped to a corresponding primary node () in the cache cluster, and the items in those regions will be stored in the corresponding assigned nodes. A hash table or some other data structure can indicate the correspondence between item keys, region keys, region hash keys, partitions, and nodes. Thus, each region can be assigned to a single partition and the entire region can be co-located or stored on a single cache node.","Bucketizing () item keys () into regions, hashing () region keys () into hash keys (), and mapping () partition ranges () of hash keys to nodes () can be done by the data manager component () discussed above with reference to  or by some other component. The cache items can then be stored and maintained in the assigned nodes () of the distributed partitioned cache.","Alternatively, some other technique could be utilized for assigning cache item keys to region keys, and then assigning or mapping those region keys to cache nodes. For example, a function other than a hash function could be used to produce the partition ranges of region identifiers. Indeed, the regions corresponding to particular nodes could be specified in some way other than by specifying ranges, such as by mapping cache region names to particular cache nodes.","B. Cache Region Techniques","The following techniques can be implemented in cache systems and computing environments such as those discussed above or in some other cache systems and\/or computing environments. Referring now to , a cache region storage technique will be described. In the technique, a cache region creation request can be received (). For example, the cache region creation request can be received () at a cache system, and it can be received from an application outside the cache system. An application can still be considered to be outside the cache system if components of the cache system are embedded in applications in the cluster. The cache region creation request may be an explicit creation request that explicitly requests the cache system to create the region. Alternatively, the cache region creation request may be an implicit creation request from which a cache system can infer that the creation of a cache region is being requested.","In response to receiving () the cache region creation request, the cache region can be created (). For example, the cache system can associate the region with an identifier, and assign the region to a particular cache node, such as by including the cache region in a particular cache partition that is in turn assigned to a particular cache node. The cache node may correspond to a particular physical or virtual computer machine so that the entire region is prevented from being spread across multiple computer machines. The cache region can be stored () in the assigned cache node. Of course, the cache region may later be assigned to a different cache node. Also, the region is still considered to be stored on a single primary cache node if the region is also replicated on a secondary cache node that is different from the primary cache node.","Referring to , a cache region operation technique will be described. A cache can be created (), such as by defining a named distributed partitioned cache in a cache system. The cache system can be part of a computer system that also hosts a running application. A cache region can be created () in the cache, and cache items can be stored () in the cache region.","In addition, a region operation request can be received (), and the region can be operated () on in response to the region operation request. A region operation request is a request for one or more operations to be performed on a specified region, but it can be any of a wide variety of requests.","For example, the region operation request can be a bulk write request that includes a plurality of identified cache items to be stored in the region, and the operation () on the cache region can include storing the plurality of identified cache items in the region. Cache insertion APIs can take a list of items to be inserted into the region and all items in the region can be co-located in one storage process, so the entire list of items can be sent in bulk (or in chunks as needed) to the cache machine. This can save network overhead, as compared to doing individual inserts for each cache item. In addition, the entire insertion can be completed before the region is made accessible for read (get) operations. For example, the region may be made accessible by attaching the region hash table to the internal cache metadata structures. Doing this for the entire region at one time can guarantee atomicity of the insert, which can be useful when it is desirable for the entire contents of a region to be present for consistency reasons.","As another example, the request can be a request to delete the region (e.g., \u201cCache.DeleteRegion(String regionName)\u201d), and the operation () can include deleting the region in a single operation, rather than sending delete requests and performing delete operations for each item in the region. In an implementation where the cache includes a replica of the cache region (such as in a high availability scenario), the cache region operation request can be a request to delete the cache region, and the operation () on the cache region can include deleting the cache region and the replica of the cache region (such as by distributing the logical region delete operation to the secondary nodes, as opposed to sending every individual item deletion).","As another example, the cache region operation request can include a get request, and the operation () on the cache region can include sending all the cache items in the cache region to the application that sent the request. In yet another example, the cache region operation request can include a request to store metadata corresponding to the region in a persistent state, and the operation () on the cache region can include storing the metadata in a persistent state.","In yet another example, the cache region operation request can be a request to replace one or more items in the region, and the operation () on the cache region can include locking the entire region and replacing the one or more items. This can help to provide atomicity of read operations, so that a read will fail or succeed for the entire region. As noted above, this can be useful when the entire contents of the region must be present for consistency reasons.","Optimistic concurrency at the region level can be achieved by attaching a version number to the primary region in the cache. This version number can be updated atomically when create, update, or delete operations are performed on the primary region. This version number can be supplied to requesting applications in response to GetCacheItem requests as a RegionVersion property. When an application sends a PutCacheItem request along with an updated cache item, this RegionVersion property may be supplied along with the request. If the RegionVersion sent with the PutCacheItem request is the same as the current RegionVersion for the primary region, then this indicates that the region has not been modified since the application received the item from the cache, and the update can be performed. If the RegionVersion sent with the PutCacheItem request does not match the current RegionVersion for the primary cache region, then this indicates that the region was modified after the item was sent to the application, and the PutCacheItem request can result in a failure. The cache version can be checked before performing a variety of different types of operations, such as bulk write operations, delete operations, get or read operations, operations that store cache metadata in a persistent state, and replacement operations. This can help to provide region level consistency of operations. Accordingly, in yet another example of a cache region operation request, the request can include a request version identifier. In this example, the operation () on the cache region can include comparing the request version identifier with a region version identifier associated with the primary region in the cache, and operating on the region if the request version identifier matches the region version identifier. If the request version identifier does not match the region version identifier, then the requested operation may not be performed, and a failure notification may be sent in response to the request.","Referring to , yet another cache region technique will be described. In this technique, a plurality of cache items can be maintained () in a cache, such as a distributed partitioned cache in a cache system. The cache system can be part of a computer system that also includes a running application. A region creation request can be received (), such as being received from the running application. A cache region in the cache can be created () in response to receiving () the region creation request.","One or more cache items can be stored () in the region, such as in response to receiving a storage request from the application. For example, the storage request can identify the cache item(s) to be stored and the region where the cache item(s) are to be stored. Identifying the region(s) or item(s) can include identifying them explicitly by name or by some alternative. Alternatively, identifying could be done implicitly. For example, a storage request could identify a number of cache items to be stored, and could specify, either implicitly or explicitly, that those cache items be stored in a single region.","The technique of  may also include maintaining () a local cache, such as maintaining the local cache on a machine running the application. The local cache can store a replica of the region, and maintaining the local cache can include invalidating the entire region in the local cache in a single operation. For example, this could be done in response to changes being made to one or more items in the primary region in the main cache (i.e., in the primary storage location of the region in the cache) or in some other storage location, such as a permanent storage location that stores information corresponding to information in the region.","The technique of  can also include operating () on the region. For example, operating () on the region can include expiring the region in a single region expiration operation, evicting the region in a single region eviction operation, or automatically deleting the cache region when all cache items in the cache region have been deleted. For example, when a cache region is created a call can be made with the following syntax: \u201cCache.CreateRegion(String RegionName, Timespan DefaultRegionExpiration, Boolean AllowExpirationOfItems, Boolean AllowEvictionOfItems)\u201d. If the Boolean expressions for expiration of items (\u201cBoolean AllowExpirationOfItems\u201d) and eviction of items (\u201cBoolean AllowEvictionOfItems\u201d) within a region is set to false, then the entire region can be considered for eviction from the cache, such as based on least recently used (LRU) policies. A component of the cache system, such as a data manager component, can record one last accessed time on the region container for the last time that any item in the region was accessed, instead of tracking the last accessed times for each cache item in the region. This allows the eviction algorithm to include the region container in the eviction chain, as opposed to including each cache item in the eviction chain. In addition, if the expiration of items is allowed for the region, then a default time (\u201cTimespan DefaultRegionExpiration\u201d) for expiration of cache items in the region can be specified by an application that requests creation of the region.","Also in the technique of , the cache can be spread across a plurality of computer machines or nodes, and the technique can include co-locating the entire cache region in one of the plurality of machines or nodes.","What has been described above includes various exemplary aspects. It is, of course, not possible to describe every conceivable combination of components or methodologies for purposes of describing these aspects, but one of ordinary skill in the art may recognize that many further combinations and permutations are possible. Accordingly, the aspects described herein are intended to embrace all such alterations, modifications and variations that fall within the spirit and scope of the appended claims. Furthermore, to the extent that the term \u201cincludes\u201d is used in either the detailed description or the claims, such term is intended to be inclusive in a manner similar to the term \u201ccomprising\u201d as \u201ccomprising\u201d is interpreted when employed as a transitional word in a claim."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
