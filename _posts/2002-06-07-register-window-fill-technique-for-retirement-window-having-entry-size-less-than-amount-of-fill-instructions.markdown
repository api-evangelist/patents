---
title: Register window fill technique for retirement window having entry size less than amount of fill instructions
abstract: A register window fill technique for a retirement window having an entry size less than a number of fill instructions used in a fill condition is provided. The technique uses modified fill instructions that allow the retirement window to retire a portion of the fill instructions without having to determine whether a remaining portion of the fill instructions will execute without exceptions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07035999&OS=07035999&RS=07035999
owner: Sun Microsystems, Inc.
number: 07035999
owner_city: Santa Clara
owner_country: US
publication_date: 20020607
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["A typical computer system includes at least a microprocessor and some form of memory. The microprocessor has, among other components, arithmetic, logic, and control circuitry that interpret and execute instructions necessary for the operation and use of the computer system.  shows a typical computer system  having a microprocessor , memory , integrated circuits  that have various functionalities, and communication paths , i.e., buses and signals, that are necessary for the transfer of data among the aforementioned components of the computer system .","A microprocessor, such as the one shown in , typically includes an integer unit and a floating point-unit, each with its own registers. This organization allows for implementations with concurrency between integer and floating-point instruction execution. Typically, the integer unit contains general-purpose registers and controls the overall operation of the microprocessor. The integer unit executes the integer arithmetic instructions and computes memory addresses for loads and stores. The integer unit also maintains the program counter and controls instruction execution for the floating-point unit.","In an exemplary implementation of an integer unit, the integer unit may contain 64 to 528 general-purpose 64-bit r registers (an r register is an integer register and is also known in the art as a \u201cgeneral-purpose register\u201d or \u201cworking register\u201d). They are partitioned into 8 global registers, 8 alternate global registers, 8 MMU global registers, 8 interrupt global registers, plus an implementation-dependent number of 16-register sets. As shown in Table 1, a \u201cregister window\u201d consists of the current 8 in registers, 8 local registers, and 8 out registers.",{"@attributes":{"id":"p-0005","num":"0004"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Window Addressing"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Windowed Register","r Register"]},{"entry":[{},"Address","Address"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"in[0]\u2013in[7]","r[24]\u2013r[31]"]},{"entry":[{},"local[0]\u2013local[7]","r[16]\u2013r[23]"]},{"entry":[{},"out[0]\u2013out[7]","r[8]\u2013r[15]"]},{"entry":[{},"global[0]\u2013global[7]","r[0]\u2013r[7]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"At any time, an instruction may access the 8 global registers and a 24-register window into the r registers. A register window comprises the 8 in and 8 local registers of a particular register set together with the 8 in registers of an adjacent register set, which are addressable from the current window as out registers.","As an example of register windowing,  shows a 5 register window architecture . As those skilled in the art will understand, although  shows a 5 register window scheme, the number of windows or register sets is implementation-dependent. The total number of r registers in a given implementation is 8 (for the global registers), plus 8 (for the alternate global registers), plus 8 (for the MMU global registers), plus 8 (for the interrupt global registers), plus the number of sets multiplied by 16 registers\/set.","A current window into the r registers is given by the current window pointer (CWP) register. The CWP is decremented by a RESTORE instruction and is incremented by a SAVE instruction. Window overflow is detected via a CANSAVE register and window underflow is detected via a CANRESTORE register. More specifically, the CANSAVE register contains the number of register windows following CWP that are not in use and are available to be allocated by a SAVE instruction. The CANRESTORE register contains the number of register windows preceding CWP that are in use by the current program and can be restored via the RESTORE instruction.","Additionally, state registers OTHERWIN and CLEANWIN may be used in some register window schemes. The OTHERWIN register contains the count of register windows that will be spilled\/filled using a particular set of trap vectors. When all of the register windows fill and another register window is saved, a register window overflow, or \u201cspill\u201d occurs, in which case some number of registers are saved to the program stack. Alternatively, when restoring a register window that is not already in a register window, a register window underflow, or \u201cfill\u201d occurs, in which case some number of register windows are restored from the program stack. In some implementations, the OTHERWIN register may be used to split the register windows among different address spaces and handle spill\/fill traps using separate spill\/fill vectors. The CLEANWIN register counts the number of registers that are \u201cclean\u201d with respect to the current program. That is, register windows that contain only zeroes, valid addresses, or valid data from that program are counted. Registers in these windows need not be cleaned before they are used. The count includes the register windows that can be restored (the value in the CANRESTORE register) and the register windows following CWP that can be used without cleaning.","As discussed above, each window shares its ins with one adjacent window and its outs with another. The outs of the CWP\u22121 window are addressable as the ins of the current window, and the outs in the current window are the ins of the CWP+1 window. The locals are unique to each window. When one function, or subroutine, calls another, the callee may choose to execute a SAVE instruction. This instruction increments CWP, shifting the register window upward. The caller's out registers then become the callee's in registers, and the callee gets a new set of local and out registers for its own use. Only the CWP changes because the registers and return address do not need to be stored on a stack. The CALL instruction automatically saves its own address in, for example, out register , which becomes in register  if CWP is incremented. Therefore, the callee may access the return address whether or not it has decremented CWP.","According to one aspect of the present invention, a method for performing a fill operation for a register window comprises: determining whether a restore instruction causes a fill condition; if the restore instruction causes the fill condition, sending a portion of a fill instruction set to a retirement window; retiring at least one instruction of the portion of the fill instruction set, where execution of the at least one instruction updates a temporary register; and sending another portion of the fill instruction set to the retirement window upon execution of the at least one instruction.","According to another aspect, a method for performing a register window fill operation comprises: step for determining whether a restore instruction causes a fill condition; if the restore instruction causes the fill condition, step for sending a portion of a fill instruction set to a retirement window; step for retiring at least one instruction of the portion of the fill instruction set, where execution of the at least one instruction updates a temporary register; and step for sending another portion of the fill instruction set to the retirement window upon execution of the at least one instruction.","According to another aspect, a computer system comprises: a processor; a memory; and a fill instruction set, residing in the memory and executable by the processor, for saving particular contents of a program stack in memory to a register in a register window, where the fill instruction set is arranged so as to allow a retirement window to retire a portion of the fill instruction set without a determination as to whether a remaining portion of the fill instruction set will result in at least one exception, and where the remaining portion is not in the retirement window.","Other aspects and advantages of the invention will be apparent from the following description and the appended claims.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 3","FIG. 3"],"b":["40","0","4"]},"When CWP points to window  and a RESTORE occurs, a fill condition occurs, in which particular contents of a program stack are popped, i.e., restored, to window . When such a fill condition occurs, some prior art implementations issue a software trap, whereby a software trap handler is used to execute fill instructions necessary to restore certain contents of the program stack into window . However, issuing and handling a trap leads to a performance blow, and thus, such treatment of the fill condition is undesirable. In other implementations, the fill instructions necessary to restore certain contents of the program stack into window  are implemented in hardware through the use of a read-only memory (ROM). The read-only memory is used to store the fill instructions, and when a fill condition occurs, the fill instructions are forwarded to a retirement window and a processor pipeline. One example of a set of fill instructions is as follows:",{"@attributes":{"id":"p-0021","num":"0020"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(inst1)","H_SRL %06, 0, %06"]},{"entry":[{},"(inst2)","H_LDUW [%06+BIAS32+0], %10"]},{"entry":[{},"(inst3)","H_LDUW [%06+BIAS32+4], %11"]},{"entry":[{},"(inst4)","H_LDUW [%06+BIAS32+8], %12"]},{"entry":[{},"(inst5)","H_LDUW [%06+BIAS32+12], %13"]},{"entry":[{},"(inst6)","H_LDUW [%06+BIAS32+16], %14"]},{"entry":[{},"(inst7)","H_LDUW [%06+BIAS32+20], %15"]},{"entry":[{},"(inst8)","H_LDUW [%06+BIAS32+24], %16"]},{"entry":[{},"(inst9)","H_LDUW [%06+BIAS32+28], %17"]},{"entry":[{},"(inst10)","H_LDUW [%06+BIAS32+32], %i0"]},{"entry":[{},"(inst11)","H_LDUW [%06+BIAS32+36], %i1"]},{"entry":[{},"(inst12)","H_LDUW [%06+BIAS32+40], %i2"]},{"entry":[{},"(inst13)","H_LDUW [%06+BIAS32+44], %i3"]},{"entry":[{},"(inst14)","H_LDUW [%06+BIAS32+48], %i4"]},{"entry":[{},"(inst15)","H_LDUW [%06+BIAS32+52], %i5"]},{"entry":[{},"(inst16)","H_LDUW [%06+BIAS32+56], %i6"]},{"entry":[{},"(inst17)","H_LDUW [%06+BIAS32+60], %i7"]},{"entry":[{},"(inst18)","H_RESTORED"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"With respect to the above fill instructions, the H_LDUW instruction is a load instruction and architectural register %06 is the base address from which the contents of the program stack are restored to window  (). Those skilled in the art will note that in the instructions above, instructions 2\u201317 may result in one or more exceptions. The contents of window  () are restored with respect to increments of 4 because of an assumption that the fill condition occurs for 32-bit code. Those skilled in the art will appreciate that in other embodiments, the instructions may vary according to code specifications.","In the situation where the number of fill instructions is less than or equal to the size of the retirement window, i.e., retirement window size>=number of fill instructions, the fill instructions can all fit into the retirement window. Thereafter, the instructions are checked to determine whether one or more of the instructions results in an exception. If one of the above instructions results in an exception, then remedial action must be taken because one or more of the architectural registers may be incorrectly updated. If there are no exceptions, then the instructions are executed and retired and normal operation continues.","If the retirement window size is less than the number of fill instructions, then the treatment of the fill condition becomes more difficult. For example, if a system uses a 16-instruction retirement window, then upon a fill condition, only 16 of the above 18 instructions can be sent to the retirement window. If instructions 1\u201316 are sent to the 16-instruction retirement window, then a deadlock state occurs because instruction 17 is not part of the 16-instruction retirement window and the instructions in the 16-instruction retirement window cannot be retired until it is known that all the fill instructions are exception free. In other words, the retirement window cannot retire the fill instructions until it is determined that the fill instructions that are not in the retirement window will be executed exception-free.","Embodiments of the present invention relate to a register window fill technique for a retirement window that has an entry size less than a number of fill instructions used in a fill condition. The present invention uses modified fill instructions that allow a retirement window to retire a portion of the fill instructions without having to determine whether a remaining portion of the fill instructions will execute without exceptions. An example of a fill instruction set in accordance with an embodiment of the present invention is as follows:",{"@attributes":{"id":"p-0026","num":"0025"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(inst1)","H_SRL %06, 0, %temp"]},{"entry":[{},"(inst2)","H_LDUW [%temp+BIAS32+0], %10"]},{"entry":[{},"(inst3)","H_LDUW [%temp+BIAS32+4], %11"]},{"entry":[{},"(inst4)","H_LDUW [%temp+BIAS32+8], %12"]},{"entry":[{},"(inst5)","H_LDUW [%temp+BIAS32+12], %13"]},{"entry":[{},"(inst6)","H_LDUW [%temp+BIAS32+16], %14"]},{"entry":[{},"(inst7)","H_LDUW [%temp+BIAS32+20], %15"]},{"entry":[{},"(inst8)","H_LDUW [%temp+BIAS32+24], %16"]},{"entry":[{},"(inst9)","H_LDUW [%temp+BIAS32+28], %17"]},{"entry":[{},"(just10)","H_LDUW [%temp+BIAS32+32], %i0"]},{"entry":[{},"(inst11)","H_LDUW [%temp+BIAS32+36], %i1"]},{"entry":[{},"(inst12)","H_LDUW [%temp+BIAS32+40], %i2"]},{"entry":[{},"(inst13)","H_LDUW [%temp+BIAS32+44], %i3"]},{"entry":[{},"(inst14)","H_LDUW [%temp+BIAS32+48], %i4"]},{"entry":[{},"(inst15)","H_LDUW [%temp+BIAS32+52], %i5"]},{"entry":[{},"(inst16)","H_LDUW [%temp+BIAS32+56], %i6"]},{"entry":[{},"(inst17)","H_LDUW [%temp+BIAS32+60], %i7"]},{"entry":[{},"(inst18)","H_SRL %temp, 0, %06"]},{"entry":[{},"(inst19)","H_RESTORED"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"With respect to the above set of fill instructions, %temp is a temporary register that is used to restore certain contents of the program stack to window  (). Those skilled in the art will note that in the instructions above, instructions 2\u201317 may result in one or more exceptions.","In the case of a fill condition involving a 16-instruction retirement window, instructions 1\u201316 are sent to the retirement window, whereby instruction 1 is executable\/retirable, after which instruction 17 is sent to the retirement window. Thereafter, a determination may be made as to whether any of instructions 2\u201317 result in an exception, in which case appropriate remedial action be taken. Because a temporary register %temp is used at the outset of the fill condition, if an exception results, an architectural register, such as architectural register %06 above, is not adversely impacted. If instructions 2\u201317 are exception-free, then they are retired, at which point the contents of the temporary register %temp are copied over to architectural register %06 (inst18).","Those skilled in the art will understand that although the discussion with respect to  relates to a 5-register window scheme, the principles of the present invention are equally applicable to register window schemes using a different number of register windows and to systems having different specifications (i.e., 64-bit registers instead of 32-bit registers).",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 4","FIG. 4","FIG. 3","FIG. 3"],"b":["50","52","1"]},"However, if the RESTORE does result in a fill condition, in , a portion of a set of fill instructions is sent to the retirement window. In , non-exception instructions, such as instruction 1 above, are executed\/retired, thereby, in , allowing for remaining instruction(s) of the fill instruction set to be sent to the retirement window. Thereafter, in , the remaining unretired instructions in the retirement window are checked for exceptions and if all of them execute without exceptions, they are then retired. If after this iteration, in , more instructions of the fill instruction set are remaining that have not yet been sent to the retirement window, those instructions are forwarded to the retirement window in .","As mentioned above, the fill instruction set is designed so as to allow the retirement of certain fill instructions irregardless of whether other fill instructions would result in an exception. In the case of an exception, adverse architectural register impact is avoided because the present invention uses a temporary register so as to allow certain instructions of a fill instruction set to be executed\/retired without consideration of other fill instructions.","Advantages of the present invention may include one or more of the following. In some embodiments, because a register window fill technique for a retirement window having a size less than an amount of fill instructions needed to perform a register window fill operation is provided, the issuance and handling of performance hindering software traps is avoided.","In some embodiments, because a modified fill instruction set allows a retirement window to retire certain fill instructions without a determination as to whether other fill instructions result in one or more exceptions, a system using a retirement window having a size less than the amount of fill instructions needed to perform a fill operation is able to efficiently and accurately handle a fill condition.","While the invention has been described with respect to a limited number of embodiments, those skilled in the art, having benefit of this disclosure, will appreciate that other embodiments can be devised which do not depart from the scope of the invention as disclosed herein. Accordingly, the scope of the invention should be limited only by the attached claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
