---
title: Process device context switching
abstract: Methods, systems, and computer readable media embodiments are disclosed for preemptive context-switching of processes running on an accelerated processing device. A method includes, responsive to an exception upon access to a memory by a process running on a accelerated processing device, whether to preempt the process based on the exception, and preempting, based upon the determining, the process from running on the accelerated processing device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09256465&OS=09256465&RS=09256465
owner: Advanced Micro Devices, Inc.
number: 09256465
owner_city: Sunnyvale
owner_country: US
publication_date: 20111104
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY OF EMBODIMENTS","DETAILED DESCRIPTION OF EMBODIMENTS OF THE INVENTION"],"p":["This application claims the benefit of U.S. provisional application No. 61\/422,595, filed on Dec. 13, 2010, which is hereby incorporated by reference in its entirety.","1. Field of the Invention","The present invention is generally directed to computer systems. More particularly, the present invention is directed to the execution of processes on an accelerated processing device within a computer system.","2. Background Art","The desire to use a graphics processing unit (GPU) for general computation has become much more pronounced recently due to the GPU's exemplary performance per unit power and\/or cost. The computational capabilities for GPUs, generally, have grown at a rate exceeding that of the corresponding central processing unit (CPU) platforms. This growth, coupled with the explosion of the mobile computing market (e.g., notebooks, mobile smart phones, tablets, etc.) and its necessary supporting server\/enterprise systems, has been used to provide a specified quality of desired user experience. Consequently, the combined use of CPUs and GPUs for executing workloads with data parallel content is becoming a volume technology.","However, GPUs have traditionally operated in a constrained programming environment, available primarily for the acceleration of graphics. These constraints arose from the fact that GPUs did not have as rich a programming ecosystem as CPUs. Their use, therefore, has been mostly limited to two dimensional (2D) and three dimensional (3D) graphics and a few leading edge multimedia applications, which are already accustomed to dealing with graphics and video application programming interfaces (APIs).","With the advent of multi-vendor supported OpenCL\u00ae and DirectCompute\u00ae, standard APIs and supporting tools, the limitations of the GPUs in traditional applications has been extended beyond traditional graphics. Although OpenCL and DirectCompute are a promising start, there are many hurdles remaining to creating an environment and ecosystem that allows the combination of a CPU and a GPU to be used as fluidly as the CPU for most programming tasks.","Existing computing systems often include multiple processing devices. For example, some computing systems include both a CPU and a GPU on separate chips (e.g., the CPU might be located on a motherboard and the GPU might be located on a graphics card) or in a single chip package. Both of these arrangements, however, still include significant challenges associated with (i) separate memory systems, (ii) efficient scheduling, (iii) providing quality of service (QoS) guarantees between processes, (iv) programming model, and (v) compiling to multiple target instruction set architectures (ISAs)\u2014all while minimizing power consumption.","For example, the discrete chip arrangement forces system and software architects to utilize chip to chip interfaces for each processor to access memory. While these external interfaces (e.g., chip to chip) negatively affect memory latency and power consumption for cooperating heterogeneous processors, the separate memory systems (i.e., separate address spaces) and driver managed shared memory create overhead that becomes unacceptable for fine grain offload.","Both the discrete and single chip arrangements can limit the types of commands that can be sent to the GPU for execution. This performance based limitation exists because the CPU may relatively quickly require the results of the operations performed by these computational commands. However, because of the high overhead of dispatching work to the GPU in current systems and the fact that these commands may have to wait in line for other previously-issued commands to be executed first, the latency incurred by sending computational commands to the GPU is often unacceptable.","Given that a traditional GPU may not efficiently execute some computational commands, the commands must then be executed within the CPU. Having to execute the commands on the CPU increases the processing burden on the CPU and can hamper overall system performance.","Although GPUs provide excellent opportunities for computational offloading, traditional GPUs may not be suitable for system-software-driven process management that is desired for efficient operation in some multi-processor environments. These limitations can create several problems.","For example, since processes cannot be efficiently identified and\/or preempted, a rogue process can occupy the GPU for arbitrary amounts of time. The occupying of the GPU by rogue processes for arbitrary amounts of time can prevent the effective utilization of the available system capacity, and can prevent or significantly reduce the processing progress of the system. In other cases, the ability to context switch off the hardware is severely constrained\u2014occurring at very coarse granularity and only at a very limited set of points in a program's execution.","Therefore, what is needed is a method and system for efficiently preempting processes from a graphics processing device, such as a GPU, and context switching another process onto the graphics processing device.","Although GPUs, accelerated processing units (APUs), and general purpose use of the graphics processing unit (GPGPU) are commonly used terms in this field, the expression \u201caccelerated processing device (APD)\u201d is considered to be a broader expression. For example, APD refers to any cooperating collection of hardware and\/or software that performs those functions and computations associated with accelerating graphics processing tasks, data parallel tasks, or nested data parallel tasks in an accelerated manner with respect to resources such as conventional CPUs, conventional GPUs, and\/or combinations thereof.","An embodiment of the present invention includes, responsive to an exception upon access to a memory by a process running on an APD, determining whether to preempt the process based on the exception, and preempting the process from running on the accelerated processing device.","Further features and advantages of the invention, as well as the structure and operation of various embodiments of the invention, are described in detail below with reference to the accompanying drawings. It is noted that the invention is not limited to the specific embodiments described herein. Such embodiments are presented herein for illustrative purposes only. Additional embodiments will be apparent to persons skilled in the relevant art(s) based on the teachings contained herein.","In the detailed description that follows, references to \u201cone embodiment,\u201d \u201can embodiment,\u201d \u201can example embodiment,\u201d etc., indicate that the embodiment described may include a particular feature, structure, or characteristic, but every embodiment may not necessarily include the particular feature, structure, or characteristic. Moreover, such phrases are not necessarily referring to the same embodiment. Further, when a particular feature, structure, or characteristic is described in connection with an embodiment, it is submitted that it is within the knowledge of one skilled in the art to affect such feature, structure, or characteristic in connection with other embodiments whether or not explicitly described.","The term \u201cembodiments of the invention\u201d does not require that all embodiments of the invention include the discussed feature, advantage or mode of operation. Alternate embodiments may be devised without departing from the scope of the invention, and well-known elements of the invention may not be described in detail or may be omitted so as not to obscure the relevant details of the invention. In addition, the terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. For example, as used herein, the singular forms \u201ca\u201d, \u201can\u201d and \u201cthe\u201d are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms \u201ccomprises,\u201d \u201ccomprising,\u201d \u201cincludes\u201d and\/or \u201cincluding,\u201d when used herein, specify the presence of stated features, integers, steps, operations, elements, and\/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and\/or groups thereof.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 1A","b":["100","102","104","102","100","102","104","104","102","102","104"]},"In one example, system  also includes a memory , an OS , and a communication infrastructure . The OS  and the communication infrastructure  are discussed in greater detail below.","The system  also includes a kernel mode driver (KMD) , a software scheduler (SWS) , and a memory management unit , such as input\/output memory management unit (IOMMU). Components of system  can be implemented as hardware, firmware, software, or any combination thereof. A person of ordinary skill in the art will appreciate that system  may include one or more software, hardware, and firmware components in addition to, or different from, that shown in the embodiment shown in .","In one example, a driver, such as KMD , typically communicates with a device through a computer bus or communications subsystem to which the hardware connects. When a calling program invokes a routine in the driver, the driver issues instructions to the device. Once the device sends data back to the driver, the driver may invoke routines in the original calling program. In one example, drivers are hardware-dependent and operating-system-specific. They usually provide the interrupt handling required for any necessary asynchronous time-dependent hardware interface. Device drivers, particularly on modern Microsoft Windows\u00ae platforms, can run in kernel-mode (Ring 0) or in user-mode (Ring 3).","A benefit of running a driver in user mode is improved stability, since a poorly written user mode device driver cannot crash the system by overwriting kernel memory. On the other hand, user\/kernel-mode transitions usually impose a considerable performance overhead, thereby prohibiting user mode-drivers for low latency and high throughput requirements. Kernel space can be accessed by user modules only through the use of system calls. End user programs like the UNIX shell or other GUI based applications are part of the user space. These applications interact with hardware through kernel supported functions.","CPU  can include (not shown) one or more of a control processor, field programmable gate array (FPGA), application specific integrated circuit (ASIC), or digital signal processor (DSP). CPU , for example, executes the control logic, including the OS , KMD , SWS , and applications , that control the operation of computing system . In this illustrative embodiment, CPU , according to one embodiment, initiates and controls the execution of applications  by, for example, distributing the processing associated with that application across the CPU  and other processing resources, such as the APD .","APD , among other things, executes instructions and programs for selected functions, such as graphics operations and other operations that may be, for example, particularly suited for parallel processing. In general, APD  can be frequently used for executing graphics pipeline operations, such as pixel operations, geometric computations, and rendering an image to a display. In various embodiments of the present invention, APD  can also execute compute processing operations (e.g., those operations unrelated to graphics such as, for example, video operations, physics simulations, computational fluid dynamics, etc.), based on commands or instructions received from CPU .","For example, commands can be considered as special instructions that are not typically defined in the instruction set architecture (ISA). A command may be executed by a special processor such as a dispatch processor, command processor, or network controller. On the other hand, instructions can be considered as, for example, a single operation of a processor within a computer architecture. In one example, when using two sets of ISAs, some instructions are used to execute x86 programs and some instructions are used to execute kernels on APD compute unit.","In an illustrative embodiment, CPU  transmits selected commands and\/or other instructions to APD . These selected instructions can include graphics instructions and other commands amenable to parallel execution. These selected instructions, that can also include compute processing instructions, can be executed substantially independently from CPU .","APD  can include its own compute units (not shown), such as, but not limited to, one or more single instruction multiple data (SIMD) processing cores. As referred to herein, a SIMD is a pipeline, or programming model, where a kernel is executed concurrently on multiple processing elements each with its own data and a shared program counter. All processing elements execute an identical set of instructions. The use of predication enables work-items to participate or not for each issued command.","In one example, each APD  compute unit can include one or more scalar and\/or vector floating-point units and\/or arithmetic and logic units (ALUs). The APD compute unit can also include special purpose processing units (not shown), such as inverse-square root units and sine\/cosine units. In one example, the APD compute units are referred to herein collectively as shader core .","Having one or more SIMDs, in general, makes APD  ideally suited for execution of data-parallel tasks such as those that are common in graphics processing.","Some graphics pipeline operations, such as pixel processing, and other parallel computation operations, can require that the same instruction stream or compute kernel be performed on streams or collections of input data elements. Respective instantiations of the same compute kernel can be executed concurrently on multiple compute units in shader core  in order to process such data elements in parallel. As referred to herein, for example, a compute kernel is a function containing instructions declared in a program and executed on an APD compute unit. This function is also referred to as a kernel, a shader, a shader program, or a program.","In one illustrative embodiment, each compute unit (e.g., SIMD processing core) can execute a respective instantiation of a particular work-item to process incoming data. A work-item is one of a collection of parallel executions of a kernel invoked on a device by an instruction. A work-item can be executed by one or more processing elements as part of a work-group executing on a compute unit.","A work-item is distinguished from other executions within the collection by its global ID and local ID. In one example, a subset of work-items in a workgroup that execute simultaneously together on a SIMD can be referred to as a wavefront . The width of a wavefront is a characteristic of the hardware of the compute unit (e.g., SIMD processing core). As referred to herein, a workgroup is a collection of related work-items that execute on a single compute unit. The work-items in the group execute the same kernel and share local memory and work-group barriers.","In the exemplary embodiment, all wavefronts from a workgroup are processed on the same SIMD processing core. Instructions across a wavefront are issued one at a time, and when all work-items follow the same control flow, each work-item executes the same program. Wavefronts can also be referred to as warps, vectors or threads.","An execution mask and work-item predication are used to enable divergent control flow within a wavefront, where each individual work-item can take a unique code path through the kernel. Partially populated wavefronts can be processed when a full set of work-items is not available at wavefront start time. For example, shader core  can simultaneously execute a predetermined number of wavefronts , each wavefront  comprising a multiple work-items.","Within the system , APD  includes its own memory, such as graphics memory  (although memory  is not limited to graphics only use). Graphics memory  provides a local memory for use during computations in APD . Individual compute units (not shown) within shader core  can have their own local data store (not shown). In one embodiment, APD  includes access to local graphics memory , as well as access to the memory . In another embodiment, APD  can include access to dynamic random access memory (DRAM) or other such memories (not shown) attached directly to the APD  and separately from memory .","In the example shown, APD  also includes one or \u201cn\u201d number of command processors (CPs) . CP  controls the processing within APD . CP  also retrieves instructions to be executed from command buffers  in memory  and coordinates the execution of those instructions on APD .","In one example, CPU  inputs instructions based on applications  into appropriate command buffers . As referred to herein, an application is the combination of the program parts that will execute on the compute units within the CPU and APD.","A plurality of command buffers  can be maintained with each process scheduled for execution on the APD .","CP  can be implemented in hardware, firmware, or software, or a combination thereof. In one embodiment, CP  is implemented as a reduced instruction set computer (RISC) engine with microcode for implementing logic including scheduling logic.","APD  also includes one or \u201cn\u201d number of dispatch controllers (DCs) . In the present application, the term dispatch refers to a instruction executed by a dispatch controller that uses the context state to initiate the start of the execution of a kernel for a set of work groups on a set of compute units. DC  includes logic to initiate workgroups in the shader core . In some embodiments, DC  can be implemented as part of CP .","System  also includes a hardware scheduler (HWS)  for selecting a process from a run list  for execution on APD . HWS  can select processes from run list  using round robin methodology, priority level, or based on other scheduling policies. The priority level, for example, can be dynamically determined. HWS  can also include functionality to manage the run list , for example, by adding new processes and by deleting existing processes from ran-list . The run list management logic of HWS  is sometimes referred to as a run list controller (RLC).","In various embodiments of the present invention, when HWS  initiates the execution of a process from run list , CP  begins retrieving and executing instructions from the corresponding command buffer . In some instances, CP  can generate one or more instructions to be executed within APD , which correspond with instructions received from CPU . In one embodiment, CP , together with other components, implements a prioritizing and scheduling of instructions on APD  in a manner that improves or maximizes the utilization of the resources of APD  and\/or system .","APD  can have access to, or may include, an interrupt generator . Interrupt generator  can be configured by APD  to interrupt the OS  when interrupt events, such as page faults, are encountered by APD . For example, APD  can rely on interrupt generation logic within IOMMU  to create the page fault interrupts noted above.","APD  can also include preemption and context switch logic  for preempting a process currently running within shader core . Context switch logic , for example, includes functionality to stop the process and save its current state (e.g., shader core  state, and CP  state).","As referred to herein, the term state can include an initial state, an intermediate state, and\/or a final state. An initial state is a starting point for a machine to process an input data set according to a programming in order to create an output set of data. There is an intermediate state, for example, that needs to be stored at several points to enable the processing to make forward progress. This intermediate state is sometimes stored to allow a continuation of execution at a later time when interrupted by some other process. There is also final state that can be recorded as part of the output data set","Preemption and context switch logic  can also include logic to context switch another process into the APD . The functionality to context switch another process into running on the APD  may include instantiating the process, for example, through the CP  and DC  to run on APD , restoring any previously saved state for that process, and starting its execution.","Memory  can include non-persistent memory such as DRAM (not shown). Memory  can store, e.g., processing logic instructions, constant values, and variable values during execution of portions of applications or other processing logic. For example, in one embodiment, parts of control logic to perform one or more operations on CPU  can reside within memory  during execution of the respective portions of the operation by CPU .","During execution, respective applications, OS functions, processing logic instructions, and system software can reside in memory . Control logic instructions fundamental to OS  will generally reside in memory  during execution. Other software instructions, including, for example, kernel mode driver  and software scheduler  can also reside in memory  during execution of system . Software instructions, prior to being loaded into system memory  for execution, can reside on a persistent storage computer readable media  such as a hard disk, flash memory, and the like.","In this example, memory  includes command buffers  that are used by CPU  to send instructions to APD . Memory  also contains process lists and process information (e.g., active list  and process control blocks ). These lists, as well as the information, are used by scheduling software executing on CPU  to communicate scheduling information to APD  and\/or related scheduling hardware. Access to memory  can be managed by a memory controller , which is coupled to memory . For example, requests from CPU , or from other devices, for reading from or for writing to memory  are managed by the memory controller .","Referring back to other aspects of system , IOMMU  is a multi-context memory management unit.","As used herein, context can be considered the environment within which the kernels execute and the domain in which synchronization and memory management is defined. The context can include a set of devices, the memory accessible to those devices, the corresponding memory properties and one or more command-queues used to schedule execution of a kernel(s) or operations on memory objects.","Referring back to the example shown in , IOMMU  includes logic to perform virtual to physical address translation for memory page access for devices including APD . IOMMU  may also include logic to generate interrupts, for example, when a page access by a device such as APD  results in a page fault. IOMMU  may also include, or have access to, a translation lookaside buffer (TLB) . TLB , as an example, can be implemented in a content addressable memory (CAM) to accelerate translation of logical (i.e., virtual) memory addresses to physical memory addresses for requests made by APD  for data in memory .","In the example shown, communication infrastructure  interconnects the components of system  as needed. Communication infrastructure  can include (not shown) one or more of a peripheral component interconnect (PCI) bus, extended PCI (PCI-E) bus, advanced microcontroller bus architecture (AMBA) bus, accelerated graphics port (AGP), or other such communication infrastructure. Communications infrastructure  can also include an Ethernet, or similar network, or any suitable physical communications infrastructure that satisfies an application's data transfer rate requirements. Communication infrastructure  includes the functionality to interconnect components including components of computing system .","In this example, OS  includes functionality to manage the hardware components of system  and to provide common services. In various embodiments, OS  can execute on CPU  and provide common services. These common services can include, for example, scheduling applications for execution within CPU , fault management, interrupt service, as well as processing the input and output of other applications.","In some embodiments, based on interrupts generated by an interrupt controller, such as interrupt controller , OS  invokes an appropriate interrupt handling routine. For example, upon detecting a page fault interrupt, OS  may invoke an interrupt handler to initiate loading of the relevant page into memory  and to update corresponding page tables.","OS  may also include functionality to protect system  by ensuring that access to hardware components is mediated through OS managed kernel functionality. In effect, OS  ensures that applications, such as applications , run on CPU  in user space. OS  also ensures that applications  invoke kernel functionality provided by the OS to access hardware and\/or input\/output functionality.","According to an embodiment, the operating system includes an OS memory manager  and an OS scheduler . OS memory manager  may operate to manage memory objects such as, but not limited to, page tables  and page event queues . Page tables  include tables that indicate the location of pages currently loaded in memory . Page event queue  includes a queue in which page related events, such as page fault events, are enqueued by other devices, such as IOMMU , in order to communicate page related information to the OS. OS scheduler  may operate to determine the status of page faults and to determine if a GPU context switch should be initiated in response to a page fault. Exception statistics  may collect statistics related to page faults and other exceptions.","By way of example, applications  include various programs or instructions to perform user computations that are also executed on CPU . CPU  can seamlessly send selected instructions for processing on the APD .","In one example, KMD  implements an application program interface (API) through which CPU , or applications executing on CPU  or other logic, can invoke APD  functionality. For example, KMD  can enqueue instructions from CPU  to command buffers  from which APD  will subsequently retrieve the instructions. Additionally, KMD  can, together with SWS , perform scheduling of processes to be executed on APD . SWS , for example, can include logic to maintain a prioritized list of processes to be executed on the APD.","In other embodiments of the present invention, applications executing on CPU  can entirely bypass KMD  when enqueuing instructions.","In some embodiments, SWS  maintains an active list  in memory  of processes to be executed on APD . SWS  also selects a subset of the processes in active list  to be managed by HWS  in the hardware. Information relevant for running each process on APD  is communicated from CPU  to APD  through process control blocks (PCB) .","Processing logic for applications, OS, and system software can include commands and\/or other instructions specified in a programming language such as C and\/or in a hardware description language such as Verilog, RTL, or netlists, to enable ultimately configuring a manufacturing process through the generation of maskworks\/photomasks to generate a hardware device embodying aspects of the invention described herein.","A person of skill in the art will understand, upon reading this description, that computing system  can include more or fewer components than shown in . For example, computing system  can include one or more input interfaces, non-volatile storage, one or more output interfaces, network interfaces, and one or more displays or display interfaces.",{"@attributes":{"id":"p-0074","num":"0073"},"figref":["FIG. 1B","FIG. 1A","FIG. 1B","FIG. 1A","FIG. 1B"],"b":["104","124","124","124","124","124","125","124","162","124","124","160","166","128"],"i":["a","b","c","a","b ","c"]},"In , graphics pipeline  can include a set of blocks, referred to herein as ordered pipeline . As an example, ordered pipeline  includes a vertex group translator (VGT) , a primitive assembler (PA) , a scan converter (SC) , and a shader-export, render-back unit (SX\/RB) . Each block within ordered pipeline  may represent a different stage of graphics processing within graphics pipeline . Ordered pipeline  can be a fixed function hardware pipeline. Other implementations can be used that would also be within the spirit and scope of the present invention.","Although only a small amount of data may be provided as an input to graphics pipeline , this data will be amplified by the time it is provided as an output from graphics pipeline . Graphics pipeline  also includes DC  for counting through ranges within work-item groups received from CP pipeline . Compute work submitted through DC  is semi-synchronous with graphics pipeline .","Compute pipeline  includes shader DCs  and . Each of the DCs  and  is configured to count through compute ranges within work groups received from CP pipelines and ","The DCs , , and , illustrated in , receive the input ranges, break the ranges down into workgroups, and then forward the workgroups to shader core .","Since graphics pipeline  is generally a fixed function pipeline, it is difficult to save and restore its state, and as a result, the graphics pipeline  is difficult to context switch. Therefore, in most cases context switching, as discussed herein, does not pertain to context switching among graphics processes. An exception is for graphics work in shader core , which can be context switched.","After the processing of work within graphics pipeline  has been completed, the completed work is processed through a render back unit , which does depth and color calculations, and then writes its final results to memory .","Shader core  can be shared by graphics pipeline  and compute pipeline . Shader core  can be a general processor configured to run wavefronts. In one example, all work within compute pipeline  is processed within shader core . Shader core  runs programmable software code and includes various forms of data, such as state data.",{"@attributes":{"id":"p-0082","num":"0081"},"figref":["FIG. 2","FIGS. 1A and 1B"],"b":["200","200","100","200","200"]},"In step , the APD runs a first process. Running of a process which could include the HWS or SWS-selecting the process from a run-list of processes and maps it to the APD which will process it on the appropriate processing pipeline. Graphics processing utilizes the graphics pipeline of the APD, and the compute pipeline utilizes the compute pipeline. Both types of processes can utilize a shader core of the APD for processing, e.g., as discussed above.","In step , the first process running on the APD requests data. According to an embodiment, the request from the first process running on the APD is intercepted by, or directed to, a memory management unit. The memory management unit can be an IOMMU communicatively coupled to the APD, e.g., as discussed above with regards to system . The IOMMU may be incorporated in the APD, may be incorporated in another memory management unit, such as a memory controller, or may be implemented separately. The IOMMU can include the functionality to translate between the virtual memory address space as seen by the APD and the system memory physical address space.","In step , a page fault or other exception is detected. According to an embodiment, the IOMMU receives the request for data from the APD and attempts to perform the translation of the requested data from the APD's virtual address space to the physical address space. The IOMMU then attempts to retrieve the data from memory based upon the determined physical address of the data. The IOMMU attempts to retrieve the requested data from, for example, system memory, such as system memory .","In an example, if the requested data is not in system memory, a memory exception or page fault is triggered. The page fault can be triggered by the IOMMU or other hardware or software component associated with the IOMMU access to memory. A page fault, as used herein, indicates that a requested memory object, such as a page of in-memory data, does not exist in physical memory that is accessible to the requesting entity. A page fault can be triggered, for example, if an entry corresponding to the virtual address is not present in the page table. A page fault can also be triggered for other reasons, such as when a page table entry for the requested virtual address exists but the corresponding page is not accessible to the requesting process. For example, a page may not be accessible to the requesting process due to synchronization or mapping issues between the page table accessible to the IOMMU and system memory, due to memory protection errors such as when the requesting device or process is not permitted to access the area of memory in which the requested address is present, and the like.","In the exemplary embodiment, upon receiving from the APD a request for data, the IOMMU accesses a TLB with the request for data. The TLB can be implemented in the IOMMU, the APD, or separately. The TLB is a cache, typically implemented in a content addressable memory (CAM), which performs translation between the system memory physical address space and a virtual address space in a more efficient manner than by using page table lookup. The TLB is looked up using a virtual address as seen by the process executing on the APD. If the TLB currently has an entry corresponding to that virtual address, then the corresponding physical memory address is returned to the IOMMU. The IOMMU can then attempt to retrieve the corresponding page from the memory.","If the TLB currently does not have an entry corresponding to that virtual address, then a TLB miss occurs. Upon a TLB miss, the IOMMU may lookup the requested virtual address in the page table. The process of the IOMMU looking up the page table for a virtual address is sometimes referred to as a page table walk. The page table walk, in general, is more time consuming than looking up that address using a TLB.","In step , notification of the page fault issues (in the exemplary embodiment it is issued to the OS). According to an embodiment, the OS is notified by an interrupt generated by the IOMMU. The IOMMU may generate the interrupt upon detecting that the requested virtual address does not exist in the TLB and in the page table accessible to the IOMMU. According to another embodiment, the interrupt can be generated by the IOMMU upon receiving a signal from the APD requesting the generation of the interrupt.","In step , a determination is made if there should be a context switch or a stall in response to the detected page fault. In some embodiments, this determination may be made by software such as the OS. According to an embodiment, an interrupt handler of the OS traps the interrupt generated by the IOMMU to indicate the page fault. The interrupt handler can invoke the logic to determine if, based on the detected page fault, a context switch or stall should be implemented in the APD. The OS functionality to determine if a context switch should be attempted upon a page fault can be implemented by an OS scheduler, for example.","The decision to select between a context switch or stall can be based upon the type of the page fault or an estimate of the time required to recover from such page fault. If the page fault is due to a page that is not loaded into memory from a virtual memory, such page faults can be considered as requiring substantial time to recover.","According to other embodiments, even in cases where the requested page is required to be loaded from virtual memory to system memory, the required recovery time to load the page and update the corresponding tables (such as page tables) can be considered short or long based on factors such as the location in virtual memory and current utilization of system memory. If the page fault is due to a page table entry not being updated after a page is loaded into memory, then recovery from the page fault may require only a short time.","In the exemplary embodiment, the OS can decide to initiate a context switch in cases where the page fault is considered a long page fault (i.e., expected recovery time is substantial), and can decide to stall the process on the APD if the page fault is a short page fault (i.e., expected recovery time is short or insubstantial). The functionality to load the page into memory and update page tables may be included in an OS memory manager.","According to yet one other embodiment, the OS maintains statistics corresponding to the various page faults. For example, the maintained statistics can include, but are not limited to, the type and count of each type of page fault, page faults per active process, page faults for pages from predetermined areas\/segments of memory, and the like. The statistics can also include response time related information, such as, but not limited to, the time that was required for loading the pages in response to particular types of page faults in a predetermined interval. The statistics can be updated, for example, by the interrupt handler servicing the page fault interrupt and\/or the OS memory manager. The decision to initiate a context switch based upon a detected page fault can, in some embodiments, be based upon such statistics available to the OS. For example, if the statistics maintained by the OS is indicative of the requesting process having page faulted beyond a threshold number of times, then the OS may determine that the process should be context switch.","The OS can also consider other factors, such as, the number of processes and\/or the priority of processes that are ready to be run on the APD when determining whether to initiate a context switch. For example, the OS can consider processes in the active list and\/or run-list of processes queued for running by the APD. According to an embodiment, the OS can more frequently determine that lower priority processes are to be context switched when high priority processes are enqueued for running on the APD.","If, in step , it is determined that no context switch is required and that a stall should be adequate, then in step  other operations can be performed in response to the stall. A stall does not require the OS to communicate that determination to the APD or other component. According to another embodiment, the OS can update any statistics maintained, such as, for example the number of stalls and\/or the number of stalls caused by the requesting process.","According to another embodiment, the OS can communicate the determination to stall to the APD and\/or IOMMU. For example, a message can be queued in a buffer monitored by the IOMMU indicating the determination to stall. The IOMMU can, for example, initiate or continue attempts to perform the address translation based on the communication from the OS.","If, in step , it is determined that a context switch is to be initiated, then in step , initiation of the preemption of the current process from the APD occurs.","Subsequent to initiating the preemption of the current process, in step  other processes can be initiated, e.g., a the running of a second process in the APD. The initiation of the preemption of an APD process and the initiation of the context switch can be performed by, for example, OS scheduler. OS aided preemption of APD processes and context switching is further described below in relation to .",{"@attributes":{"id":"p-0100","num":"0099"},"figref":["FIG. 3","FIGS. 1A and 1B"],"b":["206","206","100","302","308","206","206"]},"In step , the IOMMU receives a request for data from the APD. The request can include the virtual address of a single data element or a block of data.","In step , the IOMMU initiates a TLB lookup for the requested data. The TLB lookup can be performed using the virtual address provided by the APD, or a virtual address derived based upon the received virtual address. For example, the IOMMU can derive an address of a block of data based upon the address provided by the APD.","The TLB lookup, if successful, results in the TLB returning the physical address corresponding to the virtual address on which the lookup was based.","If the TLB lookup is not successful (i.e., TLB miss), an indication of the miss is returned to the IOMMU and\/or APD. Accordingly, the IOMMU and\/or APD, upon receiving the TLB miss indication, can choose to initiate a retry sequence of performing the TLB lookup. For example, the retry sequence may involve continually retrying the TLB lookup at predetermined intervals.","In step , according to another embodiment, upon receiving the TLB miss indication, the APD or IOMMU attempts to locate the address in the page tables. According to an embodiment, the IOMMU receives the TLB miss indication and initiates the page table walk to locate the address in the page tables. In another embodiment, the APD is notified of the miss, for example, by the IOMMU which initially receives the TLB request miss notification, or by receiving the miss notification directly in the APD from the TLB, The APD may then request the IOMMU to translate the address and\/or retrieve the data corresponding to the requested address using the page tables. According to an embodiment, the APD can transmit an Address Translation Service (ATS) Request to the IOMMU to initiate the page walk for the requested virtual address.","If an entry corresponding to the virtual address is located in the page table, then the corresponding request for the data can be sent to memory to retrieve data as appropriate. If no entry corresponding to the requested virtual address is located in the page table, then the IOMMU signals a page fault to the APD. According to an embodiment, the APD is notified of the page fault using an ATS Response.","In step , the APD requests fault handling of the page fault from the OS. According to an embodiment, the APD makes the request through the IOMMU. The fault handling request to the OS can be generated by an interrupt and\/or message (such as a Page Request Interface Request) that the APD exchanges with the IOMMU.",{"@attributes":{"id":"p-0108","num":"0107"},"figref":["FIG. 4","FIGS. 1A and 1B"],"b":["208","208","100","402","08","208","208"]},"In step , an interrupt corresponding to page faults is generated. According to an embodiment, the interrupt is generated by the IOMMU on behalf of the APD. According to another embodiment, the APD can directly cause the generation of the interrupt without going through the IOMMU.","In step , a page fault event is enqueued in a page fault event queue in system memory. The enqueued page fault event can include information necessary for the OS to service the page fault and to maintain statistics about page faults. According to an embodiment, the page fault event includes the type of page fault, the time the page fault is generated, virtual address upon which the page fault was generated, the process requesting the virtual address upon which the page fault was generated, and the identity of the device causing the page fault.","In step , the OS allocates the page for which the page fault was generated, and updates corresponding page table entries to indicate that the page was allocated. According to an embodiment, the OS becomes aware of the page fault, for example, by being notified by an interrupt service routine that traps the interrupt generated by the IOMMU and\/or APD in step . Upon receiving the interrupt, the OS can retrieve the corresponding page fault event from a page fault event buffer. The page fault event provides the OS with detailed information regarding the page fault. According to an embodiment, if the page fault is due to a page not being in memory, the OS attempts to load the page into memory and update the page tables correspondingly. If the page fault is due to the page tables not being correctly updated with information regarding pages already in memory, the OS updates the corresponding entry in the page table.","In step , the OS notifies the IOMMU and\/or APD that the page was loaded. According to an embodiment, this notification is delivered using an interrupt which is trapped by the IOMMU. The OS may, according to embodiments, issue this notification upon the initiating or upon the completing of the loading of the corresponding page and\/or updating of the corresponding page tables.","It should be noted that the OS, upon being notified of the page fault in step , also initiates the determination whether to preemptively context switch the process on the APD. This is described, for example, above in relation to step  and also below in relation to .",{"@attributes":{"id":"p-0114","num":"0113"},"figref":["FIG. 5","FIGS. 1A and 1B"],"b":["210","210","502","506","502","506","210","100","210"]},"In step , the OS accesses information regarding the page fault and other page fault statistics that are accessible to the OS. For example, information about the current page fault can be available based upon the corresponding page fault event enqueued by the IOMMU. Statistics of page faults can be maintained by the OS based upon each of the page faults of which it is notified. The statistics can be stored in system memory.","In step , the determination whether to preemptively context switch or stall is made by the OS, for example, by an OS memory scheduler.","If it is determined to context switch, then, in step , the context switch is initiated by the OS. According to an embodiment, the OS signals a software scheduler (SWS) for the APD to initiate the context switch. For example, OS scheduler  can signal SWS . The SWS can be implemented as either a part of a kernel mode driver (KMD) for the APD or as a separate module that communicates with the APD through the KMD. The KMD, SWS and OS execute on the CPU.","According to an embodiment, upon being signaled by the OS to initiate a context switch on the APD, the SWS performs the scheduling of processes to run on the APD. The SWS can maintain a list of processes from which the processes to be run on the APD are selected. The list of runnable processes can be maintained as a single or multi-level list. According to an embodiment, the list of runnable processes is maintained as a two-level list. At the higher level, the SWS enqueues the runnable processes to an active-list, such as active list  maintained in system memory. The active-list includes an entry for each process that the SWS has scheduled to be run on the APD. Each entry in the active-list can include, or can point to, information regarding the process that may be needed for the execution of the process on the APD. For example, each entry in the active-list can point to a corresponding entry in the list of process control blocks  in system memory. The process control blocks can include information regarding, for example, process state, program counter, and the like. The SWS can select some processes from the active-list and enqueue them in a second level list of runnable processes referred to herein as the run-list. According to an embodiment, the run-list may include a plurality of processes selected to be run on the APD by the SWS. The run-list can be implemented in the hardware or firmware, and can be managed by the APD or an associated hardware scheduler (HWS). According to an embodiment, whereas the SWS selects the processes to be input to the run-list, the HWS can select the process to be run on the APD from those in the run-list. The selection of the next process to be run on the APD can be based upon a round-robin or other selection discipline.","Upon being signaled by the OS to initiate a context switch on the APD, the SWS first signals the APD to preempt the current process which caused the page fault. According to an embodiment, the SWS first signals the APD to stop running the current process. The SWS next signals the APD to remove the current process from the run-list, and to save the context of the current process to system memory. The SWS may also provide an address in system memory to which the context of the current process is to be saved. Stopping the current process from running on the shader core, removing it from the run-list, and saving its context completes the preemption of the current process from running on APD. The SWS instructions directing the preemption are received and acted upon by the CP to preempt the current process from running on the shader processor.","Having preempted the current process from running on the APD, the SWS selects a second process to run on the APD. According to an embodiment, the SWS selects the second process from the active-list or as a new process to be added to the list of runnable processes. If the second process already has stored context, for example, from a previous execution, then the SWS signals the APD to restore the context for the second process. The SWS can then signal the APD to add the second process to the run-list managed by the HWS. When the HWS selects the second process to run from the run-list, the CP will dispatch the second process and restore any context necessary for the execution of the second process on the APD.","The Summary and Abstract sections may set forth one or more but not all exemplary embodiments of the present invention as contemplated by the inventor(s), and thus, are not intended to limit the present invention and the appended claims in any way.","The present invention has been described above with the aid of functional building blocks illustrating the implementation of specified functions and relationships thereof. The boundaries of these functional building blocks have been arbitrarily defined herein for the convenience of the description. Alternate boundaries can be defined so long as the specified functions and relationships thereof are appropriately performed.","The foregoing description of the specific embodiments will so fully reveal the general nature of the invention that others can, by applying knowledge within the skill of the art, readily modify and\/or adapt for various applications such specific embodiments, without undue experimentation, without departing from the general concept of the present invention. Therefore, such adaptations and modifications are intended to be within the meaning and range of equivalents of the disclosed embodiments, based on the teaching and guidance presented herein. It is to be understood that the phraseology or terminology herein is for the purpose of description and not of limitation, such that the terminology or phraseology of the present specification is to be interpreted by the skilled artisan in light of the teachings and guidance.","The breadth and scope of the present invention should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS\/FIGURES","p":["The accompanying drawings, which are incorporated herein and form part of the specification, illustrate the present invention and, together with the description, further serve to explain the principles of the invention and to enable a person skilled in the pertinent art to make and use the invention. Various embodiments of the present invention are described below with reference to the drawings, wherein like reference numerals are used to refer to like elements throughout.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 1B","FIG. 1A"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
