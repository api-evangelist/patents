---
title: Service adaptation definition language
abstract: A back-end service adaptation system provides access to normalized data in a data repository for a consumer runtime environment sending a query request for denormalized data. The back-end service adaptation system can include a data access service layer, a parser layer, and a back-end service adaptation runtime layer. The consumer runtime can use a service adaptation definition language (SADL), and the parser and data access service can be configured to convert and translate the SADL request for the back-end service adaptation runtime layer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08387030&OS=08387030&RS=08387030
owner: SAP AG
number: 08387030
owner_city: Waldorf
owner_country: DE
publication_date: 20091228
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The subject matter described herein relates to data service adaptations between a provider layer and a consumer layer such as a consumer runtime environment.","Business objects or other data objects in an object-oriented computer program can represent the entities in a business domain that the object-oriented computer program is designed to support. Business objects are also sometimes referred to as domain objects. A domain model can represent the set of domain objects and the relationships between them. A business object can encapsulate all or at least some of the data and business behavior associated with the entity that it represents. In some applications for example an enterprise resource application such as those available from SAP AG (Walldorf, Germany), a business object can be modeled and implemented in a normalized manner to optimize service provisioning. However, normalized business objects can be less convenient for certain consumer needs which can, in some examples, be more efficiently satisfied using denormalized views. For example, joined data of other business objects for use in a user interface, a form, an agent, a data analytic routine or module, or the like may be more efficiently accessed using one or more denormalized views. A service adaptation can provide a mapping facility to fill the gap between the provider layer, for example one or more repositories storing data and data objects, and a consumer layer that accesses the data and data objects.","Frontend service adaptation allows for the combination of fields from different business object nodes so that a resulting adapted business object node can be used for displaying required business data in a user interface. With frontend service adaptation, an adapted business object node is configured to contain fields from different business object nodes along an association path. Such an arrangement can result in a large amount of meta-data residing and being processed by a frontend server. In addition, during runtime, all data on an associated path is transferred to the frontend server. Moreover, many association paths may need to be evaluated on the frontend in order to access required business object fields. All of such requirements relating to frontend service adaptation can negatively affect performance, network data volume, memory consumption, and response time for the corresponding user interfaces.","In one aspect, a computer-implemented method includes receiving, at a service adaptation definition language-specific data access service of a back-end service adaptation system that is implemented on at least one processor, a query request in a service adaptation definition language (SADL) from a runtime application executing in a SADL consumer runtime environment on a client machine. The query request requests runtime access to a runtime instance of a data object via the consumer runtime environment. The data object includes application data that are stored in an application repository. The service adaptation definition language-specific data access service creates a denormalized data object. An interpreter of the back-end service adaptation system executes a runtime load compiled from a SADL source code provided by the SADL consumer runtime environment that includes an execution plan for retrieving and converting the normalized data. Executing the runtime load includes retrieving the application data from the application repository and converting the application data for inclusion in the denormalized data object according to the execution plan. The denormalized data object containing the converted application data is delivered to the SADL consumer runtime environment.","In optional variations, one or more of the following features can be included. The application data can be either normalized or denormalized. The interpreter can call at least one of a search plug-in and a local client proxy according to the execution plan of the runtime load. The search plug-in and\/or the local client proxy access the application data repository to retrieve the application data. A SADL parser of the back-end service adaptation system can create, from the source code in the service adaptation definition language, a compiler format of adaptation meta-data necessary to provide runtime access to the application data. A compiler of the back-end service adaptation system can generate, using the compiler format, the runtime load. The generating can include calling, by the compiler, at least one search plug-in to determine the execution plan to provide optimal performance in response to the query request. The runtime load can be stored by the compiler in a load cache, and the interpreter can access the runtime load from the load cache via the compiler.","An SADL parser of the backend service adaptation system can verify a proper syntax of the query request. A load availability check can be performed to determine whether the runtime load has been previously generated and is up to date. If the load availability check determines that the runtime load has been not previously generated or is not up to date, the method can further include receiving the SADL source code from the SADL consumer runtime environment, and calling the SADL parser to trigger generation of the runtime load from the SADL source code by a compiler of the back-end service adaptation system. The SADL parser can translate the SADL source code into a language-independent format usable by the compiler.","Articles are also described that comprise a tangibly embodied machine-readable medium that stores instructions. When executed by at least one processor or machine (for example a programmable computer), these instructions cause the at least one processor to perform operations such as those described herein. Similarly, computer systems are also described that may include at least one processor and at least one memory coupled to the processor. The memory may include a program or programs that cause the processor to perform at least one of the operations described herein.","The details of one or more variations of the subject matter described herein are set forth in the accompanying drawings and the description below. Other features and advantages of the subject matter described herein will be apparent from the description and drawings, and from the claims.","When practical, similar reference numbers denote similar structures, features, or elements.","By shifting service adaptation to the backend, performance, network data volume, memory consumption, and response times can all be improved. These improvements are based, in part, on a reduction of meta-data on the frontend, data transferred to the frontend, and fewer roundtrips between the frontend and the backend. An example of backend service adaptation is described in co-pending and co-owned U.S. patent application Ser. No. 12\/246,247, the disclosure of which is incorporated herein by reference in its entirety.","A consumer runtime environment provided by a different vendor or that is otherwise not native to one or more data sources in a data provider layer may not be directly compatible with a business or data object meta-model used by the data provider layer. In currently available solutions, a support mechanism for integrating otherwise incompatible consumer runtime environments with a data provider layer is typically based on open schema standard like Extensible Mark-up Language (XML) Schema Definition (XSD) or open protocols like Web Services. For example, only data-oriented mapping facilities might be provided from proprietary data types, for example Advanced Business Application Programming (ABAP, available from SAP AG, Walldorf, Germany), Java data types, or the like to business object node attributes.","According to one or more implementations of the current subject matter, more full-featured access to such data types via a specific language, such as for example Business Query Language (BQL), Service Adaptation Definition Language (SADL), or the like, can be supported by a data access service (DAS) layer of a service adaptation system. In some variations, data can be stored in service data objects (SDOs), which can be internally-based on an ABAP table format. Data access to these SDOs can be provided by one or more available application programming interfaces (API) to facilitate good performance, convenience of data access, and a broader range of data access tools and features to different data users via multiple, possibly incompatible, consumer runtime environments that are not native to the data format used in the data provider layer.","Different languages can be provided for defining queries and joining data using a language-parser-compiler-interpreter approach. An architecture for such an approach can include a single runtime that supports all available data mapping features and allows runtime APIs to access these available data mapping features. The feature set can be separated into an interpreter and compiler feature set.","The compiler feature set can be language independent and can provide APIs for generating a back-end service adaptation runtime load which can be used by an interpreter. The load can be generated transiently just for one session or it can be cached server-wide (shared memory) or system-wide (database). In addition, the compiler can provide a validation API to validate a concrete abstract syntax tree (specific query and\/or mapping) against the content of the runtime repository. The validation API can provide design-time support for a \u201ccheck button\u201d feature that allows real time diagnostics to be executed.","The runtime interpreter can also be language independent and can execute one or more of a specific query, a specific mapping, or the like. The runtime interpreter can also provide additional facilities such as in-memory aggregation if this is not available by the runtime execution plug-ins, such as for example the Fast Search Infrastructure (FSI) or Object-Relational mapping (O-R mapping).","One or more languages or data formats can be supported via an abstract syntax tree by a service adaptation layer according to implementations of the current subject matter. For example, the Business Query Language (BQL) can be supported to provide an easy to use and quick to learn beginner's language that is similar to Structured Query Language (SQL). A service adaptation definition language (SADL) can also be provided as an Extensible Markup Language (XML) that provides broad feature set support, repository integration, flexibility facilities, and the like. For each supported language, a different parser can be provided to handle creation of an abstract syntax tree for a service adaptation compiler that provides syntactical checks for the specific language. A semantic check of the abstract syntax tree can be provided by the service adaptation compiler in a language independent way.","A query called on a business object node and originating, for example, at a user interface of a consumer runtime environment on one or more client machines can act as a starting point for a service adaptation process. In addition, data of other intra-business object or cross-business object nodes can be joined by a service adaptation and the result displayed in a user interface. For business intelligence reporting, a query can be created based on business object node attributes. Such a query is typically not modeled in the business object. Instead, so-called searchable fields can be marked in the business object nodes so that a query builder can determine which fields can be used in the search conditions and which fields can only be joined. Searchable fields are fields that can be accessed very quickly because they are available and\/or replicated, for example cached in memory, in a search engine. One example of a search engine is the TREX search engine available from (SAP AG, Walldorf, Germany). Other fields can be inserted, but typically not conveniently searched, if they are calculated at runtime and therefore have no persistence, and\/or if they are not replicated in a search engine (because of the performance demands that can arise from using a standard database index for a search if no search engine index is available). To improve performance, additional reporting features, such as for example aggregation, other query conditions that can use Boolean expressions or SQL where clauses (for example), or free defined queries can be supported by the underlying query engine close to the persistency. For a case in which a spreadsheet is used for reporting, a key user and\/or an end user may need to customize the report in an ad-hoc scenario by joining additional business object node attributes to a report or by using additional business object node attributes in the search and aggregation conditions. Some user interfaces can be based on enhanced controller objects (ECO) or other types of technical business objects. Mapping between node attributes of such technical business objects and mapped business object node attributes can be supported by business object to business object mapping. The entry point for a user interface in this example can be a query of a business object node.","In an implementation, a system  as shown in  can include one or more processors, programmable machines, computers, or the like that execute one or more software modules or other machine readable instructions that implement various functionality consistent with one or more aspects or features of the current subject matter. As shown in , the system includes a service adaptation runtime layer , a parser layer , and a data access layer . The service adaptation runtime layer can be a back-end service adaptation runtime layer  as shown in .","A consumer runtime environment, which can be a SADL consumer runtime environment or an other consumer runtime environment , can be implemented on the one or more processors, or alternatively on one or more client machines in communication with the one or more processors over a computer network. The computer network can be a local or wide area network, an organization's intranet, the Internet, or the like. The consumer runtime environment , can access a repository , which can be a meta-data repository, either locally or over a network. In some cases, the consumer runtime environment , can be part of a front-end (e.g., client-side) application and the provider business objects can be part of a back-end (e.g., server-side) system.","The service adaptation runtime layer  can, in some implementations, for example to improve performance, be executed as a back-end service adaptation layer  as shown . In other implementations, the service adaptation layer  can also be defined in other design time environments than those provided by the back-end service adaptation system . A back-end service adaptation approach can include at least one language in a format that is transportable between different systems and that is provided by the back-end service adaptation layer . A service adaptation definition language (SADL) can be aware of code exits for calculated fields and can be seamlessly integrated in the flexibility facilities of the system. Other languages, such as for example BQL, and the like can also be supported. Other languages can be easily supported according to the current subject matter without modifying the compiler  or the interpreter , both of which are language-independent. A new language-specific parser  and language-specific data access server (DAS)  can be added to the parser layer  and the data access layer , respectively, so that the back-end service adaptation system  can be supported in addition to SADL and\/or BQL.","The BSA compiler  can provide an interface to the parser layer  where service adaptation meta-data can be passed. In an implementation, the BSA compiler  defines a parser independent format which can be compiled in an optimized format for the consumer runtime environment . A runtime load  can be cached in the load cache  or other shared memory to provide access to the runtime load  at runtime. The BSA compiler  can provide an internal channel for the BSA interpreter  to retrieve the runtime load  load cache . The BSA compiler  can store service adaptation meta-data in the repository  or, alternatively, in another repository (not shown in ), to recompile the runtime load  when it is needed. Identification of the runtime load  can include an Universal Unique Identifier (UUID) as part of input meta-data. A consumer runtime environment or can provide a source code document, for example via a mapping provider for a SADL consumer runtime environment , if the availability check fails. In implementations where the back-end service adaptation system  does not include a repository in which to store the source code document, the consumer runtime environment or can store the source code document in the repository  or some other repository. The BSA compiler  can access the meta-data repository  where business object meta-data can be stored, to get necessary information about the business objects being mapped in the service adaptation language (for example SADL, BQL, or another language).","The BSA compiler , which can be service adaptation language independent, can also validate the adaptation meta-data to check whether the business objects within the back-end service adaptation are used correctly. This validation can especially be used in design time tools for syntax checking. During compilation, the BSA compiler  can determine the best strategy to fulfill the user request in the most efficient way. This can be advantageous for a search scenario where several optimizations are possible during runtime. In some implementations, one or more search plug-ins  can be called by the BSA compiler  and\/or the BSA interpreter  to find a best search strategy. Alternatively, a local client proxy (LCP)  can be called to provide input to the best search strategy. Such a strategy can also be stored as part of the runtime load . The LCP  and the search plug-ins  can each access one or more application data repositories  from which the consumer runtime or requests data access.","Examples of search plug-ins  can include, but are not limited to FSI and Business Object Processing Framework (BOPF), which is a generic framework for persistency and business logic of application data. A FSI plug-in can analyze whether there is a FSI view that can be used for executing the user request or creating a new FSI view. A BOPF plug-in can analyze database tables, for example in the repository  where the data for the business subjects are stored. The plug-ins  can be registered in a registry and can be called via an interface so that the plug-ins  can be implemented independently from the back-end service adaptation runtime layer .","As shown in , the parser layer  can include one or more of a SADL parser and a BQL parser . As noted above, other languages can also be supported. A language-specific parser can be provided in the parser layer  for each supported language. In an implementation, a service adaptation description language (SADL) can be an XML-based language that describes mappings between data structures and attributes of business object nodes via XPath-like expressions. The mapping features within the SADL can include simple field mappings and enhanced mapping capabilities. Enhanced mapping capabilities can include, but are not limited to key-mapping. The SADL source can be passed to the BSA runtime layer  via the SADL parser .","To provide access to a SADL consumer runtime environment , the SADL parser can check the syntax of a SADL source and translate the SADL source into a format usable by the BSA compiler . In an implementation, the SADL parser can provide an interface that validates the syntax of the SADL source. This interface can be used in design time tools to check the SADL source and to provide the SADL source to the SADL consumer runtime environment . A generation step can also be triggered via the SADL consumer runtime environment during runtime in the event that a consumer meta-data object has been changed, for example due to an upgrade of the system or some other event that causes change in a business object or its underlying data. The SADL source can be indicated via an UUID which can be defined in header data of a definition source.","In an alternative or additional implementation, a SQL dialect called Business Query Language (BQL) can be used to describe free-defined queries on business objects. One advantage of BQL is its easy to learn syntax. In combination with additional meta-data in the business object model to mark business object node attributes as searchable fields, BQL can provide a quick to learn and easy to use consumer interface for the application platform. A BQL parser in the parser layer  can be used to translate a BQL statement to the format of the BSA compiler . The BQL parser can also provide an interface to validate the syntax of the BQL statement. This interface can be used in design time tools to check the generated BQL string.","The BSA interpreter  of the BSA runtime layer  can be called by a SADL data access service , a BQL data access service , or another language data access service of the data access layer , for example using an object key of the runtime load . The BSA interpreter  can retrieve the runtime load  from the BSA load cache  and execute the necessary operations. This execution can either be done via the plug-ins  or via a local client proxy  depending on the execution strategy determined by the BSA compiler  during compilation. In case the query can be executed via a BOPF plug-in, the plug-in can execute an open SQL select statement on the underlying database tables. To improve speed and efficiency of execution of a request from the consumer runtime environment or , the BSA interpreter  can store results of a local client proxy call in the temporary runtime buffer  to prevent unnecessary duplicate calls. The BSA interpreter  can also integrate authority check capabilities on functional and instance levels as supported by a protocol, concept, or the like used by the back-end service adaptation system or other enterprise systems used by an organization or the like for authorization checks. One example of such a concept is Role-Based Access Management (RBAM), which is used in some systems available from SAP AG (Walldorf, Germany).","The consumer API or other consumer runtime environment or can provide the entry point for application developers to consume the framework. A service adaptation format according to an implementation of the current subject matter can comply with a different set of requirements for each of several consumers. One consumer can be a user interface which normally wants to retrieve only the data that is currently displayed on the screen. In such an example, the consumer runtime environment -(API) needs capabilities to load data on demand. Alternatively, in an \u201capplication To X users\u201d (A2X) agent scenario, the complete data can be retrieved via one call. Data access services according to implementations of the current subject matter can separate data objects and data access services. Data access services -can provide an API to read data from business objects into a data source neutral object. The result of a data access service -can be a data object or a collection of data objects. In this manner, the framework can be more readily enhanced to deal with other data sources, such as for example business configuration data or the like. A data access service  can be provided to retrieve read-only data from a provider layer (for example a repository ) via a BQL statement based on the BQL specification or via a SADL specification. Both data access services -can call the BSA interpreter  to provide the requested data. In addition, the consumer runtime environment -can also provide meta-data access to retrieve, such as for example user interface related information including but not limited to value help, label texts, or the like.","The interaction of the above described system features will now be explained in additional detail in regards to an illustrative runtime scenario, for example in conjunction with a consumer runtime, such as for example a user interface (UI) runtime, an \u201capplication To X users\u201d (A2X) runtime, or the like.  shows a sequence diagram  of an example runtime execution.","As shown in , after activation of a consumer runtime , which can be a SADL consumer runtime , a BQL consumer runtime , or a consumer runtime of another supported language, the consumer runtime  accesses runtime meta-data from a meta-data repository  at . The meta-data repository  returns the accessed meta-data at . The consumer runtime  extracts a key and forwards the key to a language parser  at  to check on the availability of a runtime load. The language parser  can be a SADL parser , a BQL parser , or another language parser. The language parser  relays this runtime load availability check to a back-end service adaptation compiler  at . The back-end service adaptation compiler  returns a status of the runtime load availability to the language parser  at  and in turn the language parser  returns the status to the consumer runtime  at .","If no load is available, for example because a load has not been previously generated, the consumer runtime  extracts a source code. The source code can be retrieved from a repository of the consumer runtime , or generated by the consumer runtime  based on other data in the repository at the consumer runtime . For example, a user interface runtime can generate a SADL from its UI model. The source code can be provided by the consumer runtime  in a language native to the consumer runtime . In one implementation, the source code is provided in SADL. In another implementation, SADL and other languages are supported by the back-end service adaptation system  by inclusion of a language-specific parser in the parser layer  and a language-specific data access service in the data access layer  corresponding to each service adaptation language that the back-end service adaptation system  supports.","The language parser  transforms the adaptation data received from the a consumer runtime  using the corresponding language into the internal, language-independent format used by the BSA compiler . In some implementations, the consumer runtime  can provide a mapping provider that implements a callback method called by the language parser  to access the source code document in the language of the SADL consumer runtime document if the runtime load  is not available or if it is out of date. For other service adaptation languages, for example BQL, the source code can be directly given (since BQL is an ad-hoc scenario) without any callback mechanism. At , the consumer runtime  calls the language parser  with the source code to trigger generation of a runtime load . The language parser  checks the syntax of the source code, creates a compiler format of the adaptation meta-data, and calls the BSA compiler  at . The BSA compiler  can determine a runtime execution strategy with the assistance of one of more search plug-ins  at . Input from the search plug-ins  regarding the runtime execution strategy can be returned at  so that the BSA compiler  can generate a runtime load . The runtime load can be generated if necessary, but more or less independent of the consumer using the consumer runtime . If the consumer wishes to retrieve the data via the DAS or , the runtime load can contain the execution plan telling how to retrieve the data.","Once a runtime load  is available, the consumer runtime  initiates data retrieval via a language data access service (DAS)  at . The language DAS  can be a SADL DAS , a BQL DAS , or another language DAS. The language DAS  triggers a back-end service adaptation interpreter  at . At , the BSA interpreter  accesses the runtime load  from a cache at the BSA compiler , and the runtime load  is returned at . Depending on the runtime execution strategy, execution of the runtime load  can include one or more calls to the one or more search plug-ins  at  and\/or to an LCP  at  with data returned to the BSA interpreter  at  and , respectively. The BSA interpreter , using the runtime load  and the returned data, creates one or more data objects that are returned at  to the language DAS . The one or more data objects are then delivered at  by the language DAS  to the consumer runtime .",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 3","b":["300","302","304","306","310","312","314","316","320","302","322","324","326","302","110","302","322","312","302","312","322","302","312","322","110","302","312","322"]},"In an implementation, a back-end service adaptation SADL XML source format can be used to provide one or more features and advantages of the current subject matter. The process flow diagram  of  illustrates a method for back-end service adaptation. At , a back-end service adaptation system implemented on at least one processor receives a query request from a runtime application executing in a consumer runtime environment A on a client machine. The consumer runtime environment uses SADL. The query request requests access via the consumer runtime environment to application data, that can be normalized or denormalized, stored in a data repository . At , a SADL parser of the back-end service adaptation system  creates a compiler format of adaptation data necessary to provide runtime access to the application data to reply to the query request. At , a data access service A of the back-end service adaptation system  creates a denormalized data object by calling the BSA interpreter . At , the BSA interpreter  executes a runtime load  retrieved from the load cache  via a BSA compiler . The runtime load  can contain an execution plan defining how the application data can be retrieved and a strategy indicating whether a local client proxy (LCP) , a search plug-in , or the like should be used in converting the data to a denormalized format for use by the SADL consumer runtime environment . Execution of the execution plan of the runtime load  results in the back-end service adaptation system  retrieving the application data from one or more of the application data repositories  and converting the retrieved application data to the requested format according to the execution plan. The denormalized data object containing the retrieved and converted application data is delivered to the SADL consumer runtime environment at .","In an additional implementation, a back-end service adaptation can be provided for an other consumer runtime environment using an other service adaptation language as shown in the process flow chart  of . At , a back-end service adaptation system  that is implemented on at least one processor receives a query request from a runtime application executing in an other consumer runtime environment on a client machine. The query request requests runtime access to a runtime instance of a data object via the consumer runtime environment . The data object includes application data that are stored in an application repository . The query request designates an application programming interface suitable for a service adaptation language used by the other consumer runtime environment . At . the back-end service adaptation system  instantiates an other language-specific data access service for the service adaptation language according to the application programming interface. The other language-specific data access service creates, at , a target data object to fulfill the request. At , the back-end service adaptation system  converts application data retrieved from the application data repository  in accordance with an execution plan defined by an interpreter  and a compiler  of a back-end service adaptation runtime layer  of the back-end service adaptation system . The execution plan is stored in a runtime load  compiled from a service adaptation language source code provided by the consumer runtime environment. The target data object containing the retrieved and converted application data is delivered to the consumer runtime environment at . An other language-specific parser can be provided at a parser layer  of the back-end service adaptation system . The other language-specific parser can create a compiler format of adaptation meta-data necessary to provide runtime access to the application data to reply to the query request. At , a language-specific data access service is instantiated in a data access service layer of the back-end service adaptation system.","An XML source format can be oriented on a standard such as XSD\/XPath or the like. In an implementation, the Service Adaptation Description Language (SADL) is used. For this language, a namespace xmlns:sadl can be defined and used. A sadl:definition can also include other namespaces to avoid naming conflicts. The namespace of business objects for which service adaptation is to be provided can be an Enterprise Services Repository (ESR) namespace of the business objects. Namespaces with prefixes for associations, attributes, and other BO components can be used to facilitate distinguishing within a business object. For example, within a content of a binding attribute, an association name or attribute name (or other BO component) can occur. To avoid name clashes, such as associations and attributes having the same names within a business object node, a default namespace can be used the namespace for the business object attributes. User defined namespace prefixes can also be specified in a SADL XML document. An SADL parser can check the uniqueness of the namespace prefixes. Therefore a sadl:definition can contain a sadl:dataSource where the type of the data source (for example, a business object), the binding (for example an entry path of the business object) and a name (which can be used as alias in an XML document), are specified.","In a sadl:definition, the sadl:resultSet can also be defined. The sadl:resultSet can contain a sadl:structure with the attributes and substructures. In a sadl:atttibute, the name of the attribute and the binding can be specified. The binding can contain, in a Xpath-like syntax, an access path for mapping to the business object data. For example, such an approach can provide either direct business object attribute access of the node as specified in the binding of the sadl:dataSource (for example using \u2018\/\u2019 for subcomponent access in the attribute type) or business object attribute access with sub path specification via business object associations (for example with a namespace prefix such as \u201cassoc:\u201d or \u201cass:\u201d to denote an association) using \u2018\/\u2019 for the association links.","A sadl:definition can contain a list of XML namespace definitions, possibly including but not limited to the UUID of the SADL, the date and time of the SADL (CreatelLastChange), one or more sadl:dataSource definitions, a list of sadl:callbacks (can be empty), and a sadl:resultSet. A sadl:dataSource can advantageously contain the data in some type. If the data source type is a business object node type, a binding can be defined. Especially when several data sources are specified, naming of the data source can be very helpful. The data source names can be used in the source definition as aliases to distinguish accesses to the different data sources. A sadl:callback can contain the programming language of the callback, the callback's class name, the names of the target business object type, the target node name, and the path ID of the callback. The callback can be used in any binding definition where an association can occur by specifying the callback name, for example with a prefix such as \u201cclb:\u201d. Filtering by an association filter can also be provided. Filter expressions can be defined in brackets. In an implementation, an attribute binding can allow only one-to-one associations if a filter is not specified.","For a SADL consumer, the resulting structure need not necessarily be a structure specified in the result sadl:resultSet. Some consumers, such as for example an A2X service, a modeled agent, or the like, can prefer to pass a predefined type. In such an example, the resulting structure could also be an input of the data access service runtime for SADL. It can be advantageous for the resulting structure to be type compatible with the structure defined in the sadl:resultSet. A sadl:resultSet can be defined by a sadl:structure, that can have a name, a data source identifier, a binding and an explicit cardinality definition.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 6","b":"600"},"The sadl:structure can also contain a list with at least one attribute or substructure. The cardinality of the structure can be derived from the business object meta-data by default. A sadl:attribute can have a name and can have a binding or type and a behavior attribute definition. In the binding definition, the access paths are specified either to the attributes directly or via association paths, or a function call is specified. As noted above, association identifiers can be qualified with an association namespace prefix, for example \u201cass:\u201d or \u201cassoc.\u201d. In the binding of the data source definition, the path for the business object root can be used. If an association- or path-callback is used for the association path then a qualified path identifier, for example having a callback namespace prefix such as \u201cclb:\u201d, can be defined.","A sadl:callback can be used for an association or a path callback. For example, traversing to a target business object and a target business object node can be implemented in an ABAP class. The sadl:callback definition can therefore contain a class name, a target business object, a target node and a name representing a path ID. To facilitate compatibility with other programming languages, the programming language of the callback can be defined in a type attribute of sadl:callback. The callback can be used in any structure and attribute binding definition where an association can occur, for example by specifying a callback name with a prefix such as \u201cclb:\u201d.  shows an example of a source code  illustrating an implementation of sadl:callback.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 8","b":"800"},"Filtering via the login language used by the consumer runtime environment can also be provided. For example, as shown in the example source code  of , a variable, for example \u201cSY-LANGU\u201d can be used as the expression value in an association filter definition to support filtering by the login language for language-dependent attributes.","The attributes in a SADL result set can also contain a specification of a behavior attribute, for example one that determines whether attributes of the result are searchable. For example, an \u201cis Searchable\u201d behavior attribute can have the value \u201cTRUE\u201d to indicate that the sadl:attribute is used in a search condition or \u201cFALSE\u201d to indicate that the sadl:attribute is not used in a search condition. The \u201cFALSE\u201d value can be the default, to indicate that all attributes without explicit specification of the is Searchable attribute are not used in a search condition. In the example shown in the example source code  shown in , a sadl:attribute \u201cPRODUCT-NAME\u201d is used for selection and is part of the result structure.","To be able to declare that an attribute is used in a search condition, but not part of the result structure, additionally an \u201cis Output\u201d behavior attribute with the value FALSE can be used. The \u201cis Output\u201d behavior attribute can have the value of \u201cTRUE\u201d to indicate that the sadl:attribute is part of the result set or \u201cFALSE\u201d to indicate that the sadl:attribute is not part of the result set. \u201cTRUE\u201d can be the default value. In an example, the \u201cis Searchable\u201d behavior attribute can be used to check whether a corresponding FSI query view contains the business object attribute. For example, for a sadl:attribute with the \u201cis Searchable\u201d value \u201cTRUE\u201d, a FSI view containing the corresponding BO attribute can be mandatory, because such attribute is used in the selection parameters of a \u201cfree\u201d query. If the FSI view is not available, the generation of the FSI view can be triggered by the SADL parser during the query consumer runtime. The generation of a FSI view may be successful only when a search engine load for this attribute is already available. The search engine can in one example be the TREX search engine available from SAP AG (Walldorf, Germany). Otherwise, the SADL parser can trigger an exception, return an error, or the like because the \u201cfree search\u201d query could not be executed with good performance by using the fast search infrastructure (FSI).","The subject matter described herein can be embodied in systems, apparatus, methods, and\/or articles depending on the desired configuration. In particular, various implementations of the subject matter described herein can be realized in digital electronic circuitry, integrated circuitry, specially designed application specific integrated circuits (ASICs), computer hardware, firmware, software, and\/or combinations thereof. These various implementations can include implementation in one or more computer programs that are executable and\/or interpretable on a programmable system including at least one programmable processor, which can be special or general purpose, coupled to receive data and instructions from, and to transmit data and instructions to, a storage system, at least one input device, and at least one output device.","These computer programs, which can also be referred to programs, software, software applications, applications, components, or code, include machine instructions for a programmable processor, and can be implemented in a high-level procedural and\/or object-oriented programming language, and\/or in assembly\/machine language. As used herein, the term \u201cmachine-readable medium\u201d refers to any computer program product, apparatus and\/or device, such as for example magnetic discs, optical disks, memory, and Programmable Logic Devices (PLDs), used to provide machine instructions and\/or data to a programmable processor, including a machine-readable medium that receives machine instructions as a machine-readable signal. The term \u201cmachine-readable signal\u201d refers to any signal used to provide machine instructions and\/or data to a programmable processor.","To provide for interaction with a user, the subject matter described herein can be implemented on a computer having a display device, such as for example a cathode ray tube (CRT) or a liquid crystal display (LCD) monitor for displaying information to the user and a keyboard and a pointing device, such as for example a mouse or a trackball, by which the user may provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well. For example, feedback provided to the user can be any form of sensory feedback, such as for example visual feedback, auditory feedback, or tactile feedback; and input from the user may be received in any form, including, but not limited to, acoustic, speech, or tactile input.","The subject matter described herein can be implemented in a computing system that includes a back-end component, such as for example a data server, or that includes a middleware component, such as for example an application server, or that includes a front-end component, such as for example a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described herein, or any combination of such back-end, middleware, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication, such as for example a communication network. Examples of communication networks include, but are not limited to, a local area network (\u201cLAN\u201d), a wide area network (\u201cWAN\u201d), and the Internet.","The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.","The implementations set forth in the foregoing description do not represent all implementations consistent with the subject matter described herein. Instead, they are merely some examples consistent with aspects related to the described subject matter. Although a few variations have been described in detail above, other modifications or additions are possible. In particular, further features and\/or variations can be provided in addition to those set forth herein. For example, the implementations described above can be directed to various combinations and subcombinations of the disclosed features and\/or combinations and subcombinations of several further features disclosed above. In addition, the logic flow depicted in the accompanying figures and\/or described herein do not necessarily require the particular order shown, or sequential order, to achieve desirable results. Other implementations may be within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF DRAWINGS","p":["The accompanying drawings, which are incorporated in and constitute a part of this specification, show certain aspects of the subject matter disclosed herein and, together with the description, help explain some of the principles associated with the disclosed implementations. In the drawings,",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
