---
title: Resources managing in isolated plurality of applications context using data slots to access application global data and specification of resources lifetime to access resources
abstract: Methods and apparatus, including computer program products, for application management. Application management may include managing a context of an executing application such that the application is isolated from contexts of other executing applications. Furthermore, application management may include providing methods for accessing resources for the context of the executing application, the resources to process application tasks, and managing the resources.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08032890&OS=08032890&RS=08032890
owner: SAP AG
number: 08032890
owner_city: Walldorf
owner_country: DE
publication_date: 20031223
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Example"],"p":["This application claims the benefit of the filing date of U.S. Provisional Application No. 60\/489,573 for ENTERPRISE SERVICES FRAMEWORK TECHNOLOGIES, filed Jul. 22, 2003, the disclosure of which is incorporated by reference in its entirety.","The invention relates to data processing by digital computer, and more particularly to application business object processing.","Large scale business software applications are sometimes categorized in terms of a \u201cfront end component\u201d that includes a graphical user interface (GUI) to present data to users and accept data entry from users. Such front end components may be customized for specific customers. Another component of such software applications is sometimes referred to as a \u201cback end component\u201d that stores business data and processes the business data according to business logic. The back end component retrieves, generates, and maintains the business data. The back end component is usually responsible for the consistency and correctness of the data. The back end component also can store relationships between the various data. In a typical business software application, the front end component includes application code to display and aggregate data of the back end and provides help to generate requests to the back end for update operations.","The data of the back end can be represented using relational database terminology. In relational database terminology, an entity is a record, and an entity type is a set of entities with common attributes to which a unique name and a unique description are assigned. Typically, a database has multiple two dimensional tables where each table represents an entity type and each row in each table represents an entity. An attribute is a description of a characteristic of an entity or entity type. Typically, an attribute is specified in a field or a column in a database table. Entity types can also have relationships that enable linking one or more entities of an entity type to other entities of another entity type. This linking can be performed using foreign keys by having one or more fields in one table pointing to a primary key of a second table. This allows traversing from a set of entities in one table to related entities in another table.","In one aspect, a system and a method, including instructions stored on a machine-readable medium, for application management are provided. The system and method include the ability to provide methods for accessing resources for a context of an executing application, the resources to perform application tasks, and manage the resources. The resources may include back end and operating system resources. The system and method may additionally include the ability to manage a context of the executing application such that the application is isolated from contexts of other executing applications.","In certain implementations, the system and method also include the ability to provide methods for accessing variables of the context of the executing application. The methods may include the ability to allow the executing application to generate, set values of, get values of, and remove variables. The variables may be accessed from all levels of the executing application.","In particular implementations, the system and method additionally include the ability to borrow one or more resources from a resource provider that is integrated and published at runtime. The resources may be specified by their types and parameters, and the source of the resource providers may be unknown to the executing application.","In some implementations, the system and method may further include the ability to publish and subscribe events in a context of the executing application.","In certain implementations, the system and method may additionally include the ability to define and control transactional boundaries. Defining and controlling transactional boundaries may include defining a transactional boundary for a request-response cycle such that system resources are not allocated to the application context while waiting for an external input.","Particular implementations may include various options. For example, the methods for accessing resources may allow for the specification of resource lifetimes. Moreover, front end and back end life cycles may be synchronized. As another example, the lifetime of an allocated resource may be bound to the lifetime of a request. As a further example, managing the resources may include monitoring lifetime scopes of the resources. A resource may be released when the resource is out of scope. As an additional example, managing the resources may include determining the dependency of resources on other resources. The dependent resources may be mapped into a resource tree, which may be associated with the application context. In some implementations, the root node of the resource tree is a lifetime resource. Managing the resources further may include notifying children of a resource when the resource is to be released. As another example, managing the resources may include recovering from an application failure. Recovery may include releasing resources associated with a failed application.","In certain implementations, the accessor interface provides methods for accessing services for a context of an executing application, the services for manipulating the resources, and the server framework manages the services. The services may be provided by service providers.","In another general aspect, a system for application management includes an application framework and a server framework. The application framework includes an accessor interface and an event dispatcher. The application framework is operable to provide methods for accessing variables of a context for an executing application and to provide methods for accessing resources associated with the application context, the resources to perform application tasks, wherein the methods allow for the specification of resource lifetimes. The application framework is also operable to define and control transactional boundaries, wherein a transactional boundary for a request-response cycle is provided such that system resources are not allocated to the application context while waiting for an external input. The event dispatcher is operable to publish and subscribe events in the context of the executing application. The server framework includes a resource manager for managing the resources. The resource manager is operable to integrate and publish the resources, to monitor lifetime scopes of the resources, and to release a resource when the resource is out of scope. The resource manager is also operable to determine dependency of the resources on each other by mapping the resources into one or more resource trees, wherein the root node of at least one resource tree is a lifetime resource and the resource tree is associated with the application context, and to notify children of a resource when the resource is to be released.","Particular implementations may include various options. For example, the variables of the context may be accessed from all levels of the executing application. As another example, one or more resources may be borrowed from resource providers that are integrated and published at runtime. The resources may be specified by their types and parameters, and the source of the resource providers may be unknown to the executing application. As a further example, the lifetime of an allocated resource may be bound to the lifetime of a request. As an additional example, managing the resources may include recovering from an application failure. Recovery may include releasing resources associated with a failed application.","These and other implementations may have one or more of the following features. There can be independent software lifecycles for resource providers and resource consumers. Additionally, resources provided by a resource-based software architecture can be reused for different situations, and generic engines in the software architecture can combine resources for new applications. Furthermore, an application context may be made available to all levels of an executing application, and the resources may be managed in an efficient manner.","The details of one or more implementations are set forth in the accompanying drawings and the description below. Further features will become apparent from the description, the drawings, and the claims.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1","b":["2","3","5","7","9","9","3","9","9","9","9","5","3","9","9","3","9","9","9","9","5","9","9","3","5","5","9","9","3","5","9","9","5"]},"As described in more detail below, separation layer  is based on a meta model that defines how back end data (e.g.,  and \u2032) are represented in separation layer . Meta data is stored in repository  that describes how the back end data  and \u2032 fit into the meta model representation. Client  interacts with back end data  and \u2032 using a generic command set defined by separation layer . As described in more detail below, separation layer  accesses service providers that perform the generic commands from client , using the meta data in repository , to effect the requested manipulation of back end data  and \u2032. The service providers are configurable so that different service providers can be used for different back end data  and \u2032. Separation layer  includes an interface (e.g., a service manager) that hides the characteristics of the corresponding back end data  and \u2032 and also the granularity and distribution of the implementation (i.e., the service providers).",{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 2","FIG. 2"],"b":["2","2","4","6","4","6","4","6","4","6"]},"A network  couples computers  and . The network  is any form or medium of digital data communication (e.g., a communication network). Examples of communication network  include a local area network (\u201cLAN\u201d) and a wide area network (\u201cWAN\u201d) (e.g., the Internet).","Computer  executes instructions of a front end application program . Application program  represents a front end component of the business software architecture . Service manager , running on computer , is a service layer between the front end application program  and a set of back end service providers . Service manager  provides a service interface to front end application program  to enable indirect interaction with the set of back end service providers  running on computer . This service interface allows for a partial separation of software development for front end application program  and the set of back end service providers .","Computer  includes a data storage device  that stores a back end database  containing data that can be used by the set of back end service providers . Computer  also includes a data storage device  containing an information repository  that defines and describes the services provided by the set of back end service providers . The meta data in repository  is organized according to a meta model.","In general, a meta model is a collection of \u201cconcepts\u201d that are the vocabulary with which a certain domain can be described. Meta models typically are built according to a strict rule set, which in most cases is derived from entity-relationship-attribute or object-oriented modeling. The front end application program  can access (and interpret according to the strict rule set) the contents of repository  via the service manager . These services support the functionality of application program  and include retrieving and reading data in addition to modifying stored data. The service providers  can access or modify stored data in back end database  to provide services to front end application program . To provide the services, the set of back end service providers , upon request from the front end application program , access or modify stored data in back end database  or calculate new data.","The repository  defines a syntax for requesting services provided by the set of back end service providers  and semantically describes the services. As front end application program  executes, it can use this syntax and semantic description from the repository  (accessed through the service manager ) to determine what services front end application program  should use to meet its requirements. This syntax and semantic description for stored or computed back end data can be referred to as \u201cmeta data\u201d. This stored or computed back end data is conceptually organized using object-oriented terminology in terms of business objects, where each business object is an instance of a class or data entity type. In one example, a class of business objects refers to a relational database table where each row of data in the table represents the data for a business object. In this example, each field in the table represents an attribute of the business object class. In another example, there is a class of business objects that partially refers to a relational database table such that some of the fields in the table represent attributes of the business object class and other fields are computed upon request.","In the business software architecture , services provided to front end application program  are focused on data (i.e., data-centric) so the description of these services in repository  is also data-centric. Thus, the meta data in repository  is structured around representations of classes of these business objects. This meta data includes aspects, or descriptions of these representations of business object classes, and descriptions of available operations on aspects such as select, insert, update, delete, select by relation, and update fields that are provided by service providers . Each description of these aspects includes data attributes as well as actions that can be requested to be executed by the set of back end service providers  on instances of these aspects.","Classifications of data, relations between data classes, prebuilt queries for accessing data, and other descriptions of data provided by the set of back end service providers  are represented by repository . This representation, or meta data, of data (e.g., stored in back end database ) provided by the set of back end service providers  describes different abstract types or classes of data in back end database  and how different data classes relate to each other. Objects are instances of these different abstract types. Meta data is information about data rather than content of the data. The meta data also defines a set of pre-built queries that can be executed on the data in database .","The semantic description in repository  can enable front end application program  to determine which services to request from service manager . These services often take the form of requesting data to display. Front end application program  reads the meta data in repository  and can flexibly request data organized in different ways that are specified by the meta data. For example, two service managers  with two different repositories  handle services that determine prices of books for companies A and B. For A and B, book prices are represented by different aspects with different data fields. Front end application program  reads A's repository  to obtain descriptions of data (including a price) concerning a particular book from A's service providers . Front end application program  reads B's repository  to obtain descriptions of data (including a price) concerning a particular book from B's service providers . Front end application program  is able to request and display the information from A's service provider  and the information organized differently from B's service provider  to present the book price information to a user.","For requesting the services described by the semantic description in repository , service manager  provides a canonical interface for services on the business objects in the back end. This canonical interface includes a set of standard operations on the business objects. Such standard operations on the business objects include select, insert, update, delete, select by relation, and update fields. These standard operations are intended to be easy to understand and use. The usage of these standard operations is understood through the strict rule set of the meta model of the repository . Furthermore, the repository  also includes documented modeling of the side effects of the usage of the operations. The side effects for an operation model which stored business objects are affected by executing the method. For example, \u201cdelete\u201d usually has an effect on specific stored business objects. Other standard methods are more specialized and support functionality for transactions between front end application program  and service manager .","The canonical interface provided by the service manager  also includes specialized actions that are defined for specific classes of business objects and queries that can be defined for clusters of classes of business objects. The clusters are modeled as service modules (described in more detail below) in the meta data. These actions and queries are also defined in the meta data of the repository .","During execution, front end application program  issues service requests to service manager , service manager  checks the requests for consistency with the meta data in repository , and then the service manager  passes the requests to back end service providers  according to the meta data in the repository database . The manner of implementing the set of back end service providers  and data in database  is independent of application , with back end service providers  and data in database  conforming to the definitions and descriptions of the meta data in the repository . Database  can be a relational database. However, database  can be modified to use a different mode of data organization other than a relational database and front end application program  does not need to be modified if back end service providers  and data in database  still conform to the meta data in the repository . One such different mode of data organization for database  can be an object-oriented database.","Front end application program  provides user interfaces displayed on monitor . Front end application program  provides application code to display and aggregate the data of the set of back end service providers . Front end application program  generates requests, via service manager , to the set of back end service providers  for standard operations such as select, insert, update, delete, and execute in addition to more specialized operations. Front end application program  is interaction-centric, focused on aggregating data of the back end service providers  and combining interactive steps into a flow of screens and syndicated screen elements.","Front end application program  contains screen-flow logic of User Interface (UI) oriented applications, and front end application program  binds a UI to the meta data in repository . Front end application program  can be indirectly bound to a specific set of back end services by back end service providers  via descriptions of the services in the meta data of the repository . Front end application program  can also be formed from various generic interaction-centric front-end layers that are only bound by configuration to a highly standardized service layer by service manager  serving as an intermediary to back end service providers .","In certain implementations, the front end application program  is not restricted to a program having a (graphical) user interface. Generally, any application can use services provided by the set of backend service providers . Example applications include a batch process that modifies or analyzes data. For instance, the front end application program  can be an application that automatically calculates proposals for paying incoming invoices based on the same encapsulation of business logic as a UI for manually maintaining payment information.","In some implementations, a service manager proxy  gives the front end application program  a buffered access to a service interface provided by service manager . Service manager proxy  is a server on computer  that acts as an intermediary between the front end application program  and the service manager  so that the business software architecture  can ensure security, administrative control, and caching service. The service manager  offers a queuing functionality, which is used by the front end application program  to bundle several service requests or commands (resulting in service methods) into a single service method queue in order to save round trips. Service manager proxy  allows front end application program  and service manager  to be separated onto different computers , . Furthermore, this can allow service manager  and the set of back end service providers  to be distributed over multiple computers.","In certain implementations, architecture  also includes a context monitor . In general, context monitor  facilitates application context encapsulation, scalability, and stability in a multi-threaded and\/or clustered server environment. There are a wide variety of applications that need an application context, which describes the application's current processing state. In particular implementations, the application context can include an application global scope in which the application can store its global data. Context monitor  can make the application context available from different levels, independent from a particular application design. Furthermore, context monitor  may manage the visibility and lifetime scopes of application contexts.","Context monitor  can also manage resources in a server environment. Resources may include file resources, database resources, repository resources, and\/or any other appropriate entities for performing application tasks. Application tasks may, for example, include storing data, retrieving data, and manipulating data. The resources may be available via services. Numerous kinds of applications need resources, which may be allocated in the hosting process, on a local machine, or in a distributed environment. Context monitor  may be responsible for allocating and releasing, sharing and locking, recovering and monitoring resources that can be used by an application. Context monitor  may ensure that available resources are used in a system efficient manner and that allocated resources of an application will be released in an application failure situation. Context monitor  may similarly manage services.","Context monitor  can also provide a notification mechanism for weak-coupled communications. Various kinds of applications need a notification mechanism for weak-coupled communication. For application isolation in a multi-threaded system environment, context monitor  provides a notification mechanism that is restricted to the application context.","Context monitor  may additionally provide application notifications. A variety of application types need notifications at particular points in time, which affects the further processing and state. The most well known phases for an application are the init and exit notifications. In a more differentiated picture, an application needs notifications or callbacks when, for example, services are failed or resources are released.","Context monitor  can provide a variety of features to architecture . For example, context monitor  can handle memory management, thread management, thread pools, dispatching and messaging, data caching and synchronization, and resource management and monitoring. This assists application development because an application developer does not have to worry about the complexity of the distributed environment in multi-threaded and clustered system environment. The context monitor  may provide an infrastructure and framework that gives an application the vision of a single-threaded and exclusive running program.","As another example, context monitor  can handle resources in an efficient manner. Resources are typically important units of an application, as an application needs special kinds of resources to process its tasks. But resources are also the critical bottlenecks for performance and scalability of a system, especially in a system environment running applications concurrently in the same process and with the same resources, which can also be external resources. Due to application failures, it is possible that one faulty or failed application impacts all other applications running in the process. For example, in productive scenarios, resources may not be released by a failed application, or resources may not be released as fast as necessary to ensure an optimal resource sharing in a server environment, which is important for the performance and scalability of a system. Because context monitor  may handle resources in an efficient manner, it may enhance system performance, stability, and scalability.","As shown in , the service manager  provides an interface (defined by the metadata in repository ) to front end application program  that hides the characteristics of the corresponding back end service providers from the set of back end service providers  and data in database . Front end application  uses this interface to display data in graphical user interface (GUI)  for interaction with a user. In other cases, front end application  uses this interface to automatically calculate data.","The service manager  provides the interface to front end application program  by receiving and executing requests from front end application program  to back end service providers , the requests possibly being bundled in a queue and dispersed by RPE . After each receipt of a request by the service manager , the service manager  delegates the request to one or more service providers , , , , , , and . Service provider  is an instance of a software class repository service provider. Service providers , , , , , and  represent instances of software classes such as query service provider class (), aspect service provider class (), transaction service provider class (), locking service provider class (), action service provider class (), and query relation service provider class (). The software classes for service providers , , , , , and  can be implemented as ABAP global classes maintained by the ABAP class library using the ABAP development environment available from SAP AG of Walldorf, Germany. They also can be implemented by any other programming language on any other platform (e.g., Java on Linux or C# on Windows).","Repository service provider  handles requests to get or modify meta data from repository . Query service provider  handles queries on data in back end database  from front end application program . Aspect service provider  handles accessing and modifying data, navigation through relations and calling actions. The aspect service provider  has a standard set of methods that correspond to the standard operations on aspects that can be requested from the service manager . These standard operations include select, insert, update, delete, select by relation, and update fields. Transaction service provider  allows business logic to act on different states of a transaction between front end application program  and service providers. Locking service provider  enables separation of concurrent accesses on data types in back end database . Action service provider  enables execution of actions on aspects. Query relation service provider  is the interface for the target aspect of a relation. In some examples, service manager  can have different multiple instances of service providers , , , , , and  for different elements in repository  representing services. Upon receiving a request for a service represented by an element in repository , the service manager  can look up a name of a service provider (e.g., , , , , , and ) in the meta data for the element in repository . For example, the meta data describing an aspect in repository  defines which aspect service provider  is designed to handle services for the aspect. The service manager  uses this information in the meta data to direct requests from the front end application program  to the appropriate aspect service provider . Similarly, the meta data describing a query in repository  defines which query service provider  is designed to handle services for the query.","In one example, the service manager proxy  communicates with service manager  using SOAP (Simple Object Access Protocol) messages via network . SOAP is a way for a program running in one kind of operating system (such as a Windows\u00ae XP Operating system available from Microsoft Corporation of Redmond, Wash.) to communicate with a program in the same or another kind of an operating system (such as Linux) by using the World Wide Web's Hypertext Transfer Protocol (HTTP) and Extensible Markup Language (XML) as mechanisms for information exchange. Since Web protocols are installed and available for use by all major operating system platforms, HTTP and XML provide a solution to a problem of how programs running under different operating systems in a network can communicate with each other. SOAP specifies exactly how to encode an HTTP header and an XML file so that a program in one computer can call and pass information to a program in another computer. SOAP also specifies how the called program can return a response.","The interface provided by the service manager  provides requests or commands to front end application program . As mentioned previously, standard commands select, insert, update, delete, select by relation, and update fields are standard operations on aspects in the repository . These standard operations are provided by aspect service provider  and correspond to some of the requests or commands available to front end application program . A \u201cSelect\u201d command provides a capability such that if the identifiers (or keys) of instances of a data type (possibly stored in database ) provided by aspect service provider  are known, front end application program  can select and read the attributes of these instances. An \u201cInsert\u201d command allows front end application program  to add new instances of a data type (possibly stored in database ) provided by aspect service provider . A \u201cSelect By Relation\u201d command provides a capability that if a data type is known, front end application program  can find other data types that have relations to this data type as defined in repository . An \u201cUpdate\u201d command provides a capability to modify instances of data types (possibly stored in back end database ) provided by aspect service provider . A \u201cDelete\u201d command provides the capability to delete one or more selected instances of one or more data types (possibly stored in back end database ) provided by aspect service provider .","An \u201cExecute\u201d action command provides a capability to execute a semantically defined action on one or more instances of one or more data types (possibly stored in database ) provided by aspect service provider . Either the aspect service provider  or the action service provider  executes the Execute action command.","A \u201cQuery\u201d command provides a capability to search and find particular data of interest. The Query command is a method with a fixed set of search parameters and a result set with a defined structure. Queries are defined for particular service modules, or clusters of aspects in the meta data of the repository . The query service provider  executes a Query command.","As discussed previously, context monitor  provides the ability to manage contexts of and resources for applications.  illustrates one example of context monitor . In this implementation, context monitor  has an application framework  and a server framework . In general, application framework  is responsible for handling tasks for a front end application, and server framework  is responsible for handling tasks for a back end server. In this implementation, context monitor  is one of the core instances of a system environment. It separates application contexts and manages system and back end resources. The hosting process, such as, for example, a Java 2, Enterprise Edition (J2EE) server or any other application server, may integrate the context monitor .","In more detail, application framework  includes an accessor interface , application contexts , and an event dispatcher . Accessor interface  is the basic application programming interface for an application running in a system environment, like J2EE server, or a stand-alone environment. Accessor interface  allows an application to access and use data, resources, and event dispatching.","Data can include access global variables for the application, which are part of the application's application context . In particular implementations, accessor interface  can be used to access data in all levels of a running application. Moreover, accessor interface  need not be restricted to the application.","To accomplish its operations, accessor interface  can provide methods for accessing the data of the current active application context  that is associated with the running application. The application contexts  describe the current processing state of the applications. The data of an application context  may be fully accessed, meaning that the application can generate and remove data and can set and get values of the data. But data may be visible only in the application context  in which it was generated. In a Java environment, the values of data may be objects. Thus, it may be possible to hold complex object networks in the application contexts .","As indicated, the context monitor  manages a collection of application related contexts . A context can be activated or deactivated by the context monitor  at special synchronization points, which can be triggered by the hosting process. A typical synchronization point is the assigning of a worker thread to a request, which activates an application context . After processing the request, the worker thread will be put back to the thread pool, which is the synchronization point to deactivate the context . If a context  is in a deactivated state, access to context specific content will be led to an exception. Other synchronization points for activating and deactivating contexts are possible, and may depend on the type of the application.","Data slots may be used to manage and access application global data, which is only visible within an application context . This technique is useful in multi-threaded system environments for application isolation. Almost every application needs some type of global data. In a multi-threaded environment, the server is shared by the applications. The data slots provide a technique for applications running in concurrent threads to identify their own global data. The access to this global data can be unsynchronized, but still thread-safe.","Accessor interface  also provides methods for resource access. For the context monitor , resources are borrowed from resource providers and are monitored. The resources may be provided by resource providers, which may be part of the context monitor framework and not visible to the application. The resource providers understand the internal features of the resources and provide the resources in an adequate way for the applications.","A resource can be specified by its type and parameters, which may be necessary to allocate the appropriate instance. Accessor interface  also allows for the specification of the lifetime of the used resources and the sharing mode. For example, it is possible that an application can bind the lifetime of an allocated resource to the lifetime of a request. In this case, the context monitor  ensures that the resource will be released when the request will be go out of scope.","Accessor interface  also allows access to event dispatcher . Event dispatcher  can be based on a publish-subscribe mechanism. Event dispatcher  has a context relation, meaning that the publishing and subscribing of events is only visible in each application context . Thus, an application does not communicate with other applications or impact other applications by events. Special services, however, may realize application-to-application communication. Multiple event subscribing can also be supported.","Examples of special services for application-to-application communication include native communication techniques like RMI (Remote Method Invocation) and sophisticated services implemented within a service-oriented framework infrastructure. Which technique to use depends on the topology. For example, consider an application that runs in the same Java system on the same Java server in the same Java Virtual Machine (VM). In this case, a DMI (Direct Method Invocation) channel may be used. When a method queue is flushed from the calling application to the called application, the dispatcher of the VM will be notified. The dispatcher suspends the active thread\/context of the calling application, activates a second worker thread and context for the called application, and lets the worker thread run. In the called application, the method queue is executed via DMI. Thus, there is a very fast application-to-application communication if the two applications are running in the same VM. Yet, application isolation and efficient resource monitoring are still provided.","In a run-time environment, events are an appropriate medium for communication between a producer and a consumer of a notification, when the consumer of the notification is unknown for the producer. The event handling can be realized with an event dispatcher, which is responsible for the subscribing and dispatching of events.","In an active context , a listener can be subscribed to listen for a specified event. When the event dispatcher  raises the specified event, a callback method of the subscribed listener is called.","Server framework  is the programming interface for hosting processes and resource providers. It provides methods for generating and destroying application contexts , which can be activated and deactivated by the hosting process. Server framework  includes a resource manager  that is responsible for resource management. Resource manager  can be the central instance for resource management. As such, it may ensure fail-fast behavior for controlled fault recovery. Furthermore, it may be able to clean up and recover from application failures without the help of the failing application and ensure that the fault recovery is consistent between back end and front end.","In performing its operations, resource manager  may define and control transactional boundaries. A request-response cycle, for example, defines a transactional boundary. Resource manager  may ensure that no critical system resource are allocated to an application context  while waiting for external input.","As mentioned previously, the context of a single application needs to be defined, provided, controlled, and isolated from the context of other running applications. The session environment of an application may be available everywhere within the application code from the context monitor .","Resources are provided by resource providers, which can be integrated and published during runtime. Thus, the system may be upgraded and updated while running, which avoids shutting down of the system. A resource provider can run in the context of the context monitor . Context monitor  may manage the startup and shutdown of resource providers and monitor the current state of the system and back end resources. Operating system resources like connections, transactions, and files may also need to be provided and controlled.","Different resources could have different lifetimes scopes in an application. When the context monitor  manages a resource, it understands the lifetime of the resource to be able to decide when the resource goes out of scope and disposes of the resource. From an abstract point of view, although special, lifetimes are also a kind of resource. Thus, it is possible to define a resource provider for a session lifetime resource or for a request lifetime resource. In special system environments like a J2EE server, the lifetime resources may be extended dynamically (i.e., a transaction lifetime resource can be loaded via plug in). Typically, the root node of a resource branch within an application context  should be a lifetime resource.","Resources may use other resources, which may be of any other type. Resources, therefore, can be attached to the lifetime scope of other resources, which results in a hierarchical resource dependency. Context monitor  can be aware of this hierarchical dependency and form resource relationships  for each context.","In many situations, an application knows exactly how long the required resource is needed, and the application can dispose the resource by itself. But in critical failure situations, the context monitor  is able to handle the resources due to the fact that it has knowledge about the resource relations of an application context. Thus, it can initiate a cleanup of the resources.","In particular implementations, the resources of resource relationships  are organized as a tree. In general, the root node of a resource tree can be a lifetime resource like session-lifetime or request-lifetime. The resource trees for the relationships  are assigned to an application context . When a resource is removed, the context monitor  notifies all child resources. Due to the fact that all the resources are assigned to an application context, the context monitor  sweeps the resources when an application context  is removed by the hosting application. Typically, the hosting process will provide the lifetime resources.","Resources are provided to an application context  on a lease basis during the performance of a request-response cycle. Lifetime scopes are also resources provided by specialized resource providers, depending on the hosting process.","In practicality, there is little difference between system resources and backend resources. Thus, they can be managed and provided in the same way. The back end resources, however, may be managed resources in a distributed environment, which are described as back end resources. Front end to back end lifecycles may be synchronized.","Resource usage can be monitored from a central console. The context monitor  can provide an agent that publishes the resource usage.","Context monitor  may similarly monitor and\/or manage services, which may be provided by service providers. The resources may be available through the services.","Context monitor  has a variety of features. For example, the context monitor  provides a server application the illusion of a single threaded and fully isolated environment. As another example, the context monitor  can monitor the access to resources and be responsible for the cleanup of these resources after they go out of scope.",{"@attributes":{"id":"p-0081","num":"0080"},"figref":["FIG. 5","FIG. 4"],"b":["500","500","15"]},"Process  begins with determining whether a synchronization point has occurred (operation ). A synchronization point can result, for example, when the status of an application context is to be affected. If a synchronization point has occurred, process  calls for determining whether an application context is to be activated (operation ). An application context may need to be activated, for example, when a worker thread is assigned to a request. If an application context is to be activated, process  calls for activating the application context (operation ). A resource tree can be associated with the application context.","If, however, no application context is to be activated, or if an application context has been activated, process  calls for determining whether an application context is to be deactivated (operation ). An application context may need to be deactivated, for example, if a worker thread is to be put back in the thread pool. If an application context is to be deactivated, process  calls for deactivating the application context (operation ).","Process  continues with returning to determine whether another synchronization point has occurred (operation ). Synchronization points may occur regularly, periodically, irregularly, or otherwise.","If a synchronization point has not occurred, process  calls for determining whether a resource request has been received (operation ). A resource request can specify a particular operation to be performed for an application (e.g., data retrieval). If a resource request has been received, process  continues with determining whether the associated application context process is active (operation ). If the associated application context is not active, process  calls for generating an exception (operation ). If, however, the associated application context is active, process  calls for determining the lifetime scope of the resource (operation ) and assigning the resource to a resource tree (operation ). The resource may or may not be related to other resources of the application context. If related, the resource can be a parent and\/or child to other resources.","After generating an exception or assigning the resource to a resource tree, or if a resource request has not been received, process  calls for determining whether a resource is out of scope (operation ). If a resource is out of scope, process  calls for releasing the resource and the child resources (operation ). The child resources can be determined from the resource tree.","After releasing the resources, or if a resource is not out of scope, process  calls for determining whether an application failure has occurred (operation ). If an application failure has occurred, process  continues with determining resources for the associated application context (operation ). The resources for the associated context can be determined by examining the resource tree associated with the application context. Process  also calls for releasing the resources for the application (operation ).","After releasing the resources, or if an application failure has not occurred, process  calls for returning to check for a synchronization point (operation ), a resource request (operation ), an out of scope resource (operation ), or an application failure (operation ).","Although  illustrates process  for application management, other processes for application management may include fewer, additional, and\/or a different arrangement of operations. For example, checking synchronization points, resource requests, out of scope resources, and application failures can occur in any order. As another example, a process may include generating a resource tree when an application context is generated. As a further example, a process may not include determining whether a synchronization point has occurred, a resource request has been received, an out of scope resource has occurred, or an application failure has occurred.","Although context monitor  has been discussed in relation to managing business applications, it can also be used in a variety of other environments. For example, the resources do not have to be business resource. The objects can be for any other type of organization or procedure. As another example, an architecture does not have to include meta data repository  or a canonical interface. In general, therefore, the context monitor  can be used in systems that have a multi-threaded and\/or clustered environment.","Returning to , data in the meta data is classified into data types or classes. The names of meta model classes representing data types in repository  have the suffix \u201cdescriptor\u201d to express their belonging to the meta model and to differentiate them from runtime classes used by service manager . Descriptors of classes of the meta data of the repository  and their class relations are illustrated using an Unified Modeling Language (UML) class diagram  in .","Comparing the meta data to data described by relational database terminology, an aspect in the repository  can represent a class or an entity type fully or partially stored in back end database  and an aspect descriptor  includes attributes for the entity type in addition to other information about the entity type. The meta data in the repository  also can include relations descriptors  defining relations between aspects that can be implemented in database  as relationships using foreign keys in relational databases. The meta data also can include service modules descriptors  representing service modules that are aggregations of aspects and have predefined queries for accessing data in database .","The service modules defined in repository  are the building blocks for a set of applications (e.g., front end application program ) in business software architecture  for a particular application area or industry. The service modules encapsulate the implementation and business logic and provide access to data and functionality in a unified canonical way. Examples for service modules in repository  are \u201cbusiness partner\u201d, \u201cemployee\u201d, \u201csales order\u201d or \u201cbusiness activity\u201d. Service modules descriptors  describe services modules in the data model of the meta data of the repository  and how the service modules can be accessed by queries from application program .","In repository , each defined query is an entry point to search instances of a data type (represented by an aspect) provided by service providers  via service manager . A \u201ckey\u201d is an identifier of an instance of a data type provided by service providers . An \u201caction\u201d is a specialized method on one or more instances of an aspect. A \u201cstructure\u201d is the aggregation of attributes representing the data of an aspect. A \u201crelation\u201d is the relation between objects of a source and a target aspect. A service module group is associated with a service module and is an aggregation of aspects, relations, and queries. An aspect group is associated with an aspect and is an aggregation of relations, aspect actions, and field descriptors . The meta data in the repository  also includes a text description of each aspect, query, key, action, structure, relation, service module group, and aspect group. The framework of the meta data in the repository  can be described in terms of data types aspect, query, key, action, structure, relation, service module group, and aspect group.","The data model for attributes of aspects, queries, keys, and actions is based on structure descriptors . In one example, every aspect has one structure descriptor  that defines the data attributes of the aspect. Structure descriptors  refer to a data dictionary in repository . A data dictionary is a collection of descriptions of the data objects or items in a data model for the benefit of programmers and others who need to refer to them. The structure descriptors  can be defined in an XML Schema or in one or more database tables in repository .","In one example, structure descriptors  defined in repository  include flat structures in database tables. A flat structure is a sequence of pairs of attribute names and field descriptors  of simple value types such as real, integer, character string, and Boolean. For instance, a structure descriptor  defining a two dimensional point can be a list {X, real, Y, real}, where X and Y are attribute names having real values.","In another example of the repository , structure descriptors  can include nesting and collections of other structure descriptors . Nesting of other structure descriptors , or sub structures, to enable the generation of larger aspects is useful whenever the use of keys for sub structures defining smaller aspects does not make sense.","For front end application program  to access data (possibly stored in back end database ) from service providers  through the service manager , instances of business object classes are identified by unique keys within a service module, for example the number of an order or the identification (ID) of a product. To differentiate between different types of keys for different aspects in a service module, key descriptors define different types of keys. A key descriptor  is associated with a structure descriptor  that can include more than one data attribute. In one example, every key has a character string attribute. A service module can be associated with different key descriptors  for different aspects (e.g., an order key can have another key descriptor  as an order item key).","Service module descriptor  includes a collection of aspect descriptors. An aspect descriptor refers to exactly one structure descriptor  and one key descriptor . The structure descriptor  includes all key attributes of the corresponding key descriptor . Key descriptors  are specialized aspect descriptors . The key descriptor  attribute of a key refers to itself as a self-reference. Examples for aspect descriptors  within a simple sales order service module can include: Order, Order Detail, Shipping Address, Billing Address, and Order Item, as well as descriptors for key aspects like Order ID and Order Item Key. Service module descriptor  specifies the collection of supported aspect descriptors . Multiple service module descriptors  can be associated with the same aspect descriptor .","Aspect descriptors  relate to each other specified by relation descriptors . A relation descriptor  has one source aspect descriptor  and one target aspect descriptor . In this sense, relation descriptors  are directed. Relation descriptors  also have an optional cardinality (e.g., 1 . . . n) and a category. Supported categories are Parent-Child or Child-Parent.","A relation descriptor  defining a relation between source aspect A and target aspect B means that it is possible to traverse from instances of aspect A to instances of aspect B. For example, given that aspects A and B are implemented in back end database  as relational database tables, this means that one or more fields in a table corresponding to aspect A point to the primary key of a table corresponding to aspect B.","The relation descriptor  defining a Parent-Child relation from source aspect A and target aspect B means that aspect B depends on the existence of aspect A. For example, given that aspects A and B are implemented in back end database  as relational database tables, this means that a primary key of a table corresponding to aspect B is derived from a table corresponding to aspect A.","Relation descriptors  are introduced to describe internal navigation from one aspect to another within the same service module (e.g., from an order to the shipping address (cardinality 1 . . . 1) or to the order items (cardinality 1 . . . n) within a sales order service module).","Relation descriptors  are independent of service modules and can be reused by different service modules. For an internal navigation or traversal from one data type to another in back end database , the visible (usable) relation descriptors of a source aspect descriptor  are defined by the service module descriptor , which has a list of supported relation descriptors . Only those relation descriptors  are allowed that have a target aspect descriptor  that is also supported by the service module descriptor .","Operations for accessing and acting on data types in back end database  are described in operation descriptors . The structure descriptor  defines input parameters of the operation descriptor . This structure descriptor  also includes an input key descriptor  that enables mass and filter operations. Mass operations are operations specified by front end application program  on multiple instances of a data type in back end database . Filter operations filter the results of an operations (e.g., a query) by the keys defined by the input key descriptor. Input parameters for operation descriptors  are optional.","There are three types of operation descriptors  (i.e., query descriptors , aspect action descriptors , and action descriptors ). The aforementioned commands Query and Execute action are defined by operation descriptors .","Query descriptors  describe query methods that allow searching for instances of aspects within a service module. The query descriptor  includes an input parameter, an input key descriptor , and a result aspect descriptor . The input parameter is a structure descriptor  that defines the search parameter structure of the query. The input key descriptor  defines which keys may be used for filtering. For example, executing a query defined by a query descriptor  with filtering keys results in a list of keys meeting the criteria of the first input. This list of keys is filtered by the set of filtering keys of the input key descriptor  so that a subset of the list of keys can be returned. The result aspect descriptor  for the query descriptor  specifies the type of result of the query, which could be any aspect descriptor  that is associated with the service module.","Each service module descriptor  has a set of supported query descriptors . Service module descriptors  cannot use query descriptors  defined in other service module descriptors  since the query descriptor  belongs to one service module descriptor .","Aspects provide additional operations (beyond the standard operations select, insert, update, delete, select by relation, and update fields) in the form of actions, which are described by aspect action descriptors . Aspect action descriptors  are specialized operation descriptors  on aspects. The aspect descriptor  can have a set of supported aspect action descriptors . The input parameter for an aspect descriptor  defines the parameter structure of the action. The input key descriptor  specifies which keys may be used for mass operations (e.g., an email action may have as input a list of keys representing multiple emails).","Action descriptors  can define actions for multiple actions like Print, Email, Fax, Approve, Clear, Cut, Copy, Paste and Cancel. But there may be also more aspect specific actions that can be only used for one or a few aspects. Action descriptors  are introduced to enforce reuse. Each aspect action descriptor  is associated with an action descriptor , where the name and the meaning (textual description) are defined.","Action descriptors  specify a name and the meaning (textual description) of the action. They do not specify parameters and are not used to describe polymorphic behavior of operations. They can be used for taxonomies.","A service module group descriptor  can be associated with aspect descriptors , relation descriptors , and query descriptors . An aspect group descriptor  can be associated with relation descriptors , aspect action descriptors , and field descriptors .","Using object-oriented terminology, diagram  includes a zero or more to zero or more relationship  between service module descriptor  and aspect descriptor  since aspects can be grouped together in a service module. Service module group descriptor  has a zero or more to zero or more directed relation  towards aspect descriptor  since aspects can be grouped together in a service module group. Service module group descriptor  also has a zero or more to one composite aggregation relationship  with service module descriptor  because service modules can be grouped together in a service module group. Key descriptor , as a specialization of aspect descriptor , has an inheritance relationship  with aspect descriptor . Key descriptor  also has a one to zero or more relationship  with aspect descriptor  since each aspect has a key associated with it to uniquely identify instances of the aspect. Operation descriptor  has a directed zero or more to zero or more relationship  with key descriptor  since operations can include input keys. Aspect descriptor  has a zero or more to one relationship  with structure descriptor  since each aspect descriptor  can have a structure descriptor defining its attributes. Aspect group descriptor  has a zero or more to one composite aggregation relationship  with aspect descriptor  since aspect groups are aggregations of aspects. Aspect group descriptor  also has a directed zero or more to zero or more relationship  with relation descriptor  since aspect groups also include relations. Structure descriptor  has a one to zero or more ownership relationship  with field descriptor  since a structure can use many data fields to define itself. Aspect group descriptor  also has a zero or more to zero or more ownership relationship  with field descriptor .","Aspect action descriptor  has a zero or more to one relationship  with aspect descriptor  since aspects can provide actions that can be executed on the aspect. Aspect action descriptor  has an inheritance relationship  with its superior class operation descriptor . Query descriptor  also has an inheritance relationship  with its superior class operation descriptor . Service module descriptor  has a one to zero or more relationship  with query descriptor  since a service module includes queries. Service module group descriptor  has a zero or more to zero or more directed relationship  with query descriptor  since queries can also be grouped together in a service module group.","Operation descriptor  has a zero or more to zero or one relationship  with structure descriptor  since each operation includes input parameters in the form of structures. Query descriptor  has a zero or more to zero or one relationship  with aspect descriptor  since queries include a resulting aspect. Lastly, relation descriptor  has zero or more to one relationships  and  with aspect descriptor  since relations have source and target aspects.","To illustrate these descriptors defining a framework of the meta data in repository , the framework can be implemented using a fixed set of relational database tables. Other persistence mechanisms (e.g., XML) can also be used. The relational database tables are defined in Tables 1-6 where each row of Tables 1-6 defines a field or column of the relational database tables. The main data type of repository  is the aspect. The database tables for describing an aspect are Table 1, SCOL_ASPECT, and Table 2, SCOL_ASP_ACTION.","Table 1 includes descriptions of properties of an aspect. The key field for Table 1, SCOL_ASPECT, is the ASPECT_NAME field because an aspect's name is unique for an aspect. The ASPECT_CATEGORY field indicates if the aspect represents a non-key aspect or a key aspect. The STRUCTURE field indicates a data structure name for data attributes of the aspect. A key is associated with an aspect by putting the key's name in the KEY_ASPECT field. The SERVICE_PROVIDER field defines the aspect service provider  for an aspect. The TRANSAC_PROVIDER field defines the transaction service provider  for an aspect. The LOCKING_PROVIDER field defines the locking service provider  for an aspect. The repository  can also have a corresponding table for the description of an aspect.",{"@attributes":{"id":"p-0118","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SCOL_ASPECT definition"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field Name","Key","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["ASPECT_NAME","X","Name of the aspect"]},{"entry":["ASPECT_CATEGORY",{},"Aspect type: aspect or key aspect"]},{"entry":["STRUCTURE",{},"The corresponding data structure of"]},{"entry":[{},{},"the aspect"]},{"entry":["KEY_ASPECT",{},"The corresponding key aspect"]},{"entry":["SERVICE_PROVIDER",{},"The name of the corresponding"]},{"entry":[{},{},"aspect service provider class"]},{"entry":["TRANSAC_PROVIDER",{},"The name of the corresponding"]},{"entry":[{},{},"transaction provider class"]},{"entry":["LOCKING_PROVIDER",{},"The name of the corresponding"]},{"entry":[{},{},"locking provider class"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Aspects can provide actions that can be executed on the aspect. Descriptions of the actions are stored in Table 2, SCOL_ASP_ACTION. The actions are uniquely denoted by the aspect name and the name of the action so ASPECT_NAME and ACTION_NAME fields are key fields for SCOL_ASP_ACTION table. The field PARAM_STRUCTURE refers to a data structure that holds input data parameters for the action. The field INPUT_KEY_ASPECT refers to the name of a key aspect that defines the type of keys used to designate which instances of data types in repository  are acted upon by the action. The field PROVIDER_CLASS refers to the name of the action service provider class providing the action from the service provider implementing the aspect named in ASPECT_NAME field.",{"@attributes":{"id":"p-0120","num":"0119"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SCOL_ASP_ACTION definition"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field Name","Key","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["ASPECT_NAME","X","Name of the aspect"]},{"entry":["ACTION_NAME","X","Name of the Action"]},{"entry":["PARAM_STRUCTURE",{},"The corresponding data structure"]},{"entry":[{},{},"of the input parameters"]},{"entry":["INPUT_KEY_ASPECT",{},"The name of the key aspect of the"]},{"entry":[{},{},"input aspects"]},{"entry":["PROVIDER_CLASS",{},"The name of the action service"]},{"entry":[{},{},"provider class"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Aspects can be related with each other. Descriptions of the relations between aspects are stored in Table 3, SCOL_RELATION. A relation is uniquely defined by its name so the key of a relation table is the relation name specified in field RELATION_NAME. For each relation, the field SOURCE_ASPECT defines the aspect that is the source of the directed relation, the field TARGET_ASPECT defines the aspect that is the target of the directed relation, the field TARGET_PROVIDER defines the query relation service provider for the target aspect, the field REL_PARAM_TYPE defines the type of the relation (Parent-Child or Child-Parent), and the field REL_PARAMETER defines the cardinality of the relation. The repository  can also have a corresponding table for the description of a relation.",{"@attributes":{"id":"p-0122","num":"0121"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SCOL_RELATION definition"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field Name","Key","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["RELATION_NAME","X","Name of the relation"]},{"entry":["SOURCE_ASPECT",{},"Name of the source aspect of the"]},{"entry":[{},{},"relation"]},{"entry":["TARGET_ASPECT",{},"Name of the target aspect of the"]},{"entry":[{},{},"relation"]},{"entry":["TARGET_PROVIDER",{},"Name of the query relation service"]},{"entry":[{},{},"provider class"]},{"entry":["REL_PARAM_TYPE",{},"Type of the relation"]},{"entry":["REL_PARAMETER",{},"Parameter of the relation"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"The properties of a service module are stored in the Table 4, SCOL_SVC_MODULE. Each Service module is uniquely described by its name so SVC_MODULE_NAME field is the key field for a SCOL_SVC_MODULE table. For each service module, the field TRANSAC_PROVIDER specifies the name of the transaction provider  for the service module. The repository also has a corresponding table for the description of a service module.",{"@attributes":{"id":"p-0124","num":"0123"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SCOL_SVC_MODULE definition"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field Name","Key","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["SVC_MODULE_NAME","X","Name of the service module"]},{"entry":["TRANSAC_PROVIDER",{},"The name of the corresponding"]},{"entry":[{},{},"transaction service provider class"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Every service module is associated with aspects that can be used within the service module. Names of the aspects that can be used within each service module are stored in the Table 5, SCOL_ASPECT_USE. Since each aspect-service module usage is uniquely described by a name of a service module and the name of an aspect, the fields SVC_MODULE_NAME and ASPECT_NAME are the keys for SCOL_ASPECT_USE table.",{"@attributes":{"id":"p-0126","num":"0125"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 5"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SCOL_ASPECT_USE definition"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Field Name","Key","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"SVC_MODULE_NAME","X","Name of the service module"]},{"entry":[{},"ASPECT_NAME","X","Name of the aspect"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"Service Modules can provide queries to retrieve data. Descriptions of the queries of a service module are stored in the table SCOL_QUERY illustrated in Table 6 below. The structure of the database table is defined in Table 6. Since each query is uniquely defined by a service module and a query name, the fields SVC_MODULE_NAME and QUERY_NAME are key fields for SCOL_QUERY table. Other fields include RESULT_ASPECT that specifies the name of an aspect defining the data type returned by the query and PARAM_STRUCTURE that specifies a data structure containing the input parameters for the query. For example, a query done on a particular aspect (e.g., specified in field RESULT_ASPECT) associated with the service module can include input parameters that are matched with attributes of instances of the particular aspect and the matching instances are returned as a dataset of keys referring to those instances. The field INPUT_KEY_ASPECT is used to define the key aspect describing keys that could be used as filters for the query. The PROVIDER_CLASS specifies the name of the query service provider  associated with each query. The repository also has a corresponding table for the description of a query.",{"@attributes":{"id":"p-0128","num":"0127"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 6"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SCOL_QUERY definition"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field Name","Key","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["SVC_MODULE_NAME","X","Name of the service module"]},{"entry":["QUERY_NAME","X","Name of the query"]},{"entry":["RESULT_ASPECT",{},"Name of the result aspect of the"]},{"entry":[{},{},"query"]},{"entry":["PARAM_STRUCTURE",{},"The corresponding data structure of"]},{"entry":[{},{},"the input parameters"]},{"entry":["INPUT_KEY_ASPECT",{},"The name of the key aspect of the"]},{"entry":[{},{},"input aspects"]},{"entry":["PROVIDER_CLASS",{},"The name of the corresponding query"]},{"entry":[{},{},"provider class"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"As stated previously, architecture  includes six service provider classes (i.e., transaction, query, aspect, action, query relation, and locking) for handling requests from front end application program  other than requesting meta data from repository  (handled by repository service provider class). To provide services upon request by front end application program , service manager  directly calls instances of service provider classes. These instances of service provider classes can be located on the same computer (e.g., ) as service manager  or on a different computer.","The locking service provider  can be used to implement a generic lock manager for a single aspect or a set of aspects. Each locking service provider  needs to be registered with an aspect. The name of the locking service provider  is set in SCOL_ASPECT table in LOCKING_PROVIDER field for each aspect. Locking service provider class has two methods that can be called by service manager . These are LOCK and UNLOCK. LOCK takes as input a collection of keys representing business objects to be locked, a name of an aspect representing a class of the business objects, and a lock mode. There are various locking modes depending on the locking capability of the target system. Locking mode can specify \u201cE\u201d, \u201cS\u201d, or \u201cSP\u201d. \u201cE\u201d means an exclusive lock or that only one client can obtain the lock. \u201cS\u201d means a shared lock indicating that any clients can lock and no lock exclusive to one client is possible. \u201cSP\u201d means the same as \u201cS\u201d but a subsequent upgrade to an exclusive lock is possible.","LOCK method outputs a Boolean value indicating if the request is rejected or not and also outputs a return code. UNLOCK takes as input a collection of keys representing business objects to be unlocked and a name of an aspect representing a class of the business objects to be unlocked. UNLOCK method also outputs a Boolean value indicating if the request is rejected or not and a return code. A call to UNLOCK is rejected if a transactional buffer is already in a \u201cdirty\u201d state (i.e., if any update, insert, delete operation or an action that is not marked as COL_AFFECTS_NOTHING has been issued since the last CLEANUP call). All locks are removed if the CLEANUP method (described below) of the transaction service provider class is called with reason \u2018END\u2019.","A transaction is a sequence of information exchange and related work (such as database updating) that is treated as a unit for the purposes of satisfying a request from front end application program  to service manager  and for ensuring integrity of back end database . For a transaction to be completed and changes to database  to be made permanent, a transaction has to be completed in its entirety. All of the steps of a transaction are completed before the transaction is successful and the database is actually changed to reflect the new order. If something happens before the transaction is successfully completed, any changes to the back end database  must be kept track of so that the changes can be undone.","To handle transactions, the transaction service provider  receives notifications on the various states of a transaction between service manager , another non-transaction service provider (e.g., , , , ), and front end application program  (or service manager proxy  in some cases). These notifications are the transaction service provider 's methods BEFORE_SAVE, CLEANUP, and SAVE that are called by the service manager  during transactions.","The service manager  calls the transaction service provider 's method BEFORE_SAVE to check if the transactional buffer can be saved. The method BEFORE_SAVE returns false if it is not possible to save the transactional buffer, then the transaction end is aborted. Thus, the BEFORE_SAVE method has a BOOLEAN return parameter REJECTED. This allows checking if the internal state of the non-transaction service provider is ready for being saved. BEFORE_SAVE takes a Boolean as an input parameter. The transactional service provider  can prevent the following save and commit operations by setting the REJECTED parameter to a non-initial value (i.e., to \u201ctrue\u201d). The method BEFORE_SAVE is called within the service manager 's sequence of operations triggered by the front-end application 's SAVE method.","The SAVE method finally triggers the application to save the transactional buffer to the database . By calling SAVE, all internal state of the non-transaction service provider is made persistent\u2014either by direct updates or by creating appropriate calls to the update task. If all service providers in architecture  have received a SAVE request, service manager  commits the transaction.","The CLEANUP method tells all non-transaction service providers to release all their transactional buffers and enqueue-based locks. Calling CLEANUP method communicates that all service providers in architecture  need to clean up their internal state. CLEANUP takes a REASON string as an input parameter. The REASON field indicates the reason for the clean up operation. This can be either a \u2018COMMIT\u2019 due to a SAVE-operation or the \u2018END\u2019 of the transaction due to the system closing the transaction automatically. There is no guarantee that cleanup is called under failure conditions.","The action service provider  is called by service manager  to execute an action for an aspect. The name of action service provider  is set in the PROVIDER_CLASS field of SCOL_ASP_ACTION table for a row corresponding to an action. Action service provider  has one method EXECUTE. EXECUTE method takes as input parameters an aspect name (ASPECT), a set of keys (INKEYS) specifying which instances of the aspect are acted upon by the action, a generic input parameter (INPARAM), the name of the action (ACTION) to be executed, a set of keys (RELATION_INKEY) for an action acting on an relation, and a name of the relation (RELATION). EXECUTE method returns as output parameters the changed or newly generated objects (OUTRECORDS), which have been modified by the action. The objects returned by the OUTRECORDS parameter are transported back to the calling aspect object on the client framework.","The aspect service provider  is called by service manager  to provide functionality to read and modify the content of one or more aspects. As described previously, an aspect is described by its name (the name is globally unique within a repository), an associated data structure, an associated key (i.e., identifier) structure, a set of implemented actions, a set of outgoing relations, and a set of incoming relations. Aspect service provider  has methods EXECUTE, SELECT, INSERT, UPDATE, DELETE, SELECT_BY_RELATION, and UPDATE_FIELDS.","The method EXECUTE is derived from the action service provider  and allows executing an action. EXECUTE has as input parameters a name (ASPECT) of the aspect, where the action is to be executed on, keys (INKEYS) of the objects, where the action is executed on, parameters (INPARAM) for the actions, name (ACTION) of the action. Returned parameters include modified or generated aspect rows (OUTRECORDS), a Boolean flag (REJECTED) indicating if the request for the method was rejected or not, and return codes (RETURN_CODES).","The method SELECT reads the aspect data associated with the input keys for a given aspect. SELECT has as input parameters a list of keys (INKEYS) encoded within the associated key structure to describe the aspect rows to read and the name (ASPECT) of the aspect. SELECT has as output parameters the result (OUTRECORDS) encoded in the aspect data structure, a Boolean flag (REJECTED) indicating if the request for the method was rejected or not, and return codes (RETURN_CODES).","The method INSERT inserts new data into an aspect. INSERT includes as input parameters a table containing the records to be inserted, if aspect is designed for row wise write operations (INRECORDS). Depending on the aspect description (ExternalKeys=true\/false) for the object the keys of the record can be filled or not. Input parameters also include the name (ASPECT) of the aspect, a set of keys (RELATION_INKEY) for an action acting on a relation, and a name of the relation (RELATION). Method INSERT returns a set of records (OUTRECORDS) representing the inserted records together with their keys and possible other modifications that aspect service provider  wants to do on the inserted records. For example one modification can be filling out calculated fields for the set of records. The order of the OUTRECORDS rows has to correspond to the order of the INRECORDS rows. Other output parameters include a Boolean flag (REJECTED) indicating if the request for the SELECT method was rejected or not and return codes (RETURN_CODES).","The UPDATE method updates existing instances of an aspect either record wise or field wise. The input parameters for UPDATE method include a table (INRECORDS) containing the instance keys to be updated, if the aspect is designed for row wise write operations. Input parameters also include the name (ASPECT) of the aspect. Parameters returned by the UPDATE method include the updated records (OUTRECORDS) together with their keys and possible other modifications the service provider wants to do. The order of the OUTRECORDS rows has to correspond to the order of the INRECORDS rows. Other output parameters include a Boolean flag (REJECTED) indicating if the request for the SELECT method was rejected or not and return codes (RETURN_CODES).","The DELETE method deletes rows or instances of an aspect in the back end. Input parameters for DELETE method are a list of keys (INKEYS) encoded within the associated key structure to describe the aspect rows to be deleted and the name (ASPECT) of the aspect. Parameters returned by the DELETE method include a Boolean flag (REJECTED) indicating if the request for the SELECT method was rejected or not and return codes (RETURN_CODES).","The SELECT_BY_RELATION method returns, depending on the relation parameter description, either attributes to follow a relation or already another aspect where the source aspect has a relation pointing to the other aspect. Input parameters for SELECT_BY_RELATION are name (RELATION) of the relation to follow, records (INRECORDS) of the source aspect, name of the source aspect (ASPECT), and a structure (OPTIONS) describing various options of the queries for paging etc. Output parameters returned by SELECT_BY_RELATION include the result encoded in the target aspect data structure (OUTRECORDS), an index table showing which row of the OUTRECORDS parameters belongs to which INRECORDS row (INDEX), a description of the result (DESCRIPTION), a Boolean flag (REJECTED) indicating if the request for the SELECT method was rejected or not and return codes (RETURN_CODES).","The UPDATE_FIELDS method updates fields of instances of an aspect. Input parameters include a list of keys (INRECORDS) encoded within the associated key structure to describe the instances of the aspect to be updated. Input parameters also include a table (INFIELDS) containing pairs of names of fields and corresponding values to be updated within a set of records, if the aspect is designed for field wise write operations. If more than one instance of an aspect is to be updated, the additional field index INKEY points to the associated key record. Input parameters also include the name (ASPECT) of the aspect. Parameters returned by UPDATE_FIELDS include the generated or changed instances of the aspect (OUTRECORDS) together with their keys and possible other modifications the aspect service provider  did. The index of the various OUTRECORDS rows have to be associated to the row indexes in the INFIELDS table. Other parameters returned include a Boolean flag (REJECTED) indicating if the request for the SELECT method was rejected or not and return codes (RETURN_CODES).","Query service provider  performs queries. A query in the repository  is described in table SCOL_QUERY by the query name in field QUERY_NAME, the associated parameter structure in field PARAM_STRUCTURE, the associated result aspect in field RESULT_ASPECT, and optionally, the associated aspect key, with its unique data structure in field INPUT_KEY_ASPECT. Query service provider  has one EXECUTE method that performs a query on one or more aspects. Input parameters include the name of the query (QUERY), a data structure (INPARAM) containing the parameters for the query, and an optional table-type parameter (INKEYS), containing the keys of the aspect rows to which the query shall be restricted. INKEYS can but does not have to consist of the keys of OUTRECORDS returned by EXECUTE method. INKEYS can be of any key aspect structure. Which key structure is associated to the query is specified in the repository  in table SCOL_QUERY in field INPUT_KEY_ASPECT. Optionally, other input parameters can be specified including a structure describing various options (OPTIONS) of the queries (e.g., for paging) and SELECTIONS.","Parameters returned by EXECUTE method include a description (DESCRIPTION) of the query, the query result (OUTRECORDS), and a Boolean flag (REJECTED) indicating if the request for the SELECT method was rejected or not","The EXECUTE method returns the results specified by the query parameters. If the INKEYS table parameter is not empty, the result is restricted to the objects that fulfill the query parameters. INKEYS and INPARAM both restrict the query, but are used in different ways. For example, you could generate a query that returns a list of orders not yet delivered. The structure INPARAM specifies that only orders from customers with last names from A-D are to be returned. The INKEYS is a table of all orders that have not yet been delivered. OUTRECORDS contains all orders from the relevant customers that have not been delivered yet. The OUTRECORDS result of a query is a disconnected aspect, that is, the aspect is always read-only. No further back end operations can be performed on this aspect. Only the received keys can be used as parameters to select other aspect rows using the aspect service provider .","The query relation service provider  implements a routine in a service provider (e.g., aspect service provider ) for an aspect that is the target of a relation. Methods of query relation service provider  are indirectly called from the aspect service provider of the source aspect, if the relation is marked as SOURCE_KEYS or ATTRIBUTES.","Query relation service provider  has SELECT_TARGET method. The method SELECT_TARGET has input parameters as follows. Input parameters include the name (SOURCE_ASPECT) of the source aspect. Optionally, the method also includes an input parameter defining a proxy interface (TARGET) to the target aspect's SELECT method. Specifying the TARGET parameter allows calling the SELECT method of the aspect service provider for the target aspect without directly knowing the aspect service provider. This enables a query relation service provider to be added to a service module without knowledge of the aspect service provider for the target aspect.","Another input parameter is the relation (RELATION). Another input parameter is a table of fields (INPARAMS) to describe the relation. To allow mass selection INPARAMS is a table where every row describes a single selection. An INDEX parameter is used to relate the various rows of the INPARAMS structure to the OUTRECORDS rows. Another optional input parameter is a structure (OPTIONS) describing various options of the queries (e.g., for paging).","SELECT_TARGET method returns parameters that include the result encoded with the structure of the target aspect (OUTRECORDS), a description of the query result (DESCRIPTION), and a proxy interface to the target aspects SELECT method. Other output parameters include an index (INDEX) to describe the relation between the INPARAMS records and the OUTRECORDS parameter, a Boolean flag (REJECTED) indicating if the request for the SELECT method was rejected or not and return codes (RETURN_CODES).","The service providers , , , , , and , as described above, enable the following transactional model for the architecture . Executing method SELECT of aspect service provider  reads from the back end database  or reads from a transactional buffer build up in the back-end. Aspect service provider  merges data from both sources\u2014the database and its transactional buffer\u2014in a consistent way reflecting the updates made so far in this transaction correctly. Next, executing UPDATE, INSERT, MODIFY, or DELETE methods of aspect service provider  builds up a transactional buffer. Before actually changing data in the transactional buffer, the service manager  has to acquire a transactional lock on the data and read the data under the protection of a lock. There are exclusive, shared, and shared promotable lock modes available using locking service provider  as described previously. Locking has to be accompanied by selecting the locked data again under the protection of the lock. Applications can support optimistic locking by providing time-stamped or otherwise versioned data and merging actual and modified data on the front-end on conflicts.","The BEFORE_SAVE method of the transaction service provider  enables all participating service providers to declare if they are ready for saving the transactional buffer. The SAVE method of the transaction service provider  finally triggers service manager  to save the transactional buffer to the back end database .","The CLEANUP method of the transaction service provider  tells all service providers (e.g., aspect service provider ) to release all their transactional buffers and enqueue-based locks. If CLEANUP is called with reason \u2018END\u2019, all locks have to be released. If reason is set to \u2018COMMIT\u2019, each service provider can chose to keep its locks. Aspect service provider  must not call COMMIT WORK or ROLLBACK WORK internally on its own. The service manager  enforces this by automatically aborting the transaction if aspect service provider  is trying to commit a transaction.","The supported locking models and lock policies are as follows. Using policy S, many participants can obtain a shared lock. If a shared lock is obtained on an object, no exclusive lock or SP lock can be obtained. Shared locks can only be used to achieve a consistent view on a larger set of data during read operations. Using policy E, only a single participant can obtain a lock. Using policy SP (shared promotable), many participants can obtain the lock. If a SP lock exists, exclusive locks can only be obtained by participants already having a SP lock on the object. Only one of the participants can upgrade the lock to an exclusive lock. No other participant, who did obtain a lock prior to the upgrade, can upgrade to exclusive even if the first participant did release its lock.","The architecture  (of ) implements a simple task of creating a new customer, receiving the customer's order of one or more products via GUI  and submitting the order to a business process. To support this example, back end database  can be implemented using a relational database designed according to the definitions in Tables 1-6 above to define lists of customers, addresses, product types, baskets, positions of products in a basket for each order, and orders. In Tables 7-12, key fields headings are denoted with an asterisk. Customers Table 7 defines customers and each customer is uniquely identified by a CustomerId field. Customers Table 7 also includes a NAME field and a foreign key field AddressId that links addresses in an Addresses table to customers.",{"@attributes":{"id":"p-0158","num":"0157"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 7"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Customers"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CustomerId*","NAME","AddressId"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["1","John Smith","1"]},{"entry":["2","David Klein","2"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Addresses Table 8 defines addresses having a town and a street. The Address ID itself is a valid unique key for an address and the connection between address and customer is done through the Customers Table 7 (AddressId field).",{"@attributes":{"id":"p-0160","num":"0159"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 8"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Addresses"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["AddressId*","Town","Street"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["1","Athens","Main Street"]},{"entry":["2","Louisville","Willow Avenue"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Table 9 defines products having names with key ProductId.",{"@attributes":{"id":"p-0162","num":"0161"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 9"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Products"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ProductId*","Name"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["1","Saw"]},{"entry":["2","Hammer"]},{"entry":["3","Wrench"]},{"entry":["4","Screwdriver"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Table 10 defines shopping baskets having customers with key BasketId.",{"@attributes":{"id":"p-0164","num":"0163"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 10"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Baskets"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"BasketId*","CustomerId"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"1","2"]},{"entry":[{},"2","1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Table 11 defines positions of orders in baskets and having products. Positions are dependent on the existence of baskets and orders so the primary key for positions is a combination of PositionId, BasketId, and OrderId.",{"@attributes":{"id":"p-0166","num":"0165"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 11"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Positions"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PositionId*","BasketId*","OrderId*","ProductId"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"1","1","3","2"]},{"entry":[{},"2","1","2","3"]},{"entry":[{},"3","2","1","4"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}}},"Table 12 defines orders having customers and indicating whether or not each order is submitted with primary key OrderId.",{"@attributes":{"id":"p-0168","num":"0167"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 12"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Orders"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"OrderId*","CustomerId","Submitted"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"1","1","False"]},{"entry":[{},"2","2","False"]},{"entry":[{},"3","2","False"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"As shown in , process  defines the database operations on back end database  that are needed for this simple task using these tables 7-12. Process  includes front end application program  receiving () a name of a customer. Process  includes the business software application querying () a database with Customers table (Table 7) for the name in the NAME field. Process  includes checking if the customer's name matches () a row in the Customers table (Table 7). If no match is made, process  includes the business software application obtaining () the address of the customer, inserting () a new row in the Addresses table (Table 8) with a new AddressID and address, and inserting () a new row in the Customers table (Table 7) with a new Customer ID and the AddressID. If a match is made, process  includes the business software obtaining () a name of a product to order for the customer. Process  includes the business software querying () the Products table (Table 9) for the product name.","Process  includes checking if the product name matches () a row in the Products table (Table 9). If a match is made, then process  includes the business software inserting () a new order in the Orders table (Table 12) with the customer's CustomerId and setting the Submitted field to \u201cFalse\u201d. Otherwise, process  returns to obtaining () the name of the product to order. Process  includes the business software inserting () a new basket in the Basket table (Table 10) with the customer's CustomerId.","Process  includes the business software inserting () a new position in the Positions table (Table 11) with the CustomerId, BasketId, and ProductId. Process  includes the business software receiving () a request to submit the order. Process  includes the business software querying () the Orders table (Table 12) by the customer's CustomerId and this query returns orders matching the customer's CustomerId. Process  includes the business software selecting () orders in the Orders table (Table 12) matching the orders for the customer's CustomerId. Process  includes the business software setting () the Submitted field in the selected rows in the Orders table (Table 12) to \u201cTrue\u201d. Process  includes the business software getting () the address of the customer from the Addresses Table 8 for order delivery by querying Customers Table 7 for an AddressId and then querying Addresses Table 8 for a matching AddressId.","Tables 13-19 show tables in one implementation of repository  representing meta data for the example database illustrated by Tables 7-12. Tables 13-19 follow the definitions of Tables 1-6 described above such that definitions in rows of Tables 1-6 correspond to columns or fields in Tables 13-19. As with Tables 7-12, key fields in Tables 13-19 are labeled by an asterisk.","Table 13 follows the definition of a SCOL_ASPECT table (defined in Table 1) to define aspects A_Customer, A_Address, A_Product, A_Basket, A_Position, and A_OrderHeader. Each aspect has a corresponding key aspect that defines a unique key for each instance. For example, aspect A_Customer has a key aspect Customer_Key. This key aspect in the meta data repository  can correspond to a key for a relational database table in back end database . For example, the key for Customers table (Table 7) is CustomerId field. The rows in STRUCTURE field correspond to a data dictionary in Table 19 below. For example, Table 19 can define Customer_Structure to have a NAME field of type CHAR indicating a character string. The rows in SERVICE_PROVIDER field correspond to particular aspect service providers handling services for aspects. In Table 13, all of the aspects are assigned to S_provider aspect service provider (e.g.,  referring to ). The rows in TRANSAC_PROVIDER field correspond to particular transaction service providers  handling transactions for aspects. In Table 13, all of the aspects are assigned to T_provider transaction service provider (e.g.,  referring to ). The rows in LOCKING_PROVIDER field correspond to particular locking service providers handling locking for aspects. In Table 13, all of the aspects are assigned to L_provider locking service provider (e.g.,  referring to ).",{"@attributes":{"id":"p-0174","num":"0173"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"336pt","align":"center"}},"thead":{"row":{"entry":"TABLE 13"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example SCOL_ASPECT table"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ASPECT","ASPECT",{},"KEY","SERVICE","TRANSAC","LOCKING"]},{"entry":["NAME*","CATEGORY","STRUCTURE","ASPECT","PROVIDER","PROVIDER","PROVIDER"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}},{"entry":["A_Customer","aspect","Customer","Customer","S_provider","T_provider","L_provider"]},{"entry":[{},{},"Structure","Key"]},{"entry":["Customer_Key","key aspect","Customer","Customer","S_provider","T_provider","L_provider"]},{"entry":[{},{},"Key_Table","Key"]},{"entry":["A_Address","aspect","Address","Address","S_provider","T_provider","L_provider"]},{"entry":[{},{},"Structure","Key"]},{"entry":["Address_Key","key aspect","Address","Address","S_provider","T_provider","L_provider"]},{"entry":[{},{},"Key_Table","Key"]},{"entry":["A_Product","aspect","Product","Product","S_provider","T_provider","L_provider"]},{"entry":[{},{},"Structure","Key"]},{"entry":["Product_Key","key aspect","Product","Product","S_provider","T_provider","L_provider"]},{"entry":[{},{},"Key_Table","Key"]},{"entry":["A_Basket","aspect","Basket","Basket","S_provider","T_provider","L_provider"]},{"entry":[{},{},"Structure","Key"]},{"entry":["Basket_Key","key aspect","Basket","Basket","S_provider","T_provider","L_provider"]},{"entry":[{},{},"Key_Table","Key"]},{"entry":["A_Position","aspect","Position","Position","S_provider","T_provider","L_provider"]},{"entry":[{},{},"Structure","Key"]},{"entry":["Position_Key","key aspect","Position","Position","S_provider","T_provider","L_provider"]},{"entry":[{},{},"Key_Table","Key"]},{"entry":["A_OrderHeader","aspect","OrderHeader","OrderHeader","S_provider","T_provider","L_provider"]},{"entry":[{},{},"Structure","Key"]},{"entry":["OrderHeader","key aspect","OrderHeader","OrderHeader","S_provider","T_provider","L_provider"]},{"entry":["Key",{},"Key_Table","Key"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]}}]}}},"Table 14 follows the definition of a SCOL_ASP_ASPECT table (defined in Table 2) to define an action Submit for aspect A_OrderHeader. Field INPUT_KEY_ASPECT specifies the key aspect that is sent by application  with the action to specify which instances of aspect A_OrderHeader should be acted upon by the action. Action Submit changes the Submitted field of those instances in back end database  to True. No extra parameters are required for this action Submit so PARAM_STRUCTURE field is blank in Table 14. Field PROVIDER_CLASS specifies the aspect service provider  (referring to ) assigned to each action. In Table 14, action Submit is assigned to aspect service provider S_provider (e.g.,  referring to ).",{"@attributes":{"id":"p-0176","num":"0175"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 14"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example SCOL_ASP_ACTION Table"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"PARAM","INPUT",{}]},{"entry":["ASPECT","ACTION","STRUC-","KEY","PROVIDER"]},{"entry":["NAME*","NAME*","TURE","ASPECT","CLASS"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["A","Submit",{},"OrderHeader","S_provider"]},{"entry":["OrderHeader",{},{},"Key"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"Table 15 follows the definition of a SCOL_RELATION table (defined in Table 3) to define relations between aspects defined in Table 13. These relations reflect relations between data tables in back end database  illustrated by example tables 1-6. These relations between aspects are also illustrated in  for aspect A_Customer , aspect A_Address , aspect A_Product , aspect A_Basket , aspect A_Position , and aspect A_OrderHeader . These relations include R_Customer_To_Address , R_Basket_To_Customer , R_OrderHeader_To_Customer , R_Position_To_Product , R_Position_To_OrderHeader , and R_Position_To_Basket .",{"@attributes":{"id":"p-0178","num":"0177"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"center"}},"thead":{"row":{"entry":"TABLE 15"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example SCOL_RELATION Table"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["RELATION","SOURCE","TARGET","TARGET","REL_PARAM","REL"]},{"entry":["NAME*","ASPECT","ASPECT","PROVIDER","TYPE","PARAMETER"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":["R_Customer","A_Customer","A_Address","S_provider","Parent-Child",{}]},{"entry":"To_Address"},{"entry":["R_Basket_To","A_Basket","A_Customer","S_provider"]},{"entry":"Customer"},{"entry":["R_OrderHeader","A_OrderHeader","A_Customer","S_provider"]},{"entry":"To_Customer"},{"entry":["R_Position_To","A_Position","A_Product","S_provider"]},{"entry":"Product"},{"entry":["R_Position_To","A_Position","A_OrderHeader","S_provider","Child-Parent"]},{"entry":"OrderHeader"},{"entry":["R_Position_To","A_Position","A_Basket","S_provider","Child-Parent"]},{"entry":"Basket"},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}}},"Table 16 follows the definition of a SCOL_SVC_MODULE table (defined in Table 6) to define example service modules for the example definitions of back end database  given in tables 1-6. Table 16 defines service modules S_Customer, S_Product, S_Basket, and S_Order. Field TRANSAC_PROVIDER specifies a transaction service provider  (referring to ) to each service module. In Table 16, transaction service provider T_provider (e.g., , referring to ) is assigned to the service modules.",{"@attributes":{"id":"p-0180","num":"0179"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 16"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example SCOL_SVC_MODULE Table"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"TRANSAC"]},{"entry":[{},"SVC_MODULE_NAME*","PROVIDER"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"S_Customer","T_provider"]},{"entry":[{},"S_Product","T_provider"]},{"entry":[{},"S_Basket","T_provider"]},{"entry":[{},"S_Order","T_provider"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Table 17 follows the definition of a SCOL_ASPECT_USE table (defined in Table 13) to associate service modules (provided by Table 16) with aspects (provided by Table 13).",{"@attributes":{"id":"p-0182","num":"0181"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 17"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example SCOL_ASPECT_USE Table"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SVC_MODULE_NAME*","ASPECT_NAME*"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"S_Customer","A_Customer"]},{"entry":[{},"S_Customer","A_Address"]},{"entry":[{},"S_Product","A_Product"]},{"entry":[{},"S_Basket","A_Basket"]},{"entry":[{},"S_Basket","A_Position"]},{"entry":[{},"S_Order","A_OrderHeader"]},{"entry":[{},"S_Order","A_Position"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Table 18 follows the definition of a SCOL_QUERY table (defined in Table 6) to define queries designed to facilitate business process  of . For example, QueryByName query associated with S_Customer service module takes a Customer_Stucture as input for the query and a set of customer keys (Customer_Key) that defines which keys may be used for filtering. Field PROVIDER_CLASS specifies which query service provider  (referring to ) is associated with each service module. In Table 18, query service provider Q_provider (e.g., 32) is associated with each service module.",{"@attributes":{"id":"p-0184","num":"0183"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"329pt","align":"center"}},"thead":{"row":{"entry":"TABLE 18"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example SCOL_QUERY Table"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SVC_MODULE",{},"RESULT","PARAM","INPUT_KEY","PROVIDER"]},{"entry":["NAME*","QUERY_NAME*","ASPECT","STRUCTURE","ASPECT","CLASS"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":["S_Customer","QueryByName","Customer","Customer","Customer","Q_provider"]},{"entry":[{},{},"Key","Structure","Key"]},{"entry":["S_Product","QueryByName","Product","Product","Product","Q_provider"]},{"entry":[{},{},"Key","Structure","Key"]},{"entry":["S_Basket","QueryByCustomer","Basket_Key","Customer","Customer_Key","Q_provider"]},{"entry":[{},{},{},"Structure"]},{"entry":["S_OrderHeader","QueryByCustomer","OrderHeader","Customer","Customer_Key","Q_provider"]},{"entry":[{},{},"Key","Structure"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}}},"Table 19 defines a data dictionary for the implementation of repository  defined in Tables 7-12. Each row defines a structure having a name and multiple data entries and their types. For example, structure Customer_Structure has one data entry titled \u201cNAME\u201d with a CHAR type indicating a character string. The Customer_Key_Table structure defines a CustomerId key for each customer and also has a CHAR type.",{"@attributes":{"id":"p-0186","num":"0185"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 19"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example SCOL_STRUCT Table"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STRUCT_NAME*","DATA1","TYPE1","DATA2","TYPE2"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Customer_Structure","NAME","CHAR",{},{}]},{"entry":["Customer_Key_Table","CustomerId","CHAR"]},{"entry":["Address_Structure","Town","CHAR","Street","CHAR"]},{"entry":["Address_Key_Table","AddressId","CHAR"]},{"entry":["Product_Structure","Name","CHAR","ProductId","CHAR"]},{"entry":["Product_Key_Table","ProductId","CHAR"]},{"entry":"Basket_Structure"},{"entry":["Basket_Key_Table","BasketId","CHAR"]},{"entry":"Position_Structure"},{"entry":["Position_Key_Table","PositionId","CHAR"]},{"entry":["OrderHeader","Submitted","CHAR"]},{"entry":"Structure"},{"entry":["OrderHeader_Key","OrderId","CHAR"]},{"entry":"Table"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The database operations described above for process  are defined in this implementation of repository  as follows. Querying (), included in process , of the Customers database table (Table 7) is described in meta data repository  by the QueryByName query associated with aspect service module S_Customer in Table 18. This QueryByName query associated with aspect service module S_Customer is selected because the front end application program  has obtained a customer name and service module S_Customer contains aspects with customer names. For example, front end application program  can submit query QueryByName associated with service module S_Customer with NAME=\u201cJohn Smith\u201d and no filtering Customer_Key specified to service manager . Service manager  checks repository  to ensure that the query is defined. Service manager  then submits the query to Q_provider (e.g., ) that queries the Customer database table (Table 7) in database  and the output is sent back to front end application program  is a record set containing CustomerId={}.","Inserting (), included in process , on Addresses database table (Table 8) and inserting (), included in process , on Customers database table (Table 7) are described by standard Insert operations (described previously) on aspects A_Address and A_Customer, respectively, in the meta data repository .","Querying (), included in process , on the Products database table (Table 9) for a product name is described by QueryByName query associated with service module S_Product defined in Table 18. For example, application  can submit the query QueryByName associated with service module S_Product with Name=\u201cWrench\u201d and no filtering Product_Key specified to service manager . Service manager  checks repository  to ensure that the query is defined. Service manager  then submits the query to Q_provider (e.g., ) queries database  and the output sent back to application  is a record set containing ProductId={3}.","Inserting (, , and ), included in process , are defined by insert operations on aspects A_OrderHeader, A_Basket, and A_Position, respectively.","Querying (), included in process , Orders database table (Table 4) by customer is described by the QueryByCustomer query associated with service module S_Order defined in Table 18. For example, front end application program  can submit query QueryByCustomer associated with service module S_Order with Customer_Key (CustomerId)={2} and no filtering OrderHeader_Key. Service manager  checks repository  to ensure that the query is defined. Service manager  then submits the query to Q_provider (e.g., ) that queries database  and the output is sent back to application  is a record set containing OrderHeader_Key (OrderId)={2,3}.","Selecting (), included in process , order operation on Orders database table (Table 4) and setting () submitted field to true on selected orders are defined by the Execute Submit action (defined in Table 6) on aspect A_OrderHeader in repository . For example, front end application program  sends the Submit action on aspect A_OrderHeader to service manager  with OrderHeader_Key={2, 3}. Service manager  then sends the submit operation to S_provider (e.g., ) that changes the Submitted field in Orders database table (Table 4) to \u201cTrue\u201d for selected rows corresponding to OrderId={2, 3}.","Getting () customer address, included in process , from Addresses database table (Table 8) is defined by the standard Select By Relation action on A_Customer aspect. For example, the front end application program  sends a Select By Relation action on A_Customer aspect specifying relation R_Customer_To_Address and Customer_Key={2} to service manager . Service manager  checks the request against repository  and passes the request to service provider S_provider (e.g., ) that looks up foreign key AddressId matching CustomerId={2} and navigates to Addresses table 8. S_provider (e.g., ) returns a record set containing {Louisville, Willow Avenue} from Addresses database table (Table 8) to application  via service manager .","Implementations can be accomplished using digital electronic circuitry, or computer hardware, firmware, software, or combinations of them. Implementations can also be accomplished using a computer program product (i.e., a computer program tangibly embodied in an information carrier (e.g., in a machine-readable storage device or in a propagated signal) for execution by, or to control the operation of, data processing apparatus (e.g., a programmable processor, a computer, or multiple computers)). A computer program can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.","Process steps of the various implementations can be performed by one or more programmable processors executing a computer program to perform functions of the implementations by operating on input data and generating output. Process steps can also be performed by, and apparatus implementations made by, special purpose logic circuitry (e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit)).","Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data (e.g., magnetic, magneto-optical disks, or optical disks). Information carriers suitable for embodying computer program instructions and data include all forms of non-volatile memory, including by way of example semiconductor memory devices (e.g., EPROM, EEPROM, and flash memory devices); magnetic disks (e.g., internal hard disks or removable disks); magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in special purpose logic circuitry.","Various implementations can be implemented in a computing system that includes a back-end component (e.g., as a data server), or that includes a middleware component (e.g., an application server), or that includes a front-end component (e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation) or any combination of such back-end, middleware, or front-end components.","Numerous implementations have been discussed and suggested. Other implementations are within the scope of the following claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
