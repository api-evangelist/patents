---
title: System and method for performing predictable signature analysis
abstract: In one embodiment, a computer system includes a first component configured to output data on a bus in response to a request for data from a second component. The data output by the first component may include both the requested data and unrequested data, and the unrequested data may have an unpredictable value. A controller coupled to the bus may be configured to replace the unrequested data with data that has a predictable value. A signature analysis register included in the second component is configured to capture the requested data and the predictable data output by the controller. Thus, the signature captured in the second component may be predictable, despite the unpredictable data output by the first component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06873330&OS=06873330&RS=06873330
owner: Sun Microsystems, Inc.
number: 06873330
owner_city: Santa Clara
owner_country: US
publication_date: 20020304
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION OF EMBODIMENTS"],"p":["1. Field of the Invention","This invention relates to signature analysis and, more particularly, to signature analysis within graphics systems.","2. Description of the Related Art","Signature analysis is a method of hardware testing. It involves calculating the signature of a set of data according to a particular algorithm, usually after this data has passed through some hardware under test. By comparing the actual signature with a signature that is known to be correct (a \u201cgolden\u201d signature), a pass\/fail determination of the hardware under test can be made.","Signature analysis may involve creating several signature registers throughout a particular system. As data and control signals flow past each signature register, the data and control signals may be captured and combined with the signature in the signature register by applying the signature algorithm. The golden signature used to verify the signatures in the signature registers may be determined through simulation or through performing a test with a particular set of test data on a system that is known to be operating correctly.","Problems may arise during signature analysis if the data and control signals that flow past each signature register are not predictable. Since each data and control signal value may affect the signature in the signature register, unpredictable values may cause unpredictable signatures. Unpredictable signatures do not provide a useful diagnosis of the hardware under test since they may produce an incorrect signature (i.e., a signature that doesn't match the golden signature) even if the system is actually working correctly. Thus, it is desirable to be able to capture predictable signatures in systems where unpredictable data may flow past signature registers.","Various embodiments of a system and method for performing predictable signature analysis are disclosed. In one embodiment, a computer system includes a first component configured to output data on a bus in response to a request for data from a second component. The data output by the first component may include both the requested data and unrequested data, and the unrequested data may have an unpredictable value. A controller coupled to the bus may be configured to replace the unrequested data with data that has a predictable value. A signature analysis register included in the second component is configured to capture the requested data and the predictable data output by the controller. Thus, the signature captured in the second component may be predictable, despite the unpredictable data output by the first component.","While the invention admits various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form (or forms) disclosed, but on the contrary, the intention is to cover all modifications, equivalents, and alternatives falling within the spirit and scope of the present invention as defined by the appended claims. Note, the headings are for organizational purposes only and are not meant to be used to limit or interpret the description or claims. Furthermore, note that the word \u201cmay\u201d is used throughout this application in a permissive sense (i.e., having the potential to, being able to), not a mandatory sense (i.e., must).\u201d The term \u201cinclude,\u201d and derivations thereof, mean \u201cincluding, but not limited to\u201d. The term \u201cconnected\u201d means \u201cdirectly or indirectly connected,\u201d and the term \u201ccoupled\u201d means \u201cdirectly or indirectly coupled.\u201d","Computer System\u2014",{"@attributes":{"id":"P-00022","num":"00022"},"figref":"FIG. 1","b":"80"},"As shown, the computer system  includes a system unit  and a video monitor or display device  coupled to the system unit . The display device  may be any of various types of display monitors or devices (e.g., a CRT, LCD, or gas-plasma display). Various input devices may be connected to the computer system, including a keyboard  and\/or a mouse , or other input device (e.g., a trackball, digitizer, tablet, six-degree of freedom input device, head tracker, eye tracker, data glove, or body sensors). Application software may be executed by the computer system  to display graphical objects on display device .","Computer System Block Diagram\u2014",{"@attributes":{"id":"P-00025","num":"00025"},"figref":"FIG. 2","b":["1","80","102","104","104","106","104"]},"Host processor  may include one or more processors of varying types, e.g., microprocessors, multi-processors and CPUs. The system memory  may include any combination of different types of memory subsystems such as random access memories (e.g., static random access memories or \u201cSRAMs,\u201d synchronous dynamic random access memories or \u201cSDRAMs,\u201d and Rambus dynamic random access memories or \u201cRDRAMs,\u201d among others), read-only memories, and mass storage devices. The system bus or host bus  may include one or more communication or host computer buses (for communication between host processors, CPUs, and memory subsystems) as well as specialized subsystem buses.","In , a graphics system  is coupled to the high-speed memory bus . The graphics system  may be coupled to the bus  by, for example, a crossbar switch or other bus connectivity logic. It is assumed that various other peripheral devices, or other buses, may be connected to the high-speed memory bus . It is noted that the graphics system  may be coupled to one or more of the buses in computer system  and\/or may be coupled to various types of buses. In addition, the graphics system  may be coupled to a communication port and thereby directly receive graphics data from an external source, e.g., the Internet or a network. As shown in the figure, one or more display devices  may be connected to the graphics system .","Host CPU  may transfer information to and from the graphics system  according to a programmed input\/output (I\/O) protocol over host bus . Alternately, graphics system  may access system memory  according to a direct memory access (DMA) protocol or through intelligent bus mastering.","A graphics application program conforming to an application programming interface (API) such as OpenGL\u00ae or Java 3D\u2122 may execute on host CPU  and generate commands and graphics data that define geometric primitives such as polygons for output on display device . Host processor  may transfer the graphics data to system memory . Thereafter, the host processor  may operate to transfer the graphics data to the graphics system  over the host bus . In another embodiment, the graphics system  may read in geometry data arrays over the host bus  using DMA access cycles. In yet another embodiment, the graphics system  may be coupled to the system memory  through a direct port, such as the Advanced Graphics Port (AGP) promulgated by Intel Corporation.","The graphics system may receive graphics data from any of various sources, including host CPU  and\/or system memory , other memory, or from an external source such as a network (e.g., the Internet), or from a broadcast medium, e.g., television, or from other sources.","Note while graphics system  is depicted as part of computer system , graphics system  may also be configured as a stand-alone device (e.g., with its own built-in display). Graphics system  may also be configured as a single chip device or as part of a system-on-a-chip or a multi-chip module. Additionally, in some embodiments, certain of the processing operations performed by elements of the illustrated graphics system  may be implemented in software.","Graphics System\u2014",{"@attributes":{"id":"P-00033","num":"00033"},"figref":"FIG. 3","b":["112","112","112","14","18","20","22","24","112","26","28","14","18"]},"In some embodiments, one or more of these components may be removed. For example, the texture buffer may not be included in an embodiment that does not provide texture mapping. In other embodiments, all or part of the functionality incorporated in either or both of the media processor or the hardware accelerator may be implemented in software.","In one set of embodiments, media processor  is one integrated circuit and hardware accelerator is another integrated circuit. In other embodiments, media processor  and hardware accelerator  may be incorporated within the same integrated circuit. In some embodiments, portions of media processor  and\/or hardware accelerator  may be included in separate integrated circuits.","As shown, graphics system  may include an interface to a host bus such as host bus  in  to enable graphics system  to communicate with a host system such as computer system . More particularly, host bus  may allow a host processor to send commands to the graphics system . In one embodiment, host bus  may be a bi-directional bus.","Media Processor\u2014",{"@attributes":{"id":"P-00038","num":"00038"},"figref":"FIG. 4","b":["14","14","112","80","80","112","14"]},"Transformation refers to the spatial manipulation of objects (or portions of objects) and includes translation, scaling (e.g., stretching or shrinking), rotation, reflection, or combinations thereof. More generally, transformation may include linear mappings (e.g., matrix multiplications), nonlinear mappings, and combinations thereof.","Lighting refers to calculating the illumination of the objects within the displayed image to determine what color values and\/or brightness values each individual object will have. Depending upon the shading algorithm being used (e.g., constant, Gourand, or Phong), lighting may be evaluated at a number of different spatial locations.","As illustrated, media processor  may be configured to receive graphics data via host interface . A graphics queue  may be included in media processor  to buffer a stream of data received via the accelerated port of host interface . The received graphics data may include one or more graphics primitives. As used herein, the term graphics primitive may include polygons, parametric surfaces, splines, NURBS (non-uniform rational B-splines), sub-divisions surfaces, fractals, volume primitives, voxels (i.e., three-dimensional pixels), and particle systems. In one embodiment, media processor  may also include a geometry data preprocessor  and one or more microprocessor units (MPUs) . MPUs  may be configured to perform vertex transformation, lighting calculations and other programmable functions, and to send the results to hardware accelerator . MPUs  may also have read\/write access to texels (i.e., the smallest addressable unit of a texture map) and pixels in the hardware accelerator . Geometry data preprocessor  may be configured to decompress geometry, to convert and format vertex data, to dispatch vertices and instructions to the MPUs , and to send vertex and attribute tags or register data to hardware accelerator .","As shown, media processor  may have other possible interfaces, including an interface to one or more memories. For example, as shown, media processor  may include direct Rambus interface  to a direct Rambus DRAM (DRDRAM) . A memory such as DRDRAM  may be used for program and\/or data storage for MPUs . DRDRAM  may also be used to store display lists and\/or vertex texture maps.","Media processor  may also include interfaces to other functional components of graphics system . For example, media processor  may have an interface to another specialized processor such as hardware accelerator . In the illustrated embodiment, controller  includes an accelerated port path that allows media processor  to control hardware accelerator . Media processor  may also include a direct interface such as bus interface unit (BIU) . Bus interface unit  provides a path to memory  and a path to hardware accelerator  and video output processor  via controller .","Hardware Accelerator\u2014","One or more hardware accelerators  may be configured to receive graphics instructions and data from media processor  and to perform a number of functions on the received data according to the received instructions. For example, hardware accelerator  may be configured to perform rasterization, 2D and\/or 3D texturing, pixel transfers, imaging, fragment processing, clipping, depth cueing, transparency processing, set-up, and\/or screen space rendering of various graphics primitives occurring within the graphics data.","Clipping refers to the elimination of graphics primitives or portions of graphics primitives that lie outside of a 3D view volume in world space. The 3D view volume may represent that portion of world space that is visible to a virtual observer (or virtual camera) situated in world space. For example, the view volume may be a solid truncated pyramid generated by a 2D view window, a viewpoint located in world space, a front clipping plane and a back clipping plane. The viewpoint may represent the world space location of the virtual observer. In most cases, primitives or portions of primitives that lie outside the 3D view volume are not currently visible and may be eliminated from further processing. Primitives or portions of primitives that lie inside the 3D view volume are candidates for projection onto the 2D view window.","Set-up refers to mapping primitives to a three-dimensional viewport. This involves translating and transforming the objects from their original \u201cworld-coordinate\u201d system to the established viewport's coordinates. This creates the correct perspective for three-dimensional objects displayed on the screen.","Screen-space rendering refers to the calculations performed to generate the data used to form each pixel that will be displayed. For example, hardware accelerator  may calculate \u201csamples.\u201d Samples are points that have color information but no real area. Samples allow hardware accelerator  to \u201csuper-sample,\u201d or calculate more than one sample per pixel. Super-sampling may result in a higher quality image.","Hardware accelerator  may also include several interfaces. For example, in the illustrated embodiment, hardware accelerator  has four interfaces. Hardware accelerator  has an interface  (referred to as the \u201cNorth Interface\u201d) to communicate with media processor . Hardware accelerator  may receive commands and\/or data from media processor  through interface . Additionally, hardware accelerator  may include an interface  to bus . Bus  may connect hardware accelerator  to boot PROM  and\/or video output processor . Boot PROM  may be configured to store system initialization data and\/or control code for frame buffer . Hardware accelerator  may also include an interface to a texture buffer . For example, hardware accelerator  may interface to texture buffer  using an eight-way interleaved texel bus that allows hardware accelerator  to read from and write to texture buffer . Hardware accelerator  may also interface to a frame buffer . For example, hardware accelerator  may be configured to read from and\/or write to frame buffer  using a four-way interleaved pixel bus.","The vertex processor  may be configured to use the vertex tags received from the media processor  to perform ordered assembly of the vertex data from the MPUs . Vertices may be saved in and\/or retrieved from a mesh buffer .","The render pipeline  may be configured to rasterize 2D window system primitives and 3D primitives into fragments. A fragment may contain one or more samples. Each sample may contain a vector of color data and perhaps other data such as alpha and control tags. 2D primitives include objects such as dots, fonts, Bresenham lines and 2D polygons. 3D primitives include objects such as smooth and large dots, smooth and wide DDA (Digital Differential Analyzer) lines and 3D polygons (e.g. 3D triangles).","For example, the render pipeline  may be configured to receive vertices defining a triangle, to identify fragments that intersect the triangle.","The render pipeline  may be configured to handle full-screen size primitives, to calculate plane and edge slopes, and to interpolate data (such as color) down to tile resolution (or fragment resolution) using interpolants or components such as:\n\n","In embodiments using supersampling, the sample generator  may be configured to generate samples from the fragments output by the render pipeline  and to determine which samples are inside the rasterization edge. Sample positions may be defined by user-loadable tables to enable stochastic sample-positioning patterns.","Hardware accelerator  may be configured to write textured fragments from 3D primitives to frame buffer . The render pipeline  may send pixel tiles defining r, s, t and w to the texture address unit . The texture address unit  may use the r, s, t and w texture coordinates to compute texel addresses (e.g., addresses for a set of neighboring texels) and to determine interpolation coefficients for the texture filter . The texel addresses are used to access texture data (i.e., texels) from texture buffer . The texture buffer  may be interleaved to obtain as many neighboring texels as possible in each clock. The texture filter  may perform bilinear, trilinear or quadlinear interpolation. The texture environment  may apply texels to samples produced by the sample generator . The texture environment  may also be used to perform geometric transformations on images (e.g., bilinear scale, rotate, flip) as well as to perform other image filtering operations on texture buffer image data (e.g., bicubic scale and convolutions).","In the illustrated embodiment, the pixel transfer MUX  controls the input to the pixel transfer unit . The pixel transfer unit  may selectively unpack pixel data received via north interface , select channels from either the frame buffer  or the texture buffer , or select data received from the texture filter  or sample filter .","The pixel transfer unit  may be used to perform scale, bias, and\/or color matrix operations, color lookup operations, histogram operations, accumulation operations, normalization operations, and\/or min\/max functions. Depending on the source of (and operations performed on) the processed data, the pixel transfer unit  may output the processed data to the texture buffer  (via the texture buffer MUX ), the frame buffer  (via the texture environment unit  and the fragment processor ), or to the host (via north interface ). For example, in one embodiment, when the pixel transfer unit  receives pixel data from the host via the pixel transfer MUX , the pixel transfer unit  may be used to perform a scale and bias or color matrix operation, followed by a color lookup or histogram operation, followed by a min\/max function. The pixel transfer unit  may also scale and bias and\/or lookup texels. The pixel transfer unit  may then output data to either the texture buffer  or the frame buffer .","Fragment processor  may be used to perform standard fragment processing operations such as the OpenGL\u00ae fragment processing operations. For example, the fragment processor  may be configured to perform the following operations: fog, area pattern, scissor, alpha\/color test, ownership test (WID), stencil test, depth test, alpha blends or logic ops (ROP), plane masking, buffer selection, pick hit\/occlusion detection, and\/or auxiliary clipping in order to accelerate overlapping windows.","Texture Buffer ","In one embodiment, texture buffer  may include several SDRAMs. Texture buffer  may be configured to store texture maps, image processing buffers, and accumulation buffers for hardware accelerator . Texture buffer  may have many different capacities (e.g., depending on the type of SDRAM included in texture buffer ). In some embodiments, each pair of SDRAMs may be independently row and column addressable.","Frame Buffer ","Graphics system  may also include a frame buffer . In one embodiment, frame buffer  may include multiple memory devices such as 3D-RAM memory devices manufactured by Mitsubishi Electric Corporation. Frame buffer  may be configured as a display pixel buffer, an offscreen pixel buffer, and\/or a super-sample buffer. Furthermore, in one embodiment, certain portions of frame buffer  may be used as a display pixel buffer, while other portions may be used as an offscreen pixel buffer and sample buffer.","Video Output Processor\u2014","A video output processor  may also be included within graphics system . Video output processor  may buffer and process pixels output from frame buffer . For example, video output processor  may be configured to read bursts of pixels from frame buffer . Video output processor  may also be configured to perform double buffer selection (dbsel) if the frame buffer  is double-buffered, overlay transparency (using transparency\/overlay unit ), plane group extraction, gamma correction, psuedocolor or color lookup or bypass, and\/or cursor generation. For example, in the illustrated embodiment, the output processor  includes WID (Window ID) lookup tables (WLUTs)  and gamma and color map lookup tables (GLUTs, CLUTs) . In one embodiment, frame buffer  may include multiple 3DRAM64s  that include the transparency overlay  and all or some of the WLUTs . Video output processor  may also be configured to support two video output streams to two displays using the two independent video raster timing generators . For example, one raster (e.g., A) may drive a 1280\u00d71024 CRT while the other (e.g., B) may drive a NTSC or PAL device with encoded television video.","DAC  may operate as the final output stage of graphics system . The DAC  translates the digital pixel data received from GLUT\/CLUTs\/Cursor unit  into analog video signals that are then sent to a display device. In one embodiment, DAC  may be bypassed or omitted completely in order to output digital pixel data in lieu of analog video signals. This may be useful when a display device is based on a digital technology (e.g., an LCD-type display or a digital micro-mirror display).","DAC  may be a red-green-blue digital-to-analog converter configured to provide an analog video output to a display device such as a cathode ray tube (CRT) monitor. In one embodiment, DAC  may be configured to provide a high resolution RGB analog video output at dot rates of 240 MHz. Similarly, encoder  may be configured to supply an encoded video signal to a display. For example, encoder  may provide encoded NTSC or PAL video to an S-Video or composite video television monitor or recording device.","In other embodiments, the video output processor  may output pixel data to other combinations of displays. For example, by outputting pixel data to two DACs  (instead of one DAC  and one encoder ), video output processor  may drive two CRTs. Alternately, by using two encoders , video output processor  may supply appropriate video input to two television monitors. Generally, many different combinations of display devices may be supported by supplying the proper output device and\/or converter for that display device.","Sample-to-Pixel Processing Flow\u2014","In one set of embodiments, hardware accelerator  may receive geometric parameters defining primitives such as triangles from media processor , and render the primitives in terms of samples. The samples may be stored in a sample storage area (also referred to as the sample buffer) of frame buffer . The samples are then read from the sample storage area of frame buffer  and filtered by sample filter  to generate pixels. The pixels are stored in a pixel storage area of frame buffer . The pixel storage area may be double-buffered. Video output processor  reads the pixels from the pixel storage area of frame buffer  and generates a video stream from the pixels. The video stream may be provided to one or more display devices (e.g., monitors, projectors, head-mounted displays, and so forth) through DAC  and\/or video encoder .","The samples are computed at positions in a two-dimensional sample space (also referred to as rendering space). The sample space may be partitioned into an array of bins (also referred to herein as fragments). The storage of samples in the sample storage area of frame buffer  may be organized according to bins (e.g., bin ) as illustrated in FIG. . Each bin may contain one or more samples. The number of samples per bin may be a programmable parameter.","Signature Analysis\u2014","In order to provide testing capabilities, some embodiments of a graphics system like the one shown in  may include signature analysis hardware. The signal analysis hardware may include one or more signature analysis registers (SARs) that each store a signature as well as control hardware that controls how data and\/or control signals are added to the existing signature(s) and allows capture to be started and stopped. Each SAR maybe initialized to a seed value or signature and, as data and\/or control signals are captured, they may be combined with the seed value or signature to form a new signature. By comparing a calculated signature with a signature that is known to be correct for the same set of data, a pass\/fail determination of the hardware under test may be made.","SARs may be arranged so that the signature in each may be used to verify a certain section of a graphics system. SARs may also be included at various locations within the graphics system (e.g., at the interface between the frame buffer  and the hardware accelerator  in order to capture data as it is provided to the frame buffer ). As described above, data may be reordered and\/or additionally processed as it flows through the graphics system, so the final signature stored in each SAR may differ from each of the other signatures for any given test. Furthermore, some tests may only target certain SARs.","SARs may be included at various interfaces in order to determine whether the data sent to a component is the same as the data received by the component. Many situations may arise where unpredictable data is passed between components in a graphics system. In order to prevent this unpredictable data from causing one or more of the signatures to become unpredictable during testing, the signature analysis hardware may also include a controller that replaces unpredictable data with a data of a known value. For example, if one component requests 32 bits of data from another component, the other component may respond by providing 64 bits of data (e.g., in accordance with the bus protocol of the data bus connecting the two components). The unrequested 32 bits may have unpredictable values that, if captured by the requesting device's SAR, would cause the resulting signature to be unpredictable. In order to cause the signature captured by the requesting component to be predictable, the unrequested bits may be replaced with bits having a known value before the data is captured by the signature analysis register.",{"@attributes":{"id":"P-00080","num":"00080"},"figref":["FIG. 8","FIG. 8"],"b":["220","18","252","20","22","14","18"]},"The first component  includes a data consumer  that is configured to generate requests for data from the second component . The first component  sends the requests for data to the second component. In this embodiment, the second component  includes a request queue  in which to buffer received requests. An indication of which data was requested in a given a request may be stored in a buffer . Buffer  may store multiple indications that identify the data requested by multiple pending requests in some embodiments. In such an embodiment, buffer  may be implemented as a FIFO (First In, First Out) queue. Each request is satisfied by data provider  outputting data onto bus  to the first component .","Data provider  may output more data than is requested in response to certain requests. For example, in accordance with a bus protocol for one embodiment of bus , each bus transaction may involve 128 bits (16 bytes) of data and a 16-bit byte mask indicating which bytes are valid (e.g., which bytes were requested by the data consumer). Each bit in the byte mask may indicate whether a corresponding byte is valid. The byte mask corresponding to a transaction may be stored in buffer  as requests are handled by the data provider .","When data provider  outputs requested data to bus , it passes through multiplexers , which may be controlled by the byte mask in buffer  that corresponds to the requested data. Multiplexers  select requested data (e.g., based on which bytes are indicated as being valid in the byte mask) to be output on bus . For example, in one embodiment, each multiplexer may be controlled by a bit in a byte mask that identifies whether a byte of data input to that multiplexer is valid or not for the current transaction.","The multiplexers  replace unrequested data (e.g., based on which bytes are indicated as being invalid in the byte mask) with data having a known value (as shown in , this value may be \u20180\u2019) and output the data having the known value onto bus . For example, if data provider  outputs 16 bits of data, 8 bits may be input to each multiplexer. If the byte mask for a particular transaction is \u201801\u2019 (e.g., indicating that the first 8 bits are invalid and the second 8 bits are valid), the leftmost multiplexer may output \u201800000000\u2019 and the rightmost multiplexer may output the 8 bits provided from data provider . Note that while two multiplexers  may be used in some embodiments, as shown in , other embodiments may include fewer or additional multiplexers. Furthermore, other embodiments may replace unrequested data with predictable data values other than zero. Additionally, indications other than byte masks may be used to identify which of the provided data was requested. In some embodiments, unrequested data may be replaced with data having a known value without using the specific hardware illustrated in FIG. .","In this embodiment, data output from multiplexers  is provided to a data queue , where it is buffered before being output onto bus . Note that in some embodiments, data may not be buffered in a queue  before being output to bus . Additionally, in some embodiments, data in a data queue  may be initialized to a predictable value (e.g., zero) in order to increase the likelihood that SAR  will capture predictable data.","The SAR  captures the data returned on bus  and combines this data with an existing signature to generate a new signature value. Since the unrequested data seen by the SAR  has a predictable value, the correct value of signature in SAR  is predictable. Thus, the correct signature may be determined by running the same test on a known working system or by simulation. The signature actually captured in SAR  may be compared to the known correct signature in order to determine whether the first component  received the correct data. If the signature is incorrect, it may indicate a failure of bus  or the second component . Note that in some embodiments, certain control signals may also be combined with the signature in SAR .","In some embodiments, the second component  may also include an SAR (not shown) in order to capture data before it is output on bus . This may allow erroneous components to be more easily detected. For example, if the signature in SAR  is incorrect and the signature captured internally to the second component is correct, it may indicate that the second component  is working correctly and that the bus  is malfunctioning. The SAR in the second component  may be coupled to capture the data being output to bus  after it has passed through multiplexers . In one embodiment, the signatures captured in the first component  and the second component  may be compared in order to determine whether data was correctly transmitted across the bus . Note that additional SARs may also be included (e.g., to capture control signals corresponding to the data transaction).",{"@attributes":{"id":"P-00088","num":"00088"},"figref":"FIG. 8A","b":["8","202","264","254","264","258","258","220","260","260","260","204","260","258","266","206"]},"Signature capture may be controlled by test software running on a host computer system . The test software may enable signature capture and compare the captured signature(s) to the expected signature(s) that a working system would generate. The control signatures may be generated by a known working system or by simulation. Before capture is enabled, the test software may set the value of the signature field to a \u201cseed\u201d value. The seed value(s) chosen for a particular test may correspond to the test image(s) being used with that test. Note that a different seed value may be stored in each SAR. In one embodiment, each SAR's seed value may be a zero value (e.g., input by resetting each SAR).","Each SAR may receive control signals (e.g., from a host computer system ) that enable signature capture and\/or that control how many cycles of data and\/or control signals each SAR captures. In some embodiments, control signals provided to control each SAR may indicate a number of cycles that the SAR should delay before beginning capture. In one embodiment, the control signals that control each SAR may also affect the signatures of one or more of the SARs. Furthermore, reads to a particular SAR may also affect the signature stored in that SAR.","After capturing a signature, each SAR may continue to store the captured signature until its signature fields are cleared, a new seed value is written to its signature field, or capture is reinitiated. For example, in some embodiments, another capture may be requested using the previously captured signatures as the starting value (as opposed to storing a new seed value in each of the SARs) in order to capture more cycles of data and\/or control signals than were requested in the previous capture.","Various algorithms may be used to combine each new data or control signal being captured to the signature. For example, one algorithm may involve XORing a captured bit with all or part of the preexisting signature. In another embodiment, the SARs may be implemented as LHCAs (linear hybrid cellular automatons). Generally, a cellular automaton is a discrete dynamical system where the signatures in the each register are updated according to a local rule. The registers may be updated at discrete time intervals. Each register's value may depend on what its value was in the previous time step. Additionally, each register's state may also depend on the signatures in its neighboring registers in the previous time step.","Signature calculation algorithms may be chosen so each set of test data and\/or test control signals has a (nearly) unique signature. This way, there is little chance that a flawed system will produce the correct signature. In embodiments where the test sets are large, it may be useful to select an algorithm that is capable of capturing a large amount of data without creating repetitive signatures. As more data is captured, the amount of error detection may increase.","Different sets of test data and\/or control signals may be designed that will each stress particular hardware. Depending on which of these tests pass and which fail, flawed hardware may be detected.",{"@attributes":{"id":"P-00095","num":"00095"},"figref":"FIG. 9","b":["901","903","905","907","909","909"]},"Note that while specific embodiments of a method and system for performing signature analysis have been described in the context of a graphics system, similar embodiments may be implemented in other computer systems. Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A better understanding of the present invention can be obtained when the following detailed description is considered in conjunction with the following drawings, in which:",{"@attributes":{"id":"P-00010","num":"00010"},"figref":"FIG. 1"},{"@attributes":{"id":"P-00011","num":"00011"},"figref":"FIG. 2"},{"@attributes":{"id":"P-00012","num":"00012"},"figref":"FIG. 3"},{"@attributes":{"id":"P-00013","num":"00013"},"figref":"FIG. 4","b":"3"},{"@attributes":{"id":"P-00014","num":"00014"},"figref":"FIG. 5","b":"3"},{"@attributes":{"id":"P-00015","num":"00015"},"figref":"FIG. 6","b":"3"},{"@attributes":{"id":"P-00016","num":"00016"},"figref":"FIG. 7"},{"@attributes":{"id":"P-00017","num":"00017"},"figref":"FIG. 8"},{"@attributes":{"id":"P-00018","num":"00018"},"figref":"FIG. 8A"},{"@attributes":{"id":"P-00019","num":"00019"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
