---
title: System and method for sudden proximal user interface
abstract: Provided is a distributed system and method for enabling new and useful location dependent features and functionality to mobile data processing systems. Mobile data processing Systems (MSs) interact with each other as peers in communications and interoperability. Data is shared between mobile data processing systems to carry out novel Location Based eXchanges (LBX) of data for new mobile applications. Information transmitted inbound to, transmitted outbound from, is in process at, or is application modified at a mobile data processing system triggers processing of actions in accordance with user configured permissions, charters, and other configurations. In a preferred embodiment, a user configurable platform is provided for quickly building well behaving LBX applications at MSs and across a plurality of interoperating MSs. Tools, triggered interfaces and integrated applications are disclosed for a breadth of MS LBX configurations and functionality.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08897742&OS=08897742&RS=08897742
owner: 
number: 08897742
owner_city: 
owner_country: 
publication_date: 20130821
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCES TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","Location Based eXchanges (LBX) Architecture","LBX Directly Located Mobile Data Processing Systems (DLMs)","LBX Indirectly Located Mobile Data Processing Systems (ILMs)","Missing Part Triangulation (MPT)","LBX Configuration","LBX: LN-EXPANSE Configuration","LBX: LN-EXPANSE Interoperability","Alternative IPC Embodiments","LBX: Permissions and Charters\u2014Configuration","LBX: Permissions and Charters\u2014WDR Processing","Application Term Triggers","Related Linkage Discussion","Application Fields ","Sudden Proximal User Interface (SPUI)","SPUI Examples","Various Applications","Automatic Communications Processing","Automatic Application Association Processing","Automatic MS Configuration Processing","OTHER EMBODIMENTS"],"p":["This application is a continuation of application Ser. No. 12\/590,831 filed Nov. 13, 2009 and entitled \u201cSystem and Method for Location Based Exchanges of Data Facilitating Distributed Locational Applications\u201d which is a continuation in part of application Ser. No. 12\/287,064 filed Oct. 3, 2008 and entitled \u201cSystem and Method for Location Based Exchanges of Data Facilitating Distributed Locational Applications\u201d which is a continuation in part of application Ser. No. 12\/077,041 filed Mar. 14, 2008 and entitled \u201cSystem and Method for Location Based Exchanges of Data Facilitating Distributed Locational Applications\u201d. This application contains an identical specification to Ser. No. 12\/590,831 except for the title, abstract, and claims.","The present disclosure relates generally to location based services for mobile data processing systems, and more particularly to location based exchanges of data between distributed mobile data processing systems for locational applications. A common connected service is not required for location based functionality and features. Location based exchanges of data between distributed mobile data processing systems enable location based features and functionality in a peer to peer manner.","The internet has exploded with new service offerings. Websites yahoo.com, google.com, ebay.com, amazon.com, and iTunes.com have demonstrated well the ability to provide valuable services to a large dispersed geographic audience through the internet (ebay, yahoo, google, amazon and iTunes (Apple) are trademarks of the respective companies). Thousands of different types of web services are available for many kinds of functionality. Advantages of having a service as the intermediary point between clients, users, and systems, and their associated services, includes centralized processing, centralized maintaining of data, for example to have an all knowing database for scope of services provided, having a supervisory point of control, providing an administrator with access to data maintained by users of the web service, and other advantages associated with centralized control. The advantages are analogous to those provided by the traditional mainframe computer to its clients wherein the mainframe owns all resources, data, processing, and centralized control for all users and systems (clients) that access its services. However, as computers declined in price and adequate processing power was brought to more distributed systems, such as Open Systems (i.e. Windows, UNIX, Linux, and Mac environments), the mainframe was no longer necessary for many of the daily computing tasks. In fact, adequate processing power is incorporated in highly mobile devices, various handheld mobile data processing systems, and other mobile data processing systems. Technology continues to drive improved processing power and data storage capabilities in less physical space of a device. Just as Open Systems took much of the load of computing off of mainframe computers, so to can mobile data processing systems offload tasks usually performed by connected web services. As mobile data processing systems are more capable, there is no need for a service to middleman interactions possible between them.","While a centralized service has its advantages, there are also disadvantages. A service becomes a clearinghouse for all web service transactions. Regardless of the number of threads of processing spread out over hardware and processor platforms, the web service itself can become a bottleneck causing poor performance for timely response, and can cause a large amount of data that must be kept for all connected users and\/or systems. Even large web services mentioned above suffer from performance and maintenance overhead. A web service response will likely never be fast enough. Additionally, archives must be kept to ensure recovery in the event of a disaster because the service houses all data for its operations. Archives also require storage, processing power, planning, and maintenance. A significantly large and costly data center is necessary to accommodate millions of users and\/or systems to connect to the service. There is a tremendous amount of overhead in providing such a service. Data center processing power, data capacity, data transmission bandwidth and speed, infrastructure entities, and various performance considerations are quite costly. Costs include real estate required, utility bills for electricity and cooling, system maintenance, personnel to operate a successful business with service(s), etc. A method is needed to prevent large data center costs while eliminating performance issues for features sought. It is inevitable that as users are hungry for more features and functionality on their mobile data processing systems, processing will be moved closer to the device for optimal performance and infrastructure cost savings.","Service delivered location dependent content was disclosed in U.S. Pat. Nos. 6,456,234; 6,731,238; 7,187,997 (Johnson). Anonymous location based services was disclosed in U.S. PTO Publication 2006\/0022048 (Johnson). The Johnson patents and published application operate as most web services do in that the clients connecting to the service benefit from the service by having some connectivity to the service. U.S. Publication 2006\/0022048 (Johnson) could cause large numbers of users to inundate the service with device heartbeats and data to maintain, depending on the configurations made. While this may be of little concern to a company that has successfully deployed substantially large web service resources, it may be of great concern to other more frugal companies. A method is needed for enabling location dependent features and functionality without the burden of requiring a service.","Users are skeptical about their privacy as internet services proliferate. A service by its very nature typically holds information for a user maintained in a centralized service database. The user's preferences, credential information, permissions, customizations, billing information, surfing habits, and other conceivable user configurations and activity monitoring, can be housed by the service at the service. Company insiders, as well as outside attackers, may get access. Most people are concerned with preventing personal information of any type being kept in a centralized database which may potentially become compromised from a security standpoint. Location based services are of even more concern, in particular when the locations of the user are to be known to a centralized service. A method and system is needed for making users comfortable with knowing that their personal information is at less risk of being compromised.","A reasonable requirement is to push intelligence out to the mobile data processing systems themselves, for example, in knowing their own locations and perhaps the locations of other nearby mobile data processing systems. Mobile data processing systems can intelligently handle many of their own application requirements without depending on some remote service. Just as two people in a business organization should not need a manager to speak to each other, no two mobile data processing systems should require a service middleman for useful location dependent features and functionality. The knowing of its own location should not be the end of social interaction implementation local to the mobile data processing systems, but rather the starting place for a large number of useful distributed local applications that do not require a service.","Different users use different types of Mobile data processing Systems (MSs) which are also called mobile devices: laptops, tablet computers, Personal Computers (PCs), Personal Digital Assistants (PDAs), cell phones, automobile dashboard mounted data processing systems, shopping cart mounted data processing systems, mobile vehicle or apparatus mounted data processing systems, Personal Navigational Devices (PNDs), iPhones (iPhone is a trademark of Apple, Inc.), various handheld mobile data processing systems, etc. MSs move freely in the environment, and are unpredictably moveable (i.e. can be moved anywhere, anytime). Many of these Mobile data processing Systems (MSs) do not have capability of being automatically located, or are not using a service for being automatically located. Conventional methods use directly relative stationary references such as satellites, antennas, etc. to locate MSs. Stationary references are expensive to deploy, and risk obsolescence as new technologies are introduced to the marketplace. Stationary references have finite scope of support for locating MSs.","While the United States E911 mandate for cellular devices documents requirements for automatic location of a Mobile data processing System (MS) such as a cell phone, the mandate does not necessarily promote real time location and tracking of the MSs, nor does it define architecture for exploiting Location Based Services (LBS). We are in an era where Location Based Services (LBS), and location dependent features and functionality, are among the most promising technologies in the world. Automatic locating of every Mobile data processing System (MS) is an evolutionary trend. A method is needed to shorten the length of time for automatically locating every MS. Such a goal can be costly using prior art technologies such as GPS (Global Positioning System), radio wave triangulation, coming within range to a known located sensor, or the like. Complex system infrastructure, or added hardware costs to the MSs themselves, make such ventures costly and time constrained by schedules and costs involved in engineering, construction, and deployment.","A method is needed for enabling users to get location dependent features and functionality through having their mobile locations known, regardless of whether or not their MS is equipped for being located. Also, new and modern location dependent features and functionality can be provided to a MS unencumbered by a connected service.","LBS (Location Based Services) is a term which has gained in popularity over the years as MSs incorporate various location capability. The word \u201cServices\u201d in that terminology plays a major role in location based features and functionality involving interaction between two or more users. This disclosure introduces a new terminology, system, and method referred to as Location Based eXchanges (LBX). LBX is an acronym used interchangeably\/contextually throughout this disclosure for the singular term \u201cLocation Based Exchange\u201d and for the plural term \u201cLocation Based Exchanges\u201d, much the same way LBS is used interchangeably\/contextually for the single term \u201cLocation Based Service\u201d and for the plural term \u201cLocation Based Services\u201d. LBX describes leveraging the distributed nature of connectivity between MSs in lieu of leveraging a common centralized service nature of connectivity between MSs. The line can become blurred between LBS and LBX since the same or similar features and functionality are provided, and in some cases strengths from both may be used. The underlying architectural shift differentiates LBX from LBS for depending less on centralized services, and more on distributed interactions between MSs. LBX provide server-free and server-less location dependent features and functionality.","Disclosed are many different aspects to LBX, starting with the foundation requirement for each participating MS to know, at some point in time, their own whereabouts. LBX is enabled when an MS knows its own whereabouts. It is therefore a goal to first make as many MSs know their own whereabouts as possible. When two or more MSs know their own whereabouts, LBX enables distributed locational applications whereby a server is not required to middleman social interactions between the MSs. The MSs interact as peers. LBX disclosed include purely peer to peer interactions, peer to peer interactions for routing services, peer to peer interactions for delivering distributed services, and peer to peer interactions for location dependent features and functionality (e.g. a first mobile data processing system sends directly (e.g. wirelessly) to a second mobile data processing system without using an intervening data processing system). One embodiment of an LBX enabled MS is referred to as an lbxPhone\u2122.","It is an advantage herein to have no centralized service governing location based features and functionality among MSs. Avoiding a centralized service prevents performance issues, infrastructure costs, and solves many of the issues described above. No centralized service also prevents a user's information from being kept in one accessible place. LBS contain centralized data that is personal in nature to its users. This is a security concern. Having information for all users in one place increases the likelihood that a disaster to the data will affect more than a single user. LBX spreads data out across participating systems so that a disaster affecting one user does not affect any other user.","It is an advantage herein for enabling useful distributed applications without the necessity of having a service, and without the necessity of users and\/or systems registering with a service. MSs interact as peers in preferred embodiments, rather than as clients to a common service (e.g. internet connected web service).","It is an advantage herein for locating as many MSs as possible in a wireless network, and without additional deployment costs on the MSs or the network. Conventional locating capability includes GPS (Global Positioning System) using stationary orbiting satellites, improved forms of GPS, for example AGPS (Adjusted GPS) and DGPS (Differential GPS) using stationary located ground stations, wireless communications to stationary located cell tower base stations, TDOA (Time Difference of Arrival) or AOA (Angle of Arrival) triangulation using stationary located antennas, presence detection in vicinity of a stationary located antenna, presence detection at a wired connectivity stationary network location, or other conventional locating systems and methods. Mobile data processing systems, referred to as Indirectly Located Mobile data processing systems (ILMs), are automatically located using automatically detected locations of Directly Located Mobile data processing systems (DLMs) and\/or automatically detected locations of other ILMs. ILMs are provided with the ability to participate in the same LBS, or LBX, as a DLM (Directly Located Mobile data processing system). DLMs are located using conventional locating capability mentioned above. DLMs provide reference locations for automatically locating ILMs, regardless of where any one is currently located. DLMs and ILMs can be highly mobile, for example when in use by a user. There are a variety of novel methods for automatically locating ILMs, for example triangulating an ILM (Indirectly Located Mobile data processing system) location using a plurality of DLMs, detecting the ILM being within the vicinity of at least one DLM, triangulating an ILM location using a plurality of other ILMs, detecting the ILM being within the vicinity of at least one other ILM, triangulating an ILM location using a mixed set of DLM(s) and ILM(s), determining the ILM location from heterogeneously located DLMs and\/or ILMs, and other novel methods.","MSs are automatically located without using direct conventional means for being automatically located. The conventional locating capability (i.e. conventional locating methods) described above is also referred to as direct methods. Conventional methods are direct methods, but not all direct methods are conventional. There are new direct techniques disclosed below. Provided herein is an architecture, as well as systems and methods, for immediately bringing automatic location detection to every MS in the world, regardless of whether that MS is equipped for being directly located. MSs without capability of being directly located are located by leveraging the automatically detected locations of MSs that are directly located. This is referred to as being indirectly located. An MS which is directly located is hereinafter referred to as a Directly Located Mobile data processing system (DLM). For a plural acronym, MSs which are directly located are hereinafter referred to as Directly Located Mobile data processing systems (DLMs). MSs without capability of being directly located are located using the automatically detected locations of MSs that have already been located. An MS which is indirectly located is hereinafter referred to as an Indirectly Located Mobile data processing system (ILM). For a plural acronym, MSs which are indirectly located are hereinafter referred to as Indirectly Located Mobile data processing systems (ILMs). A DLM can be located in the following ways:\n\n","In one example, the mobile locations of several MSs are automatically detected using their local GPS chips. Each is referred to as a DLM. The mobile location of a non-locatable MS is triangulated using radio waves between it and three (3) of the GPS equipped DLMs. The MS becomes an ILM upon having its location determined relative the DLMs. ILMs are automatically located using DLMs, or other already located ILMs. An ILM can be located in the following ways:\n\n","Locating functionality may leverage GPS functionality, including but not limited to GPS, AGPS (Adjusted GPS), DGPS, (Differential GPS), or any improved GPS embodiment to achieve higher accuracy using known locations, for example ground based reference locations. The NexTel GPS enabled iSeries cell phones provide excellent examples for use as DLMs (Nextel is a trademark of Sprint\/Nextel). Locating functionality may incorporate triangulated locating of the MS, for example using a class of Radio Frequency (RF) wave spectrum (cellular, WiFi (some WiFi embodiments referred to as WiMax), bluetooth, etc), and may use measurements from different wave spectrums for a single location determination (depends on communications interface(s)  available). A MS may have its whereabouts determined using a plurality of wave spectrum classes available to it (cellular, WiFi, bluetooth, etc). The term \u201cWiFi\u201d used throughout this disclosure also refers to the industry term \u201cWiMax\u201d. Locating functionality may include in-range proximity detection for detecting the presence of the MS. Wave forms for triangulated locating also include microwaves, infrared wave spectrum relative infrared sensors, visible light wave spectrum relative light visible light wave sensors, ultraviolet wave spectrum relative ultraviolet wave sensors, X-ray wave spectrum relative X-ray wave sensors, gamma ray wave spectrum relative gamma ray wave sensors, and longwave spectrum (below AM) relative longwave sensors. While there are certainly more common methods for automatically locating a MS (e.g. radio wave triangulation, GPS, in range proximity detection), those skilled in the art recognize there are methods for different wave spectrums being detected, measured, and used for carrying information between data processing systems.","Kubler et al (U.S. PTO publications 2004\/0264442, 2004\/0246940, 2004\/0228330, 2004\/0151151) disclosed methods for detecting presence of mobile entities as they come within range of a sensor. In Kubler et al, accuracy of the location of the detected MS is not well known, so an estimated area of the whereabouts of the MS is enough to accomplish intended functionality, for example in warehouse installations. A confidence value of this disclosure associated with Kubler et al tends to be low (i.e. not confident), with lower values for long range sensors and higher values for short range sensors.","GPS and the abundance of methods for improving GPS accuracy has led to many successful systems for located MSs with high accuracy. Triangulation provides high accuracies for locating MSs. A confidence value of this disclosure associated with GPS and triangulating location methods tends to be high (i.e. confident). It is preferred that DLMs use the highest possible accuracy method available so that relative ILMs are well located. Not all DLMs need to use the same location methods. An ILM can be located relative DLMs, or other ILMs, that each has different locating methodologies utilized.","Another advantage herein is to generically locate MSs using varieties and combinations of different technologies. MSs can be automatically located using direct conventional methods for accuracy to base on the locating of other MSs. MSs can be automatically located using indirect methods. Further, it is an advantage to indirectly locate a MS relative heterogeneously located MSs. For example, one DLM may be automatically located using GPS. Another DLM may be automatically located using cell tower triangulation. A third DLM may be automatically located using within range proximity. An ILM can be automatically located at a single location, or different locations over time, relative these three differently located DLMs. The automatically detected location of the ILM may be determined using a form of triangulation relative the three DLMs just discussed, even though each DLM had a different direct location method used. In a preferred embodiment, industry standard IEEE 802.11 WiFi is used to locate (triangulate) an ILM relative a plurality of DLMs (e.g. TDOA in one embodiment). This standard is prolific among more compute trended MSs. Any of the family of 802.11 wave forms such as 802.11a, 802.11b, 802.11g, or any other similar class of wave spectrum can be used, and the same spectrum need not be used between a single ILM and multiple DLMs. 802.x used herein generally refers to the many 802.whatever variations.","Another advantage herein is to make use of existing marketplace communications hardware, communications software interfaces, and communications methods and location methods where possible to accomplish locating an MS relative one or more other MSs. While 802.x is widespread for WiFi communications, other RF wave forms can be used (e.g. cell phone to cell tower communications). In fact, any wave spectrum for carrying data applies herein. Of course, any protocol(s) may be involved in embodiments of the disclosures (e.g. TDMA, CDMA, H.323, SIP, 2G, 3G, ip phone, digital, analog, spectrum frequency, etc).","Still another advantage is for support of heterogeneous locatable devices. Different people like different types of devices as described above. Complete automation of locating functionality can be provided to a device through local automatic location detection means, or by automatic location detection means remote to the device. Also, an ILM can be located relative a laptop, a cell phone, and a PDA (i.e. different device types).","Yet another advantage is to prevent the unnecessary storing of large amounts of positioning data for a network of MSs. Keeping positioning data for knowing the whereabouts of all devices can be expensive in terms of storage, infrastructure, performance, backup, and disaster recovery. A preferred embodiment simply uses a distributed approach to determining locations of MSs without the overhead of an all-knowing database maintained somewhere. Positions of MSs can be determined \u201con the fly\u201d without storing information in a master database. However, there are embodiments for storing a master database, or a subset thereof, to configurable storage destinations, when it makes sense. A subset can be stored at a MS.","Another advantage includes making use of existing location equipped MSs to expand the network of locatable devices by locating non-equipped MSs relative the location of equipped MSs. MSs themselves help increase dimensions of the locatable network of MSs. The locatable network of MSs is referred to as an LN-Expanse (i.e. Location-Network Expanse). An LN-Expanse dynamically grows and shrinks based on where MSs are located at a particular time. For example, as users travel with their personal MSs, the personal MSs themselves define the LN-Expanse since the personal MSs are used to locate other MSs. An ILM simply needs location awareness relative located MSs (DLMs and\/or ILMs).","Yet another advantage is a MS interchangeably taking on the role of a DLM or ILM as it travels. MSs are chameleons in this regard, in response to location technologies that happen to be available. A MS may be equipped for DLM capability, but may be in a location at some time where the capability is inoperable. In these situations the DLM takes on the role of an ILM. When the MS again enters a location where it can be a DLM, it automatically takes on the role of the DLM. This is very important, in particular for emergency situations. A hiker has a serious accident in the mountains which prevents GPS equipped DLM capability from working. Fortunately, the MS automatically takes on the role of an ILM and is located within the vicinity of neighboring (nearby) MSs. This allows the hiker to communicate his location, operate useful locational application functions and features at his MS, and enable emergency help that can find him.","It is a further advantage that MS locations be triangulated using any wave forms (e.g. RF, microwaves, infrared, visible light, ultraviolet, X-ray, gamma ray). X-ray and gamma ray applications are special in that such waves are harmful to humans in short periods of times, and such applications should be well warranted to use such wave forms. In some medical embodiments, micro-machines may be deployed within a human body. Such micro-machines can be equipped as MSs. Wave spectrums available at the time of deployment can be used by the MSs for determining exact positions when traveling through a body.","It is another advantage to use TDOA (Time Difference Of Arrival), AOA (Angle Of Arrival), and Missing Part Triangulation (MPT) when locating a MS. TDOA uses time information to determine locations, for example for distances of sides of a triangle. AOA uses angles of arrival to antennas to geometrically assess where a MS is located by intersecting lines drawn from the antennas with detected angles. MPT is disclosed herein as using combinations of AOA and TDOA to determine a location. Exclusively using all AOA or exclusively using all TDOA is not necessary. MPT can be a direct method for locating MSs.","Yet another advantage is to locate MSs using Assisted Direct Location Technology (ADLT). ADLT is disclosed herein as using direct (conventional) location capability together with indirect location capability to confidently determine the location of a MS.","Still another advantage is to permit manual specification for identifying the location of a MS (a DLM). The manual location can then in turn be used to facilitate locating other MSs. A user interface may be used for specification of a DLM location. The user interface can be local, or remote, to the DLM. Various manual specification methods are disclosed. Manual specification is preferably used with less mobile MSs, or existing MSs such as those that use dodgeball.com (trademark of Google). The confidence value depends on how the location is specified, whether or not it was validated, and how it changes when the MS moves after being manually set. Manual specification should have limited scope in an LN-expanse unless inaccuracies can be avoided.","Another advantage herein is locating a MS using any of the methodologies above, any combinations of the methodologies above, and any combinations of direct and\/or indirect location methods described.","Another advantage is providing synergy between different locating technologies for smooth operations as an MS travels. There are large numbers of methods and combinations of those methods for keeping an MS informed of its whereabouts. Keeping an MS informed of its whereabouts in a timely manner is critical in ensuring LBX operate optimally, and for ensuring nearby MSs without certain locating technologies can in turn be located.","It is another advantage for locating an MS with multiple location technologies during its travels, and in using the best of breed data from multiple location technologies to infer a MS location confidently. Confidence values are associated with reference location information to ensure an MS using the location information can assess accuracy. A DLM is usually an \u201caffirmifier\u201d. An affirmifier is an MS with its whereabouts information having high confidence of accuracy and can serve as a reference for other MSs. An ILM can also be an affirmifier provided there is high confidence that the ILM location is known. An MS (e.g. ILM) may be a \u201cpacifier\u201d. A pacifier is an MS having location information for its whereabouts with a low confidence for accuracy. While it can serve as a reference to other ILMs, it can only do so by contributing a low confidence of accuracy.","It is another advantage for providing user customization of confidence values based on the user's experience. A MS user may completely rely on the MS system settings for setting confidence values, or may \u201ctweak\u201d location technology confidence values to accommodate experiences with particular location technologies that have been encountered during travels.","It is an advantage to synergistically make use of the large number of locating technologies available to prevent one particular type of technology to dominate others while using the best features of each to assess accurate mobile locations of MSs.","A further advantage is to leverage a data processing system with capability of being located for co-locating another data processing system without any capability of being located. For example, a driver owns an older model automobile, has a useful second data processing system in the automobile without means for being automatically located. The driver also own a cell phone, called a first data processing system, which does have means for being automatically located. The location of the first data processing system can be shared with the second data processing system for locating the second data processing system. Further still, the second data processing system without means for being automatically located is located relative a first set (plurality) of data processing systems which are not at the same location as the second data processing system. So, data processing systems are automatically located relative at least one other data processing which can be automatically located.","Another advantage is a LBX enabled MS includes a service informant component for keeping a supervisory service informed. This prevents an MS from operating in total isolation, and prevents an MS from operating in isolation with those MSs that are within its vicinity (e.g. within maximum range ) at some point in time, but to also participate when the same MSs are great distances from each other. There are LBX which would fit well into an LBS model, but a preferred embodiment chooses to use the LBX model. For example, multiple MS users are seeking to carpool to and from a common destination. The service informant component can perform timely updates to a supervisory service for route comparisons between MSs, even though periods of information are maintained only at the MSs. For example, users find out that they go to the same church with similar schedules, or coworkers find out they live nearby and have identical work schedules. The service informant component can keep a service informed of MS whereabouts to facilitate novel LBX applications. The service informant can also be configured for: communicating directly to another MS, communicating to a data processing system through a propagate-able service, invoking a \u201cplug-in\u201d home grown interface, alerting the MS user with a specified alert, or invoking an atomic command used by charter processing.","It is a further advantage in leveraging the vast amount of MS WiFi\/WiMax deployment underway in the United States. More widespread WiFi\/WiMax availability enhances the ability for well performing peer to peer types of features and functionality disclosed.","It is a further advantage to prevent unnecessary established connections from interfering with successfully triangulating a MS position. As the MS roams and encounters various wave spectrum signals, that is all that is required for determining the MS location. Broadcast signaling contains the necessary location information for automatically locating the MS.","Yet another advantage is to leverage Network Time Protocol (NTP) for eliminating bidirectional communications in determining Time of Arrival (TOA) and TDOA (Time Difference Of Arrival) measurements (TDOA as used in the disclosure generally refers to both TOA and TDOA). NTP enables a single unidirectional transmission of data to carry all that is necessary in determining TDOA, provided the sending data processing system and the receiving data processing system are NTP synchronized to an adequate granulation of time.","A further advantage is for making available to remote peer MSs certain MS operating system resources such as memory, storage, semaphores, application data, or the like, according to permissions. A single MS can access and use operating system resources of another MS, for example in charter processing. Also, semaphore controlled synchronization of processing can be achieved over a network, or plurality, of peer MSs without a common server to synchronize the processing.","It is an advantage of this disclosure to provide a competing superior alternative to server based mobile technologies such as that of U.S. Pat. Nos. 6,456,234; 6,731,238; 7,187,997; and U.S. PTO Publication 2006\/0022048 (Johnson). It is also an advantage to leverage both LBX technology and LBS technology in the same MS in order to improve the user experience. The different technologies can be used to complement each other in certain embodiments.","A further advantage herein is to leverage existing \u201cusual communications\u201d data transmissions for carrying new data that is ignored by existing MS processing, but observed by new MS processing, for carrying out processing maximizing location functions and features across a large geography. Alternatively, new data can be transmitted between systems for the same functionality.","It is an advantage herein in providing peer to peer service propagation. ILMs are provided with the ability to participate in the same Location Based Services (LBS) or other services as DLM(s) in the vicinity. An MS may have access to services which are unavailable to other MSs. Any MS can share its accessible services for being accessible to any other MS, preferably in accordance with permissions. For example, an MS without internet access can get internet access via an MS in the vicinity with internet access. In a preferred embodiment, permissions are maintained in a peer to peer manner prior to lookup for proper service sharing. In another embodiment, permissions are specified and used at the time of granting access to the shared services. Once granted for sharing, services can be used in a mode as if the sharing user is using the services, or in a mode as if the user accepting the share is a new user to the service. Routing paths are dynamically reconfigured and transparently used as MSs travel. Hop counts dynamically change to strive for a minimal number of hops for an MS getting access to a desirable service. Route communications depend on where the MS needing the service is located relative a minimal number of hops through other MSs to get to the service. Services can be propagated from DLMs to DLMs, DLMs to ILMs, ILMs to DLMs, or ILMs to ILMs.","Services otherwise unavailable to a first MS (or MS user) in the LN-Expanse become available through another MS which does have access to the service. A plurality of MSs may facilitate the connection (e.g. hops) from the first MS to the last MS which publishes the service and has access to the service. MSs can access needed services through MSs in the vicinity when necessary. A service directory is shared and propagated between MSs so that the superset of services in a LN-Expanse are made available to any one MS in the LN-Expanse regardless of current MS conditions, whereabouts, capability, or an inability to connect to a desired service. A service route is minimized for best performance even with highly mobile MSs by minimizing a number of hops between MSs to reach a service.","It is another advantage herein for providing peer to peer permissions, authentication, and access control. A service is not necessary for maintaining credentials and permissions between MSs. Permissions are maintained locally to a MS. In a centralized services model, a database can become massive in size when searching for needed permissions. Permission searching and validation of U.S. PTO Publication 2006\/0022048 (Johnson) was costly in terms of database size and performance. There was overhead in maintaining who owned the permission configuration for every permission granted. Maintaining permissions locally, as described below, reduces the amount of data to represent the permission because the owner is understood to be the personal user of the MS. Additionally, permission searching is very fast because the MS only has to search its local data for permissions that apply to only its MS.","Yet another advantage is to provide a nearby, or nearness, status using a peer to peer system and method, rather than intelligence maintained in a centralized database for all participating MSs. There is lots of overhead in maintaining a large database containing locations of all known MSs. This disclosure removes such overhead through using nearby detection means of one MS when in the vicinity of another MS. There are varieties of controls for governing how to generate the nearby status. In one aspect, a MS automatically calls the nearby MS thereby automatically connecting the parties to a conversation without user interaction to initiate the call. In another aspect, locally maintained configurations govern functionality when MSs are newly nearby, or are newly departing being nearby. Nearby status, alerts, and queries are achieved in a LBX manner.","It is yet another advantage for automatic call forwarding, call handling, and call processing based on the whereabouts of a MS, or whereabouts of a MS relative other MSs. The nearness condition of one MS to another MS can also affect the automatic call forwarding functionality.","Yet another advantage herein is for peer to peer content delivery and local MS configuration of that content. Users need no connectivity to a service. Users make local configurations to enjoy location based content delivery to other MSs. Content is delivered under a variety of circumstances for a variety of configurable reasons. Content maintained local to an MS is delivered asynchronously to other MSs for nearby alerts, arrival or departure to and from geofenced areas, and other predicated conditions of nearby MSs. While it may appear there are LBS made available to users of MSs, there are in fact LBX being made available to those users.","Another advantage herein is a LBX enabled MS can operate in a peer to peer manner to data processing systems which control environmental conditions. For example, automobile equipped (or driver kept) MSs encounter an intersection having a traffic light. Interactions between the MSs at the intersection and a data processing system in the vicinity for controlling the traffic light can automatically override light color changing for optimal traffic flow. In another embodiment, a parking lot search by a user with an MS is facilitated as he enters the parking lot, and in accordance with parking spaces currently occupied. In general, other nearby data processing systems can have their control logic processed for a user's preferences (as defined in the MS), a group of nearby user's preferences, and\/or situational locations (see U.S. Pat. Nos. 6,456,234; 6,731,238; 7,187,997 (Johnson) for \u201csituational location\u201d terminology) of nearby MSs.","Another advantage herein is an MS maintains history of hotspot locations detected for providing graphical indication of hotspot whereabouts. This information can be used by the MS user in guiding where a user should travel in the future for access to services at the hotspot. Hotspot growth prevents a database in being timely configured with new locations. The MS can learn where hotspots are located, as relevant to the particular MS. The hotspot information is instantly available to the MS.","A further advantage is for peer to peer proximity detection for identifying a peer service target within the MS vicinity. A peer service target can be acted upon by an MS within range, using an application at the MS. The complementary whereabouts of the peer service target and MS automatically notify the user of service availability. The user can then use the MS application for making a payment, or for performing an account transfer, account deposit, account deduction, or any other transaction associated with the peer service target.","Yet another advantage is for a MS to provide new self management capability such as automatically marking photographs taken with location information, a date\/time stamp, and who was with the person taking the picture.","Yet another advantage is being alerted to nearby people needing assistance and nearby fire engines or police cars that need access to roads.","A further advantage is providing a MS platform for which new LBX features and functionality can be brought quickly to the marketplace. The platform caters to a full spectrum of users including highly technical software developers, novice users, and users between those ranges. A rich programming environment is provided wherein whereabouts (WDR) information interchanged with other MSs in the vicinity causes triggering of privileged actions configured by users. The programming environment can be embedded in, or \u201cplugged into\u201d, an existing software development environment, or provided on its own. A syntax may be specified with source code statements, XML, SQL database definitions, a datastream, or any other derivative of a well defined BNF grammar. A user friendly configuration environment is provided wherein whereabouts information interchanged with other MSs in the vicinity causes triggering of privileged actions configured by users. The platform is an event based environment wherein WDRs containing certain configured sought information are recognized at strategic processing paths for causing novel processing of actions. Events can be defined with complex expressions, and actions can be defined using homegrown executables, APIs, scripts, applications, a set of commands provided with the LBX platform, or any other executable processing. The LBX platform includes a variety of embodiments for charter and permission definitions including an internalized programmatic form, a SQL database form, a data record form, a datastream form, and a well defined BNF grammar for deriving other useful implementations (e.g. lex and yacc).","It is an advantage for permissions and\/or charters to be configured in anticipation of every possible future travel, situation, environment, application, or condition of a MS (or MS user), or a plurality of related (by permissions and charters) MSs (or MS users). It is powerful in how permissions and charters configured in advance of anticipated events reveal novel unpredictably timed automated actions and application behavior for novel uses.","It is another advantage to support a countless number of privileges that can be configured, managed, and processed in a peer to peer manner between MSs. Any peer to peer feature or set of functionality can have a privilege associated to it for being granted from one user to another. It is also an advantage for providing a variety of embodiments for how to manage and maintain privileges in a network of MSs.","It is another advantage to support a complete set of options for charters that can be configured, managed, and processed in a peer to peer manner between MSs. Charters can become effective under a comprehensive set of conditions, expressions, terms, and operators. It is also an advantage for providing a variety of embodiments for how to manage and maintain charters in a network of MSs. Charters themselves can be self modifying for changing permissions or charters \u201con the fly\u201d (i.e. during charter processing).","It is a further advantage for providing multithreaded communications of permission and charter information and transactions between MSs for well performing peer to peer interactions. Any signal spectrum for carrying out transmission and reception is candidate, depending on the variety of MS. In fact, different signaling wave spectrums, types, and protocols may be used in interoperating communications, or even for a single transaction, between MSs.","It is yet another advantage for increasing the range of the LN-expanse from a wireless vicinity to potentially infinite vicinity through other data processing (e.g. routing) equipment. While wireless proximity is used for governing automatic location determination, whereabouts information may be communicated between MSs great distances from each other provided there are privileges and\/or charters in place making such whereabouts information relevant for the MS. Whereabouts information of others will not be maintained unless there are privileges in place to maintain it. Whereabouts information may not be shared with others if there have been no privileges granted to a potential receiving MS. Privileges can provide relevance to what whereabouts (WDR) information is of use, or should be processed, maintained, or acted upon.","Another advantage is to provide a MS which can be user configured for any desired behavior based on location, whereabouts, and \u201cin the vicinity\u201d conditions for the MS and\/or its peer MSs during travels. A user has infinite control over providing a processing \u201ccharacter\u201d for the MS. Also, various MS applications are generically supported with integrated locational based features and functionality. Charters may be used to automatically perform: MS configuration and system variable setting, clip-board and paste operations, MS input and output control, automatic communications with other MSs or data processing systems, enabling\/disabling a feature or service, and many other features.","Another advantage is for using a convenient user interface such as map navigation for generating a map term such as a point, point and radius, or set of points defining area(s) on a map which is conveniently referenced in a charter configuration and later processed for replacement. For example, a user makes selection(s) on a map, and location information is automatically generated for the selection(s). The user can assign a convenient name to the location information without knowing details of the location information itself. The user can then reference the name for completely specifying the associated location information details. Also, the user may use WDR search criteria for determining a map term, the WDR found being one originated from the MS of map term creation or that of a peer MS. Recent whereabouts of a WDR found (e.g. from queue ), or past whereabouts of a WDR found (e.g. history ) may be used. Queue  may be viewed as maintaining a short term history, while history  may be viewed as maintaining a longer term history. Specifying locations in charter configurations can be tedious. Map terms provide the user with a simple user interface method to specify locations, and for hiding complexities of how the location was determined and generated for charter use. In some embodiments, map terms are used in broader scope by permitting any substitution where referenced. In some embodiments, map terms are used in broader scope by permitting \u201cspecial terms\u201d to be automatically created by a user by simply selecting a MS on a map.","It is an advantage for a convenient \u201ccharters starters\u201d user interface for browsing, enabling, disabling, and maintaining charters depending on application, categories, or useable\/clone-able snippets of the charters. For example, a MS may come prepackaged with many charters which have been organized and marked for particular applications and categories. The user can search, find, manage and enable\/disable a set of charters based on their application or category, and can clone charter subsets for creating new charters. A MS user may manage his own charters, or charters of privilege granting others, using the charters starters interfaces. The user is also able to search, find, manage and enable\/disable a set of charters based on any criteria found in the charter definitions themselves. A knowledgeable or authorized user may organize charters as he sees fit, for example to assign charters to categories and applications. The charter starters user interface organizes charters in easily identifiable groups (e.g. folders, categories, applications, etc) and provides simplicity for enabling, disabling and organizing any desired sets of complex charter configurations.","It is an advantage in providing application term triggered processing to the LBX platform described, and for all users and skill sets thereof. A rich programming environment and user friendly configuration environment is provided wherein application data which becomes modified causes triggering of privileged actions configured by users. The programming environment can be embedded in, or \u201cplugged into\u201d, an existing software development environment, or provided on its own. A syntax may be specified with source code statements, XML, SQL database definitions, a datastream, or any other derivative of the disclosed BNF grammar. The platform is an event based environment wherein events of modifying application data containing configured sought values\/information are recognized for triggering processing of actions. Events can be defined with complex expressions, and actions can be defined using homegrown executables, APIs, scripts, applications, a set of commands provided with the LBX platform, or any other executable processing. The LBX platform includes a variety of embodiments as described.","Another advantage is providing a comprehensive palette of paste commands for pasting LBX data into data entry fields, snapshot images, or one or more video stream frames. Data can be accessed and used for pasting from: queue ; history ; statistics ; service directory ; atomic terms; map terms; WDRTerm data; AppTerm data; any term or construct of the LBX BNF grammar; data describing current, past or future LBX data; averages of MS or LBX data; data derived from MSs in the vicinity (e.g. nearby); and data sensed, received, sent, processed, analyzed, or predicted at the MS. Data being pasted may be converted prior to the paste as a user requests. The user may adjust the paste data appearance (font, size, color, or any other appearance characteristic) prior to finalizing the paste action.","Yet another advantage is providing \u201cplug-in\u201d application support so that an application can be integrated conveniently into the LBX architecture and framework through Prefix Registry Records 5300. Application data and executable interfaces are \u201cplugged in\u201d. Application data is made accessible to charter processing for conditional and configurable event based charter processing. Various \u201cplug-in\u201d systems and methods are described. The LBX platform is designed to integrate well with MS applications of all varieties for a cohesive architecture.","Another advantage is for tightly coupling\/integrating LBX processing configuration and processing into a programming environment for a WPL in context of a rich PPL. LBX processing can be a \u201cplug-in\u201d to PPLs, or may be integrated into the PPL syntax for a rich WPL. There are a variety of systems and methods described for a comprehensive LBX platform.","It is an advantage for facilitating the creation of charters that make sense in context of a particular MS application by automating suggestions. Special terms and atomic operands are determined for an application context, and candidate charters and\/or portions thereof are presented for use to the user based on being derived from the special terms and atomic operands determined for the application context. A user's effort in creating charters for a particular application context is minimized with ready-made charters or charter portions that are automatically determined to be relevant for the particular application context. Upon being presented with suggestions, the user can select, or select and \u201ctweak\u201d to a desired charter configuration. The user can also configure privileges that are in context of the application or the charters selected.","It is an advantage for automatically comparing MS data profile information for matches for triggering conditional actions of charters. Users can configure data which is beaconed to other MSs and then compared for matches for automated charter processing. MSs are automated with social interaction to other MSs so that MS users are alerted of MS users of interest in the vicinity for a variety of applications.","It is an advantage for transmitting application data fields to peer MSs in the vicinity, receiving application data fields from peer MSs in the vicinity, transmitting application data fields to data processing systems in the vicinity in a peer to peer manner, and receiving application data fields from data processing systems in the vicinity in a peer to peer manner for interoperability of a diverse set of applications and automated triggered processing thereof, while not using an application server to middle-man the data (e.g. MSs communicate with each other directly and wirelessly as peers). Application data fields shared between peer data processing systems (e.g. MSs) are preferably additionally available at a MS as AppTerm data (see below). A user has control for disabling or enabling which application data fields are shared. Privileges configured between MSs enforce desired effects for processing the data on MSs which send or receive the data.","A further advantage is to provide MSs with a wealth of location based enhanced applications without requiring a service. It is also an advantage to not require a service for geo-fence alerts, proactive content delivery, and nearby alerts, for example as described by server based U.S. patent pending Ser. No. 11\/207,080 (\u201cSystem and Method for Anonymous Location Based Services\u201d, Johnson). Herein, alert processing, geo-fences and content is maintained at a MS for a) being processed at the MS when interacting directly with peer MSs; and b) being shared with peer MSs for being processed at peer MSs. Better performance of processing content delivery and providing alerts is achieved because it occurs at the MSs without any interoperability to some \u201cmiddleman\u201d service.","Another advantage is in leveraging the multi-threaded and wireless multi-wave, multi-frequency and multi-channel capability of the disclosed MS for RFID and RDS integration. RFID and RDS interfaces fit nicely in the LBX framework as described below.","A further advantage is for the MS to automatically, or upon user request, analyze a picture, or video stream frame, for the purpose of more confidently determining a MS location. User configurations are used to drive desired processing.","Another advantage is for thoroughly maintaining and managing statistics and history information at a MS. Many options are supported for how, where, and when to save such information.","A further advantage is to provide Sudden Proximal User Interfaces (SPUIs) at a MS when detecting other data processing systems in the vicinity (e.g. another MS, a RFID device, a data processing system emulating a MS, or any other data processing system). A SPUI is a GUI for notifying a MS user that a remote data processing system of interest is in the vicinity, based on configured \u201cin the vicinity\u201d conditions. Presenting the SPUI at the MS can be triggered by charter configurations, application term (AppTerm) trigger configurations, or RFID trigger configurations. There are many applications for SPUI processing for saving MS users time from MS user interface interactions for common tasks, for example appliance and device interfaces. Authentication can be automated. Also, SPUIs save data from previous executions for defaulting data in a subsequent execution thereby preventing the burdening of a MS user from re-entering data to the MS that was already entered once previously. There are many applications that fit within the SPUI framework, some of which are described below.","Another advantage is for providing a user with the ability to manually request to send\/transmit outbound data with options for customizing, such as: a WDR, a derivative of a WDR, a subset of a WDR, a user configured set of data, or any customized set of data. If a WDR or derivative\/subset thereof is to be sent, the WDR may first be searched for at the MS with user specified search criteria and\/or transmitted outbound according to user specified transmission criteria.","It is an advantage to provide a task monitor\/trace interface for examining MS task status for current and past system states. The task monitor interface permits convenient contextual charter creation as desired by the user based on task status findings.","It is an advantage for providing generic application record sorting based on: MS whereabouts, whereabouts of a particular MS, whereabouts of others in the vicinity, or other WDR search criteria for sorting WDRs maintained at the MS where the sort is requested.","Another advantage is for providing one or more vicinity monitors for indicating MSs of interest that are nearby. The multi-threaded MS supports a plurality of vicinity monitors. A MS user configures criteria\/conditions (i.e. expression) for a vicinity monitor for being compared to WDR information as it is received at the MS. The expression result (True\/False) determines whether or not the MS that originated the WDR is to be monitored within the particular vicinity monitor. A polling or asynchronous event (e.g. as WDRs received) design may be used.","Another advantage is for automatic inventory management processing for inventory items that are in the vicinity of a MS at some point in time. A MS user can move to the whereabouts of particular items he desires to keep an inventory of for automatically managing the inventory by counting the current stock, performing orders for stocking, and tracking an order. The MS user can configure payment information for automatic order processing. Inventory items are enabled for inventory management in having an associated data processing system (e.g. (RFID tag, affixed\/integrated MS, etc). A MS user can manually perform an order using the automatically determined inventory count information, or the order can be scheduled for automatic ordering (e.g. using a calendar entry). Inventory items can be ordered individually or as a group, perhaps as part of a group hierarchy. Typical uses are for managing the life of a typical MS user: products stocked in kitchen pantry, refrigerator, freezer, closet, office, bathrooms, laundry room, office supply closet, or other areas of a MS user's home, office or place of work.","Another advantage is for providing a MS user with a convenient resource mapping of privileges and charters between identities. For example, it could be tedious figuring out all the privileges, grants and charters which are granted to one MS user, and then granting those same rights to another MS user. Such a task is error prone and time consuming. Resource mapper functionality is provided wherein all rights (e.g. privileges) of one identifier can be assigned to another identifier in a single operation. The same rights can subsequently be removed as a single operation. A MS user has the ability to model granting privileges and charters to an identity (e.g. group), and then assign all of those, or remove all of those, in a single operation to other identifiers.","A further advantage is for different applications to be correlated through cross application addressing so that features or contexts of one application can be used to automatically affect features or contexts of another application. Identifiers used in context of one application are correlated to another application form. For example, an email application recipient address is correlated to the phone application caller id for the same MS in order to instantly (upon user request) show all emails associated to a person on an active phone call. The correlation occurs transparently without needing to know addressing details. There can be many identifier forms for correlation for a single MS depending on an application in use.","Further features and advantages of the disclosure, as well as the structure and operation of various embodiments of the disclosure, are described in detail below with reference to the accompanying drawings. In the drawings, like reference numbers generally indicate identical, functionally similar, and\/or structurally similar elements. The drawing in which an element first appears is indicated by the leftmost digit(s) in the corresponding reference number, except that reference numbers  through  may be found on the first 4 drawings of , and . Dashed outlines (e.g. process blocks, data record fields) may be used in the drawings to highlight, or indicate optional embodiments, for example depending on MS performance considerations. None of the drawings, discussions, or materials herein is to be interpreted as limiting to a particular embodiment. The broadest interpretation is intended. Other embodiments accomplishing same functionality are within the spirit and scope of this disclosure. It should be understood that information is presented by example and many embodiments exist without departing from the spirit and scope of this disclosure.","With reference now to detail of the drawings, the present disclosure is described. Obvious error handling is omitted from the flowcharts in order to focus on the key aspects of the present disclosure. Obvious error handling includes database I\/O errors, field validation errors, errors as the result of database table\/data constraints or unique keys, data access errors, communications interface errors or packet collision, hardware failures, checksum validations, bit error detections\/corrections, and any other error handling as well known to those skilled in the relevant art in context of this disclosure. A semicolon may be used in flowchart blocks to represent, and separate, multiple blocks of processing within a single physical block. This allows simpler flowcharts with less blocks in the drawings by placing multiple blocks of processing description in a single physical block of the flowchart. Flowchart processing is intended to be interpreted in the broadest sense by example, and not for limiting methods of accomplishing the same functionality. Preferably, field validation in the flowcharts checks for SQL injection attacks, communications protocol sniff and hack attacks, preventing of spoofing MS addresses, syntactical appropriateness, and semantics errors where appropriate. Disclosed user interface processing and\/or screenshots are also preferred embodiment examples that can be implemented in other ways without departing from the spirit and scope of this disclosure. Alternative user interfaces (since this disclosure is not to be limiting) will use similar mechanisms, but may use different mechanisms without departing from the spirit and scope of this disclosure.","Locational terms such as whereabouts, location, position, area, destination, perimeter, radius, geofence, situational location, or any other related two or three dimensional locational term used herein to described position(s) and\/or locations and\/or whereabouts is to be interpreted in the broadest sense. Location field may include an area (e.g. on earth), a point (e.g. on earth), or a three dimensional bounds in space. In another example, a radius may define a sphere in space, rather than a circle in a plane. In some embodiments, a planet field forms part of the location (e.g. Earth, Mars, etc as part of field ) for which other location information (e.g. latitude and longitude on Mars also part of field ) is relative. In some embodiments, elevations (or altitudes) from known locatable point(s), distances from origin(s) in the universe, etc. can denote where exactly is a point of three dimensional space, or three dimensional sphere, area, or solid, is located. That same point can provide a mathematical reference to other points of the solid area\/region in space. Descriptions for angles, pitches, rotations, etc from some reference point(s) may be further provided. Three dimensional areas\/regions include a conical shape, cubical shape, spherical shape, pyramidal shape, irregular shapes, or any other shape either manipulated with a three dimensional graphic interface, or with mathematical model descriptions. Areas\/regions in space can be occupied by a MS, passed through (e.g. by a traveler) by a MS, or referenced through configuration by a MS. In a three dimensional embodiment, nearby\/nearness is determined in terms of three dimensional information, for example, a spherical radius around one MS intersecting a spherical radius around another MS. In a two dimensional embodiment, nearby\/nearness is determined in terms of two dimensional information, for example, a circular radius around one MS intersecting a circular radius around another MS. Points can be specified as a point in a x-y-z plane, a point in polar coordinates, or the like, perhaps the center of a planet (e.g. Earth) or the Sun, some origin in the Universe, or any other origin for distinctly locating three dimensional location(s), positions, or whereabouts in space. Elevation (e.g. for earth, or some other planet, etc) may be useful to the three dimensional point of origin, and\/or for the three dimensional region in space. A region in space may also be specified with connecting x-y-z coordinates together to bound the three dimensional region in space. There are many methods for representing a location (field ) without departing from the spirit and scope of this disclosure. MSs, for example as carried by users, can travel by airplane through three dimensional areas\/regions in space, or travel under the sea through three dimensional regions in space.","Various embodiments of communications between MSs, or an MS and service(s), will share channels (e.g. frequencies) to communicate, depending on when in effect. Sharing a channel will involve carrying recognizable and processable signature to distinguish transmissions for carrying data. Other embodiments of communications between MSs, or an MS and service(s), will use distinct channels to communicate, depending on when in effect. The number of channels that can be concurrently listened on and\/or concurrently transmitted on by a data processing system will affect which embodiments are preferred. The number of usable channels will also affect which embodiments are preferred. This disclosure avoids unnecessary detail in different communication channel embodiments so as to not obfuscate novel material. Independent of various channel embodiments within the scope and spirit of the present disclosure, MSs communicate with other MSs in a peer to peer manner, in some aspects like automated walkie-talkies.","Novel features disclosed herein need not be provided as all or none. Certain features may be isolated in some MS embodiments, or may appear as any subset of features and functionality in other embodiments.",{"@attributes":{"id":"p-0299","num":"0312"},"figref":"FIG. 1A","b":["2","4","32","4","2","32","32","34","36","38","32","4","32","34","36","38","32","4","6","30"]},"LBX character  preferably includes at least Peer Interaction Processing (PIP) code , Peer Interaction Processing (PIP) data , self management processing code , self management processing data , WDR queue , send queue , receive queue , service informant code , and LBX history . Peer interaction processing (PIP) code  comprises executable code in software, firmware, or hardware form for carrying out LBX processing logic of the present disclosure when interacting with another MS. Peer interaction processing (PIP) data  comprises data maintained in any sort of memory of MS , for example hardware memory, flash memory, hard disk memory, a removable memory device, or any other memory means accessible to MS . PIP data  contains intelligence data for driving LBX processing logic of the present disclosure when interacting with other MSs. Self management processing code  comprises executable code in software, firmware, or hardware form for carrying out the local user interface LBX processing logic of the present disclosure. Self management processing data  contains intelligence data for driving processing logic of the present disclosure as disclosed for locally maintained LBX features. WDR queue  contains Whereabouts Data Records (WDRs) , and is a First-In-First-Out (FIFO) queue when considering housekeeping for pruning the queue to a reasonable trailing history of inserted entries (i.e. remove stale entries). WDR queue  is preferably designed with the ability of queue entry retrieval processing similar to Standard Query Language (SQL) querying, wherein one or more entries can be retrieved by querying with a conditional match on any data field(s) of WDR  and returning lists of entries in order by an ascending or descending key on one or any ascending\/descending ordered list of key fields.","All disclosed queues (e.g. , , , ,  (See ), or any other queue) are implemented with an appropriate thread-safe means of queue entry peeking (makes copy of sought queue entry without removing), discarding, retrieval, insertion, and queue entry field sorted search processing. Queues are understood to have an associated implicit semaphore to ensure appropriate synchronous access to queue data in a multi-threaded environment to prevent data corruption and misuse. Such queue interfaces are well known in popular operating systems. In MS operating system environments which do not have an implicit semaphore protected queue scheme, queue accesses in the present disclosure flowcharts are to be understood to have a previous request to a queue-assigned semaphore lock prior to queue access, and a following release of the semaphore lock after queue access. Operating systems without semaphore control may use methods to achieve similar thread-safe synchronization functionality. Queue functionality may be accomplished with lists, arrays, databases (e.g. SQL) and other methodologies without departing from the spirit and scope of queue descriptions herein.","Queue  alternate embodiments may maintain a plurality of WDR queues which segregate WDRs  by field(s) values to facilitate timely processing. WDR queue  may be at least two (2) separate queues: one for maintaining the MS  whereabouts, and one for maintaining whereabouts of other MSs. WDR queue  may be a single instance WDR  in some embodiments which always contains the most current MS  whereabouts for use by MS  applications (may use a sister queue  for maintaining WDRs from remote MSs). At least one entry is to be maintained to WDR queue  at all times for MS  whereabouts.","Send queue  (Transmit (Tx) queue) is used to send communications data, for example as intended for a peer MS within the vicinity (e.g. nearby as indicated by maximum range ) of the MS . Receive queue  (Receive (Rx) queue) is used to receive communications data, for example from peer MSs within the vicinity (e.g. nearby as indicated by maximum range ) of the MS . Queues  and  may also each comprise a plurality of queues for segregating data thereon to facilitate performance in interfacing to the queues, in particular when different queue entry types and\/or sizes are placed on the queue. A queue interface for sending\/receiving data to\/from the MS is optimal in a multi-threaded implementation to isolate communications transport layers to processing behind the send\/receive queue interfaces, but alternate embodiments may send\/receive data directly from a processing thread disclosed herein. Queues , , and\/or  may be embodied as a purely data form, or SQL database, maintained at MS  in persistent storage, memory, or any other storage means. In some embodiments, queues  and  are not necessary since other character  will already have accessible resources for carrying out some LBX character  processing.","Queue embodiments may contain fixed length records, varying length records, pointers to fixed length records, or pointers to varying length records. If pointers are used, it is assumed that pointers may be dynamically allocated for record storage on insertions and freed upon record use after discards or retrievals.","As well known to those skilled in the art, when a thread sends on a queue  in anticipation of a corresponding response, there is correlation data in the data sent which is sought in a response received by a thread at queue  so the sent data is correlated with the received data. In a preferred embodiment, correlation is built using a round-robin generated sequence number placed in data for sending along with a unique MS identifier (MS ID). If data is not already encrypted in communications, the correlation can be encrypted. While the unique MS identifier (MS ID) may help the MS identify which (e.g. wireless) data is destined for it, correlation helps identify which data at the MS caused the response. Upon receipt of data from a responder at queue , correlation processing uses the returned correlation (e.g. field ) to correlate the sent and received data. In preferred embodiments, the sequence number is incremented each time prior to use to ensure a unique number, otherwise it may be difficult to know which data received is a response to which data was sent, in particular when many data packets are sent within seconds. When the sequence number reaches a maximum value (e.g. 2**32\u22121), then it is round-robinned to 0 and is incremented from there all over again. This assures proper correlation of data between the MS and responders over time. There are other correlation schemes (e.g. signatures, random number generation, checksum counting, bit patterns, date\/time stamp derivatives) to accomplish correlation functionality. If send and receive queues of Other Character  are used, then correlation can be used in a similar manner to correlate a response with a request (i.e. a send with a receipt).","There may be good reason to conceal the MS ID when transmitting it wirelessly. In this embodiment, the MS ID is a dependable and recognizable derivative (e.g. a pseudo MS ID) that can be detected in communications traffic by the MS having the pseudo MS ID, while concealing the true MS ID. This would conceal the true MS ID from would-be hackers sniffing wireless protocol. The derivative can always be reliably the same for simplicity of being recognized by the MS while being difficult to associate to a particular MS. Further still, a more protected MS ID (from would-be hackers that take time to deduce how an MS ID is scrambled) can itself be a dynamically changing correlation anticipated in forthcoming communications traffic, thereby concealing the real MS ID (e.g. phone number or serial number), in particular when anticipating traffic in a response, yet still useful for directing responses back to the originating MS (with the pseudo MS ID (e.g. correlation)). A MS would know which correlation is anticipated in a response by saving it to local storage for use until it becomes used (i.e. correlated in a matching response), or becomes stale. In another embodiment, a correlation response queue (like CR queue ) can be deployed to correlate responses with requests that contain different correlations for pseudo MS IDs. In all embodiments, the MS ID (or pseudo MS ID) of the present disclosure should enable targeting communications traffic to the MS.","Service informant code  comprises executable code in software, firmware, or hardware form for carrying out of informing a supervisory service. The present disclosure does not require a connected web service, but there are features for keeping a service informed with activities of MS LBX. Service informant code  can communicate as requested any data , , , , , , , , or any other data processed at MS .","LBX history  contains historical data useful in maintaining at MS , and possibly useful for informing a supervisory service through service informant code . LBX History  preferably has an associated thread of processing for keeping it pruned to the satisfaction of a user of MS  (e.g. prefers to keep last 15 days of specified history data, and 30 days of another specified history data, etc). With a suitable user interface to MS , a user may browse, manage, alter, delete, or add to LBX History  as is relevant to processing described herein. Service informant code  may be used to cause sending of an outbound email, SMS message, outbound data packet, or any other outbound communication in accordance with LBX of the MS.","PIP data  preferably includes at least permissions , charters , statistics , and a service directory . Permissions  are configured to grant permissions to other MS users for interacting the way the user of MS  desires for them to interact. Therefore, permissions  contain permissions granted from the MS  user to other MS users. In another embodiment, permissions  additionally, or alternatively, contain permissions granted from other MS users to the MS  user. Permissions are maintained completely local to the MS . Charters  provide LBX behavior conditional expressions for how MSs should interact with MS . Charters  are configured by the MS  user for other MS users. In another embodiment, charters  additionally, or alternatively, are configured by other MS users for the MS  user. Some charters expressions depend on permissions . Statistics  are maintained at MS  for reflecting peer (MS) to peer (MS) interactions of interest that occurred at MS . In another embodiment, statistics  additionally, or alternatively, reflect peer (MS) to peer (MS) interactions that occurred at other MSs, preferably depending on permissions . Service informant code  may, or may not, inform a service of statistics  maintained. Service directory  includes routing entries for how MS  will find a sought service, or how another MS can find a sought service through MS .","In some embodiments, any code (e.g. , , , , ) can access, manage, use, alter, or discard any data (e.g. , , , , , , , ) of any other component in MS . Other embodiments may choose to keep processing of LBX character  and other character  disjoint from each other. Rectangular component boundaries are logical component representations and do not have to delineate who has access to what. MS (also MSs) references discussed herein in context for the new and useful features and functionality disclosed is understood to be an MS  (MSs ).",{"@attributes":{"id":"p-0311","num":"0324"},"figref":["FIG. 1B","FIG. 1B"],"b":["2","40","1306","32","1304","1304"]},"Regardless of the embodiment, an MS  can communicate with any of its peers in the vicinity using methods described below. Regardless of the embodiment, a communication path  between any two MSs is understood to be potentially bidirectional, but certainly at least unidirectional. The bidirectional path  may use one communications method for one direction and a completely different communications method for the other, but ultimately each can communicate to each other. When considering that a path  comprises two unidirectional communications paths, there are N*(N\u22121) unidirectional paths for N MSs in a network . For example, 10 MSs results in 90 (i.e. 10*9) one way paths of communications between all 10 MSs for enabling them to talk to each other. Sharing of the same signaling channels is preferred to minimize the number of MS threads listening on distinct channels. Flowcharts are understood to process at incredibly high processing speeds, in particular for timely communications processing. While the MSs are communicating wirelessly to each other, path  embodiments may involve any number of intermediary systems or communications methods, for example as discussed below with .",{"@attributes":{"id":"p-0313","num":"0326"},"figref":"FIG. 1C","b":["44","1","1","1","1","46"]},{"@attributes":{"id":"p-0314","num":"0327"},"figref":"FIG. 1D","b":["2","50","50","52","54","54","54","50","54","50","50","56","56","50","58","60","62","54","50","60"]},"The data processing system  may also include a display device interface  for driving a connected display device (not shown). The data processing system  may further include one or more input peripheral interface(s)  to input devices such as a keyboard, keypad, Personal Digital Assistant (PDA) writing implements, touch interfaces, mouse, voice interface, or the like. User input (\u201cuser input\u201d, \u201cuser events\u201d and \u201cuser actions\u201d used interchangeably) to the data processing system are inputs accepted by the input peripheral interface(s) . The data processing system  may still further include one or more output peripheral interface(s)  to output devices such as a printer, facsimile device, or the like. Output peripherals may also be available via an appropriate interface.","Data processing system  will include communications interface(s)  for communicating to another data processing system  via analog signal waves, digital signal waves, infrared proximity, copper wire, optical fiber, or other wave spectrums described herein. A MS may have multiple communications interfaces  (e.g. cellular connectivity, 802.x, etc). Other data processing system  may be an MS. Other data processing system  may be a service. Other data processing system  is a service data processing system when MS  communicates to other data processing system  by way of service informant code . In any case, the MS and other data processing system are said to be interoperating when communicating.","Data processing system programs (also called control logic) may be completely inherent in the processor(s)  being a customized semiconductor, or may be stored in main memory  for execution by processor(s)  as the result of a read-only memory (ROM) load (not shown), or may be loaded from a secondary storage device into main memory  for execution by processor(s) . Such programs, when executed, enable the data processing system  to perform features of the present disclosure as discussed herein. Accordingly, such data processing system programs represent controllers of the data processing system.","In some embodiments, the disclosure is directed to a control logic program product comprising at least one processor  having control logic (software, firmware, hardware microcode) stored therein. The control logic, when executed by processor(s) , causes the processor(s)  to provide functions of the disclosure as described herein. In another embodiment, this disclosure is implemented primarily in hardware, for example, using a prefabricated component state machine (or multiple state machines) in a semiconductor element such as a processor .","Those skilled in the art will appreciate various modifications to the data processing system  without departing from the spirit and scope of this disclosure. A data processing system, and more particularly a MS, preferably has capability for many threads of simultaneous processing which provide control logic and\/or processing. These threads can be embodied as time sliced threads of processing on a single hardware processor, multiple processors, multi-core processors, Digital Signal Processors (DSPs), or the like, or combinations thereof. Such multi-threaded processing can concurrently serve large numbers of concurrent MS tasks. Concurrent processing may be provided with distinct hardware processing and\/or as appropriate software driven time-sliced thread processing. Those skilled in the art recognize that having multiple threads of execution on an MS is accomplished in many different ways without departing from the spirit and scope of this disclosure. This disclosure strives to deploy software to existing MS hardware configurations, but the disclosed software can be deployed as burned-in microcode to new hardware of MSs.","Data processing aspects of drawings\/flowcharts are preferably multi-threaded so that many MSs and applicable data processing systems are interfaced with in a timely and optimal manner. Data processing system  may also include its own clock mechanism (not shown), if not an interface to an atomic clock or other clock mechanism, to ensure an appropriately accurate measurement of time in order to appropriately carry out processing described below. In some embodiments, Network Time Protocol (NTP) is used to keep a consistent universal time for MSs and other data processing systems in communications with MSs. This is most advantageous to prevent unnecessary round-tripping of data between data processing systems to determine timing (e.g. Time Difference of Arrival (TDOA)) measurements. A NTP synchronized date\/time stamp maintained in communications is compared by a receiving data processing system for comparing with its own NTP date\/time stamp to measure TOA (time of arrival (i.e. time taken to arrive)). Of course, in the absence of NTP used by the sender and receiver, TOA is also calculated in a bidirectional transmission using correlation. In this disclosure, TOA measurements from one location technology are used for triangulating with TOA measurements from another location technology, not just for determining \u201chow close\u201d. Therefore, TDOA terminology is generally used herein to refer to the most basic TOA measurement of a wave spectrum signal being the difference between when it was sent and when it was received. TDOA is also used to describe using the difference of such measurements to locate (triangulate). NTP use among participating systems has the advantage of a single unidirectional broadcast data packet containing all a receiving system requires to measure TDOA, by knowing when the data was sent (date\/time stamp in packet) and when the data was received (signal detected and processed by receiving system). A NTP clock source (e.g. atomic clock) used in a network is to be reasonably granular to carry out measurements, and ensures participating MSs are updated timely according to anticipated time drifts of their own clocks. MS clocks should maintain time as accurately as possible to minimize drift and minimize how often resynchronization with a NTP clock source is required. There are many well known methods for accomplishing NTP, some which require dedicated thread(s) for NTP processing, and some which use certain data transmitted to and from a source to keep time in synch.","Those skilled in the art recognize that NTP accuracy depends on participating MS clocks and processing timing, as well as time server source(s). Radio wave connected NTP time server(s) is typically accurate to as granular as 1 millisecond. Global Positioning System (GPS) time servers provide accuracy as granular as 50 microseconds. GPS timing receivers provide accuracy to around 100 nanoseconds, but this may be reduced by timing latencies in time server operating systems. With advancements in hardware, microcode, and software, obvious improvements are being made to NTP. In NTP use embodiments of this disclosure, an appropriate synchronization of time is used for functional interoperability between MSs and other data processing systems using NTP. NTP is not required in this disclosure, but it is an advantage when in use.",{"@attributes":{"id":"p-0322","num":"0335"},"figref":"FIG. 1E","b":["102","104","102","106","108","108","106","108","106","110","110","112","112","114","112","114","112","114","114","116","118","110","120","122","124","120","124","110","126","128","130","170","132","132"],"i":["b","e","a ","d"]},"In another embodiment of the present disclosure, GPS satellites such as satellite , satellite , and satellite  provide information, as is well known in the art, to GPS devices on earth for triangulation locating of the GPS device. In this embodiment, a MS has integrated GPS functionality so that the MS monitors its positions. The MS is preferably known by a unique identifier, for example a phone number, caller id, device identifier, or like appropriate unique handle (e.g. network address).","In yet another embodiment of the present disclosure, a physically connected device, for example, telephone , computer , PDA , telephone , and fax machine , may be newly physically connected to a network. Each is a MS, although the mobility is limited. Physical connections include copper wire, optical fiber, USB, or any other physical connection, by any communications protocol thereon. Devices are preferably known by a unique identifier, for example a phone number, caller id, device identifier, physical or logical network address, or like appropriate unique handle. The MS is detected for being newly located when physically connected. A service can be communicated to upon detecting connectivity. The service may execute at an Automatic Response Unit (ARU) , a telephony switch, for example telephony switch , a web server  (for example, connected through a gateway ), or a like data processing system that communicates with the MS in any of a variety of ways as well known to those skilled the art. MS detection may be a result of the MS initiating a communication with the service directly or indirectly. Thus, a user may connect his laptop to a hotel network, initiate a communication with the service, and the service determines that the user is in a different location than the previous communication. A local area network (LAN)  may contain a variety of connected devices, each an MS that later becomes connected to a local area network  at a different location, such as a PDA , a server computer , a printer , an internet protocol telephone , a computer , or the like. Hard copy presentation could be made to printer  and fax .","Current technology enables devices to communicate with each other, and other systems, through a variety of heterogeneous system and communication methods. Current technology allows executable processing to run on diverse devices and systems. Current technology allows communications between the devices and\/or systems over a plethora of methodologies at close or long distance. Many technologies also exist for automatic locating of devices. It is well known how to have an interoperating communications system that comprises a plurality of individual systems communicating with each other with one or more protocols. As is further known in the art of developing software, executable processing of the present disclosure may be developed to run on a particular target data processing system in a particular manner, or customized at install time to execute on a particular data processing system in a particular manner.",{"@attributes":{"id":"p-0326","num":"0339"},"figref":["FIG. 1F","FIG. 1F","FIG. 1B"],"b":["4","10","12","4","2","2","10","12","2","2","2","2","2","2","2","2","2","2","2","4"],"i":["p ","p ","p","q ","q ","r ","r ","r ","s ","t "]},"In some embodiments, an administrator or authorized user (e.g. parent) configures the MS for intended LBX character and use by the main MS user (e.g. child). Credentials such as a password, access code, user identifier and password, etc, or other authorization scheme may be used when accessing a disclosed configuration interface to limit configurability to certain users, types of users, or users with certain privileges.",{"@attributes":{"id":"p-0328","num":"0341"},"figref":["FIG. 2A","FIG. 1E","FIG. 1E"],"b":["200","200","108","200","108","108","200","108","200","108","200","108","108","108","200","200"],"i":["b","b ","b","b ","b ","b ","b ","b "]},{"@attributes":{"id":"p-0329","num":"0342"},"figref":["FIG. 2B","FIG. 1E","FIG. 1E"],"b":["200","200","202","204","200","202","202","200","202","200","202","200","202","202","202","200","200"]},{"@attributes":{"id":"p-0330","num":"0343"},"figref":["FIG. 2C","FIG. 1E","FIG. 1E"],"b":["200","200","212","210","200","212","212","200","212","200","212","212","212","212","200","200"]},"Once DLM  is within the building , a strategically placed antenna  with a desired detection range within the building is used to detect the DLM  coming into its proximity. Wall breakout  is used to see the antenna  through the building . The known antenna  location is used to automatically detect the location of the DLM . In fact, any DLM that travels within the coverage area served by antenna  is identified as the location of antenna . The confidence of a location of a DLM  is low when the antenna coverage area of antenna  is large. In contrast, the confidence of a location of a DLM  is higher when the antenna coverage area of antenna  is smaller. Travels of DLM  can be limited by objects, pathways, or other limiting circumstances of traffic, to provide a higher confidence of location of DLM  when located by antenna , or when located by any locating antenna described herein which detects MSs coming within range of its location. Location confidence is improved with a TDOA measurement as described above. Antenna  can process all locating by itself (with connected data processing system (not shown) as well known to those skilled in the art), or with interoperability to other services as connected to antenna , for example with connectivity described in . Antenna  can be used to communicate the location of DLM  to a service, to the DLM , to other MSs within its coverage area, any combination thereof, or to any connected data processing system, or MS, of . Other in-range detection antennas of a  embodiment may be strategically placed to facilitate warehouse operations such as in Kubler et al.",{"@attributes":{"id":"p-0332","num":"0345"},"figref":["FIG. 2D","FIGS. 2A through 2C","FIG. 2D","FIG. 13A","FIG. 13A","FIG. 13C"],"b":["200","230","232","230","242","1302","1304","232","234","1100","236","1100","1100"]},"In another embodiment, blocks  through  are not required. A service connected antenna (or cell tower) periodically broadcasts its whereabouts (WDR info (e.g. )) and MSs in the vicinity use that directly at block . The MS can choose to use only the confidence and location provided, or may determine a TDOA measurement for determining how close it is. If the date\/time stamp field indicates NTP is in use by the service, and the MS is also using NTP, then a TDOA measurement can be determined using the one unidirectional broadcast via the antenna by using the date\/time stamp field received with when the WDR information was received by the MS (subtract time difference and use known wave spectrum for distance). If either the service or MS is not NTP enabled, then a bidirectional correlated data flow between the service and MS is used to assess a TDOA measurement in terms of time of the MS. One embodiment provides the TDOA measurement from the service to the MS. Another embodiment calculates the TDOA measurement at the MS.","Network Time protocol (NTP) can ensure MSs have the same atomic clock time as the data processing systems driving antennas (or cell towers) they will encounter. Then, date\/time stamps can be used in a single direction (unidirectional) broadcast packet to determine how long it took to arrive to\/from the MS. In an NTP embodiment, the MS () and\/or the antenna () sends a date\/time stamp in the pulse, beacon, or protocol. Upon receipt, the antenna (or cell tower) service data processing system communicates how long the packet took from an MS to the antenna (or cell tower) by comparing the date\/time stamp in the packet and a date\/time stamp of when it was received. The service may also set the confidence value, before sending WDR information to the MS. Similarly, an MS can compare a date\/time stamp in the unidirectional broadcast packet sent from a locating service () with when received by the MS. So, NTP facilitates TDOA measurements in a single broadcast communication between systems through incorporation to usual communications data  with a date\/time stamp in Communications Key (CK) , or alternatively in new data . Similarly, NTP facilitates TDOA measurement in a single broadcast communication between systems through incorporation to usual communications data  with a date\/time stamp in Communications Key (CK) , or alternatively in new data .","The following template is used in this disclosure to highlight field settings. See  descriptions. Fields are set to the following upon exit from block :\n\n","A service connected to the antenna (or cell tower) preferably uses historical information and artificial intelligence interrogation of MS travels to determine fields and . Block  continues to block  where parameters are prepared for passing to  processing invoked at block . Parameters are set for: WDRREF=a reference or pointer to the WDR; DELETEQ= location queue discard processing; and SUPER= supervisory notification processing. Thereafter, block  invokes  processing and  processing terminates at block .  processing will insert to queue  so this MS knows at least its own whereabouts whenever possible. A single data instance embodiment of WDR queue  will cause  to update the single record of WDR information for being current upon exit from block  (this is true for all flowchart blocks invoking  processing).","With reference now to , depicted is a flowchart for describing a preferred embodiment of a procedure for inserting a Whereabouts Data Record (WDR)  to MS WDR queue . Appropriate semaphores are used for variables which can be accessed simultaneously by another thread other than the caller. With reference now to , procedure processing starts at block  and continues to block  where parameters passed from the invoking block of processing, for example block , are determined. The variable WDRREF is set by the caller to a reference or pointer to the WDR so subsequent blocks of  can access the WDR. The variable DELETEQ is set by the caller so that block  knows how to discard obsolete location queue entries. The DELETEQ variable can be a multi-field record (or reference thereof) for how to prune. The variable SUPER is set by the caller so that block  knows under what condition(s), and which data, to contact a supervisory service. The SUPER variable can be a multi-field record (or reference thereof) for instruction.","Block  continues to block  where the DLMV (see  and later discussions for DLMV (DLM role(s) List Variable)), or ILMV (see  and later discussions for ILMV (ILM role(s) List Variable)), is checked for an enabled role matching the WDR for insertion (e.g. DLM: location technology field (technology and originator indicator) when MS ID=this MS; ILM: DLM or ILM indicator when MS ID not this MS). If no corresponding DLMV\/ILMV role is enabled for the WDR to insert, then processing continues to block  (the WDR is not inserted to queue ). If the ILMV\/DLMV role for the WDR is enabled, then processing continues to block  where the confidence of the WDR  is validated prior to insertion. An alternate embodiment to  will not have block  (i.e. block  continues directly to block ) since appropriate DLM and\/or ILM processing may be terminated anyway when DLM\/ILM role(s) are disabled (see FIG. A\/B).","If block  determines the data to be inserted is not of acceptable confidence (e.g. field <confidence floor value (see FIG. A\/B)), then processing continues to block  described below. If block  determines the data to be inserted is of acceptable confidence (e.g. field 70), then processing continues to block  for checking the intent of the WDR insertion.","If block  determines the WDR for insert is a WDR describing whereabouts for this MS (i.e. MS ID matching MS of  processing (DLM: , or ILM: FIG. A\/B)), then processing continues to block . If block  determines the WDR for insert is from a remote ILM or DLM (i.e. MS ID does not match MS of  processing), then processing continues to block . Block  peeks the WDR queue  for the most recent highest confidence entry for this MS whereabouts by searching queue  for: the MS ID field matching the MS ID of  processing, and a confidence field greater than or equal to the confidence floor value, and a most recent date\/time stamp field . Thereafter, if block  determines one was found, then processing continues to block , otherwise processing continues to block  where a Last Whereabouts date\/Time stamp (LWT) variable is set to field of the WDR for insert (e.g. first MS whereabouts WDR), and processing continues to block .","If block  determines the WDR for insertion has significantly moved (i.e. using a movement tolerance configuration (e.g. 3 meters) with fields of the WDR for insert and the WDR peeked at block ), then block  sets the LWT (Last Whereabouts date\/Time stamp) variable (with appropriate semaphore) to field of the WDR for insert, and processing continues to block , otherwise processing continues directly to block  (thereby keeping the LWT as its last setting). The LWT is to hold the most recent date\/time stamp of when the MS significantly moved as defined by a movement tolerance. The movement tolerance can be system defined or configured, or user configured in  by an option for configuration detected at block , and then using the Configure Value procedure of  (like confidence floor value configuration).","Block  accesses the DLMV and updates it with a new DLM role if there is not one present for it. This ensures a correct list of DLMV roles are available for configuration by . Preferably, by default an unanticipated DLMV role is enabled (helps inform the user of its availability). Likewise in another embodiment, ILMV roles can be similarly updated, in particular if a more granulated list embodiment is maintained to the ILMV, or if unanticipated results help to identify another configurable role. By default, block  should allow unanticipated roles to continue with WDR insertion processing, and then block  can add the role, enable it, and a user can decide what to do with it in configuration (FIG. A\/B).","Thereafter, the WDR  is inserted to the WDR queue  at block , block  discards any obsolete records from the queue as directed by the caller (invoker), and processing continues to block . The WDR queue  preferably contains a list of historically MS maintained Whereabouts Data Records (WDRs) as the MS travels. When the MS needs its own location, for example from an application access, or to help locate an ILM, the queue is accessed for returning the WDR with the highest confidence value (field ) in the most recent time (field ) for the MS (field ). Block  preferably discards by using fields and relative to other WDRs. The queue should not be allowed to get too large. This will affect memory (or storage) utilization at the MS as well as timeliness in accessing a sought queue entry. Block  also preferably discards WDRs from queue  by moving selected WDRs to LBX History .","As described above, queue interfaces assume an implicit semaphore for properly accessing queue . There may be ILMs requesting to be located, or local applications of the MS may request to access the MS whereabouts. Executable thread(s) at the MS can accesses the queue in a thread-safe manner for responding to those requests. The MS may also have multiple threads of processing for managing whereabouts information from DLMs, ILMs, or stationary location services. The more concurrently executable threads available to the MS, the better the MS is able to locate itself and respond to others (e.g. MSs). There can be many location systems and methods used to keeping a MS informed of its own whereabouts during travel. While the preferred embodiment is to maximize thread availability, the obvious minimum requirement is to have at least 1 executable thread available to the MS. As described above, in operating system environments without proper queue interfaces, queue access blocks are first preceded by an explicit request for a semaphore lock to access queue  (waits until obtained), and then followed by a block for releasing the semaphore lock to another thread for use. Also, in the present disclosure it is assumed in blocks which access data accessible to more than 1 concurrent thread (e.g. shared memory access to DLMV or ILMV at block ) that an appropriate semaphore (created at block ) protect synchronous access.","If block  determines information (e.g. whereabouts) should be communicated by service informant code  to a supervisory service, for example a service , then block  communicates specified data to the service and processing terminates at block  by returning to the invoker (caller). If block  determines a supervisory service is not to be informed, then processing terminates with an appropriate return to the caller at block . Service informant code , at block , can send information as data that is reliably acknowledged on receipt, or as a datagram which most likely (but unreliably) is received.","Depending on the SUPER variable, block  may opt to communicate every time a WDR is placed to the queue, or when a reasonable amount of time has passed since last communicating to the supervisory service, or when a WDR confidence reaches a certain sought value, or when any WDR field or fields contain certain sought information, or when a reasonably large number of entries exist in WDR queue , or for any processing condition encountered by blocks  through , or for any processing condition encountered by caller processing up to the invocation of  processing. Different embodiments will send a single WDR  at block , a plurality of WDRs , or any other data. Various SUPER parameter(s) embodiments for  caller parameters can indicate what, when, where and how to send certain data. Block  may send an email, an SMS message, or use other means for conveying data. Service informant code  may send LBX history , statistics  and\/or any other data , data , queue data, data  or resources . Service informant code  may update data in history , statistics  or any other data , data , queue data, data  and\/or resources , possibly using conditions of this data to determine what is updated. Blocks  and  may be omitted in some embodiments.","If a single WDR is sent at block  as passed to  processing, then the WDR parameter determined at block  is accessed. If a plurality of WDRs is sent at block , then block  appropriately interfaces in a thread-safe manner to queue , and sends the WDRs.","Some preferred embodiments do not incorporate blocks  through . (i.e. block  continues to block  if confidence ok). Blocks  through  are for the purpose of implementing maintaining a date\/time stamp of last MS significant movement (using a movement tolerance). Architecture  uses , as does DLM processing.  must perform well for the preferred multithreaded architecture . Block  performs a peek, and block  can be quite timely depending on embodiments used for location field . A movement tolerance incorporated at the MS is not necessary, but may be nice to have. Therefore, blocks  through  are optional blocks of processing.",{"@attributes":{"id":"p-0349","num":"0376"},"figref":["FIG. 2F","FIG. 2F"],"b":["22","289","1100","290","290","289","289","290"]},"With reference now to , depicted is a flowchart for describing a preferred embodiment of an MS whereabouts update event of an antenna in-range detected MS, for example a DLM , when MS location awareness is monitored by the MS.  describes relevant processing for MSs to maintain their own whereabouts. Processing begins at block  when the MS receives a signal from an antenna (or cell tower) deserving a response and continues to block  where the antenna or cell tower signal is authenticated by the MS as being a legitimate signal for processing. The signal can be received for processing by blocks  through  as the result of a continuous, or pulsed, broadcast or beaconing by the antenna, or cell tower (), or as part of usual communication protocol in progress with at least one MS ( usual data  with embedded Communications Key ), or as a response via antenna to a previous MS signal (). The signal is preferably authenticated by a data parsed signature deserving further processing. Block  continues to block  where the MS sends an outbound request for soliciting an immediate response from the antenna (or cell tower) service. The request by the MS is appropriately correlated (e.g. as described above) for a response, which additionally facilitates embodiments using TDOA measurements (time of communications between the MS and antenna, or cell tower) to determine how close is the MS in range. Block  waits for a response, or waits until a reasonable timeout, whichever occurs first. There are also multithreaded embodiments to breaking up  where block  does not wait, but rather terminates  processing and depends on another thread to correlate the response and then continue processing blocks  through  (like architecture ).","Thereafter, if block  determines the request timed out, then processing terminates at block . If block  determines the response was received, then processing continues to block . Block  completes a WDR  with appropriate response data received along with data set by the MS. See  descriptions. Fields are set to the following upon exit from block :\n\n","The longer time it takes between sending a request and getting a response at block , the less confidence there is for being located because the MS must be a larger distance from the antenna or cell tower. The less time it takes, the more confidence there is for being located because the MS must be a closer distance to the antenna or cell tower. Confidence values are analogously determined as described for .  NTP embodiments also apply here. NTP can be used so no bidirectional communications is required for TDOA measurement. In this embodiment, the antenna (or cell tower) sets a NTP date\/time stamp in the pulse, beacon, or protocol. Upon receipt, the MS instantly knows how long the packet took to be received by comparing the NTP date\/time stamp in the packet and a MS NTP date\/time stamp of when it was received (i.e. no request\/response pair required). If location information is also present with the NTP date\/time stamp in data received at block , then block  can continue directly to block .","An alternate MS embodiment determines its own (direction) heading and\/or speed for WDR completion based on historical records maintained to the WDR queue  and\/or LBX history .","Block  continues to block  for preparing parameters for: WDRREF=a reference or pointer to the WDR; DELETEQ= location queue discard processing; and SUPER= supervisory notification processing. Thereafter, block  invokes the procedure ( processing) to insert the WDR to queue . After  processing of block ,  processing terminates at block .","In alternative \u201ccoming within range\u201d (same as \u201cin range\u201d, \u201cin-range\u201d, \u201cwithin range\u201d) embodiments, a unique MS identifier, or MS group identifier, for authenticating an MS for locating the MS is not necessary. An antenna emitting signals () will broadcast (in CK  of data ) not only its own location information (e.g. location field ), but also an NTP indicated date\/time stamp field , which the receiving MS (also having NTP for time synchronization) uses to perform a TDOA measurement upon receipt. This will enable a MS to determine at least how close (e.g. radius  range, radius  range, radius  range, or radius  range) it is located to the location of the antenna by listening for and receiving the broadcast (e.g. of ). Similarly, in another embodiment, an NTP synchronized MS emits signals () and an NTP synchronized data processing system associated with a receiving antenna can make a TDOA measurement upon signal receipt. In other embodiments, more than a single unidirectional signal may be used while still preventing the requirement to recognize the MS to locate it. For example, an antenna emitting signals (e.g.  hotspot WiFi .) will contain enough information for a MS to respond with correlation for being located, and visa-versa. In any case, there can be multi-directional exchanged signals for determining a TDOA measurement.",{"@attributes":{"id":"p-0356","num":"0397"},"figref":"FIG. 3A","b":["200","200","108","108","108","200","108","108","108"],"i":["b","d","f","b","d","f "]},{"@attributes":{"id":"p-0357","num":"0398"},"figref":["FIG. 3B","FIG. 3A","FIGS. 3B and 3C","FIG. 13A","FIG. 13C"],"b":["200","310","312","1304","1302","1314","1312","32"]},"TDOA is calculated from the time it takes for a communication to occur from the MS back to the MS via the base tower, or alternatively, from a base tower back to that base tower via the MS. NTP may also be used for time calculations in a unidirectional broadcast from a base tower () to the MS, or from the MS () to a base tower (as described above). AOA is performed through calculations of the angle by which a signal from the MS encounters the antenna. Triangle geometry is then used to calculate a location. The AOA antenna is typically of a phased array type.","See \u201cMissing Part Triangulation (MPT)\u201d section below with discussions for  for details on heterogeneously locating the MS using both TDOA and AOA (i.e. Missing Part Triangulation (MPT)). Just as high school taught geometry for solving missing parts of a triangle, so to does MPT triangulate an MS location. Think of the length of a side of a triangle as a TDOA measurement\u2014i.e. length of time, translatable to a distance. Think of the AOA of a signal to an antenna as one of the angles of a triangle vertice. Solving with MPT analogously uses geometric and trigonometric formulas to solve the triangulation, albeit at fast processing speeds.","Thereafter, if the MS is determined to be legitimate and deserving of processing (similar to above), then block  continues to block . If block  determines the MS is not participating with the service, in which case block  did little to process it, then processing continues back to block  to continue working on behalf of legitimate participating MSs. The controller at block  may communicate with other controllers when base stations in other cellular clusters are picking up a signal, for example, when the MS roams. In any case, at block , the controller(s) determines the strongest signal base stations needed for locating the MS, at block . The strongest signals that can accomplish whereabouts information of the MS are used. Thereafter, block  accesses base station location information for base stations determined at block . The base station provides stationary references used to (relatively) determine the location of the MS. Then, block  uses the TDOA, or AOA, or MPT (i.e. heterogeneously both AOA and TDOA) information together with known base station locations to calculate the MS location.","Thereafter, block  accesses historical MS location information, and block  performs housekeeping by pruning location history data for the MS by time, number of entries, or other criteria. Block  then determines a heading (direction) of the MS based on previous location information. Block  may perform Artificial Intelligence (AI) to determine where the MS may be going by consulting many or all of the location history data. Thereafter, block  completes a service side WDR , block  appends the WDR information to location history data and notifies a supervisory service if there is one outside of the service processing of . Processing continues to block  where the service communicates the WDR to the located MS.","Thereafter, the MS completes its own WDR at block  for adding to WDR queue  to know its own whereabouts whenever possible, and block  prepares parameters for invoking WDR insertion processing at block . Parameters are set for: WDRREF=a reference or pointer to the MS WDR; DELETEQ= location queue discard processing; and SUPER= supervisory notification processing (e.g. no supervisory notification processing because it was already handled at block , or by being in context of the  service processing). At block , the MS invokes  processing already described. After block , processing continues back to block . Of course, block  continues directly to block  at the service(s) since there is no need to wait for MS(s) processing in blocks  through .  processing is continuous for every MS in the wireless network 7 days a week, 24 hours a day.","See  descriptions. Fields are set to the following upon exit from block :\n\n",{"@attributes":{"id":"p-0364","num":"0419"},"figref":["FIG. 3C","FIG. 3B","FIG. 13C","FIG. 13C","FIGS. 11A through 11E","FIG. 13C"],"b":["200","350","352","352","354","356","358","358"]},"Thereafter, block  accesses historical MS location information (e.g. WDR queue  and\/or LBX history ) to prevent redundant information kept at the MS, and block  performs housekeeping by pruning the LBX history  for the MS by time, number of entries, or other criteria. Block  then determines a heading (direction) of the MS based on previous location information (unless already known from block  for AOA determination). Block  may perform Artificial Intelligence (AI) to determine where the MS may be going by consulting queue  and\/or history . Thereafter, block  completes a WDR , and block  prepares parameters for  processing: WDRREF=a reference or pointer to the MS WDR; DELETEQ= location queue discard processing; and SUPER= supervisory notification processing. Block  continues to block  for invoking  processing already described above. After block , processing continues back to block .  processing is continuous for the MS as long as the MS is enabled. In various multithreaded embodiments, many threads at the MS work together for high speed processing at blocks  through  for concurrently communicating to many stationary references.","See  descriptions. Fields are set to the following upon exit from block :\n\n","In alternative triangulation embodiments, a unique MS identifier, or MS group identifier, for authenticating an MS for locating the MS is not necessary. An antenna emitting signals () will broadcast (CK  of data ) not only its own location information, but also an NTP date\/time stamp, which the receiving MS (also having NTP for time synchronization) uses to perform TDOA measurements upon receipt. This will enable a MS to determine how close (e.g. radius  range, radius  range, radius  range, or radius  range) it is located to the location of the antenna by listening for and receiving the broadcast (e.g. of ). Similarly, in another embodiment, an NTP synchronized MS emits signals () and an NTP synchronized data processing system associated with a receiving antenna can determine a TDOA measurement upon signal receipt. In other embodiments, more than a single unidirectional signal may be used while still preventing the requirement to recognize the MS to locate it. For example, an antenna emitting signals will contain enough information for a MS to respond with correlation for being located. Alternatively, an MS emitting signals will contain enough information for a service to respond with correlation for being located. In any case, there can be multi-directional exchanged signals for determining TDOA. Similarly, a service side data processing system can interact with a MS for AOA information without requiring a known identifier of the MS (use request\/response correlation).",{"@attributes":{"id":"p-0368","num":"0437"},"figref":"FIG. 4A","b":["200","200","134","136","138"]},{"@attributes":{"id":"p-0369","num":"0438"},"figref":["FIG. 4B","FIG. 4B","FIG. 2F","FIG. 2F","FIG. 4B","FIG. 4B"],"b":["200","410","412","414","416","412","414","414","416","1100","418","420","422","424","420"]},"See  descriptions. Fields are set to the following upon exit from block :\n\n",{"@attributes":{"id":"p-0371","num":"0454"},"figref":["FIG. 5A","FIG. 5A","FIGS. 3A to 3C","FIG. 5A"],"b":["200","502","504","504","504","504","504","200","504"],"i":["f","h","i "]},{"@attributes":{"id":"p-0372","num":"0455"},"figref":"FIG. 5B","b":["200","510","512","514","516","518","520","522","524","512"]},"Thereafter, block  accesses historical MS location information, performs housekeeping by pruning location history data for the MS by time, number of entries, or other criteria, and determines a heading (direction) of the MS based on previous location information. Block  may perform Artificial Intelligence (AI) to determine where the MS may be going by consulting many or all of the location history data. Thereafter, block  completes a service side WDR , block  appends the WDR information to location history data and notifies a supervisory service if there is one outside of the service processing of . Processing continues to block  where the service communicates the WDR to the located MS.","Thereafter, the MS completes the WDR at block  for adding to WDR queue . Thereafter, block  prepares parameters passed to  processing for: WDRREF=a reference or pointer to the MS WDR; DELETEQ= location queue discard processing; and SUPER= supervisory notification processing (e.g. no supervisory notification processing because it was already handled at block , or by being in context of the  service processing). Block  continues to block  where the MS invokes  processing already described above. After block , processing continues back to block . Of course, block  continues directly to block  at the service(s) since there is no need to wait for MS(s) processing in blocks  through .  processing is continuous for every MS in the wireless network 7 days a week, 24 hours a day.","See  descriptions. Fields are set to the following upon exit from block :\n\n",{"@attributes":{"id":"p-0376","num":"0473"},"figref":"FIG. 6A","b":"200"},"Relevant processing begins at block  and continues to block  where an MS device is physically\/logically connected to a network. Thereafter, the MS accesses a service at block . Then, at block , the service accesses historical MS location history, and block  performs housekeeping by pruning the location history data maintained for the MS by time, number of entries, or other criteria. Block  may perform Artificial Intelligence (AI) to determine where the MS may be going (e.g. using heading based on previous locations) by consulting much or all of the location history data. Thereafter, service processing at block  completes a service side WDR , then the service appends WDR information to location history data at block , and may notify a supervisory service if there is one outside of the service processing of . Processing continues to block  where the service communicates WDR information to the newly physically\/logically connected MS. There are many embodiments for determining a newly connected MS location using a physical or logical address, for example consulting a database which maps locations to network addresses (e.g. location to logical ip address; location to physical wall jack\/port; etc). Then, at block  the MS completes its own WDR using some information from block ,  parameters are prepared at block , block  invokes  processing already described above, and processing terminates at block . Parameters are set at block  for: WDRREF=a reference or pointer to the MS WDR; DELETEQ= location queue discard processing; and SUPER= supervisory notification processing (e.g. no supervisory notification processing because it was already handled at block , or by being in context of the  service processing). Of course, block  continues directly to block  at the service(s) since there is no need to wait for MS processing in blocks  through .  processing is available at any appropriate time in accordance with the underlying service.","See  descriptions. Fields are set to the following upon exit from block :\n\n",{"@attributes":{"id":"p-0379","num":"0490"},"figref":["FIG. 6B","FIG. 6A","FIG. 6A","FIG. 2F","FIG. 2F","FIG. 6B","FIG. 6B","FIG. 6B"],"b":["200","640","642","644","646","644","646","644","648","646","644","36","8","20","648","1100","650","652","654","650"]},"See  descriptions. Fields are set to the following upon exit from block :\n\n",{"@attributes":{"id":"p-0381","num":"0506"},"figref":["FIGS. 7A","FIG. 7A","FIG. 7D","FIG. 7A"],"b":["7","7","200","702","704","702","702","704","200","702","701","702","200","702","702","702","700","700","200","701","702","708","702","708","200","706","200","708","706","200","200","702","704","702","708","704"]},"With reference now to , image capture device  is positioned for monitoring MSs that come into the field of view  of device . MSs are preferably distinguishable by appearance (e.g. color, shape, markings, labels, tags, etc), or as attached (e.g. recognized mount to host) or carried (e.g. recognized by its recognized user). Such techniques are well known to those skilled in the art. Device  is as described above with connectivity to locating service  and antenna (or cell tower) .  illustrates that device  uses known measurements within its field of view for determining how large, and where located, are objects that come into the field of view . For example, a well placed and recognizable vertical line and horizontal line , which are preferably perpendicular to each other, have known lengths and positions. The objects which come into the field of view are measured based on the known lengths and positions of the lines and which may be landscape markings (e.g. parking lot lines) for additional purpose. Field of view  may contain many lines and\/or objects of known dimensions strategically placed or recognized within the field of view  to facilitate image processing by service . Building  may serve as a reference point having known dimension and position in measuring objects such as a person  or DLM . A moving object such as a shopping cart  can have known dimensions, but not a specific position, to facilitate service  in locating an MS coming into the field of view . Those skilled in the art recognize that known dimensions and\/or locations of anticipated objects in field of view  have measurements facilitating discovering positions and measurements of new objects that may travel into the field of view . Using  techniques with  techniques provides additional locating accuracy. A distance may be estimated based on the anticipated sizes of references in the field of view, relative size of the recognized MS.","With reference now to , image capture device  is positioned for monitoring MSs that come into the field of view  of device . Device  is as described above with connectivity to locating service  and antenna (or cell tower) . MSs are preferably distinguishable by appearance (e.g. color, shape, markings, labels, tags, etc), or as attached (e.g. recognized mount to host) or carried (e.g. recognized by its user), or as identified by  and\/or  methodologies.  illustrates that device  uses known locations within its field of view for determining how large, and where located, are objects that come into the field of view . For example, building , tree , and traffic sign  have its locations known in field of view  by service . Solving locations of objects that move into the field of view is accomplished with graphical triangulation measurements between known object reference locations (e.g. building , tree , and sign ) and the object to be located. Timely snapshots by device  provide an ongoing locating of an MS, for example DLM . Line segment distances  (a, b, c) can be measured using references such as those of . Whereabouts are determined by providing known coordinates to anticipated objects such as building , tree , and sign . Similarly, graphical AOA measurements (i.e. graphical angle measurements) and graphical MPT measurements can be used in relation to anticipated locations of objects within the field of view . There may be many anticipated (known) object locations within field of view  to further facilitate locating an MS. Being nearby an object may also be enough to locate the MS by using the object's location for the location of the MS. Using  techniques with  and\/or  techniques provides additional locating accuracy.","The system and methodologies illustrated by  are preferably used in optimal combination by locating service  to provide a best location of an MS. In some embodiments, MS whereabouts is determined as the location of a device  by simply being recognized by the device . In other embodiments, multiple devices  can be strategically placed within a geographic area for being used in combination to a common locating service  for providing a most accurate whereabouts of an MS. Multiple field of views  from difference angles of different devices  enable more precise locating within three dimensional space, including precise elevations.",{"@attributes":{"id":"p-0385","num":"0510"},"figref":["FIG. 7D","FIGS. 7A through 7C","FIGS. 7A through 7C","FIGS. 7B and 7C","FIG. 7D","FIGS. 7A through 7C"],"b":["700","700","700","700","732","734","700","734","736","702","736","736","738","736","754","702","702","736","736","738","702","700","736","738","738","740","740","736","738","740","742","744","746","701","748"]},"There may be a plurality of MSs in the field of view, so communications at block  targets each MS recognized. A MS should not rely on the service to have done its job correctly. At a MS, block  checks the MS ID communicated for validation. If block  determines the MS ID is incorrect, then processing continues back to block  (for the particular MS). If block  determines the MS ID is correct, then processing continues to block  where the particular MS completes its WDR  received from service . Thereafter, MS(s) prepare parameters at block , invoke local  processing already described above (at block ), and processing continues for service  back to block . Of course, block  continues directly to block  at the service(s) since there is no need to wait for MS(s) processing in blocks  through . Parameters set at block  are: WDRREF=a reference or pointer to the MS WDR; DELETEQ= location queue discard processing; and SUPER= supervisory notification (e.g. no supervisory notification processing because it was already handled at block , or by being in context of the  service processing). No snapshots from device  are to be missed at block .","See  descriptions. Fields are set to the following upon exit from block :\n\n","In an alternative embodiment, MS  may be equipped (e.g. as part of resources ) with its own device  and field of view  for graphically identifying recognizable environmental objects or places to determine its own whereabouts. In this embodiment, the MS would have access to anticipated objects, locations and dimensions much the same way described for , either locally maintained or verifiable with a connected service. Upon a successful recognition of an object, place, or other graphically perceptible image which can be mapped to a location, the MS would complete a WDR similarly to above. The MS may recognize addresses, buildings, landmarks, of other pictorial data. Thus, the MS may graphically determine its own location. The MS would then complete a WDR  for  processing exactly as described for  with the exceptions of fields that follow:\n\n","With reference now to , depicted is a flowchart for describing a preferred embodiment of processing for a MS to graphically locate itself.  processing is used on each image (generally referred to as a frame) which is captured (or stored) at a MS. There are many embodiments for how, when, where and why an image (frame) is captured at the MS which subsequently gets analyzed by  processing, including:\n\n","Independent of how a frame is selected for processing, frame analysis processing begins at block , continues to block  for applicable initialization in preparation for subsequent processing, and then to block  for accessing graphical recognition criteria. In a preferred embodiment, graphical recognition criteria is preconfigured for a MS and governs how and what to examine in images for determining a location. Thereafter, if block  determines Optical Character Recognition (OCR) criteria is configured, then block  performs optical character recognition on the frame and produces an output text stream if one or more characters is identified. Block  preferably employs all reasonable methods and systems for improving optical character recognizing functionality (e.g. employ relevant techniques of U.S. Pat. No. 5,875,261 (Method of and apparatus for optical character recognition based on geometric and color attribute hypothesis testing, Fitzpatrick et al); U.S. Pat. No. 5,645,309 (Method of and apparatus for character recognition through related spelling heuristics, Johnson); U.S. Pat. No. 5,406,640 (Method of and apparatus for producing predominate and non-predominate color coded characters for optical character recognition, Fitzpatrick et al); U.S. Pat. No. 5,396,564 (Method of and apparatus for recognizing predominate and non-predominate color code characters for optical character recognition, Fitzpatrick et al); U.S. Pat. No. 5,262,860 (Method and system communication establishment utilizing captured and processed visually perceptible data within a broadcast video signal, Fitzpatrick et al)).","Processing continues to block  where the next (or first) text fragment from block  is accessed, and block  checks if a new text fragment is available for processing. If block  determines that a new text fragment is available for processing, then block  checks if the fragment, along with any other data so far processed, contains high confidence address information. If block  determines high confidence address information was detected in the frame, then block  performs further validation using whereabouts information available to the MS at the time of block  processing, and block  checks if a location can be determined for the address information containing the text fragment being processed. If block  determines a location was determined, then block  completes a WDR , block  prepares parameters for  processing, block  invokes local  processing already described above, and processing continues back to block  for a next text fragment to process. Parameters set at block  are: WDRREF=a reference or pointer to the MS WDR; DELETEQ= location queue discard processing; and SUPER= supervisory notification. The location determined at block  should be of a reasonable confidence when completing the WDR at block . See  descriptions, and WDR completion descriptions above.","A fragment at block  may be any subset text string of the text stream from block  so that text fragments, for example, may include re-processing previously processed or subsequently processed text portions of a loop iteration of block  through . Intelligence is maintained at block  for selecting an optimal next best text fragment. For example, if the user of the MS snaps a picture of an address on the outside of an office building, block  should have enough intelligence to select the entire address text string rather than just a portion (e.g. zip code) for processing, and then prevent reprocessing redundant information for another loop iteration. Block  may incorporate intelligence based on anticipated address lookup capability accessible to block . Block  determines an indisputable address as a zip code, number and street address, state, street sign block, combinations thereof, or any other textual address information which corresponds to some location. Block  preferably has access to address mapping or geo-coding conversion information which is accessed local and\/or remote to the MS of  processing for partial address search (e.g. find all states with street address), as well as queue , LBX history , statistics  and any other data which can complement or confirm determining whereabouts of the MS (e.g. narrow down state for street address based on what is found on queue ). A most recent WDR at queue  with a confident location can confirm whether or not the OCR findings are reasonable or possible.","With reference back to block , if it is determined that a confident location cannot be determined, processing continues back to block . With reference back to block , if it is determined that an indisputable address was not found, processing continues to block . If block  determines a partial address was determined in the text fragment, block  performs resolution accessing other text information from the text stream as well as using validation resources used by block , and processing continues to block  already described above. With reference back to block , if it is determined that a partial address was not found, processing continues back to block . With reference back to block , if it is determined that that all reasonable text fragments have been processed from the text stream output of block , processing continues to block . With reference back to block , if it is determined that no OCR criteria is configured for processing, then processing continues to block .","If it is determined at block  that one or more landmarks have been configured for graphical recognition criteria, block  gets the next (or first) configured landmark, and block  checks if all have been processed. If there is a landmark to process, then block  compares the landmark criteria to the frame and block  checks if a match was determined. Landmark criteria is preferably scaled, two dimensionally translated, and color matched as a raster over the frame image for matching to a landmark in the frame. If block  determines a match was found, then block  performs validation similarly to block . Landmarks are configured with known location information (e.g. latitude and longitude, address, etc) for facilitating comparisons to useful MS resources for validation (i.e. queue , LBX history , statistics , and any other data which can complement or confirm determining whereabouts of the MS).","Thereafter, if block  determines a confident location was validated at block , then block  completes a WDR , block  prepares parameters for  processing, block  invokes local  processing already described above, and processing continues back to block  for the next landmark criteria to process. Parameters set at block  are: WDRREF=a reference or pointer to the MS WDR; DELETEQ= location queue discard processing; and SUPER= supervisory notification.","If block  determines that a confident location could not be determined, then processing continues directly back to block . If block  determines a match was not found, processing continues back to block . Referring back to block , if all landmarks have been processed, then processing continues to block . Referring back to block , if no landmark information is configured, processing continues to block .","If it is determined at block  that one or more conditional locations have been configured for graphical recognition criteria, block  gets the next (or first) configured conditional location, and block  checks if all have been processed. If there is a conditional location to process, then block  compares the conditional location criteria to the frame and block  checks if a match was determined. Conditional location is somewhat of a catch all for analyzing graphical objects in a frame, for example bar codes, special predefined location symbols, skiing direction signs, and other perceptible visuals other than OCR text and graphical landmarks. Conditional locations further support MS conditions which must be satisfied in order for frame analysis to take place. For example, if the frame is from a snapshot image (not an image stream) and a certain application is active, only then will frame analysis be performed for the criteria configured. In some embodiments, block  can support all expressions of charter BNF Grammar and . A True result of that expression then causes a compare using the location criteria of the conditional location criteria. If block  determines a match was found (and\/or expression to process=True), then block  performs validation similarly to block  (e.g. consulting queue , LBX history , statistics , and any other data which can complement or confirm determining whereabouts of the MS).","Thereafter, if block  determines a confident location was validated at block , then block  completes a WDR , block  prepares parameters for  processing, block  invokes local  processing already described above, and processing continues back to block  for the next conditional location criteria to process. Parameters set at block  are: WDRREF=a reference or pointer to the MS WDR; DELETEQ= location queue discard processing; and SUPER= supervisory notification.","If block  determines that a confident location could not be determined, then processing continues directly back to block . If block  determines a match was not found (and\/or expression to process=False), processing continues back to block . Referring back to block , if all conditional locations have been processed, then  processing terminates at block .","With reference to , depicted is a flowchart for describing a preferred embodiment of processing for configuring criteria used by a MS to graphically locate itself. The user of  may be a MS user, an authenticated administrator of the MS of  processing, or an appropriate administrator for manufactured MSs which have not yet been sold retail.","User interface processing begins at block  and continues to block  for initialization and for accessing any graphical recognition criteria already configured. Thereafter, block  present any current configurations with alteration options, and block  waits for a user action. When a user action is detected to the user interface, processing continues to block .","If block  determines the user selected to configure OCR capability, then block  interfaces with the user for enabling, or disabling, appropriate OCR functionality to be used by , otherwise processing continues to block . When block  is complete, processing continues back to block .","If block  determines the user selected to configure landmark criteria for graphical recognition, then block  interfaces with the user for enabling, or disabling, landmark recognition functionality to be used by , otherwise processing continues to block . When block  is complete interfacing with the user to specify graphical landmark criteria as well as associated location data, processing continues back to block . Graphical landmark criteria may include scalable geometric or raster description including edge dimensions, angles, and recognizable appearance features; color and shading information for verifiable time(s) of the day; unique color combinations or contrasts from known vantage points; actual graphical representation; or combinations thereof.","If block  determines the user selected to configure conditional location criteria for graphical recognition, then block  interfaces with the user for enabling, or disabling, conditional location recognition functionality to be used by , otherwise processing continues to block . When block  is complete interfacing with the user to specify criteria as well as associated location data, processing continues back to block . Conditional location criteria may include any valid BNF grammar charter expression, as well as any other criteria which can be compared for a match to a graphical image. Block  should support a user syntax for expression specification.","If block  determines the user selected to save configuration made thus far, then block  saves the configurations for  and processing continues back to block , otherwise processing continues to block . Block  may internalize conditional expressions of block  for optimal  processing.","If block  determines the user selected to exit  processing, then block  appropriately terminates the  interface and processing, otherwise block  handles other user interface actions detected at block  before continuing back to block .",{"@attributes":{"id":"p-0407","num":"0563"},"figref":["FIG. 8A","FIGS. 3B and 3C","FIGS. 3B and 3C"],"b":["200","802","806","802","806","802","806"]},"It has been shown that light can be used to triangulate position or location information (e.g. U.S. Pat. No. 6,549,288 (Migdal et al) and U.S. Pat. No. 6,549,289 (Ellis)). Optical sensors  through  detect a light source of, or illumination of, an MS, for example DLM . Data is superimposed on the light wave spectrum with specified frequency\/wavelength and\/or periodicity, or data occurs in patterned breaks in light transmission. Data may contain a unique identifier of the MS so service(s) attached to sensors  through  can communicate uniquely to an MS. Mirrors positioned at optical sensors  through  may be used to determine an AOA of light at the sensor, or alternatively TDOA of recognizable light spectrum is used to position an MS. The  flowcharts occur analogously for light signals received by sensors  through  which are connected to service processing of . The only difference is wave spectrum used.","Heterogeneously speaking,  illustrates having strategically placed sensors  through  for detecting a wave spectrum and using TDOA, AOA, or MPT. Those skilled in the art appreciate that a wave is analogously dealt with by  regardless of the wave type, albeit with different sensor types  through  and different sensor interface to service(s) of . Wave signal spectrums for triangulation by analogous processing to  include microwaves, infrared, visible light, ultraviolet light, X-rays, gamma rays, longwaves, magnetic spectrum, or any other invisible, visible, audible, or inaudible wave spectrum. Sensors  through  are appropriately matched according to the requirements. Alternatively, a MS may be sensing wave spectrums emitted by transmitters  through .","Those skilled in the relevant arts appreciate that the point in all this discussion is all the wave forms provide methods for triangulating whereabouts information of an MS. Different types of wave forms that are available for an MS can be used solely, or in conjunction with each other, to determine MS whereabouts. MSs may be informed of their location using the identical wave spectrum used for whereabouts determination, or may use any other spectrum available for communicating WDR information back to the MS. Alternatively, the MS itself can determine WDR information relative applicable sensors\/transmitters. In any case, a WDR  is completed analogously to .",{"@attributes":{"id":"p-0411","num":"0567"},"figref":"FIG. 8B","b":["200","810","812","814"],"ul":{"@attributes":{"id":"ul0017","list-style":"none"},"li":{"@attributes":{"id":"ul0017-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0018","list-style":"none"},"li":["a) Touching sensors contact the MS (or host\/housing having MS) to interpret physical characteristics of the MS in order to uniquely identify it (e.g. Braille, embossed\/raised\/depressed symbols or markings, shape, temperature, depressions, size, combinations thereof, etc);","b) Purchase is made with MS while in vicinity of device accepting purchase, and as part of that transaction, the MS is sensed as being at the same location as the device accepting purchase, for example using a cell phone to purchase a soft drink from a soft drink dispensing machine;","c) Barcode reader is used by person to scan the MS (or host\/housing having MS), for example as part of shipping, receiving, or transporting;","d) The MS, or housing with MS, is sensed by its odor (or host\/housing having MS), perhaps an odor indicating where it had been, where it should not be, or where it should be. Various odor detection techniques may be used;","e) Optical sensing wherein the MS is scanned with optical sensory means, for example to read a serial number; and\/or","f) Any sensing means which can identify the MS through physical contact, or by nearby\/close physical contact with some wave spectrum.\n\nBlock  continues to block  where a database is accessed for recognizing the MS identifier (handle) by mapping sensed information with an associated MS handle. If a match is found at block , then block  determines WDR  information using the location of where sensing took place. If block  determines no match was found, then data is saved at block  for an unrecognized entity such as is useful when an MS should have been recognized, but was not. In another embodiment, the MS handle is directly sensed so block  continues directly to block  (no block ). Block  continues to block  where processing terminates. Block  may not use the entire MS identifier for search, but some portion of it to make sure it is a supported MS for being located by sensing. The MS identifier is useful when communicating wirelessly the WDR information to the MS (at block ).\n"]}}}},"Referring now back to block , processing continues to block  where a supervisory service may be updated with the MS whereabouts (if applicable), and block  communicates the WDR information to the MS. Any available communication method can be used for communicating the WDR information to the MS, as described above. Thereafter, the MS completes the WDR at block , block  prepares  parameters, and block  invokes  processing already described above. Processing terminates thereafter at block . Parameters set at block  are: WDRREF=a reference or pointer to the MS WDR; DELETEQ= location queue discard processing; and SUPER= supervisory notification (e.g. no supervisory notification processing because it was already handled at block , or by being in context of the  service processing).  processing is available at any appropriate time for the MS. In an alternate embodiment, the MS senses its environment to determine whereabouts.","See  descriptions. Fields are set to the following upon exit from block :\n\n",{"@attributes":{"id":"p-0414","num":"0590"},"figref":"FIG. 8C","b":["200","850","18","852","852","854","860","854","856","856","862","856","858","858","880","882","858","884","852"]},"With reference back to block , the user interfaces with the MS user interface to manually specify WDR information. The user can specify:\n\n","The user can specify a relevant confidence value for the manually entered location, however, processing at block  preferably automatically defaults a confidence value for the data entered. For example, a complete address, validated at block , will have a high confidence. A partial address such as city and state, or a zip code will have a low confidence value. The confidence value will reflect how large an area is candidate for where the MS is actually located. To prevent completely relying on the user at block  for accurate WDR information, validation embodiments may be deployed. Some examples:\n\n","After WDR information is specified at block , the MS completes the WDR at block , block  prepares parameters for  processing, and (at block ) the MS invokes  processing already described above before returning back to block . Parameters set at block  are: WDRREF=a reference or pointer to the MS WDR; DELETEQ= location queue discard processing; and SUPER= supervisory notification processing. Various embodiments permit override of the confidence floor value by the user, or by  processing. Block  may convert the user specified information into a standardized more usable form in an LN-expanse (e.g. convert to latitude and longitude if possible, truncated precision for more area coverage). WDR  fields (see ) are set analogously in light of the many variations already described above.","With reference back to block , if it is determined that the MS is equipped with capability (e.g. in range, or in readiness) to locate itself, then processing continues to block  where the MS locates itself using MS driven capability described by , C, B, B, and A or MS driven alternative embodiments to , B, B, A, D, A, and B, or any other MS capability for determining its own whereabouts with or without help from other data processing systems or services. Interfacing to locating capability preferably involves a timeout in case there is no, or slow, response, therefore block  continues to block  where it determined whether or not block  timed out prior to determining a location. If block  determines a timeout was encountered, then block  provides the user with an error to the user interface, and processing continues back to block . Block  preferably requires use acknowledgement prior to continuing to block .","If block  determines there was no timeout (i.e. whereabouts successfully determined), then block  interfaces to the locating interface to get WDR information, block  completes a WDR, and blocks  and  do as described above. If block  determines the MS cannot locate itself and needs help, then block  emits at least one broadcast request to any listening service which can provide the MS its location. Appropriate correlation is used for an anticipated response. Example services listening are service driven capability described by , B, B, A, D, A, and B, or service side alternative embodiments of , C, B, B, and A, or any other service capability for determining MS whereabouts with or without help from the MS or other data processing systems or services. Block  then continues to block .","If block  determines a timeout was encountered from the service broadcast request, then block  provides the user with an error to the user interface, and processing continues back to block . If block  determines there was no timeout (i.e. whereabouts successfully determined), then block  receives WDR information from the locating interface of the responding service, block  completes a WDR, and blocks  and  do as already described above.","See  descriptions. Depending how the MS was located via processing started at block  to block , a WDR is completed analogous to as described in Figs. above. If the user manually specified whereabouts at block , fields are set to the following upon exit from block :\n\n",{"@attributes":{"id":"p-0422","num":"0622"},"figref":"FIG. 9A","b":"200"},"The  table has DLM location methods for rows and a single column for the MS (e.g. DLM ). Each location technology can be driven by the client (i.e. the MS), or a service (i.e. the location server(s)) as denoted by a row qualifier \u201cC\u201d for client or \u201cS\u201d for service. An MS may be located by many technologies. The table illustrated shows that the MS with unique identifier 0A12:43EF:985B:012F is able to be heterogeneously located, specifically with local MS GPS capability, service side cell tower in-range detection, service side cell tower TDOA, service side cell tower MPT (combination of TDOA and AOA), service side antenna in-range detection, service side antenna AOA, service side antenna TDOA, service side antenna MPT, service side contact\/sensory, and general service side MPT. The unique identifier in this example is a universal product identifier (like Host Bus Adapter (HBA) World Wide Name (WWN) identifiers are generated), but could be in other form as described above (e.g. phone #214-403-4071). An MS can have any subset of technologies used to locate it, or all of the technologies used to locate it at some time during its travels. An MS is heterogeneously located when two or more location technologies are used to locate the MS during MS travels and\/or when two or more location technologies with incomplete results are used in conjunction with each other to locate the MS during MS travels, such as MPT. MPT is a heterogeneous location technology because it uses at least two different methods to accomplish a single location determination. Using combinations of different location technologies can be used, for example a TDOA measurement from an in-range antenna with a TDOA measurement relative a cell tower (e.g. as accomplished in MS processing of ), using completely different services that have no knowledge of each other. Another combination is to use a synergy of whereabouts data from one technology with whereabouts data from another technology. For example, in-range detection is used in combination with graphical identification to provide better whereabouts of a MS. In another example, a GPS equipped MS travels to an area where GPS does not work well (e.g. downtown amidst large and tall buildings). The DLM becomes an ILM, and is triangulated relative other MSs. So, an MS is heterogeneously located using two or more technologies to determine a single whereabouts, or different whereabouts of the MS during travel.",{"@attributes":{"id":"p-0424","num":"0624"},"figref":["FIG. 9B","FIG. 2F","FIG. 2F","FIG. 9B","FIG. 9B","FIG. 11A"],"b":["200","9","950","952","950","952","954","954","954","956","956","958","956","958","958","960","962","964","960","1100"]},"In some embodiments of  processing, Missing Part Triangulation (MPT) is used to heterogeneously locate an MS. For a service side embodiment example, block  begins service processing when TDOA information itself cannot be used to confidently locate the MS, or AOA information itself cannot be used to confidently locate the MS, however using angles and distances from each in conjunction with each other enables solving whereabouts confidently. See \u201cMissing Part Triangulation (MPT)\u201d section below with discussions for  for MPT processing of blocks  and . Data discovered at block  and processed by block  depends on the embodiment, what stationary reference point locations are known at the time of blocks  and  processing, and which parts are missing for triangulating the MS. Having three (3) sides (all TDOA) with known stationary vertices location(s) solves the triangle for locating the MS. Three (3) angles (all AOA) with known stationary vertices location(s) solves the triangle for locating the MS. Those skilled in the art appreciate that solving triangulation can make complementary use of different distances (time used to determine length in TDOA) and angles (from AOA) for deducing a MS location confidently (e.g. MPT). Those skilled in the art recognize that having stationary reference locations facilitates requiring less triangular information for deducing a MS location confidently.","While MPT has been discussed by example, flowchart B is not to be interpreted in a limiting sense. Any location technologies, for example as shown in , can be used in conjunction with each other when not all information required is available in a single location technology to confidently deduce an MS location. Data available from the different location technologies available will be examined on its own merits, and optionally used in conjunction to deduce a confident location. For example, a TDOA (difference between when signal sent and when received) measurement from \u201ccoming within range\u201d technology can be used to distinguish how close, or how far, is an MS in the vicinity. That measurement may be used to more confidently locate the MS using other TDOA measurements from other unrelated \u201ccoming within range\u201d whereabouts information. In another example, graphical locating information described with  can be used in conjunction with AOA and\/or TDOA, or other useful locating information of other locating technologies. In another example, light triangulation information is used in conjunction with sound triangulation, or light and\/or sound information is used with any other wave form location information to perform accurate locating of a MS. Thus, there are many examples where heterogeneously locating involves using the best available data from a plurality of different locating technologies.","With the many DLM examples above, it should be clear now to the reader how to set the WDR  for DLM invoked  processing. There can be other location technologies that will set WDR  fields analogously. Locating methodologies of  can be used in any combination, for example for more timely or accurate locating. Furthermore, a MS automatically takes on a role of a DLM or ILM depending on what capability is available at the time, regardless of whether or not the MS is equipped for being directly located. As a DLM roams to unsupported areas, it can remain a DLM using different DLM technologies, and it can become an ILM to depend on other MSs (ILMs or DLMs) in the vicinity to locate it.",{"@attributes":{"id":"p-0428","num":"0628"},"figref":["FIGS. 10A and 10B","FIG. 10A","FIGS. 10A and 10B"],"b":["1002","200","200","200","200","200","200","1000","200","200","200","200","1000","200","1000","1000","1000","1000","200","1900","200","200","200","1000","1100","1100"],"i":["a","b","c","d","e ","b ","b","c","e","b","b ","b ","b ","b ","b","c","e ","b ","d "]},"With reference now to , ILM has been located relative a plurality of DLMs, namely DLM , DLM , and DLM . ILM is located analogously to ILM as described for , except there are different DLMs involved with doing the locating of ILM because of a different location of ILM .  illustrate that MSs can be located using other MSs, rather than fixed stationary references described for . ILM and ILM are indirectly located using DLMs .",{"@attributes":{"id":"p-0430","num":"0630"},"figref":"FIG. 10C","b":["1002","1000","200","200","1000","200","200","1000","1000","1000","1000","1000","1000","1000","1900","200","200","1000","1000","1100","1100","1000"],"i":["a ","c","b","b","b","c ","b ","a","a ","a ","a ","a ","a","b","c","b ","a ","d ","a "]},{"@attributes":{"id":"p-0431","num":"0631"},"figref":["FIGS. 10D","FIG. 10D"],"b":["10","10","1002","1000","1000","1000","1000","1000","1000","1000","1000","1000","1000","1000","1000","1000","1000","1900","1000","1000","1000","1000","1100","1100","1000","1000","1000","1000"],"i":["e ","a","b","c","a","b ","c ","e","e ","e ","a ","c","e ","e","a","b","c ","e ","d ","e ","a","b","c. "]},"With reference now to , ILM is automatically located using the reference locations of ILM , ILM , and ILM . ILM , ILM and ILM can be mobile while providing reference locations for automatically determining the location of ILM . ILM is located analogously to ILM as described for , except there are different ILMs involved with doing the locating of ILM because of a different location of ILM . Note that as ILMs are located in the LN-expanse , the LN-expanse expands with additionally located MSs.","With reference now to , ILM is automatically located using the reference locations of ILM , ILM , and ILM . ILM , ILM and ILM can be mobile while providing reference locations for automatically determining the location of ILM . ILM is located analogously to ILM as described for , except there are different ILMs involved with doing the locating of ILM because of a different location of ILM .  illustrate that an MS can be located using all ILMs, rather than all DLMs (), a mixed set of DLMs and ILMs (), or fixed stationary references (). ILMs , , and are indirectly located using ILMs. Note that in the  illustrations the LN-expanse  has expanded down and to the right from DLMs directly located up and to the left. It should also be noted that locating any MS can be done with at least one other MS. Three are not required as illustrated. It is preferable that triangulation references used surround an MS.",{"@attributes":{"id":"p-0434","num":"0634"},"figref":"FIGS. 10G and 10H","b":"1002"},"With reference now to , an analysis of an LN-Expanse  will contain at least one DLM region  containing a plurality of DLMs, and at least one DLM indirectly located region  containing at least one ILM that has been located with all DLMs. Depending on the range, or scope, of an LN-Expanse , there may be a mixed region  containing at least one ILM that has been indirectly located by both an ILM and DLM, and there may be an exclusive ILM region  containing at least one ILM that has been indirectly located by all ILMs. The further in distance the LN-Expanse has expanded from DLM region  with a substantial number of MSs, the more likely there will an exclusive ILM region . NTP may be available for use in some regions, or some subset of a region, yet not available for use in others. NTP is preferably used where available to minimize communications between MSs, and an MS and service(s). An MS has the ability to make use of NTP when available.","With reference now to , all MSs depicted know their own locations. The upper left-hand portion of the illustration consists of region . As the reader glances more toward the rightmost bottom portion of the illustration, there can be regions  and regions  in the middle of the illustration. At the very rightmost bottom portion of the illustration, remaining ILMs fall in region . An ILM is indirectly located relative all DLMs, DLMs and ILMs, or all ILMs. An \u201cAffirmifier\u201d in a LN-expanse confidently knows its own location and can serve as a reference MS for other MSs. An affirmifier is said to \u201caffirmify\u201d when in the act of serving as a reference point to other MSs. A \u201cPacifier\u201d can contribute to locating other systems, but with a low confidence of its own whereabouts. The LN-Expanse is a network of located\/locatable MSs, and is preferably expanded by a substantial number of affirmifiers.",{"@attributes":{"id":"p-0437","num":"0637"},"figref":"FIG. 10I","b":["1050","1050","294","296","272","1050","1050","1050","1050","1050","8","20","36","38","22","24","26","30"]},{"@attributes":{"id":"p-0438","num":"0638"},"figref":"FIG. 11A","b":["1100","1100","1100","1100","1100","1100","1100","1100","1100","1100","1100","24","26","1100","1100","1100"],"i":["a ","a ","b","c","d","m","n","p","e ","f ","g "]},"Some fields are multi-part fields (i.e. have sub-fields). Whereabouts Data Records (WDRs)  may be fixed length records, varying length records, or a combination with field(s) in one form or the other. Some WDR embodiments will use anticipated fixed length record positions for subfields that can contain useful data, or a null value (e.g. \u22121). Other WDR embodiments may use varying length fields depending on the number of sub-fields to be populated. Other WDR embodiments will use varying length fields and\/or sub-fields which have tags indicating their presence. Other WDR embodiments will define additional fields to prevent putting more than one accessible data item in one field. In any case, processing will have means for knowing whether a value is present or not, and for which field (or sub-field) it is present. Absence in data may be indicated with a null indicator (\u22121), or indicated with its lack of being there (e.g. varying length record embodiments).","When a WDR is referenced in this disclosure, it is referenced in a general sense so that the contextually reasonable subset of the WDR of  is used. For example, when communicating WDRs (sending\/receiving data  or ) between data processing systems, a reasonable subset of WDR  is communicated in preferred embodiments as described with flowcharts. When a WDR is maintained to queue , preferably most (if not all) fields are set for a complete record, regardless if useful data is found in a particular field (e.g. some fields may be null (e.g. \u22121)). Most importantly, Whereabouts Data Records (WDRs) are maintained to queue  for maintaining whereabouts of the MS which owns queue . LBX is most effective the more timely (and continuous) a MS has valid whereabouts locally maintained. WDRs are designed for maintaining whereabouts information independent of any location technology applied. Over time, a MS may encounter a plurality of location technologies used to locate it. WDRs maintained to a first MS queue  have the following purpose:\n\n","A MS may go in and out of DLM or ILM roles as it is mobile. Direct location methods are not always available to the MS as it roams, therefore the MS preferably does all of 1 through 5 above. When the WDR  contains a MS ID field matching the MS which owns queue , that WDR contains the location (location field ) with a specified confidence (field ) at a particular time (date\/time stamp field ) for that MS. Preferably the MS ID field , date\/time stamp field and confidence field is all that is required for searching from the queue  the best possible, and most timely, MS whereabouts at the time of searching queue . Other embodiments may consult any other fields to facilitate the best possible MS location at the time of searching and\/or processing queue . The WDR queue  also maintains affirmifier WDRs, and acceptable confidence pacifier WDRs (block ), which are used to calculate a WDR having matching MS field so the MS knows its whereabouts via indirect location methods. Affirmifier and pacifier WDRs have MS ID field values which do not match the MS owning queue . This distinguishes WDRs of queue  for A) accessing the current MS location; from B) the WDRs from other MSs. All WDR fields of affirmifier and pacifier originated WDRs are of importance for determining a best location of the MS which owns queue , and in providing LBX functionality.","MS ID field is a unique handle to an MS as previously described. Depending on the installation, MS ID field may be a phone #, physical or logical address, name, machine identifier, serial number, encrypted identifier, concealable derivative of a MS identifier, correlation, pseudo MS ID, or some other unique handle to the MS. An MS must be able to distinguish its own unique handle from other MS handles in field . For indirect location functionality disclosed herein, affirmifier and pacifier WDRs do not need to have a correct originating MS ID field . The MS ID may be null, or anything to distinguish WDRs for MS locations. However, to accomplish other LBX features and functionality, MS Identifiers (MS IDs) of nearby MSs (or unique correlations thereof) maintained in queue  are to be known for processing by an MS. MS ID field may contain a group identifier of MSs in some embodiments for distinguishing between types of MSs (e.g. to be treated the same, or targeted with communications, as a group), as long as the MS containing queue  can distinguish its own originated WDRs . A defaulted value may also be set for a \u201cdo not care\u201d setting (e.g. null).","Date\/Time stamp field contains a date\/time stamp of when the WDR record  was completed by an MS for its own whereabouts prior to WDR queue insertion. It is in terms of the date\/time scale of the MS inserting the local WDR (NTP derived or not). Date\/Time stamp field may also contain a date\/time stamp of when the WDR record  was determined for the whereabouts of an affirmifier or pacifier originating record  to help an MS determine its own whereabouts, but it should still be in terms of the date\/time scale of the MS inserting the local WDR (NTP derived or not) to prevent time conversions when needed, and to promote consistent queue  searches\/sorts\/etc. The date\/time stamp field should use the best possible granulation of time, and may be in synch with other MSs and data processing systems according to NTP. A time zone, day\/light savings time, and NTP indicator is preferably maintained as part of field . The NTP indicator (e.g. bit) is for whether or not the date\/time stamp is NTP derived (e.g. the NTP use setting is checked for setting this bit when completing the WDR for queue  insertion). In some embodiments, date\/time stamp field is measured in the same granulation of time units to an atomic clock available to MSs of an LN-Expanse . When NTP is used in a LN-Expanse, identical time server sources are not a requirement provided NTP derived date\/time stamps have similar accuracy and dependability.","Location field depends on the installation of the present disclosure, but can include a latitude and longitude, cellular network cell identifier, geocentric coordinates, geodetic coordinates, three dimensional space coordinates, area described by GPS coordinates, overlay grid region identifier or coordinates, GPS descriptors, altitude\/elevation (e.g. in lieu of using field ), MAPSCO reference, physical or logical network address (including a wildcard (e.g. ip addresses 145.32.*.*)), particular address, polar coordinates, or any other two\/three dimensional location methods\/means used in identifying the MS location. Data of field is preferably a consistent measure (e.g. all latitude and longitude) for all location technologies that populate WDR queue . Some embodiments will permit using different measures to location field (e.g. latitude and longitude for one, address for another; polar coordinates for another, etc) which will be translated to a consistent measure at appropriate processing times.","Confidence field contains a value for the confidence that location field accurately describes the location of the MS when the WDR is originated by the MS for its own whereabouts. Confidence field contains a value for the confidence that location field accurately describes the location of an affirmifier or pacifier that originated the WDR. A confidence value can be set according to known timeliness of processing, communications and known mobile variables (e.g. MS speed, heading, yaw, pitch, roll, etc) at the time of transmission. Confidence values should be standardized for all location technologies used to determine which location information is of a higher\/lower confidence when using multiple location technologies (as determined by fields and ) for enabling determination of which data is of a higher priority to use in determining whereabouts. Confidence value ranges depend on the implementation. In a preferred embodiment, confidence values range from 1 to 100 (as discussed previously) for denoting a percentage of confidence. 100% confidence indicates the location field is guaranteed to describe the MS location. 0% confidence indicates the location field is guaranteed to not describe the MS location. Therefore, the lowest conceivable value of a queue  for field should be 1. Preferably, there is a lowest acceptable confidence floor value configured (by system, administrator, or user) as used at points of queue entry insertion\u2014see block  to prevent frivolous data to queue . In most cases, WDRs  contain a confidence field up to 100. In confidence value preferred embodiments, pacifiers know their location with a confidence of less than 75, and affirmifiers know their location with a confidence value 75 or greater. The confidence field is skewed to lower values as the LN-expanse  is expanded further from region . Confidence values are typically lower when ILMs are used to locate a first set of ILMs (i.e. first tier), and are then lower when the first set of ILMs are used to locate a second set of ILMs (second tier), and then lower again when the second set of ILMs are used to locate a third set of ILMs (third tier), and so on. Often, examination of a confidence value in a WDR  can indicate whether the MS is a DLM, or an ILM far away from DLMs, or an MS which has been located using accurate (high confidence) or inaccurate (low confidence) locating techniques.","Location Technology field contains the location technology used to determine the location of location field . An MS can be located by many technologies. Location Technology field can contain a value from a row of  or any other location technology used to locate a MS. WDRs inserted to queue  for MS whereabouts set field to the technology used to locate the MS. WDRs inserted to queue  for facilitating a MS in determining whereabouts set field to the technology used to locate the affirmifier or pacifier. Field also contains an originator indicator (e.g. bit) for whether the originator of the WDR  was a DLM or ILM. When received from a service that has not provided confidence, this field may be used by a DLM to determine confidence field ","Location Reference Info field preferably contains one or more fields useful to locate a MS in processing subsequent of having been inserted to queue . In other embodiments, it contains data that contributed to confidence determination. Location Reference Info field may contain information (TDOA measurement and\/or AOA measurement\u2014see inserted field for , E and C) useful to locate a MS in the future when the WDR originated from the MS for its own whereabouts. Field will contain selected triangulation measurements, wave spectrum used and\/or particular communications interfaces , signal strength(s), TDOA information, AOA information, or any other data useful for location determination. Field can also contain reference whereabouts information () to use relative a TDOA or AOA (otherwise WDR location field assumed as reference). In one embodiment, field contains the number of DLMs and ILMs which contributed to calculating the MS location to break a tie between using WDRs with the same confidence values. In another embodiment, a tier of ILMs used to locate the MS is maintained so there is an accounting for the number of ILMs in the LN-expanse between the currently located MS and a DLM. In other embodiments, MS heading, yaw, pitch and roll, or accelerometer values are maintained therein, for example for antenna AOA positioning. When wave spectrum frequencies or other wave characteristics have changed in a transmission used for calculating a TDOA measurement, appropriate information may be carried along, for example to properly convert a time into a distance. Field should be used to facilitate correct measurements and uses, if needed conversions have not already taken place.","Communications reference information field is a multipart record describing the communications session, channel, and bind criteria between the MS and MSs, or service(s), that helped determine its location. In some embodiments, field contains unique MS identifiers, protocol used, logon\/access parameters, and useful statistics of the MSs which contributed to data of the location field . An MS may use field for WDRs originated from affirmifiers and pacifiers for subsequent LBX processing.","Speed field contains a value for the MS speed when the WDR is originated by the MS for its own whereabouts. Speed field may contain a value for speed of an affirmifier or pacifier when the WDR was originated elsewhere. Speed is maintained in any suitable units.","Heading field contains a value for the MS heading when the WDR is originated by the MS for its own whereabouts. Heading field may contain a value for heading of an affirmifier or pacifier when the WDR was originated elsewhere. Heading values are preferably maintained in degrees up to 360 from due North, but is maintained in any suitable directional form.","Elevation field contains a value for the MS elevation (or altitude) when the WDR is originated by the MS for its own whereabouts. Elevation field may contain a value for elevation (altitude) of an affirmifier or pacifier when the WDR was originated elsewhere. Elevation (or altitude) is maintained in any suitable units.","Application fields contains one or more fields for describing application(s) at the time of completing, or originating, the WDR . Application fields may include field(s) for:\n\n","Correlation field is optionally present in a WDR when the WDR is in a transmission between systems (e.g. wireless communications) such as in data  or . Field provides means for correlating a response to an earlier request, or to correlate a response to an earlier broadcast. Correlation field contains a unique handle. In a LN-expanse which globally uses NTP, there is no need for correlation in data  or . Correlation field may be present in WDRs of queues  or . Alternatively, a MS ID is used for correlation.","Sent date\/time stamp field is optionally present in a WDR when the WDR is in transmission between systems (e.g. wireless communications) such as in data  or . Field contains when the WDR was transmitted. A time zone, day\/light savings time, and NTP indicator is preferably maintained as part of field . Field is preferably not present in WDRs of queue  (but can be if TDOA measurement calculation is delayed to a later time). In some embodiments, there is no need for field . Whereabouts determined for MSs of an LN-Expanse may be reasonably timely, facilitating simplicity of setting outbound field to the transmission date\/time stamp at the sending data processing system, rather than when the WDR was originally completed for whereabouts (e.g. when substantially the same time anyway). Sent date\/time field may be present in WDRs of queues  or .","Received date\/time stamp field is preferably present in a WDR when inserted to queue  by receiving thread(s) upon received data  or . Field contains when the WDR was received by the MS. A time zone, day\/light savings time, and NTP indicator is preferably maintained as part of field . Field is preferably not present in WDRs of queue  (but can be if TDOA measurement calculation is delayed to a later time). In some embodiments, there is no need for field . For example, thread(s)  may be listening directly on applicable channel(s) and can determine when the data is received. In another embodiment, thread(s)  process fast enough to determine the date\/time stamp of when data  or  is received since minimal time has elapsed between receiving the signal and determining when received. In fact, known processing duration between when received and when determined to be received can be used to correctly alter a received date\/time stamp. Received date\/time stamp field is preferably added to records placed to queue  by receiving thread(s) feeding queue .","Any fields of WDR  which contain an unpredictable number of subordinate fields of data preferably use a tagged data scheme, for example an X.409 encoding for a Token, Length, and Value (called a TLV encoding). Therefore, a WDR , or field therein, can be a variable sized record. For example, Location Reference info field may contain TTA, 8, 0.1456 where the Token=\u201cTTA\u201d for Time Till Arrival (TDOA measurement between when sent and when received), Length=8 for 8 bytes to follow, and Value=0.1456 in time units contained within the 8 bytes; also SS, 4, 50 where Token=\u201cSignal Strength\u201d, 4=4 for 4 bytes to follow, and Value=50 dBu for the signal strength measurement. This allows on-the-fly parsing of unpredictable, but interpretable, multipart fields. The TLV encoding also enables-on-the-fly configuration for parsing new subordinate fields to any WDR  field in a generic implementation, for example in providing parse rules to a Lex and Yacc implementation, or providing parse rules to a generic top down recursive TLV encoding parser and processor.","Any field of WDR  may be converted: a) prior to insertion to queue ; or b) after access to queue ; or c) by queue  interface processing; for standardized processing. Any field of WDR  may be converted when sending\/receiving\/broadcasting, or related processing, to ensure a standard format. Other embodiments will store and access values of WDR  field(s) which are already in a standardized format. WDR  fields can be in any order, and a different order when comparing what is in data transmitted versus data maintained to queue .","An alternate embodiment to WDRs maintained to queue  preserves transport fields , and\/or , for example for use on queue . This would enable  thread(s) to perform TDOA measurements that are otherwise calculated in advance and kept in field . However, queue  size should be minimized and the preferred embodiment uses transport fields when appropriate to avoid carrying them along to other processing.",{"@attributes":{"id":"p-0459","num":"0693"},"figref":["FIGS. 11B","FIG. 11B"],"b":["11","11","1000","1000","1000","1000","1000","1000","22","2","22","22","2"],"i":["e","e ","e","e ","e ","e"],"sub":["4","5","6 ","j","j ","j ","j ","j ","j","j ","4 ","5 ","6 "]},"With reference now to , a triangulation of MS at location  is explained using location (whereabouts)  of MS, location (whereabouts)  of MS, and location (whereabouts)  of MS. Signal transmission distance from MSlocations are represented by the radiuses, with rthe TDOA measurement (time difference between when sent and when received) between MSand MS , with rthe TDOA measurement (time difference between when sent and when received) between MSand MS , with rthe TDOA measurement (time difference between when sent and when received) between MSand MS . In this example, the known locations of MSwhich are used to determine the location of MS allow triangulating the MS whereabouts using the TDOA measurements. In fact, less triangular data in the illustration can be necessary for determining a highly confident whereabouts of MS ","With reference now to , a triangulation of MS at location  is explained using location (whereabouts)  of MS, location (whereabouts)  of MS, and location (whereabouts)  of MS. In some embodiments, AOA measurements taken at a positioned antenna of MS at location  are used relative the whereabouts , whereabouts , whereabouts  (AOA , AOA  and AOA ), wherein AOA measurements are detected for incoming signals during known values for MS heading  with MS yaw, pitch, and roll (or accelerometer readings). AOA triangulation is well known in the art. Line segment  represents the direction of signal arrival to the antenna at whereabouts  from MSat whereabouts . Line segment  represents the direction of signal arrival to the antenna at whereabouts  from MSat whereabouts . Line segment  represents the direction of signal arrival to the antenna at whereabouts  from MSat whereabouts . In this example, the known locations of MSwhich are used to determine the location of MS allow triangulating the MS whereabouts using the AOA measurements. In fact, less triangular data in the illustration can be necessary for determining a highly confident whereabouts of MS . Alternative embodiments will use AOA measurements of outbound signals from the MS at whereabouts  detected at antennas of whereabouts  and\/or  and\/or .",{"@attributes":{"id":"p-0462","num":"0696"},"figref":"FIGS. 11C and 11D","b":["952","954","1106","1110","1114"],"ul":{"@attributes":{"id":"ul0029","list-style":"none"},"li":{"@attributes":{"id":"ul0029-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0030","list-style":"none"},"li":["1) AAS=two angles and a side;","2) ASA=two angles and a common side;","3) SAS=two sides and the included angle; or","4) SSA=two sides and a non-included angle.\n\nTDOA measurements are distances (e.g. time difference between when sent and when received), and AOA measurements are angles. Each of the four conditions are recognized (e.g. block  above), and data is passed for each of the four conditions for processing (e.g. block  above). For AAS (#) and ASA (#), processing (e.g. block ) finds the third angle by subtracting the sum of the two known angles from 180 degrees (i.e. using mathematical law that triangles' interior angles add up to 180 degrees), and uses the mathematical law of Sines (i.e. a\/sin A=b\/sin B=c\/sin C) twice to find the second and third sides after plugging in the knowns and solving for the unknowns. For SAS (#), processing (e.g. block ) uses the mathematical law of Cosines (i.e. a=b+c\u22122bc cos A) to find the third side, and uses the mathematical law of Sines (sin A\/a=sin B\/b=sin C\/c (derived from law of Sines above)) to find the second angle. For SSA (#), processing (e.g. block ) uses the mathematical law of Sines (i.e. (sin A\/a=sin B\/b=sin C\/c) twice to get the second angle, and mathematical law of Sines (a\/sin A=b\/sin B=c\/sin C) to get the third side. Those skilled in the art recognize other useful trigonometric functions and formulas, and similar uses of the same trigonometric functions, for MPT depending on what data is known. The data discovered and processed depends on an embodiment, what reference locations are available, and which parts are missing for MPT. MPT uses different distances (time used to determine length in TDOA) and\/or angles (from AOA or TDOA technologies) for deducing a MS location confidently (e.g. MPT). Even a single AOA measurement from a known reference location (stationary or MS) with a single TDOA measurement relative that reference location can be used to confidently locate a MS, and triangulation measurements used to deduce a MS location need not be from the same location technologies or wave spectrums. Those skilled in the art recognize that having known reference locations facilitates requiring less triangular information for deducing a MS location confidently. MPT examples include using information from any aforementioned wave spectrums, or any heterogeneous combinations thereof, for example to leverage useful, or available, data from different wave spectrums and\/or location technologies (see heterogeneous locating discussions).\n"]}}}},{"@attributes":{"id":"p-0463","num":"0701"},"figref":["FIG. 11E","FIG. 9A"],"ul":{"@attributes":{"id":"ul0031","list-style":"none"},"li":{"@attributes":{"id":"ul0031-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0032","list-style":"none"},"li":["More than one location technology is used during travel of the MS;","More than one location technology is used to determine a single whereabouts of the MS;","MPT is used to locate the MS; and\/or","ADLT is used to locate the MS.\n\nThe WDR queue  and interactions between MSs as described below cause the MS to be heterogeneously located without special consideration to any particular location technology. While WDR  contains field , field provides a standard and generic measurement for evaluating WDRs from different location technologies, without concern for the location technology used. The highest confidence entries to a WDR queue  are used regardless of which location technology contributed to the WDR queue .\n"]}}}},{"@attributes":{"id":"p-0464","num":"0706"},"figref":["FIG. 12","FIG. 12","FIG. 19"],"b":["1202","1204","1206","32","1208","1206","26","24","1304","1302","1304","1314","1302","1312","32"]},"If block  determines NTP is enabled (as defaulted or last set by a user (i.e. persistent variable)), then block  initializes NTP appropriately and processing continues to block . If block  determines NTP was not enabled, then processing continues to block . Block  embodiments are well known in the art of NTP implementations (also see block ). Block  may cause the starting of thread(s) associated with NTP. In some embodiments, NTP use is assumed in the MS. In other embodiments, appropriate NTP use is not available to the MS. Depending on the NTP embodiment, thread(s) may pull time synchronization information, or may listen for and receive pushed time information. Resources  (or other MS local resource) provides interface to an MS clock for referencing, maintaining, and generating date\/time stamps at the MS. After block  processing, the MS clock is synchronized to NTP. Because of initialization of the MS in , block  may rely on a connected service to initially get the startup synchronized NTP date\/time. MS NTP processing will ensure the NTP enabled\/disabled variable is dynamically set as is appropriate (using semaphore access) because an MS may not have continuous clock source access during travel when needed for resynchronization. If the MS does not have access to a clock source when needed, the NTP use variable is disabled. When the MS has (or again gets) access to a needed clock source, then the NTP use variable is enabled.","Thereafter, block  creates shared memory to maintain data shared between processes\/threads, block  initializes persistent data to shared memory, block  initializes any non-persistent data to shared memory (e.g. some statistics ), block  creates system queues, and block  creates semaphore(s) used to ensure synchronous access by concurrent threads to data in shared memory, before continuing to block . Shared memory data accesses appropriately utilize semaphore lock windows (semaphore(s) created at block ) for proper access. In one embodiment, block  creates a single semaphore for all shared memory accesses, but this can deteriorate performance of threads accessing unrelated data. In the preferred embodiment, there is a semaphore for each reasonable set of data of shared memory so all threads are fully executing whenever possible. Persistent data is that data which maintains values during no power, for example as stored to persistent storage . This may include data  (including permissions , charters , statistics , service directory ), data , LBX history , data , resources , and\/or other data. Persistent data preferably includes at least the DLMV (see DLM role(s) list Variable below), ILMV (see ILM role(s) list Variable below), process variables xx-Max values (xx=, , , ,  and  (see  discussions below)) for the last configured maximum number of threads to run in the respective process, process variables xx-PID values (xx=, , , ,  and  (see  discussions below)) for multi-purpose of: a) holding an Operating System Process Identifier (i.e. O\/S PID) for a process started; and b) whether or not the respective process was last enabled (i.e. PID>0) or disabled (i.e. PID<=0), the confidence floor value (see ), the WTV (see Whereabouts Timeliness Variable (see FIG. A)), the NTP use variable (see ) for whether or not NTP was last set to disabled or enabled (used at block ), and the Source Periodicity Time Period (SPTP) value (see ). There are reasonable defaults for each of the persistent data prior to the first use of MS  (e.g. NTP use is disabled, and only becomes enabled upon a successful enabling of NTP at least one time). Non-persistent data may include data involved in some regard to data  (and subsets of permissions , charters , statistics , service directory ), data , LBX history , data , resources , queues, semaphores, etc. Block  creates queues , , and . Queues  and  are also created there if required. Queues  and  are not required when NTP is in use globally by participating data processing systems. Alternate embodiments may use less queues by threads sharing a queue and having a queue entry type field for directing the queue entry to the correct thread. Alternate embodiments may have additional queues for segregating entries of a queue disclosed for best possible performance. Other embodiments incorporate queues figuratively to facilitate explanation of interfaces between processing.","All queues disclosed herein are understood to have their own internally maintained semaphore for queue accesses so that queue insertion, peeking, accessing, etc uses the internally maintained semaphore to ensure two or more concurrently executing threads do not corrupt or misuse data to any queue. This is consistent with most operating system queue interfaces wherein a thread stays blocked (preempted) after requesting a queue entry until a queue entry appears in the queue. Also, no threads will collide with another thread when inserting, peeking, or otherwise accessing the same queue. Therefore, queues are implicitly semaphore protected. Other embodiments may use an explicit semaphore protected window around queue data accessing, in which case those semaphore(s) are created at block .","Thereafter, block  checks for any ILM roles currently enabled for the MS (for example as determined from persistent storage of an ILM role(s) list Variable (ILMV) preferably preconfigured for the MS at first use, or configured as last configured by a user of the MS). ILM roles are maintained to the ILM role(s) list Variable (ILMV). The ILMV contains one or more entries for an ILM capability (role), each entry with a flag indicating whether it is enabled or disabled (marked=enabled, unmarked=disabled). If block  determines there is at least one ILM role enabled (i.e. as marked by associated flag), then block  artificially sets the corresponding xx-PID variables to a value greater than 0 for indicating the process(es) are enabled, and are to be started by subsequent  initialization processing. The xx-PID will be replaced with the correct Process Identifier (PID) upon exit from block  after the process is started. Preferably, every MS can have ILM capability. However, a user may want to (configure) ensure a DLM has no ILM capability enabled (e.g. or having no list present). In some embodiments, by default, every MS has an unmarked list of ILM capability maintained to the ILMV for 1) USE DLM REFERENCES and 2) USE ILM REFERENCES. USE DLM REFERENCES, when enabled (marked) in the ILMV, indicates to allow the MS of  processing to determine its whereabouts relative remote DLMs. USE ILM REFERENCES, when enabled (marked) in the ILMV, indicates to allow the MS of  processing to determine its whereabouts relative remote ILMs. Having both list items marked indicates to allow determining MS whereabouts relative mixed DLMs and ILMs. An alternative embodiment may include a USE MIXED REFERENCES option for controlling the MS of  processing to determine its whereabouts relative mixed DLMs and\/or ILMs. Alternative embodiments will enforce any subset of these options without exposing user configurations, for example on a MS without any means for being directly located.","For any of the ILMV roles of USE DLM REFERENCES, USE ILM REFERENCES, or both, all processes , , , ,  and  are preferably started (i.e. -PID, -PID, -PID, -PID, -PID and -PID are artificially set at block  to cause subsequent process startup at block ). Characteristics of an anticipated LN-expanse (e.g. anticipated location technologies of participating MSs, MS capabilities, etc) will start a reasonable subset of those processes with at least process  started. Block  continues to block . If block  determines there are no ILMV role(s) enabled, then block processing continues to block .","Block  initializes an enumerated process name array for convenient processing reference of associated process specific variables described in , and continues to block  where the first member of the set is accessed for subsequent processing. The enumerated set of process names has a prescribed start order for MS architecture . Thereafter, if block  determines the process identifier (i.e. xx-PID such that xx is , , , , ,  in a loop iteration of blocks  through ) is greater than 0 (e.g. this first iteration of -PID>0 implies it is to be started here; also implies process  is enabled as used in , , A and B), then block  spawns (starts) the process (e.g. ) of  to start execution of subordinate worker thread(s) (e.g. process  thread(s)) and saves the real PID (Process Identifier) to the PID variable (e.g. -PID) returned by the operating system process spawn interface. Block  passes as a parameter to the process of  which process name to start (e.g. ), and continues to block . If block  determines the current process PID variable (e.g. -PID) is not greater than 0 (i.e. not to be started; also implies is disabled as used in , , A and B), then processing continues to block . Block  checks if all process names of the enumerated set (pattern of xx) have been processed (iterated) by blocks  through . If block  determines that not all process names in the set have been processed (iterated), then processing continues back to block  for handling the next process name in the set. If block  determines that all process names of the enumerated set were processed, then block  checks the DLMV (DLM role(s) list Variable). Blocks  through  iterate every process name of  to make sure that each is started in accordance with non-zero xx-PID variable values at  initialization.","Block  checks for any DLM roles currently enabled for the MS (for example as determined from persistent storage of a DLM role(s) list Variable (DLMV) preferably preconfigured for the MS at first use if the MS contains DLM capability). DLM capability (roles), whether on-board at the MS, or determined during MS travels (see block ), is maintained to the DLM role(s) list Variable (DLMV). The DLMV contains one or more entries for a DLM capability (role), each (role) entry with a flag indicating whether it is enabled or disabled (marked=enabled, unmarked=disabled). If block  determines there is at least one DLM role enabled (i.e. as marked by associated flag), then block  initializes enabled role(s) appropriately and processing continues to block . Block  may cause the starting of thread(s) associated with enabled DLM role(s), for DLM processing above (e.g. ). Block  may invoke API(s), enable flag(s), or initialize as is appropriate for DLM processing described above. Such initializations are well known in the art of prior art DLM capabilities described above. If block  determines there are no DLM roles to initialize at the MS, then processing continues to block . Any of the  technologies are eligible in the DLMV as determined to be present at the MS and\/or as determined by historical contents of the WDR queue  (e.g. location technology field with MS ID field for this MS) and\/or determined by LBX history . Application Programming Interfaces (APIs) may also be used to determine MS DLM capability (role(s)) for entry(s) to the DLMV.","Block  completes LBX character initialization, and  initialization processing terminates thereafter at block . Depending on what threads were started as part of block , Block  may startup the preferred number of listen\/receive threads for feeding queue  and the preferred number of send threads for sending data inserted to queue , in particular when transmitting new data  and receiving new data  or . The number of threads started should be optimal for parallel processing across applicable channel(s). Upon encounter of block , the MS is appropriately operational, and a user at the MS of  processing will have the ability to use the MS and applicable user interfaces thereof.","With reference now to , depicted is a flowchart for describing a preferred embodiment of a process for starting a specified number of threads in a specified thread pool.  is in itself an O\/S process, has a process identifier (PID) after being started, will contain at least two threads of processing after being started, and is generic in being able to take on the identity of any process name passed to it (e.g. xx) with a parameter (e.g. from block ).  represents the parent thread of a xx process. The  process is generic for executing any of processes xx (i.e. , , , ,  and ) with the prescribed number of worker threads using the xx-Max configuration (i.e. -Max, -Max, -Max, -Max, -Max and -Max).  will stay running until it (first all of its worker thread(s)) is terminated.  consists of an O\/S Process xx with at least a parent thread (main thread) and one worker thread (or number of worker threads for  processing as determined by xx-Max). The parent thread has purpose to stay running while all worker threads are running, and to own intelligence for starting worker threads and terminating the process when all worker threads are terminated. The worker threads are started subordinate to the  process at block  using an O\/S start thread interface.","A xx (i.e. , , , ,  and ) process starts at block  and continues to block  where the parameter passed for which process name to start (i.e. take on identity of) is determined (e.g. ). Thereafter, block  creates a RAM semaphore (i.e. operating system term for a well performing Random Access Memory (RAM) semaphore with scope only within the process (i.e. to all threads of the process)). The local semaphore name preferably uses the process name prefix (e.g. -Sem), and is used to synchronize threads within the process. RAM semaphores perform significantly better than global system semaphores. Alternate embodiments will have process semaphore(s) created at block  in advance. Thereafter, block  initializes a thread counter (e.g. -Ct) to 0 for counting the number of worker threads actually started within the xx process (e.g. ), block  initializes a loop variable J to 0, and block  starts a worker thread (the first one upon first encounter of block  for a process) in this process (e.g. process  starts worker thread , . . . , process  starts worker thread FIG. A\u2014see architecture  description below).","Thereafter, block  increments the loop variable by 1 and block  checks if all prescribed worker threads have been started. Block  accesses the xx-Max (e.g. -Max) variable from shared memory using a semaphore for determining the maximum number of threads to start in the process worker thread pool. If block  determines all worker threads have been started, then processing continues to block . If block  determines that not all worker threads have been started for the process of , then processing continues back to block  for starting the next worker thread. Blocks  through  ensure the xx-Max (e.g. -Max) number of worker threads are started within the process of .","Block  waits until all worker threads of blocks  through  have been started, as indicated by the worker threads themselves. Block  waits until the process xx-Ct variable has been updated to the prescribed xx-Max value by the started worker threads, thereby indicating they are all up and running. When all worker threads are started (e.g. -Ct=-Max), thereafter block  waits (perhaps a very long time) until the worker thread count (e.g. -Ct) has been reduced back down to 0 for indicating that all worker threads have been terminated, for example when the user gracefully powers off the MS. Block  continues to block  when all worker threads have been terminated. Block  sets the shared memory variable for the xx process (e.g. -PID) to 0 using a semaphore for indicating that the xx (e.g. ) process is disabled and no longer running. Thereafter, the xx process terminates at block . Waiting at blocks  and  are accomplished in a variety of well known methods:\n\n","Starting threads of processing in  has been presented from a software perspective, but there are hardware\/firmware thread embodiments which may be started appropriately to accomplish the same functionality. If the MS operating system does not have an interface for returning the PID at block , then  can have a block (e.g. ) used to determine its own PID for setting the xx-PID variable.",{"@attributes":{"id":"p-0478","num":"0723"},"figref":["FIGS. 13A through 13C","FIG. 13A"],"b":["200","1302","32","1304","1302","1302","1304","1302","1304","200","1306","1304","1308","200","1310","200","1311","200","1306","200","1306","200","1308","200","1310","1311","1306","200","1310","200","1311","1306","200","1311","200","1306"],"i":["a","a","a","a","a","a","a ","a ","a ","a ","a ","a "]},"In another embodiment, data  contains a Communications Key (CK)  because data  is new transmitted data in accordance with the present disclosure. Data  purpose is for carrying CK  information for being detected, parsed, and processed when received by another MS or other data processing system in the vicinity of the MS (e.g. DLM ) as determined by the maximum range of transmission .","With reference now to , a MS, for example an ILM , sends\/broadcasts data such as a data  in a manner well known to those skilled in the art. Data  and CK  are as described above for . Data  or CK  can be detected, parsed, and processed when received by another MS or other data processing system in the vicinity of the MS (e.g. ILM ) as determined by the maximum range of transmission . Transmission from the MS radiate out from it in all directions in a manner consistent with the wave spectrum used, and as described above for .","With reference now to , a service or set of services sends\/broadcasts data such as a data packet  in a manner well known to those skilled in the art, for example to service other character  processing. When a Communications Key (CK)  is embedded within data , data  is considered usual communications data (e.g. protocol, voice, or any other data over conventional forward channel, reverse channel, voice data channel, data transmission channel, or any other prior art use channel) which has been altered to contain CK . Data  contains a CK  which can be detected, parsed, and processed when received by an MS or other data processing system in the vicinity of the service(s) as determined by the maximum range of transmission . CK  permits \u201cpiggy-backing\u201d on current transmissions to accomplish new functionality as disclosed herein. Transmissions radiate out in all directions in a manner consistent with the wave spectrum used, and data carried thereon may or may not be encrypted (e.g. encrypted WDR information). The radius  represents a first range of signal reception from the service (e.g. antenna thereof), perhaps by a MS (not shown). The radius  represents a second range of signal reception from the service (e.g. antenna thereof), perhaps by a MS (not shown). The radius  represents a third range of signal reception from the service (e.g. antenna thereof), perhaps by a MS (not shown). The radius  represents a last and maximum range of signal reception from the service (e.g. antenna thereof), perhaps by a MS (not shown). The time of transmission from service to radius  is less than times of transmission from service to radiuses , , or . The time of transmission from service to radius  is less than times of transmission from service to radiuses  or . The time of transmission from service to radius  is less than time of transmission from service to radius . In another embodiment, data  contains a Communications Key (CK)  because data  is new transmitted data in accordance with the present disclosure. Data  purpose is for carrying CK  information for being detected, parsed, and processed when received by another MS or data processing system in the vicinity of the service(s) as determined by the maximum range of transmission.","In some embodiments, data  and  are prior art wireless data transmission packets with the exception of embedding a detectable CK  and\/or CK , respectively. Usual data communications of MSs are altered to additionally contain the CK so data processing systems in the vicinity can detect, parse, and process the CK. Appropriate send and\/or broadcast channel processing is used. In other embodiments, data  and  are new broadcast wireless data transmission packets for containing CK  and CK , respectively. A MS may use send queue  for sending\/broadcasting packets to data processing systems in the vicinity, and may use the receive queue  for receiving packets from other data processing systems in the vicinity. Contents of CKs (Communications Keys) depend on which LBX features are in use and the functionality intended.","In the case of \u201cpiggybacking\u201d on usual communications, receive queue  insertion processing simply listens for the usual data and when detecting CK presence, inserts CK information appropriately to queue  for subsequent processing. Also in the case of \u201cpiggybacking\u201d on usual communications, send queue  retrieval processing simply retrieves CK information from the queue and embeds it in an outgoing data  at first opportunity. In the case of new data communications, receive queue  insertion processing simply listens for the new data containing CK information, and inserts CK information appropriately to queue  for subsequent processing. Also in the case of new data communications, send queue  retrieval processing simply retrieves CK information from the queue and transmits CK information as new data.",{"@attributes":{"id":"p-0484","num":"0729"},"figref":["FIG. 14A","FIG. 14","FIG. 14","FIG. 15A","FIG. 15B","FIG. 16"],"b":["18","1402","1404","1406","1406","1902","1942","1406","1408","1408","1410","1410","1412","1406","1412","1410","1414","1414","1416","1406","1416","1414","1418","1418","1420","1406","1420","1418","1422"]},"If block  determines the user selected to maintain the WDR queue, then the user maintains WDRs at block  and processing continues back to block . Block  processing is described by . Blocks , ,  and  are understood to be delimited by appropriate semaphore control to avoid multi-threaded access problems. If block  determines the user did not select to maintain the WDR queue, then processing continues to block . If block  determines the user selected to configure the confidence floor value, then block  prepares parameters for invoking a Configure Value procedure (parameters for reference (address) of value to configure; and validity criteria of value to configure), and the Configure Value procedure of  is invoked at block  with the two (2) parameters. Thereafter, processing continues back to block . Blocks  and  are understood to be delimited by appropriate semaphore control when modifying the confidence floor value since other threads can access the floor value.","The confidence floor value is the minimum acceptable confidence value of any field (for example as checked by block ). No WDR with a field less than the confidence floor value should be used to describe MS whereabouts. In an alternative embodiment, the confidence floor value is enforced as the same value across an LN-expanse with no user control to modify it. One embodiment of  does not permit user control over a minimum acceptable confidence floor value. Various embodiments will default the floor value. Block  enforces an appropriate value in accordance with the confidence value range implemented (e.g. value from 1 to 100). Since the confidence of whereabouts is likely dependent on applications in use at the MS, the preferred embodiment is to permit user configuration of the acceptable whereabouts confidence for the MS. A new confidence floor value can be put to use at next thread(s) startup, or can be used instantly with the modification made, depending on the embodiment. The confidence floor value can be used to filter out WDRs prior to inserting to queue , filter out WDRs when retrieving from queue , filter out WDR information when listening on channel(s) prior to inserting to queue , and\/or used in accessing queue  for any reason (depending on embodiments). While confidence is validated on both inserts and queries (retrievals\/peeks), one or the other validation is fine (preferably on inserts). It is preferred that executable code incorporate checks where applicable since the confidence floor value can be changed after queue  is in use. Also, various present disclosure embodiments may maintain all confidences to queue , or a particular set of acceptable confidences.","If block  determines the user did not select to configure the confidence floor value, then processing continues to block . If block  determines the user selected to configure the Whereabouts Timeliness Variable (WTV), then block  prepares parameters for invoking the Configure Value procedure (parameters for reference (address) of value to configure; and validity criteria of value to configure), and the Configure Value procedure of  is invoked at block  with the two (2) parameters. Thereafter, processing continues back to block . Blocks  and  are understood to be delimited by appropriate semaphore control when modifying the WTV since other threads can access the WTV.","A critical configuration for MS whereabouts processing is whereabouts timeliness. Whereabouts timeliness is how often (how timely) an MS should have accurate whereabouts. Whereabouts timeliness is dependent on how often the MS is updated with whereabouts information, what technologies are available or are in the vicinity, how capable the MS is of maintaining whereabouts, processing speed(s), transmission speed(s), known MS or LN-expanse design constraints, and perhaps other factors. In some embodiments, whereabouts timeliness is as soon as possible. That is, MS whereabouts is updated whenever possible as often as possible. In fact, the present disclosure provides an excellent system and methodology to accomplish that by leveraging location technologies whenever and wherever possible. However, there should be balance when considering less capable processing of a MS to prevent hogging CPU cycles from other applications at the MS. In other embodiments, a hard-coded or preconfigured time interval is used for keeping an MS informed of its whereabouts in a timely manner. For example, the MS should know its own whereabouts at least every second, or at least every 5 seconds, or at least every minute, etc. Whereabouts timeliness is critical depending on the applications in use at the MS. For example, if MS whereabouts is updated once at the MS every 5 minutes during high speeds of travel when using navigation, the user has a high risk of missing a turn during travel in downtown cities where timely decisions for turns are required. On the other hand, if MS whereabouts is updated every 5 seconds, and an application only requires an update accuracy to once per minute, then the MS may be excessively processing.","In some embodiments, there is a Whereabouts Timeliness Variable (WTV) configured at the MS (blocks , , ). Whether it is user configured, system configured, or preset in a system, the WTV is used to:\n\n","If block  determines the user did not select to configure the WTV, then processing continues to block . If block  determines the user selected to configure the maximum number of threads in a xx process (see xx-Max variable in  discussions), then block  interfaces with the user until a valid xx-max variable is selected, and processing continues to block . If block  determines the xx process is already running (i.e. xx-PID>0 implies it is enabled), then an error is provided to the user at block , and processing continues back to block . Preferably, block  does not continue back to block  until the user acknowledges the error (e.g. with a user action). If block  determines the user selected xx process (process , process , process , process , process , or process ) is not already running (i.e. xx-PID=0 implies it is disabled), then block  prepares parameters for invoking the Configure Value procedure (parameters for reference (address) of xx-Max value to configure; and validity criteria of value to configure), and the Configure Value procedure of  is invoked at block  with the two (2) parameters. Thereafter, processing continues back to block . Blocks , ,  and  are understood to be delimited by appropriate semaphore control when modifying the xx-Max value since other threads can access it. The xx-Max value should not be modified while the xx process is running because the number of threads to terminate may be changed prior to terminating. An alternate embodiment of modifying a process number of threads will dynamically modify the number of threads in anticipation of required processing.","If block  determines the user did not select to configure a process thread maximum (xx-Max), then block  checks if the user selected to (toggle) disable or enable a particular process (i.e. a xx process of ). If block  determines the user did select to toggle enabling\/disabling a particular  process, then block  interfaces with the user until a valid xx process name is selected, and processing continues to block . If block  determines the xx process is already running (i.e. xx-PID>0 implies it is enabled), then block  prepares parameters (just as does block ). Thereafter, block  invokes  processing (just as does block ). Processing then continues back to block . If block  determines the xx process is not running (i.e. xx-PID=0 implies it is disabled), then block  invokes  processing (just as does block ). Processing then continues back to block . Block  does not continue back to block  until the process is completely terminated. Blocks , , ,  and  are understood to be delimited by appropriate semaphore control.","Preferred embodiments of blocks  and  use convenient names of processes being started or terminated, rather than convenient brief process names such as , , , , , or  used in flowcharts. In some embodiments, the long readable name is used, such as whereabouts broadcast process (), whereabouts collection process (), whereabouts supervisor process (), timing determination process (), WDR request process (), and whereabouts determination process (). For example, the user may know that the whereabouts supervisor process enabled\/disabled indicates whether or not to have whereabouts timeliness monitored in real time. Enabling the whereabouts supervisor process enables monitoring for the WTV in real time, and disabling the whereabouts supervisor process disables monitoring the WTV in real time.","In another embodiment of blocks  and , a completely new name or description may be provided to any of the processes to facilitate user interface usability. For example, a new name Peer Location Source Variable (PLSV) can be associated to the whereabouts broadcast process  and\/or . PLSV may be easier to remember. If the PLSV was toggled to disabled, the whereabouts broadcast process  and\/or  terminates. If the PLSV was toggled to enabled, the whereabouts broadcast process  and\/or  is started. It may be easier to remember that the PLSV enables\/disables whether or not to allow this MS to be a location source for other MSs in an LN-expanse.","In other embodiments, a useful name (e.g. PLSV) represents starting and terminating any subset of xx processes (a plurality (e.g.  and )) for simplicity. In yet other embodiments, FIG. A\/B can be used to start or terminate worker thread(s) in any process, for example to throttle up more worker threads in a process, or to throttle down for less worker threads in a process, perhaps modifying thread instances to accommodate the number of channels for communications, or for the desired performance. There are many embodiments for fine tuning the architecture  for optimal peer to peer interaction. In yet other embodiments, toggling may not be used. There may be individual options available at block  for setting any data of this disclosure. Similarly, the xx-Max variables may be modified via individual user friendly names and\/or as a group of xx-Max variables.","Referring back to block , if it is determined the user did not select to toggle for enabling\/disabling process(es), then processing continues to block . If block  determines the user selected to exit FIG. A\/B configuration processing, then block  terminates the user interface appropriately and processing terminates at block . If block  determines the user did not select to exit the user interface, then processing continues to block  of  by way of off page connector .","With reference now to , depicted is a continued portion flowchart of  for describing a preferred embodiment of MS LBX configuration processing. If block  determines the user selected to configure the Source Periodicity Time Period (SPTP) value, then block  prepares parameters for invoking the Configure Value procedure (parameters for reference (address) of value to configure; and validity criteria of value to configure), and the Configure Value procedure of  is invoked at block  with the two (2) parameters. Thereafter, processing continues back to block  by way of off page connector . Blocks  and  are understood to be delimited by appropriate semaphore control when modifying the SPTP value since other threads can access it. The SPTP configures the time period between broadcasts by thread(s) , for example 5 seconds. Some embodiments do not permit configuration of the SPTP.","If block  determines the user did not select to configure the SPTP value, then processing continues to block . If block  determines the user selected to configure service propagation, then the user configures service propagation at block  and processing continues back to block  by way of off page connector . If block  determines the user did not select to configure service propagation, then processing continues to block .","If block  determines the user selected to configure permissions , then the user configures permissions at block  and processing continues back to block  by way of off page connector . If block  determines the user did not select to configure permissions , then processing continues to block . If block  determines the user selected to configure charters , then the user configures charters  at block  and processing continues back to block  by way of off page connector . If block  determines the user did not select to configure charters , then processing continues to block . If block  determines the user selected to configure statistics , then the user configures statistics  at block  and processing continues back to block  by way of off page connector . If block  determines the user did not select to configure statistics , then processing continues to block . If block  determines the user selected to configure service informant code , then the user configures code  at block  and processing continues back to block  by way of off page connector . If block  determines the user did not select to configure code , then processing continues to block . If block  determines the user selected to maintain LBX history , then the user maintains LBX history at block  and processing continues back to block  by way of off page connector . If block  determines the user did not select to maintain LBX history , then processing continues to block .","Block  handles other user interface actions leaving block , and processing continues back to block  by way of off page connector .","Details of blocks , , , , , , and perhaps more detail to block , are described with other flowcharts. Appropriate semaphores are requested at the beginning of block processing, and released at the end of block processing, for thread safe access to applicable data at risk of being accessed by another thread of processing at the same time of configuration. In some embodiments, a user\/administrator with secure privileges to the MS has ability to perform any subset of configurations of  processing, while a general user may not. Any subset of  configuration may appear in alternative embodiments, with or without authenticated administrator access to perform configuration.",{"@attributes":{"id":"p-0501","num":"0749"},"figref":["FIG. 15A","FIG. 15C"],"b":["1412","1502","1504","1506","1506","1508","1518","22","1508","1508","1518","1506","1510","1512","1514"]},"Block  determines if there were any changes to the DLMV from  processing by comparing the DLMV after block  with the DLMV saved at block . If there were changes via  processing, such as a role which was enabled prior to block  which is now disabled, or such as a role which was disabled prior to block  which is now enabled, then block  continues to block  which handles the DLMV changes appropriately. Block  continues to block  which terminates  processing. If block  determines there were no changes via block , then processing terminates at block .","Block  enables newly enabled role(s) as does block  described for . Block  disables newly disabled role(s) as does block  described for .",{"@attributes":{"id":"p-0504","num":"0752"},"figref":["FIG. 15B","FIG. 15C"],"b":["1416","1522","1524","1526","1526","1528","1538","1528","1528","1538","1526","1530","1532","1534"]},"Block  determines if there were any changes to the ILMV from  processing by comparing the ILMV after block  with the ILMV saved at block . If there were changes via  processing, such as a role which was enabled prior to block  which is now disabled, or such as a role which was disabled prior to block  which is now enabled, then block  continues to block  which handles the ILMV changes appropriately. Block  continues to block  which terminates  processing. If block  determines there were no changes via block , then processing terminates at block .","Block  enables newly enabled role(s) as does blocks  through  described for . Block  disables newly disabled role(s) as does blocks  through  described for .",{"@attributes":{"id":"p-0507","num":"0755"},"figref":["FIG. 15C","FIG. 15A","FIG. 15B","FIG. 15C","FIG. 15C","FIG. 15C"],"b":["1552","1554","1554","1556","1554","1556","1558","1560","1554","1558","1562","1562","1564","1554","1562","1566","1566","1568","1554","1566","1570"]},{"@attributes":{"id":"p-0508","num":"0756"},"figref":["FIG. 15C","FIG. 15A","FIG. 15B"]},{"@attributes":{"id":"p-0509","num":"0757"},"figref":"FIG. 16","b":["1420","1602","1604","1606","1608","1608","1610","1608","1612","1614","1606","1612","2828"]},"If block  determines the user did not respond for disabling NTP, then block  checks for a toggle to being enabled. If block  determines the user wanted to enable NTP use, then block  accesses known NTP server address(es) (e.g. ip addresses preconfigured to the MS, or set with another user interface at the MS), and pings each one, if necessary, at block  with a timeout. As soon as one NTP server is determined to be reachable, block  continues to block . If no NTP server was reachable, then the timeout will have expired for each one tried at block  for continuing to block . Block  determines if at least one NTP server was reachable at block . If block  determines no NTP server was reachable, then an error is presented to the user at block  and processing continues back to block . Preferably, the error presented at block  requires the user to acknowledge the error before block  continues to block . If block  determines that at least one NTP server was reachable, then block  initializes NTP use appropriately, block  sets the NTP use setting to enabled (and saves), and processing continues back to block . Block  enables NTP as does block .","Referring back to block , if it is determined the user did not want to enable NTP use, then processing continues to block  where it is checked if the user wanted to exit  processing. If block  determines the user did not select to exit  processing, then processing continues to block  where other user interface actions leaving block  are appropriately handled, and then processing continues back to block . If block  determines the user did select to exit processing, then  processing terminates at block .",{"@attributes":{"id":"p-0512","num":"0760"},"figref":["FIG. 17","FIG. 17","FIG. 17","FIG. 17","FIG. 17"],"b":["1424","1702","1704","22","1704","1706","1732","1706","1706","1732","1704","1708","22","1708","1708","1708","1710","1710","1712","22","1714","1708","22","1712","1716","1716","22","1718","1708","1716","1720","22","1720","1722","22","1708","1720","1724","1708","1724","1726","1708","1724","1728","1728","1730","1710","1708","1728","1732"]},"There are many embodiments for maintaining WDRs of queue . In some embodiments,  (i.e. block ) processing is only provided for debug of an MS. In a single instance WDR embodiment, block  presents the one and only WDR which is used to keep current MS whereabouts whenever possible. Other embodiments incorporate any subset of  processing.",{"@attributes":{"id":"p-0514","num":"0762"},"figref":["FIG. 18","FIG. 18","FIG. 18","FIG. 18"],"b":["1430","1802","1804"]},"Block  continues to block  where the current value passed is presented to the user (e.g. confidence floor value), and then to block  for awaiting user action. When a user action is detected at block , block  checks if the user selected to modify the value, in which case block  interfaces with the user for a validated value using the validity criteria parameter before continuing back to block . Validity criteria may take the form of a value range, value type, set of allowable values, or any other criteria for what makes the value a valid one.","If block  determines the user did not select to modify the value, then block  checks if the user wanted to exit  processing. If block  determines the user did not select to exit  processing, then processing continues to block  where other user interface actions leaving block  are appropriately handled, and then processing continues back to block . If block  determines the user did select to exit processing, then  processing appropriately returns to the caller at block .",{"@attributes":{"id":"p-0517","num":"0765"},"figref":["FIG. 19","FIG. 19"],"b":["1900","1902","1912","1922","1932","1942","1952","6","19","1902","1912","1922","1932","1942","1952","19","1902","1912","1922","1932","1942","1952"],"ul":{"@attributes":{"id":"ul0037","list-style":"none"},"li":{"@attributes":{"id":"ul0037-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0038","list-style":"none"},"li":["1) \u201cparent thread\u201d; and","2) \u201cworker thread\u201d.\n\nA parent thread () is the main process thread for:\n","starting the particular process;","starting the correct number of worker thread(s) of that particular process;","staying alive while all worker threads are busy processing; and","properly terminating the process when worker threads are terminated.\n\nThe parent thread is indeed the parent for governing behavior of threads at the process whole level. Every process has a name for convenient reference, such as the names , , , ,  and . Of course, these names may take on the associated human readable forms of whereabouts broadcast process, whereabouts collection process, whereabouts supervisor process, timing determination process, WDR request process, and whereabouts determination process, respectively. For brevity, the names used herein are by the process label of  in a form xx. There must be at least one worker thread in a process. Worker thread(s) are described with a flowchart as follows:\n",{"@attributes":{"id":"ul0038-0007","num":"0772"},"b":"1902","figref":"FIG. 20"},{"@attributes":{"id":"ul0038-0008","num":"0773"},"b":"1912","figref":"FIG. 21"},{"@attributes":{"id":"ul0038-0009","num":"0774"},"b":"1922","figref":"FIG. 22"},{"@attributes":{"id":"ul0038-0010","num":"0775"},"b":"1932","figref":"FIG. 23"},{"@attributes":{"id":"ul0038-0011","num":"0776"},"b":"1942","figref":"FIG. 25"},{"@attributes":{"id":"ul0038-0012","num":"0777"},"b":["1952","1900"],"figref":"FIG. 26A","br":{}},"1) \u201cSlave to Queue\u201d; and","2) \u201cSlave to Timer\u201d."]}}}},"A xx process is a slave to queue process when its worker thread(s) are driven by feeding from a queue of architecture . A slave to queue process stays \u201cblocked\u201d (O\/S terminology \u201cblocked\u201d=preempted) on a queue entry retrieval interface until the sought queue item is inserted to the queue. The queue entry retrieval interface becomes \u201ccleared\u201d (O\/S terminology \u201ccleared\u201d=clear to run) when the sought queue entry is retrieved from the queue by a thread. These terms (blocked and cleared) are analogous to a semaphore causing a thread to be blocked, and a thread to be cleared, as is well known in the art. Queues have semaphore control to ensure no more than one thread becomes clear at a time for a single queue entry retrieved (as done in an O\/S). One thread sees a particular queue entry, but many threads can feed off the same queue to do the same work concurrently. Slave to queue type of processes are , ,  and . A slave to queue process is properly terminated by inserting a special termination queue entry for each worker thread to terminate itself after queue entry retrieval.","A xx process is a slave to timer process when its worker thread(s) are driven by a timer for peeking a queue of architecture . A timer provides the period of time for a worker thread to sleep during a looped iteration of checking a queue for a sought entry (without removing the entry from the queue). Slave to timer threads periodically peek a queue, and based on what is found, will process appropriately. A queue peek does not alter the peeked queue. The queue peek interface is semaphore protected for preventing peeking at an un-opportune time (e.g. while thread inserting or retrieving from queue). Queue interfaces ensure one thread is acting on a queue with a queue interface at any particular time. Slave to timer type of processes are  and . A slave to timer process is properly terminated by inserting a special termination queue entry for each worker thread to terminate itself by queue entry peek.","Block  knows the type of xx process for preparing the process type parameter for invocation of  at block . The type of process has slightly different termination requirements because of the worker thread(s) processing type. Alternate embodiments of slave to timer processes will make them slave to queue processes by simply feeding off Thread Request (TR) queue  for driving a worker thread when to execute (and when to terminate). New timer(s) would insert timely queue entries to queue , and processes  and  would retrieve from the queue (FIG. A record ). The queue entries would become available to queue  when it is time for a particular worker thread to execute. Worker threads of processes  and  could retrieve, and stay blocked on, queue  until an entry was inserted by a timer for enabling a worker thread (field set to  or ). TR queue  is useful for starting any threads of architecture  in a slave to queue manner. This may be a cleaner architecture for all thread pools to operate the same way (slave to queue). Nevertheless, the two thread pool methods are implemented.","Each xx process has at least four (4) variables for describing present disclosure processing:\n\n","Receive (Rx) queue  is for receiving CK  or CK  data (e.g. WDR or WDR requests), for example from wireless transmissions. Queue  will receive at least WDR information (destined for threads ) and WDR requests ( records  destined for threads ). At least one thread (not shown) is responsible for listening on appropriate channel(s) and immediately depositing appropriate records to queue  so that they can be processed by architecture . Preferably, there is a plurality (pool) of threads for feeding queue  based on channel(s) being listened on, and data  or  anticipated for being received. Alternative embodiments of thread(s)  may themselves directly be listening on appropriate channels and immediately processing packets identified, in lieu of a queue . Alternative embodiments of thread(s)  may themselves directly be listening on appropriate channels and immediately processing packets identified, in lieu of a queue . Queue  is preferred to isolate channel(s) (e.g. frequency(s)) and transmission reception processing in well known modular (e.g. Radio Frequency (RF)) componentry, while providing a high performance queue interface to other asynchronous threads of architecture  (e.g. thread(s) of process ). Wave spectrums (via particular communications interface ) are appropriately processed for feeding queue . As soon as a record is received by an MS, it is assumed ready for processing at queue . All queue  accesses are assumed to have appropriate semaphore control to ensure synchronous access by any thread at any particular time to prevent data corruption and misuse. Queue entries inserted to queue  may have arrived on different channel(s), and in such embodiments a channel qualifier may further direct queue entries from queue  to a particular thread  or  (e.g. thread(s) dedicated to channel(s)). In other embodiments, receive processing feeds queue  independent of any particular channel(s) monitored, or received on (the preferred embodiment described). Regardless of how data is received and then immediately placed on queue , a received date\/time stamp (e.g. fields or ) is added to the applicable record for communicating the received date\/time stamp to a thread (e.g. thread(s)  or ) of when the data was received. Therefore, the queue  insert interface tells the waiting thread(s) when the data was actually received. This ensures a most accurate received date\/time stamp as close to receive processing as possible (e.g. enabling most accurate TDOA measurements). An alternate embodiment could determine applicable received date\/time stamps in thread(s)  or thread(s) . Other data placed into received WDRs are: wave spectrum and\/or particular communications interface  of the channel received on, and heading\/yaw\/pitch\/roll (or accelerometer readings) with AOA measurements, signal strength, and other field eligible data of the receiving MS. Depending on alternative embodiments, queue  may be viewed metaphorically for providing convenient grounds of explanation.","Send (Tx) queue  is for sending\/communicating CK  data, for example for wireless transmissions. At least one thread (not shown) is responsible for immediately transmitting (e.g. wirelessly) anything deposited to queue . Preferably, there is a plurality (pool) of threads for feeding off of queue  based on channel(s) being transmitted on, and data  anticipated for being sent. Alternative embodiments of thread(s) of processes , ,  and  may themselves directly transmit (send\/broadcast) on appropriate channels anything deposited to queue , in lieu of a queue . Queue  is preferred to isolate channel(s) (e.g. frequency(s)) and transmission processing in well known modular (e.g. RF) componentry, while providing a high performance queue interface to other asynchronous threads of architecture  (e.g. thread(s) ). Wave spectrums and\/or particular communications interface  are appropriately processed for sending from queue . All queue  accesses are assumed to have appropriate semaphore control to ensure synchronous access by any thread at any particular time to prevent data corruption and misuse. As soon as a record is inserted to queue , it is assumed sent immediately. Preferably, fields sent depend on fields set. Queue entries inserted to queue  may contain specification for which channel(s) to send on in some embodiments. In other embodiments, send processing feeding from queue  has intelligence for which channel(s) to send on (the preferred embodiment described). Depending on alternative embodiments, queue  may be viewed metaphorically for providing convenient grounds of explanation.","When interfacing to queue , the term \u201cbroadcast\u201d refers to sending outgoing data in a manner for reaching as many MSs as possible (e.g. use all participating communications interfaces ), whereas the term \u201csend\u201d refers to targeting a particular MS or group of MSs.","WDR queue  preferably contains at least one WDR  at any point in time, for at least describing whereabouts of the MS of architecture . Queue  accesses are assumed to have appropriate semaphore control to ensure synchronous access by any thread at any particular time to prevent data corruption and misuse. A single instance of data embodiment of queue  may require an explicit semaphore control for access. In a WDR plurality maintained to queue , appropriate queue interfaces are again provided to ensure synchronous thread access (e.g. implicit semaphore control). Regardless, there is still a need for a queue  to maintain a plurality of WDRs from remote MSs. The preferred embodiment of all queue interfaces uses queue interface maintained semaphore(s) invisible to code making use of queue (e.g. API) interfaces. Depending on alternative embodiments, queue  may be viewed metaphorically for providing convenient grounds of explanation.","Thread Request (TR) queue  is for requesting processing by either a timing determination (worker) thread of process  (i.e. thread ) or whereabouts determination (worker) thread of process  (i.e. thread ). When requesting processing by a thread , TR queue  has requests (retrieved via processing  after insertion processing ) from a thread  to initiate TDOA measurement. When requesting processing by a thread , TR queue  has requests (retrieved via processing  after insertion processing  or ) from a thread  or  so that thread  performs whereabouts determination of the MS of architecture . Requests of queue  comprise records . Preferably, there is a plurality (pool) of threads  for feeding queue  (i.e. feeding from queue ), and for feeding a plurality each of threads  and  from queue . All queue  accesses are assumed to have appropriate semaphore control to ensure synchronous access by any thread at any particular time to prevent data corruption and misuse. Depending on alternative embodiments, queue  may be viewed metaphorically for providing convenient grounds of explanation.","With reference now to , depicted is an illustration for describing a preferred embodiment of a thread request queue record, as maintained to Thread Request (TR) queue . TR queue  is not required when a LN-expanse globally uses NTP, as found in thread xx processing described for architecture , however it may be required at a MS which does not have NTP, or a MS which interacts with another data processing system (e.g. MS) that does not have NTP. Therefore, TR queue record  (i.e. queue entry ) may, or may not, be required. This is the reason  does not depict queue . When NTP is in use globally (in LN-expanse), TDOA measurements can be made using a single unidirectional data ( or ) packet containing a sent date\/time stamp (of when the data was sent). Upon receipt, that sent date\/time stamp received is compared with the date\/time of receipt to determine the difference. The difference is a TDOA measurement. Knowing transmission speeds with a TDOA measurement allows calculating a distance. In this NTP scenario, no thread(s)  are required.","Threads  and\/or DLM processing may always insert the MS whereabouts without requirement for thread(s)  by incorporating thread  logic into thread , or by directly starting (without queue ) a thread  from a thread . Therefore, threads  may not be required. If threads  are not required, queue  may not be required by incorporating thread  logic into thread , or by directly starting (without queue ) a thread  from a thread . Therefore, queue  may not be required, and threads  may not be required.","Records  (i.e. queue entries ) contain a request type field and data field . Request type field simply routes the queue entry to destined thread(s) (e.g. thread(s)  or thread(s) ). A thread  remains blocked on queue  until a record  is inserted which has a field containing the value . A thread  remains blocked on queue  until a record  is inserted which has a field containing the value . Data field is set to zero (0) when type field contains  (i.e. not relevant). Data field contains an MS ID (field ) value, and possibly a targeted communications interface  (or wave spectrum if one to one), when type field contains . Field will contain information for appropriately targeting the MS ID with data (e.g. communications interface to use if MS has multiple of them). An MS with only one communications interface can store only a MS ID in field ","Records  are used to cause appropriate processing by xx threads (e.g.  or ) as invoked when needed (e.g. by thread(s) ). Process  is a slave to queue type of process, and there are no queue  entries  which will not get timely processed by a thread . No interim pruning is necessary to queue .","With reference now back to , Correlation Response (CR) queue  is for receiving correlation data for correlating requests transmitted in data  with responses received in data  or . Records  are inserted to queue  (via processing ) from thread(s)  so that thread(s)  (after processing ) correlate data  or  with requests sent by thread(s)  (e.g. over interface ), for the purpose of calculating a TDOA measurement. Additionally, records  are inserted to queue  (via processing ) from thread(s)  so that thread(s)  (after processing ) correlate data  or  with requests sent by thread(s)  (e.g. over interface ), for the purpose of calculating a TDOA measurement. Preferably, there is a plurality (pool) of threads for feeding queue  and for feeding from queue  (feeding from queue  with thread(s) ). All queue  accesses are assumed to have appropriate semaphore control to ensure synchronous access by any thread at any particular time to prevent data corruption and misuse. Depending on alternative embodiments, queue  may be viewed metaphorically for providing convenient grounds of explanation.","With reference now to , depicted is an illustration for describing a preferred embodiment of a correlation response queue record, as maintained to Correlation Response (CR) queue . CR queue  is not required when a LN-expanse globally uses NTP, as found in thread xx processing described for architecture , however it may be required at a MS which does not have NTP, or a MS which interacts with another data processing system (e.g. MS) that does not have NTP. Therefore, CR record  (i.e. queue entry ) may, or may not, be required. This is the reason  does not depict queue . The purpose of CR queue  is to enable calculation of TDOA measurements using correlation data to match a request with a response. When NTP is used globally in the LN-expanse, no such correlations between a request and response is required, as described above. In the NTP scenario, thread(s)  can deduce TDOA measurements directly from responses (see ), and there is no requirement for threads .","TDOA measurements are best taken using date\/time stamps as close to the processing points of sending and receiving as possible, otherwise critical regions of code may be required for enabling process time adjustments to the measurements when processing is \u201cfurther out\u201d from said points. This is the reason MS receive processing provides received date\/time stamps with data inserted to queue  (field or ). In a preferred embodiment, send queue  processing inserts to queue  so the date\/time stamp field for when sent is as close to just prior to having been sent as possible. However, there is still the requirement for processing time spent inserting to queue  prior to sending anyway. Anticipated processing speeds of architecture  allow reasonably moving sent date\/time stamp setting just a little \u201cfurther out\u201d from actually sending to keep modular send processing isolated. A preferred embodiment (as presented) assumes the send queue  interface minimizes processing instructions from when data is placed onto queue  and when it is actually sent, so that the sending thread(s) xx (, ,  and ) insert to queue  with a reasonably accurate sent\/date stamp field . This ensures a most accurate sent date\/time stamp (e.g. enabling most accurate TDOA measurements). An alternate embodiment makes appropriate adjustments for more accurate time to consider processing instructions up to the point of sending after queue  insertion.","Records  (i.e. queue entries ) contain a date\/time stamp field and a correlation data field . Date\/time stamp field contains a date\/time stamp of when a request (data ) was sent as set by the thread inserting the queue entry . Correlation data field contains unique correlation data (e.g. MS id with suffix of unique number) used to provide correlation for matching sent requests (data ) with received responses (data  or ), regardless of the particular communications interface(s) used (e.g. different wave spectrums supported by MS). Upon a correlation match, a TDOA measurement is calculated using the time difference between field and a date\/time stamp of when the response was received (e.g. field ). A thread  accesses queue  for a record  using correlation field to match, when data  or  contains correlation data for matching. A thread  then uses the field to calculate a TDOA measurement. Process  is not a slave to queue  (but is to queue ). A thread  peeks queue  for a matching entry when appropriate. Queue  may contain obsolete queue entries  until pruning is performed. Some WDR requests may be broadcasts, therefore records  may be used for correlating a plurality of responses. In another record  embodiment, an additional field is provided for specification of which communication interface(s) and\/or channel(s) to listen on for a response.","With reference now back to , any reasonable subset of architecture  processing may be incorporated in a MS. For example in one minimal subset embodiment, a DLM which has excellent direct locating means only needs a single instance WDR (queue ) and a single thread  for broadcasting whereabouts data to facilitate whereabouts determination by other MSs. In a near superset embodiment, process  processing may be incorporated completely into process , thereby eliminating processing  by having threads  feed from queue  for WDR requests as well as WDR information. In another subset embodiment, process  may only send requests to queue  for responses, or may only start a thread  for determining whereabouts of the MS. There are many viable subset embodiments depending on the MS being a DLM or ILM, capabilities of the MS, LN-expanse deployment design choices, etc. A reference to  accompanies thread xx flowcharts (, , , ,  and A). The user, preferably an administrator type (e.g. for lbxPhone\u2122 debug) selectively configures whether or not to start or terminate a process (thread pool), and perhaps the number of threads to start in the pool (see ). Starting a process (and threads) and terminating processes (and threads) is shown in flowcharts A and B. There are other embodiments for properly starting and terminating threads without departing from the spirit and scope of this disclosure.","LBX of data may also be viewed as LBX of objects, for example a WDR, WDR request, TDOA request, AOA request, charters, permissions, data record(s), or any other data may be viewed as an object. A subset of an object or data may also be viewed as an object.","While a consumer ready lbxPhone\u2122 preferably incorporates a multithreaded architecture  using an optimized O\/S kernel and communications interfaces in hardware (\u201cburned in\u201d well tested semiconductor(s) microcode) for maximum performance, some LBX enabled MSs may integrate the functionality as close to a MS O\/S kernel as is reasonable for a particular MS (e.g. with modifiable software, pluggable microcode chip, etc). Still other MSs may provide plug-in adaptability for LBX processing, perhaps even at an application layer. For example, Apple may provide LBX processing, or a subset thereof, as an \u201cApp\u201d (application) in their \u201cApp Store\u201d for customer download to an iPhone when the MS (iPhone) contains sufficient performance and\/or interfaces to provide optimal performance. There are many examples for carrying out the LBX architecture.",{"@attributes":{"id":"p-0538","num":"0804"},"figref":["FIG. 20","FIG. 20","FIG. 20"],"b":["1902","6","1902","1444","1902","2016","24"]},"In an alternative embodiment having multiple transmission channels visible to process , there can be a worker thread  per channel to handle broadcasting on multiple channels. If thread(s)  (block ) do not transmit directly over the channel themselves, this embodiment would provide means for communicating the channel for broadcast to send processing when interfacing to queue  (e.g. incorporate a channel qualifier field with WDR inserted to queue ). This embodiment could allow specification of at least one (1) worker thread per channel, however multiple worker threads configurable for process  as appropriated for the number of channels configurable for broadcast.","Processing begins at block , continues to block  where the process worker thread count -Ct is accessed and incremented by 1 (using appropriate semaphore access (e.g. -Sem)), and continues to block  for peeking WDR queue  for a special termination request entry. Block  may also check the -Ct value, and signal the process  parent thread that all worker threads are running when -Ct reaches -Max. Thereafter, if block  determines that a worker thread termination request was not found in queue , processing continues to block . Block  peeks the WDR queue  (using interface ) for the most recent highest confidence entry for this MS whereabouts by searching queue  for: the MS ID field matching the MS ID of  processing, and a confidence field greater than or equal to the confidence floor value, and a most recent NTP enabled date\/time stamp field within a prescribed trailing period of time (e.g. preferably less than or equal to 2 seconds). For example, block  peeks the queue (i.e. makes a copy for use if an entry found for subsequent processing, but does not remove the entry from queue) for a WDR of this MS (i.e. MS of  processing) which has the greatest confidence over 75 and has been most recently inserted to queue  with an NTP date\/time stamp in the last 2 seconds. Date\/time stamps for MS whereabouts which are not NTP derived have little use in the overall palette of process xx choices of architecture  because receiving data processing systems (e.g. MSs) will have no means of determining an accurate TDOA measurement in the unidirectional transmission from an NTP disabled MS. A receiving data processing system will still require a bidirectional correlated exchange with the MS of  processing to determine an accurate TDOA measurement in its own time scale (which is accomplished with thread(s)  pulling WDR information anyway). An alternate embodiment to block  will not use the NTP indicator as a search criteria so that receiving data processing systems can receive to a thread , and then continue for appropriate correlation processing, or can at least maintain whereabouts to queue  to know who is nearby.","Thread  is of less value to the LN-expanse when it broadcasts outdated\/invalid whereabouts of the MS to facilitate locating other MSs. In an alternate embodiment, a movement tolerance (e.g. user configured or system set (e.g. 3 meters)) is incorporated at the MS, or at service(s) used to locate the MS, for knowing when the MS has significantly moved (e.g. more than 3 meters) and how long it has been (e.g. 45 seconds) since last significantly moving. In this embodiment, the MS is aware of the period of time since last significantly moving and the search time criteria is set using the amount of time since the MS significantly moved (whichever is greater). This way a large number of (perhaps more confident candidates) WDRs are searched in the time period when the MS has not significantly moved. Optional blocks  through  may have been incorporated to  for movement tolerance processing just described, in which case the LWT is compared to the current date\/time of block  processing to adjust block  search time criteria for the correct trailing period. In any case, a WDR is sought at block  which will help other MSs in the LN-expanse locate themselves, and to let other MSs know who is nearby.","Thereafter, if block  determines a useful WDR was found, then block  prepares the WDR for send processing, block  broadcasts the WDR information (using send interface ) by inserting to queue  so that send processing broadcasts data  (e.g. on all available communications interface(s) ), for example as far as radius , and processing continues to block . The broadcast is for reception by data processing systems (e.g. MSs) in the vicinity. At least fields , , , and are broadcast. See  descriptions. Fields are set to the following upon exit from block :\n\n","Block  causes thread  to sleep according to the SPTP setting (e.g. a few seconds). When the sleep time has elapsed, processing continues back to block  for another loop iteration of blocks  through . Referring back to block , if a useful WDR was not found (e.g. candidates too old), then processing continues to block . Referring back to block , if a worker thread termination request entry was found at queue , then block  decrements the worker thread count by 1 (using appropriate semaphore access (e.g. -Sem)), and thread  processing terminates at block . Block  may also check the -Ct value, and signal the process  parent thread that all worker threads are terminated when -Ct equals zero (0).","Block  causes broadcasting data  containing CK  wherein CK  contains WDR information prepared as described above for block . Alternative embodiments of block  may not search a specified confidence value, and broadcast the best entry available anyway so that listeners in the vicinity will decide what to do with it. A semaphore protected data access (instead of a queue peek) may be used in embodiments where there is always one WDR current entry maintained for the MS.","In the embodiment wherein usual MS communications data  of the MS is altered to contain CK  for listening MSs in the vicinity, send processing feeding from queue , caused by block  processing, will place WDR information as CK  embedded in usual data  at the next opportune time of sending usual data . If an opportune time is not timely, send processing should discard the send request of block  to avoid broadcasting outdated whereabouts information (unless using a movement tolerance and time since last significant movement). As the MS conducts its normal communications, transmitted data  contains new data CK  to be ignored by receiving MS other character  processing, but to be found by listening MSs within the vicinity which anticipate presence of CK . Otherwise, when LN-Expanse deployments have not introduced CK  to usual data  communicated on a receivable signal by MSs in the vicinity,  sends repeated timely pulsed broadcasts of new data  (per SPTP) for MSs in the vicinity of the first MS to receive. In any case, appropriate implementation should ensure field is as accurate as possible for when data  is actually sent.","An alternate embodiment to architecture  for elimination of process  incorporates a trigger implementation for broadcasting MS whereabouts at the best possible time\u2014i.e. when the MS whereabouts is inserted to queue . As soon as a new (preferably NTP enabled) WDR candidate becomes available, it can be broadcast at a new block  of . (e.g. new block  continued to from block  and then continuing to block ). Fields are set as described above for . Preferably, the new block  starts an asynchronous thread consisting of blocks  and  so that  processing performance is not impacted. In a further embodiment, block  can be further enhanced using the SPTP value to make sure that too many broadcasts are not made. The SPTP (Source Periodicity Time Period) could be observed for getting as close as possible to broadcasting whereabouts in accordance with SPTP (e.g. worst case there are not enough broadcasts).",{"@attributes":{"id":"p-0547","num":"0827"},"figref":["FIG. 21","FIG. 21","FIG. 21"],"b":["1912","6","1912","1444","1912","1900","26","26"]},"In an alternative embodiment having multiple receiving transmission channels visible to process  (e.g. thread(s)  receiving directly), there can be a worker thread  per channel to handle receiving on multiple channels simultaneously. If thread(s)  do not receive directly from the channel, the preferred embodiment of  would not need to convey channel information to thread(s)  waiting on queue  anyway. Embodiments could allow specification\/configuration of many thread(s)  per channel.","Processing begins at block , continues to block  where the process worker thread count -Ct is accessed and incremented by 1 (using appropriate semaphore access (e.g. -Sem)), and continues to block  for interim housekeeping of pruning the WDR queue by invoking a Prune Queues procedure of . Block  may also check the -Ct value, and signal the process  parent thread that all worker threads are running when -Ct reaches -Max. Block  may not be required since block  can cause queue  pruning (block ).","Thereafter, block  retrieves from queue  a WDR (using interface ), perhaps a special termination request entry, or a WDR received in data  (CK ) or data  (CK ), and only continues to block  when a WDR has been retrieved. Block  stays blocked on retrieving from queue  until any WDR is retrieved. If block  determines that a special WDR indicating to terminate was not found in queue , processing continues to block . Block  adjusts date\/time stamp field if necessary depending on NTP use in the LN-expanse and adjusts the confidence field accordingly. In a preferred embodiment, fields and for the WDR in process is set as follows for certain conditions:\n\n","If at block , the WDR confidence field is not greater than the confidence floor value, then processing continues back to block . If block  determines that the WDR field is satisfactory, then block  initializes a TDOA_FINAL variable to False, and block  checks if the WDR from block  contains correlation (field ).","If block  determines the WDR does not contain correlation, then block  accesses the ILMV, block  determines the source (ILM or DLM) of the WDR using the originator indicator of field , and block  checks suitability for collection of the WDR. While processes xx running are generally reflective of the ILMV roles configured, it is possible that the more descriptive nature of ILMV role(s) not be one to one in relationship to xx processes, in particular depending on the subset of architecture  in use. Block  is redundant anyway because of block . If block  determines the ILMV role is disabled for collecting this WDR, then processing continues back to block . If block  determines the ILMV role is enabled for collecting this WDR, then processing continues to block .","If block  determines both the first (sending) and second (receiving) MS are NTP enabled (i.e. Fields , and are NTP indicated) OR if TDOA_FINAL is set to True (as arrived to via block ), then block  completes the WDR for queue  insertion, block  prepares parameters for  processing and block  invokes  processing (interface ). Parameters set at block  are: WDRREF=a reference or pointer to the WDR completed at block ; DELETEQ= location queue discard processing; and SUPER= supervisory notification processing. Block  calculates a TDOA measurement whenever possible and inserts to field . See  descriptions. Fields are set to the following upon exit from block :\n\n","Block  continues to block  where a record  is built (i.e. field = and field is set to null (e.g. \u22121)) and then block  inserts the record  to TR queue  (using interface ) so that a thread  will perform processing. Blocks  and  may be replaced with an alternative embodiment for starting a thread . Block  continues back to block .","Referring now back to block , if it is determined that a TDOA measurement cannot be made (i.e. (field or not NTP indicated) OR if TDOA_FINAL is set to False), then block  checks if the WDR contains a MS ID (or pseudo MS ID). If block  determines there is none, then processing continues back to block  because there is no way to distinguish one MS from another with respect to the WDR retrieved at block  for directing bidirectional correlation. An alternate embodiment will use a provided correlation field received at block , instead of a field , for knowing how to target the originating MS for TDOA measurement processing initiated by a thread . If block  determines there is a usable MS ID (or correlation field), then block  builds a record  (field =, field =the MS ID (or pseudo MS ID, or correlation) and particular communications interface from field (if available) of the WDR of block , and block  inserts the record  to queue  (interface ) for starting a thread . Block  continues back to block . An alternate embodiment causes block  to continue directly to block  (no block ) for a No condition from block . Regardless of whether the originating MS ID can be targeted, a correlation (in lieu of an MS ID) may be used when the MS responds with a broadcast. The WDR request made by thread  can be a broadcast rather than a targeted request. Thread(s)  can handle sending targeted WDR requests (to a known MS ID) and broadcast WDR requests.","Referring back to block , if it is determined the WDR does contain correlation (field ), block  peeks the CR queue  (using interface ) for a record  containing a match (i.e. field matched to field ). Thereafter, if block  determines no correlation was found on queue  (e.g. response took too long and entry was pruned), then processing continues to block  already described. If block  determines the correlation entry was found (i.e. thread  received a response from an earlier request (e.g. from a thread  or ), then block  uses date\/time stamp field (from block ) with field (e.g. from block ) to calculate a TDOA measurement in time scale of the MS of  processing, and sets field appropriately in the WDR. Note that correlation field is valid across all available MS communications interfaces (e.g. all supported active wave spectrums). The TDOA measurement considers duration of time between the earlier sent date\/time of record  and the later time of received date\/time field . The TDOA measurement may further be altered at block  processing time to a distance knowing the velocity of the wave spectrum used as received to queue . Block  continues to block  where the TDOA_FINAL variable is set to True, then to block  for processing already described.","Referring back to block , if a WDR for a worker thread termination request was found at queue , then block  decrements the worker thread count by 1 (using appropriate semaphore access (e.g. -Sem)), and thread  processing terminates at block . Block  may also check the -Ct value, and signal the process  parent thread that all worker threads are terminated when -Ct equals zero (0).","In the embodiment wherein usual MS communications data  of the MS is altered to contain CK  or  for listening MSs in the vicinity, receive processing feeding queue  will place WDR information to queue  as CK  or  is detected for being present in usual communication data  or . As normal communications are conducted, transmitted data  or  contains new data CK  or  to be ignored by receiving MS other character  processing, but to be found by listening MSs within the vicinity which anticipate presence of CK  or . Otherwise, when LN-Expanse deployments have not introduced CK  (or ) to usual data  (or ) communicated on a receivable signal by MSs in the vicinity,  receives new data  (or ) sent. In any case, field should be as accurate as possible for when data  (or ) was actually received. Critical regions of code and\/or anticipated execution timing may be used to affect a best setting of field ","So,  is responsible for maintaining whereabouts of others to queue  with data useful for triangulating itself.",{"@attributes":{"id":"p-0560","num":"0862"},"figref":["FIG. 22","FIG. 22","FIG. 22","FIG. 22","FIG. 22","FIG. 22"],"b":["1922","6","1922","1952","2218","2224","2226","2228","1444","1922","2224","24"]},"In an alternative embodiment having multiple transmission channels visible to process , there can be a worker thread  per channel to handle broadcasting on multiple channels. If thread(s)  (block ) do not transmit directly over the channel, this embodiment would provide means for communicating the channel for broadcast to send processing when interfacing to queue  (e.g. incorporate a channel qualifier field with WDR request inserted to queue ). This embodiment could allow specification of one (1) thread per channel, however multiple worker threads configurable for process  as determined by the number of channels configurable for broadcast.","Processing begins at block , continues to block  where the process worker thread count -Ct is accessed and incremented by 1 (using appropriate semaphore access (e.g. -Sem)), and continues to block  for interim housekeeping of pruning the CR queue by invoking a Prune Queues procedure of . Block  may also check the -Ct value, and signal the process  parent thread that all worker threads are running when -Ct reaches -Max. Block  continues to block  for peeking WDR queue  (using interface ) for a special termination request entry. Thereafter, if block  determines that a worker thread termination request was not found in queue , processing continues to block . Block  peeks the WDR queue  (using interface ) for the most recent highest confidence entry for this MS whereabouts by searching queue  for: the MS ID field matching the MS ID of  processing, and a confidence field greater than or equal to the confidence floor value, and a most recent date\/time stamp field within a prescribed trailing period of time of block  search processing using a function of the WTV (i.e. f(WTV)=short-hand for \u201cfunction of WTV\u201d) for the period. For example, block  peeks the queue (i.e. makes a copy for use if an entry found for subsequent processing, but does not remove the entry from queue) for a WDR of the first MS which has the greatest confidence over 75 and has been most recently inserted to queue  in the last 3 seconds. Since the MS whereabouts accuracy may be dependent on timeliness of the WTV, it is recommended that the f(WTV) be some value less than or equal to WTV, but preferably not greater than the WTV. Thread  is of less value to the MS when not making sure in a timely manner the MS is maintaining timely whereabouts for itself. In an alternate embodiment, a movement tolerance (e.g. user configured or system set (e.g. 3 meters)) is incorporated at the MS, or at service(s) used to locate the MS, for knowing when the MS has significantly moved (e.g. more than 3 meters) and how long it has been (e.g. 45 seconds) since last significantly moving. In this embodiment, the MS is aware of the period of time since last significantly moving and the f(WTV) is set using the amount of time since the MS significantly moved (i.e. f(WTV)=as described above, or the amount of time since significantly moving, whichever is greater). This way a large number of (perhaps more confident candidates) WDRs are searched in the time period when the MS has not significantly moved. Optional blocks  through  may have been incorporated to  for movement tolerance processing just described, in which case the LWT is compared to the current date\/time to adjust the WTV for the correct trailing period. In any case, a WDR is sought at block  which will verify whether or not MS whereabouts are current.","Thereafter, if block  determines a satisfactory WDR was found, then processing continues to block . Block  causes thread  to sleep according to a f(WTV) (preferably a value less than or equal to the WTV (e.g. 95% of WTV)). When the sleep time has elapsed, processing continues back to block  for another loop iteration of blocks  through .","If block  determines a current WDR was not found, then block  builds a WDR request (e.g. containing record  with field for the MS of  processing (MS ID or pseudo MS ID) so receiving MSs in the LN-expanse know who to respond to, and field with appropriate correlation for response), block  builds a record  (using correlation generated for the request at block ), block  inserts the record  to queue  (using interface ), and block  broadcasts the WDR request (record ) for responses. Absence of field indicates to send processing feeding from queue  to broadcast on all available comm. interfaces .","With reference now to , depicted is an illustration for describing a preferred embodiment of a WDR request record, as communicated to queue  or . When a LN-expanse globally uses NTP, as found in thread xx processing described for architecture , a WDR request record  may, or may not, be required. TDOA calculations can be made using a single unidirectional data ( or ) packet containing a sent date\/time stamp (of when the data was sent) as described above.","Records  contain a MS ID field and correlation field . MS ID field contains an MS ID (e.g. a value of field ). An alternate embodiment will contain a pseudo MS ID (for correlation), perhaps made by a derivative of the MS ID with a unique (suffix) portion, so that receiving MSs can directly address the MS sending the request without actually knowing the MS ID (i.e. they know the pseudo MS ID which enables the MS to recognize originated transmissions). Correlation data field contains unique correlation data (e.g. MS id with suffix of unique number) used to provide correlation for matching sent requests (data ) with received WDR responses (data  or ). Upon a correlation match, a TDOA measurement is calculated using the time difference between field and a date\/time stamp of when the response was received (e.g. field ). Received date\/time stamp field is added by receive processing feeding queue  when an MS received the request from another MS. Comm interface field is added by receive processing inserting to queue  for how to respond and target the originator. Many MSs do not have choices of communications interfaces, so field may not be required. If available it is used, otherwise a response can be a broadcast. Field may contain a wave spectrum identifier for uniquely identifying how to respond (e.g. one to one with communications interface), or any other value for indicating how to send given how the request was received.","With reference back to , block  builds a request that receiving MSs will know is for soliciting a response with WDR information. Block  generates correlation for field to be returned in responses to the WDR request broadcast at block . Block  also sets field to when the request was sent. Preferably, field is set as close to the broadcast as possible. In an alternative embodiment, broadcast processing feeding from queue  makes the record  and inserts it to queue  with a most accurate time of when the request was actually sent. Fields are to be as accurate as possible. Block  broadcasts the WDR request data  (using send interface ) by inserting to queue  so that send processing broadcasts data , for example as far as radius . Broadcasting preferably uses all available communications interface(s)  (e.g. all available wave spectrums). Therefore, the comm interface field is not set (which implies to send processing to do a broadcast).","Block  continues to block  where a record  is built (i.e. field = and field is set to null (e.g. \u22121)) and then block  inserts the record  to TR queue  (using interface ) so that a thread  will perform processing. Blocks  and  may be replaced with an alternative embodiment for starting a thread . Block  continues back to block .","Referring back to block , if a worker thread termination request entry was found at queue , then block  decrements the worker thread count by 1 (using appropriate semaphore access (e.g. -Sem)), and thread  processing terminates at block . Block  may also check the -Ct value, and signal the process  parent thread that all worker threads are terminated when -Ct equals zero (0).","In the embodiment wherein usual MS communications data  of the MS is altered to contain CK  for listening MSs in the vicinity, send processing feeding from queue , caused by block  processing, will place the request as CK  embedded in usual data  at the next opportune time of sending usual data . This may require the alternative embodiment of adding the entry to queue  being part of send processing. As the MS conducts its normal communications, transmitted data  contains new data CK  to be ignored by receiving MS other character  processing, but to be found by listening MSs within the vicinity which anticipate presence of CK . Otherwise, when LN-Expanse deployments have not introduced CK  to usual data  communicated on a receivable signal by MSs in the vicinity,  sends new WDR request data .",{"@attributes":{"id":"p-0571","num":"0873"},"figref":["FIG. 23","FIG. 23","FIG. 23"],"b":["1932","6","1932","1444","1932","1900","1912"]},"Processing begins at block , continues to block  where the process worker thread count -Ct is accessed and incremented by 1 (using appropriate semaphore access (e.g. -Sem)), and continues to block  for interim housekeeping of pruning the CR queue by invoking a Prune Queues procedure of . Block  may also check the -Ct value, and signal the process  parent thread that all worker threads are running when -Ct reaches -Max.","Thereafter, block  retrieves from queue  a record  (using interface ), perhaps a special termination request entry, or a record  received from thread(s) , and only continues to block  when a record  containing field set to  has been retrieved. Block  stays blocked on retrieving from queue  until a record  with field = is retrieved. If block  determines a special entry indicating to terminate was not found in queue , processing continues to block .","If at block , the record  does not contain a MS ID (or pseudo MS ID) in field , processing continues to block  for building a WDR request (record ) to be broadcast, and then to block . Broadcasting preferably uses all available communications interface(s)  (e.g. all available wave spectrums). If block  determines the field is a valid MS ID (not null), block  builds a WDR request targeted for the MS ID, and processing continues to block . A targeted request is built for targeting the MS ID (and communications interface, if available) from field . Send processing is told which communications interface to use, if available (e.g. MS has multiple), otherwise send processing will target each available interface. In the unlikely case a MS ID is present in field without the communications interface applicable, then all communications interfaces  are used with the targeted MS ID. In MS embodiments with multiple communications interfaces , then is to contain the applicable communication interface for sending. Block  generates appropriate correlation for a field (e.g. to be compared with a response WDR at block ), block  sets field to the current MS date\/time stamp, block  inserts the record  to queue  (using interface ), and block  sends\/broadcasts (using interface ) a WDR request (record ). Thereafter, processing continues back to block  for another loop iteration. An alternative embodiment will only target a WDR request to a known MS ID. For example, block  would continue back to block  if no MS ID is found (=null), otherwise it will continue to block  (i.e. no use for block ).","Block  sets field to correlation to be returned in responses to the WDR request sent\/broadcast at block . Block  sets field to when the request is sent. Preferably, field is set as close as possible to when a send occurred. In an alternative embodiment, send processing feeding from queue  makes the record  and inserts it to queue  with a most accurate time of when the request was actually sent. Fields are to be as accurate as possible. Block  sends\/broadcasts the WDR request data  (using send interface ) by inserting to queue  a record  (=the targeted MS ID (or pseudo MS ID) OR null if arrived to from block , field =correlation generated at block ) so that send processing sends data , for example as far as radius . A null MS ID may be responded to by all MSs in the vicinity. A non-null MS ID is to be responded to by a particular MS. Presence of field indicates to send processing feeding from queue  to target the MS ID over the specified comm. interface (e.g. when MS has a plurality of comm. interfaces  (e.g. cellular, WiFi, Bluetooth, etc; i.e. MS supports multiple classes of wave spectrum)).","Referring back to block , if a worker thread termination request was found at queue , then block  decrements the worker thread count by 1 (using appropriate semaphore access (e.g. -Sem)), and thread  processing terminates at block . Block  may also check the -Ct value, and signal the process  parent thread that all worker threads are terminated when -Ct equals zero (0).","In the embodiment wherein usual MS communications data  of the MS is altered to contain CK  for listening MSs in the vicinity, send processing feeding from queue , caused by block  processing, will place the WDR request as CK  embedded in usual data  at the next opportune time of sending usual data . As the MS conducts its normal communications, transmitted data  contains new data CK  to be ignored by receiving MS other character  processing, but to be found by listening MSs within the vicinity which anticipate presence of CK . This may require the alternative embodiment of adding the entry to queue  being part of send processing. Otherwise, when LN-Expanse deployments have not introduced CK  to usual data  communicated on a receivable signal by MSs in the vicinity,  sends\/broadcasts new WDR request data .","An alternate embodiment to block  can wait for a response with a reasonable timeout, thereby eliminating the need for blocks  through  which is used to correlate the subsequent response (to thread ) with the request sent at block . However, this will cause a potentially unpredictable number of simultaneously executing thread(s)  when many MSs are in the vicinity.","Thread(s)  are useful when one or both parties to WDR transmission (sending and receiving MS) do not have NTP enabled. TDOA measurements are taken to triangulate the MS relative other MSs in real time.",{"@attributes":{"id":"p-0580","num":"0882"},"figref":["FIG. 25","FIG. 22","FIG. 23","FIG. 25","FIG. 22","FIG. 25","FIG. 25"],"b":["23","1942","6","1942","1444","1942","1900","26"]},"In an alternative embodiment having multiple receiving transmission channels visible to process , there can be a worker thread  per channel to handle receiving on multiple channels simultaneously. If thread(s)  do not receive directly from the channel, the preferred embodiment of  would not need to convey channel information to thread(s)  waiting on queue  anyway. Embodiments could allow specification\/configuration of many thread(s)  per channel.","Processing begins at block , continues to block  where the process worker thread count -Ct is accessed and incremented by 1 (using appropriate semaphore access (e.g. -Sem)), and continues to block  for retrieving from queue  a record  (using interface ), perhaps a special termination request entry, and only continues to block  when a record  is retrieved. Block  stays blocked on retrieving from queue  until any record  is retrieved. If block  determines a special entry indicating to terminate was not found in queue , processing continues to block . There are various embodiments for thread(s)  and thread(s)  to feed off a queue  for different record types, for example, separate queues A and B, or a thread target field with either record found at queue  (e.g. like field ). In another embodiment, thread(s)  are modified with logic of thread(s)  to handle all records described for a queue , since thread(s)  are listening for queue  data anyway.","Block  peeks the WDR queue  (using interface ) for the most recent highest confidence entry for this MS whereabouts by searching queue  for: the MS ID field matching the MS ID of  processing, and a confidence field greater than or equal to the confidence floor value, and a most recent date\/time stamp field within a prescribed trailing period of time of block  search processing (e.g. 2 seconds). For example, block  peeks the queue (i.e. makes a copy for use if an entry found for subsequent processing, but does not remove the entry from queue) for a WDR of the MS (of  processing) which has the greatest confidence over 75 and has been most recently inserted to queue  in the last 2 seconds. It is recommended that the trailing period of time used by block  be never greater than a few seconds. Thread  is of less value to the LN-expanse when it responds with outdated\/invalid whereabouts of the MS to facilitate locating other MSs. In an alternate embodiment, a movement tolerance (e.g. user configured or system set (e.g. 3 meters)) is incorporated at the MS, or at service(s) used to locate the MS, for knowing when the MS has significantly moved (e.g. more than 3 meters) and how long it has been (e.g. 45 seconds) since last significantly moving. In this embodiment, the MS is aware of the period of time since last significantly moving and the trailing period of time used by block  is set using the amount of time since the MS significantly moved, or the amount of time since significantly moving, whichever is greater. This way a large number of (perhaps more confident candidate) WDRs are searched in the time period when the MS has not significantly moved. Optional blocks  through  may have been incorporated to  for movement tolerance processing just described, in which case the LWT is compared to the current date\/time to adjust the trailing period of time used by block  for the correct trailing period. In any case, a WDR is sought at block  to satisfy a request helping another MS in the LN-expanse locate itself.","Thereafter, if block  determines a useful WDR was not found, then processing continues back to block  for another loop iteration of processing an inbound WDR request. If block  determines a useful WDR was found, then block  prepares the WDR for send processing with correlation field set from correlation field retrieved at block , and block  sends\/broadcasts (per field ) the WDR information (using send interface ) by inserting to queue  so that send processing transmits data , for example as far as radius , and processing continues back to block . At least fields , , , and are sent\/broadcast. See  descriptions. Fields are set to the following upon exit from block :\n\n","Embodiments may rely completely on the correlation field with no need for field . Referring back to block , if a worker thread termination request was found at queue , then block  decrements the worker thread count by 1 (using appropriate semaphore access (e.g. -Sem)), and thread  processing terminates at block . Block  may also check the -Ct value, and signal the process  parent thread that all worker threads are terminated when -Ct equals zero (0).","Block  causes sending\/broadcasting data  containing CK , depending on the type of MS, wherein CK  contains WDR information prepared as described above for block . Alternative embodiments of block  may not search a specified confidence value, and broadcast the best entry available anyway so that listeners in the vicinity will decide what to do with it. A semaphore protected data access (instead of a queue peek) may be used in embodiments where there is always one WDR current entry maintained for the MS.","In the embodiment wherein usual MS communications data  of the MS is altered to contain CK  for listening MSs in the vicinity, send processing feeding from queue , caused by block  processing, will place WDR information as CK  embedded in usual data  at the next opportune time of sending usual data . If an opportune time is not timely, send processing should discard the send request of block  to avoid broadcasting outdated whereabouts information (unless using a movement tolerance and time since last significant movement). As the MS conducts its normal communications, transmitted data  contains new data CK  to be ignored by receiving MS other character  processing, but to be found by listening MSs within the vicinity which anticipate presence of CK . Otherwise, when LN-Expanse deployments have not introduced CK  to usual data  communicated on a receivable signal by MSs in the vicinity,  sends\/broadcasts new WDR response data . In any case, field should be as accurate as possible for when data  is actually sent. Critical regions of code (i.e. prevent thread preemption) and\/or anticipated execution timing may be used to affect a best setting of field ","In an alternate embodiment, records  contain a sent date\/time stamp field of when the request was sent by a remote MS, and the received date\/time stamp field is processed at the MS in  processing. This would enable block  to calculate a TDOA measurement for returning in field of the WDR sent\/broadcast at block .",{"@attributes":{"id":"p-0589","num":"0905"},"figref":["FIG. 26A","FIG. 26A","FIG. 26A","FIG. 26A"],"b":["1952","6","1952","1444","1952","1900","1912","1952","19","1952"]},"Processing begins at block , continues to block  where the process worker thread count -Ct is accessed and incremented by 1 (using appropriate semaphore access (e.g. -Sem)), and continues to block  for interim housekeeping of pruning the WDR queue by invoking a Prune Queues procedure of . Block  may also check the -Ct value, and signal the process  parent thread that all worker threads are running when -Ct reaches -Max. Block  may not be necessary since pruning may be accomplished at block  when invoking  (block ).","Thereafter, block  retrieves from queue  a record  (using interface ), perhaps a special termination request entry, or a record  received from thread(s) , and only continues to block  when a record  containing field set to  has been retrieved. Block  stays blocked on retrieving from queue  until a record  with field = is retrieved. If block  determines a special entry indicating to terminate was not found in queue , processing continues to block .","Block  peeks the WDR queue  (using interface ) for the most recent highest confidence entry for this MS whereabouts by searching queue  for: the MS ID field matching the MS ID of  processing, and a confidence field greater than or equal to the confidence floor value, and a most recent date\/time stamp field within a prescribed trailing period of time of block  search processing using a f(WTV) for the period. For example, block  peeks the queue (i.e. makes a copy for use if an entry found for subsequent processing, but does not remove the entry from queue) for a WDR of the MS (of  processing) which has the greatest confidence over 75 and has been most recently inserted to queue  in the last 2 seconds. Since MS whereabouts accuracy may be dependent on timeliness of the WTV, it is recommended that the f(WTV) be some value less than or equal to WTV. In an alternate embodiment, a movement tolerance (e.g. user configured or system set (e.g. 3 meters)) is incorporated at the MS, or at service(s) used to locate the MS, for knowing when the MS has significantly moved (e.g. more than 3 meters) and how long it has been (e.g. 45 seconds) since last significantly moving. In this embodiment, the MS is aware of the period of time since last significantly moving and the f(WTV) is set using the amount of time since the MS significantly moved (i.e. f(WTV)=as described above, or the amount of time since significantly moving, whichever is greater). This way a large number of (perhaps more confident candidate) WDRs are searched in the time period when the MS has not significantly moved. Optional blocks  through  may have been incorporated to  for movement tolerance processing just described, in which case the LWT is compared to the current date\/time to adjust the WTV for the correct trailing period.","Thereafter, if block  determines a timely whereabouts for this MS already exists to queue  (current WDR found), then processing continues back to block  for another loop iteration of processing. If  determines a satisfactory WDR does not already exist in queue , then block  determines a new highest confidence WDR for this MS ( processing) using queue .","Thereafter, if block  determines a WDR was not created (BESTWDR variable=null) for the MS of  processing (by block ), then processing continues back to block . If block  determines a WDR was created (BESTWDR=WDR created by ) for the MS of  processing by block , then processing continues to block  for preparing  parameters and  processing is invoked with the new WDR at block  (for interface ) before continuing back to block . Parameters set at block  are: WDRREF=a reference or pointer to the WDR completed at block ; DELETEQ= location queue discard processing; and SUPER= supervisory notification processing.","Referring back to block , if a worker thread termination request was found at queue , then block  decrements the worker thread count by 1 (using appropriate semaphore access (e.g. -Sem)), and thread  processing terminates at block . Block  may also check the -Ct value, and signal the process  parent thread that all worker threads are terminated when -Ct equals zero (0).","Alternate embodiments to  will have a pool of thread(s)  per location technology (WDR field ) for specific WDR field(s) selective processing.  processing is shown to be generic with handling all WDRs at block .",{"@attributes":{"id":"p-0597","num":"0913"},"figref":["FIG. 26B","FIG. 26A","FIG. 26B","FIG. 26A","FIG. 26B","FIG. 26B"],"b":["2600","2630","2632"]},"Thereafter, block  peeks the WDR queue  (using interface ) for most recent WDRs by searching queue  for: confidence field greater than or equal to the confidence floor value, and a most recent date\/time stamp field within a prescribed trailing period of time of block  search processing using a f(WTV) for the period. For example, block  peeks the queue (i.e. makes a copy of all WDRs to a result list for use if any found for subsequent processing, but does not remove the entry(s) from queue) for all WDRs which have confidence over 75 and has been most recently inserted to queue  in the last 2 seconds. It is recommended that the f(WTV) used here be some value less than or equal to the WTV (want to be ahead of curve, so may use a percentage (e.g. 90%)), but preferably not greater than a couple\/few seconds (depends on MS, MS applications, MS environment, whereabouts determination related variables, etc).","In an alternative embodiment, thread(s)  coordinate with each other to know successes, failures or progress of their sister threads for automatically adjusting the trailing f(WTV) period of time appropriately. See \u201cAlternative IPC Embodiments\u201d below.","Thread  is of less value to the MS when whereabouts are calculated using stale WDRs, or when not enough useful WDRs are considered. In an alternate embodiment, a movement tolerance (e.g. user configured or system set (e.g. 3 meters)) is incorporated at the MS, or at service(s) used to locate the MS, for knowing when the MS has significantly moved (e.g. more than 3 meters) and how long it has been (e.g. 45 seconds) since last significantly moving. In this embodiment, the MS is aware of the period of time since last significantly moving and the f(WTV) is set using the amount of time since the MS significantly moved (i.e. f(WTV)=as described above, or the amount of time since significantly moving, whichever is greater). This way a large number of (perhaps more confident candidates) WDRs are searched in the time period when the MS has not significantly moved. Optional blocks  through  may have been incorporated to  for movement tolerance processing just described, in which case the LWT is compared to the current date\/time to adjust the WTV for the correct trailing period. In any case, all useful WDRs are sought at block  and placed into a list upon exit from block .","Thereafter, block  sets THIS_MS list and REMOTE_MS list sort keys to be used at blocks  and . Blocks  through  will prioritize WDRs found at block  depending on the sort keys made at block . A number of variables may be used to determine the best sort keys, such as the time period used to peek at block  and\/or the number of entries in the WDR list returned by block , and\/or other variables. When the time period of search is small (e.g. less than a couple seconds), lists (THIS_MS and REMOTE_MS) should be prioritized primarily by confidence (fields ) since any WDRs are valuable for determining whereabouts. This is the preferred embodiment.","When the time period is great, careful measure must be taken to ensure stale WDRs are not used (e.g. >few seconds, and not considering movement tolerance). Depending on decision embodiments, there will be preferred priority order sort keys created at exit from block , for example \u201ckey1\/key2\/key3\u201d implies that \u201ckey1\u201d is a primary key, \u201ckey2\u201d is a second order key, and \u201ckey3\u201d is a third order key. A key such as \u201cfield-\/field-\/field-:signal-strength\u201d would sort WDRs first by using date\/time stamp fields , then by confidence value fields (sorted within matching date\/time stamp WDRs), then by signal-strength field sub-field values (sorted within matching WDR confidences; no signal strength present=lowest priority). Another sort key may be \u201cfield-\/field-\u201d for sorting WDRs first by using confidence values, then by date\/time stamps (sorted within matching WDR confidences). The same or different sort keys can be used for lists THIS_MS and REMOTE_MS. Any WDR data (fields or subfields) can be sorted with a key, and sort keys can be of N order dimension such that \u201ckey1\/key2\/ . . . \/keyN\u201d. Whatever sort keys are used, block  will have to consider confidence versus being stale, relative to the WTV. In the preferred embodiment, the REMOTE_MS and THIS_MS lists are set with the same sort keys of \u201cfield-\/field-\u201d (i.e. peek time period used at block  is less than 2 seconds) so that confidence is primary.","Thereafter, block  gets the first (if any) WDR in the list returned at block  (also processes next WDR in list when encountered again in loop of blocks  through ), and block  checks if all WDRs have already been processed. If block  finds that all WDRs have not been processed, then block  checks the WDR origination. If block  determines the WDR is one that originated from a remote MS (i.e. MS ID does not match the MS of  processing), then block  inserts the WDR into the REMOTE_MS list using the desired sort key (confidence primary, time secondary) from block , and processing continues to block  for another loop iteration. If block  determines the WDR is one that originated from this MS (MS ID field matches the MS of  processing (e.g. this MS being a DLM at the time of WDR creation (this MS ID=field ) or this MS being an ILM at the time of WDR creation (previous processing of FIG. A)), then processing continues to block  to determine how to process the WDR which was inserted by \u201cthis MS\u201d for its own whereabouts.","Block  accesses field for data found there (e.g.  may have inserted useful TDOA measurements, even though DLM processing occurred; or  may have inserted useful TDOA and\/or AOA measurements with reference station(s) whereabouts; or receive processing may have inserted AOA and related measurements). Thereafter, if block  determines presence of TDOA and\/or AOA data, block  checks if reference whereabouts (e.g.  selected stationary reference location(s)) is also stored in field . If block  determines whereabouts information is also stored to field , then block  makes new WDR(s) from the whereabouts information containing at least the WDR Core and field containing the AOA and\/or TDOA information as though it were from a remote DLM or ILM. Block  also performs the expected result of inserting the WDR of loop processing into the THIS_MS list using the desired sort key from block . Processing then continues to block  where the newly made WDR(s) is inserted into the REMOTE_MS list using the desired sort key (confidence primary, time secondary) from block . Block  continues back to block .","Block  through  show that DLM stationary references may contribute to determining whereabouts of the MS of  processing by making such references appear to processing like remote MSs with known whereabouts. Any DLM location technology processing discussed above can facilitate  whereabouts processing when reference whereabouts can be maintained to field along with relative AOA, TDOA, MPT, confidence, and\/or other useful information for locating the MS. Various embodiments will populate field wherever possible with any useful locating fields (see data discussed for field with  discussions above) for carrying plenty of information to facilitate  processing.","Referring back to block , if it is determined that whereabouts information was not present with the AOA and\/or TDOA information of field , then processing continues to block  for inserting into the REMOTE_MS list (appropriately with sort key from block ) the currently looped WDR from block . In-range location technology associates the MS with the antenna (or cell tower) location, so that field already contains the antenna (or cell tower) whereabouts, and the TDOA information was stored to determine how close the MS was to the antenna (or cell tower) at the time. The WDR will be more useful in the REMOTE_MS list, then if added to the THIS_MS list (see loop of blocks  through ). Referring back to block , if it is determined that no AOA and\/or TDOA information was in field , then processing continues to block  for inserting the WDR into the THIS_MS list (appropriately with sort key (confidence primary, time secondary) from block ).","Block  handles WDRs that originated from the MS of  (this MS), such as described in , or results from previous  processing. Block  maintains remote DLMs and\/or ILMs (their whereabouts) to the REMOTE_MS list in hope WDRs contain useful field information for determining the whereabouts of the MS of  processing. Block  handles WDRs that originated from the MS of  processing (this MS), but also processes fields from stationary references used (e.g. ) by this MS which can be helpful as though the WDR was originated by a remote ILM or DLM. Thus, block  causes inserting to both lists (THIS_MS and REMOTE_MS) when the WDR contains useful information for both. Blocks ,  and  cause the iterative loop of blocks  through  to perform ADLT using DLMs and\/or ILMs. Alternate embodiments of blocks  through  may use peek methodologies to sort from queue  for the REMOTE_MS and THIS_MS lists.","Referring back to block , if it is determined that all WDRs in the list from block  have been processed, then block  initializes a DISTANCE list and ANGLE list each to null, block  sets a loop iteration pointer to the first entry of the prioritized REMOTE_MS list (e.g. first entry higher priority than last entry in accordance with sort key used), and block  starts the loop for working with ordered WDRs of the REMOTE_MS list. Exit from block  to block  occurs when the REMOTE_MS and THIS_MS lists are in the desired priority order for subsequent processing. Block  gets the next (or first) REMOTE_MS list entry for processing before continuing to block . If block  determines all WDRs have not yet been processed from the REMOTE_MS list, then processing continues to block .","Blocks  and  direct collection of all useful ILM triangulation measurements for TDOA, AOA, and\/or MPT triangulation of this MS relative known whereabouts (e.g. other MSs). It is interesting to note that TDOA and AOA measurements (field ) may have been made from different communications interfaces  (e.g. different wave spectrums), depending on interfaces the MS has available (i.e. all can participate). For example, a MS with blue-tooth, WiFi and cellular phone connectivity (different class wave spectrums supported) can be triangulated using the best available information (i.e. heterogeneous location technique). Examination of fields in  can show wave spectrums (and\/or particular communications interfaces ) inserted by receive processing for what the MS supports. If block  determines an AOA measurement is present (field sub-field), then block  appends the WDR to the ANGLE list, and processing continues to block . If block  determines an AOA measurement is not present, then processing continues to block . If block  determines a TDOA measurement is present (field sub-field), then block  appends the WDR to the DISTANCE list, and processing continues to block . Block  uses WDRs for providing at least an in-range whereabouts of this MS by inserting to the THIS_MS list in sorted confidence priority order (e.g. highest confidence first in list, lowest confidence at end of list). Block  continues to block . Block  may cause duplicate WDR(s) inserted to the THIS_MS list, but this will have no negative effect on selected outcome.","Block  compares the ANGLE and DISTANCE lists constructed thus far from loop processing (blocks  through ) with minimum triangulation requirements (e.g. see \u201cMissing Part Triangulation (MPT)\u201d above). Three (3) sides, three (3) angles and a side, and other known triangular solution guides will also be compared. Thereafter, if block  determines there is still not enough data to triangulate whereabouts of this MS, then processing continues back to block  for the next REMOTE_MS list entry, otherwise block  maximizes diversity of WDRs to use for triangulating. Thereafter, block  uses the diversified DISTANCE and ANGLE lists to perform triangulation of this MS, block  inserts the newly determined WDR into the THIS_MS list in sort key order, and continues back to block . Block  will use heterogeneous (MPT), TDOA and\/or AOA triangulation on ANGLE and DISTANCE lists for determining whereabouts.","Block  preferably keeps track of (or checks THIS_MS for) what it has thus far determined whereabouts for in this  thread processing to prevent inserting the same WDR to THIS_MS using the same REMOTE_MS data. Repeated iterations of blocks  through  will see the same data from previous iterations and will use the best of breed data in conjunction with each other at each iteration (in current thread context). While inserting duplicates to THIS_MS at block  does not cause failure, it may be avoided for performance reasons. Duplicate insertions are preferably avoided at block  for performance reasons as well, but they are again not harmful. Block  preferably keeps track of previous diversity order in this  thread processing to promote using new ANGLE and DISTANCE data in whereabouts determination at block  (since each iteration is a superset of a previous iteration (in current thread context)). Block  promotes using WDRs from different MSs (different MS IDs), and from MSs located at significantly different whereabouts (e.g. to maximize surrounded-ness), preferably around the MS of  processing. Block  preferably uses sorted diversity pointer lists so as to not affect actual ANGLE and DISTANCE list order. The sorted pointer lists provide pointers to entries in the ANGLE and DISTANCE lists for a unique sorted order governing optimal processing at block  to maximize unique MSs and surrounded-ness, without affecting the lists themselves (like a SQL database index). Different embodiments of blocks  through  should minimize inserting duplicate WDRs (for performance reasons) to THIS_MS which were determined using identical REMOTE_MS list data. Block  causes using ADLT at blocks  through  which uses the best of breed whereabouts, either as originated by this MS maintained in THIS_MS list up to the thread processing point of block , or as originated by remote MSs (DLMs and\/or ILMs) processed by blocks  through the start of block .","Referring back to block , if it is determined that all WDRs in the REMOTE_MS list have been processed, then block  sets the BESTWDR reference to the head of THIS_MS (i.e. BESTWDR references first WDR in THIS_MS list which is so far the best candidate WDR (highest confidence) for this MS whereabouts, or null if the list is empty). It is possible that there are other WDRs with matching confidence adjacent to the highest confidence entry in the THIS_MS list. Block  continues to block  for comparing matching confidence WDRs, and if there are matches, then breaking a tie between WDRs with matching confidence by consulting any other WDR field(s) (e.g. field signal strength, or location technology field , etc). If there is still a tie between a plurality of WDRs, then block  may average whereabouts to the BESTWDR WDR using the matching WDRs. Thereafter processing continues to block  where the BESTWDR is completed, and processing terminates at block . Block  also frees resources (if any) allocated by  processing (e.g. lists). Blocks  through  result in setting BESTWDR to the highest priority WDR (i.e. the best possible whereabouts determined). It is possible that  processing causes a duplicate WDR inserted to queue  (at block ) for this MS whereabouts determination, but that is no issue except for impacting performance to queue . An alternate embodiment to queue  may define a unique index for erring out when inserting a duplicate to prevent frivolous duplicate entries, or block  will incorporate processing to eliminate the chance of inserting a WDR of less use than what is already contained at queue . Therefore, block  may include processing for ensuring a duplicate will not be inserted (e.g. null the BESTWDR reference) prior to returning to  at block .","Averaging whereabouts at block  occurs only when there are WDRs at the head of the list with a matching highest confidence value and still tie in other WDR fields consulted, yet whereabouts information is different. In this case, all matching highest confidence whereabouts are averaged to the BESTWDR to come up with whereabouts in light of all matching WDRs. Block  performs ADLT when finalizing a single whereabouts (WDR) using any of the whereabouts found in THIS_MS (which may contain at this point DLM whereabouts originated by this MS and\/or whereabouts originated by remote DLMs and\/or ILMs). Block  must be cognizant of sort keys used at blocks  and  in case confidence is not the primary key (time may be primary).","If no WDRs were found at block , or no THIS_MS list WDRs were found at blocks  and , and no REMOTE_MS list entries were found at block ; or no THIS_MS list WDRs were found at blocks  and , and no REMOTE_MS list entries were found useful at blocks  and\/or ; then block  may be setting BESTWDR to a null reference (i.e. none in list) in which case block  does nothing. Hopefully, at least one good WDR is determined for MS whereabouts and a new WDR is inserted for this MS to queue , otherwise a null BESTWDR reference will be returned (checked at block ). See  descriptions. If BESTWDR is not null, then fields are set to the following upon exit from block :\n\n","Block  determines whereabouts using preferred guidelines, such as whereabouts determined never results in a confidence value exceeding any confidence value used to determine whereabouts. Some embodiments will use the mean (average) of confidence values used, some will use the highest, and some the lowest of the WDRs used. Preferred embodiments tend to properly skew confidence values to lower values as the LN-Expanse grows away from region . Blocks  through  may consult any of the WDR fields (e.g. field sub-fields yaw, pitch, roll; speed, heading, etc) to deduce the most useful WDR inputs for determining an optimal WDR for this MS whereabouts.","Thread(s)  are started for every WDR collected from remote MSs. Therefore, it is possible that identical new WDRs are inserted to queue  using the same WDR information at blocks  of simultaneously executing threads , but this will not cause a problem since at least one will be found when needed, and duplicates will be pruned together when appropriate. Alternative embodiments provide IPC (Interprocess Communications Processing) coordination between  threads for higher performance processing, for example:\n\n",{"@attributes":{"id":"p-0617","num":"0950"},"figref":"FIG. 26B","b":["2634","2682"]},{"@attributes":{"id":"p-0618","num":"0951"},"figref":["FIG. 27A","FIG. 27A"],"b":["2702","2704","2706","22","2708","1100","2710","2706","22","2710","2710","1990","2712","2450","2714","2710","1990","2714","2714"],"i":["b","a"]},"The current design for queue  does not require  to prune it. Alternative embodiments may add additional queues for similar processing. Alternate embodiments may use  like processing to prune queues , , or any other queue under certain system circumstances. Parameters received at block  may also include how to prune the queue, for example when using different constraints for what indicates entry(s) for discard.",{"@attributes":{"id":"p-0620","num":"0953"},"figref":"FIG. 27B","b":["1496","1496","1496","1496"],"i":["f","g","c "],"ul":{"@attributes":{"id":"ul0049","list-style":"none"},"li":{"@attributes":{"id":"ul0049-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0050","list-style":"none"},"li":["Block checks to see if the user selected to configure (set) a default for confidence value(s) used for WDRs\u2014an option for configuration at block  wherein the user action to configure it is detected at block ;","Block is processed if block determines the user did select to configure (set) a default for confidence value(s). Block invokes  for interfacing with the user accordingly, and processing then continues to block ","Block is processed if block determines the user did not select to configure (set) a default for confidence value(s), or as the result of processing leaving block . Block handles other user interface actions leaving block  (e.g. becomes the \u201ccatch all\u201d as currently shown in block  of )."]}}}},"Confidence value configuration begins at block  upon a user action to present the interface. In one embodiment, the user is an authenticated administrator prior to being permitted to get access to processing of . Block  continues to block  where all conceivable MS roles (DLM and ILM) are accessed, then to block  to ensure the MS is enabled for at least one role which can have a setting configured. Depending on an embodiment, block  may access roles which are supported, currently enabled, possible for future use, or those having other accessible characteristics. If block  determines at least one role is available to the MS, then block  accesses any default confidence values for each role determined and block  presents a list (scrollable if applicable) to the user with any settings found. Block  determines if there are any user configured defaults already configured through a prior use of . The list presented at block  will indicate when no user configuration was determined and what the current system default value is. The user can select an entry from the list, for example with a cursor, and perform a particular action on the selected entry as described below. Block  continues to block  where processing waits for certain user actions in response to the list presented. When block  detects a user action, processing continues to block .","If block  determines the user selected to modify a role default entry (e.g. which was configured at a prior use of ), then block  interfaces with the user for an updated confidence value default setting and processing continues back to block . If block  determines the action was not for modifying an existing role default entry, processing continues to block . If block  determines the user selected to add a new default to a selected role, then block  interfaces with the user for a confidence value default setting and processing continues back to block . If block  determines the action was not for adding a confidence value default to a role, processing continues to block . If block  determines the user selected to remove a user configured confidence default value for a role, then block  interfaces with the user for removal (e.g. reset back to system default setting) and processing continues back to block . If block  determines the action was not for a role confidence default value removal, processing continues to block . If block  determines the user selected to save user configured role settings resulting from  processing up to this point, then block  saves all user configured confidence default values for MS processing use, and processing continues back to block . If block  determines the action was not for saving user configurations, processing continues to block . If block  determines the user selected to exit  processing, then processing continues to block  where the user interface is appropriately terminated and to block  where  processing is terminated, otherwise processing continues to block  where other user actions leaving block  are appropriately handled, and processing then continues back to block .","Referring back to block , if no DLM or ILM roles are determined for the MS, then block  presents an error to the user and processing continues to block  and block  thereafter, already described above.","Default confidence values are the initial defaults used for setting a WDR confidence value (e.g. at blocks , , , , , , , , , , , , , , , , , etc, or any other processing block where a confidence value is defaulted based on a location technology used, logic used, or any particular location processing used), however processing may further refine or adjust the confidence as is deemed appropriate when considering circumstances relevant for a particular processing block (e.g. surrounded-ness, timeliness of WDR information used for locating, heterogeneous sources considered, or any other variable for consideration of adjustment to a confidence default). In some embodiments, the user configured default value is a hard coded numeric value. In some embodiments, the user configured default value is an offset to be incremented (added (+)) or decremented (subtracted (\u2212)) from an existing system default value. In other embodiments, the user configured default value includes an expression which elaborates to a default value or an offset to be applied to a system default. There may be a plurality of conditions specified for how to evaluate the expression.",{"@attributes":{"id":"p-0625","num":"0961"},"figref":["FIG. 28","FIG. 28","FIGS. 2A through 9B"],"b":["2802","2804","2804","2804","2804","2806"]},"Blocks  through  handle termination of all processes\/threads associated with the ILMV roles so there is no explicit ILMV check required. Block  initializes an enumerated process name array for convenient processing reference of associated process specific variables described in , and continues to block  where the first member of the set is accessed for subsequent processing. The enumerated set of process names has a prescribed termination order for MS architecture . Thereafter, if block  determines the process identifier (i.e. xx-PID such that xx is , , , , ,  in a loop iteration of blocks  through ) is greater than 0 (e.g. this first iteration of -PID>0 implies it is to be terminated here; also implies process  is enabled as used in , , A and B), then block  prepares parameters for  invocation, and block  invokes (calls) the procedure of  to terminate the process (of this current loop iteration (xx)). Block  prepares the second parameter in accordance with the type of xx process. If the process (xx) is one that is slave to a queue for dictating its processing (i.e. blocked on queue until queue entry present), then the second parameter (process type) is set to 0 (directing  processing to insert a special termination queue entry to be seen by worker thread(s) for terminating). If the process (xx) is one that is slave to a timer for dictating its processing (i.e. sleeps until it is time to process), then the second parameter (process type) is set to the associated xx-PID value (directing  to use in killing\/terminating the PID in case the worker thread(s) are currently sleeping). Block  passes the process name and process type as parameters to  processing. Upon return from , block  continues to block . If block  determines that the xx process is not enabled, then processing continues to block . Upon return from  processing, the process is terminated and the associated xx-PID variable is already set to 0 (see blocks , ,  and ).","Block  checks if all process names of the enumerated set (xx) have been processed (iterated) by blocks  through . If block  determines that not all process names in the set have been processed (iterated), then processing continues back to block  for handling the next process name in the set. If block  determines that all process names of the enumerated set were processed, then block  continues to block .","Block  destroys semaphore(s) created at block . Thereafter, block  destroys queue(s) created at block  (may have to remove all entries first in some embodiments), block  saves persistent variables to persistent storage (for example to persistent storage ), block  destroys shared memory created at block , and block  checks the NTP use variable (saved prior to destroying shared memory at block ).","If block  determines NTP is enabled, then block  terminates NTP appropriately (also see block ) and processing continues to block . If block  determines NTP was not enabled, then processing continues to block . Block  embodiments are well known in the art of NTP implementations. Block  may cause terminating of thread(s) associated with NTP use.","Block  completes LBX character termination, then block  completes other character  termination processing, and  processing terminates thereafter at block . Depending on what threads were started at block , block  may terminate the listen\/receive threads for feeding queue  and the send threads for sending data inserted to queue . Depending on what threads were started at block , block  may terminate the listen\/receive threads for feeding queue  and the send threads for sending data inserted to queue  (i.e. other character  threads altered to cause embedded CK processing). Upon encounter of block , the MS is appropriately terminated for reasons as set forth above for invoking .","With reference now to , depicted is a flowchart for describing a preferred embodiment of a procedure for terminating a process started by . When invoked by a caller, the procedure starts at block  and continues to block  where parameters passed are determined. There are two parameters: the process name to terminate, and the type of process to terminate. The type of process is set to 0 for a process which has worker threads which are a slave to a queue. The type of process is set to a valid O\/S PID when the process worker threads are slave to a timer.","Thereafter, if block  determines the process type is 0, then block  initializes a loop variable J to 0, and block  inserts a special termination request queue entry to the appropriate queue for the process worker thread to terminate. See  discussions for the queue inserted for which xx process name.","Thereafter, block  increments the loop variable by 1 and block  checks if all process prescribed worker threads have been terminated. Block  accesses the xx-Max (e.g. -Max) variable from shared memory using a semaphore for determining the maximum number of threads to terminate in the process worker thread pool. If block  determines all worker threads have been terminated, processing continues to block  for waiting until the xx-PID variable is set to disabled (e.g. set to 0 by block ), and then to block  which causes return to the caller. Block  uses a preferred choice of waiting described for blocks  and . The xx process (e.g. ) will have its xx-PID (e.g. -PID) variable set at 0 (block ) when the process terminates. In some embodiments, the waiting methodology used at block  may use the xx-PID variable, or may be signaled by the last terminating worker thread, or by block .","If block  determines that not all worker threads have been terminated yet, then processing continues back to block  to insert another special termination request queue entry to the appropriate queue for the next process worker thread to terminate. Blocks  through  insert the proper number of termination queue entries to the same queue so that all of the xx process worker threads terminate.","Referring back to block , if it is determined the process type is not 0 (i.e. is a valid O\/S PID), then block  inserts a special WDR queue  entry enabling a queue peek for worker thread termination. The reader will notice that the process termination order of block  ensures processes which were slaves to the WDR queue  have already been terminated. This allows processes which are slaves to a timer to see the special termination queue entry inserted at block  since no threads (which are slaves to queue) will remove it from queue . Thereafter, block  waits until the xx process name (parameter) worker threads have been terminated using a preferred choice of waiting described for blocks  and . The xx process (e.g. ) will have its xx-PID (e.g. -PID) variable set at 0 (block ) when the process terminates. In some embodiments, the waiting methodology used at block  may use the xx-PID variable, or may be signaled by the last terminating worker thread, or by block . Block  also preferably waits for a reasonable timeout period in anticipation of known sleep time of the xx process being terminated, for cases where anticipated sleep times are excessive and the user should not have to wait for lengthy  termination processing. If the timeout occurs before the process is indicated to be terminated, then block  will continue to block . Block  also continues to block  when the process has successfully terminated.","If block  determines the xx process did terminate, the caller is returned to at block  (i.e. xx-PID already set to disabled (0)). If block  determines the xx process termination timed out, then block  forces an appropriate O\/S kill to the PID thereby forcing process termination, and block  sets the xx-PID variable for disabled (i.e. process xx was terminated). Thereafter, block  causes return to the caller.","There are many embodiments for setting certain queue entry field(s) identifying a special queue termination entry inserted at blocks  and . Some suggestions: In the case of terminating thread(s) , queue  insertion of a WDR preferably sets the MS ID field with a value that will never appear in any other case except a termination request (e.g. \u2212100). In the case of terminating thread(s) ,  and , queue  insertion of a WDR preferably sets the MS ID field with a value that will never appear in any other case except a termination request (e.g. \u2212100). In the case of terminating thread(s) , queue  insertion of a WDR request preferably sets the MS ID field with a value that will never appear in any other case except a termination request (e.g. \u2212100). In the case of terminating thread(s) , queue  insertion of a thread request queue record  preferably sets field with a value that will never appear in any other case except a termination request (e.g. \u2212100). Of course, any available field(s) can be used to indicate termination to particular thread(s).","Terminating threads of processing in  has been presented from a software perspective, but there are hardware\/firmware thread embodiments which may be terminated appropriately to accomplish the same functionality. If the MS operating system does not have an interface for killing the PID at block , then blocks  through  can be eliminated for relying on a  invocation timeout (incorporated for block ) to appropriately rob power from remaining thread(s) of processing.","An ILM has many methods and systems for knowing its own location. LBX depends on MSs maintaining their own whereabouts. No service is required to maintain the whereabouts of MSs in order to accomplish novel functionality.","Armed with its own whereabouts, as well as whereabouts of others and others nearby, a MS uses charters for governing many of the peer to peer interactions. A user is preferably unaware of specificities of the layer(s) providing WDR interoperability and communications. Permissions  and charters  surface desired functionality to the MS user(s) without fully revealing the depth of features that could be made available. Permissions provide authentication for novel features and functionality, and to which context to apply the charters. However, some permissions can provide action(s), features, and functionality by themselves without a charter. It is preferred that LBX features and functionality be provided in the most elegant manner across heterogeneous MSs.","User configured permissions are maintained at a MS and their relevance (applicability) to WDRs that are being processed is determined. WDR processing events are recognized through being placed in strategic LBX processing paths of WDRs. For example, permissions govern processing of newly processed WDRs at a MS, regardless of where the WDR originated. A permission can provide at least one privilege, and may provide a plurality of privileges. A permission is granted from a grantor identity to a grantee identity. Depending on what permissions are determined relevant to (i.e. applicable to) a WDR being processed (e.g. by accessing at least one field in the WDR), an action or plurality of actions which are associated with the permission can automatically occur. Actions may be as simple as modifying a setting which is monitored\/used by an LBX application, or as complex as causing many executable application actions for processing. User configured charters are maintained at a MS and their relevance (applicability) to WDRs that are being processed is determined, preferably in context of the same recognized events (i.e. strategic processing paths) which are used for determining relevance of permissions to WDRs. A charter consists of a conditional expression and can have an action or plurality of actions which are associated with the expression. Upon evaluating the expression to an actionable condition (e.g. evaluates to a Boolean true result), the associated action(s) are invoked. Charters can be created for a MS by a user of that MS, or by a user of another MS. Charters are granted similarly to permissions in using a grantor and grantee identity, therefore granting a charter is equivalent to granting a permission to execute the charter.","While some embodiments will provide disclosed features as one at a time implementations, a comprehensive architecture is disclosed for providing a platform that will survive LBX maturity.  depict a preferred embodiment BNF (Backus Naur Form) grammar for permissions  and charters . A BNF grammar is an elegant method for describing the many applicable derived subset embodiments of syntax and semantics in carrying out processing behavior. The BNF grammar of  specifically describes:\n\n",{"@attributes":{"id":"p-0643","num":"0989"},"figref":"FIGS. 30A through 30B","b":["3002","3002","10","8","12"],"i":["a ","b "],"ul":{"@attributes":{"id":"ul0053","list-style":"none"},"li":{"@attributes":{"id":"ul0053-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0054","list-style":"none"},"li":"*myVar(555++, 23\u2212=4,888\u2212\u2212,200+=100)\n\nThis instantiation specifies that all occurrences of the string \u201c555\u201d should be incremented by 1 such that the first occurrence of \u201c555\u201d becomes \u201c556\u201d, next occurrence of \u201c555\u201d becomes \u201c557\u201d, and so on. Changing all occurrences of \u201c555\u201d to \u201c556\u201d is accomplished with the string substitution. This instantiation also specifies that all occurrences of the string \u201c23\u201d should be decremented by 4 such that the first occurrence of \u201c23\u201d becomes \u201c19\u201d, next occurrence of \u201c23\u201d becomes \u201c15\u201d, and so on. Changing all occurrences of \u201c23\u201d to \u201c19\u201d is accomplished with the string substitution. This instantiation also specifies that all occurrences of the string \u201c888\u201d should be decremented by 1 such that the first occurrence of \u201c888\u201d becomes \u201c887\u201d, next occurrence of \u201c888\u201d becomes \u201c886\u201d, and so on. Changing all occurrences of \u201c888\u201d to \u201c887\u201d is accomplished with the string substitution. This instantiation also specifies that all occurrences of the string \u201c200\u201d should be incremented by 100 such that the first occurrence of \u201c200\u201d becomes \u201c300\u201d, next occurrence of \u201c200\u201d becomes \u201c400\u201d, and so on. Changing all occurrences of \u201c200\u201d to \u201c300\u201d is accomplished with the string substitution.\n"}}}},"Preferably, when a variable is set to another variable (e.g. a=b), an instantiation of the variable (i.e. *a) equals the variable b, not b's value (i.e. *(*a)=b's value). If the variable b is set to a variable c (e.g. b=c) in the example, and the variable a is set to the variable b as already described (past or future, prior to instantiation), and c was set (i.e. c=2) to the value 2 (past or future, prior to instantiation), then the preferred embodiment requires three (3) instantiations of variable a to get to the value assigned to variable c (e.g. *(*(*a)))=2). Instantiation of variable a (e.g. *a) preferably corresponds to a level of \u201cpeeling back\u201d through the hierarchy of variable assignments if one exists. Alternative embodiments will allow a single instantiation of a variable to get through any number of indirect variable assignments for the first encountered value in the indirect chain value (e.g. *a=2) at the time of instantiation. Either semantic may have useful features from a programming standpoint. Over-instantiating (e.g. *(*c)=error) should cause an error. An assigned value is the leaf node in peeling back with instantiations.","The BNF Grammar \u201cnull\u201d is an atomic element for no value. In a syntactic embodiment, a null value may be a special null character (e.g. \u00d8). The History construct is preferably used to track when certain constructs were created and last modified. An alternative embodiment will track all construct changes to LBX history  for later human, or automated, processing audit.","Grammar \u201csystem type\u201d is an atomic element (atomic elements are not constructs which elaborate to other things; atomic elements are shown delimited in double quotes) generalized for the type of MS (e.g. PDA, cell phone, laptop, etc). Other embodiments will provide more detail to the type of MS (e.g. iPhone, Blackberry Pearl, Nextel i845, Nokia 741, etc). ID is an identity construct of the present disclosure for identifying a MS, a user, a group, or any other entity for which to associate data and\/or processing. IDType provides the type of ID to support a heterogeneous identifying grammar. An identity (i.e. ID [IDType]) can be directly associated to a MS (e.g. MS ID), or may be indirectly associated to a MS (e.g. user ID or group ID of the MS). Indirect identity embodiments may assume an appropriate lookup for mapping between identities is performed to get one identity by looking up another identity. There may be multiple identities for a MS. Identities, by definition, provide a collective handle to data. For example, an email sender or recipient is an example of an identity (\u201clogical handle\u201d) which can be associated to a user identity and\/or MS identity and\/or group identity. A sender, source, recipient, and system parameter in some atomic commands presented below is any of the variety of types of identities.","Address elements of \u201cip address\u201d and \u201cSNA address\u201d are examples of logical addresses, but are mentioned specifically anyway. ID, IDType and Address construct atomic elements (as elaborated on Right Hand Side (RHS)) are self explanatory. The TimeSpec construct is one of various kinds of \u201cdate\/time stamp\u201d or \u201cdate\/time period\u201d atomic elements. In a syntactic embodiment, date\/time stamps are specified with prefixed character(s) and a time format such as xYYYYMMDDHHMMSS.12.J (J=# places to right of decimal point, such that 1=is the one tenth ( 1\/10) second place, two=the one hundredth ( 1\/100) second place, etc). The first character(s) (i.e. x) clarify the date\/time stamp information.\n\n",{"@attributes":{"id":"p-0648","num":"1003"},"figref":"FIG. 30C","b":["3034","10","8","3034"]},"There are two (2) main types of permissions (privileges): semantic privileges which on their own enable LBX features and functionality; and grammar specification privileges which enable BNF grammar specifications. Semantic privileges are named, anticipated by applications, and have a semantic meaning to an application. Semantic privileges are variables to applications whereby values at the time of an application checking the variable(s) determine how the application will behave. Semantic privileges can also have implicit associated action(s). Grammar specification privileges are named, anticipated by charter parser implementation, and indicate what is, and what is not, permitted when specifying a charter. Grammar specification privileges are variables to charter parsing whereby values at the time of charter parse logic checking the variable(s) determine whether or not the charter is valid (i.e. privileged) for execution. Impersonation is not directly defined in the BNF grammar of charters, and is therefore considered a semantic privilege.","The \u201cMS relevance descriptor\u201d atomic element is preferably a binary bit-mask accommodating all anticipated MS types (see \u201csystem type\u201d). Each system type is represented by a bit-mask bit position wherein a bit set to 1 indicates the MS type does participate with the privilege assigned, and a bit set to 0 indicates the MS type does not participate with the privilege assigned. This is useful when MSs do not have equivalent capabilities thereby limiting interoperability for a particular feature governed by a privilege. When the optional MSRelevance construct is not specified with a privilege, the preferred default is assumed relevance for all MSs (i.e. =all bits set to 1). An alternate embodiment will make the default relevant for no MSs (i.e. =all bits set to 0). Privilege codes (i.e. syntactical constants equated to an \u201catomic privilege for assignment\u201d description) are preferably long lived and never changing so that as new LBX privileges are introduced (i.e. new privileges supported), the old ones retain their values and assigned function, and operate properly with new software releases (i.e. backwards compatible). Thus, new constants (e.g. \\lbxall=privilege for allowing all LBX interoperable features) for \u201catomic privilege for assignment\u201d should be chosen carefully.","Grants are used to organize privileges in desired categories and\/or sub-categories (e.g. organization name, team name, person name, etc and then privileges for that particular grant name). A grant can be used like a folder. Grants provide an hierarchy of tree branch nodes while privileges are leaf nodes of the grant privilege tree. There are many types of privileges. Many are categorized for configuring charter conditions and charter actions, and some can be subsets of others, for example to have an overall category of privileges as well as many subordinate privileges within that category. This facilitates enabling\/disabling an entire set with a single configuration, or enabling\/disabling certain privileges within the set. This also prevents forcing a user to define Grants to define privilege categories. BNF grammar  does not clarify the Privilege construct with a parameter for further interpretation, however some embodiments will incorporate an optional Parameters specification:\n\nPrivilege=\u201catomic privilege for assignment\u201d[Parameters][MSRelevance][TimeSpec][Description][History]|Varinstantiations\n\nIn such embodiments, Parameters preferably resolves to the Parameters construct of  for clarifying how to apply a particular privilege. Parameters, if used for privileges, have meaning within the context of a particular privilege. Similarly, Parameters may also be used at a Grant level for applying qualifying information to a group of privileges:\n\nGrant=\u201cgrant name\u201d[Parameters]AND (Privileges[TimeSpec][Description][History]|Grants[TimeSpec][Description][History]|Varinstantiations)\n\nSome examples of semantic privileges (i.e. \u201catomic privilege for assignment\u201d) that can be granted from a grantor identity (ID\/IDType) to a grantee identity (ID\/IDType) include:\n\n","While the Grantor construct translates to the owner of the permission configuration according to grammar , impersonation permits a user to take on the identity of a Grantor for making a configuration. For example, a group by its very nature is a form of impersonation when a single user of the group grants permissions from the group to another identity. A user may also impersonate another user (if has the privilege to do so) for making configurations. In an alternative embodiment, grammar  may include means for identifying the owner of the permission(s) granted. Group constructs provide means for collections of ID constructs, for example for teams, departments, family, whatever is selected for grouping by a name (atomic element \u201cgroup name\u201d). The impersonation privilege should be delegated very carefully in the preferred embodiment since the BNF grammar does not carry owner information except through a History construct use.","The Grantor of a privilege is the identity wanting to convey a privilege to another identity (the Grantee). The Grantee is the identity becoming privileged by administration of another identity (the Grantor). There are various embodiments for maintaining privileges, some embodiments having the side affect of increasing, or decreasing, the palette of available privileges for assignment. Privilege\/Permission embodiments include:\n\n","In an alternative embodiment, groups can be used to handle groups of privileges as well as groups of IDs, so that Groups\/Group BNF constructs generically handle a collection of things, regardless of the type of things, for example using a qualifier like IDType. Grants and Groups have a similar hierarchy. There may be no need to have separate Grants\/Grant BNF grammar definitions. The Groups\/Group constructs can be extended to handle Privileges in a similar manner. Groups\/Group construct related changes may be made to the BNF grammar, database tables and flowcharts described below for consolidating collections of IDs, groups and privileges for properly carrying out and supporting groups and grants as disclosed.",{"@attributes":{"id":"p-0655","num":"1110"},"figref":"FIGS. 30D through 30E","b":["3068","3068","3034"],"i":["a ","b "]},"It is important to note the context of terminology use \u201cGrantor\u201d and \u201cGrantee\u201d appears in, since they are similarly used in context of charters versus permissions. In both cases there is an acceptance\/authentication\/configuration granted by a Grantor to a Grantee. A permission Grantor grants a privilege to a Grantee. A charter Grantor grants a privilege to enable a Grantee's charters (may be at the mercy of privileges in the preferred embodiment). The Grantee construct in charters translates to the owner\/creator\/maintainer identity of the charter configuration according to grammar and , and the Grantor construct translates to an identity the Grantee has created the charter for, but does not necessarily have the privilege to do so, or does not necessarily have the privilege for any subset of processing of the charter. Privileges preferably govern whether charters are in effect, and how they are in effect. An alternative embodiment will activate (make in effect) a charter by granting it from one identity to another as shown in grammar . A charter consists of a conditional expression and can have an action or plurality of actions which are associated with the conditional expression. Upon evaluating the expression to an actionable condition (e.g. evaluates to a Boolean true result), the associated action(s) are invoked.","Impersonation permits a user to take on the identity of a Grantee for making a configuration. For example, a group by its very nature is a form of impersonation when a single user of the group administrates charters for the group. A user may also impersonate another user (if has the privilege to do so) for making configurations. In an alternative embodiment, grammar and may include means for identifying the owner of the charters administrated. The impersonation privilege should be delegated very carefully in the preferred embodiment since the BNF grammar does not carry owner information except through a History construct use.","The Grantee of a charter is the identity (e.g. creates and owns the charter) wanting to have its charters processed for another identity (the Grantor). The Grantor is the identity targeted for processing the administrated charter(s) created by the Grantee. The terminology \u201cGrantor\u201d and \u201cGrantee\u201d will become reversed (to match privilege assignments) in an embodiment which grants charters like privileges. There are various embodiments for maintaining charters, some embodiments having the side affect of increasing, or decreasing, the palette of available charter processing deployed. Charter embodiments include:\n\n","WDRTerm provides means for setting up conditions on any WDR  field or subfield that is detected for WDR(s):\n\n","AppTerm provides means for setting up conditions on data of any application of an MS, for example to trigger an action based on a particular active call during whereabouts processing. A few AppTerm examples are any of the following:\n\n","PointSet provides means for defining a set of points for a variety of applications. Points of a PointSet may describe a single point (i.e. one point record), a line segment, a polygon, a point with radius, a two dimensional area, a three dimensional area in space, or any other multi-dimensional region. An optional dimension qualifier (i.e. 2D or 3D; default=2D) specifies whether or not the set of points are for two dimensional space or three dimensional space. Alternate embodiments support higher dimensions for certain applications, for example to describe another universe dimension as straightforward as time, or a situational location (e.g. extending a point record definition), or as complex as a string theory dimension. If point records can be specified for the dimension qualifier(s), any dimension(s) may be used. An optional point type qualifier (i.e. Geo, Cartesian or Polar; default=Geo) specifies the type of points in the set wherein each point is a record of appropriate data. Alternate embodiments support other type qualifiers for certain applications, for example to describe lines, arcs, or regions containing an infinite set of points (e.g. extending a point record definition for describing a collection of points), or to specify different models (e.g. Geodetic, Polar Cylindrical, Polar Spherical, etc). When a \u201ctext string\u201d format is used for the PointSet, it is preferably null terminated (e.g. null included in ANSI encoded length) and an appropriate syntax is used to identify point record components (e.g. comma), and to delimit point records (e.g. semicolon) in the set of points (e.g. \u201c+33.27,\u221297.4;+34.1,\u221297.3;+34.13,\u221297.12;\u201d specifies a two dimensional Geo polygon PointSet (i.e. point records of latitude,longitude decimal degree pairs) and \u201c3D\/Geo; +33.27,\u221297.4,4500F;+34.1,\u221297.3,1L;+34.13,\u221297.21,2000Y;+34.3,\u221297.1,2000Y;+34.89,\u221297.08,2000Y\u201d specifies a three dimensional Geo polygon solid region in space PointSet (i.e. point records of latitude,longitude,altitude decimal degree tuples)).","A single point may have an additional specification for a radius around the point (e.g. \u201c+33.27,\u221297.4,R1000F\u201d) as indicated with the \u201cR\u201d prefix. The R prefix solves ambiguity between a 3D specification for a point at an elevation\/altitude and a point with a spherical radius. Syntactical unit qualifiers may, or may not, be supported for any of the point record components (e.g. 4500F=4500 feet, 1L=1 Mile, 2000Y=2000 Yards, latitude\/longitude specified in desirable way (e.g. 33.27N,97.4W;), etc). A numeric(s) (binary) format will cause each PointSet record component to occupy an anticipated number of bits\/bytes along with an overall length describing all bytes of the PointSet. Numeric indication (e.g. bit(s)) is used to indicate whether a radius is specified for a single point versus an altitude\/elevation in a 3D specification. In some embodiments, the user interfaces to convenient units which are converted to a standard form of units in the PointSet and converted when necessary.","The Data construct is used for either string or binary specification. In a preferred embodiment string syntax, a Point Set is encoded like an atomic term with a leading backslash and anticipated characters (e.g. \\PS_ . . . ) for proper conditional evaluation (e.g. at blocks  and ). In another embodiment, a Point Set is treated as a \u201cspecial term\u201d (e.g. atomic term) and gets replaced (e.g. at blocks  and ) with an internalized form for proper condition evaluation. In some embodiments, a Point Set is encoded with a unique syntax (e.g. PS: . . . ). A PointSet is useful for specifying two dimensional polygons, or point delimited regions in three dimensional space. Well known polygon implementation techniques may affect how to internalize a PointSet specification, for example to determine whether or not a MS is relevant (i.e. in, not in, at, not at, was in, was not in, was at, was not at, in vicinity of, not in vicinity of, newly in vicinity of, not newly in vicinity of, recently in vicinity of, not recently in vicinity of, departed from, not departed from, recently departed from, not recently departed from, etc) using processing of \u201cDetermining If A Point Lies On The Interior Of A Polygon\u201d published November 1987 by Paul Bourke.","With reference now to , depicted is a flowchart for a preferred embodiment for processing the request to specify a map term. A map term is a name which resolves to a point, point and radius or set of points (see PointSet described above). There are a variety of MS applications which can be used to create a point, point and radius, or PointSet thereby preventing a tedious user encoding. The user sets up a map term with a convenient user interface (e.g. ), gives it a name, and can then reference it in expressions by the map term name (using a ? prefix to the name to indicate its is a map term). Otherwise, the user may be faced with specifying a challenging encoding (e.g. complex text string) for an expression.","Map term specification processing begins at block  upon a user action to create a map term, continues to block  where the user is prompted for how to specify the map term, and waits at block  for the user's response. Block  continues to block  when the user responds.","If block  determines the user selected to use the user's current location (i.e. current location of the MS), then block  accesses queue  for a current and most recent MS location and makes a point (may make point and default radius, or set of points in alternate embodiments) using the location information if a reasonably current location was found. Thereafter, if block  determines there was no current (i.e. reasonably recent) location found, then block  provides the user with an error, block  appropriately terminates the  user interface, and  processing terminates at block . Block  preferably requires the user to acknowledge the error. If block  determines a current location was found, then block  prompts the user for a radius, and block  interfaces with the user for specification of a valid radius. A three dimensional embodiment additionally prompts the user for 2D or 3D for the point set to be created, and the user additionally specifies 2D or 3D at block . When the user specifies the requested information, block  automatically generates a unique map term name (e.g. mt035), preferably using a round-robin sequence number and ensuring no current map terms currently have the name in use, and then continues to block  where the map term information is saved to a new record . Block  saves the user specifications as a PointSet which can be referenced by the name. The user may have specified only a single point for a location, or a single point and radius around it for a location when arriving to block  from block . Block  continues to block .","With reference now to , depicted is a preferred embodiment of a Map Term Data Record (MTDR)  for discussing operations of the present disclosure, derived from the grammar of . A MTDR  contains a name field which can be referenced in an expression or condition with a \u201c?\u201d prefix (e.g. ?mt035), a type field which indicates the type of PointSet for interpretation of field , and the PointSet encoding field . Encoding field may be a binary or textual encoding depending on the embodiment. A description field may be included for user documentation of the map term. A MS may enforce a maximum number of records . Records  may be used to save waypoints as well known to those skilled in the art.","With reference back to , block  accesses all records , continues to block  for producing a scrollable list of map term names, and continues to block  where processing waits for a user action in response to the map term list. Block  continues to block  upon a user action. Block  preferably highlights a newly created map term from  processing up to the point of processing at block . The user can highlight which map term to perform an action on as handled by block .","If block  determines the user selected to delete a particular map term from the list, then block  deletes it from records  and processing continues back to block  for a list refresh. If block  determines the user did not select to delete a particular map term, processing continues to block . If block  determines the user selected to rename a particular map term from the list (e.g. the newly created map term with a default name), then block  interfaces with the user for a valid name and saves it to the particular record  field . A valid name is unique in all records . The name should be descriptive so that the user knows why the map term was created. Thereafter, processing continues back to block  for a list refresh. If block  determines the user did not select to rename a particular map term, processing continues to block . If block  determines the user selected to add a new map term, then processing continues back to block , otherwise processing continues to block . If block  determines the user selected to display a particular map term on a map, then block  displays the map term on a suitable map, block  interfaces with the user for navigating and interfacing to the map, and processing continues back to block  for a list refresh when the user is done at block . The map term location information of the particular record  is preferably used at block  to provide a best map at a best zoom. Block  preferably supports any kind of map navigation (like blocks  through ). If block  determines the user did not select to display a map term on a map, processing continues to block . If block  determines the user selected to exit list processing, then block  terminates user interface processing, and  processing terminates at block , otherwise block  handles any other user actions detected at block  and continues back to block .","Referring back to block , if it is determined that the user did not select to specify a map term with the current MS location, processing continues to block . If block  determines the user selected to use a map to specify a map term, then processing continues to block , otherwise any other actions leaving block  are handled appropriately at block  and processing continues back to block .","In some embodiments, an action for processing blocks  through  is available to the user at block  and detected at block  for being processed (e.g. at block ). This allows a user to browse map terms without creating one first. While a map term should be named for being easy to remember, there may be many defined. Maintaining existing map terms may be provided through a separate user interface, or a user may use a database query manager in a SQL database embodiment to manage MTDRs  directly. In another embodiment, a user may specify at block  to use the last known location or current location of another MS for map term creation, in which case processing at block  includes continuing to a block A (like block ) for access to queue  (and\/or possibly LBX history  in some embodiments) for another MS location. Processing already described for block  would involve another MS location in the block A with processing of blocks  and thereafter for that location. Other embodiments allow a user to specify any search criteria at block  for finding any WDR at queue  and\/or from history , regardless of the originator, to then have the associated location used for specifying a map term.","Block  establishes latitude and longitude landmarks upon the selected map (map is defaulted on first encounter of block  from block ) and associates corresponding x and y pixels, preferably with the leftmost bottom corner at the Cartesian coordinate system origin, for example the leftmost top corner (e.g. (x,y)=(0,Y)), rightmost top corner (e.g. (x,y)=(X,Y)), rightmost bottom corner (e.g. (x,y)=(X,0)), and leftmost bottom corner (e.g. (x,y)=(0,0)) of a rectangular map graphic. Other embodiments may use a different system. Each map graphic is preferably stored with the 4 corners being a well known latitude and longitude, along with a vertical and horizontal curvature factor. In cases where humans have traveled to other planets (also moons or any other body in space) with MS use, associated planetary maps (parent map selectable) will contain applicable latitude and longitude coordinates with relative curvature factors depending on the particular body in space.","The map graphics are preferably small enough in area, yet large enough in display, to avoid too much skewing of latitude and longitude calculations based on points a user selects in the map relative to the four well known corners. Latitude and longitude considers earth curvature wherein one embodiment of map selection may not. However, other embodiments will use curvature factors relative to where map points are selected.","Thereafter, block  presents the selected (or defaulted) map to the user, and the user navigates the map and interfaces to the map at block  until a certain action is invoked. Thereafter, if block  determines the user selected to display a descending geographical map (map that drills down into a territory on the current map), or ascending map (map that covers more territory including the current map), then processing continues back to block  for the desired map initialization. Convenient map hierarchy traversal is provided for zooming in or out. Panning may also be provided at block  which will access other maps for display before returning to block  for subsequent processing, as determined by action subsequent to block . The user can traverse the map hierarchy in any direction for location specification.","If block  determines the user did want a descending or ascending map, then processing continues to block . If block  determines the user completed location specifications (e.g. a point, circle (point with radius), rectangle, or polygon), then processing continues to block , otherwise processing continues back to block . Block  is intended for the user to specify a point, circle (point with radius), rectangle, or polygon on a map for convenient automated location information specification. The user makes selections with a cursor for a point, circle, rectangle, or polygon. Block  scales the specified points (point, center of circle (with radius), 4 rectangle corners, polygon sequence of points) according to pixel locations for deriving the corresponding latitude(s) and longitude(s) as determined relative to the map well known 4 corners and any curvature skewing information. Processing then continues to block  already described above. When block \/ is arrived to after block , block  saves the user specifications to a new record  for a point, point with radius, or set of points (i.e. PointSet).","Alternate embodiments to  will enable specification of certain atomic terms for convenient reference by name, for example situational locations. In such embodiments, the user specifies additional information (e.g. conditions) to clarify the location to a situational location. In other embodiments, any Expression, Condition, Term, or other charter portion may be specified with a map term so that the reference (e.g. ?refname) is a way to substitute an encoding that was conveniently configured as a map term in advance of use. For example, a user may select on a map another MS user and have any of a variety of associated terms (e.g. atomic term \\locByID_Larry) conveniently specified for the map term which corresponds to the MS user. Various mathematical models can be used to achieve high accuracy on deriving user selected pixels on maps to precise location coordinates. Some map embodiments of blocks  through  will support selecting, panning, and navigating MAPSCO maps, zip codes, and other map means for specifying a location. In such embodiments, an appropriate PointSet is generated for the user's specification.","With reference now to , grammar completes definition of grammar rules for charters. The Invocation construct elaborates to any of a variety of executables, with or without parameters, including Dynamic Link Library (DLL) interfaces (e.g. function), post-compile linked interfaces (e.g. function), scripts, batch files, command files, or any other executable. The invoked interface should return a value, preferably a Boolean (true or false), otherwise one will preferably be determined or defaulted for it. The \u201coptional params\u201d may include any variety of the Parameter construct, and may also include any special term or expression that evaluates to: a) any variety of the Parameter construct; or b) any variety of data acceptable to the invoked interface. The \u201coptional params\u201d may also include other invocations which provide at least one return data providing a data parameter to the hosting Invocation. This allows nesting of invocations for bubbling back parameter values to the next outermost invocation. Expressions in \u201coptional parameters\u201d may include arithmetic operations, string operations, formatting operations, or any other operation involving evaluation to at least one value, preferably with a stack based elaboration.","The Op construct contains atomic elements (called atomic operators) for certain operators used for terms to specify conditions. In syntactical embodiments, each atomic operator may be clarified with a not modifier (i.e. !). For example, \u201cequal to\u201d is \u201c=\u201d and \u201cnot equal to\u201d is \u201c!=\u201d. Those skilled in the art recognize which atomic operator is contextually appropriate for which applicable terms (see BNF grammar ). There are many reasonable syntactical embodiments for atomic operators, with at least:\n\n","Resolving of conditions using atomic operators involves evaluating conditions (BNF grammar constructs) and additionally accessing similar data of LBX history  in some preferred embodiments. Atomic operator validation errors should result when inappropriately used.","Example syntactical embodiments of the \u201catomic profile match operator\u201d atomic element include:\n\n","In one embodiment of profiles maintained at MSs, a LBX singles\/dating application maintains a MS profile for user's interests, tastes, likes, dislikes, etc. The ProfileMatch operators enable comparing user profiles under a variety of conditions, for example to cause an action of alerting a user that a person of interest is nearby. See  for other profile information. In some embodiments, the qualifiers of the atomic profile match operators can be results of an evaluated expression. For example, an expression which results in a string can be used to specify a tag list (e.g. (\u201cinterests,\u201d && *var2) wherein the var2 variable elaborates to a text string). In another example, the file for comparison may be the result of an expression (e.g. *path && *fname). Terms of Expressions\/Conditions can themselves be expressions which elaborate to a particular term for contextual use. A preferred embodiment performs automatic typecasting when necessary to promote comparisons of condition Terms. Appropriate operator precedence, and use of parenthesis to override implemented precedence, is incorporated to ensure no ambiguity across expressions and operators.","Atomic operators are context sensitive and take on their meaning in context to terms (i.e. BNF Grammar Term) they are used with (e.g. atomic operator evaluation may include access to local or remote geo-coding conversion tables to resolve locations in appropriate terms or format for comparisons and other processing). An alternate embodiment incorporates new appropriate atomic operators for use as CondOp operators, provided the result of the condition is a Boolean (e.g. term>=term results in a true or false). Also, while a syntactical form of parenthesis is not explicitly shown in the BNF grammar, the Conditions constructs explicitly defines how to make complex expressions with multiple conditions. Using parenthesis is one preferred syntactical embodiment for carrying out the Conditions construct. The intention of the BNF grammar is to end up with any reasonable conditional expression for evaluating to a Boolean True or False. Complex expression embodiments involving any conceivable operators, terms, order of evaluation (e.g. as syntactically represented with parentheses), and other arithmetic similarities, are certainly within the spirit and scope of this disclosure.","BNF grammar terms are to cover expressions containing conditions involving WDR fields (WDRTerm), situational locations, geofences (i.e. a geographic boundary identifying an area or space), two dimensional and three dimensional areas, two dimensional and three dimensional space, point in an area, point in space, movement amounts, movement distances, movement activity, MS IDs, MS group IDs, current mobile locations, past mobile locations, future mobile locations, nearness, distantness, newly near, newly afar, activities at locations (past, present, future), applications and context thereof in use at locations (past, present, future), etc. There are many various embodiments for specific supported operators used to provide interpretation to the terms. Certain operators, terms, and processing is presented for explanation and is in no way meant to limit the many other expression (BNF Grammar Expression) embodiments carrying the spirit of the disclosure.","Terms (e.g. atomic terms, WDRTerms, etc) may or may not be case sensitive, and term case sensitivity may or may not be enforced. Regardless, users can be consistent when using in environments where they are not enforced to be case sensitive.","The Command construct elaborates to atomic commands. The \u201catomic command\u201d atomic element is a list of supported commands such as those found in the column headings of  table (see discussions for ). There are many commands, some popular commands being shown. The Operand construct elaborates to atomic operands. The \u201catomic operand\u201d atomic element is a list of supported operands (data processing system objects) such as those found in the row headings of  table (see discussions for ). There are many operands, some popular operands being shown. For each command and operand combination, there may be anticipated parameters. The command and operand pair indicates how to interpret and process the parameters.","Constructs (e.g. Parameter, WDRTerm, AppTerm, Value, PointSet, Data, etc) are appropriately interpreted within context of their usage. An optional time specification is made available when specifying charters (i.e. when charter is in effect), expressions (i.e. a plurality of conditions (e.g. with Conditions within Expressions construct)), a particular condition (e.g. with Condition elaborations within Condition construct), and actions (e.g. with Action elaborations within Action construct). One embodiment supports multiple Host specifications for a particular action. Some embodiments allow an Invocation to include invocations as parameters in a recursive manner so as to \u201cbubble up\u201d a resulting Boolean (e.g. fcn1(2, fcn2(p1, x, 45), 10) such that fcn2 may also have invocations for parameters. The conventional inside out evaluation order is implemented. Other embodiments support various types of invocations which contribute to the overall invocation result returned.","In alternate embodiments, an action can return a return code, for example to convey success, failure, or some other value(s) back to the point of performing the action. Such embodiments may support nesting of returned values in BNF grammar Parameters so as to affect the overall processing of actions. For example: action(parameter(s), . . . , action( . . . parameters . . . ), . . . parameter(s)), and action may include returning value(s) from its parameters (which are actions).","Wildcarding is of value for broader specifications in a single specification. Wildcards may be used for BNF grammar specification wherever possible to broaden the scope of a particular specification (e.g. Condition, TimeSpec, etc).",{"@attributes":{"id":"p-0689","num":"1219"},"figref":["FIGS. 31A through 31E","FIG. 37B","FIG. 37C"]},"An \u201catomic command\u201d is an enumeration shown in column headings (i.e. , , . . . etc) with an implied command meaning.  shows what meaning is provided to some of the \u201catomic command\u201d enumerations shown (also see ). A plurality of commands can map to a single command meaning. This supports different words\/phrases (e.g. spoken in a voice command interface) to produce the same resulting command so that different people specify commands with terminology, language, or (written) form they prefer. An \u201catomic operand\u201d is an enumeration shown in row headings (i.e. , , . . . etc) with an implied operand meaning.  shows what meaning is provided to some of the \u201catomic operand\u201d enumerations shown (also see ). A plurality of operands can map to a single operand meaning. This supports different words\/phrases (e.g. spoken in a voice command interface) to produce the same resulting operand so that different people specify operands with terminology, language, or (written) form they prefer. Operands are also referred to as data processing system objects because they are common objects associated with data processing systems.  demonstrate anticipated parameters for each combination of a command with an operand. There are potentially hundreds (or more) of commands and operands. This disclosure would be extremely large to cover all the different commands, operands, and parameters that may be reasonable. Only some examples with a small number of parameters are demonstrated in  to facilitate discussions. There can be a large number of parameters for a command and operand pair. Each parameter, as shown by the BNF grammar, may be in many forms. In one preferred embodiment (not shown in BNF grammar), the Parameter construct of  may also elaborate to a ParameterExpression which is any valid arithmetic expression that elaborates to one of the Parameter constructs (RHS) shown in the BNF Grammar. This allows specifying expressions which can be evaluated at run time for dynamically evaluating to a parameter for processing.","The combination of a command with an operand, and its set of associated parameters, form an action in the present disclosure, relative the BNF grammar discussed above. Some of the command\/operand combinations overlap, or intersect, in functionality and\/or parameters. In general, if parameters are not found (null specified) for an anticipated parameter position, a default is assumed (e.g. parameters of 5, 7 indicates three (3) parameters of 5, use default or ignore, and 7). Operands and parameters are preferably determined at executable code run time when referenced\/accessed so that the underlying values may dynamically change as needed at executable code run time in the same references. For example, a variable set with constructs which elaborates to a command, operand, and parameters, can be instantiated in different contexts for completely different results. Also, a programming language enhanced with new syntax (e.g. as described in ) may include a loop for processing a single construct which causes completely different results at each loop iteration. The operand or parameter specification itself may be for a static value or dynamic value as determined by the reference used. An alternate embodiment elaborates values like a preprocessed macro ahead of time prior to processing for static command, operand, and parameter values. Combinations described by  are discussed with flowcharts. In another embodiment, substitution (like parameter substitution discussed above for ) can be used for replacing parameters at the time of invocation. In any case, Parameters can contain values which are static or dynamically changing up to the time of reference.","Parameters of atomic command processing will evaluate\/resolve\/elaborate to an appropriate data type and form for processing which is described by the #B matrices below (e.g.  is the matrix for describing atomic send command processing). The #B descriptions provide the guide for the data types and forms supportable for the parameters. For example, an email body parameter may be a string, a file containing text, a variable which resolves to a string or file, etc. The BNF grammar is intended to be fully exploited in the many possible embodiments used for each parameter.",{"@attributes":{"id":"p-0693","num":"1223"},"figref":["FIG. 32A","FIG. 32A","FIG. 32B","FIG. 34D"],"b":["3202","3204","1","3204","2","3204","3202"]},{"@attributes":{"id":"p-0694","num":"1224"},"figref":["FIG. 32B","FIG. 34D"],"b":["3252","3254","1","3254","2","3254","3252"]},"In the preferred embodiment, Parameters are contextually determined upon the MS recognizing user directives, depending on the context in use at the time. In another embodiment, Parameters will also have directive mappings for being interpreted for MS processing, analogously to .",{"@attributes":{"id":"p-0696","num":"1226"},"figref":["FIG. 33A","FIGS. 30A through 30B","FIGS. 33A through 33C","FIG. 33B","FIG. 30C","FIG. 33C","FIGS. 30D through 30E"],"b":["10","12","10","12"]},"The preferred embodiment of a WDRTerm is a system well known WDR field\/subfield variable name with two (2) leading underscore characters (e.g. source code references of: _confidence refers to a confidence value of a WDR confidence field _msyaw refers to a yaw value of a WDR location reference field MS yaw subfield). Some useful examples using a WDRTerm include:\n\n","An \u201catomic term\u201d is another special type of user specifiable programmatic variable reference for expressions\/conditions to cause certain actions. The preferred embodiment of an atomic term is a system well known variable name with a leading backslash (\\) escape character (e.g. source code references of: \\loc_my refers to the most recent MS location; \\timestamp refers to the current MS system date\/time in a date\/time stamp format). There can be atomic terms to facilitate expression\/condition specifications, some of which were described above.",{"@attributes":{"id":"p-0699","num":"1233"},"figref":["FIGS. 33A through 33C","FIGS. 30A through 30E","FIGS. 30A through 30E","FIGS. 30A through 30E","FIGS. 34A through 34G","FIGS. 35A through 37C","FIG. 52","FIG. 54"]},{"@attributes":{"id":"p-0700","num":"1234"},"figref":["FIGS. 34A through 34G","FIGS. 30A through 30E","FIGS. 34A through 34G","FIG. 52","FIG. 30A through 30E"],"ul":{"@attributes":{"id":"ul0073","list-style":"none"},"li":{"@attributes":{"id":"ul0073-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0074","list-style":"none"},"li":["Parsing, processing, and\/or internalizing a derivative X.409 encoding of the BNF grammar of  (e.g. );","Parsing, processing, and\/or internalizing a derivative XML encoding of the BNF grammar of ;","Compiler parsing, processing, and\/or internalizing of a programming language processing form of the BNF grammar of ;","Interpreter parsing, processing, and\/or internalizing of a programming language processing form of the BNF grammar of ;","Internalized representation of permissions , groups (data ) and\/or charters  to data processing system memory;","Internalized representation of permissions , groups (data ) and\/or charters  to data processing system storage; and\/or","Parsing, processing, and\/or internalizing any particular derivative form, or subset, of the BNF grammar of ."]}}}},"Source code header information is well understood by those skilled in the relevant art in light of the BNF grammar disclosed. The example does make certain assumptions which are easily altered depending on specificities of a derivative form, or subset, of the grammar of . Assumptions are easily modified for \u201cgood\u201d implementations through modification of isolated constants in the header file:\n\n","The TIMESPEC structure of  preferably utilizes a well performing Julian date\/time format. Julian date\/time formats allows using unambiguous floating point numbers for date\/time stamps. This provides maximum performance for storage, database queries, and data manipulation. Open ended periods of time use an unspecified start, or end date\/time stamp, as appropriate (i.e. DT_NOENDSPEC or DT_NOSTARTSPEC). A known implemented minimal time granulation used in Julian date\/time stamps can be decrement or incremented by one (1) as appropriate to provide a non-inclusive date\/time stamp period delimiter in a range specification (e.g. >date\/time stamp).","The VAR structure provides a pointer to a datastream which can be typecast (if applicable in embodiments which elaborate the variable prior to being instantiated, or referenced), or later processed. Variables are preferably not elaborated\/evaluated until instantiated or referenced. For example, the variable assigned value(s) which are parsed from an encoding remains unprocessed (e.g. stays in X.409 datastream encoded form) until instantiated. Enough space is dynamically allocated for the value(s) (e.g. per length of variable's value(s)) (e.g. X.409 encoding form), the variable's value (e.g. X.409 encoding) is copied to the allocated space, and the v.value pointer is set to the start of the allocated space. The v.value pointer will be used later when the variable is instantiated (to then parse and process the variable value(s) when at the context they are instantiated).","An alternate embodiment to the PERMISSION structure of  may not require the grantor fields (e.g. grantor, gortype) since the data processing system owning the data may only maintain permissions for the grantor (e.g. the MS user). An alternate embodiment to the CHARTER structure of  may not require the grantee fields (e.g. grantee, geetype) or the grantor fields (e.g. grantor, gortype) since the data processing system owning the data may only maintain charters for that user at his MS. Another embodiment to the CHARTER structure of  may not require the grantor fields (e.g. grantor, gortype) since the data processing system owning the data may be self explanatory for the Grantor identity (e.g. charters used at MS of Grantor).","Some figures illustrate data records (, , , , C, , , , , or any other disclosed data records), for example maintained in an SQL database, or maintained in record form by a data processing system. Depending on the embodiment, some data record fields disclosed may be multi-part fields (i.e. have sub-fields), fixed length records, varying length records, or a combination with field(s) in one form or another. Some data record field embodiments will use anticipated fixed length record positions for subfields that can contain useful data, or a null value (e.g. \u22121). Other embodiments may use varying length fields depending on the number of sub-fields to be populated, or may use varying length fields and\/or sub-fields which have tags indicating their presence. Other embodiments will define additional data record fields to prevent putting more than one accessible data item in one field. In any case, processing will have means for knowing whether a value is present or not, and for which field (or sub-field) it is present. Absence in data may be indicated with a null indicator (\u22121), or indicated with its lack of being there (e.g. varying length record embodiments). Fields described may be converted: a) prior to storing; or b) after accessing; or c) by storage interface processing; for standardized processing. Fields described may not be converted (i.e. used as is).",{"@attributes":{"id":"p-0706","num":"1256"},"figref":["FIG. 35A","FIGS. 30A through 30E"],"b":["3500","3500","10","12","3500","3500","3500","3500","3500","3500","3520","3700","3500","3500","3500","3520","3500","3700","3500","3500","3500","3500","3500","3500","3500","3500","3500","3500","3500","1","3500","2","3500","3500","3500","3500","3500","3500","3500","3500","3500"],"i":["a ","a ","a ","a ","b ","a","t ","t ","a ","b ","a","a ","a","b ","b ","c ","d","e ","f","b ","b","b","b ","b ","c ","d ","c","e ","f ","e. "]},{"@attributes":{"id":"p-0707","num":"1257"},"figref":["FIG. 35B","FIGS. 30A through 30E"],"b":["3510","3510","3510","3510","3510","3510","3500","3510","3510","3510","3500","3510"],"i":["a ","a ","a ","b ","b ","b ","c "]},{"@attributes":{"id":"p-0708","num":"1258"},"figref":["FIG. 35C","FIGS. 30A through 30E"],"b":["3520","3520","3520","3520","3520","3520","3500","3510","3540","3520","3520","3520","3520","3510","3540","3500","3500","3520"],"i":["a ","a ","b ","b ","a","a","a","c ","c ","d ","d ","a","a","c","e"],"ul":{"@attributes":{"id":"ul0077","list-style":"none"},"li":{"@attributes":{"id":"ul0077-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0078","list-style":"none"},"li":["Grant(s) (the descendants) in a permission (the ascendant);","Privilege(s) in a permission;","Grant(s) in a grant (e.g. tree structure of grant names);","Privilege(s) in a grant;","Groups(s) in a group (e.g. tree structure of group names);","IDs in a group (e.g. group of grantors and\/or grantees); and\/or","Other parent\/child relationships of data records disclosed.\n\nAn alternate embodiment will define distinct record definitions (e.g. -z) for any subset of relationships described to prevent data access performance of one relationship from impacting performance accesses of another relationship maintained. For example, in an SQL embodiment, there may be two (2) tables: one for handling three (3) of the relationships described, and another for handling all other relationships described. In another SQL example, six (6) distinct tables could be defined when there are only six (6) relationships to maintain. Each of the distinct tables could have only two (2) fields defined for the relationship (i.e. ascendant ID and descendant ID). The type fields may not be required since it would be known that each table handles a single type of relationship (i.e. GADR-grant-to-permission, GADR-privilege-to-permission, GADR-grant-to-grant, GADR-privilege-to-grant, GADR-group-to-group and GADR-ID-to-group). Performance considerations may provide good reason to separate out relationships maintained to distinct tables (or records).\n"]}}}},{"@attributes":{"id":"p-0709","num":"1266"},"figref":["FIG. 35D","FIGS. 30A through 30E"],"b":["3530","3530","3530","3530","3530","3530","3530","3530","3530","3530"],"i":["a ","a ","b ","a ","b ","b "]},{"@attributes":{"id":"p-0710","num":"1267"},"figref":["FIG. 35E","FIGS. 30A through 30E"],"b":["3540","3540","3540","3540","3540","3540","3500","3540","3540","3540","3500","3540"],"i":["a ","a ","a ","b ","b ","b ","c "]},{"@attributes":{"id":"p-0711","num":"1268"},"figref":["FIG. 36A","FIGS. 30A through 30E"],"b":["3600","3600","3600","3600","3600","3600","3500","3510","3530","3500","3500","3700","3750","3775","3540","3600","3600","3600","3600","3600","3600","3600","3600","3520"],"i":["a ","c","a ","a ","a","a","a","c","e","a","a","a","a","b ","c","b ","a","c ","a ","b"]},{"@attributes":{"id":"p-0712","num":"1269"},"figref":["FIG. 36B","FIGS. 30A through 30E"],"b":["3620","3620","3620","3620","3620","3620","3500","3510","3530","3500","3500","3700","3750","3775","3540","3620","3620","3620","3620","3620","3620","3620","3620","3520","3620","3620","1","3620","2","3620","3"],"i":["a ","c","a ","a ","a","a","a","c","e","a","a","a","a","b ","c","b ","a","c ","a ","b","c ","c","c","c"]},{"@attributes":{"id":"p-0713","num":"1270"},"figref":["FIG. 36C","FIGS. 30A through 30E"],"b":["3640","3640","3640","3640","3640","3640","3500","3510","3530","3700","3750","3640","3640","3640","3640","3640","3640","3640","3640","3520","3640","3640","1","3640","2","3620","3","3640","3640","3640","3640","3640","3640"],"i":["a ","c","a ","a ","a","a","a","a","a","b ","c","b ","a","c ","a ","b ","c ","c","c","c","c ","a","c ","a ","b ","c "],"ul":{"@attributes":{"id":"ul0079","list-style":"none"},"li":{"@attributes":{"id":"ul0079-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0080","list-style":"none"},"li":["Past (\u201cP\u201d): indicates that the associated data record (e.g. permission, charter, action, etc) applies to all WDR information maintained to LBX History ;","Self Past (\u201cSP\u201d): indicates that the associated data record (e.g. permission, charter, action, etc) applies to only WDR information maintained to LBX History  for the MS owning history ;","Other Past (\u201cOP\u201d): indicates that the associated data record (e.g. permission, charter, action, etc) applies to only WDR information maintained to LBX History  for all MSs other than the one owning history ;","Future (\u201cF\u201d): indicates that the associated data record (e.g. permission, charter, action, etc) applies to all WDRs created\/received (e.g. inserted to queue ) in the future by the MS (i.e. after configuration made);","Self Future (\u201cSF\u201d): indicates that the associated data record (e.g. permission, charter, action, etc) applies to all WDRs created in the future (e.g. inserted to queue ) by the MS for its own whereabouts (i.e. after configuration made);","Other Future (\u201cOF\u201d): indicates that the associated data record (e.g. permission, charter, action, etc) applies to all WDRs received (e.g. inserted to queue ) in the future by the MS for other MS whereabouts (i.e. after configuration made);","All (\u201cA\u201d): indicates that the associated data record (e.g. permission, charter, action, etc) applies to all WDRs created\/received in the future by the MS (i.e. after configuration made) and WDRs already contained by queue ;","Self All (\u201cSA\u201d): indicates that the associated data record (e.g. permission, charter, action, etc) applies to all WDRs created in the future by the MS for its own whereabouts (i.e. after configuration made) and WDRs already contained by queue  for the MS;","Other All (\u201cOA\u201d): indicates that the associated data record (e.g. permission, charter, action, etc) applies to all WDRs received in the future by the MS for other MS whereabouts (i.e. after configuration made) and WDRs already contained by queue  for other MSs; and\/or","Any combination of above (e.g. \u201cSF,OA,OP\u201d)\n\nA syntactical equivalent may be specified for subsequent internalization causing configurations to immediately take effect. Another embodiment qualifies which set of MSs to apply time specification for, but this is already accomplished below in the preferred embodiment through specifications of conditions. Yet another embodiment provides an additional qualifier specification for which WDRs to apply the time specification: WDRs maintained by the MS (e.g., to queue ), inbound WDRs as communicated to the MS, outbound WDRs as communicated from the MS; for enabling applying of time specifications before and\/or after privileges\/charters are applied to WDRs with respect to an MS. Blocks ,  and  may be amended to include processing for immediately checking historical information maintained at the MS which privileges\/charters have relevance, for example after specifying a historical time specification or special tense qualifier.\n"]}}}},{"@attributes":{"id":"p-0714","num":"1281"},"figref":["FIG. 36D","FIGS. 30A through 30E","FIGS. 30A through 30F"],"b":["3660","3660","3660","3660","3660","3660","3500","3660","3660","3660","3660","3660","3660","3660","3660","3660","3660","3660"],"i":["a ","a ","b ","b ","c ","d ","d ","d ","d ","d ","d ","d ","c ","d "]},{"@attributes":{"id":"p-0715","num":"1282"},"figref":["FIG. 37A","FIGS. 30A through 30E"],"b":["3700","3700","3700","3700","3700","3700","3500","3700","3500","3700","3700","3700","3500","3700","3700","3700","3700","3700","3700","3700","3520","3700","3700","3700","3750","3700","3700","3750","45","2356","9738","3750","3750","3700","3520","3750","3700","3700","3700","3700","3500","3500","3700","3700","3700","3700","3700"],"i":["a ","a ","a ","a ","a","b ","b ","b ","c ","d","c ","c ","c ","c ","c ","a ","d ","a ","c ","d ","a ","a","d ","a ","a ","e ","h ","c ","f","f ","f ","f ","t ","t "]},{"@attributes":{"id":"p-0716","num":"1283"},"figref":["FIG. 37B","FIGS. 30A through 30E","FIG. 34D","FIG. 34D","FIGS. 31A through 31E"],"b":["3750","3750","3750","3750","3750","3500","3750","3750","3750","3500","3750","3750","3750","3750","3750","3750","3750","3750","3775","3750","3750","3750","3775","234","18790","3775","3775","3750","3520","3775","3750","3750"],"i":["a ","a ","a ","b ","b ","b ","c ","d ","c ","c","c ","e ","f ","g ","a ","e ","f ","g ","a ","a","g ","a ","a "]},{"@attributes":{"id":"p-0717","num":"1284"},"figref":["FIG. 37C","FIGS. 30A through 30E"],"b":["3775","3775","3775","3775","3775","3500","3775","3775","3775","3500","3775","3750","3750","3775","3775","3750","3775","3775"],"i":["a ","a ","a ","b ","b ","b ","c ","g","g ","c","g ","c. "]},{"@attributes":{"id":"p-0718","num":"1285"},"figref":["FIG. 37D","FIG. 57"],"b":["3790","3795","3790","4608","3790","3795","3795","3790","3790","3790","3790","3790","3790","3790","3790","3795","3795","3700","3795","3790","3700"],"i":["a ","b ","a","b ","b ","c ","c ","d ","d ","d","b\/c\/d","a ","a","b ","a","f "]},"Preferably, blocks , , , , ,  and related charter processing described below support presenting and managing appropriately per context the applicable charters starters schema described above in the applicable context.","In one embodiment, data can be maintained to data records (e.g. of , , , , C, , , , , and\/or any other disclosed data records) such that it is marked as enabled or disabled (e.g. additional column in SQL table for enabled\/disabled). In another embodiment, a record is configured in disabled form and then subsequently enabled, for example with a user interface. Any subset of data records may be enabled or disabled as a related set. Privileges may be configured for which subsets can be enabled or disabled by a user. In another embodiment, privileges themselves enable or disable a data record, a subset of data records, a subset of data record types, or a subset of data of data records. In some embodiments, an administrator or authorized user makes configurations for an intended MS user.","Data records were derived from the BNF grammar of . Other data record embodiments may exist. In a preferred embodiment, data records of  are maintained to persistent storage of the MS. A MS used for the first time should be loaded with a default set of data (e.g. starter templates containing defaulted data) preloaded to the data records for user convenience. Loading may occur from local storage or from remotely loading, for example over a communications channel when first initializing the MS (e.g. enhanced block  for additionally ensuring the data records are initialized, in particular for the first startup of an MS). Owner fields (e.g. field ) for preloaded data are preferably set to a system identity for access and use by all users. Preferably, a user cannot delete any of the system preloaded data. While the data records themselves are enough to operate permissions  and charters  at the MS after startup, a better performing internalization may be preferred. For example, block  can be enhanced for additionally using data records to internalize to a non-persistent well performing form such as compiled C encoding of  (also see FIG. ), and block  can be enhanced for additionally using the internalized data to write out to data records maintained in persistent storage. Any compiled\/interpreted programming source code may be used without departing from the spirit and scope of the disclosure.  (also see ) are an example, but may provide an internalized form for processing. In any case, many examples are provided for encoding permissions  and charters . Continuing with the data record examples, for example a persistent storage form of data records in a MS local SQL database (e.g. a data record corresponds to a particular SQL table, and data record fields correspond to the SQL table columns), flowcharts  through B are provided for configuration of permissions  and charters . Data records are to be maintained in a suitable MS performance conscious form (may not be an SQL database). An \u201cs\u201d is added as a suffix to disclosed acronyms (e.g. GDR) to reference a plural version of the acronym (e.g. GDRs=Granting Data Records).",{"@attributes":{"id":"p-0722","num":"1289"},"figref":"FIGS. 35A through 37D"},"It is anticipated that management of permissions  and charters  be as simple and as lean as possible on an MS. Therefore, a reasonably small subset of the  grammar is preferably implemented. While  demonstrate a significantly large derivative of the BNF grammar, the reader should appreciate that this is to \u201ccover all bases\u201d of consideration, and is not necessarily a derivative to be incorporated on a MS of limited processing capability and resources. A preferred embodiment is discussed, but much smaller derivatives are even more preferred on many MSs. Appropriate semaphore lock windows are assumed incorporated when multiple asynchronous threads can access the same data concurrently.",{"@attributes":{"id":"p-0724","num":"1291"},"figref":["FIG. 38","FIG. 38","FIG. 39A","FIG. 40A","FIG. 41A","FIG. 42","FIG. 42","FIG. 42","FIG. 44A","FIG. 43"],"b":["1478","18","3802","3804","3806","3806","3808","3808","3810","3804","3808","3812","3812","3814","3804","3812","3816","3816","3818","3804","3816","3820","3820","3822","3804","3820","3824","3824","3826","3804","3824","3828","3828","3830","3804","3828","3832","3832","3834","3804","3832","3836","3836","3838","3804","3836","3840","3840","1478","3842","1478","3840","3844","3806","3804"]},"In an alternate embodiment where the MS maintains GDRs , GRTDRs , GADRs , PDRs  and GRPDRs  (and their associated data records DDRs, HDRs and TDRs) at the MS where they were configured,  may not provide blocks  through . The MS may be aware of its user permissions and need not share the data (i.e. self contained). In some embodiments, options  through  cause access to locally maintained data for others (other users, MSs, etc) or cause remote access to data when needed (e.g. from the remote MSs). In the embodiment where no data is maintained locally for others, blocks  through  may not be necessary. The preferred embodiment is to locally maintain permissions data for the MS user and others (e.g. MS users) which are relevant to provide the richest set of permissions governing MS processing at the MS.",{"@attributes":{"id":"p-0726","num":"1293"},"figref":["FIGS. 39A through 39B","FIG. 39A"],"b":["3810","3902","3904","3906","3906","3540","3520","3520","3520","3520","3520","3540","3906","3908","3906","3908"],"i":["c ","d ","a ","b ","a"]},"Block  accesses all GDRs (e.g. all rows from a GDR SQL table) for the user of  matching field to Permission, and the owner information of the GDRs (e.g. user information matches field ) to the user and to groups the user is a member of (e.g. group information matches field (e.g. owner type=group, owner id=a group ID field from block ). The GDRs are additionally joined (e.g. SQL join) with DDRs and TDRs (e.g. fields and =Permission and by matching ID fields and with field ). Description field may provide a useful description last saved by the user for the permission entry. Block  may also retrieve system predefined data records for use and\/or management. Thereafter, each joined entry returned at block  is associated at block  with the corresponding data IDs (at least fields and ) for easy unique record accesses when the user acts on the data. Block  also initializes a list cursor to point to the first list entry to be presented to the user. Thereafter, block  sets user interface indication for where the list cursor is currently set (e.g. set to highlight the entry), and any list scrolling settings are set (the list is initially not set for being scrolled on first  processing encounter to block  from block ). Block  continues to block  where the entry list is presented to the user in accordance with the list cursor and list scroll settings managed for presentation at block . Thereafter, block  waits for user action to the presented list of permissions data and will continue to block  when a user action has been detected. Presentation of the scrollable list preferably presents in an entry format such that an entry contains fields for: DDR  description; GDR owner information, grantor information and grantee information; GRPDR owner information and group name if applicable; and TDR time spec information. Alternate embodiments will present less information, or more information (e.g. GRTDR(s)  and\/or PDR(s)  via GADR(s)  joining fields (e.g. , , )).","If block  determines the user selected to set the list cursor to a different entry, then block  sets the list cursor accordingly and processing continues back to block . Block  always sets for indicating where the list cursor is currently pointed and sets for appropriately scrolling the list if necessary when subsequently presenting the list at block . If block  determines the user did not select to set the list cursor, then processing continues to block . If block  determines the user selected to add a permission, then block  accesses a maximum number of permissions allowed (perhaps multiple maximum values accessed), and block  checks the maximum(s) with the number of current permissions defined. There are many embodiments for what deems a maximum (for this user, for a group, for this MS, etc). If block  determines a maximum number of permissions allowed already exists, then block  provides an error to the user and processing continues back to block . Block  preferably requires the user to acknowledge the error before continuing back to block . If block  determines a maximum was not exceeded, then block  interfaces with the user for entering validated permission data and block  adds the data record(s), appropriately updates the list with the new entry, and sets the list cursor appropriately for the next list presentation refresh, before continuing back to block . If block  determines the user did not want to add a permission, processing continues to block . Block  will add a GDR , DDR , HDR  (to set creator information) and TDR . The DDR and TDR are optionally added by the user, but the DDR may be strongly suggested (if not enforced on the add). This will provide a permission record assigning all privileges from the grantor to the grantee. Additionally, blocks \/ may support adding new GADR(s)  for assigning certain grants and\/or privileges (which are validated to exist prior to adding data at block ).","If block  determines the user selected to delete a permission, then block  deletes the data record currently pointed to by the list cursor, modifies the list for the discarded entry, and sets the list cursor appropriately for the next list presentation refresh, before continuing back to block . Block  will use the granting ID field (associated with the entry at block ) to delete the permission. Associated GADR(s) , DDR , HDR , and TDR  is also deleted (e.g. preferably with a cascade delete in a SQL embodiment). If block  determines the user did not select to delete a permission, then processing continues to block  of  by way of off-page connector .","With reference now to , if block  determines the user selected to modify a permission, then block  interfaces with the user to modify permission data of the entry pointed to by the list cursor. The user may change information of the GDR and any associated records (e.g. DDR, TDR and GADR(s)). The user may also add the associated records at block . Block  waits for a user action indicating completion. Block  will continue to block  when the complete action is detected at block . If block  determines the user exited, then processing continues back to block  by way of off-page connector . If block  determines the user selected to save changes made at block , then block  updates the data and the list is appropriately updated before continuing back to block . Block  may update the GDR and\/or any associated records (e.g. GADR(s), DDR, and\/or TDR) using the permission id field (associated to the entry at block ). Block  will update an associated HDR as well. Block  may add new GADR(s), a DDR and\/or TDR as part of the permission change. If block  determines the user did not select to modify a is permission, then processing continues to block .","If block  determines the user selected to get more details of the permission (e.g. show all joinable data to the GDR that is not already presented with the entry), then block  gets additional details (may involve database queries in an SQL embodiment) for the permission pointed to by the list cursor, and block  appropriately presents the information to the user. Block  then waits for a user action that the user is complete reviewing details, in which case processing continues back to block . If block  determines the user did not select to get more detail, then processing continues to block .","If block  determines the user selected to internalize permissions data thus far being maintained, then block  internalizes (e.g. as a compiler would) all applicable data records for well performing use by the MS, and block  saves the internalized form, for example to MS high speed non-persistent memory. In one embodiment, blocks  and  internalize permission data to applicable C structures of  (also see ). In various embodiments, block  maintains statistics for exactly what was internalized, and updates any running totals or averages maintained for a plurality of internalizations up to this point, or over certain time periods. Statistics such as: number of active constructs; number of user construct edits of particular types; amount of associated storage used, freed, changed, etc with perhaps a graphical user interface to graph changes over time; number of privilege types specified, number of charters affected by permissions; and other permission dependent statistics. In other embodiments, statistical data is initialized at internalization time to prepare for subsequent gathering of useful statistics during permission processing. In embodiments where a tense qualifier is specified for TimeSpec information, saving the internalized form at block  causes all past and current tense configurations to become effective for being processed.","Bock  then continues back to block . If block  determines the user did not select to internalize permission configurations, then processing continues to block . Alternate embodiments of processing permissions  in the present disclosure will rely upon the data records entirely, rather than requiring the user to redundantly internalize from persistent storage to non-persistent storage for use. Persistent storage may be of reasonably fast performance to not require an internalized version of permission . Different embodiments may completely overwrite the internalized form, or update the current internalized form with any changes.","If block  determines the user selected to exit block  processing, then block  cleans up processing thus far accomplished (e.g. issue a stop using database command), and block  completes block  processing. If block  determines the user did not select to exit, then processing continues to block  where all other user actions detected at block  are appropriately handled, and processing continues back to block  by way off off-page connector .",{"@attributes":{"id":"p-0735","num":"1302"},"figref":["FIGS. 40A through 40B","FIG. 40A"],"b":["3814","4002","4004","4006","4006","3540","3520","3520","3520","3520","3520","3540","3540","4006","4008","4006","4008"],"i":["c ","d ","a ","b ","a"]},"Block  accesses all GRTDRs  (e.g. all rows from a GRTDR SQL table) for the user of  matching the owner information of the GRTDRs (e.g. user information matches field ) to the user and to groups the user is a member of (e.g. group information matches field (e.g. owner type=group, owner id=group ID field from block ). The GRTDRs  are additionally joined (e.g. SQL join) with DDRs  and TDRs  (e.g. fields and =Grant and by matching ID fields and with field ). Description field can provide a useful description last saved by the user for the grant data, however the grant name itself is preferably self documenting. Block  may also retrieve system predefined data records for use and\/or management. Block  will also retrieve grants within grants to present the entire tree structure for a grant entry. Block  retrieves all GRTDRs  joined to other GRTDRs  through GADRs  which will provide the grant tree structure hierarchy. Grants can be descendant to other grants in a grant hierarchy. Descendant type field set to Grant and descendant ID field for a particular grant will be a descending grant to an ascending grant of ascendant type field set to Grant and ascendant ID field . Therefore, each list entry is a grant entry that may be any node of a grant hierarchy tree. There may be grant information redundantly presented, for example when a grant is subordinate to more than one grant, but this helps the user know a grant tree structure if one has been configured. A visually presented embodiment may take the following form wherein a particular Grant, appears in the appropriate hierarchy form.",{"@attributes":{"id":"p-0737","num":"1304"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Grant Info"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Grant Info"]},{"entry":[{},"Grant Info"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Grant Info"]},{"entry":[{},"Grant Info"]},{"entry":[{},"..."]},{"entry":[{},"Grant Info"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"..."]},{"entry":[{},"Grant Info"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Grant Info"]},{"entry":[{},"..."]},{"entry":[{},"Grant Info"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["4008","4010","3510","3540","4010","4012","4012","4010","4012","4014","4012","4016","4018","3510","3530","3520"],"i":["a ","a","c"],"figref":"FIG. 40A"},"If block  determines the user selected to set the list cursor to a different grant reference, then block  sets the list cursor accordingly and processing continues back to block . Block  always sets for indicating where the list cursor is currently pointed and sets for appropriately scrolling the list if necessary when subsequently presenting the list at block . If block  determines the user did not select to set the list cursor, then processing continues to block . If block  determines the user selected to add a grant, then block  accesses a maximum number of grants allowed (perhaps multiple maximum values accessed), and block  checks the maximum(s) with the number of current grants defined. There are many embodiments for what deems a maximum (for this user, for a group, for this MS, etc). If block  determines a maximum number of grants allowed already exists, then block  provides an error to the user and processing continues back to block . Block  preferably requires the user to acknowledge the error before continuing back to block . If block  determines a maximum was not exceeded, then block  interfaces with the user for entering validated grant data and block  adds the data record, appropriately updates the list with the new entry, and sets the list cursor appropriately for the next list presentation refresh, before continuing back to block . If block  determines the user did not want to add a grant, processing continues to block . Block  will add a GRTDR , DDR , HDR  (to set creator information) and TDR . The DDR and TDR are optionally added by the user. Additionally, at block  the user may add new GADR(s)  for assigning certain grants to the added grant and\/or privileges to the grant (which are validated to exist prior to adding data at block ).","If block  determines the user selected to modify a grant, then block  interfaces with the user to modify grant data of the entry pointed to by the list cursor. The user may change information of the GRTDR and any associated records (e.g. DDR, TDR and GADR(s)). The user may also add the associated records at block . Block  waits for a user action indicating completion. Block  will continue to block  when the action is detected at block . If block  determines the user exited, then processing continues back to block . If block  determines the user selected to save changes made at block , then block  updates the data and the list is appropriately updated before continuing back to block . Block  may update the GRTDR and\/or any associated records (e.g. GADR(s), DDR, and\/or TDR) using the grant id field (associated to the grant item at block ). Block  will update an associated HDR as well. Block  may add new GADR(s), a DDR and\/or TDR as part of the grant change. If block  determines the user did not select to modify a grant, then processing continues to block  by way of off-page connector .","With reference now to , if block  determines the user selected to get more details of the grant (e.g. show all joinable data to the GRTDR that is not already presented with the entry), then block  gets additional details (may involve database queries in an SQL embodiment) for the grant pointed to by the list cursor, and block  appropriately presents the information to the user. Block  then waits for a user action that the user is complete reviewing details, in which case processing continues back to block  by way of off-page connector . If block  determines the user did not select to get more detail, then processing continues to block .","If block  determines the user selected to delete a grant, then block  determines any data records (e.g. GADR(s) ) that reference the grant data record to be deleted. Preferably, no ascending data records (e.g. GRTDRs) are joinable to the grant data record being deleted, otherwise the user may improperly delete a grant from a configured permission or other grant. In the case of descending grants, all may be cascaded deleted in one embodiment, provided no ascending grants exist for any of the grants to be deleted. The user should remove ascending references to a grant for deletion first. Block  continues to block . If block  determines there was at least one reference, block  provides an appropriate error with the reference(s) found so the user can subsequently reconcile. Block  preferably requires the user to acknowledge the error before continuing back to block . If no references were found as determined by block , then processing continues to block  for deleting the data record currently pointed to by the list cursor, along with any other related records that can be deleted. Block  also modifies the list for the discarded entry(s), and sets the list cursor appropriately for the next list presentation refresh, before continuing back to block . Block  will use the grant ID field (associated with the entry at block ) to delete a grant. Associated records (e.g. DDR , HDR , and TDR ) are also deleted (e.g. preferably with a cascade delete in a SQL embodiment). If block  determines the user did not select to delete a grant, then processing continues to block .","If block  determines the user selected to exit block  processing, then block  cleans up processing thus far accomplished (e.g. issue a stop using database command), and block  completes block  processing. If block  determines the user did not select to exit, then processing continues to block  where all other user actions detected at block  are appropriately handled, and processing continues back to block  by way off off-page connector .",{"@attributes":{"id":"p-0743","num":"1310"},"figref":["FIGS. 41A through 41B","FIG. 41A"],"b":["3818","4102","4104","4106","4106","3540","3520","3520","3520","3520","3520","3540","3540","4106","4108","4106","4108"],"i":["c ","d ","a ","b ","a"]},"Block  accesses all GRPDRs  (e.g. all rows from a GRPDR SQL table) for the user of  matching the owner information of the GRPDRs (e.g. user information matches field ) to the user and to groups the user is a member of (e.g. group information matches field (e.g. owner type=group, owner id=group ID field from block )). The GRPDRs  are additionally joined (e.g. SQL join) with DDRs  and TDRs  (e.g. fields and =Group and by matching ID fields and with field ). Description field can provide a useful description last saved by the user for the group data, however the group name itself is preferably self documenting. Block  may also retrieve system predefined data records for use and\/or management. Block  will also retrieve groups within groups to present the entire tree structure for a group entry. Block  retrieves all GRPDRs  joined to other GRPDRs  through GADRs  which will provide the group tree structure hierarchy. Groups can be descendant to other groups in a group hierarchy. Descendant type field set to Group and descendant ID field for a particular group will be a descending group to an ascending group of ascendant type field set to Group and ascendant ID field . Therefore, each list entry is a group entry that may be any node of a group hierarchy tree. There may be group information redundantly presented, for example when a group is subordinate to more than one group, but this helps the user know a group tree structure if one has been configured. A visually presented embodiment may take the following form wherein a particular Group, appears in the appropriate hierarchy form.",{"@attributes":{"id":"p-0745","num":"1312"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Group Info"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Group Info"]},{"entry":[{},"Group Info"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Group Info"]},{"entry":[{},"Group Info"]},{"entry":[{},"..."]},{"entry":[{},"Group Info"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"..."]},{"entry":[{},"Group Info"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Group Info"]},{"entry":[{},"..."]},{"entry":[{},"Group Info"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["4108","4110","3540","4110","4112","4112","4110","4112","4114","4112","4116","4118","3540","3520"],"i":["a","c"],"figref":"FIG. 41A"},"If block  determines the user selected to set the list cursor to a different group entry, then block  sets the list cursor accordingly and processing continues back to block . Block  always sets for indicating where the list cursor is currently pointed and sets for appropriately scrolling the list if necessary when subsequently presenting the list at block . If block  determines the user did not select to set the list cursor, then processing continues to block . If block  determines the user selected to add a group, then block  accesses a maximum number of groups allowed (perhaps multiple maximum values accessed), and block  checks the maximum(s) with the number of current groups defined. There are many embodiments for what deems a maximum (for this user, for a group, for this MS, etc). If block  determines a maximum number of groups allowed already exists, then block  provides an error to the user and processing continues back to block . Block  preferably requires the user to acknowledge the error before continuing back to block . If block  determines a maximum was not exceeded, then block  interfaces with the user for entering validated group data and block  adds the data record, appropriately updates the list with the new entry, and sets the list cursor appropriately for the next list presentation refresh, before continuing back to block . If block  determines the user did not want to add a group, processing continues to block . Block  will add a GRPDR , DDR , HDR  (to set creator information) and TDR . The DDR and TDR are optionally added by the user. Additionally, at block  the user may add new GADR(s)  for assigning certain groups to the added group and\/or identities to the group (which are validated to exist prior to adding data at block ).","If block  determines the user selected to modify a group, then block  interfaces with the user to modify group data of the entry pointed to by the list cursor. The user may change information of the GRPDR and any associated records (e.g. DDR, TDR and GADR(s)). The user may also add the associated records at block . Block  waits for a user action indicating completion. Block  will continue to block  when the complete action is detected at block . If block  determines the user exited, then processing continues back to block . If block  determines the user selected to save changes made at block , then block  updates the data and the list is appropriately updated before continuing back to block . Block  may update the GRPDR and\/or any associated GADR(s), DDR, and\/or TDR using the group id field associated to the group item at block . Block  will update an associated HDR as well. Blocks \/ may support adding new GADR(s), a DDR and\/or TDR as part of the group change. If block  determines the user did not select to modify a group, then processing continues to block  by way of off-page connector .","With reference now to , if block  determines the user selected to get more details of the group (e.g. show all joinable data to the GRPDR that is not already presented with the entry), then block  gets additional details (may involve database queries in an SQL embodiment) for the group pointed to by the list cursor, and block  appropriately presents the information to the user. Block  then waits for a user action that the user is complete reviewing details, in which case processing continues back to block  by way of off-page connector . If block  determines the user did not select to get more detail, then processing continues to block .","If block  determines the user selected to delete a group, then block  determines any data records (e.g. GADR(s) ) that reference the group data record to be deleted. Preferably, no ascending data records (e.g. GRPDRs) are joinable to the group data record being deleted, otherwise the user may improperly delete a group from a configured permission or other group. In the case of descending groups, all may be cascaded deleted in one embodiment, provided no ascending groups exist for any of the groups to be deleted. The user should remove ascending references to a group for deletion first. Block  continues to block . If block  determines there was at least one reference, block  provides an appropriate error with the reference(s) found so the user can subsequently reconcile. Block  preferably requires the user to acknowledge the error before continuing back to block . If no references were found as determined by block , then processing continues to block  for deleting the data record currently pointed to by the list cursor, along with any other related records that can be deleted. Block  also modifies the list for the discarded entry(s), and sets the list cursor appropriately for the next list presentation refresh, before continuing back to block . Block  will use the group ID field (associated with the entry at block ) to delete the group. Associated records (e.g. DDR , HDR , and TDR ) are also deleted (e.g. preferably with a cascade delete in a SQL embodiment). If block  determines the user did not select to delete a group, then processing continues to block .","If block  determines the user selected to exit block  processing, then block  cleans up processing thus far accomplished (e.g. issue a stop using database command), and block  completes block  processing. If block  determines the user did not select to exit, then processing continues to block  where all other user actions detected at block  are appropriately handled, and processing continues back to block  by way off off-page connector .",{"@attributes":{"id":"p-0751","num":"1318"},"figref":["FIG. 42","FIG. 42"],"b":["4202","4204","4206","4208","4208","4210"]},"In an alternative embodiment, block  appropriately accesses privileges granted from the owner criteria to the user of  to ensure the user has a privilege to browse the data records (per object type parameter) of the specified owner. Block  will provide an error when there is no privilege, and will continue to block  when there is a privilege. Block  may also provide a user exit option for continuing to block  for cases the user cannot successfully specify owner criteria. In similar embodiments, there may be a separate privilege required for each object type a user may browse.","Block  gets (e.g. SQL selects) data according to the object type parameter (e.g. GRPDR(s), GDR(s), GRTDR(s), CDR(s), ADR(s) or PARMDR(s), along with any available associated joinable data (e.g. DDR(s), HDR(s), TDR(s) and data records via GADR(s) if applicable), per object type passed). There are various embodiments to block  in accessing data: locally maintained data for the owner criteria specified at block , communicating with a remote MS for accessing the MS of the owner criteria to synchronously pull the data, or sending a request to a remote MS over an interface like interface  for then asynchronously receiving by an interface like interface  for processing. Block  may access field in the case of filtering desired charter records. One preferred embodiment is to locally maintain relevant data. In privilege enforced embodiments, appropriate privileges are determined before allowing access to the other's data.","Thereafter, if block  determines there were no data records according to the object type passed by the caller for the owner criteria specified at block , then block  provides an error to the user, and processing continues to block . Block  performs cleanup of processing thus far accomplished (e.g. perform a stop using database command), and then continues to block  for returning to the caller of  processing. Block  preferably requires the user to acknowledge the error before continuing to block .","If block  determines at least one data record of object type was found, then block  presents a browse-able scrollable list of entries to the user (i.e. similar to lists discussed for presentation by , , , ,  or , per object typed passed), and block  waits for a user action in response to presenting the list. When a user action is detected at block , processing continues to block . If block  determines the user selected to specify new owner criteria (e.g. for comparison to field , , , , or , per object type passed) for browse, then processing continues back to block  for new specification and applicable processing already discussed for blocks thereafter. If block  determines the user did not select to specify new owner criteria, processing continues to block .","If block  determines the user selected to get more detail of a selected list entry, then processing continues to block  for getting data details of the selected entry, and block  presents the details to the user, and waits for user action. Detail presentation is similar to getting detail processing discussed for presentation by , , , ,  or , per object typed passed. Block  continues to block  upon a user action (complete\/clone).","If block  determines the user action from block  was to exit browse, processing continues to block . If block  determines the user action from block  was to clone the data (e.g. to make a copy for user's own use), processing continues to block  for accessing permissions. Thereafter, if block  determines the user does not have permission to clone, processing continues to block  for reporting an error (preferably requiring the user to acknowledge before leaving block  processing), and then back to block . If block  determines the user does have permission to clone, processing continues to block  where the data item browsed is appropriately duplicated with defaulted fields as though the user of  processing had created new data himself. Processing then continues back to block . If block  determines the user did not select to get more detail on a selected item, then processing continues to block .","If block  determines the user selected to exit browse processing, then processing continues to block  already described. If block  determines the user did not select to exit, then processing continues to block  where all other user actions detected at block  are appropriately handled, and processing continues back to block .","In an alternate embodiment,  will support cloning multiple entries in one action so that a first user conveniently makes use of a second user's data (like starter template(s)) for the first user to create\/configure new data without entering it from scratch in the other interfaces disclosed. Another embodiment will enforce unique privileges for which data can be cloned by which user(s).",{"@attributes":{"id":"p-0760","num":"1327"},"figref":"FIG. 43","b":["10","12","10","12","2","2","4302","4304","4306"],"ul":{"@attributes":{"id":"ul0081","list-style":"none"},"li":{"@attributes":{"id":"ul0081-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0082","list-style":"none"},"li":["Accept no data (MS will not accept data from any source); or","Accept all data (MS will accept data from any source); or","Accept data according to permissions (MS will accept data according to those sources which have permission to send certain data (perhaps privilege also specifies by a certain method) to the MS).\n\nAnd the second set being:\n","Targeted data packet sent or broadcast data packet sent (preferably one or the other);","Electronic Mail Application;","SMS message; and\/or","Persistent Storage Update (e.g. file system).\n\nBlock  continues to block  where the user makes a selection in the first set, and any number of selections in the second set. Thereafter, processing at block  saves the user's selections for the object type parameter passed, and processing returns to the caller at block . LBX processing may have intelligence for an hierarchy of attempts such as first trying to send or broadcast, if that fails send by email, if that fails send by SMS message, and if that fails alert the MS user for manually copying over the data at a future time (e.g. when MSs are in wireless vicinity of each other). Block  may provide a user selectable order of the attempt types. Intelligence can be incorporated for knowing which data was sent, when it was sent, and whether or not all of the send succeeded, and a synchronous or asynchronous acknowledgement can be implemented to ensure it arrived safely to destination(s). Applicable information is preferably maintained to LBX history  for proper implementation.\n"]}}}},"In one embodiment, the second set of configurations is further governed by individual privileges (each send type), and\/or privileges per a source identity. For example, while configurations of the second set may be enabled, the MS will only accept data in a form from a source in accordance with a privilege which is enabled (set for the source identity). Privilege examples (may also each have associated time specification) include:\n\n","In some embodiments, charter data that is received may be received by a MS in a deactivated form whereby the user of the receiving MS must activate the charters for use (e.g. use of charter enabled field for indicating whether or not the charter is active (Y=Yes, N=No)). Field may also be used by the charter originator for disabling or enabling for a variety of reasons. This permits a user to examine charters, and perhaps put them to a test, prior to putting them into use. Other embodiments support activating charters (received and\/or originated): one at a time, as selected sets by user specified criteria (any charter characteristic(s)), all or none, by certain originating user(s), by certain originating MS(s), or any other desirable criteria. Of course, privileges are defined for enabling accepting privileges or charters from a MS, but many privileges can be defined for accepting privileges or charters with certain desired characteristics from a MS.",{"@attributes":{"id":"p-0763","num":"1341"},"figref":["FIG. 44A","FIG. 44A","FIG. 44A","FIG. 44A","FIG. 44A","FIG. 44A","FIG. 44A"],"b":["6","10","12","24","4430","24","24","24","24"]},"In any case, see detailed explanations of , as well as supporting exemplifications shown in , respectively. Processing begins at block , continues to block  where the caller parameter passed to  processing is determined (i.e. OBJ_TYPE), and processing continues to block  for interfacing with the user to specify targets to send data to, in context of the object type parameter specified for sending (PERMISSION_INFO or CHARTER_INFO). An alternate embodiment will consult a configuration of data for validated target information. Depending on the present disclosure embodiment, a user may specify any reasonable supported (ID\/IDType) combination of the BNF grammar ID construct (see ) as valid targets. Validation will validate at least syntax of the specification. In another embodiment, block  will access and enforce known permissions for validating which target(s) (e.g. grantor(s)) can be specified. Various embodiments will also support wildcarding the specifications for a group of ID targets (e.g. department* for all department groups). Additional target information is to be specified when required for sending, for example, if email or SMS message is to be used as a send method (i.e. applicable destination recipient addresses to be specified). An alternate embodiment to block  accesses mapped delivery addresses from a database, or table, (referred to as a Recipient Address Book (RAB)) associating a recipient address to a target identity, thereby alleviating the user from manual specification, and perhaps allowing the user to save to the RAB for any new useful RAB data. In another embodiment, block  (discussed below) accesses the RAB for a recipient address for the target when preparing the data for sending.","Upon validation at block , processing continues to block . It is possible the user was unsuccessful in specifying targets, or wanted to exit block  processing. If block  determines the user did not specify at least one validated target (equivalent to selecting to exit  processing), then processing continues to block  where processing returns to the caller. If block  determines there is at least one target specified, then block  accesses LBX history  to determine if any of the targets have been sent the specific data already. Thereafter, if block  determines the most recently updated data for a target has already been sent, then block  presents an informative error to the user, preferably requiring user action. Block  continues to block  when the user performs the action. If block  determines the user selected to ignore the error, then processing continues to block , otherwise processing continues back to block  for updating target specifications.","Block  interfaces with the user to specify a delivery method. Preferably, there are defaulted setting(s) based on the last time the user encountered block . Any of the \u201csecond set\u201d of options described with  can be made. Thereafter, block  logs to LBX history  the forthcoming send attempt and gets the next target from block  specifications before continuing to block . If block  determines that all targets have not been processed, then block  determines applicable OBJ_TYPE data for the target (e.g. check LBX history  for any new data that was not previously successfully sent), and block  gets (e.g. preferably new data, or all, depending on embodiment) the applicable target's OBJ_TYPE data (permissions or charters) before continuing to block . Block  formats the data for sending in accordance with the specified delivery method, along with necessary packet information (e.g. source identity, wrapper data, etc) of this loop iteration (from block ), and block  sends the data appropriately. For a broadcast send, block  broadcasts the information (using a send interface like interface ) by inserting to queue  so that send processing broadcasts data  (e.g. on all available communications interface(s) ), for example as far as radius , and processing continues to block . The broadcast is for reception by data processing systems (e.g. MSs) in the vicinity (see , as further explained in detail by  which includes potentially any distance). For a targeted send, block  formats the data intended for recognition by the receiving target. Block  causes sending\/broadcasting data  containing CK , depending on the type of MS, wherein CK  contains information appropriately. In a send email embodiment, confirmation of delivery status may be used to confirm delivery with an email interface API to check the COD (Confirmation of Delivery) status, or the sending of the email (also SMS message) is assumed to have been delivered in one preferred embodiment.","In an embodiment wherein usual MS communications data  of the MS is altered to contain CK  for listening MSs in the vicinity, send processing feeding from queue , caused by block  processing, will place information as CK  embedded in usual data  at the next opportune time of sending usual data . This embodiment will replace synchronous sending success validation of blocks  through  and multiple delivery methods of  (and subsequent loop processing) with status asynchronously updated by the receiving MS(s) for a single type of delivery method selected at block . An alternate embodiment will attempt the multiple send types in an appropriate asynchronous thread of processing depending on success of a previous attempt. As the MS conducts its normal communications, transmitted data  contains new data CK  to be ignored by receiving MS other character  processing, but to be found by listening MSs within the vicinity which anticipate presence of CK . Otherwise, when LN-Expanse deployments have not introduced CK  to usual data  communicated on a receivable signal by MSs in the vicinity,  sends\/broadcasts new data .","For sending an email, SMS message, or other application delivery method, block  will use the additional target information (recipient address) specified via block  for properly sending. Thereafter, block  waits for a synchronous acknowledgement if applicable before either receiving one or timing out. If a broadcast was made, one (1) acknowledgement may be all that is necessary for validation, or all anticipated targets can be accounted for before deeming a successful ack. An email, SMS message, or other application send may be assumed reliable and that an ack was received. Thereafter, if block  determines an applicable ack was received (i.e. data successfully sent\/received), or none was anticipated (i.e. assume got it), then processing continues back to block  for processing any next target(s). If block  determines an anticipated ack was not received, then block  logs the situation to LBX history  and the next specified delivery method is accessed. Thereafter, if block  determines all delivery methods have already been processed for the current target, then processing continues to block  for logging the overall status and providing an error to the user. Block  may require a user acknowledgement before continuing back to block . If block  determines there is another specified delivery method for sending, then processing continues back to block  for sending using the next method.","Referring back to block , if all targets are determined to have been processed, then block  maintains  processing results to LBX history  and the caller is returned to at block . In an alternate embodiment to  processing, a trigger implementation is used for sending\/broadcasting data at the best possible time (e.g. when new\/modified permissions or charters information is made for a target) as soon as possible, as soon as a target is detected to be nearby, or in the vicinity (vicinity is expanded as explained by ), or as soon as the user is notified to send (e.g. in response to a modification) and then acknowledges to send. See  for explanation of communicating data from a first MS to a second MS over greater distances. In another embodiment, background thread(s) timely poll (e.g. per user or system configurations) the permissions and\/or charters data to determine which data should be sent, how to send it, who to send it to, what applicable permissions are appropriate, and when the best time is to send it. A time interval, or schedule, for sending data to others on a continual interim basis may also be configured. This may be particularly useful as a user starts using a MS for the first time and anticipates making many configuration changes. The user may start or terminate polling threads as part of FIGS. A\/B processing, so that  is relied on to make sure permissions and\/or charters are communicated as needed. Appropriate blocks of  will also interface to statistics  for reporting successes, failures and status of  processing.","In sum,  provide a LBX peer to peer method for ensuring permissions and charters are appropriately maintained at MSs, wherein  sends in a peer to peer fashion and  receives in a peer to peer to fashion. Thus, permissions  and charters  are sent from a first MS to a second MS for configuring maintaining, enforcing, and\/or processing permissions  and charters  at an MS. There is no intermediary service required for permissions and charters for LBX interoperability.  demonstrates a preferred push model. A pull model may be alternatively implemented. An alternative embodiment may make a request to a MS for its permissions and\/or charters and then populate its local image of the data after receiving the response. Privileges would be appropriately validated at the sending MS(s) and\/or receiving MS(s) in order to ensure appropriate data is sent\/received to\/from the requesting MS.",{"@attributes":{"id":"p-0771","num":"1349"},"figref":["FIG. 44B","FIG. 44B","FIG. 18","FIG. 29A","FIG. 29B","FIG. 44B","FIGS. 33A through 33C","FIG. 44B"],"b":["6","19","1900","19","1942","26","24","1220","1240","1436","1456","1516","1536","2804","2818","1900","1226","2806","1900","1444","1900","26"]},"In an alternative embodiment having multiple receiving transmission channels visible to the RxCD process, there can be a RxCD worker thread per channel to handle receiving on multiple channels simultaneously. If RxCD thread(s) do not receive directly from the channel, the preferred embodiment of  would not need to convey channel information to RxCD thread(s) waiting on queue  anyway. Embodiments could allow specification\/configuration of many RxCD thread(s) per channel.","A RxCD thread processing begins at block  upon the MS receiving permission data and\/or charter data, continues to block  where the process worker thread count RxCD-Ct is accessed and incremented by 1 (using appropriate semaphore access (e.g. RxCD-Sem)), and continues to block  for retrieving from queue  sent data (using interface like interface ), perhaps a special termination request entry, and only continues to block  when a record of data (permission\/charter data, or termination record) is retrieved. In one embodiment, receive processing deposits X.409 encoding data as record(s) to queue , and may break up a datastream into individual records of data from an overall received (or ongoing) datastream. In another embodiment, XML is received and deposited to queue , or some other suitable syntax is received as derived from the BNF grammar. In another embodiment, receive processing receives data in one format and deposits a more suitable format for  processing. Receive processing embodiments may deposit \u201cpiece-meal\u201d records of data as sent, \u201cpiece-meal\u201d records broken up from data received, full charter or permission datastreams and\/or subsets thereof to queue  for processing by .","Block  stays blocked on retrieving from queue  until any record is retrieved, in which case processing continues to block . If block  determines a special entry indicating to terminate was not found in queue , processing continues to block . There are various embodiments for RxCD thread(s), thread(s)  and thread(s)  to feed off a queue  for different record types, for example, separate queues A, B and C, or a thread target field with different record types found at queue  (e.g. like field ). In another embodiment, there are separate queues C and D for separate processing of incoming charter and permission data. In another embodiment, thread(s)  are modified with logic of RxCD thread(s) to handle permission and\/or charter data records, since thread(s)  are listening for queue  data anyway. In another embodiment, there are segregated RxCD threads RxCD-P and RxCD-C for separate permission and charter data processing.","Block  validates incoming data for this targeted MS before continuing to block . A preferred embodiment of receive processing already validated the data is intended for this MS by having listened specifically for the data, or by having already validated it is at the intended MS destination (e.g. block  can continue directly to block  (no block  and block  required)). If block  determines the data is valid for processing, then block  accesses the data source identity information (e.g. owner information, sending MS information, grantor\/grantee information, etc, as appropriate for an embodiment), block  accesses acceptable delivery methods and\/or permissions\/privileges for the source identity to check if the data is eligible for being received, and block  checks the result. Depending on an embodiment, block  may enforce an all or none privilege for accepting the privilege or charter data, or may enforce specific privileges from the receiving MS (MS user) to the sending MS (MS user) for exactly which privileges or charters are acceptable to be received and locally maintained.","If block  determines the delivery is acceptable (and perhaps privileged, or privileged per source), then block  appropriately updates the MS locally with the data (depending on embodiment of , block  may remove from existing data at the MS as well as per privilege(s)), block  completes an acknowledgment, and block  sends\/broadcasts the acknowledgement (ack), before continuing back to block  for more data. Block  sends\/broadcasts the ack (using a send interface like interface ) by inserting to queue  so that send processing transmits data , for example as far as radius . Embodiments will use the different correlation methods already discussed above, to associate an ack with a send. In some embodiments, block  may default field in the case of receiving charter records.","If block  determines the data is not acceptable, then processing continues directly back to block . For security reasons, it is best not to respond with an error. It is best to ignore the data entirely. In another embodiment, an error may be returned to the sender for appropriate error processing and reporting. Referring back to block , if it is determined that the data is not valid, then processing continues back to block .","Referring back to block , if a worker thread termination request was found at queue , then block  decrements the RxCD worker thread count by 1 (using appropriate semaphore access (e.g. RxCD-Sem)), and RxCD thread processing terminates at block . Block  may also check the RxCD-Ct value, and signal the RxCD process parent thread that all worker threads are terminated when RxCD-Ct equals zero (0).","Block  causes sending\/broadcasting data  containing CK , depending on the type of MS, wherein CK  contains ack information prepared. In the embodiment wherein usual MS communications data  of the MS is altered to contain CK  for listening MSs in the vicinity, send processing feeding from queue , caused by block  processing, will place ack information as CK  embedded in usual data  at the next opportune time of sending usual data . As the MS conducts its normal communications, transmitted data  contains new data CK  to be ignored by receiving MS other character  processing, but to be found by listening MSs within the vicinity which anticipate presence of CK . Otherwise, when LN-Expanse deployments have not introduced CK  to usual data  communicated on a receivable signal by MSs in the vicinity,  sends\/broadcasts new ack data .","In an alternate embodiment, permission and\/or charter data records contain a sent date\/time stamp field of when the data was sent by a remote MS, and a received date\/time stamp field (like field ) is processed at the MS in  processing. This would enable calculating a TDOA measurement while receiving data (e.g. permissions and\/or charter data) that can then be used for location determination processing as described above.","For other acceptable receive processing, methods are well known to those skilled in the art for \u201chooking\u201d customized processing into application processing of sought data received. For example, in an email application, a callback function API is preferably made available to the present disclosure so that every time an applicable received email distribution is received with specified criteria (e.g. certain subject, certain attached file name, certain source, or any other identifiable email attribute(s) (provided by present disclosure processing to API)) sent by block , the callback function (provided by present disclosure processing to the appropriate API) is invoked for custom processing. In this example, the present disclosure invokes the callback API for providing: the callback function to be invoked, and the email criteria for triggering invocation of the callback function; for processing of permissions or charter data. For example, a unique subject field indicates to the email application that the email item should be directed by the email application to the callback function for processing. The present disclosure callback function then parses permissions and\/or charter information from the email item and updates local permissions  and\/or charters . Data received in the email item may be textual syntax derived from the BNF grammar in an email body or attached file form, XML syntax derived from the BNF grammar in email body or attached file form, an X.409 binary encoding in attached file form, or other appropriate format received with the email item (e.g. new Document Interchange Architecture (DIA) attribute data, etc). DIA is an IBM electronic mail (email) interchange protocol standard between email systems. A process return status is preferably returned by the callback function, for example for appropriate email confirmation of delivery processing.","In another embodiment, the present disclosure provides at least one thread of processing for polling a known API, or email repository, for sought criteria (e.g. attributes) which identifies the email item as destined for present disclosure processing. Once the email item(s) are found, they are similarly parsed and processed for updating permissions  and\/or charters .","Thus, there are well known methods for processing data in context of this disclosure for receiving permissions  and\/or charters  from an originating MS to a receiving MS, for example when using email. Similarly (callback function or polling), SMS messages can be used to communicate data  and\/or  from one MS to another MS, albeit at smaller data exchange sizes. The sending MS may break up larger portions of data which can be sent as parse-able text (e.g. source syntax, XML, etc. derived from the BNF grammar) to the receiving MS. It may take multiple SMS messages to communicate the data in its entirety.","Regardless of the type of receiving application, those skilled in the art recognize many clever methods for receiving data in context of a MS application which communicates in a peer to peer fashion with another MS (e.g. callback function(s), API interfaces in an appropriate loop which can remain blocked until sought data is received for processing, polling known storage destinations of data received, or other applicable processing).","Permission data  and charter data  may be manually copied from one MS to another over any appropriate communications connection between the MSs. Permission data  and charter data  may also be manually copied from one MS to another MS using available file management system operations (move or copy file\/data processing). For example, a special directory can be defined which upon deposit of a file to it, processing parses it, validates it, and uses it to update permissions  and\/or charters . Errors found may also be reported to the user, but preferably there are automated processes that create\/maintain the file data to prevent errors in processing. Any of a variety of communications wave forms can be used depending on MS capability.",{"@attributes":{"id":"p-0786","num":"1364"},"figref":["FIG. 45A","FIG. 45A","FIG. 46A","FIG. 47A","FIG. 48A","FIG. 42","FIG. 42","FIG. 42","FIG. 44A","FIG. 43"],"b":["1482","18","4502","4504","4506","4506","4508","4508","4510","4504","4508","4512","4512","4514","4504","4512","4516","4516","4518","4504","4516","4520","4520","4522","4504","4520","4524","4524","4526","4504","4524","4528","4528","4530","4504","4528","4532","4532","4534","4504","4532","4536","4536","4538","4504","4536","4540","4540","1482","4542","1482","4540","4544","4506","4504"]},"In an alternate embodiment where the MS maintains GDRs, GADRs, CDRs, ADRS, PARMDRs and GRPDRs (and their associated data records DDRs, HDRs and TDRs) at the MS where they were configured,  may not provide blocks  through . The MS may be aware of its user charters and need not share the data (i.e. self contained). In some embodiments, options  through  cause access to locally maintained data for others (other users, MSs, etc) or cause remote access to data when needed (e.g. from the remote MSs). In the embodiment where no data is maintained locally for others, blocks  through  may not be necessary. In sum, the preferred embodiment is to locally maintain charters data for the MS user and others (e.g. MS users) which are relevant to provide the richest set of charters governing MS processing at the MS.",{"@attributes":{"id":"p-0788","num":"1366"},"figref":["FIG. 45B","FIG. 45B","FIG. 45B"],"b":["3790","3795","1496","1496","1496","1496"],"i":["h","i","c "],"ul":{"@attributes":{"id":"ul0085","list-style":"none"},"li":{"@attributes":{"id":"ul0085-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0086","list-style":"none"},"li":["Block checks to see if the user selected to configure enablement or disablement of charters\u2014an option for configuration at block  wherein the user action to configure it is detected at block ;","Block is processed if block determines the user did select to configure charters for enabled\/disable. Block invokes  for interfacing with the user accordingly, and processing then continues to block ","Block is processed if block determines the user did not select to configure charters for enable\/disable, or as the result of processing leaving block . Block handles other user interface actions leaving block  (e.g. becomes the \u201ccatch all\u201d as currently shown in block  of )."]}}}},"CSR configuration begins at block  upon a user action to present the interface. In one embodiment, the user is an authenticated administrator prior to being permitted to get access to processing of . Block  continues to block  where the user is able to specify which search criteria to use against CSR fields, charter fields and sort preferences thereof. Any view of charters can be retrieved using any combination of values of CSRs, CDRs, ADRs, and PARMDRs. For example, all charters using certain atomic commands, expressions conditions, etc may be searched and provided in a list for enablement or disablement as a set. In a simple example, the user specifies to retrieve all charters associated to a category of \u201cShopping\u201d (e.g. found in field ), and associated to the applications of \u201cCalendar\u201d and \u201cMessaging\u201d (e.g. found in field ), in a sorted key order of category first and application next, both in alphabetic ascending order. Snippets field may also be specified by the user for search. Various block  embodiments support searching on entire entries of any of the CSR or charter record fields, or in any subset string(s) of the fields. Sort order can be ascending or descending with a specified key order (e.g. first, then within each of those rows found).","Thereafter, block  accesses all joined CSRs and CDRs through the CDR2CSR records  for returning all sought charters. Preferably, CSRs drive the ability to correlate associated CDRs when searching on at least one CSR field (e.g. SQL inner join). Processing preferably presents the list of charters found as a list of entries wherein each entry contains enough information to determine there is a unique charter, which search criteria it pertains to, and whether or not it is currently enabled or disabled (e.g. field ). Also, each entry has associated to it the charter id field and charter starter id field for convenient subsequent I\/O operations. Thereafter, block  waits for a user action in response to the list which can be scrolled, and a specific entry selected for an applicable action. Block  continues to block  when a user action is detected.","If block  determines the user selected to enable all charters of the list presented at block , then block  updates all the charters to enabled (e.g. updates field to enabled), block  refreshes and re-presents the list to reflect changes, and processing continues back to block . If block  determines the user did not select to enable the search result charters of the list, then processing continues to block .","If block  determines the user selected to disable all charters of the list presented at block , then block  updates all the charters to disabled (e.g. updates field to disabled), block  refreshes and re-presents the list to reflect changes, and processing continues back to block . If block  determines the user did not select to disable the search result charters of the list, then processing continues to block .","If block  determines the user selected to manage (i.e. add, change, delete, view details, etc) information of a specific charter of the list, block  interfaces with the user for managing\/maintaining the specified charter information and validating any modifications if applicable before continuing to block  already described. If block  determines the user did not select to manage a charter, then processing continues to block . Blocks  and  may include processing for managing charter data as already described in , A, B, A, B, A and B. It should be understood that applicable charter management processing of those Figures can be embodied in  for user convenience.","If block  determines the user selected to use at least one snippet of a charter list entry, then block  accesses data of associated field where the user can select at least one snippet for in turn creating a new charter. Block  enables a user to make use of charter snippets as executable starters for new charters. Thereafter, processing continues to block . If block  determines the user did not select to use snippet data, then processing continues to block . An enabled or disabled charter may be created as a result of block  if the user desires so. Snippets are charter portions (i.e. subsets) which make it convenient to clone, and from which to create new charters. In some embodiments, a reasonable plurality of subset snippets is automatically generated from charter data when adding a CDR2CSR record (block ). If more than one charter is joinable to the CSR, then many snippets may potentially be automatically made from associated charters for subsequent use at block .","If block  determines the user selected to specify new search criteria, then processing continues back to block , otherwise processing continues to block .","If block  determines the user selected to exit  processing, then block  terminates the  interface and block  terminates  processing. If block  determines the user did not select to exit, then processing continues to block .","If block  determines the user selected to create a CSR, then block  interfaces with the user to create one and terminate that interface before processing continues back to block  since there are no list changes. If block  determines the user did not select to create a CSR, then processing continues to block .","If block  determines the user selected to change a CSR associated to a particular charter list entry, then block  interfaces with the user to modify it, validate any changes, and terminate that interface before processing continues to block . Any charters of the list from the search result that now do not meet the search criteria are removed from the list at block  processing. Any charters of the list from the search result that now newly meet the search criteria are added to the list at block  processing. If block  determines the user did not select to change a CSR, then processing continues to block .","If block  determines the user selected to delete a CSR associated to a particular charter list entry, then block  interfaces with the user to delete it and terminate that interface before processing continues to block . Any charters of the list from the search result that do not meet the search criteria are removed from the list at block  processing. If block  determines the user did not select to delete a CSR, then processing continues to block .","If block  determines the user selected to add a CSR or delete a list entry CSR, then block  interfaces with the user to add or delete before terminating that interface and continuing processing to block . In a preferred embodiment, the associated snippet(s) field is automatically updated with reasonable useful charter subsets (e.g. conditions, expressions, actions, etc). In another embodiment, a user manually updates CSR field at blocks  and . Any charters of the list from the search result that do not meet the search criteria are removed from the list at block  processing. Any charters of the list from the search result that now newly meet the search criteria are added to the list at block  processing. If block  determines the user did not select to add or delete a CDR2CSR, then processing continues to block  where any other action leaving block  is appropriately handled. Block  continues to block .","In some embodiments, and in accordance with permissions, users may access another user's data for the same  processing to maintain another user's data and make use of other's snippets. It may be useful to determine which of other's charters should be enabled or disabled. In other embodiments, snippets may include tag fields to identify a snippet description for facilitating which snippets to use, or for what purpose to use snippets. Snippets provide building blocks to build new and useful charters. A user may use his own or other's snippets to create new charters. In an alternate embodiment, categories and applications are maintained as folders for encapsulating and organizing charters, and may be visually presented that way to a user for easy interpretation (as opposed to charters starters schema of ). The most recent set of enabled charters are those that remain in effect from that point in time forward for MS processing. In other embodiments, configured charters for WITS processing are affected (e.g. removed, altered, etc) by  processing.",{"@attributes":{"id":"p-0802","num":"1383"},"figref":["FIGS. 46A through 46B","FIG. 46A"],"b":["4510","4602","4604","4606","4606","3540","3520","3520","3520","3520","3520","3540","4606","4608","4606","4608"],"i":["c ","d ","a ","b ","a"]},"Block  accesses all CDRs (e.g. all rows from a CDR SQL table) with enabled field set to Yes for the user of  (e.g. user information matches field ), and for the groups the user is a member of (e.g. group information matches field (e.g. owner type=group, owner id=a group ID field from block )). The CDRs are additionally joined (e.g. SQL join) with GDRs, DDRs and TDRs (e.g. fields , and =Charter and by matching ID fields , and with field ). Description field can provide a useful description last saved by the user for the charter entry. Block  may access field in the case of filtering desired charter records. Block  may also retrieve system predefined data records for use and\/or management. Thereafter, each joined entry returned at block  is associated at block  with the corresponding data IDs (at least fields \/and ) for easy unique record accesses when the user acts on the data. Block  also initializes a list cursor to point to the first list entry to be presented to the user. Thereafter, block  sets user interface indication for where the list cursor is currently set (e.g. set to highlight the entry), and any list scrolling settings are set (the list is initially not set for being scrolled on first  processing encounter to block  from block ). Block  continues to block  where the entry list is presented to the user in accordance with the list cursor and list scroll settings managed for presentation at block . Thereafter, block  waits for user action to the presented list of charters data and will continue to block  when a user action has been detected. Presentation of the scrollable list preferably presents in an entry format such that an entry contains fields for: DDR  description; GDR owner information, grantor information and grantee information; GRPDR owner information and group name if applicable; CDR information; and TDR time spec information. Alternate embodiments will present less information, or more information (e.g. join to ADR and\/or PARMDR information).","If block  determines the user selected to set the list cursor to a different entry, then block  sets the list cursor accordingly and processing continues back to block . Block  always sets for indicating where the list cursor is currently pointed and sets for appropriately scrolling the list if necessary when subsequently presenting the list at block . If block  determines the user did not select to set the list cursor, then processing continues to block . If block  determines the user selected to add a charter, then block  accesses a maximum number of charters allowed (perhaps multiple maximum values accessed), and block  checks the maximum(s) with the number of current charters defined. There are many embodiments for what deems a maximum (for this user, for a group, for this MS, etc). If block  determines a maximum number of charters allowed already exists, then block  provides an error to the user and processing continues back to block . Block  preferably requires the user to acknowledge the error before continuing back to block . If block  determines a maximum was not exceeded, then block  interfaces with the user for entering validated charter data and block  adds the data record(s), appropriately updates the list with the new entry, and sets the list cursor appropriately for the next list presentation refresh, before continuing back to block . If block  determines the user did not want to add a charter, processing continues to block . Block  will add a CDR, GDR, DDR, HDR (to set creator information) and TDR. The DDR and TDR are optionally added by the user, but the DDR may be strongly suggested (if not enforced on the add). This will provide a charter record. Additionally, block  may add new ADR(s) and\/or PARMDR(s) (which are validated to exist prior to adding data at block ). In one embodiment, a GDR associated to the CDR is not added; for indicating the user wants his charter made available to all other user MSs which are willing to accept it.","If block  determines the user selected to delete a charter, then block  deletes the data record currently pointed to by the list cursor, modifies the list for the discarded entry, and sets the list cursor appropriately for the next list presentation refresh, before continuing back to block . Block  will use the Charter ID field \/(associated with the entry at block ) to delete the charter. Associated CDR, ADR(s), PARMDR(s), DDR , HDR , and TDR  is also deleted (e.g. preferably with a cascade delete in a SQL embodiment). If block  determines the user did not select to delete a charter, then processing continues to block  of  by way of off-page connector .","With reference now to , if block  determines the user selected to modify a charter, then block  interfaces with the user to modify charter data of the entry pointed to by the list cursor. The user may change information of the GDR, CDR, ADR and\/or PARMDR and any associated records (e.g. DDR and TDR). The user may also add applicable records at block . Block  waits for a user action indicating completion. Block  will continue to block  when the complete action is detected. If block  determines the user exited, then processing continues back to block  by way of off-page connector . If block  determines the user selected to save changes made at block , then block  updates the data and the list is appropriately updated before continuing back to block . Block  may update the GDR, CDR, ADR, PARMDR and\/or any associated records (e.g. DDR, and\/or TDR) using the charter id field \/(associated to the entry at block ). Block  will update an associated HDR as well. Block  may add new CDR, ADR(s), PARMDR(s), a DDR and\/or TDR as part of the charter change. If block  determines the user did not select to modify a charter, then processing continues to block .","If block  determines the user selected to get more details of the charter (e.g. show all joinable data to the GDR or CDR that is not already presented with the entry), then block  gets additional details (may involve database queries in an SQL embodiment) for the charter pointed to by the list cursor, and block  appropriately presents the information to the user. Block  then waits for a user action that the user is complete reviewing details, in which case processing continues back to block . If block  determines the user did not select to get more detail, then processing continues to block .","If block  determines the user selected to internalize charters data thus far being maintained, then block  internalizes (e.g. as a compiler would) all applicable data records for well performing use by the MS, and block  saves the internalized form, for example to MS high speed non-persistent memory. In one embodiment, blocks  and  internalize charter data to applicable C structures of  (also see ). In various embodiments, block  maintains statistics for exactly what was internalized, and updates any running totals or averages maintained for a plurality of internalizations up to this point, or over certain time periods. Statistics such as: number of active constructs; number of user construct edits of particular types; amount of associated storage used, freed, changed, etc with perhaps a graphical user interface to graph changes over time; number of charter expressions, actions, term types, etc specified, number of charters affected and unaffected by permissions; and other charter dependent statistics. In other embodiments, statistical data is initialized at internalization time to prepare for subsequent gathering of useful statistics during charter processing. In embodiments where a tense qualifier is specified for TimeSpec information, saving the internalized form at block  causes all past and current tense configurations to become effective for being processed.","Block  then continues back to block . If block  determines the user did not select to internalize charter configurations, then processing continues to block . Alternate embodiments of processing charters  in the present disclosure will rely upon the data records entirely, rather than requiring the user to redundantly internalize from persistent storage to non-persistent storage for use. Persistent storage may be of reasonably fast performance to not require an internalized version of charters . Different embodiments may completely overwrite the internalized form, or update the current internalized form with any changes.","If block  determines the user selected to exit block  processing, then block  cleans up processing thus far accomplished (e.g. issue a stop using database command), and block  completes block  processing. If block  determines the user did not select to exit, then processing continues to block  where all other user actions detected at block  are appropriately handled, and processing continues back to block  by way off off-page connector .",{"@attributes":{"id":"p-0811","num":"1392"},"figref":["FIGS. 47A through 47B","FIG. 47A"],"b":["4514","4702","4704","4706","4706","3540","3520","3520","3520","3520","3520","3540","3540","4706","4708","4706","4708"],"i":["c ","d ","a ","b ","a"]},"Block  accesses all ADRs (e.g. all rows from a ADR SQL table) for the user of  matching the owner information of the ADRs (e.g. user information matches field ) to the user and to groups the user is a member of (e.g. group information matches field (e.g. owner type=group, owner id=group ID field from block )). The ADRs are additionally joined (e.g. SQL join) with DDRs  and TDRs  (e.g. fields and =Action and by matching ID fields and with field ). Description field can provide a useful description last saved by the user for the action data. Block  may also retrieve system predefined data records for use and\/or management. Thereafter, each joined entry returned at block  is associated at block  with the corresponding data IDs (at least fields and ) for easy unique record accesses when the user acts on the data. Block  also initializes a list cursor to point to the first action item to be presented to the user in the list. Thereafter, block  sets user interface indication for where the list cursor is currently set (e.g. set to highlight the entry) and any list scrolling settings are set (the list is initially not set for being scrolled on first  processing encounter to block  from block ). Block  continues to block  where the entry list is presented to the user in accordance with the list cursor and list scroll settings managed for presentation at block . Thereafter, block  waits for user action to the presented list of action data and will continue to block  when a user action has been detected. Presentation of the scrollable list preferably presents in an entry format reference-able by the list cursor. An action entry presented preferably contains ADR fields including owner information; GRPDR owner information and group name if applicable; TDR time spec information; and DDR information. Alternate embodiments will present less information, or more information (e.g. join ADR(s) to PARMDR(s) via field(s) ).","If block  determines the user selected to set the list cursor to a different action entry, then block  sets the list cursor accordingly and processing continues back to block . Block  always sets for indicating where the list cursor is currently pointed and sets for appropriately scrolling the list if necessary when subsequently presenting the list at block . If block  determines the user did not select to set the list cursor, then processing continues to block . If block  determines the user selected to add an action, then block  accesses a maximum number of actions allowed (perhaps multiple maximum values accessed), and block  checks the maximum(s) with the number of current actions defined. There are many embodiments for what deems a maximum (for this user, for a group, for this MS, etc). If block  determines a maximum number of actions allowed already exists, then block  provides an error to the user and processing continues back to block . Block  preferably requires the user to acknowledge the error before continuing back to block . If block  determines a maximum was not exceeded, then block  interfaces with the user for entering validated action data and block  adds the data record, appropriately updates the list with the new entry, and sets the list cursor appropriately for the next list presentation refresh, before continuing back to block . If block  determines the user did not want to add an action, processing continues to block . Block  will add an ADR, HDR  (to set creator information) and TDR . The DDR and TDR are optionally added by the user. Additionally, at block  the user may add new PARMDR(s) for the action.","If block  determines the user selected to modify an action, then block  interfaces with the user to modify action data of the entry pointed to by the list cursor. The user may change information of the ADR and any associated records (e.g. DDR, TDR). The user may also add the associated records at block . Block  waits for a user action indicating completion. Block  will continue to block  when the action is detected at block . If block  determines the user exited, then processing continues back to block . If block  determines the user selected to save changes made at block , then block  updates the data and the list is appropriately updated before continuing back to block . Block  may update the ADR and\/or any associated records (e.g. DDR and\/or TDR) using the action id field (associated to the action item at block ). Block  will update an associated HDR as well. Block  may add a DDR and\/or TDR as part of the action change. If block  determines the user did not select to modify an action, then processing continues to block  by way of off-page connector .","With reference now to , if block  determines the user selected to get more details of the action (e.g. show all joinable data to the ADR that is not already presented with the entry), then block  gets additional details (may involve database queries in an SQL embodiment) for the action pointed to by the list cursor, and block  appropriately presents the information to the user. Block  then waits for a user action that the user is complete reviewing details, in which case processing continues back to block  by way of off-page connector . If block  determines the user did not select to get more detail, then processing continues to block .","If block  determines the user selected to delete an action, then block  determines any data records (e.g. CDR(s)) that reference the action data record to be deleted. Preferably, no referencing data records (e.g. CDRs) are joinable (e.g. field ) to the action data record being deleted, otherwise the user may improperly delete an action from a configured charter. The user should remove ascending references to an action for deletion first. Block  continues to block . If block  determines there was at least one CDR reference, block  provides an appropriate error with the reference(s) found so the user can subsequently reconcile. Block  preferably requires the user to acknowledge the error before continuing back to block . If no references were found as determined by block , then processing continues to block  for deleting the data record currently pointed to by the list cursor. Block  also modifies the list for the discarded entry, and sets the list cursor appropriately for the next list presentation refresh, before continuing back to block . Block  will use the action ID field (associated with the entry at block ) to delete an action. Associated records (e.g. DDR , HDR , and TDR ) are also deleted (e.g. preferably with a cascade delete in a SQL embodiment). If block  determines the user did not select to delete an action, then processing continues to block .","If block  determines the user selected to exit block  processing, then block  cleans up processing thus far accomplished (e.g. issue a stop using database command), and block  completes block  processing. If block  determines the user did not select to exit, then processing continues to block  where all other user actions detected at block  are appropriately handled, and processing continues back to block  by way off off-page connector .",{"@attributes":{"id":"p-0818","num":"1399"},"figref":["FIGS. 48A through 48B","FIG. 48A"],"b":["4518","4802","4804","4806","4806","3540","3520","3520","3520","3520","3520","3540","3540","4806","4808","4806","4808"],"i":["c ","d ","a ","b ","a"]},"Block  accesses all PARMDRs (e.g. all rows from a PARMDR SQL table) for the user of  matching the owner information of the PARMDRs (e.g. user information matches field ) to the user and to groups the user is a member of (e.g. group information matches field (e.g. owner type=group, owner id=group ID field from block )). The PARMDRs are additionally joined (e.g. SQL join) with DDRs  (e.g. field =Parameter and by matching ID field with field ). Description field can provide a useful description last saved by the user for the parameter data. Block  may also retrieve system predefined data records for use and\/or management. Thereafter, each joined entry returned at block  is associated at block  with the corresponding data IDs (at least fields and ) for easy unique record accesses when the user acts on the data. Block  also initializes a list cursor to point to the first parameter entry to be presented to the user in the list. Thereafter, block  sets user interface indication for where the list cursor is currently set (e.g. set to highlight the entry) and any list scrolling settings are set (the list is initially not set for being scrolled on first  processing encounter to block  from block ). Block  continues to block  where the entry list is presented to the user in accordance with the list cursor and list scroll settings managed for presentation at block . Thereafter, block  waits for user action to the presented list of parameter data and will continue to block  when a user action has been detected. Presentation of the scrollable list preferably presents in an entry format reference-able by the list cursor. A parameter entry presented preferably contains fields for: PARMDR field ; GRPDR owner information; owning GRPDR owner information and group name if applicable; and DDR information. Alternate embodiments will present less information, or more information (e.g. commands and operands parameters may be used with, parameter descriptions, etc).","If block  determines the user selected to set the list cursor to a different parameter entry, then block  sets the list cursor accordingly and processing continues back to block . Block  always sets for indicating where the list cursor is currently pointed and sets for appropriately scrolling the list if necessary when subsequently presenting the list at block . If block  determines the user did not select to set the list cursor, then processing continues to block . If block  determines the user selected to add a parameter, then block  accesses a maximum number of parameter entries allowed (perhaps multiple maximum values accessed), and block  checks the maximum(s) with the number of current parameter entries defined. There are many embodiments for what deems a maximum (for this user, for a group, for this MS, etc). If block  determines a maximum number of parameter entries allowed already exists, then block  provides an error to the user and processing continues back to block . Block  preferably requires the user to acknowledge the error before continuing back to block . If block  determines a maximum was not exceeded, then block  interfaces with the user for entering validated parameter data, and block  adds the data record, appropriately updates the list with the new entry, and sets the list cursor appropriately for the next list presentation refresh, before continuing back to block . If block  determines the user did not want to add a parameter entry, processing continues to block . Block  will add a PARMDR, DDR  and HDR  (to set creator information). The DDR is optionally added by the user.","If block  determines the user selected to modify a parameter entry, then block  interfaces with the user to modify parameter data of the entry pointed to by the list cursor. The user may change information of the PARMDR and any associated records (e.g. DDR). The user may also add the associated records at block . Block  waits for a user action indicating completion. Block  will continue to block  when the complete action is detected at block . If block  determines the user exited, then processing continues back to block . If block  determines the user selected to save changes made at block , then block  updates the data and the list is appropriately updated before continuing back to block . Block  may update the PARMDR and\/or any associated DDR using the parameter id field (associated to the parameter entry at block ). Block  will update an associated HDR as well. Block  may add a new DDR as part of the parameter entry change. If block  determines the user did not select to modify a parameter, then processing continues to block  by way of off-page connector .","With reference now to , if block  determines the user selected to get more details of the parameter entry, then block  gets additional details (may involve database queries in an SQL embodiment) for the parameter entry pointed to by the list cursor, and block  appropriately presents the information to the user. Block  then waits for a user action that the user is complete reviewing details, in which case processing continues back to block  by way of off-page connector . If block  determines the user did not select to get more detail, then processing continues to block .","If block  determines the user selected to delete a parameter entry, then block  determines any data records (e.g. ADR(s)) that reference the parameter data record to be deleted. Preferably, no referencing data records (e.g. ADRs) are joinable (e.g. field ) to the parameter data record being deleted, otherwise the user may improperly delete a parameter from a configured action. The user should remove references to a parameter entry for deletion first. Block  continues to block . If block  determines there was at least one reference, block  provides an appropriate error with the reference(s) found so the user can subsequently reconcile. Block  preferably requires the user to acknowledge the error before continuing back to block . If no references were found as determined by block , then processing continues to block  for deleting the data record currently pointed to by the list cursor, along with any other related records that can be deleted. Block  also modifies the list for the discarded entry(s), and sets the list cursor appropriately for the next list presentation refresh, before continuing back to block . Block  will use the parameter ID field (associated with the entry at block ) to delete the parameter entry. Associated records (e.g. DDR , and HDR ) are also deleted (e.g. preferably with a cascade delete in a SQL embodiment). If block  determines the user did not select to delete a parameter entry, then processing continues to block .","If block  determines the user selected to exit block  processing, then block  cleans up processing thus far accomplished (e.g. issue a stop using database command), and block  completes block  processing. If block  determines the user did not select to exit, then processing continues to block  where all other user actions detected at block  are appropriately handled, and processing continues back to block  by way off off-page connector .",{"@attributes":{"id":"p-0825","num":"1406"},"figref":["FIGS. 39A","FIGS. 39A","FIGS. 39A&B","FIGS. 40A&B","FIGS. 41A&B","FIGS. 46A&B","FIGS. 47A&B","FIGS. 48A&B","FIGS. 39A&B","FIGS. 40A&B","FIGS. 41A&B","FIGS. 46A&B","FIGS. 47A&B","FIGS. 48A&B"],"b":["40","41","46","47","48","3904","4004","4104","4604","4704","4804","3904","4004","4104","4604","4704","4804","40","41","46","47","48","3904","4004","4104","4604","4704","4804","3500","3500"],"i":["c ","d"]},{"@attributes":{"id":"p-0826","num":"1407"},"figref":"FIGS. 39A","b":["40","41","46","47","48","3660"]},{"@attributes":{"id":"p-0827","num":"1408"},"figref":["FIG. 49A","FIG. 49A"],"b":["10","22","4920","10"],"sub":"1 ","ul":{"@attributes":{"id":"ul0087","list-style":"none"},"li":{"@attributes":{"id":"ul0087-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0088","list-style":"none"},"li":["2) The first identity ID(Grantor) granting a privilege to a second identity ID(Grantee; grammar ID\/IDType), as shown in cell : Privilege data is maintained by IDat the IDMS as is used to govern actions, functionality, features, and\/or behavior for the benefit of ID, by a) processing IDWDR information at the IDMS (preferably, privileges are communicated to IDMS for enforcing and\/or cloning there), b) processing IDWDR information at the IDMS (privileges locally maintained to ID), and c) processing IDWDR information at the IDMS (privileges locally maintained to ID);","3) The first identity ID(Grantor) granting a privilege to himself (Grantee), as shown in cell : Preferably, privilege data in this case is not necessary, no configuration interface is required for this scenario, and an identity implicitly has all conceivable privileges assigned to himself by default; however, alternatively privileges may be appropriate for activating\/deactivating functionality;","4) The second identity ID(Grantor) granting a privilege to the first identity (Grantee), as shown in cell : Privilege data is used for informing ID(or enabling IDto clone per a privilege) and to govern actions, functionality, features, and\/or behavior for the benefit of ID, by a) processing IDWDR information at the IDMS (preferably, privileges are communicated to IDMS for enforcing and\/or cloning there), b) processing IDWDR information at the IDMS (privileges locally maintained to ID); and c) processing IDWDR information at the IDMS (privileges locally maintained to ID); and\/or","5) The second identity granting a privilege to himself, as shown in cell : Preferably, privilege data in this case is not necessary, no communications interface is required for this scenario, and an identity implicitly has all conceivable privileges assigned to himself by default; however, alternatively privileges may be appropriate for activating\/deactivating functionality."]}}}},"Table  depicts considerations for privilege data (i.e. permission data ) resident at the MS of a second identity ID(grammar ID\/IDType), depending on privileges granted in the following scenarios:\n\n",{"@attributes":{"id":"p-0829","num":"1418"},"figref":["FIG. 49B","FIG. 49B"],"b":["12","22","4960"],"sub":"1 ","ul":{"@attributes":{"id":"ul0091","list-style":"none"},"li":{"@attributes":{"id":"ul0091-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0092","list-style":"none"},"li":["1) The first identity ID(Grantee) owning a charter for use at the MS of a second identity ID(Grantor; grammar ID\/IDType), as shown in cell : Charter data is maintained by IDat the IDMS for being candidate use at the IDMS to cause actions, functionality, features, and\/or behavior, in accordance with configured permission data , for the benefit of either IDor IDby a) processing IDWDR information at the IDMS (preferably, charters are communicated to IDMS for use there), and b) processing IDWDR information at the IDMS (preferably, charters are communicated to IDMS for use there);","2) The first identity ID(Grantee) owning a charter for use at his own MS, as shown in cell : Charter data is maintained locally for local use to cause actions, functionality, features, and\/or behavior, in accordance with configured permission data , for the benefit of either IDor IDby a) processing IDWDR information at the IDMS, and b) processing IDWDR information at the IDMS;","3) The second identity ID(Grantee) owning a charter for use at the MS of the first identity ID(Grantor; grammar ID\/IDType), as shown in cell : Charter data is used at the IDMS for informing IDand enforcing cause of actions, functionality, features, and\/or behavior, in accordance with configured permission data , for the benefit of either IDor IDby a) processing IDWDR information at the IDMS (preferably, charters are communicated to IDMS for use there), and b) processing IDWDR information at the IDMS (preferably, charters are communicated to IDMS for use there); and\/or","4) The second identity ID(Grantee) owning a charter at his own MS, as shown in cell : Charter data may be communicated to the IDMS for informing ID, allowing IDto browse, or allowing IDto use as a template for cloning and then making\/maintaining into ID's own charter(s), wherein each reason for communicating to the IDMS (or processing at the IDMS) has a privilege grantable from IDto ID.\n\nTable  depicts considerations for charter data resident at the MS of a second identity ID(grammar ID\/IDType), depending on privileges granted in the following scenarios:\n","5) The first identity ID(Grantee) owning a charter for use at the MS of the second identity ID(Grantor), as shown in cell : Charter data is used at the IDMS for informing IDand enforcing cause of actions, functionality, features, and\/or behavior, in accordance with configured permission data , for the benefit of either IDor IDby a) processing IDWDR information at the IDMS (preferably, charters are communicated to IDMS for use there), and b) processing IDWDR information at the IDMS (preferably, charters are communicated to IDMS for use there);","6) The first identity ID(Grantee) owning a charter for use at his own MS, as shown in cell : Charter data may be communicated to the IDMS for informing ID, allowing IDto browse, or allowing IDto use as a template for cloning and then making into ID's own charter(s), wherein each reason for communicating to the IDMS (or processing at the IDMS) has a privilege grantable from IDto ID.","7) The second identity ID(Grantee) owning a charter for use at the MS of the first identity ID(Grantor; grammar ID\/IDType), as shown in cell : Charter data is maintained by IDat the IDMS for being candidate use at the IDMS to cause actions, functionality, features, and\/or behavior, in accordance with configured permission data , for the benefit of either IDor IDby a) processing IDWDR information at the IDMS (preferably, charters are communicated to IDMS for use there), and b) processing IDWDR information at the IDMS (preferably, charters are communicated to IDMS for use there); and\/or","8) The second identity ID(Grantee) owning a charter at his own MS, as shown in cell : Charter data is maintained locally for local use to cause actions, functionality, features, and\/or behavior, in accordance with configured permission data , for the benefit of either IDor IDby a) processing IDWDR information at the IDMS, and b) processing IDWDR information at the IDMS."]}}}},"Various embodiments will implement any reasonable subset of the considerations of , for example to minimize or eliminate communicating a user's permissions  and\/or charters  to another MS, or to prevent storing the same permissions and\/or charters data at more than one MS.  are intended to highlight feasible embodiments wherein  terminology \u201cincoming\u201d is used generally for referring to WDRs in-process which are a) being maintained (e.g. \u201cincoming\u201d as being maintained to queue ); and b) incoming to a particular MS (e.g. \u201cincoming\u201d as being communicated to the MS).","In one subset embodiment, privileges and charters are only maintained at the MS where they are configured for driving LBX features and functionality. In another embodiment, privileges are maintained at the MS where they were configured as well as any MSs which are relevant for those configurations, yet charters are only maintained at the MS where they are configured. In yet another embodiment, privileges and charters are maintained at the MS where they were configured, as well as any MSs which are relevant for those configurations. In another embodiment, a MS may not have all privileges assigned to itself (said to be assigned to the user of the MS) by default. Privileges may require being enabled as needed for any users to have the benefits of the associated LBX features and functionality. Thus, the considerations highlighted by  are to \u201ccover many bases\u201d with any subset embodiment within the scope of the present disclosure.","Preferably, statistics are maintained by WITS for counting occurrences of each variety of the  processing scenarios. WITS processing should also keep statistics for the count by privilege, and by charter, of each applicable WITS processing event which was affected. Other embodiments will maintain more detailed statistics by MS ID, Group ID, or other \u201clabels\u201d for categories of statistics. Still other embodiments will categorize and maintain statistics by locations, time, applications in use at time of processing scenarios, etc. Applicable statistical data can be initialized at internalization time to prepare for proper gathering of useful statistics during WITS processing.",{"@attributes":{"id":"p-0833","num":"1430"},"figref":["FIGS. 50A through 50C","FIGS. 13A through 13C","FIGS. 13A through 13C","FIGS. 50A through 50C","FIGS. 13A and 50A","FIGS. 13B and 50B","FIGS. 13C and 50C","FIGS. 50A through 50C","FIGS. 13A through 13C","FIGS. 13A through 13C","FIGS. 50A through 50C"],"b":["200","1000","200","1000"],"i":["a ","k ","a","k"]},"With reference now to , \u201cin the vicinity\u201d language is described in more detail for the MS (e.g. DLM ) as determined by clarified maximum range of transmission . In some embodiments, maximum wireless communications range (e.g. ) is used to determine what is in the vicinity of the DLM . In other embodiments, a data processing system  may be communicated to as an intermediary point between the DLM and another data processing system  (e.g. MS or service) for increasing the distance of \u201cin the vicinity\u201d between the data processing systems to carry out LBX peer to peer data communications. Data processing system  may further be connected to another data processing system , by way of a connection , which is in turn connected to a data processing system  by wireless connectivity as disclosed. Data processing systems  and  may be a MS, service, router, switch, bridge, or any other intermediary data processing system (between peer to peer interoperating data processing systems and ) capable of communicating data with another data processing system. Connection  may be of any type of communications connection, for example any of those connectivity methods, options and\/or systems discussed for . Connection  may involve other data processing systems (not shown) for enabling peer to peer communications between DLM and data processing system .  clarifies that \u201cin the vicinity\u201d is conceivably any distance from the DLM as accomplished with communications well known to those skilled in the art demonstrated in . In some embodiments, data processing system  may be connected at some time with a physically connected method to data processing system , or DLM may be connected at some time with a physically connected method to data processing system , or DLM and data processing system  may be connected to the same intermediary data processing system. Regardless of the many embodiments for DLM to communicate in a LBX peer to peer manner with data processing system , DLM and data processing system  preferably interoperate in context of the LBX peer to peer architecture. In some embodiments, data processing systems between DLM and the data processing system  intercept data for tracking, book-keeping, statistics, and for maintaining data potentially accessed by service informant code , however, the LBX peer to peer model is preferably not interfered with.","Data processing system  may be a DLM, ILM, or service being communicated with by DLM as disclosed in the present disclosure for , or for . LBX architecture is founded on peer to peer interaction between MSs without requiring a service to middleman data, however data processing systems ,  and those applicable to connection  can facilitate the peer to peer interactions. In some embodiments, data processing systems between DLM and the data processing  intercept data for tracking, book-keeping, statistics, and for maintaining data potentially accessed by service informant code , however, the LBX peer to peer model is preferably not interfered with. Data processing system  generically represents a DLM, ILM or service(s) for analogous  processing for sending\/broadcasting data such as a data packet  (like \/). When a Communications Key (CK)  (like \/) is embedded within data , data  is considered usual communications data (e.g. protocol, voice, or any other data over conventional forward channel, reverse channel, voice data channel, data transmission channel, or any other appropriate channel) which has been altered to contain CK . Data  contains a CK  which can be detected, parsed, and processed when received by an MS or other data processing system in the vicinity (conceivably any distance depending on embodiment) of data processing system  as determined by the maximum range of transmission  (like \/). CK  permits \u201cpiggy-backing\u201d on current transmissions to accomplish new functionality as disclosed herein. Transmissions radiate out in all directions in a manner consistent with the wave spectrum used, and data carried thereon may or may not be encrypted (e.g. encrypted WDR information). The radius  (like \/) represents a first range of signal reception from data processing system  (e.g. antenna thereof), perhaps by a MS. The radius  (like \/) represents a second range of signal reception from data processing system  (e.g. antenna thereof), perhaps by a MS. The radius  (like \/) represents a third range of signal reception from data processing system  (e.g. antenna thereof), perhaps by a MS. The radius  (like \/) represents a last and maximum range of signal reception from data processing system  (e.g. antenna thereof), perhaps by a MS (not shown). The time of transmission from data processing system  to radius  is less than times of transmission from service to radiuses , , or . The time of transmission from data processing system  to radius  is less than times of transmission to radiuses  or . The time of transmission from data processing system  to radius  is less than time of transmission to radius . In another embodiment, data  contains a Communications Key (CK)  because data  is new transmitted data in accordance with the present disclosure. Data  purpose is for carrying CK  information for being detected, parsed, and processed when received by another MS or data processing system in the vicinity (conceivably any distance depending on embodiment) of data processing system  as determined by the maximum range of transmission.","With reference now to , \u201cin the vicinity\u201d language is described in more detail for the MS (e.g. ILM ) as determined by clarified maximum range of transmission . In some embodiments, maximum wireless communications range (e.g. ) is used to determine what is in the vicinity of the ILM . In other embodiments, a data processing system  may be communicated to as an intermediary point between the ILM and another data processing system  (e.g. MS or service) for increasing the distance of \u201cin the vicinity\u201d between the data processing systems to carry out LBX peer to peer data communications. Data processing system  may further be connected to another data processing system , by way of a connection , which is in turn connected to a data processing system  by wireless connectivity as disclosed. Data processing systems  and  may be a MS, service, router, switch, bridge, or any other intermediary data processing system (between peer to peer interoperating data processing systems and ) capable of communicating data with another data processing system. Connection  may be of any type of communications connection, for example any of those connectivity methods, options and\/or systems discussed for . Connection  may involve other data processing systems (not shown) for enabling peer to peer communications between ILM and data processing system .  clarifies that \u201cin the vicinity\u201d is conceivably any distance from the ILM as accomplished with communications well known to those skilled in the art demonstrated in . In some embodiments, data processing system  may be connected at some time with a physically connected method to data processing system , or ILM may be connected at some time with a physically connected method to data processing system , or ILM and data processing system  may be connected to the same intermediary data processing system. Regardless of the many embodiments for ILM to communicate in a LBX peer to peer manner with data processing system , ILM and data processing system  preferably interoperate in context of the LBX peer to peer architecture. In some embodiments, data processing systems between ILM and the data processing system  intercept data for tracking, book-keeping, statistics, and for maintaining data potentially accessed by service informant code , however, the LBX peer to peer model is preferably not interfered with.","With reference now to , \u201cin the vicinity\u201d language is described in more detail for service(s) as determined by clarified maximum range of transmission . In some embodiments, maximum wireless communications range (e.g. ) is used to determine what is in the vicinity of the service(s). In other embodiments, a data processing system  may be communicated to as an intermediary point between the service(s) and another data processing system  (e.g. MS) for increasing the distance of \u201cin the vicinity\u201d between the data processing systems to carry out LBX peer to peer data communications. Data processing system  may further be connected to another data processing system , by way of a connection , which is in turn connected to a data processing system  by wireless connectivity as disclosed. Data processing systems  and  may be a MS, service, router, switch, bridge, or any other intermediary data processing system (between peer to peer interoperating data processing system service(s) and ) capable of communicating data with another data processing system. Connection  may be of any type of communications connection, for example any of those connectivity methods, options and\/or systems discussed for . Connection  may involve other data processing systems (not shown) for enabling peer to peer communications between service(s) and data processing system .  clarifies that \u201cin the vicinity\u201d is conceivably any distance from the service(s) as accomplished with communications well known to those skilled in the art demonstrated in . In some embodiments, data processing system  may be connected at some time with a physically connected method to data processing system , or service(s) may be connected at some time with a physically connected method to data processing system , or service(s) and data processing system  may be connected to the same intermediary data processing system. Regardless of the many embodiments for service(s) to communicate in a LBX peer to peer manner with data processing system , service(s) and data processing system  preferably interoperate in context of the LBX peer to peer architecture. In some embodiments, data processing systems between service(s) and the data processing system  intercept data for tracking, book-keeping, statistics, and for maintaining data potentially accessed by service informant code , however, the LBX peer to peer model is preferably not interfered with.","In an LN-expanse, it is important to know whether or not WDR information is of value for locating the receiving MS, for example to grow an LN-expanse with newly located MSs.  demonstrate that WDR information sources may be great distances (over a variety of communications paths) from a particular MS receiving the WDR information. Carrying intermediary system indication is well known in the art, for example to know the number of hops of a communications path. The preferred embodiment uses communications reference field to maintain whether or not the WDR encountered any intermediate systems, for example as identified with hops, network address change(s), channel extender transmission indications, or any pertinent data to indicate whether the WDR encountered anything other than a wireless transmission (e.g. directly between the sending MS and receiving MS). This provides  with a means to qualify the peek at block  for only those WDRs which show field to be over a single wireless connection from the source to the MS (i.e. block  to read as \u201cPeek all WDRs from queue  for confidence>confidence floor and most recent in trailing f(WTV) period of time and field indicating a wireless connected source over no intermediary systems\u201d). Field would be set intelligently for all WDRs received and processed by the MS (e.g. inserted to queue ). In another embodiment, fields and are used to indicate that the WDR can be relied upon for triangulating a new location of the MS (e.g. block  altered to get the next WDR from the REMOTE_MS list which did not arrive except through a single wireless path). In other embodiments, the correlation (e.g. field ) can be used to know whether it involved more than a single wireless communications path. The requirement is to be able to distinguish between WDRs that can contribute to locating a MS and WDRs which should not be used to locate the MS. In any case, WDRs are always useful for peer to peer interactions as governed by privileges and charters (see WITS filtering discussed below).","In other embodiments, the WDR fields and information is altered to additionally contain the directly connected system whereabouts (e.g. intermediary system  whereabouts) so that the MS (e.g. ) can use that WDR information relevant for locating itself (e.g. triangulating the MS whereabouts). This ensures that a MS receives all relevant WDRs from peers and also uses the appropriate WDR information for determining its own location.  would distinguish between the data that describes the remote MS whereabouts from the data useful for locating the receiving MS. A preferred embodiment always sets an indicator to at least field , , or for indicating that the WDR was in transit through one or more intermediary system(s). This provides the receiving MS with the ability to know whether or not the WDR was received directly from a wireless in-range MS versus a MS which can be communicated with so that the receiving MS can judiciously process the WDR information (see WITS filtering discussed below).","An alternate embodiment supports WDR information source systems which are not in wireless range for contributing to location determination of a MS. For example, a system can transmit WDR information outbound in anticipation of when it will be received by a MS, given knowledge of the communication architecture. Outbound date\/time information is strategically set along with other WDR information to facilitate making a useful measurement at a receiving MS (e.g. TDOA). The only requirement is the WDR conform to a MS interface and be \u201ctrue\u201d to how fields are set for LBX interpretation and appropriate processing, for example to emulate a MS transmitting useful WDR information.","WITS filtering provides a method for filtering out (or in) WDRs which may be of use for locating the receiving MS, or are of use for permission and\/or charter processing. Supporting ranges beyond a range within wireless range to a MS can cause a massive number of WDRs to be visible at a MS. Thus, only those WDRs which are of value, or are candidate for triggering permissions or charter processing, are to be processed. Application fields may also contain data which affects WITS filtering (e.g. appfld.loc.blackout). WITS filtering can use the source information (e.g. MS ID) or any other WDR fields, or any combination of WDR fields to make a determination if the WDR deserves further processing. The longer range embodiment of  preferably incorporates a send transmission for directing the WDRs to MSs which have candidate privileges and\/or charters in place, rather than a broadcast for communicating WDRs. Broadcasting can flood a network and may inundate MSs with information for WITS filtering, however the multithreaded LBX architecture may process efficiently even for broadcast data.","In another embodiment, a configuration can be made (user or system) wherein  are applicable, and non-wireless range originated WDRs are always ignored. For example, a WDR Range Configuration (WRC) indicates how to perform WITS filter processing:\n\n",{"@attributes":{"id":"p-0843","num":"1447"},"figref":["FIG. 51A","FIGS. 30A through 30E"]},{"@attributes":{"id":"p-0844","num":"1448"},"figref":["FIG. 51A","FIG. 51A"],"ul":{"@attributes":{"id":"ul0095","list-style":"none"},"li":"Text(str)=\u201cTest Case #106729 (context)\u201d;\n\nThe str variable is of type Text (i.e. BNF Grammar \u201ctext string\u201d) and is set with string \u201cTest Case #106729 (context)\u201d. Below will demonstrate variable string substitution for the substring \u201ccontext\u201d when str is instantiated.\n"}},{"@attributes":{"id":"p-0845","num":"1450"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Generic(assignPrivs) = \u201cG=Family,Work,\\vuloc"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[T=>20080402000130.24,<20080428; D=*str; H;]\u201d;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0846","num":"1451"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Groups {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LBXPHONE_USERS = Austin, Davood, Jane, Kris, Mark,"]},{"entry":[{}," Ravi, Sam, Tim;"]},{"entry":[{},"\u201cSW Components\u201d = \u201cSM 1.0\u201d, \u201cPIP 1.0\u201d, \u201cPIPGUI 1.0\u201d,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{}," \u201cSMGUI 1.0\u201d, \u201cCOMM 1.0\u201d, \u201cKERNEL 1.1\u201d;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0847","num":"1452"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Grants \/* Can define Grant structure(s) prior to assignment *\/ {"]},{"entry":[{},"..."]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"ul":{"@attributes":{"id":"ul0096","list-style":"none"},"li":"Family=\\lbxall[R=0xFFFFFFFF;] [D=*str(context=\u201cFamily\u201d)];\n\nA grant named \u201cFamily\u201d is assigned the privilege \u201c\\lbxall\u201d and is relevant for all MS types (i.e. 0xFFFFFFFF such that the \u201cR\u201d is a specification for MSRelevance). \\lbxall is the all inclusive privilege for all LBX privileges. \\lbxall maps to a unique privilege id (e.g. maintained to field ,  \u201cunsigned long priv\u201d, etc). Optional specifications are made with delimiters \u201c[\u201d and \u201c]\u201d, which coincidentally were used in defining the BNF grammar optional specifications. Each optional specification can have its own delimiters, or all optional specifications could have been made in a single pair of delimiters. The \u201cD\u201d specification is a Description specification which is set to an instantiation of the str variable using a string substitution. Thus, the Description is set to the string \u201cTest Case #106729 (Family)\u201d.\n"}},{"@attributes":{"id":"p-0848","num":"1454"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Work ="},{"entry":"[T=YYYYMMDD08:YYYYMMDD17;D=*str(context=\u201cWork\u201d);H;] {"},{"entry":"..."},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{},"figref":"FIGS. 36B","b":["33","34"],"ul":{"@attributes":{"id":"ul0097","list-style":"none"},"li":"\u201cDepartment 232\u201d=\\geoar,\\geode,\\nearar,\\nearde;\n\nThe grant \u201cDepartment 232\u201d is subordinate to \u201cWork\u201d and has four (4) privileges assigned, and no optional specifications.\n"}},{"@attributes":{"id":"p-0849","num":"1456"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u201cDepartment 458\u201d = [D=\u201cDavood lyadi's mgt scope\u201d;] {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u201cServer Development Team\u201d = ;"]},{"entry":[{},"\u201clbxPhone Development Team\u201d ="]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"\u201cComm Layer Guys\u201d = \\mssys;\\msbios;"]},{"entry":[{},"\u201cGUI girls\u201d = \\msguiload;"]},{"entry":[{},"\u201cMark and Tim\u201d = \\msapps;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"};"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"ul":{"@attributes":{"id":"ul0098","list-style":"none"},"li":"\u201cAccounting Department\u201d [H;]=\\track;\n\nThe grant \u201cAccounting Department\u201d is subordinate to \u201cWork\u201d, has optional History information to be generated, and has one (1) privilege assigned.\n"}},{"@attributes":{"id":"p-0850","num":"1458"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Parents = { Mom=\\lbxall; Dad=\\lbxall; };"]},{"entry":[{},"Michael-Friends=\\geoarr;\\geode;"]},{"entry":[{},"Jason-Friends=\\nearar;\\nearde;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0851","num":"1459"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Family"]},{"entry":[{},"Work"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Department 232"]},{"entry":[{},"Department 458"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Server Development Team"]},{"entry":[{},"lbxPhone Development Team"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Comm Layer Guys"]},{"entry":[{},"GUI girls"]},{"entry":[{},"Mark and Tim"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Accounting Department"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Parents"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Mom"]},{"entry":[{},"Dad"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Michael-Friends"]},{"entry":[{},"Jason-Friends"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"ul":{"@attributes":{"id":"ul0099","list-style":"none"},"li":["Bill: LBXPHONE_USERS [G=\\caller;\\callee;\\trkall;];\n\nThe MS ID Bill assigns (i.e. Grant specification \u201cG\u201d) three (3) privileges to the LBXPHONE_USERS group (i.e. to each member of the group). Privileges and\/or grants can be granted. The \\caller privilege enables LBXPHONE_USERS member MSs to be able to call the Bill MS. The \\callee privilege enables the Bill MS to call LBXPHONE_USERS member MSs. The \\trkall privilege enables LBXPHONE_USERS members to use the MS local tracking application for reporting mobile whereabouts of the Bill MS. The grants are optional (i.e. \u201c[\u201d and \u201c]\u201d) because without specific grants and\/or privileges specified, all privileges are granted.\n","LBXPHONE_USERS: Bill [G=\\callee;\\caller;];\n\nEach member of the LBXPHONE_USERS group assigns (i.e. Grant specification \u201cG\u201d) two (2) privileges to the Bill MS. The \\caller privilege enables the Bill MS to be able to call any of the members of the LBXPHONE_USERS group. The \\callee privilege enables the LBXPHONE_USERS member MSs to call the Bill MS.\n","Bill:Sophia;\n\nAll system privileges are assigned from Bill to Sophia.\n","Bill:Brian [*assignPrivs];\n\nThe assignPrivs variable is instantiated to \u201cG=Family,Work,\\vuloc [T=>20080402000130.24,<20080428; D=*str; H;]\u201d as though that configuration were made literally as:\n"]}},{"@attributes":{"id":"p-0852","num":"1464"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Bill:Brian [G=Family,Work,\\vuloc [T=>20080402000130.24,<20080428;"},{"entry":"D=\u201cTest Case #106729 (context)\u201d; H;] ];"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{},"ul":{"@attributes":{"id":"ul0100","list-style":"none"},"li":["Bill:George [G=\\geoall,\\nearall;];\n\nBill assigns two (2) privileges to George.\n","Michael: Bill [G=Parents,Michael-Friends;];\n\nMichael assigns to Bill the privileges \\lbxall, \\geoarr and \\geode.\n","Jason: Bill [G=Parents,Jason-Friends;];\n\nJason assigns to Bill the privileges \\lbxall, \\nearar and \\nearde.\n"]}},{"@attributes":{"id":"p-0853","num":"1468"},"figref":["FIG. 51B","FIGS. 30A through 30E"],"b":"0"},"It is important to understand that WDRs in process (e.g. to queue  (_ref), outbound (_O_ref), and inbound (_I_ref)) cause the recognized trigger of WDR processing to scan charters for testing expressions, and then performing actions for those expressions which evaluate to true. Expressions are evaluated within the context of applicable privileges. Actions are performed within the context of privileges. Thus, WDRs in process are the triggering objects for consulting charters at run time. Depending on the MS hardware and how many privileged MSs are \u201cin the vicinity\u201d, there may be many (e.g. dozens) of WDRs in process every second at a MS. Each WDR in process at a MS is preferably in its own thread of processing (preferred architecture ) so that every WDR in process has an opportunity to scan charters for conditional actions.",{"@attributes":{"id":"p-0855","num":"1470"},"figref":["FIG. 51B","FIG. 51B"],"ul":{"@attributes":{"id":"ul0101","list-style":"none"},"li":["Condition(cond1)=\u201c(_location @@ \\loc_my) [D=\u201cTest Case #104223 (v)\u201d;]\u201d;\n\nThe variable cond1 is of type Condition and is set accordingly. Validation of the variable type can occur here since the type is known. Cond1 is a Condition specification with an optional specification for the Description. Since the type \u201cGeneric\u201d can be used, it may be convenient to always use that.\n","\u201cms group\u201d={\u201cJane\u201d, \u201cGeorge\u201d, \u201cSally\u201d};\n\nThis is another method for specifying a group without a Groups block. The internalizer preferably treats an assignment using block delimiters outside of any special block definitions as a group declaration. While there has been no group hierarchies demonstrated, groups within groups can certainly be accomplished like Grants.\n"]}},{"@attributes":{"id":"p-0856","num":"1473"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"( ((msid = \u201cMichael\u201d) & *cond1(v=\u201cMichael\u201d)) |"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"((msid = \u201cJason\u201d) & *cond1(v=\u201cJason\u201d)) ):"]},{"entry":[{},"Invoke App myscript.cmd (\u201cS\u201d), Notify Autodial 214-405-6733;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["22","1100","22","1100","30","22"],"i":["a ","c "],"ul":{"@attributes":{"id":"ul0102","list-style":"none"},"li":"Condition(cond1)=\u201c(location (2W)$(10F) \\loc_my) [D=\u201cTest Case #104223 (v)\u201d;]\u201d;\n\nfor recently in vicinity (i.e. within 10 feet) of my location in last 2 weeks helps narrow the search.\n"}},"Parenthesis are used to affect how to evaluate the expression as is customary for an arithmetic expression, and can be used to determine which construct the optional specifications are for. Of course, a suitable precedence of operators is implemented. So, if the Expression evaluates to true, the actions shall be processed. There can be one or more actions processed. The first action performs an Invoke command with an Application operand and provides the parameter of \u201cmyscript.cmd(\u201cS\u201d)\u201d which happens to be an executable script invocable on the particular MS. A parameter of \u201cS\u201d is passed to the script. The script can perform anything supported in the processable script at the particular MS. The second action performs a Notify command with an Autodial operand and provides the parameter of \u201c214-405-6733\u201d. Notify Autodial will automatically perform a call to the phone number 214-405-6733 from the MS. So, if the MS of this configuration is currently at a location where Jason or Michael (in the vicinity) had been at some time before (as maintained in LBX History if necessary, or in last 2 weeks in refined example), then the two actions are processed. LBX History  will be searched for previous WDR information saved for Michael and Jason to see if the expression evaluates to true when queue  does not contain a matching WDR for Michael or Jason.","It is interesting to note that the condition \u201c((\\locByID_Michael @@ \\loc_my)|(\\locByID_Jason @@ \\loc_my))\u201d accomplishes the same expression shown in  described above. \\locRef_is an atomic term for the WDR location field with the suffix (Ref) referring to the value for test. \\loc\u201cR e f\u201d is an acceptable format when there are significant blanks in the suffix for testing against the value of the WDR field. It is also interesting to note that the expression \u201c(\\loc_my @@ \\locByID_Michael)\u201d is quite different. The expression \u201c(\\loc_my @@ \\locByID_Michael)\u201d tests if my current location was at Michael's location in history, again checking LBX history. However, the WDR in process only provided the trigger to check permissions and charters. There is no field of the in process WDR accessed here.",{"@attributes":{"id":"p-0859","num":"1477"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"((_l_msid = \u201cBrian\u201d) & (_l_location @ \\loc_my) [D=\u201cmulti-cond"},{"entry":"text\u201d;H;]):"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Invoke App (myscript.cmd (\u201cB\u201d)) [T=20080302;],"]},{"entry":[{},"Notify Autodial (214-405-5422);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["26","1100","1100","1100"],"i":["a ","c","c "]},"The _I_fldname syntax is a WDRTerm for inbound WDRs which makes sense for our expression above. A careless programmer\/user could in fact create expressions that may never occur. For example, if the user specified _O_instead of _I_, then outbound rather than inbound WDRs would be tested. (_O_msid=\u201cBrian\u201d) & (_O_location @ \\loc_my)) causes outbound WDRs to be tested (e.g. deposited to send queue ) for MS ID=Brian which are at my current location (i.e. current location of the MS with the configuration being discussed). Mixing _, _I_, and _O_prefixes has certain semantic implications and must be well thought out by the user prior to making such a configuration. The charter expression is considered upon an event involving each single WDR and is preferably not used to compare to a plurality of potentially ambiguous\/unrelated WDRs at the same time. A single WDR can be both in process locally (e.g. inserted to queue ) and inbound to the MS when received from MSs in the vicinity. It will not be known that the WDR meets both criteria until after it has been inbound and is then being inserted to queue . Likewise, a single WDR can be both in process locally (e.g. inserted to queue ) and outbound from the MS. It will not be known that the WDR meets both criteria until after it has been retrieved from queue  and then ready for being sent outbound. The programmer\/user can create bad configurations when mixing these syntaxes. It is therefore recommended, but not required, that users not mix WDR trigger syntax. Knowing a WDR is inbound and then in process to queue  is straightforward (e.g. origination other than \u201cthis MS\u201d). Knowing a WDR was on queue  and is outbound is also straightforward (e.g. origination at outbound=\u201cthis MS\u201d). However, a preferred embodiment prevents mixing these syntaxes for triggered processing.",{"@attributes":{"id":"p-0861","num":"1479"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"(M_sender = ~emailAddrVar [T=<YYYYMMDD18]):"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Notify Indicator (M_sender, \\thisMS) [D=\u201cTest Case #104223\u201d; H;];"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["53","55"],"ul":{"@attributes":{"id":"ul0103","list-style":"none"},"li":["(_appfld.email.source=M_sender)\n\nor the equivalent of:\n","(M_sender=_appfld.email.source)\n\nchecks each WDR in process for containing an Application field from the email section (if available) which matches an AppTerm. While this again seems unusual since M_sender dynamically changes according to email objects received, timeliness of WDRs in process for MSs (e.g. in the wireless vicinity) can make this useful. Further, the programmer\/user can specify more criteria for defining how close\/far in the vicinity (e.g. atomic operators of $(range), (spec)$(range), etc.\n","((_appfld.email.source=M_sender) & (_location $(500F) \\loc_my))\n\nThe WDR in process is checked to see if the originating MS has a source email address that matches a most recently received email object and the MS is within 500 feet of my current location. This configuration can be useful, for example to automatically place a call to a friend when they just sent you an email and they are nearby. You can then walk over to them and converse about the email information. Good or poor configurations can be made. One embodiment of an internalizer warns a user when an awkward configuration has been made.\n"]}},"In looking at actions for this example, the command operand pair is for \u201cNotify Indicator\u201d with two parameters (M_sender, \\thisMS). M_sender is what to use for the indicator (the source address matched). Thus, an AppTerm can be used as a parameter. \\thisMS is an atomic term for this MS ID. If the expression evaluates to true, the MS hosting the charter configuration will be notified with an indicator text string (e.g. billj@iswtechnologies.com). Notify Indicator displays the indicator in the currently focused title bar text of a windows oriented interface. In another embodiment, Notify indicator command processing displays notification data in the focused user interface object at the time of being notified. The action has optional specifications for Description and History information to be generated (when internalized).","In general, History information will be updated as the user changes the associated configuration in the future, either in syntax (recognized on internalization (e.g. to data structures)), with , etc.",{"@attributes":{"id":"p-0864","num":"1485"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"(B_srchSubj {circumflex over (\u2009)} M_subject) & !(_fcnTest(B_srchSubj)) :"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u201cms group\u201d[G].Store DBobject(JOESDB.LBXTABS.TEST,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u201cINSERT INTO TABLESAV (\u201c && \\thisMS && \u201d, \u201c &&"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\\timestamp && \u201d, 9);\u201d, \\thisMS);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":"22"},"The action demonstrates an interesting format for representing the optional Host construct (qualifier) of the BNF grammar for where the action should take place (assuming privilege to execute there is configured). \u201cms group\u201d[G]. tells the internalizer to search for a group definition like an array and find the first member of the group meeting the subscript definition. This would be \u201cGeorge\u201d (the G). Any substring of \u201cGeorge\u201d (or the entire string) could have been used to indicate use George from the \u201cms group\u201d. This allows a shorthand reference to the item(s) of the group. Multiple members that match \u201cG\u201d would all apply for the action. Also, note that the double quotes are used whenever variables contain significant blanks. \u201cms group\u201d[G].Store DBobject tells the internalizer that the Command Operand pair is to be executed at the George MS for storing to a database object per parameters. An equivalent form is George.Store DB-object with the Host specification explicitly specified as George. The parameters of (JOESDB.LBXTABS.TEST, \u201cINSERT INTO TABLESAV (\u201c&& \\thisMS &&\u201d, \u201c&& \\timestamp &&\u201d, 9);\u201d, \\thisMS) indicates to insert a row into the table TABLESAV of the TEST database at the system \u201cthis MS\u201d (the MS hosting the configuration). The second (query) parameter matches the number of columns in the table for performing a database row insert. Like other compilers\/interpreters, the \u201c \u201d evaluates to a single double quote character when double quotes are needed inside strings. A single quote can also be legal to delimit query string parameters (shown below). This example shows using atomic term(s) for a parameter (i.e. elaborates to underlying value; WDRTerm(s) can also be used for parameters). This example introduces a concatenation operator (&&) for concatenating together multiple values into a result string for one parameter (e.g. \u201cINSERT INTO TABLESAV (\u2018Bill\u2019, \u201820080421024421.45\u2019, 9);\u201d). Other embodiments will support other programmatic operators in expressions for parameters. Still other embodiments will support any reasonable programmatic statements, operators, and syntax among charter configuration to facilitate a rich method for defining charters .","Note that while we are configuring for the MS George to execute the action, we are still performing the insert to the MS hosting the Charter configuration (i.e. target system is \\thisMS). We could just as easily have configured:",{"@attributes":{"id":"p-0867","num":"1488"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Store DBobject(JOESDB.LBXTABS.TEST,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u201cINSERT INTO TABLESAV (\u201c && \\thisMS && \u201d, \u201c &&"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\\timestamp && \u201d, 9);\u201d);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"figref":"FIG. 51B"},{"@attributes":{"id":"p-0868","num":"1489"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"( _l_msid = \u201cSophia\u201d & \\loc_my (30M)$$(25M) _l_location ) :"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u201cms group\u201d.Invoke App (alert.cmd);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["26","1100","1100"],"i":["a ","c"]},{"@attributes":{"id":"p-0869","num":"1490"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"(%c:\\myprofs\\interests.chk > 90):"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Send Email (\u201cHowdy \u201d && _l_msid && \u201c !!\\n\\nOur profiles"]},{"entry":[{},"matched > 90%.\\n\\n\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"&& \u201cCall me at \u201d && \\appfld.phone.id && \u201c. We"]},{"entry":[{},"are \u201d && (_l_location - \\loc_my)F && \u201c feet apart\\n\u201d,"]},{"entry":[{},"\\appfld.source.id.email, \u201cCall Me!\u201d,, _l_appfld.email.source);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["1100","1100","1100"],"i":["k ","k ","k"],"figref":"FIG. 78"},"In sum, there are many embodiments derived from the BNF grammar of .  are simple examples with some interesting syntactical feature considerations. Some embodiments will support programmatic statements intermingled with the BNF grammar syntax derivative used to support looping, arithmetic expressions, and other useful programmatic functionality integrated into Privilege and Charter definitions.  illustrate a WPL for programming how a MS is to behave. WPL is a unique programming language wherein peer to peer interaction events containing whereabouts information (WDRs) provide the triggers for novel location based processing. Permissions and charters provide rules which govern the interoperable LBX processing between MSs. While WPL is more suited for a programmer type of user, the intent of this disclosure is to simplify configurations for all types of users. WPL may suit an advanced user while  may suit more prevalent and novice users. Other embodiments may further simplify configurations. Some WPL embodiments will implement more atomic operators, AppTerm(s), WDRTerm(s) and other configurable terms without departing from the spirit and scope of this disclosure. It is the intent that less time be spent on documentation and more time be spent implementing it. Permissions and charters are preferably centralized to the MS, and maintained with their own user interface, outside of any particular MS application for supervisory control of all MS LBX applications. See  for how PIP data  is maintained outside of other MS processing data and resources for centralized governing of MS operations.","In alternate embodiments, an action can return a return code\/value, for example to convey success, failure, or some other value(s) back to the point of performing the action. A syntactical embodiment:",{"@attributes":{"id":"p-0872","num":"1493"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"((_l_msid = \u201cBrian\u201d) & (_l_location @ \\loc_my) [D=\u201cmulti-cond"},{"entry":"text\u201d;H;]):"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Notify Autodial (214-405-5422,,,, Invoke App (myscript.cmd (\u201cB\u201d))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[T=20080302;]);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"There are many methods with different atomic operators and different Terms to accomplish the same expression or condition for providing convenient user specification. An expression with a plurality of conditions facilitates conjuncture. A charter expression syntax or encoding may be output by a MS accessed application (e.g. user interface to configure a geo-fence). The following are selected syntax examples for various condition discussions:","Geofence","(_loc $(20Y) \\locByL\u221230.21,\u221293.8) tests whether the MS of the in-process WDR has a location which is within a radius of 20 Yards of the point having the specified latitude and longitude. Precision specification (e.g. number of degree decimal places) of the point may include less or more two dimensional geographical space to be within range of. A zero elevation (or altitude) may be assumed, or one may be specified, for example to support a spherical radius as well as a circular radius.","(_I_loc >$(20Y) \\locByL\u221230.21,\u221293.8) tests whether the MS of the in-bound WDR has a location which is newly within a radius of 20 Yards of the point above.","(_loc (5M)$$(0) \\PS+33.27,\u221297.4;+34.1,\u221297.3;+34.13,\u221297.12) tests whether the MS of the in-process WDR has a location described to be departed in the last 5 minutes from the vicinity defined by the two dimensional polygon (triangle) described with points having latitude and longitude (PointSet specification). The zero (0) range specifies to use the bounds of the polygon. A non-zero value for range will cause checking the condition to be within the range of the bounds of the polygon.","(_I_loc (5M)$$(1000F) \\PS3DGeo+33.27,\u221297.4,4500F;+34.1,\u221297.3,1L;+34.13,\u221297.21,2000Y;+34.3,\u221297.1,2000Y;+34.89,\u221297.08,2000Y) tests whether the MS of the in-bound WDR has a location described to be departed in the last 5 minutes from the vicinity defined by the three dimensional polygonal region with points having latitude, longitude and elevation (or altitude). The 1000 F range specifies to check if the WDR contains a location within 1000 F of any bounds of the three dimensional polygon.","((_msid=\u201cSam\u201d) & (_loc <E>\\loc_my) & (_loc <S>\\loc_my)) tests whether the in-process WDR has a MS ID of \u201cSam\u201d and if Sam is Southeast of the MS processing the Sam WDR. Depending on embodiments of MS IDs, an automatic conversion may occur via a lookup when the MS ID embodiment is not already in a raw form of \u201cSam\u201d. The lookup may be from local mapping information, or via access to mapping information remotely (e.g. propagated service interface which in turn accesses a database service interface).","Situational Location","(\\slByID_Larry=\\sl_lat=+34.1,lon=\u221297.3;elev=1 L;speed>42) tests whether the MS with an ID of Larry can be described by the specified situational location. Note that any of the usual WDRTerm field reference names can be used in a situational location atomic term, and operators other than testing equivalency (e.g. >) may be supported. In some embodiments, a speed prefix or suffix is used to specify speed units which are appropriately converted when necessary (e.g. 42 MPH). Any constant which can be specified in more than one units of measurement are to support a qualifier in appropriate places of processing for enabling conversions when comparisons are processed.","(_WDR=\\sl_lat=+34.1,lon=\u221297.3;elev=1 L;speed>42) tests whether the in-process WDR can be described by the specified situational location. While a plurality of conditions can be specified to check an expression involving a situational location, a special syntax may also be used for contextual comparison. A _WDR specification (_I_WDR and _O_WDR also) is a contextual WDRTerm for comparison because the condition context implies which fields to check. This saves on encoding lengths (e.g. syntax required).","(_I_WDR=\\sl_lat=+34.1,lon=\u221297.3;appfld.profile.contents::hangouts>>\u201cStarbucks\u201d) tests whether the in-bound WDR can be described by the specified situational location. Note that the usual WDRTerm field reference appfld.profile.contents is specified and a particular tag is checked to contain \u201cStarbucks\u201d. Preferably, tag element comparisons are not case sensitive. Any profile tag can be accessed. A tag hierarchy may be specified (e.g. ::home,state) if there is chance of an ambiguous tag specification.","Movement Monitoring","((_msid=\u201cSam\u201d) & (_loc $(2M) \\locByID_Sam)) tests whether the in-process WDR has a MS ID of Sam AND the location of the in-process WDR is within 2 meters of the most recent location (if found) of a WDR from Sam found in history (e.g. on queue ). Preferably, the expression results in False if no record of Sam is found, depending on the depth of queue  (supported number of entries) and\/or whether or not LBX history  is checked.","(\\q_msid=Sam $(10M) \\h_msid=Sam) tests whether the most recent WDR from Sam on queue  has a location within 10 meters of the location of the most recent Sam WDR from LBX history . This condition should be made with some knowledge of where history  starts and where queue  ends for maintaining timely WDRs.","(\\q_msid=Sam;_dt>20090927120405 $(10M)","\\h_msid=Sam;_dt>=20090227;_dt<20090427) tests whether the most recent WDR from Sam on queue  later than a date\/time stamp has a location within 10 meters of the most recent location of Sam from LBX history  during the specified time period. An alternate embodiment may check all WDRs in the time period. Note that any WDRTerm can have a condition for search and the same WDRTerm reference may be used a plurality of times in the atomic term.\n\nApplication Activities\n","((_msid=\u201cSam\u201d) & ((_appfld.rfid.passive.enabled=True)|(_appfld.rfid.active.enabled=True)) & (_loc=\\loc_my)) tests whether the in-process WDR: is from the Sam MS AND the application fields section shows RFID capability is enabled AND the location matches the location of the MS where the charter condition is being evaluated. Lack of a WDR field for testing in a condition (e.g. not contained in WDR) preferably causes an error which is logged which prevents the Charter from action( )) from occurring. Other embodiments may assume a False condition to prevent charters from firing.","((\\appLive=\u201cGeofencing\u201d) & (_I_msid=\u201cSam\u201d) & (_I_loc $(2500F) \\loc_my)) tests whether the in-bound WDR: is from the Sam MS AND SAM is within 2500 feet of my current location AND the Geofencing application is active at the MS of charter processing of this expression.",{"@attributes":{"id":"p-0888","num":"1509"},"figref":["FIG. 52","FIGS. 30A through 30E","FIG. 52","FIG. 52","FIGS. 34E through 34G","FIG. 52","FIG. 34E","FIGS. 30A through 30E"]},{"@attributes":{"id":"p-0889","num":"1510"},"figref":"FIG. 53","b":["5300","5300","5300","5300","5300","5300","5300","5300","5300","5300","5300","5300","5300","5300","5300","5300","5300","5300","5300","5300","5300","5300"],"i":["a ","a","b ","c ","a","c ","d ","a","d ","e ","a","e ","f ","a","f ","g ","g ","g ","h ","h "]},"In one preferred embodiment, PRRs are supplied with a MS prior to user first MS use, and no administrator or user has to maintain them. In another embodiment, only a special administrator can maintain PRRs, which may or may not have been configured in advance. In another embodiment, a MS user can maintain PRRs, which may or may not have been configured in advance.",{"@attributes":{"id":"p-0891","num":"1512"},"figref":["FIG. 54","FIGS. 30A through 30E","FIG. 54","FIG. 54"]},"The syntax \u201c_location $(300M) \\loc_my\u201d is a condition for the WDR in process being within 300 Meters of the vicinity of my current location. Other syntax is identifiable based on previous discussions.",{"@attributes":{"id":"p-0893","num":"1514"},"figref":["FIG. 55A","FIG. 55A","FIG. 55B"],"b":["5502","5502","5504","5506","5506","5506","5508","5508","5510","5510","5512","5506","5512","5300","5512","5300","5510","5514","5514","5516","5506","5516","5300","5514","5518","5518","5520","5506","5520","5300","5520","5300","5518","5522","5522","5524","5506","5506","5522","5526","5526","5528","5300","5300","5528","5300","5506","5528","5506","5526","5530","5530","5532","5532","5532","5300","5506","5530","5534","5534","5300","5536","5300","5506","5536","5534","5538","5538","5540","5508","5506","5538","5542","5544","5542","5504"]},{"@attributes":{"id":"p-0894","num":"1515"},"figref":"FIG. 55A"},{"@attributes":{"id":"p-0895","num":"1516"},"figref":["FIG. 55B","FIG. 55B","FIG. 55B"],"b":["5552","5552","5554","5556","5558","5300","5560","5300","5562","5554","5564"],"i":["g","g "]},"If block  determines the associated PRR was not found or all data items of the found PRR for modification are not described by field , then processing continues directly to block  for releasing the semaphore lock, thereby performing no updates to an AppTerm. PRRs  control eligibility for modification by applications, as well as which AppTerm references can be made in charter processing.","An AppTerm is accessed (read) by grammar processing with the same semaphore lock control used in .",{"@attributes":{"id":"p-0898","num":"1519"},"figref":["FIG. 56","FIGS. 30A through 30E","FIGS. 35A through 37C","FIGS. 34A through 34G","FIG. 52","FIG. 33A through 33C","FIGS. 30A through 30E","FIG. 56","FIGS. 30A through 30E","FIG. 56","FIG. 56","FIG. 56","FIG. 56","FIGS. 30A through 30E"]},"Data handling of a source code for compiling\/interpreting, an encoding from a communication connection, or an encoding from some processing source starts at block . At some point in BNF grammar derived data handling, a block  gets the next (or first) token from the source encoding. Tokens may be reserved keywords, delimiters, variable names, expression syntax, or some construct or atomic element of an encoding. Thereafter, if block  determines the token is a reserved key or keyword, block  checks if the reserved key or keyword is for identifying permissions  (e.g.  \u201cPermissions\u201d,  \u201cpermission\u201d,  Permissions\/Permission, etc), in which case block  sets a stringVar pointer to the entire datastream representative of the permission(s)  to be processed, and block  prepares parameters for invoking LBX data internalization processing at block .","If block  determines the reserved key or keyword is not for permission(s) , then processing continues to block . Block  checks if the reserved key or keyword is for identifying charters  (e.g.  \u201cCharters\u201d,  \u201ccharter\u201d,  Charters\/Charter, etc), in which case block  sets a stringVar pointer to the entire datastream representative of the charter(s)  to be processed, and block  prepares parameters for invoking LBX data internalization processing at block .","Blocks  and  preferably have a stringVar set to the permission\/charter data encoding start position, and then set a length of the permission\/charter data for processing by block . Alternatively, the stringVar is a null terminated string for processing the permission(s)\/charter(s) data encoding. Embodiment requirements are for providing appropriate parameters for invoking block  for unambiguous processing of the entire permission(s)\/charter(s) for parsing and processing. The procedure of block  has already been described throughout this disclosure (e.g. creating a processable internalized form (e.g. database records, programmatic structure, etc)). Upon return from block  processing, block  resets the parsing position of the data source encoding provided at block  for having already processed the permission(s)\/charter(s) encoding handled by block . Thereafter, processing continues back to block  for getting the next token from the data encoding source.","If block  determines the reserved key or keyword is not for charter(s) , then processing continues to process the applicable reserved key or keyword identified in the source data encoding. If block  determines the token is not a reserved key or keyword, then processing continues to the appropriate block for handling the token which is not a reserved key or keyword. In any case there may be processing of other source data encoding not specifically for a permission or charter.","Eventually, processing continues to a block  for checking if there is more data source to handle\/process. If block  determines there is more data encoding source, processing continues back to block  for getting the next token. If block  determines there is no more data encoding source, processing continues to block  for data encoding source processing completion, and then to block  for termination of  processing.","Depending on the embodiment, block  may complete processing for:\n\n","Blocks  through  may represent plug-in processing for permissions  and\/or charters . Depending on when and where processing occurs for , appropriate semaphores may be used to ensure data integrity.","As WDR information is transmitted\/received between MSs, privileges and charters are used to govern automated actions. Thus, privileges and charters govern processing of at least future whereabouts information to be processed. There is WDR In-process Triggering Smarts (WITS) in appropriate executable code processing paths. WITS provides the intelligence of whether or not privilege(s) and\/or charter(s) trigger(s) an action. WITS is the processing at a place where a WDR is automatically examined against configured privileges and charters to see what actions should automatically take place. There are three different types of WITS, namely: maintained WITS (mWITS), inbound WITS (iWITS), and outbound WITS (oWITS). Each type of WITS is placed in a strategic processing path so as to recognize the event for when to process the WDR. Maintained WITS (mWITS) occur at those processing paths applicable to a WDR in process for being maintained at an MS (e.g. inserted to queue ). Other embodiments may define other maintained varieties of a WDR in process for configurations (e.g. inbound, outbound, in-process2Q22, in-process2History (i.e. WDR in process of being maintained to LBX history ), in-process2application(s) (i.e. WDR in process of being maintained\/communicated to an application), etc). Inbound WITS (iWITS) occur at those processing paths applicable to a WDR which is inbound to a MS (e.g. communicated to the MS). Outbound WITS (oWITS) occur at those processing paths applicable to a WDR which is outbound from a MS (e.g. sent by an MS). There are various WITS embodiments as described below. Users should keep in mind that a single WDR may be processed multiple times (by different WITS) with configuring charters that refer to different WITS (e.g. first inbound, then to queue ). One embodiment supports only mWITS. Another embodiment supports only iWITS. Another embodiment supports oWITS. Yet another embodiment supports use of any combination of available WITS.","mWITS:",{"@attributes":{"id":"p-0907","num":"0000"},"ul":{"@attributes":{"id":"ul0106","list-style":"none"},"li":{"@attributes":{"id":"ul0106-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0107","list-style":"none"},"li":["The preferred embodiment is a new block  in  such that block  continues to block  and block  continues to block . This allows mWITS processing block  to see all WDRs which are candidate for insertion to queue , regardless of the role check at block , confidence check at block , and any other  processing. In some embodiments, block  may choose to use enabled roles and\/or confidence and\/or any WDR field(s) values and\/or permissions and\/or any other processing result to decisively affect whether or not the WDR should be examined and\/or processed further by . For example, block  may result in processing to continue directly to block  or  (rather than block ). For example, upon determining that the WDR source had not provided any privileges to the receiving MS, the WDR can be ignored so as to not use resources of the MS. In another example, a WDR shows that it arrived completely wirelessly (e.g. field(s) ) and did not go through an intermediary service (e.g. router). The WDR may provide usefulness in locating the receiving MS despite the receiving MS not being privileged by the source MS, in which case block  continues to block  for WDR processing. It may be important to filter WDRs so that only those WDRs are maintained which either a) contribute to locating (per configurations), or b) are associated with active permissions or charters for applicable processing. The WRC discussed above may also be used to cause block  to continue to block  or . Such filtering is referred to as WITS filtering. WITS filtering may be crucial in a LBX architecture which supports MSs great distances from each other since there can be an overloading number of WDRs to process at any point in time. Charters and privileges that are configured are used for deciding which WDRs are to be \u201cseen\u201d (processed) further by  processing. If there are no privileges and no charters in effect for the in process WDR, then the WDR may be ignored. If there is no use for the WDR to help locate the receiving MS, then the WDR may also be ignored. If there are privileges and charters in effect for the in process WDR, then the WDR can be processed further by , even if not useful for locating the MS.","One preferred embodiment does make use of the confidence field to ensure the peer MS has been sufficiently located. Block  will compare information of the WDR with configured privileges to determine which actions should be performed. When appropriate privileges are in place, block  will also compare information of the WDR with configured and privileged charters (e.g. _fldname) to determine applicable configured charter actions to be performed.","Alternate embodiments can move mWITS at multiple processing places subsequent to where a WDR is completed by the MS (e.g. blocks , , , , , , , , , , , , , , etc).","Another embodiment can support mWITS at processing places subsequent to processing by blocks  and  to reflect user maintenance.","Yet another embodiment recognizes in mWITS that the WDR was first inbound to the MS and is now in process of being maintained (e.g. to queue ). This can allow distinguishing between an inbound WDR, maintained WDR, and inbound AND maintained WDR. In one embodiment, the WDR (e.g. field ) carries new bit(s) of information (e.g. set by receive processing when inserting to queue ) for indicating the WDR was inbound to the MS. The new bit(s) are checked by mWITS for new processing (i.e. inbound AND maintained WDR).\n\niWITS:\n","The preferred embodiment is a new block  in  such that block  continues to block  (i.e. on No condition) and block  continues to block . This allows iWITS processing block  to see all inbound WDRs, regardless of the confidence check at block , and any other  processing. In some embodiments, block  may choose to use confidence and\/or any WDR field(s) and\/or permissions and\/or any other processing result to decisively affect whether or not the WDR should be examined and\/or processed further by . Block  may result in processing to continue directly to block  (rather than block ). For example, upon determining that the WDR source had not provided any privileges to the receiving MS, the WDR can be ignored so as to not use resources of the MS. In another example, a WDR shows that it arrived completely wirelessly (e.g. field(s) ) and did not go through an intermediary service (e.g. router). The WDR may provide usefulness in locating the receiving MS despite the receiving MS not being privileged by the source MS, in which case block  continues to block  for WDR processing. Similar WITS filtering can occur here as was described for mWITS processing above, with the advantage of intercepting WDRs of little value at the earliest possible time and preventing them from reaching subsequent LBX processing.","One preferred embodiment does make use of the confidence field to ensure the peer MS has been sufficiently located. Block  will compare information of the WDR with configured privileges to determine which actions should be performed. When appropriate privileges are in place, block  will also compare information of the WDR with configured and privileged charters (e.g. _I_fldname) to determine applicable configured charter actions to be performed.","Another embodiment can support iWITS at processing places associated with receive queue , for example processing up to the insertion of the WDR to queue .\n\noWITS:\n","The preferred embodiment incorporates a new block  in  such that block  continues to block  and block  continues to block . This allows oWITS processing block  to see all its outbound WDRs for  processing. In some embodiments, block  may choose to use confidence and\/or any WDR field(s) and\/or permissions and\/or any other processing result to decisively affect whether or not the WDR should be processed further by . Block  may result in processing to continue directly to block . The WRC discussed may also be used appropriately here. Similar WITS filtering can occur here as was described for mWITS and iWITS processing above, with the advantage of intercepting WDRs of little value to anyone else in the LN-expanse, and preventing the WDRs from reaching subsequent LBX processing at remote MSs that will have no use for them.","The preferred embodiment will also incorporate a new block  in  such that block  continues to block  and block  continues to block . This allows oWITS processing block  to see all its outbound WDRs of  processing. In some embodiments, block  may choose to use confidence and\/or any WDR field(s) and\/or permissions and\/or any other processing result to decisively affect whether or not the WDR should be examined and\/or processed further by . Block  may result in processing to continue directly to block . For example, upon determining that the WDR is destined for a MS with no privileges in place, the WDR can be ignored and unprocessed (i.e. not sent). The WRC discussed may also be used appropriately here. Similar WITS filtering can occur here as was described for mWITS, iWITS and oWITS processing above, with the advantage of intercepting WDRs of little value to anyone else in the LN-expanse, and preventing the WDRs from reaching subsequent LBX processing at remote MSs that will have no use for them.","Blocks  and  will compare information of the WDR with configured privileges to determine which actions should be performed. When appropriate privileges are in place, blocks \/ will also compare information of the WDR with configured charters (e.g. _O_fldname) to determine applicable configured and privileged charter actions to be performed.","Another embodiment can support oWITS at processing places associated with send queue , for example after the insertion of the WDR to queue .","Yet another embodiment recognizes in oWITS that the WDR was first maintained to the MS and is now in process of being sent outbound. This can allow distinguishing between an outbound WDR, maintained WDR, and outbound AND maintained WDR. Different embodiments will use different criteria for what designates an outbound AND maintained WDR, for example seeking certain values in maintained WDR field(s), seeking certain values in outbound WDR field(s), or both. In one embodiment, the WDR carries new bit(s) of information (e.g. set by send processing) for indicating the WDR was outbound from the MS. WDR processing for a maintained WDR and\/or an outbound WDR can also be made relevant for designating an outbound AND maintained WDR. Criteria may be important in this embodiment since an outbound WDR was maintained in some fashion prior to being candidate as an outbound WDR."]}}}},{"@attributes":{"id":"p-0908","num":"1548"},"figref":["FIG. 57","FIG. 57","FIG. 57","FIG. 57","FIG. 57","FIG. 57","FIG. 57"],"b":["6","5700","273","2111","2015","2515","273","2111","2015","2515","5700","22"]},"Depending on the embodiment, charter fields , or an equivalent descriptor thereof, may be accessed by WITS processing to determine which charters are enabled for applicable charter list use. Block  continues to block -where the WRC and applicable origination information of the WDR is accessed. Thereafter, if the WRC and WDR information indicates to ignore the WDR at block -, then processing continues to block , otherwise processing continues to block . Whenever block  is encountered, the decision is made (assumed in ) to continue processing the WDR or not continue processing the WDR in processing which includes  (i.e. , ,  ) as described above. This decision depends on how block  was arrived to by  processing. Blocks -and -may perform any variety of WITS filtering for any reason to prevent further processing of a WDR. In one embodiment, block -checks MS privilege and\/or charter configurations for relevance of further processing the WDR (e.g. there are no configurations existing which are relevant to the WDR from that particular originating MS, therefore no further WDR processing is warranted).","Block  determines the identity (e.g. originating MS) of the in-process WDR (e.g. check field ). A lookup, conversion, and\/or other facilitated determination may be made. Thereafter, if block  determines the identity of the in-process WDR does not match the identity of the MS of  processing, processing continues to block . Block  continues to block  when a) the in-process WDR is from other MSs and is being maintained at the MS of  processing (i.e. FIG. =mWITS); or b) the in-process WDR is from other MSs and is inbound to the MS of  processing (i.e. FIG. =iWITS). For example, a first MS of  processing handles a WDR from a second MS starting at block .","With reference now to , depicted is an illustration for granted data characteristics in the present disclosure LBX architecture, specifically with respect to granted permission data and granted charter data as maintained by a particular MS of  processing (i.e. as maintained by \u201cthis MS\u201d). To facilitate discussion of , permission data  can be viewed as permission data collection  wherein arrows shown are to be interpreted as \u201cprovides privileges to\u201d (i.e. Left Hand Side (LHS) provides privileges to the Right Hand Side (RHS)). Any of the permissions representations heretofore described (internalized, datastream, XML, source code, or any other BNF grammar derivative) can be used to represent, or encode, data of the collection . Regardless of the BNF grammar derivative\/representation deployed, the minimal requirement of collection  is to define the relationships of privileges granted from one ID to another ID (and perhaps with associated MSRelevance and\/or TimeSpec qualifier(s)). Whether grants or explicit privileges are assigned, ultimately there are privileges granted from a grantor ID to a grantee ID.","Different identity embodiments are supported (e.g. MS ID or user ID) for the LHS and\/or RHS (see BNF grammar for different embodiments). Permission data collection  is to be from the perspective of one particular MS, namely the MS of  processing. Thus, the terminology \u201cthis MS ID\u201d refers to the MS ID of the MS of  processing. The terminology \u201cWDR MS ID\u201d is the MS ID (field ) of an in-process WDR of  processing distinguished from all other MS IDs configured in collection  at the time of processing the WDR. The terminology \u201cother MS IDs\u201d is used to distinguish all other MS IDs configured in collection  which are not the same as the MS ID of the terminology \u201cWDR MS ID\u201d (i.e. MS IDs other than the MS ID (field ) of the in-process WDR of  processing (also other than the \u201cthis MS\u201d MS ID)). Privilege configurations  are privileges provided from an in-process WDR MS ID (i.e. WDR being processed by  at \u201cthis MS\u201d) to the MS ID of  processing. The groups an ID belongs to can also provide, or be provided with, privileges so that the universe of privileges granted should consider groups as well. Privilege configurations  are privileges provided from the MS of  processing (this MS) to the MS ID (field ) of the in-process WDR being processed by . Privilege configurations  are privileges provided from the MS of  processing (this MS) to MS IDs (field ) configured in collection  other than the MS ID of the in-process WDR being processed by  (also other than the \u201cthis MS\u201d MS ID). Privilege configurations  are privileges provided from MS IDs configured in collection  at the MS of  processing (this MS) which are different than the MS ID of the in-process WDR being processed by  (also different than the \u201cthis MS\u201d MS ID).","Also to facilitate discussion of , charter data  can be viewed as a charter data collection  wherein arrows shown are to be interpreted as \u201ccreates enabled charters for\u201d (i.e. Left Hand Side (LHS) creates enabled charters for the Right Hand Side (RHS)). Any of the charter representations heretofore described (internalized, datastream, XML, source code, or any other BNF grammar derivative) can be used to represent, or encode, data of the collection . Regardless of the BNF grammar derivative\/representation deployed, the minimal requirement of collection  is to define the charters granted by one ID to another (and perhaps with associated TimeSpec qualifier(s); TimeSpec may be an aggregate-result of TimeSpec specified for the charter, charter expression, charter condition and\/or charter term). Preferably, for charters with multiple actions, each action is evaluated on its own specified TimeSpec merit if applicable. In embodiments that use a tense qualifier in TimeSpecs: LBX history, appropriate queue(s), and any other reasonable source of information shall be utilized appropriately.","Different identity embodiments are supported (e.g. MS ID or user ID) for the LHS and\/or RHS (see BNF grammar for different embodiments). A privilege preferably grants the ability to create effective (enabled) charters for one ID from another ID. However, in some embodiments the granting of a charter by itself from one ID to another ID can be treated like the granting of a permission\/privilege to use the charter, thereby preventing special charter activating permission(s) be put in place. Charter data collection  is also to be from the perspective of the MS of  processing. Thus, the terminology \u201cthis MS ID\u201d refers to the MS ID of the MS of  processing. The terminology \u201cWDR MS ID\u201d is the MS ID (field ) of the in-process WDR of  processing distinguished from all other MS IDs configured in collection  at the time of processing the WDR. The terminology \u201cother MS IDs\u201d is used to distinguish all other MS IDs configured in collection  which are not the same as the MS ID of the terminology \u201cWDR MS ID\u201d (i.e. MS IDs other than the MS ID (field ) of the in-process WDR of  processing (also other than the \u201cthis MS\u201d MS ID)). Charter configurations  are charters created by the MS ID of an in-process WDR (i.e. WDR being processed by  at \u201cthis MS\u201d) for being effective at the MS of  processing (this MS ID). The groups an ID belongs to can also provide, or be provided with, charters so that the universe of charters granted should consider groups as well. Charter configurations  are charters created by the MS ID of  processing (i.e. this MS) for being effective at the MS of  processing (this MS ID). Charter configurations  include the most common embodiments of creating charters for yourself at your own MS. Charter configurations  are charters created by the MS ID of  processing (this MS) for being effective at MSs with MS IDs configured in collection  other than the MS ID of the in-process WDR being processed by . Charter configurations  are charters at the MS of  processing (this MS) which are created by MS IDs other than the MS ID of the in-process WDR being processed by  (also other than the \u201cthis MS\u201d MS ID).","Any subset of data collections  and  can be resident at a MS of  processing, depending on a particular embodiment of the present disclosure, however preferred and most common data used is presented in . While  facilitates flowchart descriptions and discussions for in-process WDR embodiments of being maintained (e.g. to queue ), being inbound (e.g. communicated to the MS), and\/or being outbound (e.g. communicated from the MS),  provide relevant discussions for WDR in-process embodiments when considering generally \u201cincoming\u201d WDRs (i.e. being maintained (e.g. to queue ) or being inbound (e.g. communicated to the MS)).","In the preferred embodiment, groups defined local to the MS are used for validating which data using group IDs of collections  and  are relevant for processing. In alternate embodiments, group information of other MSs may be \u201cvisible\u201d to  processing for broader group configuration consideration, either by remote communications, local maintaining of MS groups which are privileged to have their groups maintained there (communicated and maintained like charters), or another reasonable method.","With reference back to , block  forms a PRIVS2ME list of configurations  and continues to block  for eliminating duplicates that may be found. Block  may collapse grant hierarchies to form the list. Duplicates may occur for privileges which include the duplicated privileges (i.e. subordinate privileges). For example, \\lbxall specifies all LBX privileges and \\nearar is only one LBX privilege already included in \\lbxall. Recall that some privileges can be higher order scoped (subordinate) privileges for a plurality of more granulated privileges. Block  additionally eliminates duplicates that may exist for permission embodiments wherein a privilege can enable or disable a feature. In a present disclosure embodiment wherein a privilege can enable, and a privilege can disable the same feature or functionality, there is preferably a tie breaker of disabling the feature (i.e. disabling wins). In an alternate embodiment, enabling may break a tie of ambiguity. Block  further eliminates privileges that have a MSRelevance qualifier indicating the MS of  processing is not supported for the particular privilege, and also eliminates privileges with a TimeSpec qualifier invalid for the time of  processing (an alternate embodiment can enforce TimeSpec interpretation at blocks  (i.e. in  processing) and  (i.e. in  processing)). Thereafter, block  forms a PRIVS2WDR list of configurations  and continues to block  for eliminating duplicates that may be found in a manner analogous to block  (i.e. subordinate privileges, enable\/disable tie breaker, MSRelevance qualifier, TimeSpec qualifier). Block  may collapse grant hierarchies to form the list. An alternate embodiment can enforce TimeSpec interpretation at block  (i.e. in  processing). Thereafter, block  forms a CHARTERS2ME list of configurations  and preferably eliminates variables by instantiating\/elaborating at points where they are referenced. Then, block  eliminates those charters which are not privileged. In some embodiments, block  is not necessary ( continues to ) because un-privileged charters will not be permitted to be present at the MS of  processing anyway (e.g. eliminated when receiving). Nevertheless, block  removes from the CHARTERS2ME list all charters which do not have a privilege (e.g. using PRIVS2WDR) granted by the MS (the MS user) of  processing to the creator of the charter, for permitting the charter to be \u201cin effect\u201d (activated). In the preferred embodiment, there is a privilege (e.g. \\chrtrs) which can be used to grant the permission of activating any charters of another MS (or MS user) at the MS of  processing. In the preferred embodiment, there can be any number of subordinate charter privileges (i.e. subordinate to \\chrtrs) for specifically indicating which type of charters are permitted. For example, privileges for governing which charters are to be active from a remote MS include:\n\n","Block  checks the PRIVS2ME list to see if there is a privilege granted from the identity of the in-process WDR to the MS (or user of MS) of  processing for being able to \u201csee\u201d the WDR. One main privilege (e.g. \\lbxiop) can enable or disable whether or not the MS of  processing should be able to do anything at all with the WDR from the remote MS. If block  determines this MS can process the WDR, then processing continues to block . Block  enables local features and functionality in accordance with privileges of the PRIVS2ME list by invoking the enable features and functionality procedure of  with the PRIVS2ME list, and the in-process WDR as parameters (preferably passed by pointer\/reference).","With reference now to , depicted is a flowchart for describing a preferred embodiment of a procedure for enabling LBX features and functionality in accordance with a certain type (category) of permissions. Blocks , , , , , , , and  enable or disable LBX features and functionality for semantic privileges. Processing of block  starts at block  and continues to block  where the permission type list parameter passed (i.e. PRIVS2ME () when invoked from block ) is determined, and the in-process WDR may be accessed. The list parameter passed provides not only the appropriate list to  processing, but also which list configuration (, ,  or ) has been passed for processing by . There are potentially thousands of specific privileges that  can handle. Therefore,  processing is shown to generically handle different classes (categories) of privileges, namely privilege classes of: privilege-configuration, charter-configuration, data send, impersonation, WDR processing, situational location, monitoring, LBX, LBS, and any others as handled by block . Privileges disclosed throughout the present disclosure fall into one of these classes handled by .","Block  continues to block  where if it is determined that a privilege-configuration privilege is present in the list parameter passed to  processing, then block  will remove privileges from the list parameter if appropriate to do that. For example, a privilege (or absence thereof) detected in the list parameter for indicating no privileges can be defined\/enabled in context of the list parameter causes block  to remove all privileges from the list parameter and also from permissions  (i.e.  of collection  when  invoked from block ). Similarly, any more granular privilege-configuration privileges of the list parameter causes processing to continue to block  for ensuring remaining privileges of the list parameter (and of permissions  configurations) are appropriate. There can be many different privilege-configuration privileges for what can, and can't, be defined in permissions , for example by any characteristic(s) of permissions data  according to the present disclosure BNF grammar. Block  continues to block  when all privilege-configuration privileges are reflected in the list parameter and collection  of permissions . If block  determines there are no privilege-configuration privileges to consider in the list parameter passed to  processing, then processing continues to block .","Block  gets the next individual privilege entry (or the first entry upon first encounter of block  for an invocation of ) from the list parameter and continues to block . Blocks  through  iterate all individual privileges (list entries) associated with the list parameter of permissions  provided to block . If block  determines there was an unprocessed privilege entry remaining in the list parameter (i.e.  of collection  when  invoked from block ), then the entry gets processed starting with block . If block  determines the entry is a charter-configuration privilege, then block  will remove charters from CHARTERS2ME if appropriate to do that. For example, a privilege (or absence thereof) detected in the list parameter for indicating no CHARTERS2ME charters can be defined\/enabled in context of the list parameter causes block  to remove all charters from CHARTERS2ME and also from charters  (i.e.  of collection  when  invoked from block ). Similarly, any more granular charter-configuration privileges of the list parameter causes processing to continue to block  for ensuring remaining charters of CHARTERS2ME (and of charters  configurations) are appropriate. There can be many different charters-configuration privileges for what can and can't be defined in charters , for example by any characteristic(s) of charters data  according to the present disclosure BNF grammar, in particular for an in-process WDR from another MS. Any aspect of charters can be privileged (all, certain commands, certain operands, certain parameters, certain values of any of those, whether can specify Host for action processing, certain conditions and\/or terms\u2014See BNF grammar). Block  then continues to block . Block  will remove charters from MYCHARTERS if appropriate to do that. For example, a privilege (or absence thereof) detected in the list parameter for indicating certain MYCHARTERS charters (e.g. those that involve the in-process WDR) can\/cannot be defined\/enabled in context of the list parameter causes block  to remove charters from MYCHARTERS for subsequent  processing. Changes to charters  for the MYCHARTERS list does not occur. This prevents deleting charters locally at the MS that the user spent time creating at his MS. Removing from the MYCHARTERS list is enough to affect subsequent  processing, for example of an in-process WDR. Block  shown does additionally remove from charters  because the charters are not valid from a remote user anyway. One preferred embodiment to block  will not alter charters  (only CHARTERS2ME) similarly to block  so that subsequent  processing continues properly while preventing a remote MS user from resending charters (use of ) at a subsequent time for reinstatement upon discovering the \u201cthis MS\u201d  processing user had not provided a needed permission\/privilege. Block  continues back to block  for the next entry. Blocks  and  make use of the privilege entry data from block  (e.g. grantor ID, grantee ID, privilege, etc) to properly affect change of CHARTERS2ME and MYCHARTERS. CHARTERS2ME and MYCHARTERS are shown as global variables accessible from  processing to  processing, but an alternate embodiment will pass these lists as additional parameters determined at block . If block  determined the currently iterated privilege is not a charter configuration privilege, then processing continues to block .","If block  determines the entry is a data send privilege, then block  will enable LBX features and functionality appropriately in context for the list parameter, and processing continues back to block . A data send privilege may be one that is used at block  and enforced at block  for exactly what data can or cannot be received. Any granulation of permission data  or charter data  (e.g. by any characteristic(s)) may be supported. A data send privilege may overlap with a privilege-configuration privilege or a charter-configuration privilege since either may be used at blocks  and , depending on an embodiment. It may be useful to control what data can be received by a MS at blocks  and  versus what data actually gets used for  processing as controlled by blocks , , , , and . If block  determines the entry is not a data send privilege, then processing continues to block . Data send privileges can control what privilege, charter, and\/or group data can and cannot be sent to a MS (i.e. received by a MS). Data send privileges can be overall privileges, subordinate privileges, and\/or privileges for any granulation of data based on type, size, value, age, or any other characteristic(s) available from a derivative of the BNF grammar of .","If block  determines the entry is an impersonation privilege, then block  will enable LBX features and functionality appropriately in context for the list parameter, and processing continues back to block . An impersonation privilege is one that is used to access certain authenticated user interfaces, some of which were described above. Any granulation of permission data  (e.g. by any characteristic(s)) may be supported, for example for any subset of MS user interfaces with respect to the present disclosure. Block  may access security, or certain application interfaces accessible to the MS of  processing for read, modify, add, or otherwise alter certain related data, or cause the processing of certain related executable code, for example to manage associated identity impersonation at the MS. If block  determines the entry is not an impersonation privilege, then processing continues to block . Impersonation privileges can be overall privileges, subordinate privileges, and\/or privileges for any granulation of identity data or any other characteristic(s) available from a derivative of the BNF grammar of .","If block  determines the entry is a WDR privilege, then block  will enable LBX features and functionality appropriately in context for the list parameter, and processing continues back to block . A WDR privilege is one that is used to govern access to certain fields of the in-process WDR. Any granulation of permission data  (e.g. by any characteristic(s)) may be supported, for example for any subset of available in-process WDR data. Block  may access any in-process WDR field, subfield(s), or associated in-process WDR data to make use of certain application interfaces accessible to the MS of  processing for read, modify, add, or otherwise alter certain related data, or cause the processing of certain related executable code, for example to manage appropriate in-process WDR processing. If block  determines the entry is not a WDR privilege, then processing continues to block . WDR privileges can be overall privileges, subordinate privileges, and\/or privileges for any granulation of in-process related WDR data, perhaps using any characteristic(s) available from a derivative of the BNF grammar of .","If block  determines the entry is a Situational Location privilege, then block  will enable LBX features and functionality appropriately in context for the list parameter, and processing continues back to block . A Situational Location privilege may overlap with a WDR privilege since WDR fields are consulted for automated processing, however it may be useful to distinguish. Any granulation of permission data  (e.g. by any characteristic(s)) may be supported, for example for any subset of available in-process relevant WDR data. The term \u201csituational location\u201d is useful for describing location based conditions (e.g. as disclosed in Service delivered location dependent content of U.S. Pat. Nos. 6,456,234; 6,731,238; 7,187,997 (Johnson)). Block  may access any in-process WDR field, subfield(s), or associated in-process WDR data for appropriate LBX processing involving read, modify, add, or otherwise alter certain related data, or cause the processing of certain related executable code, for example to manage appropriate in-process WDR situational location processing. If block  determines the entry is not a situational location privilege, then processing continues to block . Situational location privileges can be overall privileges, subordinate privileges, and\/or privileges for any granulation of in-process related WDR data, perhaps using any characteristic(s) available from a derivative of the BNF grammar of .","If block  determines the entry is a monitoring privilege, then block  will enable LBX features and functionality appropriately in context for the list parameter, and processing continues back to block . A monitoring privilege governs monitoring any data of a MS for any reason (e.g. in charter conditions). Any granulation of permission data  (e.g. by any characteristic(s)) may be supported, for example for any subset of MS data. Block  may access any MS data, or associated in-process WDR data for appropriate LBX processing involving read, modify, add, or otherwise alter certain related data, or cause the processing of certain related executable code, for example to manage appropriate in-process WDR processing at the MS. If block  determines the entry is not a monitoring privilege, then processing continues to block . Monitoring privileges can be overall privileges, subordinate privileges, and\/or privileges for any granulation of MS data (MS of  processing or of the in-process WDR), perhaps using any characteristic(s) available from a derivative of the BNF grammar of .","If block  determines the entry is a LBX privilege, then block  will enable LBX features and functionality appropriately in context for the list parameter, and processing continues back to block . A LBX privilege governs LBX processing behavior at the MS of  processing. Other privileges so far discussed for  processing may overlap with an LBX privilege. Any granulation of permission data  (e.g. by any characteristic(s)) may be supported, for example for unique LBX processing at the MS of  processing. Block  may access any MS data, or associated in-process WDR data for appropriate LBX processing involving read, modify, add, or otherwise alter certain related data, or cause the processing of certain related executable code, for example to perform LBX processing at the MS. If block  determines the entry is not a LBX privilege, then processing continues to block . LBX privileges can be overall privileges, subordinate privileges, and\/or privileges for any granulation of MS data (MS of  processing or of the in-process WDR), perhaps using any characteristic(s) available from a derivative of the BNF grammar of .","If block  determines the entry is a LBS privilege, then block  will enable LBS features and functionality appropriately in context for the list parameter, and processing continues back to block . A LBS privilege governs LBS processing behavior at the MS of  processing. Other privileges so far discussed for  processing may overlap with an LBS privilege. Any granulation of permission data  (e.g. by any characteristic(s)) may be supported, for example for unique LBS processing at the MS of  processing. Block  may access any MS data, or associated in-process WDR data for appropriate LBS processing involving read, modify, add, or otherwise alter certain related data, or cause the processing of certain related executable code, for example to perform LBS processing at the MS, and perhaps cause processing at a connected LBS. If block  determines the entry is not a LBS privilege, then processing continues to block . LBS privileges can be overall privileges, subordinate privileges, and\/or privileges for any granulation of MS data (MS of  processing or of the in-process WDR), perhaps using any characteristic(s) available from a derivative of the BNF grammar of , and perhaps using any data or interface of a connected LBS.","Block  is provided for processing completeness for handling appropriately (e.g. enable or disable MS processing) a privilege that some reader may not appreciate falling into one of the privilege classes of  processing. Block  then continues to block . Referring back to block , if it is determined there are no more unprocessed entries remaining in the list parameter (i.e.  of collection  when  invoked from block ), then the caller\/invoker is returned to at block .",{"@attributes":{"id":"p-0930","num":"1581"},"figref":["FIG. 59","FIG. 59","FIG. 59","FIG. 59"],"b":["5904","5906","4466","4470","5802","5852","5904","5906","5912","5916","4466","4470","5802","5852","5912","5916"]},"In one embodiment,  uses the absence of certain privileges to enable or disable LBX features and functionality wherein block -A determines which privileges were not provided, block -B enables\/disables LBX features and functionality in accordance with the lack of privileges, and block -C returns to the caller\/invoker.","With reference back to , block  continues to block . Some embodiments of  blocks , , , , , , etc may perform sorting for a best processing order (e.g. as provided to procedures of ). Block  performs actions in accordance with privileges of the PRIVS2ME list by invoking the do action procedure of  with the PRIVS2ME list, and the in-process WDR as parameters (preferably passed by pointer\/reference).","With reference now to , depicted is a flowchart for describing a preferred embodiment of a procedure for performing LBX actions in accordance with a certain type of permissions. Blocks , , , , , , , and  perform actions for semantic privileges. Processing of block  starts at block  and continues to block  where the permission type parameter passed (i.e. PRIVS2ME () when invoked from block ) is determined, and the in-process WDR may be accessed. The list parameter passed provides not only the appropriate list to  processing, but also which list configuration (, ,  or ) has been passed for proper processing by . There are potentially thousands of specific privileges that  can handle. Therefore,  processing is shown to generically handle different classes (categories) of privileges, namely privilege classes of: data send, impersonation, WDR processing, situational location, monitoring, LBX, LBS, and any others as handled by block . Privileges disclosed throughout the present disclosure fall into one of these classes handled by .","Block  continues to block . Block  gets the next individual privilege entry (or the first entry upon first encounter of block  for an invocation of ) from the list parameter and continues to block . Blocks  through  iterate all individual privileges associated with the list parameter of permissions  provided to block . If block  determines there was an unprocessed privilege entry remaining in the list parameter (i.e.  of collection  when  invoked from block ), then the entry gets processed starting with block .","If block  determines the entry is a data send privilege, then block  will perform any LBX actions in context for the list parameter (if any applicable), and processing continues back to block . A data send privilege may be one that is used at block  and enforced at block  for exactly what data can or cannot be received, or alternatively, block  can perform actions for communicating data between MSs, or affecting data at MSs, for an appropriate local image of permissions  and\/or charters . Any granulation of permission data  or charter data  (e.g. by any characteristic(s)) may be supported. If block  determines the list entry is not a data send privilege, processing continues to block .","If block  determines the entry is an impersonation privilege, then block  will perform any LBX actions in context for the list parameter (if any applicable), and processing continues back to block . Block  may access security, or certain application interfaces accessible to the MS of  processing for read, modify, add, or otherwise alter certain related data, or cause the processing of certain related executable code, for example to manage associated identity impersonation at the MS. If block  determines the entry is not an impersonation privilege, then processing continues to block .","If block  determines the entry is a WDR privilege, then block  will perform any LBX actions in context for the list parameter (if any applicable), and processing continues back to block . Block  may access any in-process WDR field, subfield(s), or associated in-process WDR data to make use of certain application interfaces accessible to the MS of  processing for read, modify, add, or otherwise alter certain related data, or cause the processing of certain related executable code, for example to manage appropriate in-process WDR processing. If block  determines the entry is not a WDR privilege, then processing continues to block .","If block  determines the entry is a Situational Location privilege, then block  will perform any LBX actions in context for the list parameter (if any applicable), and processing continues back to block . Block  may access any in-process WDR field, subfield(s), or associated in-process WDR data for appropriate LBX processing involving read, modify, add, or otherwise alter certain related data, or cause the processing of certain related executable code, for example to manage appropriate in-process WDR situational location processing. If block  determines the entry is not a situational location privilege, then processing continues to block ","If block  determines the entry is a monitoring privilege, then block  will perform any LBX actions in context for the list parameter (if any applicable), and processing continues back to block . Block  may access any MS data, or associated in-process WDR data for appropriate LBX processing involving read, modify, add, or otherwise alter certain related data, or cause the processing of certain related executable code, for example to manage appropriate in-process WDR processing at the MS. If block  determines the entry is not a monitoring privilege, then processing continues to block .","If block  determines the entry is a LBX privilege, then block  will perform any LBX actions in context for the list parameter (if any applicable), and processing continues back to block . Block  may access any MS data, or associated in-process WDR data for appropriate LBX processing involving read, modify, add, or otherwise alter certain related data, or cause the processing of certain related executable code, for example to perform LBX processing at the MS. If block  determines the entry is not a LBX privilege, then processing continues to block .","If block  determines the entry is a LBS privilege, then block  will perform any LBS actions in context for the list parameter, and processing continues back to block . Block  may access any MS data, or associated in-process WDR data for appropriate LBS processing involving read, modify, add, or otherwise alter certain related data, or cause the processing of certain related executable code, for example to perform LBS processing at the MS, and perhaps cause processing at a connected LBS. If block  determines the entry is not a LBS privilege, then processing continues to block .","Block  is provided for processing completeness for handling appropriately (e.g. performing any LBX actions in context for the list parameter (if any applicable) a privilege that some reader may not appreciate falling into one of the privilege classes of  processing. Block  then continues to block . Referring back to block , if it is determined there are no more unprocessed entries remaining in the list parameter (i.e.  of collection  when  invoked from block ), then the caller\/invoker is returned to at block .","In one embodiment,  uses the absence of certain privileges to perform LBX actions in context for the list parameter wherein block -A determines which privileges were not provided, block -B performs LBX actions in context for the lack of privileges, and block -C returns to the caller\/invoker.",{"@attributes":{"id":"p-0944","num":"1595"},"figref":["FIG. 60","FIG. 60","FIG. 60","FIG. 60","FIGS. 59 and 60"],"b":["5300","5300","5300","5300","5300"],"i":["j ","k "],"ul":{"@attributes":{"id":"ul0110","list-style":"none"},"li":{"@attributes":{"id":"ul0110-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0111","list-style":"none"},"li":["1) Performing appropriate and directed executable linkage as indicated by the PRR at initialization time of block ;","2) Performing loading into executable memory of needed dynamically linked executables (e.g. DLL) as indicated by the PRR at initialization time of block  wherein the PRR provides link library information for resolving linkage; and\/or","3) Validating presence of, or performing loading of, the executables\/script\/etc in an appropriate manner at an appropriate initialization time.\n\nNote that atomic command processing solves performance issues by providing a tightly linked executable environment while providing methods for customized processing. Many applications may be invoked for the same privilege (i.e. blocks , , , , , ,  and\/or  can certainly invoke multiple applications (i.e. cause multiple actions) for a single privilege), depending on what is found in the APR table. Of course, integrated application action processing can be built with LBX software so that the MS applications are tightly integrated with the LBX processing. Generally,  includes appropriate processing of applications while  affects data which can be accessed (e.g. polled) by applications.\n"]}}}},"With reference back to , block  continues to block . Block  performs actions in accordance with privileges of the PRIVS2WDR list by invoking the do action procedure of  with the PRIVS2WDR list, and the in-process WDR as parameters (preferably passed by pointer\/reference), and then continues to block .  processing is analogously as described above except in context for the PRIVS2WDR () list and for the in-process WDR of  processing relative the PRIVS2WDR list. One embodiment may incorporate a block  (block  continues to  which continues to block ) for invoking  processing with PRIVS2WDR. Generally, privilege configurations  involve actions for the benefit of the WDR originator.","Block  processing merges the MYCHARTERS and CHARTERS2ME lists into a CHARTERS2DO list, and continues to block  for eliminating inappropriate charters that may exist in the CHARTERS2DO list. Block  additionally eliminates charters with a TimeSpec qualifier invalid for the time of  processing (an alternate embodiment can enforce TimeSpec interpretation at block ). If all actions, or any condition, term, expression, or entire charter itself has a TimeSpec outside of the time of  processing, then preferably the entire charter is eliminated. Action(s) are removed from a charter which remains in effect if action(s) for a charter have an invalid TimeSpec for the time of  processing, in which case any remaining actions with no TimeSpec or a valid TimeSpec are preserved for the effective charter. If all charter actions are invalid per TimeSpec, then the charter is completely eliminated. Thereafter, block  performs charter actions in accordance with conditions of charters of the CHARTERS2DO list (see ), and processing then terminates at block .","Block  can eliminate charters which are irrelevant for processing, for example depending upon the type of in-process WDR. For a maintained WDR, inappropriate charters may be those which do not have a maintained condition specification (i.e. _fldname). For an inbound WDR, inappropriate charters may be those which do not have an in-bound condition specification (i.e. _I_fldname). For an outbound WDR, inappropriate charters may be those which do not have an out-bound condition specification (i.e. _O_fldname). The context of WITS processing (mWITS, iWITS, oWITS) may be used at block  for eliminating inappropriate charters.","With reference back to block , if it is determined that this MS should not process (see) the WDR in-process, processing continues to block  where  processing is terminated, and the processing host of  (i.e. , , , ) appropriately ignores the WDR.","With reference back to block , if it is determined that the WDR identity matches the MS of  processing, processing continues to block . Block  continues to block  when a) the in-process WDR is from this MS and is being maintained at the MS of  processing (i.e. FIG. =mWITS); or b) the in-process WDR is outbound from this MS (i.e. FIG. =oWITS). Block  forms a PRIVS2OTHERS list of configurations  and continues to block  for eliminating duplicates that may be found. Block  may collapse grant hierarchies to form the list. Duplicates may occur for privileges which include the duplicated privileges (i.e. subordinate privileges) as described above. Block  additionally eliminates duplicates that may exist for permission embodiments wherein a privilege can enable or disable a feature. In a present disclosure embodiment wherein a privilege can enable, and a privilege can disable the same feature or functionality, there is preferably a tie breaker of disabling the feature (i.e. disabling wins). In an alternate embodiment, enabling may break a tie of ambiguity. Block  further eliminates privileges that have a MSRelevance qualifier indicating the MS of  processing is not supported for the particular privilege, and also eliminates privileges with a TimeSpec qualifier invalid for the time of  processing (an alternate embodiment can enforce TimeSpec interpretation at block  (i.e. in  processing)). Thereafter, block  forms a MYCHARTERS list of configurations  and preferably eliminates variables by instantiating\/elaborating at points where they are referenced. Then, block  forms a CHARTERS2ME list of configurations  and preferably eliminates variables by instantiating\/elaborating at points where they are referenced. Then, block  eliminates those charters which are not privileged. In some embodiments, block  is not necessary ( continues to ) because un-privileged charters will not be permitted to be present at the MS of  processing. Nevertheless, block  removes from the CHARTERS2ME list all charters which do not have a privilege granted by the MS (the MS user) of  processing to the creator of the charter, for permitting the charter to be enabled (as described above for block ). In any embodiments, block  ensures no charters from other users are considered active unless appropriately privileged. Thereafter, block  performs actions in accordance with privileges of the PRIVS2OTHERS list by invoking the do action procedure of  with the PRIVS2ME list, and the in-process WDR as parameters (preferably passed by pointer\/reference), and then continues to block  which has already been described.  processing is the same as described above except in context for the PRIVS2OTHERS () and for the in-process WDR of  processing relative the PRIVS2OTHERS list. Of course the context of blocks  through  are processed for in-process WDRs which are: a) maintained to the MS of  for the whereabouts of the MS of  processing; or b) outbound from the MS of  processing (e.g. an outbound WDR describing whereabouts of the MS of  processing). One embodiment may incorporate a block  (block  continues to  which continues to block ) for invoking  processing with PRIVS2OTHERS. Generally, privilege configurations  involve actions for the benefit of others (i.e. other than this MS).","When considering the terminology \u201cincoming\u201d as used for , a WDR in-process at this MS (the MS of  processing) which was originated by this MS with an identity for this MS uses: a) this MS charters ( confirmed by  bullet  part ,  bullet  part , , ); b) others' charters per this MS (or this MS user) privileges to them ( confirmed by  bullet ,  bullet ,  bullet ,  bullet , , ); and c) this MS (or this MS user) privileges to others ( confirmed by  bullet ,  bullet ,  bullet ,  bullet ). An alternate embodiment additionally uses d) others' privileges to this MS (or this MS user) (), for example to determine how nearby they are at outbound WDR time or at the time of maintaining the MS's own whereabouts. This alternate embodiment would cause  to include: a new block  for forming a PRIVS2ME list of privileges ; a new block  for eliminating duplicates, MSRelevance rejects and invalid TimeSpec entries; a new block  for enabling features an functionality in accordance with the PRIVS2ME list of block  by invoking the enable features and functionality procedure of  with PRIVS2ME as a parameter ( processing analogous to as described above except for PRIVS2ME); and a new block  for performing actions in accordance with PRIVS2ME by invoking the do action procedure of  with PRIVS2ME as a parameter ( processing analogous to as described above except for PRIVS2ME). Such an embodiment would cause block  to continue to block  which continues to block  which continues to block  which continues to block  which then continues to block .","When considering the terminology \u201cincoming\u201d as used for , a WDR in-process at this MS (the MS of  processing) which was originated by a remote MS with an identity different than this MS uses: e) this MS charters per other's privileges to this MS (or this MS user) ( confirmed by  bullet  part ,  bullet  part , , ,  bullet ); f) others' charters per this MS (or this MS user) privileges to them ( confirmed by  bullet ,  bullet ,  bullet ,  bullet , , ); g) this MS (or this MS user) privileges to others ( confirmed by  bullet ,  bullet ,  bullet ,  bullet ); and h) others' privileges to this MS (or this MS user) ( confirmed by  bullet ,  bullet ,  bullet ,  bullet ). An alternate embodiment additionally uses i) others' charters per this MS (or this MS user) privileges to them (); and\/or j) this MS (or this MS user) privileges to others (); and\/or k) others' privileges to this MS (or this MS user) (). This alternate embodiment would cause  to alter block  to further include charters , alter block  to further include privileges , include a new block  for forming a PRIVS2OTHERS list of privileges , new block  for eliminating duplicates, new block  for enabling features an functionality in accordance with the PRIVS2OTHERS list of block , new block  for enabling features an functionality in accordance with the modified PRIVS2ME list of block , and new block  for performing actions in accordance with the modified PRIVS2ME (i.e. block  continues to block  which continues to block  which continues to block  which continues to block  which continues to block  which then continues to block ). Also, blocks  and  would appropriately handle new charters of altered block . Such an embodiment would cause new blocks ,  and  to invoke the applicable procedure ( or ) with analogous processing as described above except in context for the parameter passed.","In some  embodiments, blocks  and\/or  and\/or  and\/or relevant alternate embodiment blocks discussed are remotely accessed by communicating with the MS having the identity determined at block  for the WDR in-process. The preferred embodiment is as disclosed for maintaining data local to the MS for processing there. In other embodiments, there are separate flowcharts (e.g. , B and C) for each variety of handling in-process WDRs (e.g. mWITS, iWITS, oWITS processing).","Various  embodiments' processing will invoke the procedures of  with appropriate parameters (i.e. lists for  and\/or  and\/or  and\/or ) so that any category subset of the permission data collection  (i.e.  and\/or  and\/or  and\/or ) is used to enable appropriate LBX features and functionality according to the WDR causing execution of  processing. For example, privileges between the MS of  processing and an identity other than the WDR causing  processing may be used (e.g. relevant MS third party notification, features, functionality, or processing as defined by related privileges).","Various  embodiments' processing will invoke charter processing with appropriate parameters (i.e. lists for  and\/or  and\/or  and\/or ) so that any category subset of the charter data collection  (i.e.  and\/or  and\/or  and\/or ) is used to perform LBX actions according to the WDR causing execution of  processing. For example, charters between the MS of  processing and an identity other than the WDR causing  processing may be used (e.g. relevant MS third party charters as defined by related privileges).",{"@attributes":{"id":"p-0955","num":"1609"},"figref":["FIG. 57","FIGS. 30A through 30E"],"b":["5706","5704","5706","1100","5706","5706","1100"],"i":["a","k "]},"Preferably, statistics are maintained by WITS processing for each reasonable data worthy of tracking from standpoints of user reporting, automated performance fine tuning (e.g. thread throttling), automated adjusted processing, and monitoring of overall system processing. In fact, every processing block of  can have a plurality of statistics to be maintained.",{"@attributes":{"id":"p-0957","num":"1611"},"figref":["FIG. 61","FIG. 57","FIG. 61","FIG. 61","FIG. 57"],"b":["5744","5718","5756","5744","6102","6104","6104","6104","6102","6106","6104","6104","6162"]},"If block  determines there is a charter to process, then processing continues to block  for instantiating any variables that may be referenced in the charter, and then continues to block . Charter parts are scanned for referenced variables and they are instantiated so that the charter is intact without a variable reference. The charter internalized form may be modified to accommodate instantiation(s).  may have already instantiated variables for charter elimination processing. Block  is typically not required since the variables were likely already instantiated when internalized to a preferred embodiment CHARTERS2DO processable form, and also processed by previous blocks of  processing. Nevertheless, block  is present to cover other embodiments, and to handle any instantiations which were not already necessary. In some embodiments, block  is not required since variable instantiations can occur as needed when processing the individual charter parts during subsequent blocks of  processing. Block  would continue to block  when a block  is not required.","Block  begins an iterative loop (blocks  through ) for processing all special terms from the current charter expression. Block  gets the next (or first) special term (if any) from the charter expression and continues to block . A special term is a BNF grammar WDRTerm, AppTerm, map term, or atomic term. If block  determines a special term was found for processing from the expression, then block  accesses privileges to ensure the special term is privileged for use. Appropriate permissions  are accessed in this applicable context of  processing. Block  then continues to block . Blocks  and  may not be required since unprivileged charters were already eliminated in previous blocks of  processing (e.g. see blocks  and ). Nevertheless, blocks  and  are shown to cover other embodiments, and to ensure unprivileged charters are treated ineffective. Depending on an embodiment, blocks  and  may only perform obvious eliminations. In other embodiments, there may be no blocks  or  so that charter part processing occurs only in one place (i.e. ) to achieve better MS performance by preventing more than one scan over charter data. In another embodiment, blocks  and  are not required since all charter eliminations based on privileges already occurred at the previous blocks of  processing. Block  can continue to block  when blocks  and  are not required.","If block  determines the special term is privileged for use (e.g. explicit privilege, or lack of a privilege denying use, depending on privilege deployment embodiments), then block  appropriately accesses the special term data source and replaces the expression referenced special term with the corresponding value. Block  accesses special term data dynamically so that the terms reflect values at the time of block  processing. Block  continues back to block . A WDRTerm is accessed from the in-process WDR to  processing. An AppTerm is an anticipated registered application variable accessed by a well known name, typically with semaphore control since an asynchronous application thread is writing to the variable. A map term is an indicated name (e.g. ?refname) which references a map point or map region found in records . An atomic term will cause access to WDR data at queue  or LBX history , application status for applications in use at the MS of  processing, system date\/time, the MS ID of the MS of  processing, or other appropriate data source.","Referring back to block , if it is determined that the special term of the charter expression is not privileged, then block  logs an appropriate error (e.g. to LBX history ) and processing continues back to block  for the next charter. An alternate block  may alert the MS user, and in some cases require the user to acknowledge the error before continuing back to block . So, the preferred embodiment of charter processing eliminates a charter from being processed if any single part of the charter expression is not privileged.","Referring back to block , if it is determined there are no special terms in the expression remaining to process (or there were none in the expression), then block  evaluates the expression to a Boolean True or False result using well known processing for a stack based parser for expression evaluation (e.g. See well known compiler\/interpreter development techniques (e.g. \u201cAlgorithms+Data Structures=Programs\u201d by Nicklaus Wirth published by Prentice-Hall, Inc. 1976)). Block  implements atomic operators using the WDR queue , most recent WDR for this MS, LBX history , or other suitable MS data. Any Invocation is also invoked for resulting to a True or False wherein a default is enforced upon no return code, or no suitable return code, returned. Invocation parameters that had special terms would have been already been updated by block  to eliminate special terms prior to invocation. In an alternate embodiment, stack processing of block  evaluates all special terms when required so that expressions may result in being evaluated to a special term which subsequently gets resolved. In this alternate embodiment, block  would incorporate privilege validation of blocks  and  as well as special term elaboration\/replacement of blocks ,  and ; and block  can recognize a special indicator, or syntax, for specifying to reduce an expression to a type of special term. Thereafter, if block  determines the expression evaluated to False, then processing continues back to block  for the next charter (i.e. expression=False implies to prevent (not cause) the action(s) of the charter). If block  determines the expression evaluated to True, then processing continues to block .","Block  begins an iterative loop (blocks  through ) for processing all actions from the current charter. Block  gets the next (or first) action (if any) from the charter and continues to block . There should be at least one action in a charter provided to  processing since the preferred embodiment of  processing will have eliminated any placeholder charters without an action specified (e.g. charters with no actions preferably eliminated at blocks  as part of the merge process, at block , or as part of previous  processing to form privileged charter lists). If block  determines an unprocessed action was found for processing, then block  initializes a REMOTE variable to No. Thereafter, if it is determined at block  that the action has a BNF grammar Host specification, then block  accesses privileges and block  checks if the action is privileged for being executed at the Host specified. The appropriate permissions  are accessed at block  in this applicable context of  processing. If block  determines the action is privileged for running at the Host, then block  sets the REMOTE variable to the Host specified and processing continues to block . If block  determines the action is not privileged for running at the Host, then processing continues to block  for error processing already described above. If block  determines there was no Host specified for the action, processing continues directly to block . Blocks  and  may not be required since unprivileged charters were already eliminated in previous blocks of  processing (e.g. see blocks  and ). Nevertheless, blocks  and  are shown to cover other embodiments, and to ensure unprivileged charters are treated ineffective. Depending on an embodiment, blocks  and  may only perform obvious eliminations. In other embodiments, there may be no blocks  or  so that charter part processing occurs only in one place (i.e. ) to achieve better MS performance by preventing more than one scan over charter data. In another embodiment, blocks  and  are not required since all charter eliminations based on privileges already occurred at the previous blocks of  processing. Block  can continue to block  when blocks  and  are not required and a Host was specified with the action. In some embodiments, block  may cause logging of an error and a return to block  so other charter actions are not ignored for an unprivileged host.","Block  accesses appropriate permissions  in this applicable context of  processing for ensuring the command and operand are appropriately privileged. Thereafter, if block  determines that the action's command and operand are not privileged, then processing continues to block  for error processing already described. If block  determines the action's command and operand are to be effective, then processing continues to block . Blocks  and  may not be required since unprivileged charters were already eliminated in previous blocks of  processing (e.g. see blocks  and ). Nevertheless, blocks  and  are shown to cover other embodiments, and to ensure unprivileged charters are treated ineffective. Depending on an embodiment, blocks  and  may only perform obvious eliminations. In other embodiments, there may be no blocks  or  so that charter part processing occurs only in one place (i.e. ) to achieve better MS performance by preventing more than one scan over charter data. In another embodiment, blocks  and  are not required since all charter eliminations based on privileges already occurred at the previous blocks of  processing. Block , and the No condition of block , would continue to block  when blocks  and  are not required. In some embodiments, block  may cause logging of an error and a return to block  so other charter actions are not ignored for an unprivileged action.","Block  begins an iterative loop (blocks  through ) for processing all parameter special terms of the current charter. Block  gets the next (or first) parameter special term (if any) and continues to block . A special term is a BNF grammar WDRTerm, AppTerm, map term, or atomic term (as described above). If block  determines a special term was found for processing from the parameter list, then block  accesses privileges to ensure the special term is privileged for use. The appropriate permissions  are accessed in this applicable context of  processing. Block  then continues to block . Blocks  and  may not be required since unprivileged charters were already eliminated in previous blocks of  processing (e.g. see blocks  and ). Nevertheless, blocks  and  are shown to cover other embodiments, and to ensure unprivileged charters are treated ineffective. Depending on an embodiment, blocks  and  may only perform obvious eliminations. In other embodiments, there may be no blocks  or  so that charter part processing occurs only in one place (i.e. ) to achieve better MS performance by preventing more than one scan over charter data. In another embodiment, blocks  and  are not required since all charter eliminations based on privileges already occurred at the previous blocks of  processing. Block  can continue to block  when blocks  and  are not required.","If block  determines the special term is privileged for use (e.g. explicit privilege, or lack of a privilege denying use, depending on privilege deployment embodiments), then block  appropriately accesses the special term data source and replaces the parameter referenced special term with the corresponding value (e.g. map term gets replaced with associated PointSet). Block  accesses special term data dynamically so that the terms reflect values at the time of  block  processing. Block  continues back to block . A WDRTerm, AppTerm, map term, and atomic term are accessed in a manner analogous to accessing them at block .","Referring back to block , if it is determined that the special term of the parameter list is not privileged, then processing continues to block  for error processing already described. In some embodiments, block  may cause logging of an error and a return to block  so other charter actions are not ignored for an unprivileged parameter. Referring back to block , if it is determined there are no special terms in the parameter list remaining to process (or there were none), then block  evaluates each and every parameter expression to a corresponding value using well known processing for a stack based parser for expression evaluation (e.g. See well known compiler\/interpreter development techniques (e.g. \u201cAlgorithms+Data Structures=Programs\u201d by Nicklaus Wirth published by Prentice-Hall, Inc. 1976)). Block  implements the atomic operators using the WDR queue , most recent WDR for this MS, LBX history , or other suitable MS data. Any Invocation is also invoked for resulting to Data or Value wherein a default is enforced upon no returned data. Invocation parameters that had special terms would have been updated at block  to eliminate special terms prior to invocation. Block  ensures each parameter is in a ready to use form to be processed with the command and operand. Each parameter results in embodiments of a data value, a data value resulting from an expression, a data reference (e.g. pointer), or other embodiments well known in the art of passing parameters (arguments) to a function, procedure, or script for processing. In an alternate embodiment, stack processing of block  evaluates all special terms when required so that expressions may result in being evaluated to a special term which subsequently gets resolved. In this alternate embodiment, block  would incorporate privilege validation of blocks  and  as well as special term elaboration\/replacement of blocks ,  and ; and block  can recognize a special indicator, or syntax, for specifying to reduce an expression to a type of special term. Thereafter, if block  determines the REMOTE variable is set to No (i.e. \u201cNo\u201d equals a value distinguishable from any Host specification for having the meaning of \u201cNo Host Specification\u201d), then processing continues to block  where the ExecuteAction procedure of  is invoked with the command, operand and parameters of the action in process. Upon return from the procedure of , processing continues back to block  for any remaining charter actions. If block  determines the REMOTE variable is set to a Host for running the action, then processing continues to block  for preparing send data procedure parameters for performing a remote action (of the command, operand and parameters), and then invoking at block  the send data procedure of  for performing the action at the remote MS (also see ). Processing then continues back to block . An alternate embodiment will loop on multiple BNF grammar Host specifications for multiple invocations of the send data procedure (i.e. when multiple Host specifications are supported). Another embodiment to  processing permits multiple actions with a single Host specification.","Referring back to block , if it is determined all current charter actions are processed, then processing continues to block  for any next charter to process. Referring back to block , if it is determined all charters have been processed, processing terminates at block .","Depending on various embodiments, there may be obvious error handling in  charter parsing. Preferably, the charters were reasonably validated prior to being configured and\/or previously processed\/parsed (e.g.  processing). AppTerm specifications are to cause obvious error handling processing for searching fields for determining the matching PRR. If there is no match in any PRR, the AppTerm specification is invalid. WDRTerm and atomic term specifications are to cause obvious error handling processing for being able to resolve the field reference.","TimeSpec and\/or MSRelevance information may be used in  so that charter part processing occurs only in one place (i.e.  rather than ) to achieve better MS performance by preventing more than one scan over charter data. Some embodiments of  may be the single place where charters are eliminated based on privileges, TimeSpecs, MSRelevance, or any other criteria discussed with  for charter elimination to improve performance (i.e. a single charter parse when needed). Third party MSs (i.e. those that are not represented by the in-process WDR and the MS of  processing) can be affected by charter actions (e.g. via Host specification, privileged action, privileged feature, etc). Processing of special terms at blocks  and\/or  can include concatenating of data, formatting of data, or any other term of a reasonable expression. Blocks  and\/or  may include stack processing of blocks  and\/or  for proper special term determination (e.g. expressions which evaluate to a special term). See discussions above (e.g. , Invocation, Parameters, etc).","Preferably, statistics are maintained throughout  processing for how charters were processed, which charters became effective, why they became effective, which commands were processed (e.g. invocation of ), etc.","With reference now to , depicted is a flowchart for describing a preferred embodiment of a procedure for sending data to a remote MS, for example to perform a remote action as invoked from block .  is preferably of linkable PIP code . The purpose is for the MS of  processing (e.g. a first, or sending, MS) to transmit data to other MSs (e.g. at least a second, or receiving, MS), for example an action (command, operand, and any parameter(s)), or specific processing for a particular command (e.g. Send atomic command). Multiple channels for sending, or broadcasting should be isolated to modular send processing (feeding from a queue ). In an alternative embodiment having multiple transmission channels visible to processing of  (e.g. block ), there can be intelligence to drive each channel for broadcasting on multiple channels, either by multiple send threads for  processing,  loop processing on a channel list, and\/or passing channel information to send processing feeding from queue . If  does not transmit directly over the channel(s) (i.e. relies on send processing feeding from queue ), an embodiment may provide means for communicating the channel for broadcast\/send processing when interfacing to queue  (e.g. incorporate a channel qualifier field with send packet inserted to queue ).","In any case, see detailed explanations of , as well as long range exemplifications shown in , respectively. Processing begins at block , continues to block  where the caller parameter(s) passed to  processing (e.g. action for remote execution, or command for remote execution) are used for sending at least one data packet containing properly formatted data for sending, and for being properly received and interpreted. Block  may reformat parameters into a suitable data packet(s) format so the receiving MS can process appropriately (see ). Depending on the present disclosure embodiment, any reasonable supported identity (ID\/IDType) is a valid target (e.g. as derived from a recipient or system parameter). Thereafter, block  waits for an acknowledgement from the receiving MS if the communication embodiment in use utilizes that methodology. In one embodiment, the send data packet is an unreliable datagram(s) that will most likely be received by the target MS. In another embodiment, the send data packet(s) is reliably transported data which requires a final acknowledgement that it was received in good order. In any case, block  continues to block .","Block  formats the data for sending in accordance with the specified delivery method, along with necessary packet information (e.g. source identity, wrapper data, etc), and sends data appropriately. For a broadcast send, block  broadcasts the information (using a send interface like interface ) by inserting to queue  so that send processing broadcasts data  (e.g. on all available communications interface(s) ), for example as far as radius , and processing continues to block . The broadcast is for reception by data processing systems (e.g. MSs) in the vicinity of , as further explained by  which includes potentially any distance. The targeted MS should recognize that the data is meant for it and receives it. For a targeted send, block  formats the data intended for recognition by the receiving target. In an embodiment wherein usual MS communications data  of the MS is altered to contain CK  for listening MSs in the vicinity, send processing feeding from queue , caused by block  processing, will place information as CK  embedded in usual data  at the next opportune time of sending usual data . As the MS conducts its normal communications, transmitted data  contains new data CK  to be ignored by receiving MS other character  processing, but to be found by listening MSs within the vicinity which anticipate presence of CK . Otherwise, when LN-Expanse deployments have not introduced CK  to usual data  communicated on a receivable signal by MSs in the vicinity,  sends\/broadcasts new data .","Block  waits for a synchronous acknowledgement if applicable to the send of block  until either receiving one or timing out. Block  will not wait if no ack\/response is anticipated, in which case block  sets status for block  to \u201cgot it\u201d. If a broadcast was made, one (1) acknowledgement may be all that is necessary for validation, or all anticipated targets can be accounted for before deeming a successful ack. Thereafter, if block  determines an applicable ack\/response was received (i.e. data successfully sent\/received), or none was anticipated (i.e. assume got it), then processing continues to block  for potentially processing the response. Block  will process the response if it was anticipated for being received as determined by data sent at block . Thereafter, block  performs logging for success (e.g. to LBX History ). If block  determines an anticipated ack was not received, then block  logs the attempt (e.g. to LBX history ). An alternate embodiment to block  will log an error and may require a user action to continue processing so a user is confirmed to have seen the error. Both blocks  and  continue to block  where the caller (invoker) is returned to for continued processing (e.g. back to block ).","With reference now to , depicted is a flowchart for describing a preferred embodiment of processing for receiving execution data from another MS, for example action data for execution, or processing of a particular atomic command for execution.  processing describes a Receive Execution Data (RxED) process worker thread, and is of PIP code . There may be many worker threads for the RxED process, just as described for a xx process. The receive execution data (RxED) process is to fit identically into the framework of architecture  as other xx processes, with specific similarity to process  in that there is data received from receive queue , the RxED thread(s) stay blocked on the receive queue until data is received, and a RxED worker thread sends data as described (e.g. using send queue ). Blocks  through , blocks  through  (and applicable invocation of ), block , block , blocks  through , , , and any other applicable architecture  process\/thread framework processing is to adapt for the new RxED process. For example, the RxED process is initialized as part of the enumerated set at blocks  (e.g. preferably next to last member of set) and  (e.g. preferably second member of set) for similar architecture  processing. Receive processing identifies targeted\/broadcasted data destined for the MS of  processing. An appropriate data format is used, for example using X.409 encoding of  for some subset of data packet(s) received wherein RxED thread(s) purpose is for the MS of  processing to respond to incoming data. It is recommended that validity criteria set at block  for RxED-Max be set as high as possible (e.g. 10) relative performance considerations of architecture , to service multiple data receptions simultaneously. Multiple channels for receiving data fed to queue  are preferably isolated to modular receive processing.","In an alternative embodiment having multiple receiving transmission channels visible to the RxED process, there can be a RxED worker thread per channel to handle receiving on multiple channels simultaneously. If RxED thread(s) do not receive directly from the channel, the preferred embodiment of  would not need to convey channel information to RxED thread(s) waiting on queue  anyway. Embodiments could allow specification\/configuration of many RxED thread(s) per channel.","A RxED thread processing begins at block , continues to block  where the process worker thread count RxED-Ct is accessed and incremented by 1 (using appropriate semaphore access (e.g. RxED-Sem)), and continues to block  for retrieving from queue  sent data (using interface like interface ), perhaps a special termination request entry, and only continues to block  when a record of data (e.g. action for remote execution, particular atomic command, or termination record) is retrieved. In one embodiment, receive processing deposits data as record(s) to queue . In another embodiment, XML is received and deposited to queue , or some other suitable syntax is received as derived from the BNF grammar. In another embodiment, receive processing receives data in one format and deposits a more suitable format for  processing.","Block  stays blocked on retrieving from queue  until data is retrieved, in which case processing continues to block . If block  determines a special entry indicating to terminate was not found in queue , processing continues to block . There are various embodiments for RxED thread(s), RxCD thread(s), thread(s)  and thread(s)  to feed off a queue  for different record types, for example, separate queues A, B, C and D, or a thread target field with different record types found at queue  (e.g. like field ). In another embodiment, there are separate queues D and E for separate processing of incoming remote action and send command data. In another embodiment, thread(s)  are modified with logic of RxED thread(s) to handle remote actions and send command data requests, since thread(s)  are listening for queue  data anyway. In yet another embodiment, there are distinct threads and\/or distinct queues for processing each kind of an atomic command to  processing (i.e. as processed by blocks  through ).","Block  validates incoming data for this targeted MS before continuing to block . A preferred embodiment of receive processing already validated the data is intended for this MS by having listened specifically for the data, or by having already validated it is at the intended MS destination (e.g. block  can continue directly to block  (no block  and block  required)). If block  determines the data is valid for processing, then block  checks the data for its purpose (remote action or particular command). If block  determines the data received is for processing a remote action, then block  accesses source information, the command, the operand, and parameters from the data received. Thereafter, block  accesses privileges for each of the remote action parts (command, operand, parameters) to ensure the source has proper privileges for running the action at the MS of  processing. Depending on embodiments, block  may include evaluating the action for elaborating special terms and\/or expressions as described for  (blocks  through ), although the preferred embodiment preferably already did that prior to transmitting the remote action for execution (e.g. remote action already underwent detailed privilege assessment). However, in some embodiments where privileges are only maintained locally, the action processing of  processing would be required at block  to check privileges where appropriate in processing the action. In such embodiments,  would process local actions as disclosed, but would not process actions known to be for remote execution (i.e. Host specification) since a  embodiment would include  processing for performing privilege check processing to determine that sufficient privileges are granted. Thus, depending on the present disclosure embodiment, block  may include little privilege verification, no privilege verification, or may include all applicable action privilege verification discussed already in .","In yet another embodiment, special terms processing of  can be delayed until  processing (e.g. block  continues to a new block  which continues to block ). It may be advantageous to have new block  elaborate\/evaluate special terms at the MS of  processing in some embodiments. In a further embodiment, a syntax or qualifier can be used to differentiate where to perform special term elaboration\/evaluation.","Thereafter, if block  determines the action for execution is acceptable (and perhaps privileged, or privileged per source, or there was no check necessary), then block  invokes the execute action procedure of  with the action (command, operand, and any parameter(s)), completes at block  an acknowledgement to the originating MS of the data received at block , and block  sends\/broadcasts the acknowledgement (ack), before continuing back to block  for the next incoming execution request data. Block  sends\/broadcasts the ack (using a send interface like interface ) by inserting to queue  so that send processing transmits data , for example as far as radius . Embodiments will use the different correlation methods already discussed above, to associate an ack with a send.","If block  determines the data is not acceptable\/privileged, then processing continues directly back to block . For security reasons, it is best not to respond with an error. It is best to ignore the data entirely. In another embodiment, an error may be returned to the sender for appropriate error processing and reporting.","Referring back to block , if it is determined that the execution data is for processing a particular atomic command, then processing continues to block . Block  accesses the command (e.g. send), the operand, and parameters from the data received. Thereafter, block  accesses privileges for each of the parts (command, operand, parameters) to ensure the source has proper privileges for running the atomic command at the MS of  processing. Depending on embodiments, block  may include evaluating the command for elaborating special terms and\/or expressions as described for  (blocks  through ), although the preferred embodiment preferably already did that prior to transmitting the command for execution. However, in some embodiments where privileges are only maintained locally, the privilege processing of  would be required at block  to check privileges where appropriate in processing the command. In such embodiments,  would process local actions as disclosed, but would not process actions known to be for remote execution (i.e. Host specification) since a  embodiment would include  processing for performing privilege check processing to determine that sufficient privileges are granted. Thus, depending on the present disclosure embodiment, block  may include little privilege verification, no privilege verification, or may include all applicable action privilege verification discussed already in .","In yet another embodiment, special terms processing of  can be delayed until  processing (e.g. block  continues to a new block  which continues to block ). It may be advantageous to have new block  elaborate\/evaluate special terms at the MS of  processing in some embodiments. In a further embodiment, a syntax or qualifier can be used to differentiate where to perform special term elaboration\/evaluation.","Thereafter, if block  determines the command (Command, Operand, Parameters) for execution is acceptable (and perhaps privileged, or privileged per source, or there was no check necessary), then block  performs the command locally at the MS of  processing. Thereafter, block  checks if a response is needed as a result of command (e.g. Find command) processing at block . If block  determines a response is to be sent back to the originating MS,  completes a response to the originating MS of the data received at block , and block  sends\/broadcasts the response, before continuing back to block  for the next incoming execution request data. Block  sends\/broadcasts the response containing appropriate command results (using a send interface like interface ) by inserting to queue  so that send processing transmits data , for example as far as radius . Embodiments will use the different correlation methods already discussed above, to associate a response with a send.","If block  determines a response is not to be sent back to the originating MS, then processing continues directly back to block . If block  determines the data is not acceptable\/privileged, then processing continues back to block . For security reasons, it is best not to respond with an error. It is best to ignore inappropriate (e.g. unprivileged, unwarranted) data entirely. In another embodiment, an error may be returned to the sender for appropriate error processing and reporting.","Blocks  through  are presented generically so that specific atomic command descriptions below provide appropriate interpretation and processing. The actual implementation may replace blocks  through  with programming case statement conditional execution for each atomic command supported.","Referring back to block , if it is determined that the data is not valid for the MS of  processing, processing continues back to block . Referring back to block , if a worker thread termination request was found at queue , then block  decrements the RxED worker thread count by 1 (using appropriate semaphore access (e.g. RxED-Sem)), and RxED thread processing terminates at block . Block  may also check the RxED-Ct value, and signal the RxED process parent thread that all worker threads are terminated when RxED-Ct equals zero (0).","Block  causes sending\/broadcasting data  containing CK , depending on the type of MS, wherein CK  contains ack\/response information prepared. In the embodiment wherein usual MS communications data  of the MS is altered to contain CK  for listening MSs in the vicinity, send processing feeding from queue , caused by block  processing, will place ack\/response information as CK  embedded in usual data  at the next opportune time of sending usual data . As the MS conducts its normal communications, transmitted data  contains new data CK  to be ignored by receiving MS other character  processing, but to be found by listening MSs within the vicinity which anticipate presence of CK . Otherwise, when LN-Expanse deployments have not introduced CK  to usual data  communicated on a receivable signal by MSs in the vicinity,  sends\/broadcasts new ack\/response data .","In an alternate embodiment, remote action and\/or atomic command data records contain a sent date\/time stamp field of when the data was sent by a remote MS, and a received date\/time stamp field (like field ) is processed at the MS in  processing. This would enable calculating a TDOA measurement while receiving data (e.g. actions or atomic command) that can then be used for location determination processing as described above.","For other acceptable receive processing, methods are well known to those skilled in the art for \u201chooking\u201d customized processing into application processing of sought data received, just as discussed with  above (e.g. mail application, callback function API, etc). Thus, there are well known methods for processing data in context of this disclosure for receiving remote actions and\/or atomic command data from an originating MS to a receiving MS, for example when using email. Similarly, as described above, SMS messages can be used to communicate data, albeit at smaller data exchange sizes. The sending MS may break up larger portions of data which can be sent as parse-able text to the receiving MS. It may take multiple SMS messages to communicate the data in its entirety.","Regardless of the type of receiving application, those skilled in the art recognize many clever methods for receiving data in context of a MS application which communicates in a peer to peer fashion with another MS (e.g. callback function(s), API interfaces in an appropriate loop which can remain blocked until sought data is received for processing, polling known storage destinations of data received, or other applicable processing).  are an embodiment of MS to MS communications, referred to with the acronym MS2MS. Various MS2MS communication embodiments may include: reliable transport protocol involving a plurality of packets (sends and acknowledgements) between systems for a single send; unreliable transport protocol involving a plurality of packets (sends and acknowledgements) between systems for a single send; or on-going communications processing which is subsequent to an initiation send of data between systems (e.g. peer to peer application processing (e.g. MS peer to peer phone call after call initiation (i.e. no service involved))).",{"@attributes":{"id":"p-0994","num":"1648"},"figref":["FIG. 62","FIG. 62","FIG. 62"],"b":["6202","6204","6204","6206"]},"If it is determined at block  that the action atomic command is a send command, then processing continues to block  where the send command action procedure of  is invoked. The send command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the send command action procedure, block  continues to block . Block  returns to the calling block of processing (e.g. block ) that invoked  processing. If block  determines the action atomic command is not a send command, then processing continues to block . If it is determined at block  that the action atomic command is a notify command, then processing continues to block  where the notify command action procedure of  is invoked. The notify command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the notify command action procedure, block  continues to block . If block  determines the action atomic command is not a notify command, then processing continues to block . If it is determined at block  that the action atomic command is a compose command, then processing continues to block  where the compose command action procedure of  is invoked. The compose command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the compose command action procedure, block  continues to block . If block  determines the action atomic command is not a compose command, then processing continues to block . If it is determined at block  that the action atomic command is a connect command, then processing continues to block  where the connect command action procedure of  is invoked. The connect command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the connect command action procedure, block  continues to block . If block  determines the action atomic command is not a connect command, then processing continues to block . If it is determined at block  that the action atomic command is a find command, then processing continues to block  where the find command action procedure of  is invoked. The find command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the find command action procedure, block  continues to block . If block  determines the action atomic command is not a find command, then processing continues to block . If it is determined at block  that the action atomic command is an invoke command, then processing continues to block  where the invoke command action procedure of  is invoked. The invoke command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the invoke command action procedure, block  continues to block . If block  determines the action atomic command is not an invoke command, then processing continues to block . If it is determined at block  that the action atomic command is a copy command, then processing continues to block  where the copy command action procedure of  is invoked. The copy command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the copy command action procedure, block  continues to block . If block  determines the action atomic command is not a copy command, then processing continues to block . If it is determined at block  that the action atomic command is a discard command, then processing continues to block  where the discard command action procedure of  is invoked. The discard command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the discard command action procedure, block  continues to block . If block  determines the action atomic command is not a discard command, then processing continues to block . If it is determined at block  that the action atomic command is a move command, then processing continues to block  where the move command action procedure of  is invoked. The move command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the move command action procedure, block  continues to block . If block  determines the action atomic command is not a move command, then processing continues to block . If it is determined at block  that the action atomic command is a store command, then processing continues to block  where the store command action procedure of  is invoked. The store command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the store command action procedure, block  continues to block . If block  determines the action atomic command is not a store command, then processing continues to block . If it is determined at block  that the action atomic command is an administrate command, then processing continues to block  where the administrate command action procedure of  is invoked. The administrate command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the administrate command action procedure, block  continues to block . If block  determines the action atomic command is not an administrate command, then processing continues to block . If it is determined at block  that the action atomic command is a change command, then processing continues to block  where the change command action procedure of  is invoked. The change command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the change command action procedure, block  continues to block . If block  determines the action atomic command is not a change command, then processing continues to block  for handling other supported action atomic commands on the MS. There are many commands that can be implemented on a MS. Block  continues to block  for processing as already described.  describe action processing for recognized events to process WDRs.","In-process WDRs (e.g. inbound, outbound, in process for a particular reason, etc) provide processing paths for triggering charter processing. It may be desirable to additionally provide charter processing which is triggered by changes to particular AppTerm(s). For example, as a MS application changes a processing state (e.g. as in \u201cfinite state machine\u201d) for any reason, that processing state can be reflected in changing at least one AppTerm. When that AppTerm is changed, the change itself can cause related charter processing. This provides a more rich method for automatically processing conditions at a MS.","With reference back to , AppTerm trigger(s) field contains one or more AppTerm trigger records (or pointers\/join-to thereof), each record for causing automated charter processing based on a change in the AppTerm. In some embodiments, field provides a joining identifier to another table for joining a plurality of rows containing trigger records associated to the record . An AppTerm trigger record contains:\n\n","AppTerm trigger specifications should be used carefully because the same charters configured for handling WDR processing events may be processed as though a WDR triggered the charter processing event. One preferred embodiment substitutes the most recent applicable WDR fields for referenced fields (_ref, _I_ref, _O_ref) in charter expressions. Another embodiment ignores all charters with expressions which reference an in-process (_ref, _I_ref, _O_ref) WDR field. In either embodiment, a user must consider if this is desirable, either by reviewing charters, reviewing permissions that provide charter processing to others, crafting new charters, or combinations thereof. Appropriate privileges (permission ) are provided for governing every aspect of AppTerm trigger processing and all permission descriptions heretofore do apply.","AppTerm triggered charters are executed locally and permissible charter actions can be executed locally or remotely as already discussed, however another charter directive embodiment may be used. One embodiment of a charter directive includes a specification of \u201cMS_ID, MS_ID, . . . , MS_ID\u201d such that \u201cn\u201d is the number of MSs for where to process charters wherein potential execution-hosting MSs include the local MS and any number of privilege providing remote MSs. The local MS_ID can alternatively be specified with a keyword \u201cTHISMS\u201d. The charter directive will cause charters to be processed as though an in-process WDR was received at each specified MS. An optional directive qualifier of \u201cI\u201d, \u201cO\u201d, \u201cAPP\u201d, \u201c<name>\u201d, or \u201cCB\u201d may also be specified with similar processing at the particular MS(s). Remote processing is already described in detail.","When the APP directive qualifier \u201cAPP\u201d is used, a charter section identified with the associated prefix field is processed. This charter section is only processed for AppTerm trigger specifications, and never processed for in-process WDRs. Consequently, references are not made to in-process WDR fields (i.e. _ref, _I_ref, _O_ref), however any other BNF grammar charter expression specification may be made (e.g. atomic term WDR reference (i.e. \\ref)). In an alternate embodiment, references are supported to an in-process WDR for the fields of the most recent in-process WDR which applies. When the APP directive qualifier \u201c<name>\u201d is used, a charter section identified with the associated explicit <name> is processed. This charter section is only processed for AppTerm trigger specifications, and never processed for in-process WDRs. Consequently, references are not made to in-process WDR fields (i.e. _ref, _I_ref, _O_ref), however any other BNF grammar charter expression specification may be made (e.g. atomic term WDR reference (i.e. \\ref)). Similarly, in an alternate embodiment, references are supported to an in-process WDR for the fields of the most recent in-process WDR which applies. The \u201cAPP\u201d specification provides a charter section for processing all AppTerm variables for a PRR. The \u201c<name>\u201d specification provides a special named charter section for processing specific AppTerm variables of a PRR. Charter embodiments and processing thereof heretofore described also applies for AppTerm trigger processing charters, albeit with embodiment modifications made in light of discussions (e.g. new charter type field (e.g. main, AppTerm, named (an actual name in the field other than indicator for main and AppTerm)). Below is a syntactical example to facilitate understanding. Note the use of scoped (i.e. curly braced) sections which are referenced. These sections are not executed by in-process WDR charter processing.",{"@attributes":{"id":"p-1001","num":"1658"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Charters {"},{"entry":"..."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"B_ {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"..."]},{"entry":[{},"(\u201charrow\u201d {circumflex over (\u2009)} B_srchSubj):"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Notify Weblink"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u201chttp:\/\/www.dfwfarms.com\/harrows.xls\u201d,,,target=\u201c_blank\u201d;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"..."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"};"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"..."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"doitHere {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"..."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"( ):","Invoke App alertme.cmd (\\thisAppTerm);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"..."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"};"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"..."},{"entry":"}"},{"entry":"(\u201charrow\u201d {circumflex over (\u2009)} B_srchSubj):"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Notify Weblink \u201chttp:\/\/www.dfwfarms.com\/harrows.xls\u201d,,,target=\u201c_blank\u201d;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["5300","5300"],"i":["a ","a "],"ul":{"@attributes":{"id":"ul0114","list-style":"none"},"li":"( ): Invoke App alertme.cmd \\thisAppTerm;\n\nAn AppTerm named section \u201cdoitHere\u201d is specified wherein charters are executed whenever an AppTerm referencing the named section is modified, or when the optional AppTerm condition specified results to true. Here is a valid null charter expression for unconditionally executing the atomic invoke command action. A new atomic term \\thisAppTerm is introduced which is valid only within the context of AppTerm charter sections. The \\thisAppTerm atomic term evaluated to the AppTerm variable name which caused execution of the AppTerm charter section. So, if an entered change to the srchSubj AppTerm was made in the browser application, and the AppTerm trigger specification used a named \u201cdoitHere\u201d charter directive, then the same AppTerm example above which caused the \u201cB_\u201d section to execute would additionally cause the \u201cdoitHere\u201d section to be processed. The alertme.cmd file would be invoked with \u201cB_srchSubj\u201d as a parameter.\n"}},"This example shows that the \u201cAPP\u201d section charter specifications can be a catch all for any applicable PRR AppTerm for that application. Named sections enable singling out certain AppTerm processing for unique charter processing. In a preferred embodiment, a specified \u201cAPP\u201d section redundantly handles named section processing for the same AppTerm in a PRR . Charters are configured accordingly. In an alternate embodiment, a named section overrides an \u201cAPP\u201d section for AppTerm trigger charter processing so that only one charter section is processed for an AppTerm meeting criteria of either section.","When the callback directive qualifier \u201cCB\u201d is used, the applicable executable interface is invoked for processing with parameters that may be specified. Any expressions, terms, variables, etc supported in AppTerm conditions are also supported as parameters to the callback interface. The interface may be a well known name to a linked executable or a name which is dynamically linked as needed. Any processing may occur within the callback interface.","In another embodiment, AppTerm trigger sections may be executed at remote MSs based on consistent referenced AppTerm trigger sections across a plurality of MSs. Applicable permissions govern the ability to perform remote AppTerm trigger charter processing. In another embodiment, fields and may define assignable permissions which are only relevant within the context of a particular application. When two or more MSs have the same application, privileges are granted as heretofore described because the privileges can be universally known. Another embodiment supports defining new privileges via a PRR field as long as codes used do not intersect with a universal privilege code. These new privileges can then be configured by cooperating users at interoperating MSs for desired permissible functionality using permission embodiments heretofore described. Yet another embodiment supports broadcasting new PRR privileges defined to willing (or privilege providing) MSs for making other users aware of their use. Such new privileges can be explicitly assigned to charter processing so that privilege semantics need not be incorporated in MS processing logic. For example:\n\n","With reference now to , the additional AppTerm trigger records and fields of the PRR are appropriately handled in , and  includes AppTerm trigger processing. Block  additionally accesses AppTerm trigger information of the application's associated PRR. Thereafter, if block  determines the PRR exists and at least one of the data item(s) for modification are described by field , block  updates the applicable data item(s) described by field appropriately as requested by the application invoking  processing. Thereafter, a block  checks if the PRR contains an AppTerm trigger for any of the AppTerm variables of field which have been updated. If block  determines one or more AppTerm triggers are applicable, then a block  processes applicable AppTerm charter sections and\/or callback interfaces for each AppTerm that was updated which has an associated trigger defined as described above. Processing continues from block  to block . If block  determines there is no AppTerm trigger configured for the AppTerm modified, then processing continues to block . Block  ensures applicable AppTerm charter sections are processed as described above. In an alternate embodiment, the semaphore resource is released as soon as possible to prevent preempting critical MS processing, for example by spawning an asynchronous charter processing thread for FIFO processing at block  so block  can be performed immediately. There are a various synchronization schemes that can be deployed for desired multi-threaded charter processing. AppTerm accesses in processed charters may use the same semaphore lock control used in , or as described in fields which may alternatively be used by  processing.","There are many AppTerm trigger examples for unique charter processing. An AppTerm variable can be set with a value, and subsequently cause the event for automated charter execution. The charter can access the AppTerm variable along with other data discussed for novel conditions and associated action processing, for example:\n\n",{"@attributes":{"id":"p-1007","num":"1674"},"figref":["FIGS. 63A through 74C","FIGS. 63A through 74C"]},"Together with processing disclosed above, provided is a user friendly development platform for quickly building LBX applications wherein the platform enables conveniently enabled LBX application interoperability and processing, including synchronized processing, across a plurality of MSs. Some commands involve a plurality of MSs and\/or data processing systems. Others don't explicitly support a plurality of MSs and data processing systems, however that is easily accomplished for every command since a single charter expression can cause a plurality of actions anyway. For example, if a command does not support a plurality of MSs in a single command action, the plurality of MSs is supported with that command through specifying a plurality of identical command actions in the charter configuration for each desired MS. Actions provided in this LBX release enable a rich set of LBX features and functionality for:\n\n","Syntax and reasonable validation should be performed at the time of configuration, although it is preferable to check for errors at run time of actions as well. Various embodiments may or may not validate at configuration time, and may or may not validate at action processing time. Validation should be performed at least once to prevent run time errors from occurring. Obvious error handling is assumed present when processing commands, such error handling preferably including the logging of the error to LBX History  and\/or notifying the user of the error with, or without, request for the user to acknowledge the reporting of error.",{"@attributes":{"id":"p-1010","num":"1684"},"figref":"FIGS. 63A through 74C","b":["63","63","63","1","63","7","63"],"ul":{"@attributes":{"id":"ul0120","list-style":"none"},"li":{"@attributes":{"id":"ul0120-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0121","list-style":"none"},"li":["#A=describes preferred embodiment of command action processing;","#B=describes LBX command processing for some operands; and","#C=describes one embodiment of command action processing.\n\nSome of the #A figures highlight diversity for showing different methods of command processing while highlighting that some of the methods are interchangeable for commands (e.g. Copy and Discard processing). Also the terminology \u201capplication\u201d and \u201cexecutable\u201d are used interchangeably to represent an entity of processing which can be started, terminated, and have processing results. Applications (i.e. executables) can be started as a contextual launch, custom launch through an API or command line, or other launch method of an executable for processing.\n"]}}}},"Atomic command descriptions are to be interpreted in the broadest sense, and some guidelines when reading the descriptions include:\n\n","The reader should cross reference\/compare operand descriptions in the #B matrices for each command to appreciate full exploitation of the Operand, options, and intended embodiments since descriptions assume information found in other commands is relevant across commands. Some operand description information may have been omitted from a command matrix to prevent obvious duplication of information already described for the same operand in another command.",{"@attributes":{"id":"p-1013","num":"1694"},"figref":"FIG. 63A","ul":{"@attributes":{"id":"ul0124","list-style":"none"},"li":{"@attributes":{"id":"ul0124-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0125","list-style":"none"},"li":["1) Using email or similar messaging layer as a transport layer;","2) Using a MS to MS communications (MS2MS) of ; or","3) Processing the send command locally.\n\nIn various embodiments, any of the send command Operands can be implemented with either one of the methodologies, although there may be a preference of which methodology is used for which Operand. Atomic send command processing begins at block , continues to block  for accessing parameters of send command \u201cOperand\u201d (BNF Grammar Operand) and \u201cParameters\u201d (BNF Grammar Parameters), and then to block  for checking which \u201cOperand\u201d was passed. If block  determines the \u201cOperand\u201d indicates to use email as the mechanism for performing the send command, then block  checks if a sender parameter was specified. If block  determines a sender was specified, processing continues to block , otherwise block  defaults one (e.g. valid email address for this MS) and then processing continues to block . Block  checks if a subject parameter was specified. If block  determines a subject was specified, processing continues to block , otherwise block  defaults one (e.g. subject line may be used to indicate to email receive processing that this is a special email for performing atomic command (e.g. send command) processing), and then processing continues to block . Block  may specify a null email subject line. Block  checks if an attributes parameter was specified. If block  determines attributes were specified, processing continues to block , otherwise block  defaults attributes (e.g. confirmation of delivery, high priority, any email Document Interchange Architecture (DIA) attributes or profile specifications, etc) and then processing continues to block . The terminology \u201cattributes\u201d, for example as associated to an electronic distribution (e.g. email, SMS message, etc) refers to DIA attributes or other descriptive data associated to the distribution. Block  may use email attributes to indicate that this is a special email for send command processing while using the underlying email transport to handle the delivery of information. Block  checks if at least one recipient parameter was specified. If block  determines at least one recipient was specified, processing continues to block , otherwise block  defaults one (e.g. valid email address for this MS) and then processing continues to block . Block  may specify a null recipient list so as to cause an error in later processing (detected at block ).\n"]}}}},"Block  validates \u201cParameters\u201d, some of which may have been defaulted in previous blocks (, ,  and ), and continues to block . If bock  determines there is an error in \u201cParameters\u201d, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to the caller (invoker) at block . If block  determines that \u201cParameters\u201d are in good order for using the email transport, then block  updates an email object in context for the send command \u201cOperand\u201d and \u201cParameters\u201d, block  uses a send email interface to send the email, and block  returns to the caller (e.g. block ). Block  can use the attributes parameter to affect how \u201cParameters\u201d is to be interpreted. The attributes parameter may be modified, and can be used by any processes which receive the sent distribution. Those skilled in the art know well known email send interfaces (e.g. APIs) depending on a software development environment. The email interface used at block  will be one suitable for the underlying operating system and available development environments, for example, a standardized SMTP interface. In a C# environment, an SMTP email interface example is:",{"@attributes":{"id":"p-1015","num":"1699"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"..."},{"entry":"SmtpClient smtpCl = new SmtpClient(SMTP_SERVER_NAME);"},{"entry":"..."},{"entry":"smtpCl.UseDefaultCredentials = true;"},{"entry":"..."},{"entry":"MailMessage objMsg;"},{"entry":"..."},{"entry":"objMsg = new MailMessage(fromAddr, toAddr, subjLn, emailBod);"},{"entry":"..."},{"entry":"smtpCl.Send(objMsg);"},{"entry":"objMsg.Dispose( );"},{"entry":"..."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Those skilled in the art recognize other interfaces of similar messaging capability for carrying out the transport of an action (e.g. Send command). Email is a preferred embodiment. While there are Send command embodiments that make using an existing transport layer (e.g. email) more suitable than not, even the most customized Send command Operands can use email (instead of MS2MS) by implementing one or more recognizable signature(s), indication(s), or the like, of\/in the email distribution to be used for informing a receiving email system to treat the email uniquely for carrying out the present disclosure. Depending on the embodiment, integrated processing code is maintained\/built as part of the email system, or processing code is \u201cplugged\u201d (\u201chooked\u201d) into an existing email system in an isolated third party manner. Regardless, the email system receiving the present disclosure email will identify the email as being one for special processing. Then, email contents is parsed out and processed according to what has been requested.","In embodiments where Send command Operands are more attractively implemented using an existing transport layer (e.g. email), those send commands can also be sent with MS2MS encoded in data packet(s) that are appropriate for processing.","Referring back to block , if it is determined that the \u201cOperand\u201d indicates to not use an email transport (e.g. use a MS2MS transport for performing the send command, or send command is to be processed locally), then block  checks if a sender parameter was specified. If block  determines a sender was specified, processing continues to block , otherwise block  defaults one (e.g. valid MS ID) and then processing continues to block . Block  checks if a subject message parameter was specified. If block  determines a subject message was specified, processing continues to block , otherwise block  defaults one, and then processing continues to block . Block  may specify a null message. Block  checks if an attributes parameter was specified. If block  determines attributes were specified, processing continues to block , otherwise block  defaults attributes (e.g. confirmation of delivery, high priority, etc) and then processing continues to block . Block  checks if at least one recipient parameter was specified. If block  determines at least one recipient was specified, processing continues to block , otherwise block  defaults one (e.g. valid ID for this MS) and then processing continues to block . Block  may specify a null recipient list so as to cause an error in later processing (detected at block ).","Block  validates \u201cParameters\u201d, some of which may have been defaulted in previous blocks (, ,  and ), and continues to block . If bock  determines there is an error in \u201cParameters\u201d, then block  handles the error appropriately (e.g. log error to LBX History and\/or notify user) and processing returns to the caller (invoker) at block . If block  determines that \u201cParameters\u201d are in good order, then block  updates a data object in context for the send command \u201cOperand\u201d and \u201cParameters\u201d, and block  begins a loop for delivering the data object to each recipient. Block  gets the next (or first) recipient from the recipient list and processing continues to block .","If block  determines that all recipients have been processed, then processing returns to the caller at block , otherwise block  checks the recipient to see if it matches the ID of the MS of  processing (i.e. this MS). If block  determines the recipient matches this MS, then block  (see  discussions) performs the atomic send command locally and processing continues back to block  for the next recipient. If block  determines the recipient is an other MS, block  prepares parameters for  processing, and block  invokes the procedure of  for sending the data (send command, operand and parameters) to the other MS. Processing then continues back to block  for the next recipient. Blocks , , and  can use the attributes parameter to affect how \u201cParameters\u201d is to be interpreted. The attributes parameter may be modified, and can be used by any processes which receive the send result.","MS2MS processing is as already described above (see ), except  performs sending data for the send command to a remote MS, and  blocks  through  carry out processing specifically for the send command. Block  processes the send command locally (like block \u2014see ).","In , \u201cParameters\u201d for the atomic send command in accordance with the \u201cOperand\u201d were shown to be validated for being properly privileged prior to  processing (by  processing). However, an alternate embodiment could move some or all applicable privilege validation to  in context of where the \u201cParameters\u201d are processed. Also, some embodiments may not validate \u201cParameters\u201d since they (or some reasonable subset thereof) can be understood to be in good order by the time  processing occurs (e.g. no blocks  through  and\/or  through  required). In yet another embodiment, no defaulting or some defaulting of parameters is implemented. In some embodiments, any subset of send commands will utilize email distributions for processing between MSs. In other embodiments, any subset of send commands will utilize  for processing between MSs. Operations of the send command can be carried out regardless of the transport that is actually used to perform the send command.",{"@attributes":{"id":"p-1023","num":"1707"},"figref":["FIGS. 63B-1","FIG. 34D"],"b":["63","7","6366","7584"],"ul":{"@attributes":{"id":"ul0126","list-style":"none"},"li":["E=Email transport preferably used (blocks  through );","O=Other processing (MS2MS or local) used (blocks  through ).\n\nAny of the Send command operand combinations can be carried out with either of the methodologies. The second column shows a preferred methodology (PM). The third column describes processing which is placed into flowchart embodiments. There are many embodiments derived from the Send processing descriptions without departing from the spirit and scope of the disclosure. Descriptions are self explanatory.\n"]}},"With reference back to , note that the column of information headed by \u201c101\u201d represents the parameters applicable for the Send command. The Send command has the following parameters, all of which are interpreted in context of the Operand:\n\n",{"@attributes":{"id":"p-1025","num":"1716"},"figref":["FIG. 63C","FIG. 63A","FIG. 63A","FIG. 63C"],"b":["04","54"]},{"@attributes":{"id":"p-1026","num":"1717"},"figref":"FIG. 64A","ul":{"@attributes":{"id":"ul0128","list-style":"none"},"li":{"@attributes":{"id":"ul0128-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0129","list-style":"none"},"li":["1) Using email or similar messaging layer as a transport layer;","2) Using a MS to MS communications (MS2MS) of ; or","3) Processing the notify command locally.\n\nIn various embodiments, any of the notify command Operands can be implemented with either one of the methodologies, although there may be a preference of which methodology is used for which Operand. Atomic notify command processing begins at block , continues to block  for accessing parameters of notify command \u201cOperand\u201d (BNF Grammar Operand) and \u201cParameters\u201d (BNF Grammar Parameters), and then to block  for checking which \u201cOperand\u201d was passed. If block  determines the \u201cOperand\u201d indicates to use email as the mechanism for performing the notify command, then block  checks if a sender parameter was specified. If block  determines a sender was specified, processing continues to block , otherwise block  defaults one (e.g. valid email address for this MS) and then processing continues to block . Block  checks if a subject parameter was specified. If block  determines a subject was specified, processing continues to block , otherwise block  defaults one (e.g. subject line may be used to indicate to email receive processing that this is a special email for performing atomic command (e.g. notify command) processing), and then processing continues to block . Block  may specify a null email subject line. Block  checks if an attributes parameter was specified. If block  determines attributes were specified, processing continues to block , otherwise block  defaults attributes (e.g. confirmation of delivery, high priority, any email DIA attributes or profile specifications, etc) and then processing continues to block . Block  may use email attributes to indicate that this is a special email for notify command processing while using the underlying email transport to handle the delivery of information. Block  checks if at least one recipient parameter was specified. If block  determines at least one recipient was specified, processing continues to block , otherwise block  defaults one (e.g. valid email address for this MS) and then processing continues to block . Block  may specify a null recipient list so as to cause an error in later processing (detected at block ).\n"]}}}},"Block  validates \u201cParameters\u201d, some of which may have been defaulted in previous blocks (, ,  and ), and continues to block . If bock  determines there is an error in \u201cParameters\u201d, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to the caller (invoker) at block . If block  determines that \u201cParameters\u201d are in good order for using the email transport, then block  updates an email object in context for the notify command \u201cOperand\u201d and \u201cParameters\u201d, block  uses a send email interface to notify through email, and block  returns to the caller (e.g. block ). Block  can use the attributes parameter to affect how \u201cParameters\u201d is to be interpreted. The attributes parameter may be modified, and can be used by any processes which receive the notify. The email interface used at block  will be one suitable for the underlying operating system and available development environments, for example, a standardized SMTP interface, and other messaging capability, as described above for .","While there are Notify command embodiments that make using an existing transport layer (e.g. email) more suitable than not, even the most customized Notify command Operands can use email (instead of MS2MS) by implementing one or more recognizable signature(s), indication(s), or the like, of\/in the email distribution to be used for informing a receiving email system to treat the email uniquely for carrying out the present disclosure. Depending on the embodiment, integrated processing code is maintained\/built as part of the email system, or processing code is \u201cplugged\u201d (\u201chooked\u201d) into an existing email system in an isolated third party manner. Regardless, the email system receiving the present disclosure email will identify the email as being one for special processing. Then, email contents is parsed out and processed according to what has been requested.","In embodiments where Notify command Operands are more attractively implemented using an existing transport layer (e.g. email), those notify commands can also be sent with MS2MS encoded in data packet(s) that are appropriate for processing.","Referring back to block , if it is determined that the \u201cOperand\u201d indicates to not use an email transport (e.g. use a MS2MS transport for performing the notify command, or notify command is to be processed locally), then block  checks if a sender parameter was specified. If block  determines a sender was specified, processing continues to block , otherwise block  defaults one (e.g. valid MS ID) and then processing continues to block . Block  checks if a subject message parameter was specified. If block  determines a subject message was specified, processing continues to block , otherwise block  defaults one, and then processing continues to block . Block  may specify a null message. Block  checks if an attributes parameter was specified. If block  determines attributes were specified, processing continues to block , otherwise block  defaults attributes (e.g. confirmation of delivery, high priority, etc) and then processing continues to block . Block  checks if at least one recipient parameter was specified. If block  determines at least one recipient was specified, processing continues to block , otherwise block  defaults one (e.g. valid ID for this MS) and then processing continues to block . Block  may specify a null recipient list so as to cause an error in later processing (detected at block ).","Block  validates \u201cParameters\u201d, some of which may have been defaulted in previous blocks (, ,  and ), and continues to block . If bock  determines there is an error in \u201cParameters\u201d, then block  handles the error appropriately (e.g. log error to LBX History and\/or notify user) and processing returns to the caller (invoker) at block . If block  determines that \u201cParameters\u201d are in good order, then block  updates a data object in context for the notify command \u201cOperand\u201d and \u201cParameters\u201d, and block  begins a loop for delivering the data object to each recipient. Block  gets the next (or first) recipient from the recipient list and processing continues to block .","If block  determines that all recipients have been processed, then processing returns to the caller at block , otherwise block  checks the recipient to see if it matches the ID of the MS of  processing (i.e. this MS). If block  determines the recipient matches this MS, then block  (see  discussions) performs the atomic notify command locally and processing continues back to block  for the next recipient. If block  determines the recipient is an other MS, block  prepares parameters for  processing, and block  invokes the procedure of  for sending the data (notify command, operand and parameters) to the other MS. Processing then continues back to block  for the next recipient. Blocks , , and  can use the attributes parameter to affect how \u201cParameters\u201d is to be interpreted. The attributes parameter may be modified, and can be used by any processes which receive the notify result.","MS2MS processing is as already described above (see ), except  performs sending data for the notify command to a remote MS, and  blocks  through  carry out processing specifically for the notify command. Block  processes the notify command locally (like block \u2014see ).","In , \u201cParameters\u201d for the atomic notify command in accordance with the \u201cOperand\u201d were shown to be validated for being properly privileged prior to  processing (by  processing). However, an alternate embodiment could move some or all applicable privilege validation to  in context of where the \u201cParameters\u201d are processed. Also, some embodiments may not validate \u201cParameters\u201d since they (or some reasonable subset thereof) can be understood to be in good order by the time  processing occurs (e.g. no blocks  through  and\/or  through  required). In yet another embodiment, no defaulting or some defaulting of parameters is implemented. In some embodiments, any subset of notify commands will utilize email distributions for processing between MSs. In other embodiments, any subset of notify commands will utilize  for processing between MSs. Operations of the notify command can be carried out regardless of the transport that is actually used to perform the notify command.",{"@attributes":{"id":"p-1035","num":"1729"},"figref":["FIGS. 64B-1","FIG. 34D"],"b":["64","4","6466","7584"],"ul":{"@attributes":{"id":"ul0130","list-style":"none"},"li":["E=Email transport preferably used (blocks  through );","O=Other processing (MS2MS or local) used (blocks  through ).\n\nAny of the Notify command operand combinations can be carried out with either of the methodologies. The second column shows a preferred methodology (PM). The third column describes processing which is placed into flowchart embodiments. There are many embodiments derived from the Notify processing descriptions without departing from the spirit and scope of the disclosure. Descriptions are self explanatory.\n"]}},"With reference back to , note that the column of information headed by \u201c103\u201d represents the parameters applicable for the Notify command. The Notify command has the following parameters, all of which are interpreted in context of the Operand:\n\n",{"@attributes":{"id":"p-1037","num":"1738"},"figref":["FIG. 64C","FIG. 64A","FIG. 64A","FIG. 64C"],"b":["04","54"]},{"@attributes":{"id":"p-1038","num":"1739"},"figref":"FIG. 65A","ul":{"@attributes":{"id":"ul0132","list-style":"none"},"li":{"@attributes":{"id":"ul0132-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0133","list-style":"none"},"li":["1) Launching an application, executable, or program with a standard contextual object type interface;","2) Custom launching of an application, executable, or program; or","3) Processing the compose command through a MS operating system interface.\n\nIn various embodiments, any of the compose command Operands can be implemented with either one of the methodologies, although there may be a preference of which methodology is used for which Operand. Atomic compose command processing begins at block , continues to block  for accessing parameters of compose command \u201cOperand\u201d (BNF Grammar Operand) and \u201cParameters\u201d (BNF Grammar Parameters), and then to block  for checking which \u201cOperand\u201d was passed. If block  determines the \u201cOperand\u201d indicates to launch with a standard contextual object type interface, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to the caller (invoker) at block . If block  determines there were no parameter errors, then block  interfaces to the MS operating system for the particular object passed as a parameter. Block  may prepare parameters in preparation for the Operating System (O\/S) contextual launch, for example if parameters are passed to the application which is invoked for composing the object. Processing leaves block  and returns to the caller (invoker) at block .\n"]}}}},"An example of block  is similar to the Microsoft Windows XP (Microsoft and Windows XP are trademarks of Microsoft corp.) O\/S association of applications to file types for convenient application launch. For example, a user can double click a file (e.g. when viewing file system) from Window Explorer and the appropriate application will be launched for opening the file, assuming an application has been properly registered for the file type of the file opened. In a Windows graphical user interface scenario, registration of an application to the file type is achieved, for example, from the user interface with the \u201cFile Types\u201d tab of the \u201cFolder Options\u201d option of the \u201cFile Types\u201d pulldown of the Windows Explorer interface. There, a user can define file types and the applications which are to be launched when selecting\/invoking (e.g. double clicking) the file type from the file system. Alternatively, an O\/S API or interface may be used to configure an object to associate to a launch-able executable for handling the object. In this same scheme, the MS will have a similar mechanism whereby an association of an application to a type of object (e.g. file type) has been assigned. Block  makes use of the system interface for association which was set up outside of present disclosure processing (e.g. via MS O\/S).","Referring back to block , if it is determined the \u201cOperand\u201d does not indicate to launch with a standard contextual object type interface, processing continues to block . If block  determines the \u201cOperand\u201d indicates to perform a custom launch, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to the caller (invoker) at block . If block  determines there were no parameter errors, then processing continues to block .","If block  determines the custom launch is not to use an Application Programming Interface (API) to launch the applicable application for composing the object passed as a parameter, then block  prepares a command string for launching the particular application, block  invokes the command string for launching the application, and processing continues to block  for returning to the caller.","If block  determines the custom launch is to use an Application Programming Interface (API) to launch the applicable application for composing the object passed as a parameter, then block  prepares any API parameters as necessary, block  invokes the API for launching the application, and processing continues to block  for returning to the caller.","Referring back to block , if it is determined that the \u201cOperand\u201d indicates to perform the compose command locally (e.g. use operating system interface (e.g. set semaphore, program object, data, signal, etc)), then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to the caller (invoker) at block . If block  determines there were no parameter errors, then block  performs the compose command, and block  returns to the caller.","In , \u201cParameters\u201d for the atomic compose command in accordance with the \u201cOperand\u201d were shown to be validated for being properly privileged prior to  processing (by  processing). However, an alternate embodiment could move some or all applicable privilege validation to  in context of where the \u201cParameters\u201d are processed. Also, some embodiments may not validate \u201cParameters\u201d since they (or some reasonable subset thereof) can be understood to be in good order by the time  processing occurs (e.g. no blocks \/ and\/or \/ and\/or \/ required). In yet another embodiment, some defaulting of parameters is implemented.",{"@attributes":{"id":"p-1045","num":"1749"},"figref":["FIGS. 65B-1","FIG. 34D"],"b":["65","7","6516","6534","6542"],"ul":{"@attributes":{"id":"ul0134","list-style":"none"},"li":["S=Standard contextual launch used (blocks  through );","C=Custom launch used (blocks  through );","O=Other processing (O\/S interface) used (blocks  through ).\n\nAny of the Compose command operand combinations can be carried out with either of the methodologies. The second column shows a preferred methodology (PM). The third column describes processing which is placed into flowchart embodiments. There are many embodiments derived from the Compose processing descriptions without departing from the spirit and scope of the disclosure. Descriptions are self explanatory.\n"]}},"With reference back to , note that the column of information headed by \u201c105\u201d represents the parameters applicable for the Compose command. The Compose command has the following parameters, all of which are interpreted in context of the Operand:\n\n","Compose command data is preferably maintained to LBX history, a historical call log (e.g. outgoing when call placed), or other useful storage for subsequent use (some embodiments may include this processing where appropriate (e.g. as part of blocks , , etc)).",{"@attributes":{"id":"p-1048","num":"1760"},"figref":["FIG. 65C","FIG. 65A","FIG. 65A","FIG. 65C"],"b":["04","54"]},{"@attributes":{"id":"p-1049","num":"1761"},"figref":"FIG. 66A","ul":{"@attributes":{"id":"ul0136","list-style":"none"},"li":{"@attributes":{"id":"ul0136-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0137","list-style":"none"},"li":["1) Launching an application, executable, or program with a standard contextual object type interface;","2) Custom launching of an application, executable, or program;","3) Processing the connect command through a MS operating system interface; or","4) Using a MS to MS communications (MS2MS) of .\n\nIn various embodiments, any of the connect command Operands can be implemented with either one of the methodologies, although there may be a preference of which methodology is used for which Operand. Atomic connect command processing begins at block , continues to block  for accessing parameters of connect command \u201cOperand\u201d (BNF Grammar Operand) and \u201cParameters\u201d (BNF Grammar Parameters), and then to block  for checking which \u201cOperand\u201d was passed. If block  determines the \u201cOperand\u201d indicates to launch with a standard contextual object type interface, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to the caller (invoker) at block . If block  determines there were no parameter errors, then block  interfaces to the MS operating system for the particular object passed as a parameter. Block  may prepare parameters in preparation for the O\/S contextual launch, for example if parameters are passed to the application which is invoked. Processing leaves block  and returns to the caller (invoker) at block .\n"]}}}},"An example of block  is similar to the Microsoft Windows XP O\/S association of applications to file types for convenient application launch, and is the same as processing of block  described above. Block  makes use of the system interface for association which was set up outside of present disclosure processing (e.g. via MS O\/S).","Referring back to block , if it is determined the \u201cOperand\u201d does not indicate to launch with a standard contextual object type interface, processing continues to block . If block  determines the \u201cOperand\u201d indicates to perform a custom launch, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to the caller (invoker) at block . If block  determines there were no parameter errors, then processing continues to block .","If block  determines the custom launch is not to use an Application Programming Interface (API) to launch the applicable application for the object passed as a parameter, then block  prepares a command string for launching the particular application, block  invokes the command string for launching the application, and processing continues to block  for returning to the caller.","If block  determines the custom launch is to use an Application Programming Interface (API) to launch the applicable application for the object passed as a parameter, then block  prepares any API parameters as necessary, block  invokes the API for launching the application, and processing continues to block  for returning to the caller.","Referring back to block , if it is determined that the \u201cOperand\u201d indicates to perform the connect command locally (e.g. use operating system interface (e.g. set semaphore, program object, data, signal, etc)), or to use MS2MS for processing, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to the caller (invoker) at block . If block  determines there were no parameter errors, then block  checks the operand for which processing to perform. If block  determines that MS2MS processing is needed to accomplish processing, then block  prepares parameters for  processing, and block  invokes the procedure of  for sending the data (connect command, operand and parameters) for connect processing at the MS to connect. Processing then continues to block . MS2MS processing is as already described above (see ), except  performs sending data for the connect command to the remote MS for processing, and  blocks  through  carry out processing specifically for the connect command. Block  processes the connect command for connecting the MSs in context of the Operand. Referring back to block , if it is determined that MS2MS is not to be used, then block  performs the connect command, and block  returns to the caller.","In , \u201cParameters\u201d for the atomic connect command in accordance with the \u201cOperand\u201d were shown to be validated for being properly privileged prior to  processing (by  processing). However, an alternate embodiment could move some or all applicable privilege validation to  in context of where the \u201cParameters\u201d are processed. Also, some embodiments may not validate \u201cParameters\u201d since they (or some reasonable subset thereof) can be understood to be in good order by the time  processing occurs (e.g. no blocks \/ and\/or \/ and\/or \/ required). In yet another embodiment, some defaulting of parameters is implemented.","In the case of automatically dialing a phone number at a MS, there are known APIs to accomplish this functionality, depending on the MS software development environment, by passing at least a phone number to the MS API programmatically at the MS (e.g. see C# phone application APIs, J2ME phone APIs, etc). In a J2ME embodiment, you can place a call by calling the MIDP 2.0 platformRequest method inside the MIDIet class (e.g. platformRequest(\u201ctel:\/\/mobileNumber\u201d) will request the placing call functionality from the applicable mobile platform).",{"@attributes":{"id":"p-1057","num":"1773"},"figref":["FIGS. 66B-1","FIG. 34D"],"b":["66","2","6648","7584"],"ul":{"@attributes":{"id":"ul0138","list-style":"none"},"li":["S=Standard contextual launch used (blocks  through );","C=Custom launch used (blocks  through );","O=Other processing (MS2MS or local) used (blocks  through ).\n\nAny of the Connect command operand combinations can be carried out with either of the methodologies. The second column shows a preferred methodology (PM). The third column describes processing which is placed into flowchart embodiments. There are many embodiments derived from the Connect processing descriptions without departing from the spirit and scope of the disclosure. Descriptions are self explanatory.\n"]}},"With reference back to , note that the column of information headed by \u201c119\u201d represents the parameters applicable for the Connect command. The Connect command has the following parameters, all of which are interpreted in context of the Operand:\n\n","Connect command data is preferably maintained to LBX history, a historical call log (e.g. outgoing when call placed), or other useful storage for subsequent use (some embodiments may include this processing where appropriate (e.g. as part of blocks , , , etc)).",{"@attributes":{"id":"p-1060","num":"1784"},"figref":["FIG. 66C","FIG. 66A","FIG. 66A","FIG. 66C"],"b":["04","54"]},{"@attributes":{"id":"p-1061","num":"1785"},"figref":"FIG. 67A","ul":{"@attributes":{"id":"ul0140","list-style":"none"},"li":{"@attributes":{"id":"ul0140-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0141","list-style":"none"},"li":["1) Launching an application, executable, or program with a standard contextual object type interface;","2) Custom launching of an application, executable, or program;","3) Processing the find command locally; or","4) Using MS to MS communications (MS2MS) of  for remote finding.\n\nIn various embodiments, any of the find command Operands can be implemented with either one of the methodologies, although there may be a preference of which methodology is used for which Operand. Atomic find command processing begins at block , continues to block  for accessing parameters of find command \u201cOperand\u201d (BNF Grammar Operand) and \u201cParameters\u201d (BNF Grammar Parameters), and then to block  for getting the next (or first) system parameter (block  starts a loop for processing system(s)). At least one system parameter is required for the find. If at least one system is not present for being processed by block , then block  will handle the error and continue to block  for returning to the caller (not shown\u2014considered obvious error handling, or was already validated at configuration time). Block  continues to block . If block  determines that an unprocessed system parameter remains, then processing continues to block . If block  determines the system is not the MS of  processing, then MS2MS processing is used to accomplish the remote find processing, in which case block  continues to block  for preparing parameters for  processing. Thereafter, block  checks to see if there were any parameter errors since block  also validates them prior to preparing them. If block  determines there was at least one parameter error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing continues back to block . If block  determines there were no errors, then block  invokes the procedure of  for sending the data (find command, operand and parameters) for remote find processing at the remote MS. Processing then continues back to block . MS2MS processing is as already described above (see ), except  performs sending data for the find command to the remote MS for finding sought operand dependent criteria at the remote MS, and  blocks  through  carry out processing specifically for the find command. Block  processes the find command for finding sought criteria in context of the Operand at the MS of  processing. Blocks  and  will return the results to the requesting MS of  processing, and block  will complete appropriate find processing. Note that block  preferably includes application launch processing (e.g. like found in ) for invoking the best application in the appropriate manner with the find results returned. The application should be enabled for searching remote MSs further if the user chooses to do so. Another embodiment of block  processes the search results and displays them to the user and\/or logs results to a place the user can check later and\/or logs results to a place a local MS application can access the results in an optimal manner. In some embodiments, find processing is spawned at the remote MS and the interface results are presented to the remote user. In some embodiments, the find processing results interface is presented to the user of  processing. In some embodiments, find processing is passed an additional parameter for whether or not to spawn the search interface at the remote MS for the benefit of the remote MS user (at MS of  processing), or to spawn locally for the benefit of the user of the MS of  processing.\n"]}}}},"In one embodiment, block  causes processing at a remote data processing system which incorporates similar MS2MS processing, but the remote data processing system is not a MS (i.e. system parameter is for a data processing system identifier accessible to the MS of  processing). The remote data processing system may be a service data processing system, or any other data processing system capable of similar MS2MS processing as described for the find command, perhaps involving search of storage, memory, or operating system resources which is shared by many MSs.","Referring back to block , if it is determined that the system for processing is the MS of  processing, then processing continues to block  for checking which \u201cOperand\u201d was passed. If block  determines the \u201cOperand\u201d indicates to launch a search application for the sought operand with a standard contextual object type interface, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns back to block . If block  determines there were no parameter errors, then block  interfaces to the MS operating system to start the search application for the particular object passed as a parameter. Block  may prepare parameters in preparation for the O\/S contextual launch, for example if parameters are passed to the application which is invoked for finding the object. Processing leaves block  and returns to block .","An example of block  is similar to the Microsoft Windows XP association of applications to file types for convenient application launch, just as was described above for block .","Referring back to block , if it is determined the \u201cOperand\u201d does not indicate to launch with a standard contextual object type interface, processing continues to block . If block  determines the \u201cOperand\u201d indicates to perform a custom launch, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to block . If block  determines there were no parameter errors, then processing continues to block .","If block  determines the custom launch is not to use an Application Programming Interface (API) to launch the applicable search application for finding the object passed as a parameter, then block  prepares a command string for launching the particular application, block  invokes the command string for launching the application, and processing continues to block .","If block  determines the custom launch is to use an Application Programming Interface (API) to launch the applicable application for finding the object passed as a parameter, then block  prepares any API parameters as necessary, block  invokes the API for launching the application, and processing continues back to block .","Referring back to block , if it is determined that the \u201cOperand\u201d indicates to perform the find command with other local processing, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to block . If block  determines there were no parameter errors, then block  checks the operand for which find processing to perform, and performs find processing appropriately. Processing then continues back to block .","Referring back to block , if it is determined that there are no remaining unprocessed system parameters, then processing returns to the caller at block .","In , \u201cParameters\u201d for the atomic find command in accordance with the \u201cOperand\u201d were shown to be validated for being properly privileged prior to  processing (by  processing). However, an alternate embodiment could move some or all applicable privilege validation to  in context of where the \u201cParameters\u201d are processed. Also, some embodiments may not validate \u201cParameters\u201d since they (or some reasonable subset thereof) can be understood to be in good order by the time  processing occurs (e.g. no blocks \/ and\/or \/ and\/or \/ required). In yet another embodiment, some defaulting of parameters is implemented.",{"@attributes":{"id":"p-1071","num":"1799"},"figref":["FIGS. 67B-1","FIG. 34D"],"b":["67","13","6750","7584"],"ul":{"@attributes":{"id":"ul0142","list-style":"none"},"li":["S=Standard contextual launch used (blocks  through );","C=Custom launch used (blocks  through );","O=Other processing (MS2MS or local) used (blocks  through , blocks  through ).\n\nAny of the Find command operand combinations can be carried out with either of the methodologies. The second column shows a preferred methodology (PM). The third column describes processing which is placed into flowchart embodiments. There are many embodiments derived from the Find processing descriptions without departing from the spirit and scope of the disclosure. Descriptions are self explanatory.\n"]}},"With reference back to , note that the column of information headed by \u201c107\u201d represents the parameters applicable for the Find command. The Find command has the following parameters, all of which are interpreted in context of the Operand:\n\n",{"@attributes":{"id":"p-1073","num":"1806"},"figref":["FIG. 67C","FIG. 67A","FIG. 67A","FIG. 67C"],"b":["04","54"]},"Find command processing discussed thus far demonstrates multithreaded\/multiprocessed processing for each system to search. In one embodiment, the same methodology is used for each system and each launched find processing saves results to a common format and destination. In this embodiment, block  processing continues to a new block  when all systems are processed. New block  gathers the superset of find results saved, and then launches an application (perhaps the same one that was launched for each find) to show all results found asynchronously from each other. The application launched will be launched with the same choice of schemes as blocks  through . Block  then continues to block . This design requires all applications invoked to terminate themselves after saving search results appropriately for gathering a superset and presenting in one find results interface. Then, the new block  handles processing for a single application to present all search results.","In another embodiment, while an application may be launched multiple times for each system, the application itself is relied upon for handling multiple invocations. The application itself has intelligence to know it was re-launched thereby permitting a single resulting interface for multiple target system searches, regardless of the number of times the same search application was launched.","In one preferred embodiment, find processing permits multiple instances of a search application launched wherein Find processing is treated independently (this is shown in ).","Preferably all find command embodiments provide the ability to perform other commands (e.g. Copy, Move, Discard, Change, Administrate, etc) wherever possible from the resulting interface in context for each search result found.","Find command data is preferably maintained to LBX history, a historical log, or other useful storage for subsequent use (some embodiments may include this processing where appropriate). Additional find command parameters can be provided for how and where to search (e.g. case sensitivity, get all or first, how to present results, etc).",{"@attributes":{"id":"p-1079","num":"1812"},"figref":"FIG. 68A","ul":{"@attributes":{"id":"ul0144","list-style":"none"},"li":{"@attributes":{"id":"ul0144-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0145","list-style":"none"},"li":["1) Launching an application, executable, or program with a standard contextual object type interface;","2) Custom launching of an application, executable, or program;","3) Processing the invoke command locally;","4) Using MS to MS communications (MS2MS) of  for remote invocation; or","5) Using email or similar messaging layer as a transport layer for invoking distributions.\n\nIn various embodiments, any of the invoke command Operands can be implemented with either one of the methodologies, although there may be a preference of which methodology is used for which Operand. Atomic invoke command processing begins at block , continues to block  for accessing parameters of invoke command \u201cOperand\u201d (BNF Grammar Operand) and \u201cParameters\u201d (BNF Grammar Parameters), and then to block  for checking if the Operand for invocation indicates to use the email (or similar messaging transport). If block  determines the Operand is for email\/messaging transport use, then block  invokes send command processing of  with the Operand and Parameters. Upon return, processing continues to block  for returning to the caller (invoker of  processing). If send processing of  (via block ) is to be used for Operands with a system(s) parameter, then the system(s) parameter is equivalent to the recipient(s) parameter and other parameters are set appropriately.\n"]}}}},"If block  determines the Operand is not for the email\/messaging transport use, then processing continues to block  for getting the next (or first) system parameter (block  starts an iterative loop for processing system(s)). At least one system parameter is required for the invoke command at block . If at least one system is not present for being processed by block , then block  will handle the error and continue to block  for returning to the caller (not shown\u2014considered obvious error handling, or was already validated at configuration time). Block  continues to block . If block  determines that an unprocessed system parameter remains, then processing continues to block . If block  determines the system is not the MS of  processing, then MS2MS processing is used to accomplish the remote invoke processing, in which case block  continues to block  for preparing parameters for  processing, and block  invokes the procedure of  for sending the data (invoke command, operand and parameters) for remote invoke processing at the remote MS. Processing then continues back to block . MS2MS processing is as already described above (see ), except  performs sending data for the invoke command to the remote MS for an invocation at the remote MS, and  blocks  through  carry out processing specifically for the invoke command. Block  processes the invoke command for invocation in context of the Operand at the MS of  processing (e.g. using invocation methodologies of ).","In one embodiment, blocks  and  cause processing at a remote data processing system which incorporates similar MS2MS processing, but the remote data processing system is not a MS (i.e. system parameter is for a data processing system identifier accessible to the MS of  processing). The remote data processing system may be a service data processing system, or any other data processing system capable of similar MS2MS processing as described for the invoke command, perhaps involving invocation of a suitable executable in context for the operand.","Referring back to block , if it is determined that the system for processing is the MS of  processing, then processing continues to block  for checking which \u201cOperand\u201d was passed. If block  determines the \u201cOperand\u201d indicates to invoke (launch) an appropriate application for the operand with a standard contextual object type interface, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns back to block . If block  determines there were no parameter errors, then block  interfaces to the MS operating system to start the appropriate application for the particular object passed as a parameter. Block  may prepare parameters in preparation for the O\/S contextual launch, for example if parameters are passed to the application which is invoked. Processing leaves block  and returns to block .","An example of block  is similar to the Microsoft Windows XP association of applications to file types for convenient application launch, just as described above for block .","Referring back to block , if it is determined the \u201cOperand\u201d does not indicate to launch with a standard contextual object type interface, processing continues to block . If block  determines the \u201cOperand\u201d indicates to perform a custom launch, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to block . If block  determines there were no parameter errors, then processing continues to block .","If block  determines the custom invocation (launch) is not to use an Application Programming Interface (API) to invoke the application for the object passed as a parameter, then block  prepares a command string for invoking the particular application, block  invokes the command string for launching the application, and processing continues to block .","If block  determines the custom invocation (launch) is to use an Application Programming Interface (API) to invoke the application for the object passed as a parameter, then block  prepares any API parameters as necessary, block  invokes the API for launching the application, and processing continues back to block .","Referring back to block , if it is determined that the \u201cOperand\u201d indicates to perform the invoke command with other local processing, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to block . If block  determines there were no parameter errors, then block  checks the operand for which invoke processing to perform, and performs invoke command processing appropriately.","Referring back to block , if it is determined that there are no remaining unprocessed system parameters, then processing returns to the caller at block .","In , \u201cParameters\u201d for the atomic invoke command in accordance with the \u201cOperand\u201d were shown to be validated for being properly privileged prior to  processing (by  processing). However, an alternate embodiment could move some or all applicable privilege validation to  in context of where the \u201cParameters\u201d are processed. Also, some embodiments may not validate \u201cParameters\u201d since they (or some reasonable subset thereof) can be understood to be in good order by the time  processing occurs (e.g. no blocks \/ and\/or \/ and\/or \/ required). In yet another embodiment, some defaulting of parameters is implemented.",{"@attributes":{"id":"p-1090","num":"1828"},"figref":["FIGS. 68B-1","FIG. 34D"],"b":["68","5","6850","7584"],"ul":{"@attributes":{"id":"ul0146","list-style":"none"},"li":["S=Standard contextual launch used (blocks  through );","C=Custom launch used (blocks  through );","E=Email transport preferably used (blocks  through );","O=Other processing (MS2MS or local) used (blocks  through , blocks  through ).\n\nAny of the Invoke command operand combinations can be carried out with either of the methodologies. The second column shows a preferred methodology (PM). The third column describes processing which is placed into flowchart embodiments. There are many embodiments derived from the Invoke processing descriptions without departing from the spirit and scope of the disclosure. Descriptions are self explanatory.\n"]}},"With reference back to , note that the column of information headed by \u201c109\u201d represents the parameters applicable for the Invoke command. The Invoke command has the following parameters, all of which are interpreted in context of the Operand:\n\n",{"@attributes":{"id":"p-1092","num":"1840"},"figref":["FIG. 68C","FIG. 68A","FIG. 68A","FIG. 68C"],"b":["04","54"]},"In some embodiments, the invoke command may be used as an overall strategy and architecture for performing most, if not all, actions (e.g. other commands).",{"@attributes":{"id":"p-1094","num":"1842"},"figref":"FIG. 69A","ul":{"@attributes":{"id":"ul0148","list-style":"none"},"li":{"@attributes":{"id":"ul0148-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0149","list-style":"none"},"li":["1) Launching an application, executable, or program with a standard contextual object type interface, for finding the source object(s) to copy;","2) Custom launching of an application, executable, or program, for finding the source object(s) to copy;","3) Processing the copy command locally, for finding the source object(s) to copy; or","4) MS to MS communications (MS2MS) of  for finding the source object(s) to copy.\n\nThe source parameter specifies which system is to be the source of the copy: the MS of  processing or a remote data processing system.\n\nThere are two (2) primary methodologies for carrying out copy command copy processing:\n","1) Using local processing;","2) MS to MS communications (MS2MS) of  for remote copying.\n\nIn various embodiments, any of the copy command Operands can be implemented with either of the methodologies, although there may be a preference of which methodology is used for which Operand. Atomic copy command processing begins at block , continues to block  for accessing parameters of copy command \u201cOperand\u201d (BNF Grammar Operand) and \u201cParameters\u201d (BNF Grammar Parameters), and continues to block .\n"]}}}},"If block  determines the source system parameter (source) is this MS, then processing continues to block . If block  determines the \u201cOperand\u201d indicates to launch a search application for the sought operand object with a standard contextual object type interface, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to the caller (invoker) at block . If block  determines there were no parameter errors, then block  interfaces to the MS operating system to start the search application for the particular object (for Operand). Block  may prepare parameters in preparation for the operating system. Processing leaves block  and continues to block  which is discussed below.","An example of block  is similar to the Microsoft Windows XP association of applications to file types for convenient application launch, just as was described above for block .","Referring back to block , if it is determined the \u201cOperand\u201d does not indicate to launch with a standard contextual object type interface, processing continues to block . If block  determines the \u201cOperand\u201d indicates to perform a custom launch, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to the caller at block . If block  determines there were no parameter errors, then processing continues to block .","If block  determines the custom launch is not to use an Application Programming Interface (API) to launch the searching application for copying the object, then block  prepares a command string for launching the particular application, block  invokes the command string for launching the application, and processing continues to block  discussed below.","If block  determines the custom launch is to use an Application Programming Interface (API) to launch the applicable application for searching, then block  prepares any API parameters as necessary, block  invokes the API for launching the application, and processing continues to block .","Referring back to block , if it is determined that the \u201cOperand\u201d indicates to perform the copy command with local search processing, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to the caller at block . If block  determines there were no parameter errors, then block  searches for the operand object in context for the Operand, and processing continues to block .","Referring back to block , if it is determined the source parameter is not for this MS, then block  prepares parameters for  processing. Thereafter, block  checks to see if there were any parameter errors since block  also validates them prior to preparing them. If block  determines there was at least one parameter error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to the caller at block . If block  determines there were no errors, then block  invokes the procedure of  for sending the data (copy command, operand and parameters) for remote copy search processing at the remote MS. Processing then continues to block  discussed below. MS2MS processing is as already described above (see ), except  performs searching for data for the copy command at the remote MS, and  blocks  through  carry out processing specifically for the copy command search processing. Block  processes the copy command for finding the object to copy in context of the Operand. Blocks  and  will return the results to the requesting MS of  processing, and block  will complete appropriate copy search processing so that  processing receives the search results.  can convey the found object(s) for copy by returning from a function interface (the send procedure being a function), returning to a file, setting data visible to both processes, etc. Note that block  may invoke application launch processing (e.g. like found in ) for invoking the best application in the appropriate manner for determining copy search results returned from  processing, or block  may process results itself.","In one embodiment, block  causes processing at a remote data processing system which incorporates similar MS2MS processing, but the remote data processing system is not a MS (i.e. system parameter is for a data processing system identifier accessible to the MS of  processing). The remote data processing system may be a service data processing system, or any other data processing system capable of similar MS2MS processing as described for the find command, perhaps involving search of storage, memory, or operating system resources which are shared by many MSs.","By the time processing reaches block  from any previous  processing, a search result is communicated to processing and any launched executable (application) for searching for the copy object(s) has terminated. Search results can be passed back as a function return, placed to a well known directory, placed to a file, placed to interfaced variable(s), or other communications of the result to further processing. Regardless of the embodiment, search results are accessed at block . An alternate embodiment is like  wherein the application\/processing invoked at blocks , ,  and  handles the ack parameter and ambiguous results appropriately (i.e. no need for blocks  through ) to proceed with completing the copy (processing of blocks  through  incorporated). Different methods are disclosed for similar processing to highlight methods for carrying out processing for either one of the commands (Copy or Discard).","Block  checks the results of finding the source object for copying to ensure there are no ambiguous results (i.e. not sure what is being copied since the preferred embodiment is to not copy more than a single operand object at a time). If block  determines that there was an ambiguous search result, then processing continues to block  for error handling as discussed above (e.g. in context for an ambiguous copy since there were too many things to copy). If block  determines there is no ambiguous entity to copy, block  checks the acknowledgement parameter passed to  processing. An alternate embodiment assumes that a plurality of results is valid for copying all results to the target system(s) (i.e. no ambiguous check). In another embodiment, an ambiguous result relies on user reconciliation to reconcile whether or not to perform the copy (like  discard processing).","If block  determines the acknowledgement (ack) parameter is set to true, then block  provides the search result which is to be copied. Thereafter, processing waits for a user action to either a) continue with the copy; or b) cancel the copy. Once the user action has been detected, processing continues to block . Block  provides a user reconciliation of whether or not to perform the copy. In another embodiment, there is no ack parameter and multiple results detected at block  forces processing into the reconciliation by the MS user. In yet another embodiment, the ack parameter is still provided, however multiple search results forces processing into the reconciliation by the MS user anyway for selecting which individual object shall be copied. In still other embodiments, all results are copied.","If block  determines the user selected to cancel processing, then block  logs the cancellation (e.g. log error to LBX History ) and processing returns to the caller at block . If block  determines the user selected to proceed with the copy, then processing continues to block  for getting the next (or first) system parameter (block  starts a loop for processing system(s) for the copy result). Also, if block  determines that the ack parameter was set to false, then processing continues directly to block . At least one system parameter is required for the copy as validated by previous parameter validations. Block  continues to block . If block  determines that an unprocessed system parameter remains, then processing continues to block . If block  determines the system (target for copy) is the MS of  processing, then block  appropriately copies the source object to the system and processing continues back to block . If block  determines the system is not the MS of  processing, then MS2MS processing is used to accomplish the copy processing to the remote data processing system (e.g. MS), in which case block  prepares parameters for  processing, and block  invokes the procedure of  for sending the data (copy command, operand, and search result) for remote copy processing at the remote MS. Processing then continues back to block . MS2MS processing is as already described above (see ), except  performs sending data for the copy action to the remote MS for copying sought operand dependent criteria to the remote MS, and  blocks  through  carry out processing specifically for the copy processing. Block  processes the copy of the search result from  to the system of  processing.","In one embodiment, blocks  and  cause processing at a remote data processing system which incorporates similar MS2MS processing, but the remote data processing system is not a MS (i.e. system parameter is for a data processing system identifier accessible to the MS of  processing). The remote data processing system may be a service data processing system, or any other data processing system capable of similar MS2MS processing as described for the copy command, perhaps involving storage, memory, or operating system resources which are shared by many MSs.","Referring back to block , if it is determined that there are no remaining unprocessed system parameters, then processing returns to the caller at block .","In , \u201cParameters\u201d for the atomic copy command in accordance with the \u201cOperand\u201d were shown to be validated for being properly privileged prior to  processing (by  processing). However, an alternate embodiment could move some or all applicable privilege validation to  in context of where the \u201cParameters\u201d are processed. Also, some embodiments may not validate \u201cParameters\u201d since they (or some reasonable subset thereof) can be understood to be in good order by the time  processing occurs (e.g. no blocks \/ and\/or \/ and\/or \/ required). In yet another embodiment, some defaulting of parameters is implemented.","The first parameter may define a plurality of entities to be copied when the object inherently contains a plurality (e.g. directory, container). In an alternate embodiment, the search results for copying can be plural without checking for ambiguity at block , in which case all results returned can\/will be copied to the target systems.",{"@attributes":{"id":"p-1111","num":"1865"},"figref":["FIGS. 69B-1","FIG. 34D"],"b":["69","14"],"ul":{"@attributes":{"id":"ul0150","list-style":"none"},"li":["S=Standard contextual launch used (blocks  through );","C=Custom launch used (blocks  through );","O=Other processing used (e.g. block ).\n\nAny of the Copy command operand combinations can be carried out with either of the methodologies. The second column shows a preferred methodology (PM). The third column describes processing which is placed into flowchart embodiments. There are many embodiments derived from the Copy processing descriptions without departing from the spirit and scope of the disclosure. Descriptions are self explanatory.\n"]}},"With reference back to , note that the column of information headed by \u201c111\u201d represents the parameters applicable for the Copy command. The Copy command has the following parameters, all of which are interpreted in context of the Operand:\n\n","In a preferred embodiment, an additional parameter is provided for specifying the target destination of the system for the copy. For example, a directory can be placed to a target path, an email can be placed to a target folder, etc. Otherwise, there is an assumed target destination. In another embodiment, a user can select from a plurality of search results which objects are to be copied.",{"@attributes":{"id":"p-1114","num":"1875"},"figref":["FIG. 69C","FIG. 69A","FIG. 69A","FIG. 69C"],"b":["04","54"]},{"@attributes":{"id":"p-1115","num":"1876"},"figref":"FIG. 70A","ul":{"@attributes":{"id":"ul0152","list-style":"none"},"li":{"@attributes":{"id":"ul0152-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0153","list-style":"none"},"li":["1) Launching an application, executable, or program with a standard contextual object type interface;","2) Custom launching of an application, executable, or program;","3) Processing the discard command locally; or","4) Using MS to MS communications (MS2MS) of  for remote discarding.\n\nIn various embodiments, any of the discard command Operands can be implemented with either one of the methodologies, although there may be a preference of which methodology is used for which Operand. Atomic discard command processing begins at block , continues to block  for accessing parameters of discard command \u201cOperand\u201d (BNF Grammar Operand) and \u201cParameters\u201d (BNF Grammar Parameters), and then to block  for getting the next (or first) system parameter (block  starts an iterative loop for processing system(s)). At least one system parameter is required for the discard. If at least one system is not present for being processed by block , then block  will handle the error and continue to block  for returning to the caller (not shown\u2014considered obvious error handling, or was already validated at configuration time). Block  continues to block . If block  determines that an unprocessed system parameter remains, then processing continues to block . If block  determines the system is not the MS of  processing, then MS2MS processing is used to accomplish the remote discard processing, in which case block  continues to block  for preparing parameters for  processing. Thereafter, block  checks to see if there were any parameter errors since block  also validates them prior to preparing them. If block  determines there was at least one parameter error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing continues back to block . If block  determines there were no errors, then block  invokes the procedure of  for sending the data (discard command, operand and parameters) for remote discard processing at the remote MS. Processing then continues back to block . MS2MS processing is as already described above (see ), except  performs sending data for the discard command to the remote MS for discarding sought operand dependent criteria at the remote MS, and  blocks  through  carry out processing specifically for the discard command. Block  processes the discard command for discarding sought criteria in context of the Operand. In a preferred embodiment, the discard takes place when privileged, and when an ack parameter is not provided or is set to false.\n"]}}}},"Blocks  and  will return the results to the requesting MS of  processing when the ack parameter is set to true, and block  will complete appropriate discard processing after prompting the user of the MS of  processing for whether or not to continue (just like blocks  through  discussed below). Note that block  may include invoking the best application in the appropriate manner (e.g. like found in ) with the discard results returned when an acknowledgement (ack parameter) has been specified to true, or block  may process results appropriately itself. Processing should be enabled for then continuing with the discard through another invocation of  (from block  and a following processing of blocks  through  to do the discard) if the user chooses to do so. Block  includes significant processing, all of which has been disclosed in  anyway and then included at block  if needed there for ack processing.","In one embodiment, block  causes processing at a remote data processing system which incorporates similar MS2MS processing, but the remote data processing system is not a MS (i.e. system parameter is for a data processing system identifier accessible to the MS of  processing). The remote data processing system may be a service data processing system, or any other data processing system capable of similar MS2MS processing as described for the discard command, perhaps involving search of storage, memory, or operating system resources which are shared by many MSs.","Referring back to block , if it is determined that the system for processing is the MS of  processing, then processing continues to block  for checking which \u201cOperand\u201d was passed. If block  determines the \u201cOperand\u201d indicates to launch a search application for the sought operand with a standard contextual object type interface, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns back to block . If block  determines there were no parameter errors, then block  interfaces to the MS operating system to start the search application for the particular object passed as a parameter and then to continue with the discard for ack set to false, and to prompt for doing the discard for the prompt set to true. Block  may prepare parameters in preparation for the operating system, for example if parameters are passed to the application which is invoked for discarding the object. Processing leaves block  and returns to block . An alternate embodiment processes like  wherein the application launched at block  produces only a search result prior to continuing to block . Then, the search result is discarded if there are no ambiguous results or the ack parameter is set to false, or there are ambiguous results and the user selects to continue, or the ack parameter is set to true and the user selects to continue.  demonstrates processing where the executable launched is an all inclusive processing. Likewise,  can be like  wherein the application launched handles the ack parameter appropriately. Different methods are disclosed for similar processing to highlight methods to carrying out processing for either one of the commands (Copy or Discard).","An example of block  is similar to the Microsoft Windows XP association of applications to file types for convenient application launch, just as was described above for block .","Referring back to block , if it is determined the \u201cOperand\u201d does not indicate to launch with a standard contextual object type interface, processing continues to block . If block  determines the \u201cOperand\u201d indicates to perform a custom launch, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to block . If block  determines there were no parameter errors, then processing continues to block .","If block  determines the custom launch is not to use an Application Programming Interface (API) to launch the applicable search application for discarding the object passed as a parameter, then block  prepares a command string for launching the particular application, block  invokes the command string for launching the application, and processing continues to block . An alternate embodiment processes like  wherein the application launched at block  produces only a search result prior to continuing to block . Then, the search result is discarded if there are no ambiguous results or the ack parameter is set to false, or there are ambiguous results and the user selects to continue, or the ack parameter is set to true and the user selects to continue.  demonstrates processing where the executable launched is an all inclusive processing (e.g. includes processing of blocks  through ).","If block  determines the custom launch is to use an Application Programming Interface (API) to launch the applicable application for discarding the object passed as a parameter, then block  prepares any API parameters as necessary, block  invokes the API for launching the application, and processing continues back to block . An alternate embodiment processes like  wherein the application launched at block  produces only a search result prior to continuing to block . Then, the search result is discarded if there are no ambiguous results or the ack parameter is set to false, or there are ambiguous results and the user selects to continue, or the ack parameter is set to true and the user selects to continue.  demonstrates processing where the executable launched is an all inclusive processing (includes processing of blocks  through ).","Referring back to block , if it is determined that the \u201cOperand\u201d indicates to perform the discard command with other local processing, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to block . If block  determines there were no parameter errors, then block  checks the operand for which discard processing to perform, and performs discard search processing appropriately. Thereafter, block  checks the results.","Block  checks the results of finding the source object for discard to ensure there are no ambiguous results (i.e. not sure what is being discarded since the preferred embodiment is to not discard more than a single operand object at a time). If block  determines that there was an ambiguous search result, then processing continues to block . If block  determines there is no ambiguity, then processing continues to block . If block  determines the ack parameter is set to true, then processing continues to block , otherwise processing continues to block . Block  checks the acknowledgement parameter passed to  processing. An alternate embodiment assumes that a plurality of results is valid and discards all results at the target system(s) (i.e. no ambiguous check). In another embodiment, an ambiguous result causes error handling at block  (like  copy processing).","Block  causes processing for waiting for a user action to either a) continue with the discard; or b) cancel the discard. Once the user action has been detected, processing continues to block . Block  provides a user reconciliation of whether or not to perform the discard. In another embodiment, there is no ack parameter and multiple results detected at block  are handled for the discard.","If block  determines the user selected to cancel processing, then block  logs the cancellation (e.g. log error to LBX History ) and processing returns to block . If block  determines the user selected to proceed with the discard, then processing continues to block . Block  performs the discard of the object(s) found at block . Thereafter, processing continues back to block .","Referring back to block , if it is determined that there are no remaining unprocessed system parameters, then processing returns to the caller at block .","In , \u201cParameters\u201d for the atomic discard command in accordance with the \u201cOperand\u201d were shown to be validated for being properly privileged prior to  processing (by  processing). However, an alternate embodiment could move some or all applicable privilege validation to  in context of where the \u201cParameters\u201d are processed. Also, some embodiments may not validate \u201cParameters\u201d since they (or some reasonable subset thereof) can be understood to be in good order by the time  processing occurs (e.g. no blocks \/ and\/or \/ and\/or \/ required). In yet another embodiment, some defaulting of parameters is implemented.",{"@attributes":{"id":"p-1129","num":"1894"},"figref":["FIGS. 70B-1","FIG. 34D"],"b":["70","11"],"ul":{"@attributes":{"id":"ul0154","list-style":"none"},"li":["S=Standard contextual launch used (blocks  through );","C=Custom launch used (blocks  through );","O=Other processing (MS2MS or local) used (blocks  through , blocks  through ).\n\nAny of the Discard command operand combinations can be carried out with either of the methodologies. The second column shows a preferred methodology (PM). The third column describes processing which is placed into flowchart embodiments. There are many embodiments derived from the Discard processing descriptions without departing from the spirit and scope of the disclosure. Descriptions are self explanatory.\n"]}},"With reference back to , note that the column of information headed by \u201c113\u201d represents the parameters applicable for the Discard command. The Discard command has the following parameters, all of which are interpreted in context of the Operand:\n\n","Discard command processing discussed thus far demonstrates multithreaded\/multiprocessed processing for each system to search. In search results processing, for example when a plurality of results for discard are available, an application may be launched multiple times. For each system, the application itself is relied upon for handling multiple invocations. The application itself has intelligence to know it was re-launched thereby permitting a single resulting interface for multiple target system searches, regardless of the number of times the same search application was launched. In a preferred embodiment, discard processing permits multiple instances of a search application launched. In another embodiment, a user selects which of a plurality of results are to be discarded prior to discarding.",{"@attributes":{"id":"p-1132","num":"1903"},"figref":["FIG. 70C","FIG. 70A","FIG. 70A","FIG. 70C"],"b":["04","54"]},{"@attributes":{"id":"p-1133","num":"1904"},"figref":"FIG. 71A","ul":{"@attributes":{"id":"ul0156","list-style":"none"},"li":{"@attributes":{"id":"ul0156-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0157","list-style":"none"},"li":["1) Launching an application, executable, or program with a standard contextual object type interface, for finding the source object(s) to move;","2) Custom launching of an application, executable, or program, for finding the source object(s) to move;","3) Processing the move command locally, for finding the source object(s) to move; or","4) MS to MS communications (MS2MS) of  for finding the source object(s) to move.\n\nThe source parameter specifies which system is to be the source of the move: the MS of  processing or a remote data processing system.\n\nThere are two (2) primary methodologies for carrying out move command processing:\n","1) Using local processing;","2) MS to MS communications (MS2MS) of  for remote processing.\n\nIn various embodiments, any of the move command Operands can be implemented with either of the methodologies, although there may be a preference of which methodology is used for which Operand. Atomic move command processing begins at block , continues to block  for accessing parameters of move command \u201cOperand\u201d (BNF Grammar Operand) and \u201cParameters\u201d (BNF Grammar Parameters), and continues to block .\n"]}}}},"If block  determines the source system parameter (source) is this MS, then processing continues to block . If block  determines the \u201cOperand\u201d indicates to launch a search application for the sought operand object with a standard contextual object type interface, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to the caller (invoker) at block . If block  determines there were no parameter errors, then block  interfaces to the MS operating system to start the search application for the particular object. Block  may prepare parameters in preparation for the operating system. Processing leaves block  and continues to block  which is discussed below.","An example of block  is similar to the Microsoft Windows XP association of applications to file types for convenient application launch, just as was described above for block .","Referring back to block , if it is determined the \u201cOperand\u201d does not indicate to launch with a standard contextual object type interface, processing continues to block . If block  determines the \u201cOperand\u201d indicates to perform a custom launch, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to the caller at block . If block  determines there were no parameter errors, then processing continues to block .","If block  determines the custom launch is not to use an Application Programming Interface (API) to launch the searching application for moving the object, then block  prepares a command string for launching the particular application, block  invokes the command string for launching the application, and processing continues to block  discussed below.","If block  determines the custom launch is to use an Application Programming Interface (API) to launch the applicable application for searching, then block  prepares any API parameters as necessary, block  invokes the API for launching the application, and processing continues to block .","Referring back to block , if it is determined that the \u201cOperand\u201d indicates to perform the move command with local search processing, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to the caller at block . If block  determines there were no parameter errors, then block  searches for the operand object in context for the Operand, and processing continues to block .","Block  checks the results of finding the source object for moving to ensure there are no ambiguous results (i.e. not sure what is being moved since the preferred embodiment is to not move more than a single operand object at a time). If block  determines there was an ambiguous search result, then processing continues to block  for error handling as discussed above (e.g. in context for an ambiguous move since there were too many things to move). If block  determines there is no ambiguous entity to move, block  checks the acknowledgement parameter passed to  processing. An alternate embodiment assumes that a plurality of results is valid and moves all results to the target system(s) (i.e. no ambiguous check). In another embodiment, an ambiguous result relies on user reconciliation to reconcile whether or not to perform the move (like  discard processing).","If block  determines the acknowledgement (ack) parameter is set to true, then block  provides the search result which is to be moved. Thereafter, processing waits for a user action to either a) continue with the move; or b) cancel the move. Once the user action has been detected, processing continues to block . Block  provides a user reconciliation of whether or not to perform the move. In another embodiment, there is no ack parameter and multiple results detected at block  forces processing into the reconciliation by the user. In yet another embodiment, the ack parameter is still provided, however multiple search results forces processing into the reconciliation by the MS user anyway for selecting which individual object shall be moved. In still other embodiments, all results are moved.","If block  determines the user selected to cancel processing, then block  logs the cancellation (e.g. log error to LBX History ) and processing returns to the caller at block . If block  determines the user selected to proceed with the move, then processing continues to block  for getting the next (or first) system parameter (block  starts an iterative loop for processing system(s) for the move result). Also, if block  determines that the ack parameter was set to false, then processing continues directly to block . At least one system parameter is required for the move as validated by previous parameter validations. Block  continues to block .","If block  determines that an unprocessed system parameter remains, then processing continues to block . If block  determines the system (target for move) is the MS of  processing, then block  appropriately moves the source object to the system and processing continues back to block . If block  determines the system is not the MS of  processing, then MS2MS processing is used to accomplish the move processing to the remote data processing system (e.g. MS), in which case block  prepares parameters for  processing, and block  invokes the procedure of  for sending the data (move command, operand, and search result) for remote move processing at the remote MS. Processing then continues back to block . MS2MS processing is as already described above (see ), except  performs sending data for the move action to the remote MS for moving sought operand dependent criteria to the remote MS, and  blocks  through  carry out processing specifically for the move processing. Block  processes the move of the search result from  to the system of  processing.","Referring back to block , if it is determined the source parameter is not for this MS, then block  prepares parameters for  processing. Thereafter, block  checks to see if there were any parameter errors since block  also validates them prior to preparing them. If block  determines there was at least one parameter error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to the caller at block . If block  determines there were no errors, then block  invokes the procedure of  for sending the data (move command, operand and parameters) for remote move search processing at the remote MS. Processing then continues to block . In one embodiment, the object(s) to move are discarded from the source system (via block ) in preparation for the move command processing at blocks  and . In another embodiment, the object(s) to move will be discarded from the source system when completing move processing at blocks  or . MS2MS processing via block  is as already described above (see ), except  performs searching for data for the move command at the remote MS, and  blocks  through  carry out processing specifically for at least the move command search processing for the source system. Block  processes the move command for finding the object to move in context of the Operand. Blocks  and  will return the results to the requesting MS of  processing, and block  will complete appropriate move search processing so that  processing receives the search results.  can convey the found object(s) for the move by returning from a function interface (the send procedure being a function), returning to a file, setting data visible to both processes, etc. Note that block  may include application launch processing (e.g. like found in ) for invoking the best application in the appropriate manner for determining move search results returned from  processing, or block  may process returned results itself.","In one embodiment, block  causes processing at a remote data processing system which incorporates similar MS2MS processing, but the remote data processing system is not a MS (i.e. system parameter is for a data processing system identifier accessible to the MS of  processing). The remote data processing system may be a service data processing system, or any other data processing system capable of similar MS2MS processing as described for the find command, perhaps involving search of storage, memory, or operating system resources which are shared by many MSs.","By the time processing reaches block  from any previous  processing, a search result is communicated to processing and any launched executable (application) for searching for the move object(s) has terminated. Search results can be passed back as a function return, placed to a well known directory, placed to a file, placed to interfaced variable(s), or other communications of the result to further processing. Regardless of the embodiment, search results are accessed at block . An alternate embodiment is like  wherein the application\/processing invoked at blocks , ,  and  handles the ack parameter and ambiguous results appropriately (i.e. no need for blocks  through ) to proceed with completing the move (processing of blocks  through  incorporated). Different methods are disclosed for similar processing to highlight methods for carrying out processing for either one of the commands (Move or Discard).","In one embodiment, blocks  and  cause processing at a remote data processing system which incorporates similar MS2MS processing, but the remote data processing system is not a MS (i.e. system parameter is for a data processing system identifier accessible to the MS of  processing). The remote data processing system may be a service data processing system, or any other data processing system capable of similar MS2MS processing as described for the move command, perhaps involving storage, memory, or operating system resources which are shared by many MSs.","Referring back to block , if it is determined that there are no remaining unprocessed system parameters, then processing returns to the caller at block .","In , \u201cParameters\u201d for the atomic move command in accordance with the \u201cOperand\u201d were shown to be validated for being properly privileged prior to  processing (by  processing). However, an alternate embodiment could move some or all applicable privilege validation to  in context of where the \u201cParameters\u201d are processed. Also, some embodiments may not validate \u201cParameters\u201d since they (or some reasonable subset thereof) can be understood to be in good order by the time  processing occurs (e.g. no blocks \/ and\/or \/ and\/or \/ required). In yet another embodiment, some defaulting of parameters is implemented.","The first parameter may define a plurality of entities to be moved when the object inherently contains a plurality (e.g. directory, container). In an alternate embodiment, the search results for moving can be plural without checking for ambiguity at block , in which case all results returned will be moved to the target systems.",{"@attributes":{"id":"p-1151","num":"1928"},"figref":["FIGS. 71B-1","FIG. 34D"],"b":["71","14"],"ul":{"@attributes":{"id":"ul0158","list-style":"none"},"li":["S=Standard contextual launch used (blocks  through );","C=Custom launch used (blocks  through );","O=Other processing used (e.g. block ).\n\nAny of the Move command operand combinations can be carried out with either of the methodologies. The second column shows a preferred methodology (PM). The third column describes processing which is placed into flowchart embodiments. There are many embodiments derived from the Move processing descriptions without departing from the spirit and scope of the disclosure. Descriptions are self explanatory.\n"]}},"With reference back to , note that the column of information headed by \u201c115\u201d represents the parameters applicable for the Move command. The Move command has the following parameters, all of which are interpreted in context of the Operand:\n\n","In an alternate embodiment, an additional parameter is provided for specifying the target destination of the system for the move. For example, a directory can be placed to a target path, an email can be placed to a target folder, etc.",{"@attributes":{"id":"p-1154","num":"1938"},"figref":["FIG. 71C","FIG. 71A","FIG. 71A","FIG. 71C"],"b":["04","54"]},{"@attributes":{"id":"p-1155","num":"1939"},"figref":"FIG. 72A","ul":{"@attributes":{"id":"ul0160","list-style":"none"},"li":{"@attributes":{"id":"ul0160-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0161","list-style":"none"},"li":["1) Launching an application, executable, or program with a standard contextual object type interface;","2) Custom launching of an application, executable, or program;","3) Processing the store command locally; or","4) Using MS to MS communications (MS2MS) of  for storing remotely.\n\nIn various embodiments, any of the store command Operands can be implemented with either one of the methodologies, although there may be a preference of which methodology is used for which Operand. Atomic store command processing begins at block , continues to block  for accessing parameters of store command \u201cOperand\u201d (BNF Grammar Operand) and \u201cParameters\u201d (BNF Grammar Parameters), and then to block  for getting the next (or first) system parameter (block  starts an iterative loop for processing system(s)). At least one system parameter is required for the store command. If at least one system is not present for being processed by block , then block  will handle the error and continue to block  for returning to the caller (not shown\u2014considered obvious error handling, or was already validated at configuration time). Block  continues to block . If block  determines that an unprocessed system parameter remains, then processing continues to block . If block  determines the system is not the MS of  processing, then MS2MS processing is needed to accomplish the remote store processing, in which case block  continues to block  for preparing parameters for  processing. Thereafter, block  checks to see if there were any parameter errors since block  also validates them prior to preparing them. If block  determines there was at least one parameter error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing continues back to block . If block  determines there were no errors, then block  invokes the procedure of  for sending the data (store command, operand and parameters) for remote store processing at the remote MS. Processing then continues back to block . MS2MS processing is as already described above (see ), except  performs sending data for the store command to the remote MS for storing operand dependent criteria at the remote MS, and  blocks  through  carry out processing specifically for the store command. Block  processes the store command for storing in context of the Operand.\n"]}}}},"In one embodiment, block  causes processing at a remote data processing system which incorporates similar MS2MS processing, but the remote data processing system is not a MS (i.e. system parameter is for a data processing system identifier accessible to the MS of  processing). The remote data processing system may be a service data processing system, or any other data processing system capable of similar MS2MS processing as described for the store command, perhaps involving search of storage, memory, or operating system resources which are shared by many MSs.","Referring back to block , if it is determined that the system for processing is the MS of  processing, then processing continues to block  for checking which \u201cOperand\u201d was passed. If block  determines the \u201cOperand\u201d indicates to launch a store application for the sought operand with a standard contextual object type interface, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns back to block . If block  determines there were no parameter errors, then block  interfaces to the MS operating system to start the storing application for the particular object passed as a parameter. Block  may prepare parameters in preparation for the operating system, for example if parameters are passed to the application which is invoked for storing the object. Processing leaves block  and returns to block .","An example of block  is similar to the Microsoft Windows XP association of applications to file types for convenient application launch, just as was described above for block .","Referring back to block , if it is determined the \u201cOperand\u201d does not indicate to launch with a standard contextual object type interface, processing continues to block . If block  determines the \u201cOperand\u201d indicates to perform a custom launch, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to block . If block  determines there were no parameter errors, then processing continues to block .","If block  determines the custom launch is not to use an Application Programming Interface (API) to launch the applicable application for storing the object passed as a parameter, then block  prepares a command string for launching the particular application, block  invokes the command string for launching the application, and processing continues to block .","If block  determines the custom launch is to use an Application Programming Interface (API) to launch the applicable application for storing the object passed as a parameter, then block  prepares any API parameters as necessary, block  invokes the API for launching the application, and processing continues back to block .","Referring back to block , if it is determined that the \u201cOperand\u201d indicates to perform the store command with other local processing, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to block . If block  determines there were no parameter errors, then block  checks the operand for which store processing to perform, and performs store processing appropriately. Processing then continues back to block .","Referring back to block , if it is determined that there are no remaining unprocessed system parameters, then processing returns to the caller at block .","In , \u201cParameters\u201d for the atomic store command in accordance with the \u201cOperand\u201d were shown to be validated for being properly privileged prior to  processing (by  processing). However, an alternate embodiment could move some or all applicable privilege validation to  in context of where the \u201cParameters\u201d are processed. Also, some embodiments may not validate \u201cParameters\u201d since they (or some reasonable subset thereof) can be understood to be in good order by the time  processing occurs (e.g. no blocks \/ and\/or \/ and\/or \/ required). In yet another embodiment, some defaulting of parameters is implemented.",{"@attributes":{"id":"p-1165","num":"1953"},"figref":["FIGS. 72B-1","FIG. 34D"],"b":["72","5"],"ul":{"@attributes":{"id":"ul0162","list-style":"none"},"li":["S=Standard contextual launch used (blocks  through );","C=Custom launch used (blocks  through );","O=Other processing (MS2MS or local) used (blocks  through , blocks  through ).\n\nAny of the Store command operand combinations can be carried out with either of the methodologies. The second column shows a preferred methodology (PM). The third column describes processing which is placed into flowchart embodiments. There are many embodiments derived from the Store processing descriptions without departing from the spirit and scope of the disclosure. Descriptions are self explanatory.\n"]}},"With reference back to , note that the column of information headed by \u201c117\u201d represents the parameters applicable for the Store command. The Store command has the following parameters, all of which are interpreted in context of the Operand:\n\n",{"@attributes":{"id":"p-1167","num":"1960"},"figref":["FIG. 72C","FIG. 72A","FIG. 72A","FIG. 72C"],"b":["04","54"]},{"@attributes":{"id":"p-1168","num":"1961"},"figref":"FIG. 73A","ul":{"@attributes":{"id":"ul0164","list-style":"none"},"li":{"@attributes":{"id":"ul0164-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0165","list-style":"none"},"li":["1) Launching an application, executable, or program with a standard contextual object type interface;","2) Custom launching of an application, executable, or program;","3) Processing the administrate command locally; or","4) Using MS to MS communications (MS2MS) of  for remote administration.\n\nIn various embodiments, any of the administrate command Operands can be implemented with either one of the methodologies, although there may be a preference of which methodology is used for which Operand. Atomic administrate command processing begins at block , continues to block  for accessing parameters of administrate command \u201cOperand\u201d (BNF Grammar Operand) and \u201cParameters\u201d (BNF Grammar Parameters), and then to block  for getting the next (or first) system parameter (block  starts an iterative loop for processing system(s)). At least one system parameter is required for the administrate command. If at least one system is not present for being processed by block , then block  will handle the error and continue to block  for returning to the caller (not shown\u2014considered obvious error handling, or was already validated at configuration time). Block  continues to block . If block  determines that an unprocessed system parameter remains, then processing continues to block . If block  determines the system is not the MS of  processing, then MS2MS processing is needed to accomplish the remote administration processing, in which case block  continues to block  for preparing parameters for  processing. Thereafter, block  checks to see if there were any parameter errors since block  also validates them prior to preparing them. If block  determines there was at least one parameter error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing continues back to block . If block  determines there were no errors, then block  invokes the procedure of  for sending the data (administrate command, operand and parameters) for remote administrate processing at the remote MS. Processing then continues back to block . MS2MS processing is as already described above (see ), except  performs sending data for the administrate command to the remote MS for searching for sought operand dependent criteria at the remote MS, and  blocks  through  carry out processing specifically for the administrate command search result. Block  processes the administrate command for searching for sought criteria in context of the Operand. Blocks  and  will return the results to the requesting MS of  processing, and block  will complete appropriate administrate processing. Note that block  may include application launch processing (e.g. like found in ) for invoking the best application in the appropriate manner with the administrate results returned. The application should be enabled for searching remote MSs further if the user chooses to do so, and be enabled to perform the privileged administration. Another embodiment of block  processes the search results and displays them to the user for subsequent administration in an optimal manner. In some embodiments, administrate processing is spawned at the remote MS and the interface results are presented to the remote user. In preferred embodiments, the administrate processing results interface is presented to the user of  processing for subsequent administration. In some embodiments, administrate processing is passed an additional parameter for whether or not to spawn the search interface at the remote MS for the benefit of the remote MS user, or to spawn locally for the benefit of the user of the MS of  processing. Block  may process results itself.\n"]}}}},"In one embodiment, block  causes processing at a remote data processing system which incorporates similar MS2MS processing, but the remote data processing system is not a MS (i.e. system parameter is for a data processing system identifier accessible to the MS of  processing). The remote data processing system may be a service data processing system, or any other data processing system capable of similar MS2MS processing as described for the administrate command, perhaps involving search of storage, memory, or operating system resources which are shared by many MSs.","Referring back to block , if it is determined that the system for processing is the MS of  processing, then processing continues to block  for checking which \u201cOperand\u201d was passed. If block  determines the \u201cOperand\u201d indicates to launch the administration application for the sought operand with a standard contextual object type interface, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns back to block . If block  determines there were no parameter errors, then block  interfaces to the MS operating system to start the administration application for the particular object passed as a parameter. Block  may prepare parameters in preparation for the operating system, for example if parameters are passed to the application which is invoked for administration of the object. Processing leaves block  and returns to block .","An example of block  is similar to the Microsoft Windows XP association of applications to file types for convenient application launch, just as was described above for block .","Referring back to block , if it is determined the \u201cOperand\u201d does not indicate to launch with a standard contextual object type interface, processing continues to block . If block  determines the \u201cOperand\u201d indicates to perform a custom launch, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to block . If block  determines there were no parameter errors, then processing continues to block .","If block  determines the custom launch is not to use an Application Programming Interface (API) to launch the applicable administration application for administration of the object passed as a parameter, then block  prepares a command string for launching the particular application, block  invokes the command string for launching the application, and processing continues to block .","If block  determines the custom launch is to use an Application Programming Interface (API) to launch the applicable application for administration of the object passed as a parameter, then block  prepares any API parameters as necessary, block  invokes the API for launching the application, and processing continues back to block .","Referring back to block , if it is determined that the \u201cOperand\u201d indicates to perform the administrate command with other local processing, then parameter(s) are validated at block  and block  checks the result. If block  determines there was at least one error, then block  handles the error appropriately (e.g. log error to LBX History  and\/or notify user) and processing returns to block . If block  determines there were no parameter errors, then block  checks the operand for which administration processing to perform, and performs administration processing appropriately. Processing then continues back to block .","Referring back to block , if it is determined that there are no remaining unprocessed system parameters, then processing returns to the caller at block .","In , \u201cParameters\u201d for the atomic administrate command in accordance with the \u201cOperand\u201d were shown to be validated for being properly privileged prior to  processing (by  processing). However, an alternate embodiment could move some or all applicable privilege validation to  in context of where the \u201cParameters\u201d are processed. Also, some embodiments may not validate \u201cParameters\u201d since they (or some reasonable subset thereof) can be understood to be in good order by the time  processing occurs (e.g. no blocks \/ and\/or \/ and\/or \/ required). In yet another embodiment, some defaulting of parameters is implemented.",{"@attributes":{"id":"p-1178","num":"1975"},"figref":["FIGS. 73B-1","FIG. 34D"],"b":["73","7"],"ul":{"@attributes":{"id":"ul0166","list-style":"none"},"li":["S=Standard contextual launch used (blocks  through );","C=Custom launch used (blocks  through );","O=Other processing (MS2MS or local) used (blocks  through , blocks  through ).\n\nAny of the Administrate command operand combinations can be carried out with either of the methodologies. The second column shows a preferred methodology (PM). The third column describes processing which is placed into flowchart embodiments. There are many embodiments derived from the Administrate processing descriptions without departing from the spirit and scope of the disclosure. Descriptions are self explanatory.\n"]}},"With reference back to , note that the column of information headed by \u201c121\u201d is not shown. However, it is assumed to be present ( . . . ). The Administrate command has the following parameters, all of which are interpreted in context of the Operand:\n\n",{"@attributes":{"id":"p-1180","num":"1982"},"figref":["FIG. 73C","FIG. 73A","FIG. 73A","FIG. 73C"],"b":["04","54"]},"Administrate command processing discussed thus far demonstrates multithreaded\/multiprocessed processing for each system to perform administration. In one embodiment, the same methodology is used for each system and each launched administrate processing saves results to a common format and destination. In this embodiment, block  processing continues to a new block  when all systems are processed. New block  gathers the superset of administrate results saved, and then launches an application (perhaps the same one that was launched for each administrate) to show all results found asynchronously from each other. The application launched will be launched with the same choice of schemes as blocks  through . Block  then continues to block . This design will want all applications invoked to terminate themselves after saving search results appropriately. Then, the new block  starts a single administration application to present all search results for performing the administration.","In another embodiment, while an application may be launched multiple times for each system, the application itself is relied upon for handling multiple invocations. The application itself has intelligence to know it was re-launched thereby permitting a single resulting interface for multiple target system searches, regardless of the number of times the same search application was launched.","In one preferred embodiment, administrate processing permits multiple instances of a search application launched. Administrate processing is treated independently (this is shown in ).","Preferably all administrate command embodiments provide the ability to perform other commands (e.g. Copy, Move, Discard, Change, . . . ) wherever possible from the resulting interface in context for each search result found.","There are many other reasonable commands (and operands), some of which may intersect processing by other commands. For example, there is a change command. The change command can be described by operand as the other commands were, except the change command has identical processing to other commands for a particular operand. There are multiple commands duplicated with the change command, depending on the operand of the change command (like Connect command overlap of functionality).  depicts a flowchart for describing a preferred embodiment of a procedure for Change command action processing, and  depicts a flowchart for describing one embodiment of a procedure for Change command action processing, as derived from the processing of .","Charters certainly provide means for a full spectrum of automated actions from simple predicate based (conditional) alerts to complex application processing. Actions includes API invocations, executable script invocations (e.g. from command line), executable program invocations, O\/S contextual launch executions, integrated execution processing (e.g. part of block processing), or any other processing executions. As incoming WDRs indicate that a MS (MS user) of interest is nearby, charters provide the mechanism for the richest possible executions of many varieties to be automatically processed. From as simple a use as generating nearby\/nearness\/distantness status to performing a complicated set of processing based on nearby\/nearness\/distantness relative a MS user, there is no limit to the processing that can occur. All of the processing is handled locally by the MS and no connected service was required.","A first LBX enabled MS with phone capability can have a charter configuration for automatically placing a call to a second LBX enabled MS user upon determining that the second MS is close by the first MS user, for example when both users are coincidentally nearby each other. Perhaps the users are in a store at the same time, or are attending an event without knowledge of each other's attendance. It is \u201ccool\u201d to be able to cause an automatic phone call for connecting the users by conversation to then determine that they should \u201chook up\u201d since they are nearby. Furthermore, a charter at the first MS can be configured wherein the first MS automatically dials\/calls the second MS user, or alternatively a charter at the first MS can be configured wherein the second MS automatically dials\/calls the first MS user, provided appropriate privileges are in place.",{"@attributes":{"id":"p-1188","num":"1990"},"figref":["FIG. 76A","FIG. 76A","FIG. 76A"],"b":["7602","7602","7602","7604","7606","7604","22","22","30","30","22"]},"Depending on when a user invokes the special paste option, the sought Term for pasting may not have a value set yet (e.g. AppTerm newly registered). If block  determines the Term has not yet been set with a value, then block  defaults the value for paste, otherwise block  continues to block . Block  may or may not choose to default with an obvious value for \u201cnot set yet\u201d before continuing to block . If block  determines the Term to be pasted is a WDRTerm, then processing continues to block  where the WTV is accessed, and then to block  to see how timely the most recent WDR accessed at block  is for describing whereabouts of the MS. If block  determines the WDR information is not out of date with respect to the WTV (i.e. whereabouts information is timely), then block  pastes the WDR information according to the special paste action causing execution of . If there is no data entry field in focus at the MS at the time of  processing, then an error occurs at block  which is checked for at block . If block  determines the WDR information paste operation was successful, processing terminates at block , otherwise processing continues to block . If block  determines an image frame is not in the focused object, then processing continues to block  which provides the user with an error that there is no appropriate target in focus applicable for the paste operation. The error may require a user acknowledgement to clear the error to ensure the user sees the error. Block  then continues to block .","If block  determines an image lies in the focused object, then processing continues to block A. Block  accesses appropriate status or data processing indication for knowing an image (frame) is in the user interface context. There are a variety of MS applications where an image is detected for being present in the focused user interface. These applications include:\n\n","If at block  it is determined the user attempted to paste WDR information from an untimely WDR, then block  provides the user with a warning, preferably including how stale the WDR information is, and processing waits for a user action to proceed with the paste, or cancel the paste. Thereafter, if block  determines the user selected to cancel the paste operation, then processing terminates at block , otherwise processing continues to block . Alternatively, block  may access a different timeliness variable, or perhaps one set up in advance specifically for paste operations.","Referring back to block , if it is determined the paste operation is not for a WDRTerm, then processing continues directly to block  for pasting the other Term construct terms being referenced by the paste operation (i.e. atomic term, AppTerm, map term, etc).",{"@attributes":{"id":"p-1193","num":"2002"},"figref":"FIG. 76A","b":["22","7604","7604","7616","1100","1100"],"i":["c","d"]},"In another embodiment, the keystroke sequence for the particular paste operation includes a keystroke as defined in a prefix , or in a new record field for an application, so that particular application field(s) are accessible (e.g. AppTerm data field(s) and\/or corresponding WDR Application fields ). Depending on an embodiment, the keystroke sequence(s) field may define a start sequence for applicable paste commands, or may define the directory of valid paste keystroke command sequences. In some embodiments, field provides a joining identifier to another table for joining a plurality of rows containing unique paste commands associated to the PRR . In other embodiments, there are special paste actions for LBX maintained statistics, whereabouts information averages, or any other useful current or past LBX data, including from LBX History . In another embodiment, there are special paste actions for predicted data which is based on current and\/or past LBX data, for example using an automated analysis of a plurality of WDRs, application terms, atomic terms, map terms, statistics, or information thereof. In some embodiments, special paste commands are available for the nearest N MSs (MS users) where \u201cN\u201d forms part of the paste command. For example, the nearest  users' data is pasted into a captured image at the MS for automatically documenting (as part of the image) LBX data appropriate for the picture taken by the MS (e.g. the 3 LBX enabled MS users taken in the photo). Unique paste commands (user input) may be created to access any available LBX data, in any format, combinations thereof, and any data that can be derived from available LBX data.","Paste operations are a convenient method using the wealth of LBX processing data in MS application interfaces. Paste commands also provide an excellent mechanism for component testing lbxPhone\u2122 features. Paste commands may be configured as saved keystrokes for later execution by an application which automates LBX data access (e.g. macro, user input recording file, etc which may or may not be used by an atomic command for automated processing).","Paste operations provide convenient methods for informative markings to photographs and videos. Location, date\/time, who is in the vicinity (e.g. those nearby for picture just taken), options, landmark(s), and historical information can be accessed by a unique paste command in a particular context. MS assets such as queue , LBX History , etc can be accessed with specific paste commands for desired information, even when wanting plural data across a plurality of WDRs or MSs. For example, a paste command can be provided to provide the nearest N MS identifiers in the desired appfld.source.id.X format from queue , wherein N is part of the paste command request (e.g. <ctrl><*><3> provides nearest 3 MSs email identifiers and formats it to a text string for convenient paste to the image or data entry field).","Furthermore, paste commands described by  can be used to paste the current zip code, city, county, state, address, etc. which has been converted from WDR location information using the geo-coding conversion tables. This provides a user with the ability to paste current accurate address information into MS user interfaces without actually knowing where he is located at the time.",{"@attributes":{"id":"p-1198","num":"2007"},"figref":["FIG. 76B-1","FIG. 76A"],"b":["7630","7630","7630","7630","7630","7630","5300","5300","7630","56","60","62","72"]},"An AppTerm configuration processing thread  (e.g. integrated with PRR configuration of ) updates shared memory  to correspond with PRR  configurations. As discussed above, an AppTerm is accessed with a configured prefix which corresponds to a particular application. Prefixes are unique across PRRs . A prefix prevents conflict between a plurality of applications which happen to use the same source code variable name (prefix field is unique) used for the data reference. Shared memory  contains a plurality of shared memory records  for properly interfacing between applications and threads  through . Shared memory  may be of a worst case size to accommodate a maximum number of AppTerm enabled applications by: a) a maximum array size of records ; b) a maximum sized array of pointers to records ; c) a memory pointer to a) or b); or a suitable means for maintaining records . Pointers kept within shared memory  preferably point to dynamically allocated memory which should be appropriately freed, for example upon application termination, or AppTerm removal (e.g. field removes AppTerm to expose).","With reference now to , illustrated is a preferred embodiment of Application term shared memory records, namely shared main record  and shared reference record . Prefix field is equivalent to field and provides correlation of a record  to a particular application. Reference(s) pointer field contains a pointer to a linked list (=NULL or pointer to first of a linked list of one or more records) of shared reference records . There will be a number of shared reference records  in the linked list equal to the number of exposed AppTerm data variables described by field for a particular application of a PRR . Application term(s) memory pointer field points to a block of memory of appropriate size to at least accommodate requirements of all AppTerm data storage described in the linked list of field ","Each record , maintained through field , contains a name field which contains the particular application source code variable name string for the AppTerm shared, an offset field for which byte offset into the memory pointed to by pointer contains the AppTerm value, a length field for the length of AppTerm data value starting at the offset of field , a type field for how to interpret the AppTerm value, and next pointer field for pointing to the next record  in the linked list of field . Description field may provide the default initial value for the AppTerm for the particular record , for example when newly allocating an AppTerm reference to shared memory . Fields through , and are appropriately used for application starting, terminating, checking if started\/terminated, or for determining required executable components. Fields through , and are used as required for a particular application. Field documents any AppTerm(s) which are maintained to records  with appropriate sufficient detail as to enable configuring the applicable records  for the application represented by record  (corresponding to the applicable PRR ).","With reference back to , a WITS processing thread  (e.g. at block ) accesses shared memory  according to AppTerm usage in configured charters . A user interface paste processing thread  (e.g.  processing) also accesses shared memory  according to an AppTerm paste request. Programmers of threads ,  and  anticipate at programming source code creation and executable build time what the global name is of shared memory , and what the architecture is of shared memory . Charter processing uses the prefix (fields and ) to identify which variable references are being made for which AppTerm data. Additionally, programmers of a set of applications  are to conform to the LBX architecture, anticipate at programming source code creation and executable build time what the global name is, and architecture is, of shared memory . This ensures a consistent platform for well performing AppTerm exposure, charter use, and threaded access across heterogeneous applications, while providing \u201cplug-in\u201d capability of application configurations and processing.","Block  initializes to (or may already be initialized to after block ) shared memory , and PRRs if maintained separately. Block  may allocate or deallocate records  according to PRR  alterations. Block  will deallocate any associated record  and its associated records . Block  will allocate an applicable record  and its associated records . Block  may present interesting information of statistics  maintained for accesses to shared memory . Block  preferably allocates and deallocate records  (and associated records ) to avoid errors in AppTerm accessing which are handled as obvious error handling (e.g. AppTerm reference does not exist in shared memory ). Block  displays candidate AppTerm supported applications of the MS which are known to conform to LBX architecture shared memory coding practices. Block  allocates or deallocates as already described for similar reasons described. Block  terminates using (or may terminate using after block ) shared memory , and PRRs if maintained separately.","An application thread performing at least one AppTerm update uses processing of . In a preferred embodiment, the set of applications  use at least one API for interfacing to shared memory  to prevent common source code implementation from being reinvented within different LBX conforming applications. Regardless of implementation, an application of the set of applications  conforms to the LBX architecture when programmers of the application source code implemented the architecture of shared memory  in the framework of PRRs . In one preferred embodiment, a structure (struct) of AppTerm variables is maintained by the application and offsets, lengths, types, and names into the structure are maintained. In this embodiment, field can point to memory containing the structure which is referenced conveniently at source code time with a typecast by the application, and is referenced at run time with record  and its record(s)  by threads  and . Charter processing (e.g. block ) may further contextually resolve the type of an AppTerm based on its expression use context.","With reference now to , illustrated is an embodiment of Application term interface processing for applications not using a standardized LBX coding practice for a shared memory . Threads ,  and , as well as a set of applications , are similar to as described above except with a different access architecture for \u201cmiddle-manning\u201d AppTerm data. The set of applications  of  can include:\n\n","For example, executable  exposes one or more AppTerm data references for external linkage (e.g. extern) and\/or more public interfaces for external linkage to return AppTerm data. Interface -dsif is accomplished with linking executable  to the external interface (e.g. to the extern data). Interface -csif is accomplished with linking executable  to the documented public interface for access of AppTerm data at access times by threads ,  and .","For example, executable  exposes one or more public interfaces for external linkage to return AppTerm data. Interface -csif is accomplished with linking executable  to the documented public interface for access of AppTerm data at access times by threads ,  and .","For example, segment  exposes one or more AppTerm data references for shared memory access well known to those skilled in the art (e.g. shared memory name). Interface -dsif is accomplished with building the executable  to access the shared memory.","The upside of the  architecture is applications need not conform to an AppTerm access architecture, except to make data and interfaces available as they conventionally would anyway. The downside is rebuilding the executable  during user configuration time. PRRs  would be configured for also driving automatic building, and rebuilding, of executable  wherever possible, such as part of  processing. In embodiments where full automation is not possible,  should provide instruction in response to configurations made for those situations that require manual attention. Executable  will provide appropriate thread safe access to AppTerm data.","With regard to appropriate semaphore access, there are various embodiments for AppTerm access:\n\n","Those skilled in the art will recognize alternative AppTerm access implementations using some of the schemes disclosed above. An Object Oriented Programming (OOP) embodiment can embody an AppTerm as a public class interface which consists of a data reference or a member function invocation which returns the data of the appropriate type to a caller (e.g. on the stack).","A WITS processing thread will cause at least one semaphore access when processing other special terms such as a WDRTerm and atomic term, and access to LBX history , queue  accesses, etc. Access to a WDRTerm, atomic term, queue  or LBX History  can be made through an API to isolate processing. MS embodiments may define a plurality of semaphores to manage related sets of data accesses for threads to fully execute wherever possible.","With reference now to , illustrated is a preferred embodiment of charter invocation interface processing, for example upon encounter of a BNF grammar Invocation construct. Here, the set of applications  are executable interfaces which additionally include executable path interfaces (e.g. interface -osif), for example a script  of a file system. In some embodiments, atomic commands may be linked using any of the examples depicted in  or a LBX platform DLL interface, however it is preferred that atomic command implementations be statically linked with caller processing code (e.g. WITS processing) for maximum performance.","Regardless of charter form (for WITS processing) embodiments, appropriate linkage is accomplished for the BNF grammar Invocation construct. An Invocation Mapper  is built for proper link of a WITS processing thread (e.g. ) to executable interfaces in an analogous manner as described for Mapper  (using an interface -if for middle-manning executable invocations). Interface -if preferably invokes a Dynamic Link Library (DLL) interface for executable  to \u201cin turn\u201d invoke the appropriate interface. Interface -csif is accomplished with linking executable  to the documented public interface for access by a WITS processing thread. DLL executable  exposes one or more public interfaces for external linkage wherein interface -csif is accomplished with linking executable  to the documented public interface for access by WITS processing. Interface -osif is preferably provided by a MS O\/S, and is used directly by a WITS processing thread for invoking a script  (e.g. command line file). The advantage of Mapper  is to isolate link changes to outside of WITS processing code so that invocable interfaces are adapted to WITS processing without rebuilding WITS processing itself. Mapper  would provide a single interface for all Invocations by accepting a parameter over interface -if for the requested invocation, searching the corresponding linked interface, and then invoking it. Interfaces of  may return a resulting return code conveyed back to a WITS processing thread.","Those skilled in the art will recognize alternative invocation access implementations. The set of applications  of  provides public interfaces (e.g. APIs) which accept parameters and\/or process parameters from a WITS processing thread, and may return data to a WITS processing thread.","Permission and charter specification through WPL can be processed in a variety of ways depending on the hosting programming environment as described for . The advantage of WPL is extending a programming environment with a rich set of user specified LBX functionality while enhancing LBX user specifications with access to programming environment objects (e.g. variables). Preferably, the PPL environment seamlessly supports a LBX permission and charter syntax which may or may not take on identical syntactical characteristics of the hosting programming development environment. Variable data, executable Invocation interfaces (e.g. function interfaces), semaphores, database interfacing, file system interfacing, shared memory accesses, and any other symbol, data or interface of an executable program is provided to user LBX specifications in a straightforward manner by coupling the hosting programming environment with LBX permission and charter processing in an integrated processing environment. For example, an interpreter or compiler processes embedded charter and permission syntax as any other source encoding it processes, and enables a suitable executable. A special \u201c\u02dc\u201d may not be necessary for a tightly coupled WPL syntax and processing. The \u201c\u02dc\u201d syntax is particularly useful when charter and permission source code accesses conventional programming objects in source code processing (e.g. of an interpreter or compiler) not tightly integrated. When the \u201c\u02dc\u201d reference syntax is used, preferably the programming environment is relied upon for contextually bringing data, type, and\/or meaning to the reference. Alternatively, additional LBX syntax can be provided to explicitly specify the type of BNF grammar reference being made (e.g. to explicitly state specifying a named variable address or data, named semaphore, a named function Invocation interface, a named file, named file and offset\/length therein, named database object, etc) so that interpretation or compilation will know how to treat the syntactical reference, and produce an error prior to run-time execution if improperly referenced. Raw source code, internalized interpreter source code, or compiled and linked source code of LBX privilege and charter specifications is preferably handled in the same programming environment context as the hosting programming environment would handle its native source code. WPL embodiments preferably incorporate syntactical embodiments disclosed for special terms (AppTerm, WDRTerm, atomic term, map term) with appropriate linkage and access (e.g. MS API(s) provided), but may define alternative syntax to prevent ambiguous use, conflict, or elegance issues of syntax already used in conventional source code.","In an alternate embodiment, programming environment symbolic link information is made accessible to permission and charter processing so that the programming environment supports access to its programmatic objects at appropriate permission and charter processing times. Those skilled in the art recognize that symbolic information is produced as part of an executable link, and a human readable symbol information file can also be output as an option of program linking. The symbolic information provides symbol offset addresses relative a variable base address (e.g. a segment (e.g. Data Segment (DS)). Data processing systems support allocating executables to memory (e.g. memory ) for execution. After being loaded into memory, base addresses provide base pointer addresses (e.g. stack pointer, data segment pointer, code segment pointer, etc) for real relative memory pointer address offsets identified in the symbolic information. In a data processing environment which does not support swapping, the addresses of loaded symbols may not change and may be relied upon during execution. In a data processing system environment which supports swapping, the addresses of loaded symbols may change as their base addresses (base segment addresses) change when swapped. Symbols accessed through the link output symbolic information have to be relative a current base address to the region (segment) of memory where a symbol lives. There are well known methods for determining where the value or address of a symbol lives in data processing system memory when consulting symbol information from link output. In a simple embodiment, the MS O\/S is a debug-like framework environment wherein symbol information of linked executable code provides the lookup capability to access data and variables by name to real data processing memory as needed. Also, a data processing system can be equipped with APIs for returning base addresses for symbol information ranges (like OS\/2 selectors) to then determine the offset where an address or value lives.","Atomic commands and their parameters may utilize hosting programmatic objects as described above when the atomic commands are integrated for WPL source code causing directly invoked interfaces from the interpreter or compiler (e.g. statically or dynamically linked). When atomic command interfaces are not used in the context of a WPL environment, they are preferably invoked as statically linked executable code of WITS processing, but may be dynamically linked to WITS processing. Atomic command script interfaces may be used, but performance would likely be unacceptable. When atomic commands are invoked from a WITS processing thread which is not integrated in a conventional programming environment, but access is needed from the atomic command implementation to O\/S resources (e.g. semaphore, application data, database object, file system object, etc), then linkage is needed to accomplish the access. As described above, symbolic information can be made available to atomic command processing by specifying a parameter of where to find required symbolic information to resolve the O\/S object as described by an atomic operand. For example, a symbol (variable name, semaphore name, function name, etc) value, or address thereof, is deduced using the symbol information from at least one link output symbol file in context of a current base region\/segment memory address where the symbol lives. Some embodiments may specify a directory where a plurality of symbolic information files are checked for resolving a symbolic name within a MS O\/S. In atomic commands involving database interfaces, the atomic command implementation may assume authenticated credentials, may take on credentials for authentication by the logged-on user of a MS, may require input of credentials to be authenticated, or authentication credentials may be specified in, or as part of, a parameter for an atomic command and operand pair. In any case, appropriate database access authentication is incorporated for database accesses. In atomic commands involving file system interfaces, the atomic command implementation may assume a file system search path (e.g. current working directory, DPATH, PATH, etc), or the file search path is fully specified in a parameter for an atomic command and operand pair. There are many embodiments for carrying out atomic command and atomic operand processing disclosed.",{"@attributes":{"id":"p-1219","num":"2034"},"figref":["FIG. 76D","FIG. 76D"],"b":["7660","7662","5300","7660","7662"],"i":"n "},"Thereafter, block  searches for relevant special terms (WDRTerm, AppTerm, atomic term, map term, etc) according to the user desired context for charter creation and interfaces with the user for selection(s), block  waits for a user action and block  checks the user action detected. Relevant special terms may be determined by block  through hard coded anticipation logic, but is preferably determined using a cross reference database, table, or map of which special terms are relevant to which applications wherein the cross reference database is maintained independently outside of  processing by a knowledgeable administrator. A user can select a set of special terms from the interface at block  for further processing, or the user can select to exit processing. If the user selected one or more special terms for further processing as determined by block , block  presents operators, defaulted values, other special terms, and pre-formatted charter expressions and\/or actions to minimize the user's effort in creating a useful charter according to the desired application context. Many ready made charter expressions and actions are preferably presented using the special terms from block  and relevant information determined at block . Relevancy determined at block  is application context dependent. Relevancy determined at block  may be application dependent, but is certainly based on special terms selected by the user at block . Block  may also determine relevancy by access to data of queue , statistics , LBX history , MS interoperability or any other LBX data providing guidance for automatically creating a useful charter. At block , the user may select, or create (e.g. drag and drop portions), one or more charters to be automatically created. A suitable user interface facilitating easy decisions, and well validated charter construction options is deployed. Only valid charters result when leaving block  for charter creation. Thereafter, block  checks whether the user selected to create one or more charters, or to create one or more charters and also configure permissions, or to configure permissions, or to exit processing.","If block  determines the user did not select to exit, then processing continues to block . If block  determines the user selected to configure permissions (e.g. perhaps to coincide with the new charters), then block  interfaces with the user for any charter associated relevant permission modifications (i.e. permissions determined to be relevant for the selected charter(s)), and processing continues to block , otherwise block  continues to block . If block  determines the user selected to continue charter creation from block , then processing continues to block . Block  updates charter data appropriately. Thereafter, block  terminates the  user interface, and processing terminates at block . Block  may update charters locally and\/or remotely as appropriate. See charter configuration processing already discussed above for additional information.","A preferred embodiment of block  incorporates processing of , however, it is preferred that the  processing be restricted and informative for being limited to managing permissions applicable to any charter(s) being created.","If block  determines the user selected to exit  processing, processing continues to block  for termination processing. If block  determines the user selected to exit  processing, processing continues to block  for termination processing. If block  determines the user selected to exit  processing, processing continues to block  for termination processing.","Application fields are preferably set in a WDR when it is completed for queue  insertion (for  processing). This ensures WDRs which are in-process to queue  contain the information at appropriate times. This also ensures the WDRs which are to be sent outbound contain the information at the appropriate time, and ensures the WDRs which are to be received inbound contain the information at the appropriate time. See  for an example embodiment. Fields may be set when processing at inbound time as well (e.g. by receive processing prior to being placed to queue ). Application fields can add a significant amount of storage to a WDR. Alternate embodiments may not maintain field to queue , but rather append information, or an appropriate subset thereof, to field when sending WDRs outbound to minimize storage WDRs utilize at a MS (e.g. at blocks  and ). This alternate embodiment will enable appropriate WITS processing for maintained WDRs, inbound WDRs, and outbound WDRs without an overhead of maintaining lots of data to queue , however application fields functionality will be limited to application data from an outbound originated perspective, rather than application field setting at the time of an in process WDR regardless of when it was in process. For example, field may alternatively be set at blocks  and  and then stripped after being processed by receiving MSs prior to any insertion to queue . In some embodiments, certain field data can be enabled or disabled for being present in WDR information.","WITS processing may modify the WDR (e.g. application fields ), or WDR related data at the MS, at a block , such that processing of block -continues to block  and block  continues to block . Block  will preferably modify WDR related statistics  and may modify the in-process WDR (e.g. strip, append, or alter applications fields section(s)) or any subset of data therein for any reason, including based on permissions , system settings, enabled\/disabled fields (sections) according to  (e.g. see  discussion), MS performance constraints, statistics , special terms (map term, atomic term, AppTerm, WDRTerm), application data, any other detectable configuration(s) and\/or condition(s). Block  may read-access the WDR for information (e.g. application fields) to use for related data maintenance or modification, and then incorporate WITS filtering to prevent any further processing of the WDR as was described above for blocks -and -(i.e. not continue processing the WDR in processing which includes  (i.e. , ,  )).","Preferably, there are WDRTerms for referencing each reasonable application fields section individually, as a subset, or as a set. For example, _appfld.appname.dataitem should resolve to the value of \u201cdataitem\u201d for the application section \u201cappname\u201d of application fields (i.e. \u201c_appfld\u201d). The hierarchy qualification operator (i.e. \u201c.\u201d) indicates which subordinate member is being referenced for which organization is use of field . The requirement is the organization be consistent in the LN-expanse (e.g. data values for anticipated application categories). For example, _appfld.email.source resolves to the email address associated with the email application of the MS which originated the WDR. For example, _appfld.phone.id resolves to the phone number associated with the phone application of the MS which originated the WDR (e.g. for embodiments where the MS ID is not the same as the MS caller id\/phone number). If a WDRTerm references an application field which is not present in a WDR, then preferably a run time error during WITS processing is logged with ignoring of the expression and any assigned action, or the applicable condition defaults to false. Preferably, a user has control for enabling any application subsets of data in field . Of course, appending, or setting, data in fields may involve first accessing needed data from memory , storage from secondary storage devices  such as persistent storage , a database, a file, or any other MS resource which maintains the specific application data.",{"@attributes":{"id":"p-1227","num":"2042"},"figref":["FIG. 77","FIG. 77"],"b":["1100","1100","1100"],"i":["k","k","k "]},"Application fields K specification processing begins at block  upon a user action for the user interface processing of , and continues to block  where the user is presented with options. Thereafter, block  waits for a user input\/action. The user is able to specify any of a plurality of application data for enablement or disablement in at least outbound WDR fields . Various embodiments will support enablement\/disablement for inbound, outbound, or any other in-process WDR event executable processing paths. Field can be viewed as containing application sections, each section containing data for a particular type of MS application, or a particular type of application data as described above.","Upon detection of a user action at block , block  checks if the user selected to enable a particular application section of fields . If block  determines the user selected to enable a particular application fields section, then block  sets the particular indicator for enabling that particular application fields section, and processing continues back to block . If block  determines the user did not select to enable a particular application fields section, then processing continues to block . If block  determines the user selected to disable a particular application fields section, then block  sets the particular indicator for disabling that particular application fields section, and processing continues back to block . If block  determines the user did not select to disable a particular application fields section, then processing continues to block . If block  determines the user selected to disable sending profile information in a application fields section, then block  sets the profile participation variable to NULL (i.e. disabled), and processing continues back to block . If block  determines the user did not select to disable sending profile information, then processing continues to block . If block  determines the user selected to enable sending profile information in a application fields section, then block  prompts the user for the file to be used for the profile (preferably the last used (or best used) file is defaulted in the interface), and block  interfaces with the user for a validated file path specification. The user may not be able to specify a validated profile specification at block  in which case the user can cancel out of block  processing. Thereafter, if block  determines the user cancelled out of block  processing, processing continues back to block . If block  determines the user specified a validated profile file, then block  sets the profile participation variable to the fully qualified path name of the profile file, and processing continues back to block . Block  preferably parses the profile to ensure it conforms to an LN-expanse standard format, or error processing is handled which prevents the user from leaving block  with an incorrect profile.","In an alternate embodiment, block  additionally internalizes the profile for well performing access (e.g. to a XML tag tree which can be processed). This alternate internalization embodiment for block  would additionally require performing internalization after every time the user modified the profile, in which case there could be a special editor used by the user for creating\/maintaining the profile, a special user post-edit process to cause internalization, or some other scheme for maintaining a suitable internalization. In an embodiment which internalizes the profile from a special editor, the special editor processing can also limit the user to what may be put in the profile, and validate its contents prior to internalization. An internalized profile is preferably always in correct parse-friendly form to facilitate performance when being accessed. In the embodiment of block  which sets the fully qualified path name of the profile file, a special editor may still be used as described, or any suitable editor may be used, but validation and obvious error handling may have to be performed when accessing the profile, if not validated by block  beyond a correct file path. Some embodiments may implement a profile in a storage embodiment that is not part of a file system.","If block  determines the user did not select to enable profile information to be maintained to field , then processing continues to block . If block  determines the user selected to exit  processing, application fields specification processing terminates appropriately at block . If block  determines the user did not select to exit, then processing continues to block  where any other user actions detected at block  are handled appropriately. Block  then continues back to block .","There can be many MS application sections of field which are enabled or disabled by blocks  through . In the preferred embodiment of profile processing, the profile is a human readable text file, and any file of the MS can be compared to a profile of a WDR so that the user can maintain many profiles for the purpose of comparisons in expressions. Alternate embodiments include a binary file, data maintained to some storage, or any other set of data which can be processed in a similar manner as described for profile processing. Some embodiments support specification of how to enable\/disable at blocks  through  derivatives for mWITS, iWITS and\/or oWITS.","In the preferred embodiment, a profile text file contains at least one tagged section, preferably using XML tags. Alternatively, Standard Generalized Markup Language (SGML) or HTML may be used for encoding text in the profile. There may be no standardized set of XML tags, although this would make for a universally consistent interoperability. The only requirement is that tags be used to define text strings which can be searched and compared. It helps for a plurality of users to know what tags each other uses so that comparisons can be made on a tag to tag basis between different profiles. A plurality of MS users should be aware of profile tags in use between each other so as to provide functionality for doing comparisons, otherwise profiles that use different tags cannot be compared.","Indicators disabled or enabled, as well as the profile participation variable is to be observed by WDR processing so that field is used accordingly. In some embodiments, certain application field sections cannot be enabled or disabled by users (i.e. a MS system setting). In preferred embodiments, WITS processing checks these settings to determine whether or not to perform applicable processing. In some embodiments, WITS processing checks these settings to strip out (e.g. for setting(s) disabled) information from a WDR which is to be in process.",{"@attributes":{"id":"p-1235","num":"2050"},"figref":"FIG. 78","b":["1100","7724"],"i":"k","ul":{"@attributes":{"id":"ul0174","list-style":"none"},"li":["#d:\\myprofs\\benchmark.xml>5\n\nThis condition determines if the benchmark.xml file contains greater than 5 tag section matches in the entire WDR profile of the WDR in process. Text elements of the lowest order tag sections are used to decide the comparison results. A tag hierarchy, if present, facilitates how to compare. Six (six) or more matches evaluates to true, otherwise the condition evaluates to false.\n","% d:\\myprofs\\benchmark.xml>=75\n\nThis condition determines if the benchmark.xml file contains greater than or equal to 75% of tag section matches in the entire WDR profile of the WDR in process. Contents that occurs between every tag is compared for a match. The number of matches found divided by the number of tag matches performed provides the percentage of matches (after multiplying the result by 100). The resulting percentage greater than or equal to 75% evaluates to true, otherwise the condition evaluates to false.\n","#(interests)d:\\myprofs\\benchmark.xml>2\n\nIn using  as an example, this condition determines if the benchmark.xml file contains greater than two (2) semicolon delimited matches within only the interests tag in the WDR profile of the WDR in process. If either the benchmark.xml file or the WDR profile does not contain the interests tag, then the condition evaluates to false. If both contain the interests tag, then the semicolon delimited items which is interests tag delimited are compared. Three (3) or more semicolon delimited interests that match evaluates to true, otherwise the condition evaluates to false.\n","% (home,hangouts)d:\\myprofs\\benchmark.xml>75\n\nThis condition determines if the benchmark.xml file contains greater than 75% matches when considering the two tags home and hangouts in the WDR profile of the WDR in process. Any number of tags, and any level of ascending tag hierarchy, can be specified within the ( . . . ) syntax. If either the benchmark.xml file or the WDR profile does not contain the tags for matching, then the condition evaluates to false. If both contain the sought tags for matching, then the text elements of the lowest order subordinate tags are treated as the items for compare. Of course, if the tags have no subordinate tags, then text elements would be compared that occurs between those tag delimiters. The number of matches found divided by the number of comparisons made provides the percentage of matches (after multiplying the result by 100). The resulting percentage greater than 75% evaluates to true, otherwise the condition evaluates to false.\n"]}},"WITS processing preferably uses an internalized form of  to perform comparisons. The internalized form may be established ahead of time as discussed above for better WITS processing performance, or may be manufactured by WITS processing in real time as needed.",{"@attributes":{"id":"p-1237","num":"2056"},"figref":["FIG. 79A","FIG. 79A","FIG. 78"],"b":["1","1","1","2","21","2","21","2","22","221","22","2","22","222","345","345","222","3"],"i":["j ","j ","k"]},{"@attributes":{"id":"p-1238","num":"2057"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"..."]},{"entry":[{},"home"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"city"]},{"entry":[{},"state"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"..."]},{"entry":[{},"interests"]},{"entry":[{},"..."]},{"entry":[{},"hangouts"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"morning"]},{"entry":[{},"lunch"]},{"entry":[{},"evening"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"..."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-1239","num":"2058"},"figref":["FIG. 79B","FIG. 79A","FIG. 79A","FIG. 79B","FIG. 79B","FIG. 79A","FIG. 79A","FIG. 79B","FIG. 79C"],"b":["1","56","58","56","58"]},{"@attributes":{"id":"p-1240","num":"2059"},"figref":"FIG. 79B","b":["11","11","1","11","11","11","11","12","121","2","121","2","122","1221","122","12","122","1222"],"i":["i","j ","j ","k"]},"Pointers, pointing to the left, point to the leftmost descending node (peer nodes on a tree are ordered). Pointers, pointing to the right, point to the next peer node. A tree node record contains Data (or at least one pointer to Data) and is indicated in  using the \u201cData\u201d prefix as a notation convention. The Data (i.e. data) in a node record is associated with the \u201cstuff\u201d between leaf node tags (e.g. Moorestown=\u201cstuff\u201d between city leaf node tags; basketball;programming;running;football=\u201cstuff\u201d between interests leaf node tags, etc). Data may be in any suitable form capable of storing\/representing the \u201cstuff\u201d between matching tag delimiters (e.g. <tagN>\u201cstuff\u201d<\/tagN>). In a preferred embodiment, only leaf node tags contain data and other tags have no (i.e. null) data, however data may be present for non-leaf node tags for \u201cstuff\u201d of a branch node for tag data matching embodiments that support \u201cstuff\u201d associated with non-leaf tags of an XML tag hierarchy.",{"@attributes":{"id":"p-1242","num":"2061"},"figref":["FIG. 79C","FIG. 79C","FIGS. 79A through 79D","FIGS. 38 through 48B"],"b":["4668","4670","4470","5744"]},"The XML_NODE type definition may or may not need a data_type field since data may always be the same type (e.g. null terminated strings such as in the  example which uses semicolons to delimit a plurality of data elements).",{"@attributes":{"id":"p-1244","num":"2063"},"figref":["FIG. 79D","FIG. 79C","FIG. 79C","FIG. 79D"],"b":["7952","5744","7954","7954","7954","1100","7954","7956"],"i":"k "},"If block  determines the profile match operator has not been qualified with specific tags for matching (in charter expression portion parameter), then block  sets a TAG_CHECK_LIST with a list of entries wherein each entry includes a XML tree leaf node tag name (e.g. interests) and associated tag element value (e.g. \u201cbasketball; programming; running; football\u201d). In another embodiment, block  may build a list of all tags in the XML tree and then maintain leaf node tag (within that tree node's descending scope) element data values concatenated together like a plurality of semicolon delimited data elements for compare as though the branch node was a leaf node with the element data. The tag hierarchy may, or may not, be maintained in the TAG_CHECK_LIST entry tag information for causing the tag path to have relevance in matching. Block  continues to block . If block  determines the profile match operator has been qualified with specific tags for matching (e.g. % (home,hangouts)d:\\myprofs\\benchmark.xml>75), then block  sets a TAG_CHECK_LIST with a list of entries wherein each entry includes a specified tag (e.g. home and hangouts) and their associated values (home: \u201cMoorestown; N.J.\u201d, and hangouts: \u201cStarbucks; Jammin's; Mongolian Barbeque; Confettis; Jimbos\u201d). The preferred embodiment concatenates descending leaf node tag values (within the tag node's scope) together like a larger leaf node. Another embodiment may maintain separate TAG_CHECK_LIST entries for unique branch paths from the specified tag to each descending leaf node tag so that tag hierarchy path information is considered in the compare. Block  continues to block .","Block  initializes counter variables: TAG_DATA_MATCH_ATTEMPTS=0 and TAG_DATA_MATCHES=0, and continues to block  for getting the next TAG_CHECK_LIST entry. Thereafter, if block  determines all entries from TAG_CHECK_LIST have not been processed, block  uses the associated data for the tag from the TAG_CHECK_LIST entry and attempts to access the data in an analogous manner (to building TAG_CHECK_LIST) from the attempt profile. Block  may, or may not, enforce a matching tag hierarchy to get to a matching tag.","Thereafter, if block  determines there was no matching tag in the attempt profile, or no data for a matched tag in the attempt profile, then block  increments the counter TAG_DATA_MATCH_ATTEMPTS by the number of data elements (e.g. semicolon delimited) in the TAG_CHECK_LIST entry data, and processing continues back to block . If block  determines the tag was found with element data in the attempt profile, block  gets the next data element (e.g. string up to semicolon or end of string) of the TAG_CHECK_LIST data entry. Thereafter, if block  determines the last element of data for the tag in the TAG_CHECK_LIST entry has been processed (or none was present to start with), then processing returns to block  for the next entry in the TAG_CHECK_LIST.","If block  determines there is a data element to process, then block  increments by 1 the TAG_DATA_MATCH_ATTEMPTS counter and block  checks if the data element is found in the attempt profile for the matched tag. If it is found, block  continues to block  where the TAG_DATA_MATCHES counter is incremented by 1 and processing returns to block  for processing the next (if any) data element. If block  determines the sought data is not found in the attempt profile data, then processing continues directly back to block .","Note that blocks  through  form a loop for iterating each data element (e.g. semicolon delimited) for the tag in the entry of TAG_CHECK_LIST for matching to data with the same tag in the attempt profile. If block  determines there are no more data elements to check, then processing continues back to block  for getting the next TAG_CHECK_LIST entry. Note that blocks  through  form a loop for iterating each TAG_CHECK_LIST entry for matching to data with the same tag in the attempt profile. A match is preferably made when the reference profile data element of block  appears in any subset of attempt profile data from block .","If block  determines that all TAG_CHECK_LIST entries have been processed, processing continues to block . If block  determines the profile match operator of the charter expression portion passed to  is the \u201c#\u201d operator, then block  checks the charter expression portion using TAG_DATA_MATCHES for evaluating the condition. If block  determines the condition is true, then block  returns a TRUE result to the caller (e.g. block  invoker processing), otherwise block  returns a FALSE result to the caller. If block  determines the profile match operator of the charter expression portion passed to  is the \u201c%\u201d operator, then block  calculates a percentage of matching using TAG_DATA_MATCHES and TAG_DATA_MATCH_ATTEMPTS (i.e. solve for x such that TAG_DATA_MATCHES\/TAG_DATA_MATCH_ATTEMPTS=x\/100) and block  checks the charter expression portion using the percentage calculated for evaluating the condition. If block  determines the condition is true, then block  returns a TRUE result to the caller (e.g. block  invoker processing), otherwise block  returns a FALSE result to the caller.","With reference now to , depicted is an example LBX application fields implementation status table  for being processed. As already discussed above, any section of applications field can be enabled, or disabled for being included in inbound, outbound, or any other in-process WDR, and a \u201csection\u201d may be an entire application section (i.e. all data within that application section), any subset of data within an application section, or any specific data item within an application section. Section is a broad term for being any subset of data in fields . Application fields processing (discussed with ) allows a MS user and\/or MS system settings to control:\n\n","Applications fields are preferably hierarchical sections for organizing data in an easily identifiable manner. Whether MS users use local applications or internet accessed applications (e.g. cloud computing), application fields communicated between MS users is important for interoperability. Any section of fields can be shared from one MS to another. Application fields is in at least the reference-able form: appfld.appname.dataitem such that appfld references field , appname references a specific application section of field and dataitem references a specific value (or set of values) in the application section. Some sections of fields are maintained in databases by the application and are accessed as needed (e.g. for WDR transmission, update from received WDR, etc). Syntactical references include forms: \\ref, _ref, _I_ref or _O_ref such that ref is equivalent to the field referenced: \\appfld.appname.dataitem, _appfld.appname.dataitem, _I_appfld.appname.dataitem, _O_appfld.appname.dataitem. There may be many sections and levels thereof to get to a data item. The form name. name. name . . . nameN is used as required to get to the lowest order data in a higher order section. Because of the very large number of subsets (sections) of fields , it is preferred that most, if not all, user controlled fields be disabled when a MS is powered up for the first time. The user can later enable features after learning to use a LBX enabled MS. Depending on the data embodiment for carrying data of fields , human readable names or corresponding parse-able binary identifiers are used. X.409 or a similar encoding may be used to carry data in fields . appfld section date\/time specs can use BNF grammar time specification methods.","Any subset of application fields can be moved to LBX History  for any reason at any time in MS processing, for example to keep a history of application contexts, states, data, occurrences thereof, etc",{"@attributes":{"id":"p-1254","num":"2076"},"figref":"FIG. 80A","b":"1100","i":"k ","ul":{"@attributes":{"id":"ul0177","list-style":"none"},"li":{"@attributes":{"id":"ul0177-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0178","list-style":"none"},"li":["1) Presented=new requirement(s) (e.g. ) presented to the board for making case of compelling value. The presentation may be as simple as an email, an escalated customer trouble ticket, or as serious as a live presentation. Those skilled in the art should be able to recognize alternatives for how to implement the application presented and the benefits of having such an application;","2) RFP=Request for Proposal of new requirement(s) (e.g. ) has been decided by the board for successfully presented requirement(s). The proposing party must formally submit their detailed proposal within the context of the LBX architecture before it is candidate for implementation; When an item is marked RFP, implementation is understood and documented, but additional details may be required;","3) Registered=An RFP has been accepted and is formally adopted for implementation in the LBX architecture (e.g. ). New privileges are implemented for appropriate interoperability between MSs. The registered requirement(s) are documented as part of subsequent LBX enabled product documentation. The scope of current implementation is documented as well;","4) Tabled=Requirement(s) were presented or RFP was considered, and it was decided to not pursue the requirement(s) in the LBX architecture (e.g. ). Reason(s) for being tabled is documented as part of records; and","5) Retired=Requirement(s) which were registered have been removed from the LBX architecture. Reason(s) for being retired is documented as part of records."]}}}},{"@attributes":{"id":"p-1255","num":"2082"},"figref":"FIG. 80B","b":["1100","1100","1100"],"i":["k","k","k "]},"Each data value of leaf nodes of a section hierarchy tree may be set by a MS user and\/or defaulted by a MS (see ). Permissions may be used to govern permissible values initialized or assigned. Application fields may be present to share with others (e.g. in the vicinity) for a variety of reasons, and the data can be accessed for user examination at the MS with an appropriate user interface. Some application fields require a database lookup when added to a WDR, otherwise high speed MS memory will be impacted for maintaining the data. With reference to , source section includes subordinate sections including the following examples:",{"@attributes":{"id":"p-1257","num":"2084"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["appfld.source.id.X","appfld.source.id.email ="]},{"entry":[{},"\u201cdavood.iyadi@lbxphone.com\u201d;"]},{"entry":[{},"appfld.source.id.phone = \u201c214-405-2323\u201d;"]},{"entry":[{},"appfld.source.id.calendar ="]},{"entry":[{},"\u201cdavood@lbxphone.com\u201d;"]},{"entry":[{},"appfld.source.id.ab = \u201cdavood@lbxphone.com\u201d;"]},{"entry":[{},"appfld.source.id.rfid = \u201c0A12:43EF:985B:012F\u201d;"]},{"entry":[{},"References to appfld.source.id in charter expressions"]},{"entry":[{},"contextually uses the correct ID data value based"]},{"entry":[{},"on the context of use. The fully qualified"]},{"entry":[{},"hierarchical name (e.g. appfld.source.id.email\u201d)"]},{"entry":[{},"may also be used explicitly."]},{"entry":["appfld.source.type","See BNF grammar atomic element \u201csystem type\u201d"]},{"entry":[{},"discussions."]},{"entry":["appfld.source.mfr","See BNF grammar atomic element \u201csystem type\u201d"]},{"entry":[{},"discussions for breaking out manufacturer from"]},{"entry":[{},"atomic element \u201csystem type\u201d."]},{"entry":["appfld.source.serno","See BNF grammar atomic element \u201clogical handle\u201d"]},{"entry":[{},"or \u201cphysical handle\u201d."]},{"entry":["appfld.source.ip","Suitable ip address(es) notation (e.g."]},{"entry":[{},"192.168.1.25; 50.46.123.2)"]},{"entry":[". . .",". . ."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"8002","i":"a "},"Profile section includes at least the appfld.profile.contents section containing profile information as discussed throughout this disclosure (e.g. XML or X.409 datastream).","Email section includes subordinate sections including the following examples:",{"@attributes":{"id":"p-1260","num":"2087"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["appfld.email.source","appfld.email.source = \u201cdavood.iyadi@lbxphone.com\u201d;"]},{"entry":[{},"This value is preferably used to default"]},{"entry":[{},"appfld.source.id.email, but can be changed based on"]},{"entry":[{},"permissions (e.g. specify different source address for"]},{"entry":[{},"emails)."]},{"entry":["appfld.email.default.-","Default attributes: appfld.email.attribute.cod = Y;"]},{"entry":["attribute.Y","appfld.email.attribute.urgent = N;"]},{"entry":[{},"appfld.email.attribute.charcode = 850; etc In one"]},{"entry":[{},"embodiment, the attribute section is a bit mask for"]},{"entry":[{},"enable\/disable of well known bit position attributes. There"]},{"entry":[{},"can be many attributes."]},{"entry":["appfld.email.default.-","Textual salutation may be shared with others. May be"]},{"entry":["salutation","null."]},{"entry":["appfld.email.default.-","Can inform others of preference."]},{"entry":"doctype"},{"entry":["appfld.email.default.-","Comma separated recipients for defaulting in an email"]},{"entry":["recips","recipient list. These are not defaulted into emails unless"]},{"entry":[{},"requested by the user during email composition. A"]},{"entry":[{},"special qualifier is used to specify the type of recipient"]},{"entry":[{},"(e.g. \u201cdavood.iyadi@lbxphone.com,"]},{"entry":[{},"cc:ravi.sirrayanan@lbxphone.com,"]},{"entry":[{},"bc:sam.sunn@lbxphone.com\u201d specifies a copy recipient"]},{"entry":[{},"ravi and a blind copy recipient sam. No qualifier is a"]},{"entry":[{},"primary recipient. There may be other qualifiers for other"]},{"entry":[{},"recipient types.)"]},{"entry":["appfld.email.default.-","Email encryption algorithm (settings for NONE (no"]},{"entry":["encrypt","encryption), DES, AES, RSA, Blowfish, or any other MS"]},{"entry":[{},"reference-able algorithm). May be null."]},{"entry":["appfld.email.default.-","Email compression algorithm settings for NONE, ZIP,"]},{"entry":["compress","LZO, LZX or any other MS reference-able algorithm),"]},{"entry":[{},"May be null."]},{"entry":["appfld.email.default.$","$ = other field sections."]},{"entry":["appfld.email.type","Email app type\/name can inform others which email"]},{"entry":[{},"application is used."]},{"entry":["appfld.email.pending.-","Attributes of pending email being composed:"]},{"entry":["attribute.Y","appfld.email.attribute.cod = N;"]},{"entry":[{},"appfld.email.attribute.urgent = N;"]},{"entry":[{},"appfld.email.attribute.charcode = 850; etc In one"]},{"entry":[{},"embodiment, the attribute section is a bit mask for"]},{"entry":[{},"enable\/disable of well known bit position attributes. There"]},{"entry":[{},"can be many attributes."]},{"entry":["appfld.email. pending.-","Textual salutation if present in composed email. May be"]},{"entry":["salutation","null."]},{"entry":["appfld.email.pending.-","Doc type of email being composed."]},{"entry":"doctype"},{"entry":["appfld.email.pending.-","Comma separated recipients for email underway using"]},{"entry":["recips","qualifiers discussed above."]},{"entry":["appfld.email.pending.-","Email encryption algorithm to be used as described"]},{"entry":["encrypt","above. May be null."]},{"entry":["appfld.email.pending.-","Compression algorithm to be used as described above."]},{"entry":["compress","May be null.-"]},{"entry":["appfld.email.pending.cdt","Email initial creation date\/time stamp for pending or last"]},{"entry":[{},"entry."]},{"entry":["appfld.email.pending.-","Email data (e.g. email body, attachment(s), etc) for"]},{"entry":["content","transporting between MSs. This enables a peer to peer"]},{"entry":[{},"email delivery (see MS2MS processing). No email"]},{"entry":[{},"service is required for MS users to talk to each other."]},{"entry":[{},"appfld.email.pending.content.body = the currently"]},{"entry":[{},"constructed email body being composed for sending."]},{"entry":[{},"Attachments are referenced with"]},{"entry":[{},"appfld.email.pending.content.attach.ct for the number (ct ="]},{"entry":[{},"count) of attachments and"]},{"entry":[{},"appfld.email.pending.content.attach.# (1 for first, 2 for"]},{"entry":[{},"second, etc.) for an email currently being composed"]},{"entry":[{},"which has not been sent yet. SMS messages may use"]},{"entry":[{},"this same mechanism. See content subordinate fields"]},{"entry":[{},"discussed above."]},{"entry":["appfld.email.pending.$","$ = other field sections."]},{"entry":["appfld.email.last.sent.ANY.-","Attributes of email last sent to anyone from MS:"]},{"entry":["attribute.Y","appfld.email.attribute.cod = N;"]},{"entry":[{},"appfld.email.attribute.urgent = N;"]},{"entry":[{},"appfld.email.attribute.charcode = 850; etc In one"]},{"entry":[{},"embodiment, the attribute section is a bit mask for"]},{"entry":[{},"enable\/disable of well known bit position attributes. There"]},{"entry":[{},"can be many attributes."]},{"entry":["appfld.email.last.sent.ANY.-","Textual salutation of email last sent to anyone from MS."]},{"entry":"salutation"},{"entry":["appfld.email.last.sent.ANY.-","Doc type of email last sent to anyone from MS."]},{"entry":"doctype"},{"entry":["appfld.email.last.sent.ANY.-","Comma separated recipients of email last sent to anyone"]},{"entry":["recips","from MS."]},{"entry":["appfld.email.last.sent.ANY.-","Email encryption algorithm indicator of email last sent to"]},{"entry":["encrypt","anyone from MS."]},{"entry":["appfld.email.last.sent.ANY.-","Compression algorithm indicator of email last sent to"]},{"entry":["compress","anyone from MS."]},{"entry":["appfld.email.last.sent.ANY.-","Email initial creation date\/time stamp of email last sent to"]},{"entry":["cdt","anyone from MS."]},{"entry":["appfld.email.last.sent.ANY.-","Email data (e.g. email body, attachment(s), etc) of email"]},{"entry":["content","last sent to anyone from MS for transporting between"]},{"entry":[{},"MSs. This enables a peer to peer email delivery (see"]},{"entry":[{},"MS2MS processing). No email service is required for MS"]},{"entry":[{},"users to talk to each other."]},{"entry":[{},"appfld.email.pending.content.body,"]},{"entry":[{},"appfld.email.pending.content.attach.ct, and"]},{"entry":[{},"appfld.email.pending.content.attach.# are analogous to"]},{"entry":[{},"above for the last sent email to anyone from the MS."]},{"entry":["appfld.email.last.sent.ANY.$","$ = other field sections."]},{"entry":["appfld.email.last.sent.-","There is a field here for each"]},{"entry":["{id}.*","appfld.email.last.sent.ANY.* field above, however a"]},{"entry":[{},"specific id can be specified (e.g. joe@yahoo.com). This"]},{"entry":[{},"allows access to fields of the most recently sent email"]},{"entry":[{},"item to a specific recipient. There are a plurality of fields"]},{"entry":[{},"(i.e. *) represented by this row to prevent redundantly"]},{"entry":[{},"listing each field again for an appfld.email.last.sent.{id}"]},{"entry":[{},"section . . ."]},{"entry":["appfld.email.last.rcvd.-","There is a field here for each"]},{"entry":["ANY.*","appfld.email.last.sent.ANY.* field above, however rcvd"]},{"entry":[{},"qualifier indicates that each field is for the most recent"]},{"entry":[{},"email received by the MS from anyone. There are a"]},{"entry":[{},"plurality of fields (i.e. *) represented by this row to"]},{"entry":[{},"prevent redundantly listing each field again for an"]},{"entry":[{},"appfld.email.last.rcvd.ANY section . . ."]},{"entry":["appfld.email.last.rcvd.-","There is a field here for each"]},{"entry":["{id}.*","appfld.email.last.rcvd.ANY.* field above, however a"]},{"entry":[{},"specific id can be specified (e.g. joe@yahoo.com). This"]},{"entry":[{},"allows access to fields of the most recently received"]},{"entry":[{},"email item from a specific recipient. There are a plurality"]},{"entry":[{},"of fields (i.e. *) represented by this row to prevent"]},{"entry":[{},"redundantly listing each field again for an"]},{"entry":[{},"appfld.email.last.rcvd.{id} section . . ."]},{"entry":[". . . other field sections . . .",". . ."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"8002","i":"c "},"Address Book (AB) section includes subordinate sections including the following examples:",{"@attributes":{"id":"p-1262","num":"2089"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["appfld.ab.id","This value is preferably used to default"]},{"entry":[{},"appfld.source.id.ab, but can be changed based on"]},{"entry":[{},"permissions."]},{"entry":["appfld.ab.default.-","Defaults for composing AB entries:"]},{"entry":["attribute.Y","appfld.ab.default.attribute.marker = NONE or specific"]},{"entry":[{},"visual marker type for entry created;"]},{"entry":[{},"appfld.ab.default.attribute.color = color of entry in"]},{"entry":[{},"address book;"]},{"entry":[{},"appfld.ab.default.attribute.font = font used for text;"]},{"entry":[{},"appfld.ab.default.attribute.size = size of font used. In one"]},{"entry":[{},"embodiment, the attribute section is a bit mask for"]},{"entry":[{},"enable\/disable of well known bit position attributes. There"]},{"entry":[{},"can be many attributes."]},{"entry":["appfld.ab.default.-","Background color, pattern, tiled picture, stretched picture,"]},{"entry":["background","and\/or animation file (e.g. HTML). May be null."]},{"entry":["appfld.ab.default.$","$ = other field sections."]},{"entry":["appfld.ab.type","AB app type\/name can inform others which application is"]},{"entry":[{},"used."]},{"entry":["appfld.ab.pending.-","Attributes of pending AB entry being composed as"]},{"entry":["attribute.Y","described above. In one embodiment, the attribute"]},{"entry":[{},"section is a bit mask for enable\/disable of well known bit"]},{"entry":[{},"position attributes."]},{"entry":["appfld.ab.pending.-","Background color, pattern, tiled picture, stretched picture,"]},{"entry":["background","and\/or animation file (e.g. HTML) for pending\/composed"]},{"entry":[{},"entry. May be null."]},{"entry":["appfld.ab.pending.cdt","AB initial creation date\/time stamp for pending entry."]},{"entry":["appfld.ab.pending.-","AB data (e.g. ab body, attachment(s), etc) being created,"]},{"entry":["content","which may be transported between MSs. This enables a"]},{"entry":[{},"peer to peer AB delivery (see MS2MS processing). No"]},{"entry":[{},"service is required for MS users to talk to each other."]},{"entry":[{},"appfld.ab.pending.content.name = the currently"]},{"entry":[{},"constructed AB entry name or reference to entry."]},{"entry":[{},"appfld.ab.pending.content.body = the currently"]},{"entry":[{},"constructed AB entry body being composed."]},{"entry":[{},"Attachments are supported with"]},{"entry":[{},"appfld.ab.pending.content.attach.ct for the number (ct ="]},{"entry":[{},"count) of attachments and"]},{"entry":[{},"appfld.ab.pending.content.attach.# (1 for first, 2 for"]},{"entry":[{},"second, etc.) for an AB entry being composed (i.e."]},{"entry":[{},"pending)."]},{"entry":["appfld.ab.pending.group","Optional group(s) (delimited if plural) tagging the AB"]},{"entry":[{},"entry for organization (e.g. Family; Cousins). May be null."]},{"entry":["appfld.ab.pending.$","$ = other field sections."]},{"entry":["appfld.ab.last.local.ANY.-","Attributes of AB entry last created locally wherein"]},{"entry":["attribute.Y",".attribute.Y described above for"]},{"entry":[{},"appfld.ab.default.attribute.Y."]},{"entry":["appfld.ab.last.local.ANY.-","Background color, pattern, tiled picture, stretched picture,"]},{"entry":["background","and\/or animation file (e.g. HTML) of last completed AB"]},{"entry":[{},"entry at MS."]},{"entry":["appfld.ab.last.local.ANY.-","AB creation date\/time stamp of AB entry last created at"]},{"entry":["cdt","MS."]},{"entry":["appfld.ab.last.local.ANY.-","AB data (e.g. body, attachment(s), etc) of AB entry last"]},{"entry":["content","created at MS. See above for field section descriptions."]},{"entry":["appfld.ab.last.local.ANY.-","Optional group(s) tagging the AB entry last created at"]},{"entry":["group","MS."]},{"entry":["appfld.ab.last.local.ANY.$","$ = other field sections."]},{"entry":["appfld.ab.last.local.-","There is a field here for each appfld.ab.last.local.ANY.*"]},{"entry":["{id}.*","field above, however a specific id can be specified (e.g."]},{"entry":[{},"joe@yahoo.com). This allows access to fields of the"]},{"entry":[{},"most recently created AB item for a specific person (e.g."]},{"entry":[{},"MS user). There are a plurality of fields (i.e. *)"]},{"entry":[{},"represented by this row to prevent redundantly listing"]},{"entry":[{},"each field again for an appfld.ab.last.local.{id}section . . ."]},{"entry":["appfld.ab.last.other.-","There is a field here for each appfld.ab.last.local.ANY.*"]},{"entry":["ANY.*","field above, however the other qualifier indicates that"]},{"entry":[{},"each field is for the most recent AB entry created by"]},{"entry":[{},"another user (e.g. received by the MS from anyone)."]},{"entry":[{},"There are a plurality of fields (i.e. *) represented by this"]},{"entry":[{},"row to prevent redundantly listing each field again for an"]},{"entry":[{},"appfld.ab.last.other.ANY section . . ."]},{"entry":["appfld.ab.last.other.-","There is a field here for each appfld.ab.last.other.ANY.*"]},{"entry":["{id}.*","field above, however a specific id can be specified (e.g."]},{"entry":[{},"joe@yahoo.com). This allows access to fields of the"]},{"entry":[{},"most recently created AB item from a specific user."]},{"entry":[{},"There are a plurality of fields (i.e. *) represented by this"]},{"entry":[{},"row to prevent redundantly listing each field again for an"]},{"entry":[{},"appfld.ab.last.other.{id} section . . ."]},{"entry":[". . . other field sections . . .",". . ."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"8002","i":"e "},"Calendar section includes subordinate sections including the following examples:",{"@attributes":{"id":"p-1264","num":"2091"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["appfld.calendar.id","This value is preferably used to default"]},{"entry":[{},"appfld.source.id.calendar, but can be changed based"]},{"entry":[{},"on permissions."]},{"entry":["appfld.calendar.default.","Defaults for composing CALENDAR entries:"]},{"entry":["attribute.Y","appfld.calendar.default.attribute.cod = confirmation of"]},{"entry":[{},"delivery of meeting notice;"]},{"entry":[{},"appfld.calendar.default.attribute.urgent = mark"]},{"entry":[{},"calendar entry\/notice as urgent;"]},{"entry":[{},"appfld.calendar.default.attribute.color = color for"]},{"entry":[{},"highlight of entry or NONE;"]},{"entry":[{},"In one embodiment, the attribute section is a bit mask"]},{"entry":[{},"for enable\/disable of well known bit position"]},{"entry":[{},"attributes. There can be many attributes."]},{"entry":["appfld.calendar.default.","Comma separated recipients for defaulting in a"]},{"entry":["recips","calendar notice recipient list. These are not defaulted"]},{"entry":[{},"into meeting notices unless requested by the user"]},{"entry":[{},"during composition. A special qualifier can used to"]},{"entry":[{},"specify the type of recipient (e.g."]},{"entry":[{},"\u201cdavood.iyadi@lbxphone.com,"]},{"entry":[{},"cc:ravi.sirrayanan@lbxphone.com,"]},{"entry":[{},"bc:sam.sunn@lbxphone.com\u201d specifies a copy"]},{"entry":[{},"recipient ravi and a blind copy recipient sam. No"]},{"entry":[{},"qualifier is a required attendee. There may be other"]},{"entry":[{},"qualifiers for other recipient types.)"]},{"entry":["appfld.calendar.default.","Can share with others whether you permit meeting"]},{"entry":["camp","notices created by others to camp on one of your"]},{"entry":[{},"calendar entries already scheduled. Then, if the"]},{"entry":[{},"original meeting is cancelled, the camped-on meeting"]},{"entry":[{},"becomes scheduled and attendees are automatically"]},{"entry":[{},"notified. True or False."]},{"entry":["appfld.calendar.default.$","$ = other field sections."]},{"entry":["appfld.calendar.type","CALENDAR app type\/name can inform others which"]},{"entry":[{},"application is used."]},{"entry":["appfld.calendar.pending.","Attributes of pending CALENDAR entry being"]},{"entry":["attribute.Y","composed as described above. In one embodiment,"]},{"entry":[{},"the attribute section is a bit mask for enable\/disable"]},{"entry":[{},"of well known bit position attributes."]},{"entry":["appfld.calendar.pending.","Recipients of calendar entry being composed."]},{"entry":"recips"},{"entry":["appfld.calendar.pending.","Camp-on permission of calendar entry being"]},{"entry":["camp","composed."]},{"entry":["appfld.calendar.pending.cdt","CALENDAR initial creation date\/time stamp for"]},{"entry":[{},"pending entry."]},{"entry":["appfld.calendar.pending.","CALENDAR data (e.g. calendar body, attachment(s),"]},{"entry":["content","etc) being created, which may be transported"]},{"entry":[{},"between MSs. This enables a peer to peer"]},{"entry":[{},"CALENDAR delivery (see MS2MS processing). No"]},{"entry":[{},"service is required for MS users to talk to each other."]},{"entry":[{},"appfld.calendar.pending.content.subj = the subject of"]},{"entry":[{},"the calendar notice."]},{"entry":[{},"appfld.calendar.pending.content.body = the currently"]},{"entry":[{},"constructed CALENDAR entry body being composed."]},{"entry":[{},"Attachments are supported with"]},{"entry":[{},"appfld.calendar.pending.content.attach.ct for the"]},{"entry":[{},"number (ct = count) of attachments and"]},{"entry":[{},"appfld.calendar.pending.content.attach.# (1 for first, 2"]},{"entry":[{},"for second, etc.) for an CALENDAR entry being"]},{"entry":[{},"composed (i.e. pending)."]},{"entry":["appfld.calendar.pending.","CALENDAR scheduling information (when"]},{"entry":["datetimes","scheduled)."]},{"entry":["appfld.calendar.pending.","CALENDAR appointment recurring information (e.g."]},{"entry":["recurring","every week, every month, etc) of composed calendar"]},{"entry":[{},"entry. May be null."]},{"entry":["appfld.calendar.pending.$","$ = other field sections."]},{"entry":["appfld.calendar.last.local.ANY.","Attributes of CALENDAR entry last created locally"]},{"entry":["attribute.Y","wherein attribute.Y described above for"]},{"entry":[{},"appfld.calendar.default.attribute.Y."]},{"entry":["appfld.calendar.last.local.ANY.","Same as appfld.calendar.default.recips except for the"]},{"entry":["recips","last entry created locally."]},{"entry":["appfld.calendar.last.local.ANY.","Same as appfld.calendar.default.camp except for the"]},{"entry":["camp","last entry created locally."]},{"entry":["appfld.calendar.last.local.ANY.","CALENDAR creation date\/time stamp of CALENDAR"]},{"entry":["cdt","entry last created at MS."]},{"entry":["appfld.calendar.last.local.ANY.","CALENDAR data (e.g. body, attachment(s), etc) of"]},{"entry":["content","CALENDAR entry last created at MS. See above for"]},{"entry":[{},"field section descriptions."]},{"entry":["appfld.calendar.last.local.ANY.","Same as appfld.calendar.default.datetimes except for"]},{"entry":["datetimes","the last entry created locally."]},{"entry":["appfld.calendar.last.local.ANY.","Same as appfld.calendar.default.recurring except for"]},{"entry":["recurring","the last entry created locally."]},{"entry":["appfld.calendar.last.local.ANY.$","$ = other field sections."]},{"entry":["appfld.calendar.last.local.","There is a field here for each"]},{"entry":["{id}.*","appfld.calendar.last.local.ANY.* field above, however"]},{"entry":[{},"a specific id can be specified (e.g. joe@yahoo.com)."]},{"entry":[{},"This allows access to fields of the most recently"]},{"entry":[{},"created CALENDAR item for a specific person (e.g."]},{"entry":[{},"MS user). There are a plurality of fields (i.e. *)"]},{"entry":[{},"represented by this row to prevent redundantly listing"]},{"entry":[{},"each field again for an appfld.calendar.last.local.{id}"]},{"entry":[{},"section . . ."]},{"entry":["appfld.calendar.last.other.","There is a field here for each"]},{"entry":["ANY.*","appfld.calendar.last.local.ANY.* field above, however"]},{"entry":[{},"the other qualifier indicates that each field is for the"]},{"entry":[{},"most recent CALENDAR entry created by another"]},{"entry":[{},"user (e.g. received by the MS from anyone). There"]},{"entry":[{},"are a plurality of fields (i.e. *) represented by this row"]},{"entry":[{},"to prevent redundantly listing each field again for an"]},{"entry":[{},"appfld.calendar.last.other.ANY section . . ."]},{"entry":["appfld.calendar.last.other.","There is a field here for each"]},{"entry":["{id}.*","appfld.calendar.last.other.ANY.* field above, however"]},{"entry":[{},"a specific id can be specified (e.g. joe@yahoo.com)."]},{"entry":[{},"This allows access to fields of the most recently"]},{"entry":[{},"created CALENDAR item from a specific user. There"]},{"entry":[{},"are a plurality of fields (i.e. *) represented by this row"]},{"entry":[{},"to prevent redundantly listing each field again for an"]},{"entry":[{},"appfld.calendar.last.other.{id} section . . ."]},{"entry":["appfld.calendar.next.X","Always contains the next forthcoming (wrt current MS"]},{"entry":[{},"date\/time) appointment calendar entry information"]},{"entry":[{},"such as date\/time stamp, attendees, location, etc in"]},{"entry":[{},"form: appfld.calendar.next.X for each section (field)"]},{"entry":[{},"X. Can share as appropriate."]},{"entry":["appfld.calendar.nextavail.X","Can share your next free period of time X on your"]},{"entry":[{},"calendar wrt current MS date\/time, such that X is"]},{"entry":[{},"hour (e.g. appfld.calendar.nextavail.hour), day, week,"]},{"entry":[{},"etc. There are many embodiments for permitted"]},{"entry":[{},"forthcoming periods of time available."]},{"entry":["appfld.calendar.sched.X","Can share any specified calendar portion schedule"]},{"entry":[{},"with others. Embodiments support an X section for"]},{"entry":[{},"any conceivable subset of time of a calendar. The X"]},{"entry":[{},"field is parse-able data (e.g. string) for information."]},{"entry":[". . . other field sections . . .",". . ."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"8002","i":"d "},"Phone section includes subordinate sections including the following examples:",{"@attributes":{"id":"p-1266","num":"2093"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["appfld.phone.id","= (e.g. \u201c214-405-9999\u201d) The real MS caller id which"]},{"entry":[{},"cannot be changed. This number is provided by the"]},{"entry":[{},"telecommunications service provider, or by the peer"]},{"entry":[{},"to peer MS telephone plan. Can be shared with"]},{"entry":[{},"others. This value is preferably used to default"]},{"entry":[{},"appfld.source.id.phone, but can be changed based"]},{"entry":[{},"on permissions (e.g. specify different phone id)."]},{"entry":["appfld.phone.default.","Phone call default volume."]},{"entry":"volume"},{"entry":["appfld.phone.default.","Phone call default encryption algorithm for outgoing"]},{"entry":["encrypt","voice call. Receiving system recognizes that call is"]},{"entry":[{},"encrypted and handles appropriately. See encryption"]},{"entry":[{},"choices discussed above. May be null."]},{"entry":["appfld.phone.default.","Phone call default compression algorithm for"]},{"entry":["compress","outgoing voice call. Receiving system recognizes that"]},{"entry":[{},"call is compressed and handles appropriately. See"]},{"entry":[{},"compression choices discussed above. May be null."]},{"entry":["appfld.phone.default.","Phone call default camp-on variable which when true"]},{"entry":["camp","allows callers to camp-on a busy phone call session"]},{"entry":[{},"(i.e. call waiting) in a priority order. A unique call"]},{"entry":[{},"waiting tone notifies the MS user for each new party"]},{"entry":[{},"camped-on."]},{"entry":["appfld.phone.default.$","$ = other field sections."]},{"entry":["appfld.phone.caller","Can override appfld.phone.id with a different caller id"]},{"entry":[{},"for the MS if appropriate privileges exist. This allows"]},{"entry":[{},"overriding a real caller id with an acceptable text"]},{"entry":[{},"string."]},{"entry":["appfld.phone.log.in","Log for calls received by the MS (analogous to a cell"]},{"entry":[{},"phone log with historical number)."]},{"entry":["appfld.phone.log.out","Log for calls made by the MS (analogous to a cell"]},{"entry":[{},"phone log with historical number)."]},{"entry":["appfld.phone.log.missed","Log for calls missed by the MS (analogous to a cell"]},{"entry":[{},"phone log with historical number)."]},{"entry":["appfld.phone.log.vmail","Log for calls that left message to voice mail at the"]},{"entry":[{},"MS (analogous to a cell phone log with historical"]},{"entry":[{},"number)."]},{"entry":["appfld.phone.log.$","$ = other log field sections."]},{"entry":["appfld.phone.record.X","appfld.phone.record.rx = True (record voice data of"]},{"entry":[{},"all calls received); appfld.phone.record.tx = False (do"]},{"entry":[{},"not record voice data of all calls made from MS:"]},{"entry":[{},"False is the default so need not be specified);"]},{"entry":[{},"appfld.phone.record.713-303-8900 = True (record"]},{"entry":[{},"calls made to, or received from 713-303-8900);"]},{"entry":[{},"appfld.phone.record.tx:713-303-8900 = True (record"]},{"entry":[{},"calls made to 713-303-8900);"]},{"entry":[{},"appfld.phone.record.rx:713-303-8900 = True (record"]},{"entry":[{},"calls received from 713-303-8900); Other"]},{"entry":[{},"embodiments will support other prefixes for qualifying"]},{"entry":[{},"what to do with recording a specific number (e.g."]},{"entry":[{},"appfld.phone.record.tx,Houston:713-303-8900 = 
