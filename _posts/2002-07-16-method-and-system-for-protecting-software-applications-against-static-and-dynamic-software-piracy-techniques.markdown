---
title: Method and system for protecting software applications against static and dynamic software piracy techniques
abstract: An application module is rewritten by overwriting executable code at identified authorization points with control transfers to a managed challenge system such that a rewritten application module results. The managed challenge system is constructed to include the overwritten executable code, and performs an authorization check upon acquiring control from an authorization point. The managed challenge system is linked to the rewritten application module.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07111285&OS=07111285&RS=07111285
owner: Liquid Machines, Inc.
number: 07111285
owner_city: Waltham
owner_country: US
publication_date: 20020716
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims the benefit of U.S. Provisional Application No. 60\/306,088, filed Jul. 17, 2001. The entire teachings of the above application(s) are incorporated herein by reference.","As enterprises rely more and more heavily on computers and electronic transactions for their daily business, there is an increasing demand for technologies that can secure these systems, their applications, and their associated digital content from unauthorized use and distribution. A \u201clicensed application\u201d may be considered to be an application that is meant to be protected from unauthorized use and distribution; \u201cprotected content\u201d is digital data that is desired to be similarly secured. Unlike the mechanical engines and material outputs of physical systems, it is difficult to secure applications and digital content because both are easily copied, altered, distributed, and ultimately misused.","For purposes of discussion, a \u201clicense\u201d comprises the authorized rights of an end user with respect to the protected material. A license often comprises a use agreement and one or more digital values that help enforce the terms of that agreement. The term \u201clicense file\u201d is used herein to distinguish these digital values from the more general notion of an end-user's rights, though the tangible form of said values and their associated authorizations need not be a traditional computer file. Furthermore, the protected material may be encrypted.","License files are used by industry as part of the runtime authorization mechanisms used to enforce use agreements on an end user's system and ultimately to thwart piracy. The focused goal of piracy is license subversion: the successful execution of a licensed application, a licensed application module, or an application manipulating protected content without a valid license. In some application domains, the license enforcement system is also called an authorization system, and the goal of license subversion is to bypass the runtime authorization mechanisms. Conversely, the goal of those in the domain of software protection is runtime license enforcement.","The practice of runtime license enforcement commonly involves an application module, a license file, and two additional software entities that together comprise the actual, software-based license enforcement system. (Although it is possible to build hardware-based license enforcement systems, such systems are rare because they require specialized memory or processing resources that are not generally or widely available.)",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},"The application module A  in  may be a piece of a larger application, or it may comprise the entire application. The license file L  authorizes an end user to execute the application module A (i.e., as a licensed application), or it may enable the application module A  to access or manipulate protected content in a data file (not shown).","The challenge system C  provides mechanisms for controlling execution of the application module A . It interacts with the response system R  to verify that an end user has the right to execute the application module A , and it prevents further program execution whenever authorization fails.","The response system R  reacts to a verification request from the challenge system C  by reading, validating, or in some way interacting with the license file L . Effective, software-based license enforcement systems generally contain all of the logical components illustrated in .","The challenge system C  and the response system R  together make up the license enforcement system , also called an authorization system.","It should be emphasized that  is a conceptual representation of the entities involved in runtime license enforcement. In particular, application module A  should be viewed as the set of bits that implement all of the required functionality of A, except for that functionality required for protection from software piracy. In other words, application module A  does not include any capability for reading, validating, or more generally interacting with the license file L , nor does it have the capacity to affect its own execution based on the result of license validation.","An embodiment of the present invention includes a software-based method that improves the security of both licensed applications and protected content.","Current security technologies provide only a partial solution to the problems of unauthorized use. Cryptographic techniques, for example, can be used to secure both applications and digital content, but they only secure applications and digital content while they reside on or travel through untrusted environments. The strong protection provided by cryptographic techniques ends at the point when a licensed application or protected content is decrypted.","Whether one is trying to protect a software application or digital content manipulated by such an application, a solution is needed that extends protection through program execution. In other words, mechanisms are needed to defend against changes enacted in applications for the purpose of subverting the runtime authorization mechanisms enforcing the protection around a licensed application or protected content.","The present invention addresses such acts of software piracy, including both static attacks (i.e., those made against applications as they reside on disk) and dynamic attacks (i.e., those made against the runtime memory image of applications).","Accordingly, the invention method for protecting a software application module includes rewriting the application module by overwriting executable code at identified authorization points with control transfers to a managed challenge system such that a rewritten application module results. The managed challenge system is constructed to include the overwritten executable code, and performs an authorization check upon acquiring control from an authorization point. Finally, the managed challenge system is linked to the rewritten application module.","The authorization points may be identified in the software application module, for example, by identifying or determining special pragmas used for code and\/or data protection. These pragmas may be associated with the source code of the application module at the authorization points, for example as a separate file, or they may be directly embedded into or attached to the source code. A compiler may be modified or written to recognize the special pragmas, and to then perform the steps of rewriting, constructing and linking based on these pragmas. Each special pragma may comprise authorization check data for its associated authorization point.","Alternatively, authorization points may be identified by producing a set of associations between authorization points and authorization check data, where rewriting the application module is based on the set of associations.","Alternatively, authorization points may be identified by constructing a control flow graph for the application module, and analyzing the control flow graph to identify authorization points. The control flow graph may be either complete or incomplete. If incomplete, its coverage may be increased by tracing the execution of the application module under different input data sets.","A particular authorization check may be associated with an identified authorization point. Each control transfer may be uniquely identified.","A control transfer may be implemented with an instruction sequence comprising one or more instructions, where the instruction sequence causes a runtime exception. An address of the instruction sequence may be used to uniquely identify the control transfer. Control transfer may be accomplished, by an instruction sequence that contains, for example, an interrupt instruction, or a debug breakpoint instruction.","A control transfer may be implemented with a call to the managed challenge system. The call may include a return address that uniquely identifies the control transfer.","Furthermore, in the rewritten application module, the control transfers to the managed challenge system may be hidden. This may be done, for a particular identified authorization point, by selecting and removing a set of control transfers whose removal effectively makes finding the authorization point using static analysis impossible. This selecting and removing may be accomplished by removing control transfers until the possibility of reaching the authorization point is minimized. The control transfers to be removed may be selected using a control flow graph.","The set of control transfers may be selected such that any runtime overhead is minimized.","Removing one of the control transfers may be performed by further rewriting the application module by overwriting the control transfer with a control transfer instruction sequence, which may include one or more instructions, and transferring control, upon execution of the sequence, to the managed challenge system. The control transfer that was overwritten is then included in the managed challenge system.","Furthermore, where a byte sequence in the application module matches one of said control transfers but does not correspond with an identified authorization point, dummy code, to be associated with the byte sequence, may be included in the managed challenge system. For example, if the byte 0xCC (opcode for an INT  instruction in the Intel \u00d786 instruction set) appears in the immediate field of another instruction, dummy code may be generated for it, so that an adversary looking at just the executable code could not tell that it was not an INT  instruction.","Execution or inclusion of the dummy code may be disabled if the byte sequence is a valid instruction. Including the dummy code may be responsive to a determination as to whether the byte sequence is part of another valid instruction.","Upon failure of the authorization check, a specified action may be performed, such as terminating execution of the application module, or requesting authorization information from a user.","Upon success of the authorization check, the included overwritten executable code may be executed and control returned to the application module.","The included overwritten executable code may be further modified to account for its displacement.","Furthermore, the included overwritten executable code may be combined with code for the authorization check into a single instruction sequence, for example, by merging the included overwritten executable code with the authorization check code by interspersing their respective instructions.","In addition, the executable code may be obfuscated within the managed challenge system.","Various code may be stored in a table in the managed challenge system. This code may include, but is not limited to: i) merged code sequences corresponding to authorization points in the application module; ii) hidden code sequences corresponding to removed control transfers in the application module; and\/or iii) dummy code sequences corresponding to non-authorization point code sequences. The table may be indexed by a unique identifier associated with each control transfer in the application module.","Furthermore, any or all of the code stored in the table may be encrypted.","Upon transfer of control to the managed challenge system, an executable code sequence may be dynamically generated from an entry in the table corresponding to an identifier associated with the control transfer from which control was transferred to the managed challenge system. The generated executable code sequences may then be maintained in a code cache of the managed challenge system. The code cache itself may be intentionally sized such that it is not large enough to simultaneously contain all dynamically created code sequences, so that it is impossible for the entire application executable to exist in memory at any given time.","Any overhead due to the dynamic generation of an executable code sequence may be tracked. Based on such overhead tracking, a decision may be made as to whether to undo the rewriting of all or parts of the application module.","Where the steps of rewriting, constructing and linking are performed by a compiler, the compiler may create a shared object that includes the managed challenge system and that is linked with the rewritten application module.","The rewriting may be further be accomplished, without access to source code, by instrumenting the application module's executable code.","In one embodiment of the invention, the application module may be a content protection module.","Furthermore, different byte sequences may be used to transfer control to the managed challenge system from different authorization points in the application module.","A system for protecting a software application module according to the present invention includes a coupling tool and a coupling agent template. The coupling tool rewrites the application module to form a modified application module by overwriting executable code at identified authorization points with control transfers to a managed challenge system. The coupling tool also creates the managed challenge system, and links the managed challenge system to the rewritten application module. The managed challenge system may include the overwritten executable code, executable code from a challenge system, a runtime task table and a coupling agent for managing the managed challenge system. The runtime task table associates the identified authorization points with authorization check data and with the overwritten code. The authorization check data describes an authorization check from the challenge system to be performed upon control reaching the associated authorization point. The coupling agent may be produced from a specialization of the coupling agent template.","The system may further include a protected code store, in which the coupling tool stores any combination of, but is not limited to: i) merged code sequences corresponding to authorization points in the application module; ii) hidden code sequences corresponding to removed control transfers in the application module; and iii) dummy code sequences corresponding to non-authorization point code sequences. Any of the merged code, hidden code and\/or dummy code sequences may be encrypted.","In one embodiment, the coupling agent includes a dynamic code generator which generates an executable code sequence on demand at runtime from a stored code sequence corresponding to an identifier associated with a control transfer from which control was transferred to the managed challenge system.","The coupling agent may further include a code cache for storing generated code sequences, and a cache management module which manages the code cache.","A description of preferred embodiments of the invention follows.","A goal of the present invention is to create a secure execution environment where the protected material (be it a licensed application or protected content manipulated by an application) is used only within the constraints imposed by the use agreement.","Embodiments of the present invention are independent of the actual process used to secure the protected material prior to execution by a licensed user.","An embodiment of the present invention applies to all of the runtime license enforcement systems associated with different kinds of protected material. For ease of discussion, the license is said to protect access to a licensed application module A , although this should not be interpreted as limiting the scope of the invention.","With application module A  characterized as above with respect to , it is possible to separate completely the engineering and\/or development of the application module A  from the manner in which A is licensed. The reader should avoid falling victim to the common misconception, found in much of the prior art, that source code changes in the application are required for an effective, software-based license enforcement scheme.","In fact, a common trait of most if not all prior art is that these existing schemes can only make license subversion more difficult by increasing the coupling between the source code of the application module and the runtime license enforcement system. Unfortunately, any increase in said coupling impacts the development of application module A and makes authorization an attribute impacting application development.","Crucial Aspects of an Effective License Enforcement System","In general, an effective method for securing licensed applications and protected content against piracy is one that makes license subversion difficult. In particular, such a method must achieve the following two goals:","Goal g1: It must be very difficult to execute a licensed application module successfully without a valid license or make a copy of said application module that can execute successfully.","Goal g2: It must be very difficult for an unauthorized person to obtain or duplicate a valid license.","In addition, any effective solution, to be commercially viable, must address issues beyond those directly involved in thwarting license subversion. In particular, a viable method for piracy protection must not only be effective, but must in addition achieve the following two supplementary goals:","Goal g3: It must be very easy for an authorized person to obtain a valid license and use that license to exercise his or her entitled rights.","Goal g4: It must be very easy for the application module developer to separate the details and overhead of licensing from the software development and runtime performance of the licensed application module.","Issues of effectiveness are always the first focus of attention, after which the additional issues concerning commercial viability may be addressed. Prior art may be categorized as providing an effective solution for (g1), (g2), or both (g1) and (g2). This categorization is important because different technologies can be applied to solve (g1) and (g2). Done properly, solutions can be mixed and matched to build a viable license enforcement system.","Authorization Check and Common Attacks",{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 2","b":["6","6","12","8","12","12"]},"Upon invocation by C , the response system R  reads the license file (step ), checks to see if the end user has the right to perform the requested action (step ), and returns the result (e.g., success A\/failure B) of this check to the challenge system C .","Effective license enforcement systems are based on the assumption that the enduser system is a hostile environment. For purposes of discussion, a person trying to subvert the license enforcement system  () is referred to as an \u201cadversary\u201d. When a licensed application module A  is running, an adversary has the ability to change or mask out the steps shown in  as well as intercept and spoof communications between the entities (2, 6, 8 and 10) of .","These actions need not be taken directly by an adversary, but may be performed by a program (e.g., a virus) working on behalf of the adversary. One license enforcement system is generally considered to be more effective than another if the first said system is better able to guard against all such attacks. The following describes how others have protected against such attacks.","Protecting the License File","A significant portion of existing art focuses on effective solutions to (g2), i.e., identifying a method that makes it very difficult for an adversary to obtain or duplicate a valid license.",{"@attributes":{"id":"p-0081","num":"0080"},"figref":["FIG. 3","FIG. 1","FIG. 3"],"b":["4","20","8","10","22","8","10","10"]},"The most effective methods addressing goal g2 often tie L  to one or more unique values associated with a piece of hardware (e.g., a processor, disk, dongle, or smart card) and a secret passphrase known only to the authorized user associated with said hardware. Effective license enforcement starts by encoding the unique and secret values into L  at a trusted site out of the view of the potential adversary. Then, during authorization check, response system R  extracts and matches said values with the value provided by the current user and hardware. This approach makes it difficult for an unauthorized person to subvert the authorization check by obtaining or duplicating a valid license.","Preventing Execution","Relatively little existing art, on the other hand, deals with goal g1, i.e., identifying a method that makes it very difficult to execute a licensed application module successfully without a valid license or make a copy of said application module that can execute successfully. As seen in , goal g1 involves a method for protecting the application image A  on disk and in memory, the channel  between A  and C , the challenge system C , and the channel  between C  and R .","A key aspect of goal g1, as illustrated in , is to provide the license enforcement system  with the ability to affect A's  execution depending upon the outcome of an authorization check  (). Though existing art provides for this ability in one of two ways as described below, it has to date proven difficult to protect this part of the license enforcement system  from adversaries with the same strong guarantees that have been achieved for protecting the license file L .","Controlled Launch","A simple approach requires the end user (either implicitly or explicitly) to launch the license enforcement system , which performs an authorization check before launching A . For example, Macrovision Corporation and Rainbow Technologies, Inc., provide these capabilities in their software copy protection and electronic license management products. In order for this type of approach to be effective, it must be difficult for an adversary to launch A  without the license enforcement system .","Cryptographic techniques are only partially effective, because even if the disk image of the A  is encrypted, its memory image cannot be. (Executing the encrypted memory image requires specialized hardware support.) However, to obtain an unprotected copy of A , an adversary may simply wait until A  has been launched and then copy its memory image.","Embedding License Enforcement into the Licensed Application Module",{"@attributes":{"id":"p-0087","num":"0086"},"figref":["FIG. 4","FIG. 2"],"b":["2","8","8","2","2","6"]},"Prior art supports such an approach by providing an application programming interface (API)  for licensing and license protection. Macrovision Corporation's FLEXlm product is one example of a popular API. Such APIs encapsulate the functionality of R  within one or more statically or dynamically linked libraries and thus minimize the impact of the complexity of R's functionality on the developer of A . On the other hand, the application developer is responsible for creating the source code for C  and directly embedding that code into the source code for A .","Since license enforcement is only as effective as the weakest link in the chain of protection, the effectiveness of the approach shown in  depends upon the application developer's ability to protect the challenge code embedded into A . In other words, an adversary most often does not try to reverse engineer R  or break the encryption scheme protecting L \u2014he simply identifies each challenge point in A  and either (a) replaces the call to the authorization check with a call to a routine that always returns \u201csuccess\u201d; or (b) overwrites the code that processes the response from the authorization check so that it never aborts the application module.","To defend against these kinds of attacks, the application module developer can make it difficult to identify all of the challenge points in A  and remove the effect of these challenge points without destroying the functionality of A .","Unfortunately, if an application module developer uses the straightforward challenge template illustrated in , very little protection is achieved even from the insertion of multiple authorization checks. This is because it is fairly easy, using commonly available debugging and executable-inspection tools, for a programming-savvy adversary to identify and rewrite challenges built in such a straightforward manner.","To protect against such programming-savvy adversaries, other techniques, commonly called code obfuscation, have been employed that make it more difficult to separate and remove the challenge code C  from the code for A . \u201cCode obfuscation\u201d involves a tight intertwining of the challenge and application module code in a manner that makes the two practically indistinguishable. See, for example, Christian Collberg et al., \u201cA Taxonomy of Obfuscating Transformations,\u201d Technical Report #148, Department of Computer Sciences, The University of Auckland, July 1997 (www.cs.arizona.edu\/\u02dccollberg\/Research\/Publications\/CollbergThomborsonLow97a\/ind ex.html).","Despite the growing concern about software piracy, code obfuscation lacks widespread adoption because it incurs a heavy penalty on the engineering, testing, and often the performance of the licensed application. Code obfuscation is in direct conflict with goal g4. Stated another way, the difficulty of hiding said challenges in A  makes goal g1 a difficult problem to solve effectively and an even harder problem to solve viably.","In summary, an effective solution for goal g1 must thwart piracy attempts based on static analysis of the application module's A  code, runtime observation of its memory image, and runtime interception of the license verification checks . And to be commercially successful, any practical solution must not sacrifice goals g3 and g4 to achieve greater levels of software protection.","Overview","The present invention provides an alternative solution for runtime license enforcement that makes it provably hard to subvert the protection scheme and create an unencumbered copy of a licensed application or application module. In particular, an embodiment of the present invention comprises a new method for preventing the successful unauthorized execution of a licensed application module (goal g1).","The invention does not require any engineering changes to the licensed application's A  source code, nor does it incur any noticeable impact on the runtime performance of said application (goal g4). Viewed broadly, the present invention solves the larger problem of licensing and piracy protection because said invention can be integrated, as illustrated in , with any of the previously mentioned methods for obtaining, protecting, and accessing a license file L  (goal g2). As a result, the use of the present invention in a complete solution for license enforcement does not affect the ability of an authorized end user to obtain and use a valid license (goal g3). Thus, the focus is on how to inseparably integrate a given authorization scheme with a given application module without requiring any source-level changes to the application module, and not on the specifics of the authorization or licensing scheme itself.",{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 5","b":["30","30","2","6","6","2","2","30","30","6","2","30","6","32"],"sub":"a "},"The managed challenge system M is specific to the given application module A  and will only work for that particular application module A . In contrast to the application module A , the source code for the coupling agent G is under the control of the implementer of the authorization scheme (who is likely different from the developer of the application), so such customization is feasible. Furthermore, the customization of the coupling agent G  for a given application and authorization scheme, described below, can be done automatically. Thus, creating a coupling agent G  for a given application module A  and authorization (or licensing) scheme is a fairly simple and automatic task.","Embodiments of the present invention naturally achieve the desired goal of separating an application's licensing from its development by allowing the implementation of the coupling agent G , and thus the challenge system C , to be separate from the source-level coding of the licensed application module.","Instead of integrating C  into A , an embodiment of the present invention embeds parts of A  (along with C ) into the coupling agent G . The code removed from A  and executed in the coupling agent G  is referred to as the \u201chidden application code\u201d. As described below, a deep and secure embedding of the hidden application code within the coupling agent G  can be achieved without any more information than is provided in A's executable (i.e., without the aid of A's developer).","The following statements support the inventors' claims that the organization in  is effective against a skilled adversary:","First, by taking code from A  and integrating it into the coupling agent G , an adversary cannot create a working version of A  simply by removing the coupling agent G  from the licensed application module.","Second, by hiding the locations in A  where control is transferred to the coupling agent G  in such a manner that it is provably hard to identify them via static analysis (i.e., analysis of the licensed application module's executable, as opposed to the analysis of the loaded memory image of the application during its runtime execution), it becomes very difficult or even impossible for the adversary to build a working version of the licensed application from A  and the coupling agent G  alone. To find all licensing points, the adversary must exercise all possible control paths in the application, and this is related to the well-known, hard problem of code coverage analysis in the area of software testing.","Third, by obscuring the interaction between the coupling agent G  and the response system R , it becomes very difficult for the adversary to change how the application A  ultimately calls the authorization-check routines in R  and uses the results of these calls. The present invention has complete freedom in this area because this work is done entirely within the coupling agent G .","Finally, by making it hard for the adversary to understand how the code and data structures in the coupling agent G  are used during runtime execution to accomplish the work done on behalf of A  and C , it becomes very difficult for the adversary to change the coupling agent's code to thwart license enforcement.","Description","The process by which an embodiment of the present invention turns unlicensed applications into protected, licensed applications is now discussed. Methods are also presented for expanding the capabilities of the coupling agent beyond protection to achieve the commercially important goal of minimizing the overhead of protection. Although the descriptions are organized around the process of producing a licensed application module, the runtime functioning of the present invention is also explained.",{"@attributes":{"id":"p-0107","num":"0106"},"figref":"FIG. 6","b":["50","51","53","30","55"]},{"@attributes":{"id":"p-0108","num":"0107"},"figref":["FIG. 7","FIG. 6","FIG. 6"],"b":["51","55","61","51","65","61","30","53","55","61"],"sub":"m"},"In addition, shown here at address X is an instruction that just happens to have in its immediate data the same value (0\u00d7CC) as the opcode for the transfer instruction used in the application code rewrite of step . To confuse the adversary, dummy code is added to the table of pairs  corresponding to the address of the 0\u00d7CC byte.","Referring back to , at step  an application-specific managed challenge system is constructed, in part from the coupling agent  () and the table of pairs  (). Finally, at step , the managed challenge system and any related authorization or licensing libraries are linked into A.","When complete, the application-specific coupling agent  is able to generate, at run time, a code sequence for each authorization point.",{"@attributes":{"id":"p-0112","num":"0111"},"figref":"FIG. 8","b":["70","71","73","75"],"sub":"m "},{"@attributes":{"id":"p-0113","num":"0112"},"figref":"FIG. 9","b":["80","83","32","83","2","81","91","93","6","31"],"sub":"a "},"The check data D  describes the authorization work to be done at the associated authorization point in A. Check data may include, for example, the address of an authorization function in C  to be called, the actual parameters of that call for the associated authorization point, and\/or the return values of that call that represent a successful authorization check.","From these inputs , ,  and , coupling tool U  produces M and A. Application A is a modified version of A  that requires M in order to run successfully. Mis a managed challenge system that is unique to Aand thus will not help an adversary trying to subvert another application protected by the present invention.","Managed challenge system M comprises a specialized coupling agent (G) , a runtime task table  specifying the runtime work for G  and indexed by unique identifiers associated with each point in Athat transfers control to M(e.g., the address of the transfer point), and code in the protected code store . The protected code store  includes\/represents the code taken from A , the code that composes C , and extra code that helps protect M (e.g., the hidden and dummy code sequences described below).","M represents the output of combining the coupling agent (G) , a challenge system (C) , authorization information, and pieces of the application (A)  to be protected into a module that can be statically or dynamically linked to A. Mmanages the runtime interaction between Aand an external authorization (or licensing) system. The coupling agent G  in this module performs the management function, described below.","Coupling agent G  is a run-time component of an embodiment of the present invention. It is responsible for catching the control transfers from the application (A) at the program points where authorization checks should occur. If code corresponding to an authorization point has not yet been generated, G  may dynamically generate and cache the required code. Ultimately, coupling agent G directs the program's control flow into the dynamically generated code required at an authorization point. The dynamically generated code returns control to A if the authorization check succeeds.","Coupling agent G  also handles the runtime work associated with the protection of the managed challenge system M. This protection work includes, for example, the runtime aspects of the mechanisms used to hide the control transfers in A to M and to obscure the contents of the data structures used by coupling agent G  to produce the dynamically generated code at an authorization point.","Identifying Authorization Points (, Step )","The process begins by identifying \u201cauthorization points\u201d\u2014points in an unprotected application A  where an authorization check should occur. If authorization checks only need to be performed on some subset of the software modules that comprise the application , then these modules (e.g., dynamically linked libraries, or DLLs) must be identified, for example, by the application vendor.","An authorization point can be something as simple as the starting byte address of an instruction in A . A particular authorization check is associated with each authorization point. The check may be, for example, a simple call to a routine in response system R  (), with the result indicating the success of the check, or the check may be as complex as necessary. The information that defines the authorization check is referred to herein as \u201ccheck data\u201d.","There are many ways to identify authorization points and associate check data with those points.","For example, at one end of the spectrum, a compiler may be modified to recognize special pragmas (e.g., flags, pragma statements, or other associations, etc.) used for code or data protection. A software developer can then attach a respective pragma to various source code lines of the application  to indicate respective points at which an authorization check should occur. Each pragma may additionally contain the check data for its authorization point. The compiler may then be responsible for producing the protected binary, as described below.","Alternatively, as illustrated in the block diagram of , a person at the application publisher (e.g., a security professional or even someone from the sales and marketing department) could, by analysis  of the application program , produce a table or file of pairs , where each pair contains an authorization point  (e.g., the starting byte address of an instruction in A ) and the associated check data  (see ). The coupling tool  of  may then be used to rewrite the application's  binary executable, using the contents of the pairs file  to drive the rewriting process and produce a licensed application.","In yet another alternative, illustrated in the block diagram of , an unprotected application  could be turned into a licensed application without any support from the developer of the application . In all executables, there are clearly identifiable points that can be used to find the starting address of an instruction, e.g. the starting address of the program, the starting address of an exported function, the information associated with a relocation entry, etc. From these points, it is relatively easy for one skilled in the art, using an analysis tool , to decode the instruction sequence beginning at those points and construct a control flow graph (CFG)  for the application . A security professional or other person responsible for protection of the application module could, by analysis  of the CFG , produce a table or file of pairs  identical in content to what was produced in .","A CFG is a grouping of the binary code into nodes, each node representing a sequence of straight-line code with the property that control can only enter each sequence at the first instruction in the sequence and leave only after executing all instructions in the sequence. CFG nodes are connected by directed edges that indicate that control can flow from the node at the tail of the edge to the node at head of the edge.","This approach may yield only a partially specified CFG if the application  contains program points that cannot be identified statically, e.g. a program point that is reached only through a jump instruction whose target address is determined at runtime. However, a fully specified CFG is not required for the invention to work. That is, a partially specified CFG may be sufficient because a limited number of randomly-specified, valid instruction points in the known CFG may be sufficient for license enforcement.","If desired, coverage of A's CFG  can be increased by augmenting the information learned from static analysis with information learned by tracing A's  execution under a number of different input data sets (not shown). Through tracing, it can be determined how control reaches and proceeds through the parts of A  that were previously not able to be analyzed using static analysis. There exist numerous methods well known to those in the industry for tracing program execution.","For example, tracing techniques based on special hardware resources that, for example, interrupt the program execution on every taken branch, could be used directly. For architectures without special hardware support for tracing, the execution of the application could be emulated to create a detailed execution trace.","Code Rewriting for Control Transfer from A  to the Coupling Agent  (, step )","Given the address of the first byte of an instruction at an authorization point in A , the coupling tool  () of an embodiment of the present invention replaces the byte, and possibly the other bytes in the instruction, with one or more new bytes that when executed cause the program control to be transferred to the managed challenge system M.","Note that the mechanism that causes the transfer appears in the application code and replaces some subset of the original bytes in the application . If not, it would be possible to separate A  from M, leaving a fully functional version of A . It is also important that each transfer either includes some unique identifier or targets some unique location in M, so that M can determine which authorization point was encountered and thus what authorization work needs to be performed.","For ease of discussion, assume that the inserted byte sequence is a single instruction and that this new instruction completely replaces the original instruction at the authorization point. Though this is likely to be the case for instruction sets with fixed-length instructions, the possibilities for architectures with variable-length instructions are much richer. Though variable-length instruction sets provide the ability, for example, to replace a single original instruction with several shorter, new instructions, the goal and basic approach of the present invention remain the same.","One possible solution is to replace the original instruction with an instruction that causes a runtime fault. For example, the coupling tool  may modify A  so that M is always installed as the first handler for the exception caused by the faulting instruction. The handler in M may use the fault address as the unique identifier for the authorization point and store the check data for each valid authorization point in a data structure such as a hash table indexed by the fault address. If the fault address is not a valid authorization point, M may pass the fault on to the next exception handler in the chain of exception handlers.","It is always possible to ensure that M is the first handler for any runtime exception, since this is the same procedure used for debugging an application. When debugging an application, the debugger is always the first to catch a runtime exception, enabling the user of the debugger to inspect the exception and optionally resume the application without delivering the exception to the application code. In this case, M inspects the exception and decides whether or not to deliver the exception to the application code or to resume normal execution of the application .","Alternatively, the original instruction may be replaced with a call into M. In this approach, the return address may serve as the unique identifier and all calls may target a single point in M, or each call may directly target a unique code sequence.","In either case, the insertion of control transfers can be accomplished without access to the source code of A . Care must be taken to insert new instructions that do not destroy program state required by later instructions in A . This aspect of the problem and appropriate solutions are well known to those familiar with the basics of binary rewriting.","Hiding the Control Transfers from A to M from Static Analysis (, Step )","A key attribute of effective license enforcement is the use of information that is unknown to the adversary and difficult to reconstruct. As such, it is vital in all approaches that the authorization points selected (and input data sets used for the tracing strategy described above) are kept secret.","One approach to hiding the inserted instructions that transfer control from A to M at each authorization point is based on the fact that the binary rewriting process can make it impossible for the adversary to construct a complete CFG for A . As discussed above, a CFG  () can be constructed for A . If this CFG were constructed after choosing the authorization points, then an adversary could use this CFG to identify authorization points that are directly observable from static analysis.","Thus, for each observable authorization point, a set of control transfer instructions is selected whose removal would make it impossible to find that authorization point via the static analysis described above, using a CFG  constructed from A . Many methods exist for choosing such a set, the simplest being one that removes control transfer instructions from the CFG  until it is not possible to reach the authorization point via a path in the modified CFG.","For example,  illustrates an exemplary, albeit somewhat simple, control flow graph , containing five nodes , , ,  and . Node  represents an authorization point. By removing the code in each of nodes  and  which transfers control to node , and moving that code into M, authorization point  is completely hidden from this static analysis.","More sophisticated methods could use additional information, based on further static analysis or profile data, to choose a set of control transfer instructions (effective for hiding authorization\/control transfer points) that minimizes the overhead of the protection scheme on the runtime of the licensed application.","For example, node  in  may comprise a loop that executes frequently. To reduce runtime overhead, nodes  and  may be removed instead of  and , assuming node  executes less frequently than . Both choices accomplish the goal of making it impossible to reach node .","Once a pertinent set of control transfer instructions has been identified for removal, the same rewriting method described above may be used to transform each control transfer instruction in this set into a control transfer to M, the only difference being that no authorization check is performed by M for these points.","Clearly, it should not be possible to follow the control flow statically in M to discover the targets of the removed control transfer instruction. This requirement is easily satisfied by any of the solutions described below, with respect to step  of .","Though an adversary may be able to identify some authorization points at runtime, these are limited to just those authorization points that are uncovered by the particular program run. For an adversary to be sure that all of the authorization points in a protected application have been uncovered, the adversary must find a set of data inputs that provides 100% code coverage.","Code coverage analysis and coverage testing is the problem of determining a set of inputs that exercise every instruction in an application module. A typical application module consists of a number of decision points that determine the control flow through its program code as it executes. Modern applications have many thousands of decision points, making the decision tree very large and complex.","To achieve 100% code coverage, a set of inputs must exercise every limb of the decision tree. This is known to be a mathematically exponential process, placing the problem into a category known as \u201cNP-hard\u201d. NP-hard problems have no known efficient solution. For the code coverage problem described here, a methodical solution based on enumeration would take an exponentially long time, given the complexity of the decision tree in most modem applications. Thus, it is impractical for an adversary to try to identify all authorization points by solving the code coverage problem.","Given one run of a licensed application module A with a valid license, an adversary could potentially learn the byte sequence used to transfer control from A to M at the executed authorization points. Though it is possible to use different byte sequences for the different authorization points, even if just a single sequence is used for transfer of control at all authorization points in A , it can be argued that, even if the adversary learns this single sequence, the protection scheme of the present invention cannot be subverted.","For ease of discussion, assume that A  has been compiled to run on an Intel \u00d786 microprocessor and that the single byte \u201cINT 3\u201d debugger trap instruction, having an opcode of CC(0\u00d7CC), is used as the trapping sequence. Scanning a licensed binary and searching for all occurrences of CCwill produce a candidate set of locations strictly greater than the set of all authorization points in the application . Recall that, given the work described above to obscure A's  control flow, static analysis of A's binary for purposes of producing a CFG will not help the adversary to reduce the candidate set.","Assume now that the adversary can trace the execution of the coupling agent G  in M and learn how it verifies the address of a valid authorization point. One possible attack then would be to mimic this verification process for each occurrence of CCin the candidate set and thus reduce the candidate set down to exactly the set of authorization points. An embodiment of the present invention thwarts such attacks by creating a dummy entry in M's runtime task table  and protected code store  () for each member of the candidate set.","This can be done safely for each CCthat is not a valid authorization point or a valid trap instruction used in A , because a CCbyte can only cause an exception during program execution if it is interpreted by the execution hardware as a CCinstruction. If a particular CCbyte cannot cause an exception at runtime, a dummy entry may be entered into the runtime task table  and bogus code stored in the protected code storage  () for this byte. On the other hand, the dummy entry and bogus code will confuse the adversary, and if he or she tries to replace said CCbyte with the bogus code, an incorrect version of A  will result.","One must, however, be concerned with valid CCinstructions placed in A  by the application module developer. Several possible solutions exist. For example, at one extreme, the application developer can, when inserting the authorization points, indicate which of the existing CCbytes are valid instructions. The coupling tool  could then use this information to disable the creation of dummy entries in the runtime task table  for those bytes.","On the other hand, where a protected application  is being created without assistance from the application module developer, the present invention must be limited to those CCbytes that can be identified as part of other valid instructions in the partially specified CFG. Here, the same approach described above to obscure the authorization points from the adversary can be employed. Once control transfer instructions have been removed to obscure the authorization points, it is very difficult for the adversary to reconstruct the hidden information, and the adversary is again left with the unsolvable problem of trying to identify which CCbytes in the candidate set correspond to valid authorization points.","Constructing an Application-Specific Managed Challenge System M (, step )","At each authorization point, M must be able to map the unique identifier of that point to its associated hidden application  code and authorization check data . Once the work to be done for the authorization point has been identified, M must execute a sequence of instructions that accomplishes that work.","If the authorization check fails, M may abort the program execution in a manner consistent with the protecting vendor's specifications. If the authorization check succeeds, M may return control to the application module  with a valid program state that includes the work done by the hidden application  code.","First described are the actions required to transform the program state at the authorization point to what the program state should be when control returns to the application  from the authorization check. The resulting program state should reflect the effect of the hidden application  code and the skipped application code, if any, between the authorization point and the point where control returns from M.","The problem of successfully transforming a program's state and continuing its execution is equivalent to the problem of producing compensation code along program paths that contain instructions whose execution was the result of an incorrect speculation. Well-known, compile-time algorithms exist for solving such problems (e.g. Trace Scheduling as described by Lowney, et al., \u201cThe Multiflow Trace Scheduling Compiler,\u201d The Journal of Supercomputing, Vol. 7, No. 1\u20132, pp. 51\u2013142, 1993, citeseer.nj.nec.com\/lowney92multiflow.html) that can be adapted to produce an algorithm to adjust the program state.",{"@attributes":{"id":"p-0158","num":"0157"},"figref":"FIG. 13","b":["140","142","32","144","146","144","32","146","32","85"],"sub":["a ","a ","a ","m"]},"Next, given an authorization point, the check data  for said point, an instruction sequence to be executed by M on behalf of A  at said point, and an instruction sequence corresponding to the work specified by said check data , a single instruction sequence may be constructed that performs the required work.","In one embodiment, instructions from the two input instruction sequences are interspersed to form a single instruction sequence, referred to as the \u201cmerged code sequence\u201d. Methods available for creating a merged code sequence are well known to those familiar with binary rewriting for the purposes of code instrumentation, since instrumentation of a binary requires one to merge new code sequences into existing code sequences.","For the program points in A  where the code was rewritten to hide authorization points, an appropriate instruction sequence must also be created to be executed by the coupling agent  on behalf of A  at that point. For these points, the resulting instruction sequence is referred to as the \u201chidden code sequence\u201d, since there is no authorization work (and thus no merging work) to be performed.","For the program points in A  that were identified as dummy authorization points (i.e., program points whose pre-existing byte sequence matches that used for a true authorization point), a merged code sequence is created that appears genuine. To minimize confusion, these fabricated code sequences built for dummy authorization points are referred to as \u201cdummy code sequences\u201d.","Once a merged code sequence has been created for every authorization point, a hidden code sequence for every rewritten control transfer instruction, and a dummy code sequence for every dummy authorization point, code for the coupling agent  of M may be generated. The particular manner in which the coupling agent  is constructed depends upon the method chosen to protect the channel  () between the coupling agent and response system R . In fact, a wide variety of techniques are available since the use of any particular technique does not impact the development or engineering of A . Very sophisticated techniques may be chosen to protect this channel , because the effort involved in such an undertaking needs to be done only once, during the implementation of the tool that creates the coupling agent  for an application . The effort may be amortized over every application  module that uses said invention for protection.","One option for building the coupling agent  is to create it simply as a conglomeration of all of the merged, hidden, and dummy code sequences. Depending upon the exact method chosen for implementing the control transfer at the program points where code in A was rewritten, the constructed coupling agent  may contain additional code for dispatching from a central point to each code sequence, as explained above.","To thwart any attempt at separating the work done on behalf of A  from the work done for authorization, code obfuscation techniques may be applied to the entire conglomeration of code forming the coupling agent . Published literature contains descriptions of various methods for achieving effective code obfuscation using automated techniques. (See, for example, the Collberg paper referenced above.) Unfortunately, these methods often incur a heavy runtime penalty, and thus their use may be limited to code sequences in the coupling agent that are infrequently executed if there is concern, as there well might be, with the overhead of the protection scheme.","Another option, as illustrated in , is to build the coupling agent  as a dynamic code generator, in which case the coupling agent  may comprise code for dynamic code generation , a code cache  with entries  holding the generated code sequences , and a cache management module .","The dynamic code-generating coupling agent  interacts with the runtime task table  and the protected code store . The store  may be protected by a wide variety of methods; a protection method is effective if it makes it difficult for an adversary to (a) understand the contents of the store without executing the program and\/or (b) change the contents of the protected store. Recall that the protected code store  may contain merged, hidden, and dummy code sequences. As previously discussed, dummy entries in the code store  make it difficult for the adversary to determine which entries in the store contain valid code, and thus know what code in the store should replace the byte sequences in the licensed application  that may represent control transfers to the coupling agent .","In a further embodiment, the contents of the store  may be encrypted before distribution with the private half of an asymmetric key pair. This approach achieves one of the effectiveness criteria, since an adversary can effectively change the contents of the table only if he or she can discover this private key. This removes the potential attack involving a masking out of the authorization checks from all entries (dummy or real) in the protected store .","The cache management module  may be the main driver of the coupling agent  as a dynamic code generator.  is a flowchart illustrating some of the responsibilities of the cache management module  of . This flowchart will help explain the rest of elements of  and their interconnections.","The handler  of the cache management module  is invoked when control first enters the coupling agent . The module  first checks, at step , whether the code sequence for a particular authorization point (or rewritten control transfer instruction) has already been generated and written to the code cache . The code cache  is simply a block of memory  used to store the generated code sequences , as described below.","If the required code sequence exists, an entry for it will exist in the look-up table , and this entry will specify where to find the required code sequence in the code cache . If found, the cache management module prepares the program state for jumping into the identified code sequence  in the code cache (step ) and then jumps to the start of that code sequence (step ). Recall that the code sequences are created to jump directly back to the correct continuation point in the licensed application .","Program state preparation (step ) is required, for example, in the case where control reaches the coupling agent via an exception, for example, through an interrupt instruction. For an interrupt instruction, the program state that should be in the hardware registers currently resides in the exception frame. The coupling agent  is responsible for performing all such restoration actions, specifics of which depend upon the method of control transfer selected for reaching the coupling agent at an authorization point.","If the cache management module  finds, as a result of step , that the code cache  does not contain the necessary code sequence , then the runtime task table  (step ) is read using an index based on the authorization point  (or unique identifier associated with the control transfer into the coupling agent ). In step , the cache management module  uses the data returned from the runtime task table  to decide whether control should be returned to the licensed application  (step ) or whether it should invoke the dynamic code generator to create the sequence (step ).","In the latter case, the dynamic code generator  uses the information from the runtime task table  to read an entry in the protected code store  and create an executable code sequence . The complexity of the dynamic code generator  depends upon the methods used to protect the contents of the store . If one believes that a merged code sequence is actually quite difficult to understand and safely change, then the dynamic code generator  can effectively be a routine that implements block copy. Alternatively, if the entries in the store are encrypted, then the dynamic code generator  must also include a decryption function .","The cache management module  then selects a location in the code cache  at which to place the newly generated sequence  (step ), updates its lookup tables  (step ) so that it will recognize that later requests for this code sequence  simply need to jump into the code cache , prepares the program state (step ), and finally jumps into the instruction sequence in the code cache (step ).","As with all hardware and software cache structures, the cache management module  is also responsible for choosing which stored code sequences  to evict from the cache  when no free location for a newly generated code sequence exists (shown as step ). In particular, the code cache can be purposely sized such that it is not large enough to contain all of the dynamically created code sequences, with the beneficial result that any single run of the application cannot produce the entire original application bits in memory.","The invention does not preclude the use of any particular cache structure. Clearly, the decision to use one kind of cache structure (e.g., direct mapped vs. set associative) will affect the final implementation of the cache management module , but such a decision is not key to the effectiveness of the present invention.","There are many advantages to the dynamic code generation approach. For example, runtime code generation of the authorization checks removes the most common and popular attack employed by those looking to pirate a protected application: rewriting of the application's binary to remove calls to an authorization check or to use the results of such calls. An adversary must instead perform these attacks at runtime, and this significantly increases the difficulty of the task facing the adversary. Furthermore, even if the adversary can identify the location where such an authorization call exists in one execution, the normal functioning of the code cache  of an embodiment of the present invention can have this same call appear at a different address in memory during the next execution of the protected application.","Caching of the dynamically generated code also yields performance benefits because work done by the dynamic code generator  (e.g., decryption of entries in the protected code store ) may be reused many times before being discarded. In addition, the dynamically generated code can be very efficient because protection of these sequences  from manipulation and analysis by the adversary is provided by the dynamic code generation process (e.g., encryption of the protected code store  in ) and not by obfuscation of the executed code sequence.","Finally, the coupling agent  may include additional capabilities for the sole purpose of reducing the overhead of the protection scheme. In particular, the coupling agent  may continually track the overhead of the dynamic code generation process and use this information to decide whether the dynamically-generated executable code sequence should be stored in the code cache or should directly replace the associated control transfer in the licensed application.","Direct replacement may involve removal of the authorization check and a reverting of the executable code sequence back to what it was before the code was removed from the application in step  of . Such direct replacement removes all overhead associated with the present invention for that protection point for the rest of the licensed application's current execution. Since no changes are made to the image of the application on disk, protection will again occur at that point on the next execution of the licensed application.","Linking the Managed Challenge System  into A (, Step )","Once the managed challenge system  has been created, it must be linked with the result of the binary rewriting of A , i.e., A. While there are various options, three in particular that cover several different situations are now described.","One embodiment of the present invention may be incorporated into a compiler, which may then create a DLL that is linked with the final executable. This approach can be used to create a licensed application  or to produce a trusted software application that processes protected (e.g., encrypted) content directly.","In another embodiment, where an unprotected executable for A  is being rewritten without access to the source code or the normal development tool chain, the work to be done is generally identical to the work that is done when instrumenting an executable. The result of the instrumentation process is a new executable or application module that is distributed in place of the original, unprotected application . Again, the goal may be to produce either a licensed application  or a trusted processor for protected content.","The last example involves an interesting and increasingly common case. Suppose that a vendor owns some valuable content and wishes to distribute this content in a protected manner (e.g., in an encrypted form) so that only authorized users have access to the content. Suppose also that the clear text form of this content can be processed by many existing applications in the field, but the vendor does not own or control any of these applications. Music vendors, the MP3 file format, and the large number of available MP3 players are one example of such a market. Consumers of digital music do not want to install and run multiple different MP3 players simply because each music vendor desires their own protection scheme for their music content.","As another example, consider an enterprise that wishes to share the design of a proprietary machine part with a supplier. The enterprise may want to secure the computer-aided design (CAD) file so its access is restricted to authorized persons only. Such a security precaution would be commercially impractical if it required the supplier to install and run a specially-designed CAD package for each of its enterprise customers.","A U.S. patent application Ser. No. 10\/194,655, filed on Jul. 11, 2002 by Bala and Smith, entitled \u201cMETHOD FOR PROTECTING DIGITAL CONTENT FROM UNAUTHORIZED USE BY AUTOMATICALLY AND DYNAMICALLY INTEGRATING A CONTENT-PROTECTION AGENT\u201d, (hereafter referred to as \u201cthe previous Bala and Smith patent application\u201d) and incorporated by reference herein in its entirety, describes an integration agent that automatically and dynamically (i.e., at run time) integrates a content publisher's content protection module with an existing content processor application on an end-user's machine. The content protection module is the content publisher's software implementation of, for example, the decryption scheme that converts a buffer of encrypted cipher text from the protected content file into clear text on demand, as the content processor application performs accesses to the protected content file. The content processor application is the software application (such as AUTOCAD, REALNETWORK REALPLAYER, or MICROSOFT WORD) used by the content consumer to view, play, or modify the content. This enables the content publishers to use their own custom encryption format to ship the content in a secure form, and yet have the authorized content consumer be able to process the encrypted content directly using his or her own, existing content processor application.","In this case, it is the content protection module, and not the content processor application, that is to be protected from subversion. This works well because the content publisher is in control of the content protection module but not the content processor application. Furthermore, using the invention in the referenced patent application to protect against the execution of the content protection module without proper authorization is a critical step in addressing the runtime security goals for such a content protection scheme.",{"@attributes":{"id":"p-0189","num":"0188"},"figref":"FIG. 16","b":["301","305","309","307","303","311","303","301"]},"The resulting custom content processor application  is able to transparently manipulate the protected content and yet is protected against unauthorized use and attempts to subvert the authorization checks. Together, this combination enables a content publisher to distribute protected content files in a secure and commercially practical manner.","One benefit of the present invention is that the coupling agent (and the rest of the license verification system or managed challenge system) can be upgraded as new license subversion attacks become known, without requiring updates or changes to the licensed application. In addition, because the present invention does not necessarily depend upon cryptographic techniques, it may not be subject to export restrictions associated with cryptographic technology. This makes it a practical choice for software vendors whose products are distributed in global markets.","Those of ordinary skill in the art should recognize that methods involved in protecting software applications against static and dynamic software piracy techniques may be embodied in a computer program product that includes a computer usable medium. For example, such a computer usable medium can include a readable memory device, such as a solid state memory device, a hard drive device, a CD-ROM, a DVD-ROM, or a computer diskette, having stored computer-readable program code segments. The computer readable medium can also include a communications or transmission medium, such as a bus or a communications link, either optical, wired, or wireless, carrying program code segments as digital or analog data signals.","While the system has been particularly shown and described with references to particular embodiments, it will be understood by those of ordinary skill in the art that various changes in form and details may be made without departing from the scope of the invention as encompassed by the appended claims. For example, the methods of the invention can be applied to various environments, and are not limited to the described environment."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing and other objects, features and advantages of the invention will be apparent from the following more particular description of preferred embodiments of the invention, as illustrated in the accompanying drawings in which like reference characters refer to the same parts throughout the different views. The drawings are not necessarily to scale, emphasis instead being placed upon illustrating the principles of the invention.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 7","FIG. 6"],"b":["51","55"]},{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 8","FIG. 6"]},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 9","sub":"a"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 15","FIG. 14"]},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
