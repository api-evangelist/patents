---
title: Ontology-driven information system
abstract: An ontology-driven information system includes a plurality of models, each of which expresses an aspect of a business domain using concepts and relationships between concepts. An ontology, which is in communication with each of the plurality of models, provides uniform definitions for the concepts and relationships between concepts used in the plurality of models. A method for executing an interaction flow model includes receiving an event and categorizing the received event. Once the event is categorized, a situation that matches the categorized received event is identified. One or more tasks are then executed for the situation. The execution of the one or more tasks can include either an interpretation of a model or the execution of a method of an object. The information system also includes a user and application interface and a reasoning engine that is in communication with the user and application interface. A knowledge manager is in communication with the user and application interface and is interfaced with the reasoning engine. A distributed information service also is in communication with the reasoning engine, the knowledge manager, and the user and application interface.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07567915&OS=07567915&RS=07567915
owner: 6100198 Canada Inc.
number: 07567915
owner_city: West Vancouver
owner_country: CA
publication_date: 20061020
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EXEMPLARY EMBODIMENTS"],"p":["This is a division of application Ser. No. 09\/642,200, filed Aug. 18, 2000 now U.S. Pat. No. 7,200,563, entitled \u201cOntology-Driven Information System,\u201d which claims the benefit of U.S. Provisional Application No. 60\/150,204, filed Aug. 20,1999, entitled \u201cOntology-Driven Information System,\u201d and U.S. Provisional Application No. 60\/165,147, filed Nov. 12, 1999, entitled \u201cOntology-Driven Information System,\u201d all of which are incorporated herein by reference.","The present invention relates generally to computers and, more particularly, to an ontology-driven information system.","Since the development of the Internet's World Wide Web (\u201cthe web\u201d), the number of companies engaged in electronic commerce (\u201ce-commerce\u201d) has steadily increased. Indeed, companies now offer a multitude of products and services online. By conducting business on the web, companies can decrease operational costs and expedite business activities. The web is also an effective medium for presenting information to and gathering information from customers.","To gain an edge in the increasingly competitive marketplace, companies must interact with their customers in an intelligent, personalized, and productive manner. One way for companies to further this objective is to create meaningful interactions with customers on the web. At present, many e-commerce systems do not enable companies to create meaningful, two-way interactions with customers, but instead merely implement one-way transactions, e.g., processing an order or a service request, initiated by the customer. As such, these e-commerce systems do not help companies interact effectively with their customers on the web.","To enable meaningful interactions with customers on the web, an e-commerce system should provide the following functionality. First, the system must access data that is distributed across numerous sources and react to events coming from numerous sources. In the case of a large enterprise, the data may reside in relational database management systems (RDBMSs), flat files, and large-scale packaged applications. The events may come from Internet feeds, news services, and e-commerce systems (exchanges). In addition, the events may come from event-based Internet middleware. Second, the system must analyze the distributed data and transform such data into an intelligent, personalized recommendation in real time. If the analysis is not conducted in real time, then the customer will have to wait for the intelligent, personalized recommendation. Any significant delay, e.g., a few minutes, decreases the likelihood that the customer will act on the recommendation. Third, the system must accommodate frequent changes in business conditions. In particular, it must be easy to change the business rules and business processes used to transform the data into the intelligent, personalized recommendation. If the business rules and business processes cannot be easily changed, then the system will not be able to keep up with the way the company is doing business.","Unfortunately, existing e-commerce systems do not provide the above-described functionality. One known e-commerce system generates personalized recommendations by matching business rules against customer attributes, e.g., age group, geographic region, and buying history. In this e-commerce system, however, it is difficult to change the business rules to adapt to changing business conditions. To illustrate this point, examples of the business rules used in this system are shown below:",{"@attributes":{"id":"p-0008","num":"0007"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Rule No. 1:","If","Customer lives in California &&"]},{"entry":[{},{},"They are 18-30 years old &&"]},{"entry":[{},{},"They selected a backpack"]},{"entry":[{},"Then","Recommend tents with a priority of 10."]},{"entry":["Rule No. 2:","If","Customer lives in New York &&"]},{"entry":[{},{},"They are 31-50 years old &&"]},{"entry":[{},{},"They selected a backpack"]},{"entry":[{},"Then","Recommend hiking shoes with a priority of 10."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"In the event that business conditions change, Rule Nos. 1 and 2 must be changed to reflect the new business conditions. For example, consider a situation in which market analysis shows that the age group breakdowns in Rule Nos. 1 and 2 should be changed from 18-30 years old and 31-50 years old to 18-34 years old and 35-50 years old, respectively. To implement this change, it would be necessary to change each occurrence of \u201c18-30 years old\u201d to \u201c18-34 years old\u201d and to change each occurrence of \u201c31-50 years old\u201d to \u201c35-50 years old.\u201d As there are only two business rules in this simplified example, making the required changes is not a major undertaking. To adequately model any non-trivial domain, however, hundreds or thousands of business rules may be required. Thus, in real world applications the process of changing myriad business rules in the form of Rule Nos. 1 and 2 is not only tedious, but also prone to error. Moreover, because the business rules are typically entered on a logic language level, skilled computer personnel is generally required to implement the changes. This is problematic because non-technical business managers may not be able to change the business rules as quickly as needed to keep up with the way the company is doing business.","Another example of changing business rules is the occurrence of additional context that requires that a different result be implemented when a given rule is satisfied. For instance, the system may be required to incorporate a customer's purchase history to formulate an intelligent recommendation. By way of example, if a customer has recently purchased a tent, then a recommendation suggesting that the customer purchase a tent would normally not be considered to be an intelligent recommendation.","In view of the foregoing, what is needed is an e-commerce system that analyzes distributed data and transforms such data into intelligent, personalized recommendations in real time using flexible business rules that can be easily adapted to ever-changing situations.","Broadly speaking, the present invention fills this need by providing an information system that transforms raw data from disparate sources into intelligent, personalized recommendations that may be used to drive business transactions.","In accordance with one aspect of the invention, an ontology-driven information system is provided. This information system includes a plurality of models, each of which expresses an aspect of a business domain using concepts and relationships between concepts. An ontology, which is in communication with each of the plurality of models, provides uniform definitions for the concepts and relationships between concepts used in the plurality of models. The use of the uniform definitions in the plurality of models avoids redundancy in the models, provides consistency between the models, and enables the plurality of models to provide an overall model of the business domain that is more expressive than an overall model based on a plurality of models that does not use uniform definitions. In one embodiment, the uniform definitions in the ontology can be changed on the fly by a business manager.","In accordance with another aspect of the invention, a method for executing an interaction flow model is provided. This method includes receiving a plurality of events and categorizing the received event events. Once the events are categorized, a situation that matches the categorized received events is identified. One or more tasks are then executed for the situation. The execution of the one or more tasks can include either an interpretation of a model (e.g., a rule base) or the execution of a method of an object.","In accordance with yet another aspect of the invention, an information system is provided. The information system includes a user and application interface and a reasoning engine that is in communication with the user and application interface. The system further includes a knowledge manager that is in communication with the user and application interface and is interfaced with the reasoning engine. A distributed information service also is in communication with the reasoning engine, the knowledge manager, and the user and application interface. The reasoning engine may be configured to work in conjunction with the knowledge manager to enable the reasoning engine to handle events by executing one or more specific tasks prescribed by the knowledge manager to handle the events most appropriately. In one embodiment, the knowledge manager includes an interaction flow model that is a repository for abstract situations to handle the events received by the reasoning engine, with the situations defining the one or more tasks that are to be executed by the reasoning engine.","In another embodiment, the information system includes a reasoning engine and a knowledge manager. The reasoning engine may be configured to derive a set of conclusions using a set of premises and to execute actions that are attached to the set of conclusions. The set of premises may be encoded using a plurality of models. The knowledge manager serves as a repository of the plurality of models. Each of the plurality of models is configured to define situations that occur in decision making to achieve a goal state. The knowledge manager includes an ontology, which is a collection of concepts and contexts used to provide a common vocabulary for defining rules, querying disparate data sources, and making actionable recommendations. As such, the ontology provides consistency between the plurality of models.","In accordance with a further aspect of the invention, a computer readable media having program instructions for executing an interaction flow model is provided. The computer readable media includes program instructions for receiving an event (or a plurality of events), program instructions for categorizing the received events, program instructions for identifying a situation that matches the categorized received events, and program instructions for executing one or more tasks for the situation. The execution of the one or more tasks includes one of an interpretation of a model and execution of a method of an object.","The information system of the invention enables e-market participants to apply business rules to data captured from disparate sources, e.g., existing enterprise databases and the Internet, to match buyers' interests with sellers' expertise taking into account goals, preferences, behaviors, and market context. In this manner, the information system provides more accurate and timely recommendations that increase the likelihood that a transaction will occur at the moment of contact. Such accurate and timely recommendations also increase customer satisfaction and thereby reduce customer attrition. Another advantage of the information system is that it uses business rules that are constructed using ordinary terms that can be changed on the fly by a non-technical business user. This helps reduce maintenance costs and increase responsiveness.","It is to be understood that the foregoing general description and the following detailed description are exemplary and explanatory only and are not restrictive of the invention, as claimed.","Several exemplary embodiments of the invention will now be described in detail with reference to the accompanying drawings.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 1A","b":["2","10","3","4","5","6","10","7","8","9","9","28","28"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 1B","FIG. 2"],"b":["10","10","12","14","16","18","20","18","10","18","10","22","10","24","28","28","18"]},"Distributed information service  interacts with database , enterprise information systems (EIS) , and other resource managers (not shown). In one embodiment, distributed information service  uses J2EE specified contracts to interact with these components. In one embodiment, database  includes one or more relational database management systems (RDBMS). Additional details of distributed information service  are set forth below with reference to .",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 2","FIG. 3","FIGS. 4A and 5"],"b":["10","12","14","16","18","12","12","12","16","18","12","14","12"]},"Knowledge manager  provides the functionality that is required to store and manipulate ontologies and other models of a domain. As part of an ontology, knowledge manager  maintains concepts and relationships to construct business rules, constraints, and processes. Business models use these rules, constraints, and processes to capture knowledge about a specific business domain. This knowledge may be used to reason about the domain and to derive actions to achieve stated goals. The use of concepts and relationships provides a higher abstraction on which business models can be built. This is advantageous because it enables the business models to be built more efficiently and to be managed more easily. Knowledge manager  communicates with distributed information system  and user and application interface through architected contracts. Additional details of knowledge manager  are set forth below with reference to .","Distributed information service  provides the functionality that is required to access heterogeneous, distributed data sources. More particularly, distributed information service  is a collection of services that shield other modules of information system , as well as external applications, from the details of accessing disparate information resources. Thus, distributed information service  provides a uniform and simple way to access these information resources. Each information resource may be accessed via a Uniform Resource Identifier (URI), which is a logical name that hides the location and the access protocol from the resource consumer. Furthermore, transaction and security management is handled outside the application. Distributed information service  manages a repository of information about the resource and uses that information to locate the external resource manager, to establish a connection with the resource manager, and to interact with the resource manager to, e.g., store and retrieve data. This augmentation information also is used to translate the external data into a uniform format that can be processed by client applications as well as various presentation channels. Distributed information service  communicates with reasoning engine , knowledge manager , and user and application interface  through architected contracts. Additional details of distributed information service  are set forth below with reference to .",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 3","b":["18","18","18","18","18","18","18","18","18","18","18"],"i":["a","b","c","d","e","a","c","d ","e"]},"In one embodiment, the architecture of user and application interface  is based on three technologies: Java Components, XML-based access protocols, and Business Model Languages. Java Components are Java objects that offer an interface to call methods, which implement or make accessible the functionality provided by information system . These components may be implemented using EJB, which is the standard component model for Java. Suitable XML-based access protocols include, but are not limited to, 1) HTTP with HTML or a specific XML content format, and 2) JMS with specific XML content format. The Business Model Languages deal with the capturing of knowledge that is entered into the system by a business user. This component of user and application interface  is concerned with representing the business rules, processes, and constraints that form a model of the business.","User and application interface  provides components to access services that are implemented in other modules, e.g., the distributed information service. The intrinsic functionality of user and application interface  also may be accessed via components. As used in connection with the description of the invention, the term \u201ccomponent\u201d refers to an object that provides access to data or logic or assembles data or logic. Thus, the data or logic need not be implemented by the component. Generally speaking, it must be possible to access the components through a remote client. By way of example, this remote client may be a browser or another application. To this end, the interface components may be implemented as EJB components. These components, which provide access for multiple remote clients where each client is isolated from the activity of other clients, encapsulate the state of a client session. In one embodiment, the intrinsic functionality of user and application interface  is abstracted by a set of commands. These commands may be accessed via a component or a command language interpreter.","System administration interface contains commands to configure the resource environment and to monitor running services. As such, system administration interface provides the functionality that is required to let a user enter resource naming and location information. Each information collection that can be retrieved from information system  can be specified using a Uniform Resource Identifier (URI), which is mapped and located by distributed information system , as described in more detail below. Table 1 illustrates exemplary commands contained in system administration interface .",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Naming context"]},{"entry":[{},"Add"]},{"entry":[{},"Remove"]},{"entry":[{},"Show (show the attributes and relationships of a naming context)"]},{"entry":[{},"Resource Connector"]},{"entry":[{},"Add (add a connector, e.g., Oracle JDBC driver)"]},{"entry":[{},"Remove"]},{"entry":[{},"Show (show the attributes and relationships of a connector)"]},{"entry":[{},"Entity Resource"]},{"entry":[{},"Add (create an entity that represents an information collection)"]},{"entry":[{},"Remove"]},{"entry":[{},"Show (show the attributes and relationships of an entity)"]},{"entry":[{},"Logging"]},{"entry":[{},"Start"]},{"entry":[{},"Stop"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Application deployment interface is the process that configures a specific application for its runtime environment. Table 2 illustrates exemplary commands contained in application deployment interface in accordance with one embodiment of the invention.",{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Data Source"},{"entry":"Add"},{"entry":"Remove"},{"entry":"Verify (test if a connection can be established)"},{"entry":"Show (retrieve attributes of a data source)"},{"entry":"Find"},{"entry":"External Schema"},{"entry":"Extract (import the schema from a given external data source)"},{"entry":"Create (create a schema in a given external data source)"},{"entry":"Verify (test whether a given schema is equal to the schema of a given data"},{"entry":"source)"},{"entry":"Show (retrieve the objects that are part of the schema (type definitions,"},{"entry":"elements, attributes)"},{"entry":"Find"},{"entry":"Application Schema"},{"entry":"Add (create a schema)"},{"entry":"Remove"},{"entry":"Derive (create an application schema based on an External Schema)"},{"entry":"Show (show the attributes and relationships of an application schema)"},{"entry":"Map (various mapping functions)"},{"entry":"Find"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Business modeling interface is concerned with the creation and management of business models. By way of example, business models include rule bases and business process flows. Business modeling interface serves as the entry point into information system  for business personnel, e.g., business line or marketing campaign managers, and provides the functionality that is required to enable these users to enter business rules, constraints, and processes. In one embodiment, business modeling interface implements the abstract commands shown in Table 3.",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Ontology"]},{"entry":[{},"Open"]},{"entry":[{},"Close"]},{"entry":[{},"Merge"]},{"entry":[{},"Concept Hierarchy"]},{"entry":[{},"Add concept"]},{"entry":[{},"Remove concept"]},{"entry":[{},"Relationship"]},{"entry":[{},"Add"]},{"entry":[{},"Remove"]},{"entry":[{},"Rule Base"]},{"entry":[{},"Open"]},{"entry":[{},"Add Rule"]},{"entry":[{},"Remove Rule"]},{"entry":[{},"Interaction Flow"]},{"entry":[{},"Add Interaction"]},{"entry":[{},"Remove Interaction"]},{"entry":[{},"Add Event"]},{"entry":[{},"Remove Event"]},{"entry":[{},"Add Task"]},{"entry":[{},"Remove Task"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Application object system allows an application to interface with information system  using Java objects of the modeled domain. Information system  uses the application schema to construct these objects. Application object system also is used to integrate information system  with tools that support or automate the process of building a graphical representation, e.g., a user interface. The objects that are constructed represent a model of the domain. This model can be used in Model-View-Controller type user interfaces. The model includes objects that are defined in an application schema, e.g., objects such as Customer, Product, or Offer. The objects of the domain model preferably comply with the Java Beans specification. This allows information system  to use standard tools to build views and controllers corresponding to the object model. In this manner, application object system transforms the generic representation of information items into a typed object system.","Delivery channel interface provides access to the services provided by information system  via communication protocols. This submodule also is concerned with the preparation of the content for display or further processing by a remote client. Delivery channel interface serves as the entry point into information system  for end users and provides the functionality that is required to deliver the personalized product and service recommendations. One function of delivery channel interface is to provide mechanisms to extract information from information system  in a generic form. These mechanisms stand in contrast with application object system , which represents domain objects as strictly typed Java Beans.","Delivery channel interface also enables the exchange of XML data with the information system environment. Thus, any software system, e.g., middleware, that is able to process XML-structured data and supports one of the channel protocols can communicate with information system . Every information set that can be retrieved from information system  can be specified using a Uniform Resource Identifier (URI). In contrast with Uniform Resource Locators (URLs), a URI does not encode the location of the resource. Information system  maintains a repository of resource references and locates the resources based on the URI. As will be described in more detail below, a URI is mapped and located by distributed information service .","As noted above, information system  supports a number of communication protocols. Delivery channel interface allows further protocols to be added. In one embodiment, the HTTP\/HTTPS protocol family with the following content formats is supported initially: SOAP (Simple Object Access Protocol); WML (Wireless Markup Language); and HTML (the World Wide Web protocol). All of these protocols use some specific form of XML as the data content format. Delivery channel interface also provides components that encapsulate particular services of information system . These components, which belong to a special system domain, are used to access information and recommendations from generic applications. They do not implement the functionality but rather delegate the requests to the specific modules. Examples of such components include the interaction flow engine and the distributed information service, both of which are described in detail below.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 4A","FIG. 4A","FIG. 4A"],"b":["12","12","12","12","12","12","12","12","12","12","10","12","12","12","12","10"],"i":["a","b","c, ","d","e","f. ","a ","b","f ","a "]},"In one embodiment, each engine that is part of reasoning engine  acts upon its own model. As used herein, a \u201cmodel\u201d is a representation of an aspect of the business domain. The engine and the models are tuned to one another, thereby providing an efficient way to describe a part of the business domain and to perform efficient reasoning on the model. As used herein, \u201creasoning\u201d refers to the process of reaching conclusions based on a formal representation of the domain, e.g., a model, and an inference procedure. Reasoning engine  reacts to changes in the information system environment by use of user and application interface  and the distributed information service . These modules act as the sensors and actors to the outside world. When acting in the capacity of sensors, these modules deliver events and thereby cause the invocation of reasoning engine  and, more particularly, interaction flow engine ","Interaction flow engine provides the functionality that is required to coordinate the usage of external data, ontologies, business rules, business constraints, and optimization parameters. As indicated above, interaction flow engine invokes specialized engines that are able to interpret specialized models. In a given business context, interaction flow engine generates a set of candidate recommendations, e.g., goods, services, or information, based on a customer profile and a set of business rules and constraints. The customer profile may reflect the customer's interests and the business rules and constraints may reflect the business' expertise and goals. Interaction flow engine then prescribes the collection of feedback at the time when the interaction happens. Interaction flow engine may further specify that the recommendations be optimized based on the feedback and other contextual information, the optimization models, and further business rules. It will be apparent to those skilled in the art that, because the process flow is model driven, other business interactions may be specified easily.","Interaction flow engine uses an interaction model to drive the recommendation process. This interaction model is described in more detail below (see the description of interaction flow model set forth below with reference to ). Interaction flow engine communicates with distributed information service  through an architected contract. In particular, interaction flow engine invokes methods of arbitrary Java objects. These Java objects are located using the services of distributed information service . Furthermore, interaction flow engine uses the interfaces of inference engine , constraint satisfaction engine , and optimization engine ","Interaction flow engine is responsible for initiating actions based on the precepts of the environment. The general execution principle is as follows:","1. Identify which situation of the situations specified in the interaction flow model is most appropriately reflecting the real world. To do this, interaction flow engine invokes categorization engine , which, as described in more detail below, classifies events and other available and relevant information (e.g., user input and information stored in a database).","2. Categorization engine determines a set of categories for events that have occurred. A preceding situation that has been dealt with is an event. Further, the categorization engine determines a set of categories for information entities that are stored in a database and that are relevant for classifying a situation.","3. Based on the categorized events and categorized input data, a situation action is selected and the associated actions are executed. The actions may be the interpretation of a model (one of the built-in actions) or the execution of a method of an object. Model-related actions include, for example, infer, search with constraints, interact, optimize, decide, etc. A situation can describe multiple alternatives and loops. The \u201cdecide\u201d action describes a branch in the flow.","4. After the situation is dealt with, i.e., the termination state is reached, the completion of the situation is recorded as an event.","Step 1) is similar to identifying the state in a classic workflow engine. The process of situation identification is, however, more powerful than simple state-transition models because it takes into consideration that the flow is interrupted after a situation is dealt with. Even if the situation prescribes the transition into a follow-up situation, as states do when the transition into a new state is made, the new situation does not occur unconditionally. It also is not deterministic when the following situation occurs. Often it depends on when and what feedback the user provides. Interaction flow model (see ) may specify the usage of another model, e.g., a rule base, to evaluate what situation most appropriately reflects the real world situation.","Interaction flow engine uses distributed information service  (see ) to locate a Java object that is an information resource. Interaction flow engine need only provide a Uniform Resource Identifier (URI) to distributed information service  to locate the Java object. Distributed information service  manages the additional information that is needed to look up the desired object and does the lookup for interaction flow engine ","Categorization engine provides the functionality that is required to categorize objects, which can be information entities or events. An information entity may be stored in an external system or sent to information system  using one of the interfaces. Events may be created in storage systems or an application, or may be delivered via one of the channel interfaces. During categorization, all concepts of which that object is an instance are determined. Categorization engine uses the properties and relationships of a concept to test the membership. The properties and relationships of a concept are defined in conceptual model , which is described in more detail below with reference to . Categorization engine may use a number of techniques to perform classification, which include, but are not limited to, property value testing, exemplar approximation, and probabilistic techniques. Categorization engine may receive requests for categorizations from interaction flow engine and inference engine In addition, categorization engine uses the interfaces of conceptual model (see ).","Inference engine , which also may be referred to as a rule engine, provides the functionality that is required to perform logical inference. \u201cLogical inference,\u201d which is sometimes referred to as deduction, is the process of deriving conclusions that are entailed in a set of rules and a set of facts known to be true. A \u201crule\u201d is a pair of premise or antecedent and conclusion or consequent. A set of rules, e.g., a rule base, is compiled into an efficient form for execution by inference engine . During logical inference, the entailment relation over a set of rules and a set of facts is computed. The inferred knowledge is useful only if it helps to take actions. The actions may be taken by interaction flow engine , which uses the inferred statement. Inference engine uses the interfaces of rule base , which is described in more detail below with reference to .","Constraint satisfaction engine provides the functionality that is required to search for states in the state space that satisfy a number of constraints and the goal test. Thus, constraint satisfaction is a modified search problem and constraint satisfaction engine is a special kind of search engine. In this context, states are instances of concepts. Constraints can be either absolute or preferences. Violation of an absolute constraint rules out a potential solution. In the case of preferences, one solution is preferred over another. Constraints may be dynamically inferred by inference engine or taken from a profile or constraint base, which is managed in constraint model (see the description of constraint model set forth below with reference to ). A set of constraints, e.g., a constraint base, is compiled into an efficient form for execution by constraint satisfaction engine . Furthermore, constraint satisfaction engine uses the interfaces of inference engine , constraint model (see ), and query service (see ).","An example of a constraint satisfaction problem is the search for products that match certain criteria. In this case, the inference engine is invoked first and the inferred concepts and constraints are taken and passed to the constraint satisfaction engine. The inference engine does not search for instances of the concepts. Rather, the inference results are interpreted as constraints by the constraint satisfaction engine. The constraint satisfaction engine now combines the constraints with a search strategy to come up with appropriate instances. The instances may be particular objects such as goods, services, and information. In many cases, the constraint satisfaction engine may reformulate the constraints into a query that is passed on to the query service in the distributed information service.","Optimization engine provides the functionality that is required to find an optimal solution among a number of candidate solutions. Optimization engine is used when a problem may be solved by selecting a solution that is optimal with respect to an optimization criterion. This typically requires that a metric exist. Finding a solution, e.g., a set of products to recommend, by optimization usually leads to more accurate results than simple constraint-bound searching. Optimization engine communicates with distributed information service  through an architected contract. The model may be stored in a persistent storage and may be read and modified using distributed information service . Furthermore, optimization engine uses the interfaces of ontology , which is described in more detail below with reference to . The meaning of the terms that are used in an optimization model is defined via the ontology and this knowledge may be used in interpreting the model.","Data mining engine provides the functionality that is required to analyze the correlation in data and to build a predictive model from that correlation. Stated differently, data mining engine implements the functionality to build predictive models. A \u201cpredictive model\u201d takes the properties of an instance or a set of instances and produces the value of another property or relationship that is not stored in the external storage systems. By way of example, representative predictions include a person's tax bracket based on income, marital status, and number of children and a person's behavioral cluster based on previous purchases. Data mining engine communicates with distributed information service  through an architected contract.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 4B","b":["14","14","14","14","14","14","14","14","14","14"],"i":["a","b","c","d","e","f","g"]},"An ontology managed by information system  typically contains multiple concepts and relationships between concepts. The complexity of a business domain is captured mainly in the relationships between concepts because a concept alone is usually too simplistic to be helpful. In contrast, relationships between concepts are potentially very rich. A few fundamental relationships between concepts are found in many ontologies. These fundamental relationships are meronymy, hypernomy, and synonymy. Meronymy is defined between a whole concept and its partial concepts and is called the HAS_A relationship. Hypernomy is defined between a concept and its subconcepts and is called the IS_A relationship. Synonymy exists within a number of terms referring to a concept if one can be used for the other and the meaning would be the same relative to a specified context.","Interaction flow model manages multiple interaction flow models, that is it performs operations such as creation, reading, modification, and deletion with these models. An interaction flow includes a number of situations. Each situation has a context description that contains the event concepts that a situation requires in order to occur. An interaction flow is compiled into an efficient form for execution by interaction flow engine (see ). Interaction flow model communicates with distributed information service  through an architected contract. The model may be stored in a persistent storage and may be read and modified using distributed information service . Furthermore, interaction flow model uses the interfaces of ontology . In particular, the meaning of the terms that are used in interaction flow model is defined via ontology . This knowledge may be used in interpreting the model.","Ontology of information system  serves as the common thread between all other models. For this reason, information system  is therefore an ontology-driven information system. In a more general sense, but still in the context of the information system described herein, an ontology helps to formulate and relate various other knowledge representation models, which usually are based on first order logic or interaction flow. Concrete models typically use a vocabulary. The vocabulary may be made up of words and word phrases of the particular domain. To relate different models, a commitment to the meaning of the vocabulary is needed. If, for instance, one model makes propositions about a \u201cconservative investor,\u201d then another model can refer to the same concept and assume the same intention for the concept. Ontology is linked to all of the other models by terms that are used in those models and that are defined in the ontology. Ontology communicates with distributed information service  through an architected contract.","Each knowledge representation model refers to a conceptualization of the domain. A \u201cconceptualization\u201d is a model that represents the domain as concepts. A \u201cconcept\u201d is an abstraction for a set of things. The set also may be called a category or class. The process of assigning a thing to a category is called categorization or classification. A conceptualization gathers relationships between concepts, especially the relationships between concepts and their properties, which also can be concepts. Those skilled in the art will appreciate that concepts exist independently of the words that are used to denote the concepts. For instance, the concept to which the English noun \u201cbench\u201d refers exists independently of the existence of the English language. Indeed, in the German language the noun \u201cbank\u201d is used to refer to this concept. However, the English noun \u201cbank\u201d refers to a different concept.","Humans categorize concrete objects of the world as instances of concepts. Concepts are very useful for expressing knowledge so that it is understood by computer-based interpreters. Here, \u201cunderstanding\u201d refers to the derivation of conclusions and actions. Humans use concepts to cope with the limitations of the human memory. The knowledge that humans have about even simple concepts is huge and differs from person to person. A conceptualization allows humans to reason about the knowledge without having to process the associated knowledge completely. Often it is perfectly reasonable to categorize an object and reason about it using the concept. The irrelevant properties of that instance are simply ignored. Thus, there are two basic operations in which a conceptualization is used: categorization of an object and inference using the concept.","An ontology relates a modeling language to a conceptualization. The relation is indirect because the ontology specifies the intended meaning of a vocabulary in the modeling language. If the vocabulary is used in these models, then the models commit themselves to that meaning. This commitment restricts the models that can be expressed using that modeling language. It also means that different models enter a mutual commitment via the ontology. The various models agree with the meaning of the terms that they use and will not contradict the meaning that is formulated in the conceptualization. The models can and will add more knowledge around the concepts but they do not redefine the terms. For those models, the terms have an inner structure that is solely defined outside of the model. The model would otherwise treat the terms as atoms.","An ontology is very closely related to, but not the same as, a conceptualization. Two different ontologies can be linked to the same conceptualization. For instance, take the conceptualization of \u201cmortgages\u201d plus an ontology that uses French terms and another that uses English terms. Using an ontology in a modeling language is essentially the same as declaring publicly that the terms of the vocabulary refer unambiguously to particular concepts of the conceptualization. Although a conceptualization may have more than one or no ontology, an ontology is practically useless without a conceptualization.","Conceptual model manages the creation, modification, and deletion of concepts, which form the basis of a conceptual model. A \u201cconcept\u201d is represented by a set of properties and relationships. The concept may be named using the ontology. In fact, a concept may have different names in different ontologies. Conceptual model communicates with distributed information service  through an architected contract. The model may be stored in a persistent storage and may be read and modified using distributed information service .","Rule base manages multiple rule bases. A \u201crule base\u201d is a set of rules that are used together during inference. As described above, a set of rules is compiled into an efficient form for execution by inference engine (see ). Rule base is invoked by inference engine , which executes the search inference process. Inference engine is invoked by interaction flow engine , which drives the entire reasoning process. Rule base communicates with distributed information service  through an architected contract. The rule base may be stored in a persistent storage and may be read and modified using distributed information service . Furthermore, rule base uses the interfaces of ontology . The meaning of the terms that are used in the rule base may be defined via the ontology. This knowledge may be used in interpreting the rules during the inference process.","Constraint model manages multiple models that define constraints for search problems. Constraint model contains the preference manager (not shown). As described above, a set of constraints, e.g., a constraint base, is compiled into an efficient form for execution by constraint satisfaction engine (see ). Constraint model is invoked by constraint satisfaction engine , which executes the search process. Constraint satisfaction engine is invoked by interaction flow engine , which drives the entire reasoning process. A typical interaction flow involves a search for an object in external storage systems. The search criteria may be formulated during the reasoning process. Often an inference process will produce search criteria. To ensure consistency throughout the reasoning process, constraints can be formulated and stored in a constraint model. Constraints also can be preferences, in which case an implicit ordering over the search results can be expressed.","Constraints are an important factor for the outcome of recommendations. In particular, constraints are used to prevent business policies from being violated when recommendations are given. Constraints also can be used to prevent the recommendation of products, e.g., goods, services, and information, that have been rejected during a previous interaction. Constraint model communicates with distributed information service  through an architected contract. The model may be stored in a persistent storage and may be read and modified using distributed information system . Furthermore, constraint model uses the interfaces of ontology . The meaning of the terms that are used in a constraint model may be defined via the ontology. This knowledge may be used in interpreting the model.","Optimization model manages multiple models that define metrics for optimization problems. Suitable metrics include formulas and simple properties of concepts. As described above, an optimization model is compiled into an efficient form for execution by optimization engine (see ). Optimization model communicates with distributed information service  through an architected contract. The model may be stored in a persistent storage and may be read and modified using distributed information system . Furthermore, optimization model uses the interfaces of ontology . The meaning of the terms that are used in an optimization model may be defined via the ontology. This knowledge may be used in interpreting the model.","Predictive model manages multiple models that define formulas or values found by data mining engine (see ). A \u201cpredictive model\u201d describes a functional dependency between one or more properties of one or more instances and a property that is not externally stored. Predictive model communicates with distributed information service  through an architected contract. The model may be stored in a persistent storage and may be read and modified using distributed information system . Furthermore, predictive model uses the interfaces of ontology . The meaning of the terms that are used in a predictive model may be defined via the ontology. This knowledge may be used in interpreting the model.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 5","b":["14","12","12","14","12","14","12","14","12","14","12","13","14","14","14","14"],"i":["a ","a","e ","f","c ","d","d ","e","a ","b ","d","f","e"]},"To illustrate how the components shown in  may interact, an exemplary situation in which reasoning engine  and knowledge manager  interact with one another to generate a recommendation in response to events will now be described. In response to an event or set of events received from the real world, interaction flow engine initially triggers categorization engine to determine a set of categories for the events that have occurred. In one embodiment, a preceding situation that has been dealt with also is considered an event. Based on the categorized events, a situation action is selected by searching interaction flow model . In one embodiment, the selected situation action obtained from interaction flow model is in the form of a task list. Thus, the task list, which may include one or more tasks, is read by interaction flow engine ","In this example, the task list includes instructions to interact with each of optimization engine , inference engine , and constraint satisfaction engine . It should be appreciated, however, that there are many scenarios in which only one of optimization engine , inference engine , and constraint satisfaction engine is needed to execute the instructions from the task list. In other instances, interaction flow engine can communicate with one or more external applications  (or external models) to execute the instructions from the task list. Returning now to the description of the example, the task list may require that inference engine execute an inference for the situation provided by interaction flow engine . Accordingly, inference engine will execute an inference using rule base model . Thus, the inference engine provides the functionality that is required to perform logical inference. As described herein, logical inference is the process of deriving conclusions that are entailed in a set of rules and a set of facts known to be true. A rule is a pair of premise or antecedent and conclusion or consequent. The set of rules may be compiled into an efficient form by rule base model for execution by inference engine ","Inference engine passes the result, which is in the form of a number of constraints, to interaction flow engine , which then executes the next task in the task list. In this example, the next task in the task list requires that constraint satisfaction be performed. Accordingly, interaction flow engine will pass the number of constraints to constraint satisfaction engine , which also receives compiled constraint model data from constraint model . Constraint satisfaction engine will then perform a search (i.e., execute) to identify a set of objects or solutions (e.g., a set of products or services to be recommended). The set of objects or solutions may then be communicated back to interaction flow engine . In other instances, only one object or solution may be provided. If further refinement within a set of objects or solutions is set forth in the task list, then interaction flow engine passes the objects or solutions to optimization engine ","In this case, optimization engine will also obtain compiled information from optimization model to execute an optimization model, e.g., an optimization algorithm. The optimal solution may be recorded as an \u201cevent\u201d and communicated back to interaction flow engine . In other words, optimization engine functions to determine a solution that is optimal with respect to the optimization model. In one embodiment, this requires that a metric exist. Finding a solution, e.g, a set of products, to recommend by optimization leads to more accurate results than simple constraint-bound searching. At this point, interaction flow engine may communicate the result to the appropriate receiving module or interface, such as distributed information service (DIS) . By way of example, the receiving module may be a message system, the user, a display, a database, or any other type of data receiving, data storing, or data processing object. Those skilled in the art will recognize that the number and type of engines contained in reasoning engine  may be varied from that shown in . Furthermore, because the process flow is model driven, interaction flow engine  can interact with other business models, applications, or objects.",{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 6","b":["16","16","16","16","16","16","16","16","16","16"],"i":["a","b","c","d","e","f. ","a ","a "]},"Mapping service provides the functionality that is required to implement aggregated objects whose attributes and relationships come from multiple physical data sources. Mapping service uses the interfaces of naming service , storage system , schema manager (a schema may be stored in an external storage system), and data model . Storage System defines the abstractions that all resource adapters , etc. must implement to plug into information system  as a data and event resource. Generally, abstractions unify different storage systems along various dimensions. More specifically, the storage system defines unification for connection management, transaction management, security management, interaction management, schema management, event management, and data structure representation.","Connection management specifies how connections to external enterprise information systems are created and pooled. Interaction management specifies how operations\/statements that retrieve, create, update, and delete data in the specific storage systems are expressed and invoked. Schema management specifies how the schema information that is employed by a storage system is retrieved and manipulated. Data structure representation specifies how data structures, which have been returned from a retrieval operation, are examined and how they are provided for creation and update operations. Transaction management specifies how an application server uses a transaction manager to manage transactions across multiple resource managers. This contract also supports transactions that are managed internal to an EIS resource manager without the necessity of involving an external transaction manager. Security management enables secure access to an information resource, e.g., an RDBMS, a messaging system, or a packaged application. Additional details of storage system are set forth below with reference to .","Schema manager provides the functionality that is required to create, read, update, and delete schemas. The main purpose of the schema manager is to create application schemas. These schemas are used to communicate the guaranteed structure of information items to other modules and applications, which can programmatically explore, display, and map the structure. Schema manager uses the interfaces of naming service , storage system , and data model . Query service provides the functionality that is required to execute queries that involve multiple physical data sources and schemas. Distributed information service  provides a uniform view on aggregated data coming from multiple heterogeneous data sources and, therefore, it is desirable to query that view as if it were a single data source. The query language should be compliant with URI notation. As described above, distribution information service  makes an information resource available under a URI. To find that information resource, an extended URI syntax, e.g., XPath, which allows selection of specific items along a path, may be used. Query service uses the interfaces of naming service , schema manager , and data model ","Data model provides a way to communicate the structure of a data item to its users, e.g., other modules, services, and applications. Thus, the data model is a foundation that is used by many other modules. Data model also makes the values of the data structure accessible via a single API. In one embodiment, the data model uses an interface approach to access the data structures. Interfaces are desirable because they carry only minimal runtime overhead and do not add unnecessary development effort, provided they are small and concise.","Data model provides an abstraction for all data structures that are stored in external storage systems. The data model lends itself to the abstract data model that is behind XML documents. The basic entity is an item. Items can have attributes, which have an atomic data type (no visible internal structure). Items also can have relationships with other items. These relationships may be represented as parent-child relationships. This means that each item has at most one parent. Using this relationship, aggregation can be expressed. General associations may be modeled using reference attributes. A \u201creference attribute\u201d is similar to a Java object reference. Items have names that indicate the type of an item. However, data items do not have to be strictly typed. Although an item may be an instance of a class, it nevertheless can have additional attributes and relationships. If the class defines essential attributes and relationships, then the item must have such attributes and relationships.",{"@attributes":{"id":"p-0095","num":"0094"},"figref":["FIG. 7","FIG. 6","FIG. 7","FIG. 3","FIG. 3","FIG. 6"],"b":["16","16","104","104","104","104","104","104","16","106","16","108","18","18","108","106","16","18","16","16","16","16","16"],"i":["c ","c ","a","b","c","d","e","f","c ","c ","d ","c ","a ","c ","a","b","d","f "]},{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIG. 8","b":["300","302","302","302"]},"The method proceeds to operation  in which data that meets the criteria of the rules being processed for the profile is found and retrieved. As described above, the rules are expressed in terms of generalized concepts, which may have different meanings in different contexts. The data that is found and retrieved in operation  includes the specific instances of the generalized concepts that apply to the context of the user. Next, in operation , found data that conflicts with the user's preferences is removed. The method then proceeds to operation  in which the remaining found data is optimized in order of preference against the context of the user. This optimization operation may be implemented using an appropriate optimization algorithm. In one exemplary embodiment of the invention in which investment recommendations are generated, the Markowitz optimization algorithm may be used. The optimization algorithm generates a set of products or services that optimizes the remaining found data relative to a goal test, which may be defined by the user.","Once the optimized data has been generated, the method proceeds to operation  in which the optimized data, e.g., a product recommendation, is displayed to the user. If desired, the optimized data may be displayed to the user together with the reason for the selection and the ranking. Operations - collectively comprise a product recommendation (PR) situation. Once the product recommendation or other optimized data is displayed in operation , the product recommendation situation has reached its terminated state and the method waits for an event to occur before any further action is taken. If the user fails to respond within a predetermined period of time, then an \u201cexit\u201d event is deemed to occur and this exit event is recorded. If the user responds, then a \u201cresponse\u201d event is deemed to occur and the method proceeds to operations -, which collectively comprise a response situation.","In operation , the feedback from the response is added to the user's profile. Next, in decision operation , it is determined whether the product recommendation is selected. If the recommendation is selected, then the method proceeds to operation  in which the response situation has reached its terminated state and the method transits to a purchase flow situation. On the other hand, if the product recommendation is not selected, then the method proceeds to operation  in which a constraint is added to the user's profile. This constraint is added to the user's profile to avoid providing the user with the same recommendation that was just rejected. Once the constraint is added to the user's profile, the method may cycle back up and wait for another product recommendation situation to arise.","In addition to the product recommendation situation and the response situation described above, another situation, which is labeled as situation X in , may occur. In particular, situation X may occur when external events indicate that the product recommendation made to the user is no longer valid. By way of example, in the case of a recommendation that a user purchase stock in Company A, news that Company A will experience a significant earnings shortfall may render the recommendation no good and thereby give rise to situation X. It will be apparent to those skilled in the art that numerous other events also may give rise to situation X.",{"@attributes":{"id":"p-0101","num":"0100"},"figref":"FIG. 9","b":["400","400","1","2","3","1","2","3"]},"Rule No. 1: If A, then recommend X.","Rule No. 2: If B, then recommend X.","Rule No. 3: If C, then recommend X.","Rule No. 4: If D, then recommend X.","As shown in , universal node  is coupled to classification node  by arrow . Classification node , which indicates concept A, is coupled to classification node , which indicates concept B, by arrow and to classification node , which indicates concept C, by arrow . Classification nodes  and  are each coupled to classification node , which indicates concept D, by arrows  and , respectively. Universal node  is coupled to nodes , , , and by arrows , , , and , respectively, and to nodes , , , and by arrows , , , and , respectively. Nodes , , , and indicate concepts X, X, X, and X, respectively. Nodes , , , and indicate concepts Y, Y, Y, and Y, respectively.","In this exemplary scenario, in the event Rule No. 1 fires, the specific instances of concept X, which are the items in list L, will be returned. In the event Rule No. 2 fires, the specific instances of concept X, which are the items in list L, will be returned. In the event Rule No. 3 fires, the specific instances of concept X, which are the items in list L, will be returned. In the event Rule No. 4 fires, the specific instances of concept X, which are the items in list L, will be returned.",{"@attributes":{"id":"p-0108","num":"0107"},"figref":["FIG. 10","FIG. 9","FIG. 10","FIG. 9","FIG. 10"],"b":["450","450","402","404","406","408","410","412","414","403","405","405","407","409","411","413","406","412","452","406","414","454","408","412","414","456","458","410","412","414","460","462","406","408","410","412","414","452","454","456","458","460","462"],"i":["a","b"]},"The intermediate first class objects disposed between two nodes, e.g., nodes  and , maintain the relationship between the two nodes. In the absence of such intermediate objects, the information regarding the relationship between the nodes would have to be stored in one of the nodes themselves. This is undesirable, however, because it presents complex memory management and programming issues as the system grows and the amount of relationship information stored in the nodes increases. The use of intermediate objects is a powerful solution for at least two reasons. First, the use of intermediate objects avoids the need to store relationship information in the nodes. As a result, the information stored in the nodes may be limited to strings, which the ontology treats as terms. Second, the use of intermediate objects increases the flexibility of the system by enabling additional relationships, e.g., time and precedence, to be defined in the contextual arcs, which the ontology uses to define the relationships between the terms stored in the nodes.","As shown in , nodes  and , which indicate concepts X and Y, respectively, are overloaded for concepts B, C, and D using the contextual arcs. This enables the business to implement the same selling policy defined in Rule Nos. 1-4 above with only the following business rule:","Rule No. 1: Recommend X.","When this rule fires, the specific instances of concept X that will be returned depend on the particular context. In the context of concept A, the items in list L will be returned (see arrow  in ). In the context of concept B, the items in list L will be returned (see contextual arc  in ). In the context of concept C, the items in list L will be returned (see contextual arc  in ). In the context of concept D, the items in list L will be returned (see contextual arc  in ).","Although the ontology may implement either of the above-described methods, the method described with reference to , i.e., the method in which contextual arcs are used, provides significant advantages in terms of both maintenance and also performance. As demonstrated above, the use of contextual arcs minimizes the number of business rules required to implement a given business policy. By minimizing the number of business rules required, a significant maintenance advantage is obtained because it is easier to manage fewer business rules, as illustrated below. The use of contextual arcs also provides a significant performance advantage.","To demonstrate the maintenance advantage that results from the use of contextual arcs, consider the steps a business manager would have to take to change the recommended product from X to Y in the exemplary scenario described above. Using the method described with reference to , i.e., the method without contextual arcs, the business manager would have to remove all of the business rules that recommend X, X, X, and X and add the following business rules to the ontology:","Rule No. 1: If A, then recommend Y.","Rule No. 2: If B, then recommend Y.","Rule No. 3: If C, then recommend Y.","Rule No. 4: If D, then recommend Y.","In contrast, using contextual arcs, the business manager would only have to remove the business rule that recommends X and add the following business rule to the ontology:","Rule No. 1: Recommend Y.","The use of contextual arcs also makes it easier to change the recommended products or services. For example, in the exemplary scenario described above, consider the steps a business manager would have to take to change the list of recommended stocks L. Without contextual arcs, the business manager would have to change the expression for the concept X. With contextual arcs, the business manager would only have to change the expression for contextual arc , which extends from node , which indicates concept B, to node , which indicates concept X (see ).","In summary, the present invention provides an information system that captures data from disparate sources and provides intelligent, personalized recommendations. The invention has been described herein in terms of several preferred embodiments. Other embodiments of the invention will be apparent to those skilled in the art from consideration of the specification and practice of the invention. The embodiments and preferred features described above should be considered exemplary, with the invention being defined by the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings, which are incorporated in and constitute part of this specification, illustrate exemplary embodiments of the invention and together with the description serve to explain the principles of the invention.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 7","FIG. 6"],"b":"16","i":"c "},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
