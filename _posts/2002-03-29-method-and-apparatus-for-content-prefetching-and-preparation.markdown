---
title: Method and apparatus for content pre-fetching and preparation
abstract: A method of pre-fetching and preparing content in an information processing system is provided. The method includes the steps of generating at least one content pre-fetching policy and at least one content preparation policy, wherein each of the policies are at least in part a function of context information associated with a user. The content is pre-fetched based on information contained within the at least one content pre-fetching policy. Once the content has been pre-fetched, it is prepared based on information contained within the at least one content preparation policy. The context information associated with the user includes at least one of the user's usage patterns, current location, future plans and preferences.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08516114&OS=08516114&RS=08516114
owner: International Business Machines Corporation
number: 08516114
owner_city: Armonk
owner_country: US
publication_date: 20020329
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS"],"p":["The present invention relates generally to an information processing system and, more particularly, to techniques for pre-fetching and preparing content.","Pervasive computing promises an environment in which people will be able to access any content, anywhere, at any time, and on any device. While pervasive computing offers several advantages, one of its shortcomings is that there may be increased access latency due to the extremely dynamic and variable nature of such an environment. In addition to the traditional problem of access latency due to network and server load, there are three additional factors that contribute to latency.","The first factor is device heterogeneity. That is, client devices have different form factors, modalities, and presentation formats. Due to this heterogeneity, it is necessary to have format transformation (or transcoding) capabilities in content delivery networks, especially for dynamically generated data. Such transcoding operations introduce latency that will be perceived by the user.","The second factor is network infrastructure. There are large variations in the physical characteristics of wireless channels which affect the performance perceived by the end user. This is due not only to the number of different such technologies available today but also to inherent properties of wireless channels such as multi-path fading problems, distance between client and base stations, and interference problems resulting from shared spectrum. A user's experience of accessing services can change dramatically and is a function of the user's location, the available link technologies and the number of active connections operating in the same frequency band.","The third factor is user context. Services that are available to the user may change as a function of time and as a function of the user's context. For example, services accessed in a professional environment may be different from the services accessed in a home environment. In such a situation, discovering the appropriate services at each location and binding them (i.e., interconnecting the services to each other and to other application components) introduces additional latency.","Traditional caching schemes used on proxy servers or edge servers are not sufficient to reduce access latency in pervasive environments due, primarily, to two main reasons. First, content and applications are increasingly personalized to suit the tasks and tastes of individual users. Thus, content cached for one user is often unsuitable for other users. Second, increased user mobility potentially reduces access locality, thus reducing the effectiveness of caching.","Traditional caching schemes used on client devices are also not sufficient in pervasive environments. First, mobile and task-specialized devices may be resource constrained and thus may not be able to support a sufficiently large caching storage area. Second, many pervasive applications are context specific. For example, the content delivered to the device might be specific to the geographic location of the device. Thus, content cached for one location may not be suitable in other locations.","U.S. Pat. No. 5,493,692, entitled \u201cSelective Delivery of Electronic Messages in a Multiple Computer System Based on Context and Environment of a User,\u201d to Theimer et al. (hereinafter referred to as the '692 patent), which is hereby incorporated by reference herein, discloses a method for selectively delivering electronic messages to an identified user or users in a system of mobile and fixed devices, based on the context of the system and the environment of the identified user. However, the '692 patent does not include context information that includes historical information and future plans. Additionally, although the '692 patent uses current context information to deliver electronic messages, the '692 patent does not use context information to pre-distribute and pre-process all kinds of content, as well as to manage replication among multiple copies of content.","Pre-fetching based on hyperlinks (and more generally, application structure) has been studied and applied extensively. For example, a paper entitled \u201cPre-fetching Hyperlinks\u201d by Dan Duchamp teaches a method for pre-fetching web pages into a client cache. This work makes predictions based on document content only, and does not make use of any other forms of context information. It also does not address the issues of preparation or replication management.","U.S. Pat. No. 6,243,755, entitled \u201cInformation Processing System Using Information Caching Based on User Activity,\u201d to Takagi et al. (hereinafter referred to as the '755 patent), which is hereby incorporated by reference herein, discloses a system and method to predict the information that will be required in the future by individual users using computing devices and the time at which this information will be required, based upon knowledge of the users' activity schedule. The prediction is used to transfer the necessary information to the computing device at the necessary time via a network. However, the '755 patent does not teach either management of the replicated copies of content created due to pre-fetching, or preparation of content such as via binding and transcoding ahead of time.","It is therefore apparent that a need exists for improved techniques which avoid the problems associated with the conventional approaches.","The present invention is directed to techniques for processing content in a network wherein the content is prefetched and prepared for easy and efficient access by a user. The content is prefetched and prepared in accordance with context information of the user.","In one aspect of the invention, a method of processing content in a network is provided, wherein the method includes the steps of predicting a device used by a user to access content residing in the network, wherein the prediction of the device is at least in part a function of context information associated with the user; and processing the content for access by the user via the predicted device. The processing step includes the step of transcoding the content into a predetermined format such that the format is compatible with the predicted device.","In another aspect of the invention, a method of processing content in a network includes the steps of (1) predicting at least one content item to be requested by a user, wherein the prediction of the content item is at least in part a function of context information associated with the user, and (2) pre-processing the content item for access by the user. Additionally, the method includes the steps of pre-fetching the content item and transferring the content item to at least one replica store wherein the content item is held pending a request by the user.","In another aspect of the invention, a method of maintaining data in an information network, includes the steps of (1) storing replicas of content data in two or more replica stores wherein timing of the synchronization process is a function of a user's historical context information.","In yet another aspect of the present invention, a method of pre-fetching and preparing content in an information processing system is provided. The method includes the steps of generating at least one content pre-fetching policy and at least one content preparation policy, wherein each of the policies are at least in part a function of context information associated with a user. The content is pre-fetched based on information contained within the at least one content pre-fetching policy. Once the content has been pre-fetched, it is prepared based on information contained within the at least one content preparation policy. The context information associated with the user includes at least one of the user's usage patterns, current location, future plans and preferences.","The present invention increases responsiveness of access to pervasive applications by (1) predicting the future information access needs (including the device of access) of users by using context information, such as (but not limited to) the users' usage patterns, current location, and future plans, as well as their preferences, and (2) by using this prediction to pre-distribute the right content in the right form at the right time to the right locations, and to manage it appropriately.","It is to be appreciated that the term \u201cdata\u201d as used herein is not limited to any particular format. For instance, \u201cdata\u201d may include text, images, video, audio, etc. Also, the term \u201cprocessor\u201d as used herein is intended to include any processing device, such as, for example, one that includes a CPU (central processing unit). The term \u201cmemory\u201d as used herein is intended to include a machine readable medium associated with a processor or CPU, such as, for example, RAM, ROM, a fixed memory device (e.g., hard drive), a removable memory device (e.g., diskette), etc. In addition, the term \u201cinput\/output devices\u201d or \u201cI\/O devices\u201d as used herein is intended to include, for example, one or more input devices, such as a keyboard for inputting data to the processing unit, and\/or one or more output devices, such as a CRT display and\/or printer, for providing results associated with the processing unit. It is also to be understood that various elements associated with a processor may be shared by other processors. Accordingly, software components including instructions or code for performing the methodologies of the invention, as described herein, may be stored in one or more of the associated memory devices (e.g., ROM, fixed or removable memory) and, when ready to be utilized, loaded in part or in whole (e.g., into RAM) and executed by a CPU.","It is also to be appreciated that the following terms, as used herein, are intended to have the following definitions. The term \u201ccontent\u201d refers to static and dynamic data, applications, multimedia, code, or anything that can be delivered electronically. The act of \u201cbinding\u201d refers to interconnecting application components such as service components (e.g., Web services or Enterprise JavaBeans) and presentation components (e.g., servlets or Java Server Pages) together to form an entire workable application. A \u201cclient device\u201d is a computational device, which is used by an end user, such as but not limited to a cellular phone, a personal digital assistant (PDA), a personal computer (PC), a Kiosk, a television or a vehicle. A \u201ccontent group\u201d is a unit of pre-fetching or fetching from the server. The content group may contain multiple content items or items that have not been accessed. A \u201ccontent item\u201d is a particular piece of content accessed by a user.","\u201cContent preparation\u201d includes, for example, transcoding and binding. A \u201ccontent server\u201d is a computational device for storing, managing, and distributing content, such as but not limited to a file server, an application server, a database server, or a web server. The content server includes the software residing thereon. The term \u201ccontext\u201d refers to the physical and virtual environment in which a computation task occurs. \u201cContext attributes\u201d include aspects of a context. An \u201cedge server\u201d is defined as a computational device and its software which are placed near the client devices in the network. The purpose of an edge server is to increase performance and availability. More specifically, an edge server is an intermediary node intended to increase performance, scalability, and availability by caching, load sharing, and pre-fetching. An edge server typically has a large amount of storage within which to cache content.","\u201cFuture context\u201d refers to anticipated context based upon user input rather than derived from past historical context. \u201cHistorical context\u201d refers to a record of past context, both physical and virtual. \u201cPersistent context\u201d refers to a pattern observed in the historical context. The term \u201cpre-fetching\u201d refers to the act of fetching (pulling) as well as of pushing content ahead of demand. A \u201creplica store\u201d is a functional unit that maintains synchronized copies of content, and serves that content to clients. \u201cReplicas\u201d are read\/write copies of content. \u201cReplication management\u201d refers to the acts of creation, synchronization, and garbage collection. \u201cTranscoding\u201d is the act of transforming data from one format to another. Often, the transformation transforms the data into a format which is usable by a particular device. \u201cTransient context\u201d refers to current or recent context. A \u201cuser agent\u201d is software through which a user interacts with the system. This software commonly resides on the client device. The user agent may change as the user moves location or changes devices.","\u201cPre-fetching\u201d includes techniques that move content close to a user's device before the content is accessed. \u201cPreparation\u201d includes techniques that process the content (e.g., transcoding or binding) before the content is accessed. Both pre-fetching and preparation of content can be broken down into three steps: (1) prediction based on the general notion of user context, including all forms of past and present behavior, and future plans, as well as environment, to predict the future behavior of a user, (2) the action itself (i.e., pre-fetching and\/or preparation), and (3) replication management (i.e., management of the life cycle of multiple copies of content, including creation, consistency management, and deletion). \u201cContext-based prediction\u201d includes techniques which are described above in step (1). \u201cReplication management\u201d includes techniques which are described above in step (3).","The techniques for content preparation (e.g., transcoding and binding) differ significantly from those for pre-fetching. For example, in order to pre-transcode content, the device type used to access particular content must be predicted. Second, in order to pre-bind the components of applications, the relationships among application components must be tracked. Due to these differences, conventional pre-fetching cannot be easily applied or extended to support content preparation.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 1","FIG. 2"],"b":["100","100","110","120","130","130","140","150","100","200","205","210","215","220","225","230","100"]},"For example, the processor  may represent a microprocessor, central processing unit (CPU), digital signal processor (DSP), or application-specific integrated circuit (ASIC), as well as portions or combinations of these and other processing devices. The memory  is typically an electronic memory, but may comprise or include other types of storage devices, such as disk-based optical or magnetic memory. The control device  may be associated with the processor . The control device  may be further configured to transmit control signals.","The techniques of the present invention described herein may be implemented in whole or in part using software stored and executed using the respective memory and processor elements of the processing device . For example, the techniques may be implemented at least in part using one or more software programs stored in memory  and executed by processor . The particular manner in which such software programs may be stored and executed in device elements such as memory  and processor  is well understood in the art and therefore not described in detail herein.","It should be noted that the processing device  may include other elements not shown, or other types and arrangements of elements capable of providing the function of the present invention described herein.","Computing Environment",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 2","FIG. 2"],"b":["200","205","210","215","220","225","230","205","235","210","215","220","225","230","205","200","235","200"]},"Architecture Overview","An architectural overview of a system for content pre-fetching and preparation in accordance with the present invention is shown in . A primary purpose of this system is to pre-fetch and prepare content based on policy information. The policy information is derived from several sources of knowledge relating to user behaviors.","To pre-fetch and prepare the content based on policy information, a preferred embodiment uses two sets of functional units. The first set of functional units is used for pre-fetching and preparing content using the policy table , and includes content selection and synchronization , content preparation , replica store  and user agent . The second set is used to generate pre-fetching and preparation policies to populate the policy table , and includes access monitor , access record table , context collector , context history , context correlator , context miner , access pattern , persistent context , user preferences , device profiles , policy generator , policies , and content groups . The policies table , which is described in more detail below with reference to , provides an interface between the first and second sets of functional units.","Pre-Fetching and Preparing Content","Content is stored on and managed by content server  running on content host . Content server  receives content requests either from user agent , possibly through replica store , or from content selection and synchronization unit , which is described below with reference to . Content server  then processes the request, generates or retrieves the content satisfying the request and sends it back to the requester.","In a preferred embodiment, requests for content are sent to one or more content servers  by the content selection and synchronization unit . As its name implies, the content selection and synchronization unit  performs two functions: content selection\u2014which is described with reference to , and content synchronization\u2014which is described with reference to . Generally, the content selection function selects content for clients and makes the appropriate requests to content servers . The content synchronization function maintains the consistency of content between the content servers  and the replica stores . Each of these functions is controlled by one or more policies which have been obtained from policies table .","Policies table  comprises three major types of policies, i.e., content group definitions, pre-fetching policies and preparation policies. Content group definitions specify groups of content that are of interest to a particular user. In a preferred embodiment, content group definitions are entered in the system by an administrator or user. It is contemplated that content group definitions could be generated automatically by, for example, data mining techniques. Pre-fetching policies are utilized to inform the content selection and synchronization unit  that a set of content groups is to be pre-fetched and maintained at a set of replica stores . Pre-fetching policies trigger requests for content to be forwarded from the content servers  to the content selection and preparation unit . The content received by the content selection and preparation unit  is then forwarded to the content preparation unit . The preparation policies provide preparation instructions to the content preparation unit . Typical preparation instructions include transcoding directives assisting the preparation of content in a desired format. The preparation instructions may also instruct the content preparation unit  to bind services that will be needed to serve requests.","When the content selection and synchronization unit  receives content from content servers  as a result of a pre-fetching policy, the received content is forwarded to the content preparation unit , together with preparation policies. After the content is prepared in content preparation unit , the prepared content is transferred to replica stores . The role of a replica store  is to hold prepared content in anticipation of client requests. If a client requests a piece of content that has already been pre-fetched and is currently held in the replica store , the request is served from the cache of the replica store . If the desired content has not been pre-fetched, the replica store  forwards the request to the correct content server , on behalf of the user. A user agent , such as a Web browser, is typically employed to facilitate the interaction between a replica store and a user.","Policy Generation","The generation of policies commences with the access monitor . All of a user's requests for content are intercepted by the access monitor  before being forwarded to replica store . Generally, the role of the access monitor  is to track information regarding client requests that take place in the replica store . Access monitor  is described in further detail below with reference to . Access monitor  stores the information that it obtains in access record table . The access record table  is described in further detail with reference to . The context collector , described in further detail below with reference to , tracks contextual information such as user location and user calendar entries. One system for maintaining the context of users and their devices is described in co-pending U.S. patent application Ser. No. 09\/479,821, filed Jan. 7, 2000, entitled \u201cMethod and Apparatus for Providing an Awareness-Service Architecture\u201d (the \u201c'821 application\u201d), which is hereby incorporated by reference herein. Another system is described in co-pending U.S. Provisional Patent Application Ser. No. 60\/306,314, filed Jul. 18, 2001, entitled \u201cMethod and Apparatus for Providing Extensible Scalable Transcoding of Multimedia Content\u201d (the \u201c'314 application\u201d), which is hereby incorporated by reference herein. The context information from context collector  is stored in a context history table  which is described in further detail below with reference to . The correlator  performs a correlation to generate user access patterns. The correlator  utilizes the access information stored in the access record table  and information on user context history stored in the context history table . The access patterns generated by the correlator are then stored in access pattern table . The context history is also used by the context miner  to identify patterns in the data collected by the context collector  and stored in the context history table . For example, the context miner  might find that a given user is always in his or her office on weekdays, between 9:00 a.m. and 10:00 a.m. Any patterns that are identified by the context miner  are stored in a persistent context table .","User preferences are maintained in user preferences table . User preferences are typically provided directly by the users and contain information regarding the users' behavior, needs for specific content in a specific form, and when the users are in a specific context.","Device profiles are maintained in device profiles table . Device profiles table  includes information on the individual capabilities of the various client devices that may be utilized. A more detailed description of the device profiles table  is given below with reference to .","The device profiles , user preferences , persistent context , content groups  and access pattern  tables contain all of the information that is necessary to generate all of the policies that are stored within policies table . The act of generating the policies is performed by policy generator  unit and the resulting policies are stored in policies table .","It is contemplated that there may be one or more of each of the units illustrated in . Notwithstanding having duplicate units, their functionality remains the same. Furthermore, it is to be appreciated that there are many ways to distribute the units in a wide area network. For example, a content preparation  unit could either reside within content selection and synchronization unit  or with replica store . Additionally, replica store  could either run on edge server  or on any client device , , , , or , with a user agent .","It is also contemplated that policies may be manually supplied by administrators or users.","Content Selection","One function of the content selection and synchronization unit  is that of content selection. The process of content selection is illustrated in . This process occurs for each user of the system and begins in step  with a determination of the user's current context. The process continues in step  with a selection of active policies from the policies that are stored within policies table . Determining which policies within policies table  are currently active requires a number of checks. First, a check is made to determine whether the current time is within a time range associated with the policy in question. Second, a check is made to determine whether the current context (obtained from the context collector ) is applicable to the policy in question. Third, a check is made to determine which content items (and therefore content groups) that the user is currently viewing. These checks are performed only if they are appropriate for the particular policy in question (e.g., if the policy has an associated time range and\/or context).","The active policies identified in step  are processed in steps  through . Step  selects the next active policy. In step , a determination is made as to where the content group associated with the policy should be placed in the network. In step , the replica descriptor of the content is stored in the SyncDB table . SyncDB table , illustrated in , is a table which is internal to the content selection and synchronization unit  and not visible to any other functional unit. In step , the applicable content is fetched from the appropriate content server  and, in step , the content is pushed into the content preparation unit  associated with the applicable network location. Upon completion of step , the process returns to step  to determine whether any more active policies exist. Once there are no further active policies, the process is ended in step .","The particular order of the steps illustrated in  may vary if necessary. For example, it is contemplated that step  may need to occur after step  if, for example, the complete replica descriptor recorded in step  requires information which is only available from the replica store  after the content has been pushed in step  to the applicable network location. In this case, the proper order would be steps , , , and finally .","It should be noted that the process described above with reference to  is one based upon polling. That is, the system periodically checks for the user's current context and active policies. Alternatively, the system could be written in an event-driven fashion. For example, as the user's context changes, the context selection and synchronization unit  could be informed of the event and the context change could trigger a check for active policies. Similarly, when a policy is scheduled to become active (or inactive), an event could cause the system to push content (or remove it) as appropriate. Furthermore, when a content item is created, published, or updated, the content server  could inform the content selection and synchronization unit . Such an event could then map the content item to the appropriate content group and update the content group information. Such a design offers the standard advantages, such as performance and scalability, of event-driven systems as compared with their polling counterparts.","Content Synchronization","Content synchronization in the content selection and synchronization unit  is the process that maintains consistency between content replicas in replica store  and a master copy on the content server .  illustrates a process by which content synchronization is performed in accordance with a preferred embodiment of the present invention. The content synchronization process is triggered by updates of content on the content server . In step , SyncDB  (see ) is analyzed to determine a set of rows that needs to be processed. This set consists of all the rows corresponding to the content groups that have been updated. All of the rows determined in step  are iterated through the process in steps  through  in accordance with the following description. When no more unprocessed content groups exist, the synchronization process ends as indicated in step .","Once the total amount of content groups are determined in step , in step  the process determines whether additional unprocessed content groups exist. If additional unprocessed content groups do exist, in step  the next row in SyncDB  to be processed is located. In step , a determination is made as to whether the content group identified by the content group identification column  should still be kept in the remote replica store identified by the replica descriptor column . This determination is made by checking whether the expiration time column  contains a value greater than the current time. If the expiration time  indicates that the content group is no longer needed, the copy of the content group in the replica store is invalidated in step  and the corresponding row in SyncDB  is purged. Otherwise, the synchronization process proceeds to step . In step , the set of all content items currently belonging to the content group is determined. The difference between this current set and the set in the replica store  is then calculated by examining the replica descriptor column . This process identifies content items that have been added, modified, or deleted. In step , the content items in the calculated difference are fetched from the content server, if necessary, and forwarded to the content preparation unit .","In the current embodiment of the present invention, content synchronization is triggered by content updates on the content server . In an alternative embodiment of the invention, content synchronization may be triggered by demand requests at a replica store . Further, in step , the set of rows in SyncDB  that need to be processed consists of the rows that simultaneously satisfy the following two conditions. First, the content group identification column  identifies a content group to which the demanded items belong. Second, the replica descriptor column  identifies the replica store to which the demand requests were directed.","In another embodiment of the present invention, content synchronization is triggered by lapses of fixed time intervals. Further, in step , all of the rows in SyncDB  need to be processed. Alternatively, it is contemplated that content synchronization may also be triggered by a combination of two or more of the above events.","Access Monitor","Referring now to , there is illustrated a flow diagram of the functions performed by the access monitor  in accordance with the present invention. As illustrated in , the access monitor , in step , must first intercept a request. Standard interception techniques are known to those having ordinary skill in the art and are used in the file systems community and in the web community. After intercepting a request, the access monitor , in step , prepares an entry for the access record table  based upon information contained in the request. For both file and web accesses, identifying the information about the request is straightforward. However, identifying the information about the requester requires an authenticated user. In the absence of an authenticated user, the most one can expect to identify is the physical device from which the request was made. Further details regarding the access record table  are provided below with reference to . In step , the access monitor  redirects the request to the replica store . Finally, in step , the access monitor  stores the access log record in access record table .","In an alternative embodiment, the access monitor  could monitor the network associated with the replica store , thereby listening to requests intended for the replica store  and recording the necessary information. Such a process improves the latency of requests.","Access Record Table",{"@attributes":{"id":"p-0072","num":"0071"},"figref":["FIG. 7","FIG. 7"],"b":["325","325","700","705","710","700","705","710"]},"It is contemplated that the information stored in the request descriptor column  could be combined with the information stored in the requester descriptor column . Additionally, it is contemplated that the access monitor  could lookup the user's current context and include this information in one or more columns in the access record table . This would ease the burden on the correlator .","Context Collector Architecture",{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 8","b":"330"},"In an exemplary embodiment, the present invention uses a scaleable secure context service as a context collector . It is to be appreciated that other types of context collectors may be utilized. For example, in the '314 application context is collected from context drivers and reported in response to queries. The present invention uses historical context which is recorded in a context history table  as illustrated . If a context service does not generate historical context information, then either an external function can be added to receive transient context and record it in a context history table  or the collector could be modified to generate the context history table  directly. Additionally, if a context service records historical context in some other format, software may be added to rewrite the context as necessary.","As shown in , a context collector  receives requests via a secure context service application programming interface (SCS API) . These requests are serviced by a mediator  that aggregates data from various context drivers , , , and . Communication with the various context drivers , , , and  occurs via a context driver interface . The context service also contains a number of internal utilities  which are described in detail in the '314 application, with the exception of context recorder . Context recorder  performs the function of recording information into the context history table . The context drivers , , , and  can make use of the internal utilities as needed.","The location context driver  includes three sources of location data: (1) a cellular source such as, for example, a cellular telephone system, (2) a wireless local area network (LAN) source such as, for example, an 802.11 network, and (3) a second wireless personal area network (PAN) source such as, for example, a Bluetooth network. It is contemplated that an additional source of location data could be acquired from a device enabled with a network and a global positioning system (GPS) unit. When a request for location context arrives, the location context driver  queries one or more context sources for the required location information. It is contemplated that the location context source could, alternatively, send or push location context information to the location context driver . As part of the location context, the location context driver also returns the identity of the device that was used to sense the location. The device identification information could be recorded in the source field  of the context history table , as illustrated in . For example, if the location context is sensed using a cellular infrastructure, the identity of the cellular telephone that was sensed would be returned to the location context driver  within the location context. If location context is sensed using an 802.11 infrastructure, the media access control (MAC) address of the card sensed could be returned. For an 802.11 infrastructure, with additional software support, information regarding the particular device that the card is plugged into could also be returned.","With continued reference to , the calendar context driver  and instant messaging context driver  are illustrated. These context drivers receive context information from various sources. For example, the calendar context driver  obtains calendar context information (such as when a particular subscriber is scheduled to attend a meeting) directly from a Lotus Notes calendar context source. Alternatively, it is contemplated that other calendar programs may be utilized such as Microsoft Exchange or any other calendar system, to supply the necessary information to the calendar context driver .","The instant messaging context driver  maintains information regarding a subscriber's instant messaging status. For example, the instant messaging context driver  is configured to obtain instant messaging status information from America On-Line (AOL), Sametime or any other instant messaging type of program. Each of the context sources sends context information via a context push interface . It is also contemplated that programming associated with the context drivers could be written to permit the context drivers to query their respective context sources as needed.","The mediator  is configured to use the context recorder  to record context information in the context history table  just before returning the query. The SCS API  has been augmented to allow context information to be recorded in the context history table  only, but not returned to the requester. It is contemplated that the context history table  may be populated in other ways, for example, the context collector could be modified to record all context information available to it independent of any requests.","In accordance with an embodiment of the present invention, the context service is queried to obtain the desired context information. Context information can be static or dynamic information, and requests for context information may be one time requests, event driven, or continuous. In each of these cases the context information may be recorded. It is contemplated that one or more parts of the context collector  may be modified to use the context recorder . Recording the context information in the context collector  may affect the granularity of the information available in the context history table . Further, useful data can be lost if it is filtered out before being recorded in the history table. The present invention allows users to adjust the granularity of the context history through the augmented SCS API .","Another function of the mediator  is to direct simple requests to the appropriate context driver such as drivers , , , and . For example, a request for a subscriber's location would be directed to the location context driver  and a request for a subscriber's instant messaging context would be directed to the instant messaging context driver . Additionally, another function of the mediator  is to aggregate different types of context to more efficiently process more complex requests. For example, a request regarding whether a subscriber is actually attending a meeting that appears on his or her calendar could be serviced by the mediator . However, this request would require the use of more than one of the context drivers shown in the present architecture. For this example, the mediator  would need to query both the calendar context driver  and the location context driver  and then compare the location of the current meeting with the subscriber's present location. If the two locations are the \u201csame\u201d, then the request might be answered in the affirmative; if not, then the request would be answered in the negative. However, defining the term \u201csame\u201d with regard to such a query is a complex issue with many solutions. For example, cellular tower A may cover an office which has GPS coordinates (X, Y, Z). If these two location values are reported by two separate sources, the system must recognize that these two different representations are not inconsistent. One possible way to resolve the issue is to require the requester to specify how close the locations must be to be considered the same. Additionally, the system may include information regarding the dimensions of rooms available to it so that when a request arrives that requires the system to determine if something is inside or outside a room (or any place) it is capable of doing so.","It is contemplated that the individual context sources could aggregate context data to produce a single view of one type of context data. For example, an 802.11 context aggregator could collect 802.11 data from many access points. The 802.11 context aggregator could then analyze that data to determine a single location estimate. Requests made to the 802.11 context aggregator would then result in a single location estimate, possibly with associated quality of information estimates. Similarly, in a push scenario, the single location information could be sent to the context driver or to a downstream aggregator.","It is further contemplated that another individual context source, from the context service's perspective, could itself aggregate context data from multiple different sources to define a new type of context. Additionally, context aggregators could be arranged in a hierarchical fashion, arbitrarily allowing more complex context data to be created. Thus, an architecture could be designed to address factors such as scalability, quality of information, administrative control, and so forth.","Context History Table",{"@attributes":{"id":"p-0085","num":"0084"},"figref":["FIG. 9","FIG. 9"],"b":["335","335","900","905","910","915","920","925","930","935","900","905","910","900","900"]},"The context type column  contains information regarding the type of context. Context information recorded from the context recorder  could contain location, calendar, or instant messaging information.","The context attributes column  contains actual context information such as the GPS coordinates or the fact that someone is on a business trip.","The duration column  contains information which indicates the length of time that the context event took or is scheduled to take.","The context event column  contains information which describes the event with additional specificity. For example, when combined with information from the calendar context driver , the event might be labeled as, for example, a meeting, a conference call, vacation, or travel. The location context driver  may provide information which will cause the event information in column  to be, for example, room , Atlanta, or Poughkeepsie. GPS context events could be labeled as GPS, followed by the coordinates.","The supplier column  contains information which indicates the owner of the source of the context data. The source column  contains information which indicates the origin of the data. For example, the supplier of context received via a cellular telephone could be Verizon Wireless or Sprint, and the source could be the cellular tower sensing the telephone and the telephone sensed. For some context types the source information  will include information regarding the device that generated the context source information. In another example, where the context type is identified as virtual context in column , and context event column  contains information which indicates that the context event is e-mail, the context source could be a laptop computer, Blackberry, a two way pager, or any other device where the context subject accesses e-mail. In a facility which is wired for tracking individuals, the source of meeting information could be the room where the collection of people were sensed.","The subject(s) column  contains information indicating the person, persons, object, or objects that the context event is reporting about.","It is contemplated that additional columns may be included to contain additional information that can assist in interpreting the context. For example, when the context type  is location information, the additional information may indicate whether the origin is a global positioning system (GPS), a cellular network, an 802.11 network, a local area network (LAN) or a Bluetooth network.","Correlator","The correlator  takes information from an access record table  and a context history table  as input and generates an access pattern  for each combination of context attribute values. Examples of context attribute values include access location and access device information. Because user behavior may demonstrate different characteristics under different circumstances, the present invention models access patterns separately for different context attributes.",{"@attributes":{"id":"p-0094","num":"0093"},"figref":["FIG. 10","FIG. 11","FIG. 12"],"b":["340","1000","1005","325","335","1010","1005","1015","380","1020"]},"In a preferred embodiment of the present invention, access patterns are modeled at the level of content groups. It is contemplated that access patterns may also be modeled at the level of individual content items.","Access Pattern",{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIG. 11","b":["350","1110","1100","1105","1120","1100","1105","1120","1115","1100"]},"Generate an Access Pattern",{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 12","b":"350"},"The process starts at step . In step , the init node  is created if it is not yet present. In steps  to , the input access records are iterated through and the access pattern  is updated accordingly. In step , a determination is made as to whether any additional unprocessed access records exist. If no additional unprocessed access records exist, the process is ended, as indicated by step . If additional unprocessed access records do exist, in step  the next access record to be processed is located. In step , a content node  for the content group identified in the access record is created, if necessary. In step , the set of access records that precede the current access record and whose timestamp is within the relationship window of the current record's timestamp is computed. In step , a determination is made on whether the set computed in step  is empty. If the set is empty, the process proceeds to step . Otherwise, the process proceeds to step . In step , if there is no arc yet from the init node  to the node for the current content group, an arc with a weight value equal to one is drawn. Otherwise, the weight value associated with the arc is increased by one. In step , for each content group identified by an access record in the set, an arc is drawn from that content group to the current content with a weight of one if no arc exists; otherwise, the weight associated with the arc is increased by one. According to a preferred embodiment of the present invention, the time of access and the relationship window are represented in physical time. It is also contemplated that the time of access and the relationship window may also be represented in logical time.","Context Miner","Referring now to , flow diagrams are illustrated to indicate the manner in which persistent context is generated from the context history table . The context miner's  job is to mine the historical context recorded in the context history table  to extract the persistent context. Data mining is a well known technique for extracting interesting information from a large volume of data. Data mining is used by the context miner  to reduce the context information stored in the context history table  to persistent context. Persistent context is stored in the persistent context table .","Returning to the flowchart illustrated in , the context miner  starts reading, in step , the persistent context table  to initialize an active context table (an internal table) in its memory with the persistent context table . The active context table now contains all of the persistent context events that have been previously identified and the statistics or characteristics associated with these events. Next, in step , the context miner  reads the input parameters which are the control variables that determine, for example, the sensitivity of the mining algorithms, the frequency that is required, and a tracking table (an internal table).","Generally, the next part of the algorithm reads the context history table  and updates the statistics for all previously identified events as well as identifying potential candidates for new events. This portion of the algorithm is performed in a loop. The tracking table, which resulted from the input parameters which were read as input in step , contains those context events which might be of interest.","More specifically, in step , the next entry of the context history table  is read and checked to determine whether it represents a new event pattern. If this context history entry represents a new event pattern, it is added to a tracking list in step . A new context event indicator in this tracking list entry is marked so that it will remain in the tracking list long enough to collect enough observations to determine whether it represents persistent context or an event which should be tracked. As indicated in step , if the current entry from the context history table  represents a previously existing event pattern, the parameters associated with this event are updated in step . In step , a determination is made as to whether all events were processed. If all events were not processed, the process begins again at step . This loop is repeated until there are no more events in the context history table , at which point the process continues with step  illustrated in .","The part of the algorithm shown in  identifies the persistent context and the items which need to be tracked. More specifically, the algorithm considers all of the items in the active context table and the tracking table as a single set of events. The process starts with the active context table and applies steps  through  to each event until all events in both tables are processed. It is worth noting that the tracking table, which is internal to the context miner , contains the same entries as the active context table with the addition of the new context event indicators. Both of these tables have the same information as the persistent context table . The events in the tracking table have either not occurred with high enough frequency to be considered persistent context or are new.","With continuing reference to , which begins with step , in step  the next event is read to determine whether the event is above the persistence threshold. If the event is above the persistence threshold, in step  it is moved to the active context table, if it is not already present. Note that, for events which are already in the active context table, this step does not accomplish anything. However, if the event being examined is in the tracking list, it is removed from the tracking list and added to the active context table. In step  a determination is made as to whether there are any additional events to process. If there are additional events, the process continues at step  and reads the next event from the context history .","Returning to step , if the event being examined is not above the persistence threshold, a determination is made, in step , as to whether the event is above the tracking threshold. If the event is above the tracking threshold, the event is moved to the tracking table in step , if the event is not already present in the tracking table. Note that for events in the active context table, step  removes the event from the active context table. For events which are already in the tracking table, step  has no effect. If the event being examined is not above the tracking threshold, in step , a determination is made as to whether the event is considered new (i.e., has the new event time out expired). If the event is no longer considered new, it is moved into the archive table in step . Step  removes the item from either the active context table or the tracking table, as appropriate. Returning to step , if the event is still considered new, the algorithm proceeds, in step , to check whether there is another event to process. If there is an additional event, then the algorithm returns again to step . If there are no additional events to process, in step  the active context table is stored as the persistent context table , replacing the existing table, and the tracking table is stored. The process associated with the context miner  ends at step .","It is contemplated that, in this embodiment, items that are moved from the active context table to the tracking table may be processed twice. The processing time associated with the steps described with reference to  may be improved by skipping over the items which were newly added to the tracking table. It is further contemplated that any algorithm that accurately generates persistent context and items to be tracked can be employed for use with context miner . Additionally, the input parameters supplied to the context miner will determine which events, from a set of historical context, are identified as persistent context, context to be tracked, or context to be ignored. Any data mining algorithm that separates data or observed facts into three groups, those data of interest, those of potential interest, and those of no interest, can be employed.","Persistent Context Table",{"@attributes":{"id":"p-0107","num":"0106"},"figref":"FIG. 14","b":["355","355","1400","1405","1410","1415","1400","1405","1410","905","910","915","905","910","915","1400","1405","1415"]},"Device Profiles Table",{"@attributes":{"id":"p-0108","num":"0107"},"figref":"FIG. 15","b":["365","1500","1505","1510","1510"]},"Content Groups Table",{"@attributes":{"id":"p-0109","num":"0108"},"figref":"FIG. 16","b":["380","1600","1605"]},"Policy Generator","Policies are generated by the policy generator .  is a flow chart illustrating the operation of the policy generator  in accordance with an embodiment of the present invention. Step  starts the policy generation process. Initially, in step , the process derives content group definitions. These definitions specify all of the content items which form content groups. The definitions are read from the content groups table  and map into content group definitions. The definitions are then stored as policies, in step , in the policies table . The policy generator  then reads the persistent context for a user, in step , from the persistent context table . A description of the format of persistent context records is given above with reference to .","Groups of context attributes are then extracted in step  from the persistent context records. For example, a persistent context record might indicate that a given user is always in his or her office between 9:00 a.m. and 10:00 a.m., which could be used to pre-fetch content to their office device(s) or the replica store(s) serving the device(s). In this case, the location and time attribute are grouped together with respective values equal to \u201coffice\u201d and \u201c9:00 to 10:00 a.m.\u201d. Another example of a persistent context record might indicate that a given user always uses his or her BlackBerry device when he or she visits a particular location. In this case, the context attributes predict the device that the user will probably use, based on his or her persistent context. It is contemplated that other context attributes, could be used by the context miner  to make such device or pre-fetching predictions.","The next step, , is to get user preferences from the user preferences table . There are three types of user preferences: user-defined contextual preferences, user-defined pre-fetching policies and user-defined preparation policies. From user-defined contextual preferences, additional groups of context attributes are extracted in step . The correlation between context attributes and access patterns is generated by the correlator  and stored in the access pattern table . The format of access pattern records is described above with reference to . Essentially, the access pattern records are probability graphs associated with groups of context attributes. For each group of context attributes obtained in steps  and , the corresponding probability graphs are obtained in step  from the access pattern table . These graphs indicate which content is likely to be accessed by the user, based on context attributes.","The next step taken by the policy generator  is to simplify these graphs in step  by removing vertices of the graph based on any applicable removal policy such as least recently used (LRU). Although there are several ways to simplify these graphs, in this preferred embodiment, the removal policy drops all of the vertices with a weight value which is less than a predetermined threshold weight value. Thus, the policy generator  triggers only the pre-fetching and preparation of popular content groups. The predetermined threshold weight value can be specified off-line, either by the user or by an administrator. Alternatively, the threshold weight value can be computed online, based on different network conditions. The threshold weight value serves to control the number of policies that the system generates. It is contemplated that other removal policy criteria may be utilized.","After simplifying the probability graphs in step , the policy generator  reads device profiles in step  from the device profiles  table. The policy generator  then merges the device profiles with user-defined content preparation policies and context attributes which predict the device used, to generate content preparation policies in step . With the simplified graphs obtained in step , the policy generator , in step , also generates content pre-fetching policies and adds user-defined pre-fetching policies to a list of content pre-fetching policies. In step , the policy generator then stores all of the policies generated in step  and  in the policies table . The policy generator then determines whether there are additional groups of context attributes to process, in step . If the answer is yes, the policy generator generates the associated policies following steps  to . Once all groups of context attributes associated with a user have been processed, the system checks, in step , to determine whether there are additional users to process. If the answer is yes, the policy generator repeats steps  to : the extraction of access patterns, user preferences and associated device profiles to generate policies for that user. If the answer to step  is no, as indicated by step , the policy generator ends its execution until the next scheduled time for the generation of new policies.","Policies Table",{"@attributes":{"id":"p-0115","num":"0114"},"figref":["FIG. 18","FIG. 18"],"b":["375","375","1800","1805","1810","1815","1820","1800","1805","1810","1815","1820"]},"It is contemplated that the policies table may contain additional fields or may only contain a subset of the fields described above. It is further contemplated that the time range  and\/or the device types  could be considered types of context and could be included in the other applicable contexts  rather than considered separately as described above with reference to this preferred embodiment.","SyncDB Table",{"@attributes":{"id":"p-0117","num":"0116"},"figref":["FIG. 19","FIG. 19"],"b":["1900","1900","1905","1910","1915","1905","1910","310","1915","310","1910","1900"]},"Although illustrative embodiments of the present invention have been described herein with reference to the accompanying drawings, it is to be understood that the invention is not limited to those precise embodiments, and that various other changes and modifications may be made by one skilled in the art without departing from the scope or spirit of the invention. All such changes and modifications are intended to be included within the scope of the invention as defined by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a better understanding of the invention, reference is made to the following description of exemplary embodiments thereof, and to the accompanying drawings, wherein:",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIGS. 13A and 13B"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 19"}]},"DETDESC":[{},{}]}
