---
title: Apparatus, method, and system having a pin to activate the self-test and repair instructions
abstract: In general, various methods, apparatuses, and systems in which a processor that contains self test and repair instructions to be executed on a memory is coupled to a first external pin. Assertion of a signal on the first external pin activates execution of the self-test and repair instructions on the memory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07149924&OS=07149924&RS=07149924
owner: Virage Logic Corporation
number: 07149924
owner_city: Fremont
owner_country: US
publication_date: 20020905
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DISCUSSION"],"p":["This application is a continuation in part of U.S. patent application Ser. No. 09\/962,761, filed on Sep. 24, 2001, and also claims the filing date of provisional U.S. patent application Ser. No. 60\/301,901, filed on Jun. 29, 2001.","The present invention relates generally to integrated circuits consisting of stand-alone memory devices or embedded memories, and more specifically to testing and repairing defects detected in such a memory.","Random defects occurring during the manufacturing of an integrated circuit with embedded memory blocks can render certain non-redundant elements of an integrated circuit memory device, such as a memory column, defective. For example, particle contamination during the manufacturing process may cause broken or shorted out columns and bit defects.","Redundant elements in an integrated circuit memory device, such as redundant columns, are used to compensate for these random defects. Initial testing of an integrated circuit memory occurs after the manufacturing process. During initial testing of an integrated circuit memory device, defective elements are replaced by non-defective elements referred to as redundant elements. Thus, redundant columns may be used in a scheme to replace defective non-redundant columns, discovered during initial testing of the integrated circuit memory device. The use of redundant elements is important in increasing the overall yield of an integrated circuit memory device.",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1","b":["102","102","104","106"]},"Also, four equipment insertions may be required when testing SoC memory . First, the external memory tester  tests the memory to find defective components on the SoC  die. The external memory tester  imports the failure results in order to perform redundancy analysis and allocation. The external memory tester  sends the repair signature, or in other words the information on how to allocate the repair elements for any defects, to the laser repair equipment . Second, the laser repair equipment  blows the fuses on the SoC  wafer that enable the redundant rows and memory columns to be substituted for the defective memory cells. Third, the memory tester  re-tests memory on the SoC  to ensure that the repairs were made properly. Last, the logic tester  analyzes the remaining non-memory components of the SoC .","The external test solution  is expensive, time-consuming, may not achieve a dramatic increase in yield, and in the future it may not be a feasible solution for SoC testing. The memory tester  assumes that the memories  used in a SoC  are readily accessible directly from the I\/O pins of the chip. A designer must carefully route each embedded memory  to enable pin access. As more embedded memories  are physically located onto a chip containing the entire system, more design time is required to route the embedded memories  and establish the pin connections. Meanwhile, the die size may increase from the extra routing, and chip packages may enlarge accordingly. The physical size and spacing requirements of SoC  dies may not accommodate the extra space need to test the memories. Also, memory tester  may not be able to test the memories at the speed of the chip.","Typically, a device external to the processor applies, via parallel or serial interface, an instruction sequence commonly referred to as vectors. The vectors drive a test and repair processor located on the system on a chip. The device external to the processor makes multiple attempts and handshaking operations with the processor to perform all of the test and repair operations on the memory. Usually, extra logic may be included in the system design to coordinate and drive the test and repair processor to perform these operations. Further, the design of the extra logic may become more complicated if the logic has the intelligence to determine whether it wants all of the test and repair operations performed or just a portion of those operations performed. Thus, extra time and expense may be added into a system on a chip design to accommodate the extra logic.","In general, various methods, apparatuses, and systems in which a processor that contains self test and repair instructions to be executed on a memory is coupled to a first external pin. Assertion of a signal on the first external pin activates execution of the self-test and repair instructions on the memory.","While the invention is subject to various modifications and alternative forms, specific embodiments thereof have been shown by way of example in the drawings and will herein be described in detail. The invention should be understood to not be limited to the particular forms disclosed, but on the contrary, the intention is to cover all modifications, equivalents, and alternatives falling within the spirit and scope of the invention.","In the following description, numerous specific details are set forth, such as examples of specific data signals, named components, connections, types of repair algorithms, etc., in order to provide a thorough understanding of the present invention. It will be apparent, however, to one skilled in the art that the present invention may be practiced without these specific details. In other instances, well known components or methods have not been described in detail but rather in a block diagram in order to avoid unnecessarily obscuring the present invention. Thus, the specific details set forth are merely exemplary. The specific details may be varied from and still be contemplated to be within the spirit and scope of the present invention.","In general, various methods, apparatuses, and systems are described in which a processor that contains self test and repair instructions to be executed on a memory is coupled to a first external pin. Assertion of a signal on the first external pin activates execution of the self-test and repair instructions on the memory. In an embodiment, the processor also contains logic to bypass execution of one or more of self test and repair operations contained in the processor based upon information conveyed by the second signal. In an embodiment, the processor also contains logic to augmenting a hard repair signature generated at the factory with a soft repair signature that is determined in the field.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2","b":["202","204","206","208","210","212","214","216","218","204","206","204","208","210"]},"The processor  enables a complete embedded memory self-test and repair function to be included on-chip . The processor  increases the yield of useable memories  by repairing defective memory components at a very high rate. In an embodiment, the processor  contains multiple engines to determine how much redundancy is needed and how to partition the redundant components throughout each unique memory array. The processor  understands the redundancy scheme, the failure history of the process being used, and how the unit has failed.","The processor  on the chip  that automatically tests the memory  allocates redundancy resources and coordinates or performs any necessary repairs. In an embodiment, the processor  tests the memory instances  at speed; that is, at the speed they will run in the application. After testing and repair of the memory instances , the processor  turns the memory operation over to the normal address, data and control busses on the SoC.","The repair data signature created by the processor  is sent to an external tester (not shown) via the one or more external interfaces . In an embodiment, the processor  communicates the repair data signature during wafer probe. In an embodiment, the laser repair equipment (not shown) programs the fuse box  with the necessary repair information. The fuse box  retains the permanent memory repair signature unique to that individual SoC . The signature can be executed either at wafer sort or at system power-on. In an embodiment, the processor  determines and stores the repair data signature in order to eliminate the need for a fuse box . In an embodiment, the processor  after system power-on transfers the corresponding repair data signature directly into the scan flip-flops contained within each unique memory instance  in the SoC .","In an embodiment, the processor  may perform all the appropriate testing and repair coordination of the memory instances  in order to increase yield, eliminate expensive external memory testers, and allow test and repair functions to occur in the field rather than at the factory. In an embodiment, the only factory testing required is to test the logic portion of the SoC  and, if applicable, coordinate the fuse box  programming. Thus, testing and repair of the memory instances  may occur in the field. In an embodiment, the processor  reduces the previous techniques of having four external test stages (memory test, laser repair, memory re-test, logic test) to one external test stage (logic test). In an embodiment, if a hard repair is used then there may be three external test stages, i.e. memory test, laser repair, and memory retest.","The system supports both factory and field repair methods. Factory repair takes place during wafer probe in the factory, using the laser programmed fuse box . Field repair uses a test and repair function residing in the processor  to make repairs after product deployment.","The factory repair has the advantage of performing test and repair at the wafer level. The wafer  can be subjected to a variety of stringent conditions during testing that helps insure high memory instance  and SoC  reliability during extended voltage, temperature and frequency conditions.","The field repair operation tests and repairs memory instances  each time the end product powers up or is reset. The processor  initiates and operates the test program, determines defective memory locations (if any), allocates redundancy resources, and produces a repair signature that resides in a location on the memory . This volatile repair signature is applied to the redundancy control logic and remains there as long as power is applied.","The field repair feature allows a new test every time the processor  is powered up or reset under control of the application's software but it is performed at ambient temperature and typically under non-stressful conditions.","The SoC  supports both repair functions: factory repair for manufacturing defects, and field repair for any subsequent problems that may materialize over the life of the end product.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 3","b":["302","304","306","308"]},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 4","b":["402","404","402","406","404"]},"Referring to , the processor can use the BISD engine  to find the defects and the BIRA engine  to repair the memory. The BIST engine  runs a test program to detect faults in the memory array. The BIRA engine  allocates the available redundant components to repair the memory and sends the repair information to the Reconfiguration Data engine . The Reconfiguration Data engine  translates redundancy allocation into a memory-specific repair signature that can be both sent to the external memory tester to be programmed into a fuse box or sent directly to scan chain registers in the memories themselves.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 5","b":["502","504","506","508","510","502","504","506","508","510","502","502","512","504","506","508","510","504","506","508","510","514","516","512","504","506","508","510","516","516","504","506","508","510","512"]},"In an embodiment, an extension of the processor is the Intelligent Wrapper (IW)  for example, at the first memory. The intelligent wrapper  associated with each memory instance , , ,  is used in conjunction with the processor  to perform test and repair of the memory as well as allow normal memory functioning in the system. The intelligent wrapper  contains functions such as address counters, registers, data comparators and multiplexors. The intelligent wrapper  is located close to the memory core to allow at-speed testing of these functions. Thus, the processor  in conjunction with its intelligent wrapper  increase useable memory yields due to the processor's ,  ability to detect nearly all defects, including performance defects that external memory testers commonly miss because they cannot run tests at chip speed. Further, the processor's ,  on-chip repair function allows in the factory repairs and in the field repairs. The external interface , such as the standard JTAG 1149.1 port, enables the one or more processors to communicate with the chip's other IP cores.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 6","b":["602","604","606","608","610","612","614","616","602","608","614","602","608","604","606","604","606","612"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 7","b":["700","700","700","704","706","708","710","700","704","706","704","708","710","700","700","712","714","716","718","700","712","704","714","706","716","704","706","720","704","704","716","720","704","722","706","718","704","706"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 8","b":["802","804"]},"In an embodiment, the plurality of registers may be as follows. Row register-Row_ , and row register Row_  record the faulty row addresses. Thus, each row register ,  may identify and store the address of a faulty row. In an embodiment, the amount of row registers equals the number of redundant rows. Status bit register-En  and status bit register-En  record the status of redundant row registers. These status bits indicate that the corresponding addresses recorded must be selected for repair if the memory is declared repairable after BIST. Thus, the status bit registers ,  indicate whether the corresponding redundant row is available or unavailable as a substitute row. In an embodiment, the BIST and BIRA operations are performed simultaneously.","Similarly, status bit register-CL (not shown) and status bit register-CH (not shown) record the status of redundant column registers. The status bit registers indicate whether the corresponding redundant column is available or unavailable as a substitute column. Column register Col_L  and column register Col_H  record the faulty column addresses located in the lower bank and upper bank, respectively. In an embodiment, the total amount of status bit registers equals the number of redundant rows plus the number of redundant columns.","Cross-reference row register-Row_L  and cross-reference row register Row_H  record the row addresses connected with the faults recorded in column registers Col_L  and Col_H . Each cross reference register allows an assigned redundant column, thus unavailable, to be released and reset to available status, if an assigned redundant row will also be substituting for the defective memory cell that the assigned redundant column was substituted for. In an embodiment, the BIRA engine  may couple to additional registers, such as sub input output registers which together with the column registers ,  specify the faulty column addresses of sub input output circuits associated with each memory array.","The BIRA engine  processes one or more built-in-redundancy-analysis algorithms to determine whether a memory is repairable. The BIRA engine  takes into consideration the process failure history, address mapping, and examines information about available redundancy, and the current fault data that is specific to each unique memory. The BIRA engine  combines this information and sends the information to the Reconfiguration Data engine to translate the redundancy allocation into a memory-specific repair signature.","In an embodiment, the organization and sequence of how the BIRA engine  assigns the redundant components determines whether a memory array will be repairable or not repairable, thereby, increasing or decreasing the yield of useable memories on the chip. The BIRA engine  may use many discrete algorithms, however, a one or more algorithms will be described and illustrated to demonstrate aspects of the invention.","A first Built-In-Redundancy-Analysis algorithm is based on the following main logic steps.","First, if at least two faulty cells are encountered in a word either in the lower bank or the upper bank of the memory array, then the row requires repair with a redundant row. If an available redundant row does not exist, then the memory array is considered unrepairable.","Second, if a single faulty cell is encountered in a word either in the lower bank or the upper bank of the memory array then a redundant column is used for repair, if available. If no spare column is available but a spare row is available, then a redundant row is used for repair. Otherwise, the memory array is considered unrepairable.","Third, the BIRA engine  works in parallel with the BIST logic providing the fault data. Thus, the BIRA engine  may possess three states of decision regarding the assignment of redundant components to substitute for defects in the memory detected by BIST logic. In an embodiment, the three states of decision are not set, tentatively set, and locked in. The starting state of decision for redundant rows and redundant columns is not set. Not set means that the component is available to be assigned to substitute for a defective component.","As noted in the first logic step, if at least two faulty cells are encountered in a word, then a redundant row is assigned to substitute for the defective component. In this case, the BIRA engine  locks in the state of decision for this redundant row to substitute for the defective row. Thus, this particular redundant row is now unavailable to be assigned to replace another defective component. Note, the redundant row globally replaces the entire row in both the lower bank and the upper bank irrespective of whether the two fault cells exist in the upper bank or in the lower bank or in both","As noted in the second logic step, if a single faulty cell is encountered in a word, then a redundant column is the first choice to substitute for the defective component. The BIRA engine  tentatively sets the state of decision for this redundant column to substitute for the defective component. Thus, this particular redundant column is currently unavailable to be assigned to replace another defective component; however, the status of this redundant column may be released back to available upon certain conditions. If a new fault is encountered requiring repair with a redundant row, (i.e. at least two faulty cells are encountered in a word) and a faulty row is connected with an assigned redundant column, i.e. the corresponding cross-referencing registers contain the same address as the faulty row, then the corresponding column register is reset together with the status bit register and cross referencing register. The released redundant column has become available for further repair purposes and the newly assigned redundant row satisfies the first logic step to have a locked in state of decision. If an available redundant row does not exist, then the memory array is considered unrepairable.","Fourth, the BIRA algorithm may use a marching algorithm, which sequentially examines the addresses of the memory array. The BIRA algorithm may make several passes to attempt to repair a memory. If at least one of the BIRA algorithms passes eliminates all of the defective components in the memory through redundant component substitution, then the state of decision for each redundant memory component is locked in. The memory is repaired. The BIRA engine  sends the repair information to the Reconfiguration Data generation engine.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 9","b":["902","904"]},"On the third pass , the BIRA algorithm alters the second logic step to choose to replace a single defective memory cell with a redundant row rather than a redundant column. The BIRA engine sets the state of decision for that assigned redundant row as tentatively set. On the fourth pass , the BIRA algorithm does both alter the second logic step to choose to replace a single defective memory cell with a redundant row rather than a redundant column and examines the memory array in the backward direction.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 10","b":["1002","1004","1006","1008","1010","1012","1014","1016"]},"The memory array  is split into two halves a lower bank  and an upper bank . Many word lines exist in each bank. For example, the top horizontal grouping of memory blocks is a word line, in the lower bank . Similarly, the top horizontal grouping of memory blocks in the upper bank  is an example of a word line. The row address spans from row address   through row address  . And the column address spans from address  through address . Note this is just an exemplary memory array  and how a first BIRA algorithm might be employed.","The BIST program sends data to the BIRA engine indicating the location of faulty memory cells, such as a first faulty memory cell  located in the first word line  contained within the lower bank . The first faulty memory cell  is located at row address   and also at column address . Located next to the first faulty cell , going horizontally, is a second faulty memory cell  constituting a second fault or defect with in the first word line . In an embodiment, when the BIRA algorithm encounters two faulty cells in a single word line, a first logical steps dictates that a redundant row will be substituted for the defective component.","A faulty memory cell could be an actual faulty defective bit cell within the memory, a defective multiplexor or sense amp going to that bit cell, a faulty input output circuit routing to that cell, some interconnection between those components going to that cell or some other condition to render the memory location inoperable. In an embodiment, a redundant component, such as either the redundant row or the redundant column, has the necessary components within the redundant component to substitute for any of those defects.","The exemplary use of the BIRA algorithm assumes that the memory array  has two redundant columns, a first redundant column and a second redundant column as shown in . The exemplary use of the BIRA algorithm also assumes that the memory has two redundant rows, a first redundant row and a second redundant row. Additionally assumed is that the memory array  has been split into an upper bank  and a lower bank . The specific amounts of components and the types of components are just examples to illustrate an embodiment of the invention. One or more of any of these components could exist. In an embodiment, the BIRA algorithm examines these variables as shown in .",{"@attributes":{"id":"p-0068","num":"0067"},"figref":["FIG. 11","FIG. 15"],"b":["0","1022","1","1012","0","1022","1","1016","1","1016","1032","2","1020","1","1012","1018"]},"Referring to , the BIRA algorithm continues marching in a forward direction on the first pass through the addresses of the memory array . The BIRA algorithm finishes its analysis of row address   and starts its analysis of row address- . The BIRA algorithm detects a fourth faulty cell in the upper bank  in the second word line. The BIRA algorithm determines that this is a single faulty cell contained in a word line and therefore follows the second logical step to replace the single faulty cell with a redundant column. The BIRA engine changes the contents in column register-Col_H  from a logical 0 to a logical 1 to indicate the column address of the defective component. The cross-reference register Row_H  changes it's content to reflect a 1 which is the row address connecting or cross referencing the defective row with the defective column.","Referring to ,  illustrates the first BIRA algorithm continuing its forward march on the first pass through the memory array . The BIRA algorithm detects a fifth faulty memory cell in the third word line contained in the lower bank . According to the second logical step, since the BIRA algorithm detects only a single error, the BIRA algorithm assigns a redundant column to substitute for the defective faulty component. Thus, the BIRA engine changes the contents in column register Col_L  to record a logical 1 in memory block corresponding with fifth column address to indicate that the second redundant column has been assigned to substitute for the fifth memory column in the fifth address slot. The BIRA engine changes the contents in cross reference register Row_L  to record row address  , in order to reflect the row address corresponding to the defect which caused the redundant row to be assigned to that defective column. The second redundant column replaces the defective column in fifth address slot, which is reflected by the contents in the column register Col_L  and cross reference register Row_L .","Referring to ,  illustrates the BIRA algorithm continuing a forward march through the memory array  on the first pass. The BIRA algorithm examines the fourth word line in both the lower bank  and in the upper bank . The BIRA algorithm detects a sixth memory fault in the lower bank  occurring in the fifth column address. The BIRA algorithm references the BIRA registers and detects that the second redundant column has been assigned to substitute for this defective memory cell already through contents of column register Col_L . The BIRA algorithm then continues its forward march through the memory array  and discovers a single defect in the seventh faulty memory cell located within the upper bank  occurring in column address . The BIRA algorithm references the BIRA registers and detects that the first redundant column has substituted for this defective component already. The BIRA algorithm references the column register Col_H  and detects that the contents reflect column address .","Referring to ,  illustrates the first BIRA algorithms continued march through the memory array  on the first pass. The BIRA algorithm examines defects in the fifth word line contained in the memory array . The BIRA algorithm detects a single fault occurring in the fifth word line contained in the lower bank . The eighth faulty memory cell is located in column address . The BIRA algorithm does not have any redundant columns left to replace this single fault with a redundant column, therefore according to the second logical step, the BIRA algorithm uses an available redundant row to replace this defective component.","Thus, the BIRA engine assigns the second redundant row to globally replace the bottom word line in the lower bank  and the bottom word line in the upper bank . The BIRA registers reflect this change. The BIRA engine changes the contents in row register Row  to reflect row address number  and stores the faulty row address in its contents. The BIRA engine changes the contents in status bit register En  to a logical 1 to indicate that the second redundant row is not longer available to substitute for the defective component. However, since a single fault was detected, then the state of decision for this redundant row is only tentatively set. The BIRA algorithm then proceeds to examine the memory addresses in the upper bank  and detects multiple faults, a ninth faulty memory cell existing in column address  and a tenth faulty memory cell existing in column address . The BIRA algorithm references the BIRA registers and detects that row register Row  assigns the second redundant row to replace row address  . Therefore, the BIRA algorithm determines that these errors are already covered by a redundant component.","The BIRA algorithm then goes to the fourth logical step, once the highest memory address is achieved and checks to see if all the faults in this memory array  were substituted by redundant components. In this example, the redundant components substitute for the defective components in order to replace every defect that occurred in this memory array . The BIRA algorithm then determines that this memory array  is repaired on the first pass. Therefore, the BIRA algorithm need not continue the BIRA algorithm with a second testing pattern such as a second pass, third pass, or fourth pass through this memory array .","Once the BIRA algorithm determines that one of passes or testing techniques, in this case the first pass, was successful, then the BIRA algorithm locks in the state of decision contained in the BIRA registers for each redundant component and sends the fault information onto the reconfiguration data engine. Thus, this example illustrates an embodiment of how the BIRA algorithm performs dynamic allocation and swapping of redundant components while still testing or detecting faults in the memory. The BIRA algorithm may optimize the final organization and allocation of assigning redundant components in order to replace defective components associated with the memory.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 16","FIG. 25","FIG. 16"],"b":["1632","1618","6","1618","5","1618","1620","1","1620","2","1620"]},"Referring to , the BIRA algorithm starts with the first pass. The BIRA algorithm encounters a first memory defect in the lower bank  in the sixth column address. In a single fault failure the BIRA engine assigns a redundant column to replace the defective component and sets the state of decision as tentatively set. Column register Col_L  changes the contents of its register to a logical 1 in the sixth column address position to reflect that the first redundant column has been assigned to replace the column in the sixth column address. Cross reference register Row_L  changes the content in its register to read a logical 0 to indicate the first defective memory cell is also found in row address  .","Referring to , the BIRA algorithm continues a forward march through the memory addresses by proceeding to the second word line. The second word line in the lower bank  contains no defects. The BIRA algorithm does detect a defect in the second word line in the upper bank  contained in column address . Upon detecting a single fault failure the BIRA engine assigns a second redundant column to replace the defective component. Column register Col_H  changes the contents of its register to a logical 1 in the first column address position to reflect that the second redundant column has been assigned to replace column . Cross reference register Row_L  changes the contents in its register to reflect that the memory defect covered by the second redundant column also occurs in row address  .","Referring to , the BIRA algorithm continues its march through the first pass of the memory addresses of the memory array . The BIRA algorithm detects a fault in the third word line contained in the lower bank  occurring in column address . Upon detecting a single fault failure, the BIRA algorithm would assign a redundant column to substitute for the defective component. However, according to the second logical step, if no redundant columns are available, then the BIRA algorithm assigns a redundant row. Row register Row  reflects the assignment of the first redundant row by recording the row address   in its contents. Status bit register En  changes the contents in its register to a logical 1 to reflect that the first redundant row is no longer available to be assigned to substitute for a defective memory component.","Referring to , the BIRA algorithm continues its forward march using the first pass through the memory array  starting at the fourth word line in the lower bank . The BIRA algorithm detects a single fault failure in the fourth word line in the lower bank  occurring in column address . The BIRA algorithm having no redundant columns available assigns a redundant row to substitute for this defect. The BIRA registers reflect the assignment of the second redundant row by row register Row  changing the contents of its register to record row address  . Status bit register En  changes the contents in its register to a logical 1 to indicate that the second redundant row in no longer available to substitute for a defective component. The BIRA algorithm then proceeds to detect a defective memory cell in the upper bank  contained in row address  . The BIRA algorithm references the BIRA registers to detect that the row register Row  contains a row address   already, thereby, substituting the second redundant row covering that defective component.","Referring to , the BIRA algorithm continues the forward march using the first pass though the memory array . The BIRA algorithm detects a fault in the fifth word line in the upper bank  in the column address . Upon detecting a single fault, the BIRA algorithm attempts to use a second logical step to assign a redundant column, however in this case all of the redundant columns have already been assigned. The BIRA algorithm references the BIRA registers and both column registers indicate that the redundant columns have been assigned and their corresponding status bit registers for those columns (not shown) indicate that those redundant columns have been assigned. The BIRA algorithm then tries to proceed to the second part of the second logical step and assign a redundant row to fix this error. However, the BIRA algorithm references the BIRA registers and discovers that the status bit registers for both redundant rows indicate that neither of the redundant rows is available to be assigned to substitute for a defective component. Therefore the BIRA algorithm determines that it has no available redundant components to assign to substitute for the defect found in the fifth word line in the upper bank . The BIRA algorithm determines that the redundant component cannot be substituted and cover all the defects in the memory array . The BIRA algorithm then proceeds by resetting all the registers and starting a second pass to try to repair this memory array .",{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 22","b":["1632","1632","1632","1632","1632"]},"As noted, the BIRA algorithm commences the second pass by starting at the highest memory address and proceeding to the lowest memory address. The BIRA algorithm commences its sequential march through the memory addresses in the upper bank  in the fifth word line. The BIRA algorithm detects a faulty memory cell in column address . The BIRA algorithm detects a single fault in the fifth word line and therefore, in accordance with the second logical step, assigns a redundant column to substitute for that defective component. The BIRA registers reflect the assignment of the first redundant column. Column register Col_H  changes the its content to correspond to column address  to indicate that a first redundant column has been assigned to substitute for the defective second column. Cross-reference register Row_H  changes the contents in its register to store the address of the corresponding row of this defective memory cell. Thus, cross-reference register Row_H  changes its contents to reflect column address .",{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 22","b":["1632","1620","2","3","1628","1602","3","1628"]},"Referring to , the BIRA algorithm continues with its backwards march through the memory address in row address  . In the lower bank , the BIRA algorithm detects a fault memory cell in the lower bank  in column address . Upon detecting a single fault, the BIRA algorithm assigns a redundant column to replace the defective component. The BIRA registers reflect this assignment of the second redundant column. Column registers Col_L  changes the content in the register corresponding to the fifth column address location to a logical 1. This indicates that the second redundant column has been assigned to substitute for a fifth column contained within the lower bank . Additionally the cross-reference register Row_L  changes its contents to reflect the row address that cross references to this faulty memory cell that has been replaced by a redundant column. The cross-reference register changes its content to read row address  .","The BIRA algorithm continues with its backwards march through the addresses. In row address  , the BIRA algorithm detects no errors in the upper bank . However, the BIRA engine detects an error in row address   and column address  of the lower bank . The BIRA engine references the BIRA registers and detects that this defect occurs in the fifth column. Thus, the second redundant row already substitutes for this defective component. The BIRA algorithm then may proceed with its backwards march of the next row of addresses.","Referring to , the BIRA algorithm detects a defect in row address   in the first column contained within the upper bank . The BIRA algorithm according to the second logical step first tries to assign a redundant column to repair this single defect in a word, however, the BIRA engine determines that both the first redundant column and second redundant column are unavailable to be assigned as substitutes. Therefore, according to the second logical step, the BIRA engine assigns the first redundant row to substitute for the defective component containing this faulty memory cell. The BIRA registers reflect this assignment of this first redundant row. Accordingly, row register Row  changes the content of its register to a logical 1 to represent the row address of the component containing the defect that it is substituting. Status bit register En  changes the content of its registers to a logical 1 to indicate that the first redundant row is no longer available to be assigned as a substitute component.","The BIRA algorithm continues its backward march through the memory array  and detects no faults in the second word contained in the lower bank . Also, the BIRA algorithm detects no faults in the top word contained in the upper bank .","Referring to , the BIRA algorithm detects a fault in column address  and row address   of the lower bank . According to the second logical step, the BIRA algorithm checks and sees that there are no redundant columns available and thus assigns a redundant row to replace a this single defect that it discovered in the first word line in the lower bank . The BIRA registers reflect this assignment of the second redundant row. The row register Row  changes the content in its register to reflect the address of the defective component, in this case the defective row, row address  . The status bit register En  changes the content in its register to reflect logical 1 to indicate that the second redundant row is no longer available to be assigned as a substitute component.","The BIRA algorithm reaches the lowest address in the memory array  and proceeds to the fourth logical step. Upon proceeding to the fourth logical step, the BIRA algorithm determines that this memory is repaired because all the defects have been substituted for by redundant components. The BIRA algorithm then changes the state of decision for the redundant components to locked in and sends the repair information onto the reconfiguration data engine.",{"@attributes":{"id":"p-0091","num":"0090"},"figref":["FIG. 26","FIG. 30","FIG. 26"],"b":["2618","2620","0","2622","2","2626","3","2628","2620","1","2","2626","4","2630","2632","2632"]},"The third pass sequentially marches through the memory array  addresses from lowest to highest, however the second logical step is altered to replace the very first single memory fault encountered with a redundant row rather than with a redundant column. Thus,  illustrates the starting condition of the BIRA algorithm and the BIRA registers after being reset at the completion of the unsuccessful second pass. The BIRA registers including the column register the cross-reference register the row register and the status bit registers are reset to a condition of a logical 0.","Referring to , the BIRA engine commences the BIRA algorithm by analyzing row address   and detects a faulty memory cell in the first word line in the lower bank  at column address . Upon detecting the single fault, the BIRA algorithm then replaces the single fault with a redundant row vice a redundant column. The BIRA engine assigns the first redundant row to substitute for the defective component. The BIRA registers reflect this assignment. The column register Row  changes its content to the row address that corresponds to the faulty memory cell and thus contains row address  . The status bit register En  changes its contents to reflect a logical 1 to indicate that the first redundant row is no longer available to be substituted for a defective component.","Referring to , the BIRA algorithm continues marching though the memory array  and detects no errors in the first word line in the upper bank  at row address  . The BIRA algorithm then checks row address   of the lower bank  and detects no errors. The BIRA algorithm then detects a single fault in the second word line in the upper bank  contained within row address  . The BIRA algorithm, in accordance with the second logical, replaces the single fault failure in that word with a redundant column.","The BIRA registers reflect this assignment of a redundant column to replace the faulty memory cell. Column register Col_H  changes its content in the bit position corresponding to column address  to reflect that the first redundant column has been assigned to substitute for column  in the upper bank . The cross reference register Row_H  also changes the contents to a logical 1 to indicate that the faulty memory cell now substituted by the first redundant column cross references to row address  . Thus, cross-reference register Row_H  stores a logical 1.","Referring to , the BIRA algorithm continues to sequentially march through the addresses of the memory array  and detects the next defect in the third word line contained within the lower bank . Column address  contains the faulty memory cell. Upon detecting a single fault failure in the word line, the BIRA algorithm, in accordance with the second logical step, replaces a single fault failure with a second redundant column. The BIRA registers reflect this assignment of the second redundant column. The column register Col_L  changes the content of its register corresponding to column address  to a logical 1. The cross-reference register Row_L  changes its contents to reflect the row address that cross references to the second redundant column. Thus the cross-reference register in this case changes its contents to row address .","The BIRA algorithm then continues to march on and finds a defect in the third word line contained in the upper bank  at column address . The BIRA algorithm references the BIRA registers and detects that the first redundant column substituting for the second column in the upper bank  already covers this faulty memory cell.","The BIRA algorithm continues to march forward through the memory addresses in the memory array . The BIRA algorithm detects a faulty memory cell in row address   of the lower bank . The faulty memory cell is also located in column address . The BIRA algorithm references the BIRA registers and detects that the faulty memory cell in column address  in the lower bank  is already covered by substitution of the second redundant column. Column register Col_L  contains column address . Thus, the BIRA algorithm continues to march through the memory addresses and detects no further errors in row address  .","Referring to , the BIRA algorithm continues the forward march through the memory addresses starting at column address  and detects no errors in the fifth word line contained within the lower bank . The BIRA algorithm then detects a fault in the fifth word line contained in the upper bank . The faulty memory cell exists in the row address   and also in column address . The BIRA registers and finds that this faulty cell is not covered by any redundant component at this point.","Being a single fault failure within a single word, the BIRA engine, in accordance with the second logical step, checks to see if any redundant rows are available to substitute for the defective component containing this faulty memory cell. The status bits for the redundant columns (not shown) indicate that the first redundant column and the second redundant column are unavailable to be assigned as substitute components.","The BIRA algorithm then checks to see if any redundant rows are available to be assigned as a substitute component to replace the component containing this faulty memory cell. The BIRA engine detects that after referencing the BIRA registers that the second redundant row is available to be assigned as a substitute component. The BIRA engine then assigns the second redundant row to replace this faulty memory cell found in the row address  . The BIRA engine reflects this assignment. Row register Row  changes its content within its register to indicate row address  . The status bit register En  changes its contents to a logical 1 to indicate that the second redundant row is no longer available to be used as a substitute component.","The BIRA algorithm eventually reaches the highest address in the memory array  and determines that no further faults exist. The BIRA algorithm proceeds to the fourth logical step. The BIRA algorithm has covered all of the existing defects in the memory array  with redundant components and determines that the memory is repaired. The BIRA engine then changes the state of decision for the redundant components stored in the BIRA registers to a locked in state of decision and sends the repair information and fault information to the reconfiguration data engine.","If the BIRA engine had not successfully repaired this memory array  then the BIRA engine would have reset the BIRA registers and preceded with the fourth pass thorough this memory array  in an attempt to repair this memory array . This allocation of redundant components to repair faults found in the memory can occur at power up or start up. In an embodiment, each time this redundancy allocation can differ and change in the field as different defects occur to the memory array .",{"@attributes":{"id":"p-0104","num":"0103"},"figref":"FIG. 31","b":["3102","3104","3106","3108","3110","3102","3102","3104","3106","3108","3102"]},"Several pins external to the processor  may couple to the processor . For example, four pins may couple to the processor . The first external pin  coupled to the processor  may be a control pin. Assertion of a signal on the first external pin  activates the self-test and repair instructions to be executed on the memory. The second external pin  coupled to the processor  may be a bypass pin. Assertion of a signal on the second external pin  determines which operations to bypass in the self test and repair instruction sequence. Each of the engines described above also contains logic to bypass specific test or repair operations upon receiving a signal on the bypass pin. The third external pin  coupled to the processor  may be a feedback pin. The feedback pin  conveys to any component external to the processor  when the test and repair operations are complete and that the memory is ready to be returned to a normal mode of operation. The fourth pin  coupled to the processor  may be a results pin. The results pin  conveys to any component external to the processor  whether the processor  was able to successfully repair a memory or unsuccessful in repairing the memory. Note, any of the external pins \u2013 described above may actually consist of two or more physically different pins that functionally cooperate together to accomplish the function associated with that pin.","As noted previously, the processor  and the one or more memories tested by the processor may be located in the same integrated circuit. In an addition, the one or more memories tested by the processor  may be embedded memories. In an embodiment, the test and repair allocation algorithms use a very high frequency timing mechanism and do not use the status bits. Thus, in an embodiment, the exemplary repair algorithm in  illustrates an example of the mechanics of how the testing and repair operations may occur.","Further, the external pin may activate the self-test and repair of the memory after the memory is placed into field operation. Thus, after the processor  has been place into field operations, then the assertion of a single signal triggers the self-test and repair operations contained with the processor  minus the operations bypassed indicated by the bypass pin.","In an embodiment, assertion of the first external pin  may be accomplished by tying the first external pin to a bus that powers up when the memory initially powers up or resets. The first external pin  may be directly connected to the power bus or indirectly through a voltage dropping component to the power bus. Thus, a complete test and repair of the memories may occur each time the memory initially powers up or resets. In an embodiment, assertion of the first external pin  may be accomplished by clocking a signal to that pin. Thus, positive control may exist as to when the test and repair operations on the memories occur.","Assertion of a signal includes making the voltage level sensed by an external pin go from a low state to a high state and\/or vice versa. Alternatively, assertion of a signal includes making the voltage level sensed by an external pin equal to or exceeding a preset threshold voltage level. Further, assertion of a signal on the second external pin  includes receiving a coded signal to identify which test and repair operations are to be bypassed.","The BIRA logic may augment a hard repair signature generated at the factory with a soft repair signature determined each time the memory is powered up in the field. The BIRA logic may use fuses blown at the factory to establish the hard repair signature.","After running another test of the memory, the test and repair logic may then detect a new faulty memory cell address not covered by the redundant components assigned by the hard repair signature. The BIRA logic may then assign an available redundant component to substitute for the newly detected faulty memory cell address. The hard repair signature is combined with the soft repair information determine the allocation of all the redundant components for that memory. An augmented repair signature  may be generated from the combined hard repair signature information and the soft repair information. The augmented soft repair signature  may be stored in registers , such as scan chain registers, to determine the allocation of the redundant components. In an embodiment, the augmented repair signature  may also be programmed into the fuse box .",{"@attributes":{"id":"p-0112","num":"0111"},"figref":"FIG. 32","b":["3204","3214"]},"In block , a signal asserted on the first external pin activates the self-test and repair instructions contained in the processor. The self-test and repair instructions execute on one or more memories associated with that processor. Note, during the execution of the test and repair instruction the memories are generally disabled for user access.","In block , the instructions load the fuse box repair information, i.e. the existing repair signature, into the memories being tested. Thus, in the memory, the assigned redundant components substitute for non-redundant components associated with known defects based upon the fuse box repair information.","In block , the instructions run the built in self tests and diagnosis operation to detect and identify faults in the memory.","In block , the instructions execute the BIRA logic to repair any newly detected faulted memory cells by allocating available redundant component to cover those new defects. The BIRA logic generates a software repair signature to indicate the allocation of these newly assigned redundant components.","In block , the instructions generate an augmented repair signature based upon hard repair from the fuse box information and soft repair signature information. The instructions do not generate an augmented repair signature if no new defective memory cells were detected.","In block , the instructions substitute redundant components for non-redundant components based upon the augmented repair signature in order to load the repair signature to the memories.","In block , the instructions again run the built in self tests and diagnosis operations on the memories having the redundant components substituting for the non-redundant components. The prior operation in block  should have completely repaired the memories leaving only memory cells without defects in operation. Thus, this set of self tests should not detect any defects that are not already covered by a redundant component.","In block , the instructions return the memories to a normal mode of operation if the final tests in block  indicated no defects exist.","In block , the instructions conclude the test and repair operations and allow the user to have access to the memories.","Note, when an operation in blocks \u2013 is bypassed, the user may substitute their own instructions and corresponding operation in place of the instructions and operation contained in the processor. Further, the results of user specific operation may be communicated to the block immediately proceeding the bypassed operation thru the bypass pin. For example, if a user desired to run their own built in self test operation, then the processor's built in self test operation would be bypassed. However, the results of the user's built in self test would be sent through the bypass pin to be used by the processor's test diagnostic operation.","In an embodiment, the instructions for the algorithms may be stored in a machine-readable medium. A machine-readable medium includes any mechanism that provides (i.e., stores and\/or transmits) information in a form readable by a machine (e.g., a computer). For example, a machine-readable medium includes read only memory (ROM); random access memory (RAM); magnetic disk storage media; optical storage media; flash memory devices; electrical, optical, acoustical or other form of propagated signals (e.g., carrier waves, infrared signals, digital signals, etc.).",{"@attributes":{"id":"p-0124","num":"0123"},"figref":"FIG. 33"},"In block , the designs for each memory component for the embedded memory are supplied to the memory compiler. A memory compiler may be a software program comprised of multiple algorithms and designs for the purpose of generating a circuit design and a layout in a space available on a target chip. The set of application-specific algorithms and interfaces of the memory compiler may be used by system IC integrators to rapidly create hundreds of silicon-proven memory cores. The memory compiler receives designs of memory component and utilizes those memory component designs in conjunction with memory circuit designs to optimize a circuit design and layout in the space available on a target chip. A memory having a test and repair logic section may be a basic memory building block utilized in the memory compiler.","In block , the memory compiler generates a circuit design and layout in the space available on a target chip. The memory compiler stores the data representing the embedded memory typically on a machine-readable medium. The memory compiler then provides design to be used to generate one or more lithographic masks to be used in the fabrication of that embedded memory.","In block , the machine to generate the lithographic masks receives the circuit design and layout from the memory compiler. The machine generates one or more lithographic masks to be used to transfer that circuit design onto the chip.","In block , a fabrication facility fabricates the chips with the embedded memories using the lithographic masks generated from the memory compiler's circuit design and layout. Fabrication facilities may use standard CMOS logic process employing 1.0 um, 0.50 um, 0.35 um, 0.25 um, 0.18 um, 0.13 um, 0.10 um, or less, technologies to fabricate the chips. The size of the CMOS logic process employed typically defines the smallest minimum lithographic dimension that can be fabricated on the chip using the lithographic masks, which in turn determines minimum component size. In an embodiment, light is shown through these lithographic masks onto the chip to transfer the circuit design and layout for the embedded memory onto the chip itself.","In an embodiment, the embedded memory containing one or more memories having a test and repair logic section can be embedded into the System on Chip. The embedded memories can be fabricated in a state-of-the-art, leading edge standard logic process. In an embodiment, the memory compiler is designed for embedded applications in the standard CMOS logic process.","In an embodiment, an exemplary memory compiler may also include the following. A graphic user interface, a common set of processing elements, and a library of files containing design elements such as circuits, control logic, and cell arrays that define the compiler. The library of files may also contain other files such as global parameter files, configuration files and other similar files. In an embodiment, object code in a set of executable software programs may form one or more of the compiler's function blocks.","As noted, in an embodiment, a designer chooses the specifics of the memory configuration to produce the set of files defining the requested memory instances. A memory instance may include front-end views and back-end files. The front-end views support documentation, simulation, debugging, and testing. The back-end files, such as a layout, physical LEF, etc. are for layout and fabrication.","In one embodiment, the software used to facilitate the compiler can be embodied onto a machine-readable medium. A machine-readable medium includes any mechanism that provides (e.g., stores and\/or transmits) information in a form readable by a machine (e.g., a computer). For example, a machine-readable medium includes read only memory (ROM); random access memory (RAM); magnetic disk storage media; optical storage media; flash memory devices; DVD's, electrical, optical, acoustical or other form of propagated signals (e.g., carrier waves, infrared signals, digital signals, EPROMs, EEPROMs, FLASH, magnetic or optical cards, or any type of media suitable for storing electronic instructions. Slower mediums could be cached to a faster, more practical, medium.","Some portions of the detailed descriptions above are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.","It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussions, it is appreciated that throughout the description, discussions utilizing terms such as \u201cprocessing\u201d or \u201ccomputing\u201d or \u201ccalculating\u201d or \u201cdetermining\u201d or the like, may refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers, or other such information storage, transmission or display devices.","While some specific embodiments of the invention have been shown the invention is not to be limited to these embodiments. For example, most functions performed by electronic hardware components may be duplicated by software emulation. Thus, a software program written to accomplish those same functions may emulate the functionality of the hardware components in the logic circuitry. The application specific processor may be a finite state machine. The BIRA algorithm may make one or more passes through the memory array and alter how redundant components are assigned. The invention is to be understood as not limited by the specific embodiments described herein, but only by scope of the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The drawings refer to the invention in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 11","FIG. 15"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 16","FIG. 25"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 26","FIG. 30"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 33"}]},"DETDESC":[{},{}]}
