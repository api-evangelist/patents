---
title: Abstract interface for unified communications with dynamic models
abstract: A device may include a first type of modeling environment, a second type of modeling environment, and an abstract interface. The first type of modeling environment may be associated with at least one of a first toolbox or a first function. The second type of modeling environment may include a model. The second type of modeling environment may be different than the first type of modeling environment and may be incompatible with the at least one of a first toolbox or a first function. The abstract interface may interface with the first type of modeling environment and the second type of modeling environment. The abstract interface may allow the at least one of a first toolbox or a first function to be used in the model in the second type of modeling environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08220006&OS=08220006&RS=08220006
owner: The MathWorks, Inc.
number: 08220006
owner_city: Natick
owner_country: US
publication_date: 20070820
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF AN ILLUSTRATIVE EMBODIMENT"],"p":["This application is a continuation of U.S. patent application Ser. No. 11\/270,221, (Now U.S. Pat. No. 8,127,311) entitled \u201cABSTRACT INTERFACE FOR UNIFIED COMMUNICATIONS WITH DYNAMIC MODELS,\u201d filed Nov. 9, 2005, the entire disclosure of which is incorporated herein by reference.","The present invention relates to modeling environments for dynamic systems. More particularly, the present invention relates to interfacing with models regardless of model type.","Many organizations are embracing the paradigm of Model Based Development in their production processes. \u201cModel Based Development\u201d refers to the practice of specifying, analyzing, and implementing systems using a common \u201cmodel\u201d containing a set of block diagrams and associated objects. System implementation typically involves automatically generating code for portions of the model, particularly portions corresponding to the system's control algorithm.","Graphical modeling environments are an example of software applications that may enable a user to model dynamic systems i.e., systems whose outputs change over time, using a graphical model, such as a block diagram. Some graphical modeling environments also enable simulation and analysis of models. Simulating a dynamic system in a graphical modeling environment is typically a two-step process. First, a user creates a graphical model, such as a block diagram, of the system to be simulated. A graphical model may be created using a graphical user interface, such as a graphical model editor. The graphical model depicts time-based relationships between the systems inputs, states, parameters and outputs. After creation of the graphical model, the behavior of the dynamic system over a specified time period is simulated using the information entered into the graphical model. In this step, the graphical model is used to compute and trace the temporal evolution of the dynamic systems' outputs (\u201cexecute the graphical model\u201d), and automatically produce either deployable software systems or descriptions of hardware systems that mimic the behavior of either the entire model or portions of the model (code generation).","Dynamic systems may also be modeled textually. In this methodology, dynamic systems are described in an application specific language or code. Using this textual description, the dynamic system may be simulated and analyzed. Simulating a dynamic system in a textual modeling environment is typically a two-step process. First, a user creates a textual model, such as an M-file or LTI model, of the system to be simulated. A textual model may be created using a textual user interface, such as a textual model editor. The textual model depicts time-based relationships between the systems inputs, states, parameters and outputs. After creation of the textual model, the behavior of the dynamic system over a specified time period is simulated using the information entered into the textual model. In this step, the textual model is used to compute and trace the temporal evolution of the dynamic systems' outputs (\u201cexecute the graphical model\u201d), and automatically produce either deployable software systems or descriptions of hardware systems that mimic the behavior of either the entire model or portions of the model (code generation).","There are many different techniques for modeling systems using different modeling environments. One problem with this is that a model created in one modeling environment may not be compatible with another modeling environment. As such, toolboxes possessing tools and functions of interest for use with a model may not be compatible with the modeling environment the model was created in. Thus what is need is a simple convenient way of interfacing a model regardless of model type.","According to one aspect, a device may include a first type of modeling environment, a second type of modeling environment, and an abstract interface. The first type of modeling environment may be associated with at least one of a first toolbox or a first function. The second type of modeling environment may include a model. The second type of modeling environment may be different than the first type of modeling environment and may be incompatible with the at least one of a first toolbox or a first function. The abstract interface may interface with the first type of modeling environment and the second type of modeling environment. The abstract interface may allow the at least one of a first toolbox or a first function to be used in the model in the second type of modeling environment.","According to another aspect, a method may be implemented by one or more computing devices. The method may include receiving, via an abstract interface that is configured to interface with a first type of modeling environment and a second type of modeling environment, a call from a first toolbox to a model in the second type of modeling environment. The call may use at least one function that may be compatible with the first type of modeling environment and may be incompatible with the second type of modeling environment. The method may also include allowing, via the abstract interface, the at least one function from the first toolbox to be implemented in the model in the second type of modeling environment; placing, via the abstract interface, the call to the model in the second type of modeling environment; and receiving data from the model in the second type of modeling environment in response to placing the call to the model and the at least one function being implemented in the model.","According to a further aspect, a computer-readable medium may store instructions executable by at least one processor to perform a method. The computer-readable medium may include one or more instructions for receiving an abstract interface from a remote device, the abstract interface being configured to interface with a first type of modeling environment and a second type of modeling environment; one or more instructions for receiving, via the abstract interface, a call from a first toolbox to a model in the second type of modeling environment, the call using at least one function that is compatible with the first type of modeling environment and incompatible with the second type of modeling environment; one or more instructions for allowing, via the abstract interface, the at least one function from the first toolbox to be implemented in the model in the second type of modeling environment; and one or more instructions for placing the call to the model.","According to still another aspect, a system may include means for receiving a call to a model in a first type of modeling environment. The call may use at least one function that is compatible with a second type of modeling environment and incompatible with the first type of modeling environment. The at least one function may cause one or more properties to be obtained from the model, cause the model to be simulated and a response to be returned, cause at least one Jacobian associated with the model to be obtained, or cause the model to be at least one of trimmed or linearized. The system may further include means for allowing the at least one function to be implemented in the model in the first type of modeling environment and means for placing the call to the model.","An illustrative embodiment of the present invention is directed to creating a universal object class representation of a model which can be interfaced by a number of modeling environments. The present invention will be described relative to illustrative embodiments. Those skilled in the art will appreciate that the present invention may be implemented in a number of different applications and embodiments and is not specifically limited in its application to the particular embodiments depicted herein.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["2","4","7"]},"Typically, the interaction of a human user with the computing device  occurs through an input\/output (I\/O) device , such as a graphical user interface (GUI). The I\/O device  may include a display device (such as a monitor) and an input device (such as a mouse and a keyboard and other suitable conventional I\/O peripherals.","For example, the memory  holds a modeling application  capable of creating and simulating digital versions of system models, such as block diagrams, state diagrams, signal diagrams, flow chart diagrams, sequence diagrams, UML diagrams, dataflow diagrams, circuit diagrams, ladder logic diagrams, kinematic element diagrams, or other models, which may be displayed to a user  via the display device . In the illustrative embodiment, the modeling application  comprises a MATLAB modeling environment, such as Simulink\u00ae or another suitable modeling environment. As used herein, the terms \u201cmodeling environment\u201d and \u201cphysical modeling environment\u201d refer to an application where a model, such as a model of a physical system, is created and translated into executable instructions. Examples of suitable modeling applications include, but are not limited to MATLAB, including Simulink, SimMechanics, and SimDriveline from the MathWorks, Inc.; LabVIEW, DasyLab and DiaDem from National Instruments Corporation, VEE from Agilent, SoftWIRE from Measurement Computing, VisSim from Visual Solutions, SystemVIEW from Elanix, WiT from Coreco, Vision Program Manager from PPT Vision, Khoros from Khoral Research, and numerous others. The memory  may comprise any suitable installation medium, e.g., a CD-ROM, floppy disks, or tape device; a computer system memory or random access memory such as DRAM, SRAM, EDO RAM, Rambus RAM, etc.; or a non-volatile memory such as a magnetic media, e.g., a hard drive, or optical storage. The memory may comprise other types of memory as well, or combinations thereof.","In an alternate embodiment, the computing device  is also interfaced with a network, such as the Internet. Those skilled in the art will recognize that the diagrams used by the diagramming application  may be stored either locally on the computing device  or at a remote location  interfaced with the computing device over a network. Similarly, the diagramming application  may be stored on a networked server or a remote peer.","The modeling application  of an illustrative embodiment of the invention includes a number of generic components. Although the discussion contained herein focuses on MATLAB from The MathWorks, Inc. of, Natick Mass., those skilled in the art will recognize that the invention is applicable to other software applications. The generic components of the illustrative diagramming program  include a model editor for specifying models of dynamic systems. The model editor allows users to perform such actions as construct, edit, display, annotate, save, and print out a model that represents a physical system. The illustrative diagramming application  also includes elements libraries that contain elements that may be combined to model systems. There may also be a graphical aspect that allows graphical modeling. An execution engine , also implemented in the application, is used to process a model to produce simulation results or to convert the model to executable code. The execution engine translates a model to executable entities. The executable entities are compiled and executed on a computational device, such as a computer, to implement the functionality specified by the model. Typically, the code generation preserves a model hierarchy in a call graph of the generated code. For instance, each subsystem of a model in a physical modeling environment can map to a user specified function and the generated code. Real-Time Workshop from the MathWorks, Inc. of Natick, Mass. is an example of a suitable execution engine for generating code.","In the illustrative embodiment, the modeling program  is implemented as a companion program to a technical computing program, such as MATLAB, also available from the MathWorks, Inc.","The model editor is the component that allows a user to create and modify a model representing a physical system. The model editor also allows a user to create and store data relating to model element . A textual interface with a set of commands allows interaction with the model editor. Using this textual interface, users may write special scripts that perform automatic editing operations on the model. A user generally interacts with a set of windows that act as canvases for the model. There is generally more than one window for a model because models may be partitioned into multiple hierarchical levels through the use of subsystems.","Once a model has been constructed using the editor , the execution engine simulates the model by solving equations defined by the model to trace the system outputs as a function of time. The solution of the model, which may be referred to as model execution, is carried out over a user-specified time span for a set of user-specified inputs.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2","b":"200"},{"@attributes":{"id":"p-0029","num":"0028"},"maths":[{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mover":[{"mi":"x","mo":"."},{"mo":["=","."]}],"mo":["\u2062","\u2062"],"mrow":{"mrow":[{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"mrow":{"mi":"d","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}},{"mtd":{"mrow":{"mi":"d","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}},{"mtd":{"mrow":{"mi":"d","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}}},{"mtd":{"mrow":{"mi":"d","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}}}]}},{"mrow":[{"mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"mn":"0"},{"mn":"1"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mrow":{"mo":"-","mfrac":{"mrow":[{"mi":"k","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}]}}},{"mrow":{"mo":"-","mfrac":{"mrow":[{"mi":"b","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}]}}},{"mfrac":{"mrow":[{"mi":"k","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}]}},{"mfrac":{"mrow":[{"mi":"b","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}]}}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"1"}]},{"mtd":[{"mfrac":{"mrow":[{"mi":"k","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}]}},{"mfrac":{"mrow":[{"mi":"b","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}]}},{"mrow":{"mo":"-","mfrac":{"mrow":[{"mrow":[{"mi":"k","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},{"mi":"k","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}],"mo":"+"},{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}]}}},{"mrow":{"mo":"-","mfrac":{"mrow":[{"mrow":[{"mi":"b","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},{"mi":"b","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}],"mo":"+"},{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}]}}}]}]}},"mo":"\u2062","mi":"x"},{"mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"mn":"0"}},{"mtd":{"mrow":{"mo":"-","mfrac":{"mn":"1","mi":"m1"}}}},{"mtd":{"mn":"0"}},{"mtd":{"mn":"0"}}]}},"mo":"\u2062","mi":"F"}],"mo":"+"}],"mo":"="}}}},{"@attributes":{"id":"MATH-US-00001-2","num":"00001.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"y","mo":"=","mrow":{"mrow":[{"mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"mn":"1"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"1"},{"mn":"0"}]}]}},"mo":"\u2062","mi":"x"},{"mrow":{"mo":["[","]"],"mn":"0"},"mo":"\u2062","mi":"F"}],"mo":"+"}}}}],"br":{}},"These model equations can be implemented in an M-file to be solved. Such an M-file may contain code as shown below.",{"@attributes":{"id":"p-0031","num":"0030"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"function [dx,y] = mds_model_ode (t,x,u,p1,p2,p3)"]},{"entry":[{},"% M-file ODE model of the mass-spring-damper system."]},{"entry":[{},"%"]},{"entry":[{},"% dx: Output equations"]},{"entry":[{},"% \u2003y: State equations"]},{"entry":[{},"%"]},{"entry":[{},"% t: Current time"]},{"entry":[{},"% x: State vector at time t"]},{"entry":[{},"% u: Input vector at time t"]},{"entry":[{},"% p1,..., pn: Model parameters"]},{"entry":[{},"m = p1; k = p2; b = p3;"]},{"entry":[{},"A = [0, 1, 0, 0;"]},{"entry":[{},"\u2003\u2003\u2212k(1)\/m(1), \u2212b(1)\/m(1), k(1)\/m(1), b(1)\/m(1);"]},{"entry":[{},"\u2003\u20030, 0, 0, 1;"]},{"entry":[{},"\u2003\u2003k(1)\/m(2), b(1)\/m(2), \u2212(k(1)+k(2))\/m(2), \u2212(b(1)+b(2))\/m(2)];"]},{"entry":[{},"B = [0; \u22121\/m(1); 0; 0];"]},{"entry":[{},"C = [1 0 0 0; 0 0 1 0];"]},{"entry":[{},"D = 0;"]},{"entry":[{},"dx = A*x + B*u;"]},{"entry":[{},"y = C*x + D*u;"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The Mass-Spring-Damper system of  can also be modeled in a graphical modeling environment such as Simulink. An example of such a system can be seen in the block diagram  of .","Alternatively to the M-file or Simulink models, the system of  can be modeled as linear time-invariant (LTI) object. Such a LTI object can be created using the following commands:",{"@attributes":{"id":"p-0034","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Function G = msd_model_lti( )"},{"entry":"% LTI model of the mass-spring-damper system."},{"entry":"m = [1 2]; k = [100 200]; b = [10 20];"},{"entry":"A = [0, 1, 0, 0;"},{"entry":"\u2003\u2212k(1)\/m(1), \u2212b(1)\/m(1), k(1)\/m(1), b(1)\/m(1);"},{"entry":"\u20030, 0, 0, 1;"},{"entry":"\u2003k(1)\/m(2), b(1)\/m(2), \u2212(k(1)+k(2))\/m(2), \u2212(b(1)+b(2))\/m(2)];"},{"entry":"B = [0; \u22121\/m(1); 0; 0];"},{"entry":"C = [1 0 0 0; 0 0 1 0];"},{"entry":"D = 0;"},{"entry":"G = ss(A, B, C, D);"},{"entry":"set (G, \u2018InputName\u2019, \u2003\u2018F\u2019,..."},{"entry":"\u2003\u2003\u2018OutputName\u2019 {\u2018d1\u2019 \u2018d2\u2019},..."},{"entry":"\u2003\u2003\u2018StateName\u2019, \u2003{\u2018Position 1\u2019, \u2018Velocity 1\u2019, \u2018Position 2\u2019, \u2018Velocity 2\u2019})"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"As can be seen from the above examples, there are several ways to model a system. One of the problems with there being multiple techniques is that they are not necessarily compatible. As such, toolboxes possessing tools and functions of interest may be compatible with one model but not another. For example, Simulink Parameter Estimation (SPE), Simulink Response Optimization (SRO), and Simulation Control Design (SCD) toolboxes can only be used with Simulink models. Likewise the Control System Toolbox (CST) can only be used with LTI models. This presents a problem, in that it may be desirable to use the features of a toolbox on a model the toolbox is not compatible with. Ideally, it would be advantageous to be able to interface a model, such as from a toolbox, regardless of how the model was created.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 4","b":["400","410","420","430"]},"The abstract interface allows for a model to be interfaced regardless of how it was generated. For each model type the implementation for the functions that interface with the toolbox are provided. As such, a toolbox or modeling environment can access any type of model. An example of this can be seen in the diagram  of . As depicted in this diagram , various model types  can be interface with a toolbox  using the abstract interface . In certain instances, a static model can also be interface for optimization and statistical analysis .","In certain embodiments, the abstract interface is an application programming interface (API). An API is a set of definitions of the ways one piece of computer software communicates with another. The API provides a set of routines, protocols, and tools for allowing communication between the software applications, for example the model and toolbox. Using these routines, protocols and tools the toolbox or modeling environment can interface with the model.","In one embodiment, the abstract interface is implemented using a model object class. The model class defines an interface for communicating with various types of models that can be created in MATLAB, including Simulink models, SimBiology models, and ODEs defined in M-functions. Toolboxes can communicate with the models through the model class interface, allowing the implementation of other model types.","The model class defines the properties for objects representing models. For example the class can define properties that are common for representations of all model types. These include field details, constructor details, and method details.","Field details include the version of the model. Other field details may be provided as necessary for specific models. Other suitable field details will be apparent to one skilled in the art given the benefit of this disclosure.","Constructor details set forth the call made by the abstract interface to create a model object. Examples of constructor details will be given below in reference to specific model types. Other suitable constructor details will be apparent to one skilled in the art given the benefit of this disclosure.","Method details include the methods functions and calls that are to be supported by an instantiated model object. A list of example methods that are to be implemented for all model types can be seen below:",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"getName: Returns the name of the model."},{"entry":"\u2003\u2003name = m.getName;"},{"entry":"getInputs\/findInput: Used to extract input port information from the model."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003hIn = m. getInputs;","% All inputs"]},{"entry":["\u2003\u2003hIn = m. getInputs([2 3]);","% Multiple inputs by indices"]},{"entry":["\u2003\u2003hIn = m.findInput(\u2018u\u2019) ;","% One input by name"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"getOuputs\/findOutputs: Used to extract output port information from the model."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003hOut = m.getOutputs;","% All outputs"]},{"entry":["\u2003\u2003hOut = m.getOutputs([1 2]);","% Multiple outputs by indices"]},{"entry":["\u2003\u2003hOut = m.findOutput(\u2018subsysteml\/Outl\u2019) ;","% One output by name"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"getParameters\/findParameter: Used to extract parameter information from the model."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003hPar = m.getParameters;","% All parameters"]},{"entry":["\u2003\u2003hPar = m.getParameters([2 4 7]);","% Multiple parameters by indices"]},{"entry":["\u2003\u2003hPar = m.findParameter(\u2018Ka\u2019);","% One parameter by name"]},{"entry":["\u2003\u2003hPar = m. f indParameter(\u2018reaction: Kl\u2019) ;","% One parameter by name"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"getStates\/findState: Used to extract state information from the model."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003hIc = m.getStates;","% All states"]},{"entry":["\u2003\u2003hIc = m.getStates([1 3 5]);","% Multiple states by indices"]},{"entry":["\u2003\u2003hIc = m.findState(\u2018sensor\/xl\u2019);","% One state by name"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"getValue: Used to get the current parameter and\/or initial state values in the model."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003sVal = m.getValue(\u2018Actuator Model\u2019);","% Get state value object by name"]},{"entry":["\u2003\u2003% Equivalent to:",{}]},{"entry":["\u2003\u2003sId = m.findState(\u2018Actuator Model\u2019);",{}]},{"entry":["\u2003\u2003sVal= m.getValue(sId);",{}]},{"entry":["\u2003\u2003pId \u2003= m.getParameters;",{}]},{"entry":["\u2003\u2003sId \u2003= m.getStates([2 4]);",{}]},{"entry":["\u2003\u2003pVal = m. getValue (pId) ;","% Get parameter value objects"]},{"entry":["\u2003\u2003hVal = m.getValue([pId; sId]);","% Get parameter\/state value objects"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"setValue: Used to set the parameter and\/or initial state values in the model."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003m.setValue(\u2018Actuator Model\u2019, 2.5);","% Set state value by name"]},{"entry":["\u2003\u2003% Equivalent to:",{}]},{"entry":["\u2003\u2003sId = m.findState(\u2018Actuator Model\u2019);",{}]},{"entry":["\u2003\u2003m.setValue(sId, 2.5);",{}]},{"entry":["\u2003\u2003hVal = m.getValue(sId);",{}]},{"entry":["\u2003\u2003hVal.Value = 2.5;",{}]},{"entry":["\u2003\u2003m. setValue (hVal) ;","% Set using value objects"]},{"entry":["\u2003\u2003pId = m.getParameters(2);",{}]},{"entry":["\u2003\u2003sId = m.getStates([2 4]);",{}]},{"entry":["\u2003\u2003m.setValue(pId, 1.0);","% Set parameter value"]},{"entry":["\u2003\u2003m.setValue([pId; sld], {1.0, 0.05, 0.0});","% Set parameter\/state values"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"addOutput: Adds one or more outputs to the model."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003hOut = m. addOutput(\u2018u\u2019);","% One output by name"]},{"entry":["\u2003\u2003hOut = m.addOutput(hPorts);","% From specified port objects"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"removeOutput: Removes one or more outputs from the model."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003m.removeOutput(\u2018Nz Pilot\u2019);","% One output by name"]},{"entry":["\u2003\u2003% Equivalent to:",{}]},{"entry":["\u2003\u2003hOut = m.find0utput(\u2018NZ Pilot\u2019);",{}]},{"entry":["\u2003\u2003m.removeOutput(hOut);",{}]},{"entry":["\u2003\u2003m.remove Out put;","% All outputs"]},{"entry":["\u2003\u2003m.removeOutput (hPorts);","% Specified output ports"]},{"entry":["\u2003\u2003m.removeOutput ([1 2]);","% Multiple outputs by indices"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"getLinearizationIOs\/findLinearizationIO: Used to extract linearization I\/O port information from the"},{"entry":"model."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003hLin = m.getLinearizationIOs;","% All linearization ports"]},{"entry":["\u2003\u2003hLin = m.getLinearizationIOs([1 2]);","% Multiple lin. ports by indices"]},{"entry":["\u2003\u2003hLin = m.findLinearizationIO(\u2018subsys\/In1\u2019);","% One linearization port by name"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"addLinearizationIO: Adds one or more linearization I\/Os to the model."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003hLin = m. addLinear izationIO (hPorts) ;","% From specified lin. port objects"]},{"entry":["\u2003\u2003hLin = m.addLinearizationIO(\u2018u\u2019);","% One linearization port by name"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"removeLinearizationIO: Removes one or more linearization I\/Os from the model,"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003m.removeLinearizationIO;","% All linearization ports"]},{"entry":["\u2003\u2003m. removeLinearizationIO(hPorts) ;","% Specified linearization ports"]},{"entry":["\u2003\u2003m.removeLinearizationIO([1 2]);","% Multiple lin. ports by indices"]},{"entry":["\u2003\u2003m.removeLinearizationIO(\u2018Nz Pilot\u2019);","% One linearization port by name"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"getCurrentConfig: Returns the current model configuration object (set)."},{"entry":"\u2003\u2003config = m.getCurrentConfig;"},{"entry":"setCurrentConfig: Sets the current model configuration object (set)."},{"entry":"\u2003\u2003m.setCurrentConfig(config);"},{"entry":"simulate: Returns the time response of the system for the (optionally) specified outputs."},{"entry":"\u2003\u2003[outputs, info] = m.simulate(timespan, inputs, options);"},{"entry":"getSensitivity: Gets the sensitivity derivatives of the system for the (optionally) specified outputs with"},{"entry":"respect to a given parameter or initial state."},{"entry":"\u2003\u2003[derivs, info] = m.getSensitivity(timespan, inputs, variable, options);"},{"entry":"\u2003\u2003[IResp, rResp, info] = m.getSensitivity(timespan, inputs, variable, options);"},{"entry":"findOperatingPoint: Finds the operating point (steady-state) of the model from operating point"},{"entry":"specifications or by simulation at the given times."},{"entry":"\u2003\u2003[op_point, op_report] = m.findOperatingPoint(op_spec, linoptions);"},{"entry":"\u2003\u2003op_points = m.findOperatingPoint(snapshottimes, linoptions);"},{"entry":"linearize: Linearize the model at the given operating point for (if) specified linearization I\/O ports."},{"entry":"\u2003\u2003G = m.linearize(op.point, linearizationios, linoptions);"},{"entry":"\u2003\u2003G = m.linearize(snapshottimes, linearizationios, linoptions);"},{"entry":"update: Synchronizes the concrete Model object when the underlying model changes."},{"entry":"\u2003\u2003m.update;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The model class can also be extended for specific model types. For example, the model class may be extended to a MLModel class. The MLModel class defines a concrete interface for communication with models defined in either M-Files or Mex-files. Mex-files are used to implement model equation in compiled code such as Fortran or C. The MLModel class has all the properties of the model class plus some additional properties set forth below.","Field Details","ModelFcn: Function handle to the M-file or MEX-file representing the model.","IOPorts: Object array of type MLPortID containing information about the I\/Os of the model.","LinearizationPorts: Object array of type MLLinearizationPortID containing information about the linearization I\/Os of the model.","Parameters: Object array of type MLParameterID containing information about the parameters of the model.","States: Object array of type MLStateID containing information about the states of the model.","ParameterValues: Object array of type ParameterValue storing current parameter values.","InitialState: Object array of type StateValue storing initial state values.","ConfigSet: Object containing various simulation settings for the model.","Constructor Details\u2014the syntax to create a Matlab model object is",{"@attributes":{"id":"p-0054","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["h=modelpack.MLModel(@mfile, Nin, Nout, Nstates, \u2018param1\u2019, value1, . . . );","h=modelpack.MLModel(@mfile, {\u2018in1\u2019, . . . }, {\u2018out1\u2019, . . . }, {\u2018state1\u2019 . . . }, . . . \u2018param1\u2019, value1, . . . );","h=modelpack.MLModel(Omfile, Nin, {\u2018out1\u2019, . . . }, Nstates, . . . ); % Mixed\n\nMethod Details\n"]}}}},"addParameter: Adds one or more parameters to the model.",{"@attributes":{"id":"p-0056","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pId = m.addParameter(\u2018name\u2019, value);","% One parameter by name"]},{"entry":["pId = m.addParameter","% Multiple parameters"]},{"entry":"({\u2018name1\u2019, \u2018name2\u2019}, {1.0,0.05});"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"removeParameter: Removes one or more parameters from the model.",{"@attributes":{"id":"p-0058","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["m.removeParameter(\u2018name\u2019;) ;","% One parameter by name"]},{"entry":["% Equivalent to:",{}]},{"entry":["pld = m f indParameter(\u2018name\u2019) ;",{}]},{"entry":["m.removeParameter(pId);",{}]},{"entry":["m.removeParameter;","% All parameters"]},{"entry":["m.removeParameter(pId) ;","% Specified parameters"]},{"entry":["m.removeParameter([1 2]);","% Multiple parameters by indices"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The hierarchy of the model class  to other classes, including sub classes  such as the MLModel class, can be seen in . Other possible subclasses extended from the model class will be apparent to one skilled in the art given the benefit of this disclosure.","In some embodiments, the abstract interface is further implemented using an identifier object class. As with the model class, the identifier (VariableID) class can define properties that are common for representations of all model types. These include field details, constructor details, and method details.","In this example, there are three main subclasses of the identifier class. These include the port identifier class (PortID), the parameter identifier class (ParameterID), and the state identifier class (StateID). Each of these share the common properties of the Variable ID class plus additional properties.","The port identifier class (PortID) is an abstract class that defines an interface for objects representing the concept of inputs and outputs of a model. The inputs are the points where signals are injected into a model; and the outputs are the points where signals of interest are measured and logged. These also include signals marked as linearization I\/Os. The classes derived from the PortID class need to implement the operations defined by the interface and are used by the Model objects to identify their inputs and outputs to interested client objects. In the context of parameter estimation, the operations defined by the interface provide a mapping between the inputs and outputs of a model and the experimental data that is associated with them during estimations. For example, each object storing transient data in SPE will keep a reference to an object derived from the PortID class to do this mapping.","An example of the properties for the PortID class can be seen below:","Field Details:","Description: A description string.","Version: The version number used by subclasses to handle backward compatibility issues in conjunction with their loadobj and saveobj methods.","Method Details:","getDimensions: Returns a row vector of integer numbers corresponding to the dimensions of the signal at the port.\n\n","There are three types of possible values:\n\n","getFullName: Returns the unique full name of the port. The full name of a port usually consists of a concatenation of its path and name; and it uniquely identifies the port in the model.\n\n","getName: Returns the name of the port.\n\n","getPath: Returns the path to the port, which is usually the full name of the (sub) system containing the port.\n\n","get Type: Returns the port type, which is an enumerated string of type Model_IOType.\n\n","As with the model class, the port identifier class (portID) can also be extended for specific model types. The hierarchy of the portID class  to the VariableID  and other classes can be seen in . Other possible subclasses  extended from the PortID class will be apparent to one skilled in the art given the benefit of this disclosure.","In certain embodiments a linearization I\/O class is used in conjunction with the PortID classes to denote the linearization I\/Os in a model. Examples of the pertinent properties are set forth below:","Method Details:","is OpenLoop: Returns the open-loop status of the signal marked as a linearization I\/O.\n\n","setOpenLoop: Sets the open-loop status of the signal marked as a linearization I\/O.\n\n","set Type: Sets the linearization I\/O type to an enumerated string of type Model_IOType.\n\n","The interrelation of the Linerization I\/O class  to subclasses  and other classes can be seen in . Other possible embodiments will be apparent to one skilled in the art given the benefit of this disclosure.","The parameter identifier class (ParameterID) defines an interface for objects representing the concept of parameters of a model. The classes derived from the ParameterID class need to implement the operations defined by the interface and are used by the Model objects to identify their parameters to interested client objects. In the context of parameter estimation, the operations defined by the interface provide a mapping between the parameters of a model and the objects working with parameter values during estimations. For example, each object representing estimated parameters in SPE will store a reference to an object derived from the ParameterID class to avoid redundant storage of parameter information.","An example of the properties for the ParameterID class can be seen below:","Field Details:","Description: A description string.","Version: The version number used by subclasses to handle backward compatibility issues in con junction with their loadobj and saveobj methods.","Method Details:","getDimensions: Returns a row vector of integer numbers corresponding to the dimensions of the parameter value.\n\n","getFullName: Returns the unique full name of the parameter.\n\n","getName: Returns the name of the parameter.\n\n","getPath: Returns the path to the parameter, which is usually the full name of the (sub)system in which the parameter is defined.\n\n","getClass: Returns the class of the parameter value.\n\n","getLocations: Returns a cell array of the full names of the objects (model, subsystems, blocks, etc.) using the parameter. If no other information is available, the string from getPath could be returned in a cell array. The location names are all relative to the model, and hence they do not include the model name.\n\n","As with the port identifier class (portID), the parameter identifier class (ParameterID) can also be extended for specific model types. The hierarchy of the ParameterID class  to other classes can be seen in . Other possible subclasses  extended from the ParameterID class will be apparent to one skilled in the art given the benefit of this disclosure.","The state identifier class (StateID) defines an interface for objects representing the concept of states of a model. The classes derived from the StateID class need to implement the operations defined by the interface and are used by the Model objects to identify their states to interested client objects. In the context of parameter estimation, the operations defined by the interface provide a mapping between the states of a model and the objects working with state values during estimations. For example, each object representing estimated states or initial state data in SPE will store a reference to an object derived from the StateID class to do this mapping.","An example of the properties for the State ID class can be seen below:","Field Details:","Description: A description string.","Version: The version number used by subclasses to handle backward compatibility issues in conjunction with their loadobj and saveobj methods.","Method Details;","getDimensions: Returns a row vector of integer numbers corresponding to the dimensions of the state value.\n\n","getFullName: Returns the unique name of the state.\n\n","getName: Returns the name of the state.\n\n","getPath: Returns the path to the state, which is usually the full name of the (sub)system in which the state is defined.\n\n","getTs: Returns the sampling time of the state.\n\n","As with the port identifier class (portID), the state identifier class (StateID) can also be extended for specific model types. The hierarchy of the StateID class  to other classes can be seen in . Other possible subclasses  extended from the StateID class will be apparent to one skilled in the art given the benefit of this disclosure.","In some embodiments, the abstract interface is further implemented using a value object class. As with the model and identifier classes, the value class can define properties that are common for representations of all model types. These include field details, constructor details, and method details.","In this example, there are four main types of the value class. These include a variable value class, a parameter value class, a state value class, and port value class. For purposes of illustration the discussion will focus on the variable value class. The implementation of the other classes will be apparent to one skilled in the art given the benefit of this disclosure.","The variable value (VariableValue) class defines an interface to represent the concept of value of an object identified by a Variable ID object. The classes derived from the VariableValue class need to implement the operations defined by the interface and are used by the Model objects to identify values of parameters, states, and ports to interested client objects. The value objects are used to store the values of I\/Os, parameters, or states resulting from estimation, tuning, or trimming the model. They can also be used to initialize model parameters and initial states. Hence, most of their properties are public since they would be modified by the users.","An example of the properties for the VariableValue class can be seen below:","Field Details:","ID: The VariableID object associated with this object.","Version: The version number used by subclasses to handle backward compatibility issues in conjunction with their loadobj and saveobj methods.","Name: The name of the associated object.","Value: The value of the associated object.","Description: A description string.","Constructor Details.","The classes ParameterValue, StateValue, and PortValue implement the VariableValue interface:",{"@attributes":{"id":"p-0108","num":"0134"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"h0 = modelpack.ParameterValue(m,","% Name and"]},{"entry":[{},"\u2018path\/name(expr) \u2019);","expression"]},{"entry":[{},"h0 = modelpack.ParameterValue(m, pld, \u2018expr\u2019);","% ID object"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{},{},{},{},{},{},{},{}]},"getID: Returns the identifier of type VariableID associated with this object.\n\n","The hierarchy of the variable value class , the parameter value class , the state value class , and port value class  can be seen in .","In some embodiments, the abstract interface is further implemented using a specification object class. As with the model and value classes, the specification class can define properties that are common for representations of all model types. These include field details, constructor details, and method details.","In this example, there are four main types of the specification class. These include a variable specification class, a parameter specification class, a state specification class, and port specification class. For purposes of illustration the discussion will focus on the variable specification class. The implementation of the other classes will be apparent to one skilled in the art given the benefit of this disclosure.","The variable specification (VariableSpec) class defines an interface to represent the concept of value specification for an object identified by a VariableID object. The specifications include the variable's range and initial value. These are used to specify information about unknown values to be computed (i.e. estimated, optimized, and trimmed). The classes derived from the VariableSpec class need to implement the operations defined by the interface and are used by the Model objects to specify values of parameters, states, and ports to interested client objects. The specification objects are used to specify I\/O, parameter, or state information (ranges, initial guesses, etc) for estimation, tuning, or operating point computations. Hence, most of their properties are public since they would be modified by the users.","An example of the properties for the VariableSpec class can be seen below:","Field Details.","ID: The VariableID object associated with this object.","Version: The version number used by subclasses to handle backward compatibility issues in conjunction with their loadobj and saveobj methods.","Name: The name of the associated object.","Initial Value: The initial value of the associated object.","Minimum: The minimum value of the associated object.","Maximum: The maximum value of the associated object.","Known: The optimization state of the associated object.","TypicalValue: The typical value of the associated object.","Description: A description string.","Constructor Details.","The classes ParameterSpec, StateSpec, and PortSpec implement the VariableSpec interface:",{"@attributes":{"id":"p-0124","num":"0151"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"h0 = modelpack.ParameterSpec(m,","% Name and"]},{"entry":[{},"\u2018path\/name(expr) \u2019);","expression"]},{"entry":[{},"h0 = modelpack.ParameterSpec (m, pld, \u2018expr\u2019);","% ID object"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{},{},{},{},{},{},{},{}]},"getID: Returns the identifier of type VariableID associated with this object.\n\n","The hierarchy of the variable specification class , the parameter specification class , a state specification class , and port specification class  can be seen in .","In some embodiments, the abstract interface is further implemented using a helper object class. As with the other classes discussed above, the helper class can define properties that are common for representations of all model types. These include field details, constructor details, and method details.","In this example, there are two main types of the helper class. These include a model manager class and an options class. The implementation of the other classes will be apparent to one skilled in the art given the benefit of this disclosure.","The model manager (ModelManager) class defines a singleton object to manage various model objects to avoid duplications. Basically, each model object is a singleton for a given model name.","An example of the properties for the ModelManager class can be seen below:","Field Details:","Models: Stores model object handles currently in use.","ModelListeners: Stores listeners to remove the model object handles from the model list when they are deleted.","Listeners: Internal listeners for the object's own use.","Constructor Details. The syntax to create a model manager object is:\n\n",{"@attributes":{"id":"p-0135","num":"0164"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"this = modelpack.MyModelClass;"]},{"entry":[{},"%..."]},{"entry":[{},"% Ask the model manager if the model exists"]},{"entry":[{},"h = addModeK modelpack.ModelManager, this, \u2018name\u2019 );"]},{"entry":[{},"if (this == h)"]},{"entry":[{},"\u2003% New model. Initialize it."]},{"entry":[{},"\u2003% ..."]},{"entry":[{},"else"]},{"entry":[{},"\u2003% Model already exists."]},{"entry":[{},"\u2003this = h"]},{"entry":[{},"end"]},{"entry":[{},"% Return \u2018this\u2019"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In this example the option class has two types: simoptions and gradoptions. The simoptions and gradoptions classes are used to specify various simulation and sensitivity computation options in conjunction with method object method calls.","An example of the properties for the simoptions class can be seen below","Field Details. The simoptions object has the following properties:","Configuration: Configuration set.","InitialState: An array of State Value objects.","Outputs: An array of Port ID objects indicatings the outputs for which the responses are desired.","Description: A description string.","Version: The version number used by subclasses to handle backward compatibility issues in conjunction with their loadobj and saveobj methods.","Constructor Details. The syntax to create options objects are:\n\n","The gradoptions class is a subclass of the simoptions class. As such is has the same base properties as simoptions plus the following:","Field Details.","GradientType: The gradient computation accuracy, which is an enumerated string","Perurbation: Minimum and maximum perturbation sizes used in sensitivity computations.","Constructor Details:","h=modelpack.gradoptions(m);","The hierarchy of the ModelManagaer class , the simoptions class , and gradoptions class  can be seen in .","Referring now back to , the second step of the method is making a call to the dynamic model via methods specified in the abstract interface. The call may be any of methods supported by the object classes set forth above. Using the abstract interface, calls can be used to query the model about its properties such as its inputs, parameters, etc.; simulate the model and gather its response; obtain various model jacobians; and trim and linearize the model.","An example of calls and operations performed for an M-file model can be seen below:",{"@attributes":{"id":"p-0151","num":"0181"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"% Create model object"},{"entry":"model = modelpack.MLModel(@msd_model_ode, 1, 2, 4, ..."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2018m\u2019, [1 2], \u2018k\u2019, [100 200], \u2018b\u2019, [10 20]);"},{"entry":"% or"},{"entry":"model = modelpack.MLModel(@msd_model_ode, {\u2018F\u2019}, {\u2018d1\u2019, \u2018d2\u2019}, ..."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003{\u2018Pos 1\u2019, \u2018Vel 1\u2019, \u2018Pos 2\u2019, \u2018Vel 2\u2019}, ..."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2018m\u2019 , \u2002[ 1 2 ] , \u2002\u2018k\u2019 , \u2002[100 200], \u2002\u2018b\u2019 , \u2002[10 20]);"},{"entry":"% Set initial values"},{"entry":"s = model.getStates;"},{"entry":"model.setValues(s, {1 0 1 0});"},{"entry":"% Simulate"},{"entry":"ts1 = model.simulate(time, force);"},{"entry":"% Compute sensitivity"},{"entry":"ts2 = model.getSensitivity(time, force, \u2018k\u2019);"},{"entry":"% Operating points"},{"entry":"op_point = model.findOperatingPoint(1.0);"},{"entry":"% Linearization"},{"entry":"pin = model.getInputs;"},{"entry":"pOut = model.getOutputs;"},{"entry":"model.addLinearizationIO([pIn pOut])"},{"entry":"G = model.linearize(op.point);"},{"entry":"step(G);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In this example a model object was created and initial values were set. Then the model was simulated, sensitivity was computed, and operating points determined. Then the model was linearized.","The examples to this point have focused primarily on the system where the graphical modeling environment was on a local computing device. The graphical modeling environment may, of course, also be implemented on a network , as illustrated in , having a server  and a client device . Other devices, such as a storage device , may also be connected to the network.","In one such embodiment a system for generating and displaying a graphical modeling application, comprises a distribution server for providing to a client device, intrinsic units of measure for modeling physical systems; and a client device in communication with the distribution server. Here the distribution server provides a client device, such as a computing device discussed above, an abstract interface for interfacing a model. The abstract interface is compatible with a plurality of model types. The abstract interface may be an API. The client may then use the abstract interface to access a dynamic model of a system.","In another embodiment, the server may execute the modeling environment. A user may then interact with the modeling environment on the server through the client device. In one example of such a system, a server and client device are provided. The server is capable of executing a modeling environment. The client device is in communication with the server over a network. An abstract interface is provided for interfacing a model. The abstract interface is compatible with a plurality of model types. The server receives from the client device, a call to a dynamic model using the abstract interface. The client device then receives data from the dynamic model from the server in response to the call.","It will be understood by one skilled in the art that these network embodiments are exemplary and that the functionality may be divided up in any number of ways over a network.","The proceeding examples have focused primarily on models of physical systems but it will be apparent to one skilled in the art that there are numerous other domains, systems, fields and applications the present invention would be suitable. Some examples include but are not limited to, models in the electrical, biological, and chemical domains.","The present invention has been described relative to illustrative embodiments. Since certain changes may be made in the above constructions without departing from the scope of the invention, it is intended that all matter contained in the above description or shown in the accompanying drawings be interpreted as illustrative and not in a limiting sense.","It is also to be understood that the following claims are to cover all generic and specific features of the invention described herein, and all statements of the scope of the invention which, as a matter of language, might be said to fall therebetween."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
