---
title: Database heap management system with variable page size and fixed instruction set address resolution
abstract: A heap management system for a database uses “sets” of pages to store database information. As memory for each successive set of pages is allocated, more memory is allocated for storing rows in each page of the set. Similarly, the maximum number of rows of information storable in each page of each set is greater for each successive set of pages. The number of computer instructions needed to resolve (or calculate) the memory address for a particular row is fixed. Given a target row number, (and the number of rows in the first page, and the width of the column or column group), only a fixed number of computer instructions need to be executed to resolve the starting memory address for the target row. In addition, information of the same type (i.e., one or more columns of a table) may be stored in different pages, and these pages may be located in discontiguous memory segments. This allows space for new rows to be allocated, without requiring all pre-existing rows to be moved to a different memory segment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07818346&OS=07818346&RS=07818346
owner: Temporal Dynamics, Inc.
number: 07818346
owner_city: Fishers
owner_country: US
publication_date: 20060801
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","APPENDIX 2","EXAMPLE"],"p":["This application claims the benefit of prior-filed International Application No. PCT\/US2006\/029771, filed Aug. 1, 2006, which claims priority to prior-filed U.S. patent application Ser. No. 11\/209,551, filed Aug. 24, 2005, both applications being titled DATABASE HEAP MANAGEMENT SYSTEM WITH VARIABLE PAGE SIZE AND FIXED INSTRUCTION SET ADDRESS RESOLUTION, and incorporated by reference herein.","The present invention relates to database management systems, and in particular, to heap management systems that store database information in pages.","This invention relates database for software applications which are large, complex, or which require dynamic modification and high availability. The invention addresses the stringent requirements of time-critical real-time and other high performance systems. These systems are characterized by their primary need for query performance as opposed to query flexibility. For example, a telecommunications call processing system might need to process 500 calls per second during peak demand periods. If the underlying DBMS can complete a call in 3 milliseconds (just slightly longer than the average 2-millisecond call separation), the system degradation is progressive, and the system will completely collapse. After 10 minutes of peak demand, the call completion delay would be greater than 1 minute. Even if average DBMS performance averages better than 2 ms, any significant variation can result in periods of degraded performance unacceptable in the telecommunications industry. As a result the predictability of the performance is of equal concern.","Database information may be stored in computer memory (i.e., solid state memory directly addressable by a CPU using a physical address) or on hard drives. Computer memory tends to be very fast, but there are practical and cost limitations to how much computer memory can be directly referenced by a CPU. Hard drives can store larger quantities of information, but it takes more time to move information between a CPU and a hard drive. This time constraint for information stored on hard drives makes hard drive storage unsuitable for databases that require extremely fast retrieval or storage of information. Moreover, even when an entire database is stored in computer memory, it is often important that the computer memory be located in one contiguous block, including having freespace available within the allocated block for new rows of information. This is because when there is not sufficient contiguous memory available for a new information, an entirely new, contiguous block of memory must be allocated from the operating system, and all of the database information must be copied from the old memory locations to the new, larger, memory locations where there is room to insert the new information. Even though such a moving of information can take place entirely in memory, it requires significant computing resources. Thus, the database may become temporarily unavailable, which makes such a system inadequate for some applications.","In most prior art systems, the heap management of pages function is usually performed by the operating system for all the applications running on the computer. This approach results in high levels of competition for resources and context switching, which results in a relatively slow and unpredictable response.","Two types of databases are relational databases and network (or interconnected) databases. Relational databases correlate types of information (columns) between different tables in the database. In general, in a relational database, all queries are supported equally, and normalization is a function of the data, not the query. Network databases correlate rows in different tables of the database by pointers, or references to specific rows, and are designed to focus on operational queries. These operational queries reflect a pre-determined decision by the database designer, who selects which columns will contain pointers to other tables. Stated differently, in a relational database, a join occurs at the time of a query, while in a network database, the join happens when data is inserted into the database (because that is when the pointer to other rows are created).","Accordingly, objectives of the present invention include:\n\n","A database system uses \u201csets\u201d of pages to store database information from a plurality of tables of information. For a specific type of information (one or more columns of a table) each \u201cset of pages\u201d for that information comprises one or more pages, and each page with a set is capable for storing the same number of rows. As memory for each successive set of pages is allocated, more memory is allocated for storing rows in each page of the set. Similarly, the maximum number of rows of information storable in each page of each set is greater for each successive set of pages.","In one embodiment of the invention, the number of computer instructions needed to resolve (or calculate) the memory address for a particular row is fixed. Unlike balanced binary tree implementations, where the required number of queries to an index increases with the size of the database, with the present invention, given a target row number, (and the number of rows in the first page, and the width of the column or column group), only a fixed number of computer instructions need to be executed to obtain the starting memory address for the target row.","In addition, information of the same type (i.e., one or more columns of a table) may be stored in different pages, and these pages may be located in discontiguous memory segments. As compared to prior systems requiring contiguous memory, this allows space for new rows to be allocated, without requiring all pre-existing rows to be moved to a different memory segment.","In another aspect of the invention, the database system interfaces with software applications that access database information. The system maintains a master copy of each page table. As a part of the interface, the database system maintains a version number for each page table, and provides copies of the page tables to the applications. This allows the applications to calculate physical addresses for information without having to access shared memory, which tends to be slower. This appreciably increases the speed with which information may be retrieved from the database by applications. Moreover, if a change to the database schema (data dictionary) is made, the version number of the master copy is incremented. Before an application attempts to access database information, it checks to see whether the version number of its copy of a page table matches that in the master copy. If they are different, then the application's page table copy is refreshed. This technique allows changes to be made to the database schema while applications access the database information, i.e., the database does not need to be closed.","The invention comprises a database system comprised of multiple tables of information. Each table comprises one or more columns of information. The database is a linked list database. While linked list databases are well-known in the art (see, e.g., U.S. Pat. No. 5,560,006) some of the distinguishing characteristics of them relevant to the present invention are:\n\n","An example of linked list tables is exemplified by the following:",{"@attributes":{"id":"p-0016","num":"0022"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"PersonInfo (contains names and phone numbers)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},{},{},"Pointer to"]},{"entry":["Row No.",{},{},{},{},"SSN Row"]},{"entry":["(Not Stored)","Name","Phone","NextName","Prior Name","No."]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":["1","Smith","555-1234","*","2","3"]},{"entry":["2","Jones","555-2222","1","4","4"]},{"entry":["3","Brown","555-8888","4","*","1"]},{"entry":["4","Johnson","555-0000","2","3","2"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0017","num":"0023"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SSN Info (contains SSNs and No. of Exemptions)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"42pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},{},{},"Pointer to"]},{"entry":["Row No.",{},"No.","Next","Prior","Name Row"]},{"entry":["(Not Stored)","SSN","Exemptions","SSN","SSN","No."]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":["1","222-33-4444","3","2","3","3"]},{"entry":["2","444-33-2222","4","4","1","4"]},{"entry":["3","111-22-3333","1","1","*","1"]},{"entry":["4","555-44-3333","4","*","2","2"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}}},"The database system may use \u201csets\u201d of pages to store database information from a plurality of tables of information. For a specific type of information (one or more columns of a table) each \u201cset of pages\u201d for that information comprises one or more pages, and each page with a set is capable for storing the same number of rows. For example, in one embodiment, there are 8 pages in the first \u201cset\u201d of pages, and four pages in each successive set of information. Suppose the first page of data is sized so to hold 100 rows of information. Each of the next 7 pages would also hold 100 rows, for a total capacity of 800 rows in the 8 pages comprising the first page set. The number of rows held by the 9through 12pages may be doubled to 200 rows, so 1,600 rows may be stored in total. For the third set of pages (13-16), each page may hold 400 rows. The progression is shown by the following table:",{"@attributes":{"id":"p-0019","num":"0025"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},{},"No. Rows in",{},"Cumulative No."]},{"entry":[{},"No. Pages","Each Page of","Total No. of","of Rows in All"]},{"entry":["Set No.","in Set","Set","Rows in Set","Sets"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","8","100","800","800"]},{"entry":["2","4","200","800","1600"]},{"entry":["3","4","400","1600","3200"]},{"entry":["4","4","800","3200","6400"]},{"entry":["5","4","1600","6400","12800"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The progression may continue. As memory for each successive set of pages is allocated, more memory is allocated for storing rows in each page of the set. Similarly, the maximum number of rows of information storable in each page of each set is greater for each successive set of pages. In the example shown above, the number of pages in the first set is 8. It will be appreciated that memory need only be allocated for one page at a time; memory for all pages in a set need not be allocated when memory for the first page of a new set of pages is allocated. In addition, allocation of memory for a page does not necessarily mean that all of the available memory in the page is populated with data. For example, in the example above, when memory for the first page of the first set is allocated, even if there are only, say 52 rows of database information, the system will still allocate enough space for 100 rows. The remaining 48 rows will be populated as new rows are added to the database. Allocating memory for the 101row may be deferred until the 101row of data is actually requested by the particular application adding data to the database.","In one embodiment, pages contain a power of 2 of the number of entries (entries per page\u2014epp). The base epp (bepp) is the initial epp for pages 0.7. pages 8.11 have 2*bepp. pages 12.15 have 4*bepp and so forth. For a beginning number or rows in the first page of 512, the progression of increasing page size may be as follows",{"@attributes":{"id":"p-0022","num":"0028"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},{},"rows","total"]},{"entry":[{},"page","per","no."]},{"entry":[{},"number","page","rows"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0 . . . 7","512","\u20034K"]},{"entry":[{},"\u20028 . . . 11","\u20031K","\u20038K"]},{"entry":[{},"12 . . . 15","\u20032K","\u200216K"]},{"entry":[{},"16 . . . 19","\u20034K","\u200232K"]},{"entry":[{},"20 . . . 23","\u20038K","\u200264K"]},{"entry":[{},"24 . . . 27","\u200216K","128K"]},{"entry":[{},"28 . . . 31","\u200232K","256K"]},{"entry":[{},"32 . . . 35","\u200264K","512K"]},{"entry":[{},"36 . . . 39","128K","\u20031 M"]},{"entry":[{},"40 . . . 43","256K","\u20032 M"]},{"entry":[{},"44 . . . 47","512K","\u20034 M"]},{"entry":[{},"48 . . . 51","\u20031 M","\u20038 M"]},{"entry":[{},"52 . . . 55","\u20032 M","\u200216 M"]},{"entry":[{},"56 . . . 59","\u20034 M","\u200232 M"]},{"entry":[{},"60 . . . 63","\u20038 M","\u200264 M"]},{"entry":[{},"64 . . . 67","\u200216 M","128 M"]},{"entry":[{},"68 . . . 71","\u200232 M","256 M"]},{"entry":[{},"72 . . . 75","\u200264 M","512 M"]},{"entry":[{},"76 . . . 79","128 M","\u20031 G"]},{"entry":[{},"80 . . . 83","256 M","\u20032 G"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"Efficient calculation techniques may be realized by having 8 pages in the first set of pages, though this is not a requirement of the invention. (However, the number of pages in the first set of pages is preferably a power of two, i.e., 2, 4, 8, 16, 32, 64, etc.). Also, while the number of rows in each page of each set preferably doubles for each successive set of pages, and this allows some efficient calculation techniques to be utilized, it is not mandatory that the increase be by two. Aspects of the invention merely require that there be a continuous increase in the number of rows that may be stored in the each page of successive sets of pages.","Page Tables. In one embodiment, a contiguous memory space is allocated to at least each page. Because tables or columns may be stored in multiple, discontiguous pages, not all data elements of the same data type (columns) are likely to be contiguous in memory. Although logically, multiple columns of a single table are often thought of as being \u201ccontiguous,\u201d the invention does not require that all data elements of a row be stored in contiguous memory. For example, for the four records in the PersonInfo table could be stored with all of the information for Name field being stored first, then all the information for the phone number field, as follows (assuming 10 bytes are allocated for name, 8 for phone, and one byte for each of the next, previous, and pointer fields (yielding a row width of 21 bytes):",{"@attributes":{"id":"p-0025","num":"0031"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Smith---555-1234*23Jones---555-2222144Brown---555-"]},{"entry":[{},"88884*1Johnson-555-0000232----------------------------------"]},{"entry":[{},"-------------------------------------------------------"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In the above example, the final string of 84 \u201c-\u201d's represents memory allocated for the first page capable of holding 8 rows, wherein the final 4 rows that are not yet populated with data. Of course, those of skill in the art will further appreciate that this illustrative example assumes that since only one byte is allocated for the next, prior and pointer fields, that the maximum number of rows for the record will be 2^8 or 64. In actual implementations, many more bytes would likely be allocated for these numbers, yielding a larger row width.","Page tables may be used to keep track of the pages. A page table includes an array identifying page numbers, and for each page number, an identification of the memory address (either an offset form a memory segment or a physical memory address) containing the beginning of the data for the column\/table page.","In one embodiment, a separate page is created for each column (or sets of columns) of a table that will contain pointers to other tables. The decision of what columns will be combined is usually based on whether the column will serve as an index or key. For example, suppose a table will contain information regarding names, addresses and phone numbers, and the address field will be comprised of street address, city, state and zipcode. If the database designer wishes to have an index only on name, phone number and zip code, then initially, three pages may be created: one for name, street address, city and state, one for phone number, and one for zipcode. In essence, although there are six logical \u201ccolumns\u201d of information, for purposes of implementation, there will be only three columns, as 4 columns will be grouped together for storage purposes (one of which will be indexed).","One benefit of the present system is that the number of computer instructions needed to calculate the memory address for a particular target row is fixed. The request to retrieve database information can be distilled to: For a given database table (or column), what is the beginning memory address (offset from the beginning of the page) where row x is located (firstbyte in the instructions below)? Answering this question is known as \u201caddress resolution.\u201d The \u201cmemory address\u201d referred to in this embodiment is to the offset from the beginning of the page of memory in which the row resides. To answer this question, several database parameters will be known:\n\n","Specifically, given a target row number (row, in this example, a 64 bit integer), the first byte of memory of the row containing the target row may be calculated as follows.",{"@attributes":{"id":"p-0031","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"sh = bsrl( row | (1 << (bsh+2)) ) \u2212 2 ; \/\/ calculate the shift for a given row"},{"entry":"\u2003\u2003\u2003\u2003using the barrel shift right logical command"},{"entry":"mask = (1 << sh) \u2212 1 ;\u2003\u2003\u2003\u2003\/\/ calculate a mask to be used for page"},{"entry":"\u2003\u2003\u2003\u2003row (prow) calculation"},{"entry":"pg = (row >> sh) + ((sh \u2212 bsh) << 2) ; \/\/ Calculate the page # (0 based"},{"entry":"\u2003\u2003\u2003\u2003(the first page is page no. 0)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["prow = row & mask ;","\u2003\u2003\u2003\/\/ calculate the row on the page #"]},{"entry":[{},"\u2003\u2003\u2003from above"]},{"entry":["poff = prow * width ;","\u2003\u2003\u2003\/\/ calculate the byte offset for the row on"]},{"entry":[{},"\u2003\u2003\u2003the page"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"firstbyte = pagestart +poff \/\/calculate the firstbyte of the target row"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Thus, the number of computer instructions needed to show the calculations that must be performed to calculate the memory address can be represented by the above six statements. Those of skill in the art will appreciate that these equations will work regardless of the number rows in the database. The only limit on the size of the database will be the number of bits used to store an integer.","Of course, larger or smaller databases may be accommodated by selecting CPU architectures other than 64 bit architecture.","Once the page and offset from a row have been calculate, the remaining calculations are as follows:",{"@attributes":{"id":"p-0035","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"2. Get page size in KBytes"},{"entry":"\u2003\u2003\u2003Given epp and width"},{"entry":"\u2003\u2003\u2003pgsz = ((epp * width) + HEAPUNIT \u2212 1) >> HEAPSHIFT ;"},{"entry":"\u2003\u2002\/\/ MKMOD(epp*width,HEAPUNIT) >> HEAPSHIFT"},{"entry":"3. Get epp (and pgsz) given page"},{"entry":"\u2003\u2003\u2003Given bsh"},{"entry":"\u2003\u2003\u2003if ((pg & 7) == 0) sh = bsh ;"},{"entry":"\u2003\u2003\u2003else sh = bsh + ((pg \u2212 4) >> 2) ;"},{"entry":"\u2003\u2003\u2003as before: epp = (U64)1 << sh ;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003pgsz = MKMOD(epp*width,HEAPUNIT) ;"},{"entry":"4. Get initial bsh, bepp and bpgsz given width and depth"},{"entry":"\u2003\u2003\u2003if (depth = 0)\u2003\/\/ Try for depth ~ 8K\/width"},{"entry":"\u2003\u2003\u2003\u2003bsh = bsrl(8192\/width) ; \/\/ ok if it is 0"},{"entry":"\u2003\u2009 else"},{"entry":"\u2003\u2003\u2003\u2003bsh = bsrl(depth >> 3) ;"},{"entry":"\u2003\u2009 bepp = 1 << bsh ;"},{"entry":"\u2003\u2003\u2003bpgsz = MKMOD(bepp*width,HEAPUNIT) >> HEAPSHIFT ;"},{"entry":"5. Get total N given pages and bsh"},{"entry":"\u2002\u2009 if ((pages >> 3) == 0) totN = pages << bsh ;"},{"entry":"\u2002\u2009 else {"},{"entry":"\u2003\u2002\u2009sh = bsh + ((pages \u2212 5) >> 2) ;"},{"entry":"\u2003\u2002\u2009totN = ((((pages\u22121)&3)+1) << sh) + (1 << (sh+2)) ;"},{"entry":"}"},{"entry":"Note: last page = pages \u2212 1"},{"entry":"\u2003\u2002database depth = totN \u2212 1, row: [0 . . . totN\u22121]"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Once poff (Page Offset) is known, this number may be simply added to a number representing the beginning address of the page in which the row is located, to yield the physical memory address of the first byte of the row. The latter information may be stored in a page table, or a combination of a page table and a memory segment table (if the system is implemented on a computer in which multiple memory segments may be allocated to the database system). In summary, the physical memory address for the first byte or a row equals the sum of: (a) the beginning address of the memory segment in which the page is stored; (b) the beginning address (measured from the beginning of the memory segment) of the beginning of the data for the page; and (c) the page offset. For example, in one embodiment, the database system can request from the operating system multiple memory segments as the need arises, and each memory segment may store one or more pages. For example, the following table shows how three exemplary memory segments might be allocated. Typically, the database system will request additional memory to be allocated (usually by the operating system) whenever space for additional rows must be allocated that exceeds the amount of space available in the existing memory segment(s).",{"@attributes":{"id":"p-0037","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Memory Segment Table"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Memory Segment",{},"Physical Memory"]},{"entry":["Name","Size","Starting Address"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Segment 1","250,000,000","50,000,000"]},{"entry":["Segment 2","500,000,000","475,000,000"]},{"entry":["Segment 3","1,000,000,000","2,300,000,000"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Similarly, one or more pages may be stored in each memory segment.",{"@attributes":{"id":"p-0039","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Page Table"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"49pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"Physical",{},"Physical"]},{"entry":[{},{},"Name of","Memory","Offset from","Memory"]},{"entry":[{},{},"Memory","Starting","Beginning of","Address of"]},{"entry":[{},"Size of","Segment Page","Address of","Segment to","first byte of"]},{"entry":["Page Name","Page","is Stored In","segment","Page","column\/page"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"6","colwidth":"49pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Column_1_Page_1","50,000","Segment_1","50,000,000","0","50,000,000"]},{"entry":["Column_2_Page_2","75,000","Segment_1","50,000,000","50,001","50,050,001"]},{"entry":["Column_1_Page_3","150,000","Segment_1","50,000,000","125,000","50,125,001"]},{"entry":". . ."},{"entry":["Column_1_Page_4000","500,000","Segment_3","2,300,000,000","1,000","2,300,001,000"]},{"entry":["Column_2_Page_4001","750,000","Segment_3","2,300,000,000","501,000","2,30,501,000"]},{"entry":["Column_3_Page_4002","600,000","Segment_3","2,300,000,000","12,501,000","2,312,501,000"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}}},"For purposes of illustration, the above page table contains more information than is actually necessary, The only information that needs to be specified in a page number table is, for each page, an offset into memory for the beginning memory address of the page. It is a matter of choice as to whether this offset refers to an absolute physical memory address, or to the offset from the beginning of the particular memory segment in which the page is stored. If the latter, then each time a beginning page address is retrieved from the page table, the beginning physical address of the memory segment must be added to it to yield the beginning physical memory address for the page. As noted above there can thereafter be added to this number the product of the target row number and width of the table\/column to yield the physical first bye address of the target row.","Those of skill in the art will further appreciate that the page tables are transient. Specifically, the page tables may be re-created when a database is opened.","In addition, information of the same type (i.e., one or more columns of a table) may be stored in multiple pages, and these pages may be located in discontiguous memory segments. As compared to prior systems requiring contiguous memory, this allows space for new rows to be allocated, without requiring all pre-existing rows to be moved to a different memory segment.","Thus, in the example shown above, to calculate the physical memory address for a particular row of a given column which begins with the 399byte of the page Column2_Page4001, one would sum 2,300,000,000 (beginning address of the Segment3), 12,501,000, and 399 to yield 2,312,501,399.","Those of skill in the art will appreciate that memory segment tables and pages will typically include some header information, so the first byte of data will not necessarily be the first byte of the memory allocated for the page. However, the size of the header can either be a predetermined amount, or be stored in a predetermined byte offset from the first byte of the page file.","One design consideration involves the number of rows that should be allocated for on the first page. One method for doing this is to default to some number, say 512. Another method is to allow the application requesting the creating of a table (or column) to specify an estimated maximum number of rows the database will hold, and divide this number by four, and round up to next highest power of two. For example, if a table with 400,000 rows is estimated, the initial page may have 65,536 rows. Seven pages would yield 458,752 rows for the estimated 400,000-row requirement.","Those of skill in the art of network databases will appreciate that several characteristics of a network database well-known in the art are inherent. For example, when a row of data is deleted, prior and subsequent rows are not ordinarily shifted to occupy the same physical memory space of the deleted data. Instead, the availability of the memory space formerly occupied by the deleted data is noted by either a reference in the header of the page or, for example, by inserting null values in the space. Moreover, when data is inserted into a row, its pointers to related rows of other tables are updated at the time consistent with the database schema.","In another aspect of the invention, the database system interfaces with software application(s) that access database information. The system maintains a master copy of each page table. As a part of the interface, the database system maintains a version number for each page table, and provides copies of the page tables to the applications. This allows the applications to calculate physical addresses for information without having to access shared memory, which can be slower. This increases the speed with which information may be retrieved from the database. Moreover, if a change to the database schema (data dictionary) is made, the version number of the master copy is incremented. Before an application attempts to access database information, it checks to see whether the version number of its copy of a page table matches that in the master copy. If they are different, then the application's page table copy is refreshed. This technique allows changes to be made to the database schema while applications access the database information, i.e., the database does not need to be closed.","The database system of the present invention maintains a data dictionary maintains a version number that increments each time a change is made to the schema (data dictionary). However, those of skill in the art will appreciate that changes to application data\u2014inserts, updates, deletes\u2014do not change the data dictionary. The primary access routines (the API) may resolve certain data structure addresses and keep them in local application data space. The next time a resource must be accessed, the application checks the data dictionary version number to see if it has changed. If this version number has not changed, then the local copies of the data structure addresses may be used. If this version number has changed, then the local copies of these addresses must be re-calculated. Address caching recovers the performance lost due to page-table lookups. In one embodiment, all of this activity is managed totally transparently to the applications using the database.","In one embodiment, the invention also includes a backup facility that continuously copies database modifications into persistent (disk) storage or to remote memory structures. This facility is accomplished using a multi-layered copy facility that protects against any single point of failure and is transparent and non-intrusive to the applications using the invention. In one embodiment, the database will be \u201cout-of-service\u201d for less than 1 millisecond when the backup occurs regardless of the size of the total database.","In one embodiment, the backup event can be triggered in one of three ways.\n\n","System Services: In one embodiment, a collection of database services is incorporated into the invention such as the following:\n\n","In one embodiment, the server uses the TCP\/IP networking protocol to manage remote requests. A single \u201clisten\u201d socket is used for all requests. When a connection is made to the server, a new execution thread is created (multi-threading) to service the request. New services may be added at any time (online) using shared library dynamic linking. Multi-threading is used to take advantage of modern multiprocessor computers where separate threads actually execute simultaneously.","Lock Granularity: Another feature of the database system is a lock management facility based on spinlock technology. Spinlocks represent the highest performance mechanism used to control access to shared resources. The database system provides a multi-dimensional locking feature called lock domains. Access to database resources from multiple applications involves special considerations to avoid common pitfalls associated with shared structures. As used herein, \u201cdatabase resources\u201d means data stored in the database. These problems include:\n\n","To update a table, an application needs to have \u201cread\u201d access to the data dictionary and \u201cwrite\u201d access to the columns of the table to be updated. Multiple read-locks are allowed on a single resource but a write-lock must block all other readers and writers. For example, suppose App1 needs to update Table1 and App2 needs to update Table2. No blocking action is needed. They may both read-lock the data dictionary and write-lock the separate columns to be updated.","Now suppose App1 wishes to read from Table2-Col1 and Col2. App2 wishes to update (write) Table2-Col3 based on what it finds (reads) in Col2. Even though both applications are accessing Table2, the write-lock on Col3 from App2 does not conflict with the any of the read-locks form App1. Here again, these two applications will not block.","Spinlocks are used to manage these lock domains for performance reasons. When a blocking action is needed, the operating system services are required to suspend one of the applications (threads). This facility is relatively slow compared to the database's performance parameters. For this reason, these services should be avoided unless it is absolutely necessary. A spinlock is used to mark a resource as locked. If the lock is released before any other thread tries to access the resource, the block is avoided and no operating system services are needed.","Double Linked Lists: One embodiment of the database includes software to manage one to many relationships using double-linked list structures. Inserts and deletes are supported at any point in the list. Linked list traversal is fast. This technology is an effective tool for managing non-contiguous data. The concept of double linked lists in the invention has been extended to incorporate the ability to dynamically modify the database logical structure definition that is embodied in the linked lists. Linked lists are the preferred method of addressing data when the information structure is time base or sequentially related. This is the fastest way to traverse a data set of this type.","Balanced Binary Trees: One embodiment of the database may implement sorted \u201cKeys\u201d using a balanced binary tree indexing scheme. The index tree is re-balanced with every insert or delete. Lookups use this index to provide guaranteed worst case times proportional to LOG(N) (where N represents the number of rows in the table). This results in a very gradual decline in performance with size. The approach to balanced binary tree indexing used in the system may follow the red\/black model of Sedgwick (\u201cAlgorithms in C++\u201d, Sedgwick). The algorithms described by Sedgwick may be adapted to permit dynamic modification of a database logical structure definition. Binary tree structures are the preferred approach when the lookup function is a random search in large database.","It will be appreciate by those of skill in the art that various terms, such as a database \u201cstorage area\u201d or a database \u201cresource,\u201d as used in the, claims refers to a logical data structure or software, respectively, as may be defined, for example, by software used to implement the invention. While such software could be executing on a computer, it is the intent that the claims also embody software that has not yet been installed on a computer. For example, the storage \u201carea\u201d and \u201cmemory pages\u201d can all be defined in software.","Source code for implementing aspects of the invention is shown in the Appendix 1. This includes the structure for the header of the shared memory segment table. The first entry in the database (shared memory segment 0) is the \u201cMagic\u201d number. This is an arbitrary binary value used to identify a valid database. The current value is 3500094376. The \u201cVersion\u201d number starts at 1 (one) and is incremented whenever a change is made to the database header. This would include adding a new memory segment to the database of adding new pages to the Heap. The \u201cShmMax\u201d value is taken from the license file and defines the maximum number of shared memory segments. This number never exceeds 256. The \u201cShmInuse\u201d value identifies the cu rent number of shared memory segments. The \u201cSessionMax\u201d value is taken from the license file and defines the maximum number of database connections allowed. This might be \u22121 (minus one) which indicates an unlimited number of connections. The \u201cSessionInuse\u201d value identifies the current number of connected sessions. The \u201cLocale\u201d string defines the current native language locale. This value is used to establish international character sort order. The \u201cHeapPgTb1Inuse\u201d defines the number of entries in the Heap data page table. The \u201cHeapPgTb1Shift\u201d defines the Heap data page table initial shift property. The initial number of entries per page (Heap page 0) is defined as 2 raised to the HeapPgTb1Shift power. The default value is 8. The initial default entries per page is 256. The \u201cHeapPgTb1\u201d consists of 64 page table entries for the Heap data pages. This represents a maximum of 32 million heap entries. Each heap entry represents a minimum of 1 kilobyte and a maximum of 2 terabytes. The \u201cResFCP\u201d defines the start location (byte offset from the beginning of segment 0) of the reserved FCPs.","Appendix 1 also shows header information for the page tables (or Field Control Properties\/FCP). The user defined FCP entries follow the reserved FCP entries. Each user defined data type represents a database field (column or a database link). User defined fields are assigned integer unit numbers starting with one and growing as needed to the maximum allowed fields of 2^31 (two raised to the 31 power) \u02dc2 billion. Reserved FCP entries are assigned negative unit numbers starting with \u22121.","Unit number 0 is associated with the Key field that holds the database table and column names. This Key is searched to associate table and column names with field unit numbers.","The four address resolver entries (in the ResAdd structure) provide the necessary structure to convert a row number into a physical address.","A representative API for allowing a database system of the present invention to interface with applications is shown in Appendix 2.",{"@attributes":{"id":"p-0065","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"left"}},"thead":{"row":[{"entry":"APPENDIX 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ ----- atdb_p.h ------"},{"entry":"\/\/"},{"entry":"\/\/ Private data structures used in ATDB."},{"entry":"\/\/ Including:"},{"entry":"\/\/ \u2003Database header"},{"entry":"\/\/ \u2003FC_PROPS (field control properties) in the data dictionary."},{"entry":"\/\/ \u2003\u2003\u2003(similar to FIELD_PROPS in atdb.h but not the same.)"},{"entry":"\/\/ \u2003Preferences (used at startup)"},{"entry":"\/\/ \u2003Internal typedefs . . ."},{"entry":"\/\/"},{"entry":"#ifndef ATDB_P_INCLUDED"},{"entry":"#define ATDB_P_INCLUDED 1"},{"entry":"#ifndef NULL"},{"entry":"#define NULL (void *)0"},{"entry":"#endif"},{"entry":"#include <stdlib.h>"},{"entry":"#include \u201catdb.h\u201d"},{"entry":"#include \u201cshmlib.h\u201d"},{"entry":"\/\/ Spinlock target"},{"entry":"typedef struct {"},{"entry":"\u2002U32\u2003lock ;\u2003\u2002\/\/ \u201ctest & set\u201d operates on this"},{"entry":"\u2002U32\u2003count ;\u2003\/\/ Read lock count ;"},{"entry":"\u2002U32\u2003collisions ; \/\/ unnecessary"},{"entry":"\u2002U32\u2003flags ;\u2002\u2009\/\/ special"},{"entry":"} ATDB_SPIN_t, *pATDB_SPIN_t ;"},{"entry":"#define EXTEND_PENDING 0x1\u2003\/\/ flag bit used by atdb_extend_table( )"},{"entry":"#include \u201cPLAT_P.h\u201d"},{"entry":"\/\/ What \u201cENDIAN\u201d are we - should be defined in <stdlib.h> via endian.h"},{"entry":"\/\/ \u2003(otherwise hard code _BYTE_ORDER in PLAT_P.h)"},{"entry":"#ifndef _BYTE_ORDER"},{"entry":"#error \u201cNeed to define _BYTE_ORDER\u201d"},{"entry":"#endif"},{"entry":"#if_BYTE_ORDER == _BIG_ENDIAN"},{"entry":"#define ATDB_BIGENDIAN"},{"entry":"#endif"},{"entry":"#define ATDB_MAGIC 0xd09f33a8 \/\/ Whatever?"},{"entry":"#define COMPERROR 0x8fffffff"},{"entry":"#define MKMOD(N,MOD) (((N)+(MOD)\u22121) & (~((MOD)\u22121)))"},{"entry":"\/\/-------------- The Private database structure definition --------"},{"entry":"typedef struct {"},{"entry":"\u2002pSHMOBJ_t *shm ; \/\/ Array of shared memory objects (license file issue)"},{"entry":"\u2002I32 ShmInuse ;\u2003\/\/ How many are there (compare to hdr->ShmInuse)"},{"entry":"\u2002I32 ShmMax ;\u2003\u2002\/\/ How many shm are allowed (compare to hdr->ShmMax)"},{"entry":"\u2002I32 err ;"},{"entry":"} ATDB_t, *pATDB_t ;"},{"entry":"\/\/ Define the minimum page allocation unit (Currently 1K)"},{"entry":"#define HEAPSHIFT 10"},{"entry":"#define HEAPUNIT (1<<HEAPSHIFT)"},{"entry":"\/\/ --------------Create Database Preferences -------------"},{"entry":"typedef struct {"},{"entry":"\u2002U32 DBSize ;\u2003\u2002\/\/ Requested database size k bytes (default = 20480K)"},{"entry":"\u2002U32 NumFields ;\u2002\/\/ Total number of entries in Names. (default 255)"},{"entry":"\u2002U32 HeapMax ;\u2003\u2009\/\/ Requested number of entries in Heap (default NumFields * 64)"},{"entry":"\u2002U32 SessionMax ; \/\/ Maximum number of threads connected to database (default 500)"},{"entry":"\u2002char *Locale;\u2003\/\/ Database locale (default current locale)"},{"entry":"\u2002char *DBName ;\u2003\/\/ Database name"},{"entry":"} ATDB_PREFS_t, *pATDB_PREFS_t ;"},{"entry":"\/\/ The heap page table located in DD at hdr->HeapPgTbl"},{"entry":"typedef struct {"},{"entry":"\u2002U32 seg ; \/\/ shared memory segment #"},{"entry":"\u2002U32 loc ; \/\/ offset to page in HEAPUNITs"},{"entry":"} HEAP_PGTBL_t, *pHEAP_PGTBL_t ;"},{"entry":"\/\/ Shared memory segment definition"},{"entry":"typedef struct {"},{"entry":"\u2002U32 size ; \/\/ HEAPUNITS"},{"entry":"} SHM_SEGS_t, *pSHM_SEGS_t ;"},{"entry":"\/\/ ------------ ATDB Header structure (first data in mem segment) ------------"},{"entry":"\/\/ ResFCP also = size of low memory"},{"entry":"\/\/ The first entry in HI memory is the reserved FCPs"},{"entry":"\/\/"},{"entry":"typedef struct {"},{"entry":"\u2002U32 Magic ;\u2003\u2003\u2003\u2003\u2003\u2003\/\/ IDs this segment as a valid ATDB database"},{"entry":"\u2002U32 Version ;\u2003\u2003\u2003\u2003\u2003\u2003\/\/ Data dictionary version number."},{"entry":"\u2002U32 ShmMax ;\u2003\u2003\u2003\u2003\u2003\u2003\/\/ Maximum allowed shared memory segments this database (license"},{"entry":"issue)"},{"entry":"\u2002U32 ShmInuse ;\u2003\u2003\u2003\u2003\u2003\u2002\u2009\/\/ Shared memory segments currently active"},{"entry":"\u2002U32 SessionMax ;\u2003\u2003\u2003\u2003\u2003\u2009\/\/ Maximum number of sessions (license issue)"},{"entry":"\u2002U32 SessionInuse ;\u2003\u2003\u2003\u2003\u2002\u2002\/\/ Sessions currently active"},{"entry":"\u2002U8 Locale[64] ;\u2003\u2003\u2003\u2003\u2003\u2002\u2009\/\/ Database locale ID"},{"entry":"\u2002U32 HeapPgTblInuse ;\u2003\u2003\u2003\u2002\u2009\/\/ InUse entries in the heap page table"},{"entry":"\u2002U32 HeapPgTblShift ;\u2003\u2003\u2003\u2002\u2009\/\/ Heap base epp == 1<<base-shift"},{"entry":"\u2002HEAP_PGTBL_t HeapPgTbl[64] ; \/\/ Heap Data Page table (hardcode 64??)"},{"entry":"\u2002U32 ResFCP ;\u2003\u2003\u2003\u2003\u2002\u2009\/\/ Byte offset to the reserved FCP table."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002\/\/ Freespace = ResFCP \u2212 sizeof(ATDB_HDR_t)"},{"entry":"} ATDB_HDR_t , *pATDB_HDR_t ; \/\/\u2003412 = 1024 \u2212 612"},{"entry":"\/\/ Session table"},{"entry":"typedef struct {"},{"entry":"\u2002U32 fill[4] ;"},{"entry":"} SES_TBL_t, *pSES_TBL_t ;"},{"entry":"#define ATDB_RFCP\u2003\u2003\u2003\u2003\u200332 \/\/ How many reserved FCPs"},{"entry":"#define ATDB_FCP_UNIT\u2003\u2003\u2003\u2003\u2003\u22121"},{"entry":"#define ATDB_HEAP_UNIT\u2003\u2003\u2003\u2003\u2002\u22122"},{"entry":"#define ATDB_OWNS_UNIT\u2003\u2003\u2003\u2003\u2002\u22123"},{"entry":"#define ATDB_POINTS_UNIT\u2003\u2003\u2003\u2003\u22124"},{"entry":"#define ATDB_TRANS_CACHE_UNIT\u2003\u22125"},{"entry":"#define ATDB_STRUCT_UNIT\u2003\u2003\u2009\u22126"},{"entry":"#define ATDB_STMEMB_UMIT\u2003\u2003\u2009\u2002\u22127"},{"entry":"\/\/ ResAdd (resolve address) needs this struct to do its job"},{"entry":"typedef struct {"},{"entry":"\u2002void **add ; \/\/ Array of page start addresses"},{"entry":"\u2002U32 pages ;\u2002\u2009\/\/ How many pages"},{"entry":"\u2002U32 bsh ;\u2003\/\/ Base shift (might be 0) Base epp = 1<<bsh"},{"entry":"\u2002U32 width ;\u2002\u2009\/\/ width of entry (bytes) ;"},{"entry":"} RESADD_t, *pRESADD_t ;"},{"entry":"\/\/------------- Field Control Properties --------------------"},{"entry":"typedef struct {"},{"entry":"\u2002ATDB_SPIN_t spin ; \/\/ Lock structure (Keep on 16 byte boundary for HP)"},{"entry":"\u2002U32 Version ;\u2003\u2002\/\/ change requires refresh_fp"},{"entry":"\u2002I32 type ;\u2003\u2003\/\/ Type of field (0 = deleted field)"},{"entry":"\u2002I32 lock ;\u2003\u2003\/\/ Lock struct to use"},{"entry":"\u2002I32 fmt ;\u2003\u2003\u2009\/\/ Data format"},{"entry":"\u2002I64 depth ;\u2003\u2003\/\/ Max rowID (Huge!!!)"},{"entry":"\u2002I32 width ;\u2003\u2003\/\/ width in bytes"},{"entry":"\u2002I32 UID ;\u2003\u2003\u2002\u2009\/\/ User ID"},{"entry":"\u2002I32 GID ;\u2003\u2003\u2002\u2009\/\/ Group ID"},{"entry":"\u2002I32 Permissions ; \/\/ Permission bits rwxrwxrwx"},{"entry":"\u2002I32 owner ;\u2003\u2003\/\/ Table unit number"},{"entry":"\u2002I32 point ;\u2003\u2003\/\/ Foreign key unit number"},{"entry":"\u2002I32 Data ;\u2003\u2003\u2002\/\/ Heap entry of first Data Page Table"},{"entry":"\u2002I32 VData ;\u2003\u2003\u2002\/\/ Heap entry of first VData Page Table"},{"entry":"\u2002I32 Index ;\u2003\u2003\u2002\/\/ Heap entry of first Index Page Table"},{"entry":"\u2002I32 Head ;\u2003\u2003\u2002\u2009\/\/ Heap entry of first LL Head Page Table"},{"entry":"\u2002I32 fill[4] ;\u2003\u2002\/\/ Currently FCP is 96 bytes (16-byte aligned)"},{"entry":"} FC_PROPS_t, *pFC_PROPS_t ;"},{"entry":"\/*------------ Private version of Field Property Page ----------------------*\/"},{"entry":"typedef struct ST_FP_THIS {"},{"entry":"\u2003\u2003\u2003\u2002I32 unit ;\u2003\u2003\u2003\/\/ Unit number for this field (index into Names)"},{"entry":"\u2003\u2003\u2003\u2002U32 type ;\u2003\u2003\u2003\/\/ Type of field"},{"entry":"\u2003\u2003\u2003\u2002U32 fmt ;\u2003\u2003\u2003\/\/ Data Type"},{"entry":"\u2003\u2003\u2003\u2002U32 width ;\u2003\u2003\u2003\/\/ Length in bytes for Data (if any)"},{"entry":"\u2003\u2003\u2003\u2002U64 depth ;\u2003\u2003\u2003\/\/ Max RowID"},{"entry":"\u2003\u2003\u2003\u2002I64 row ;\u2003\u2003\u2003\/\/ row (pos)"},{"entry":"\u2003\u2003\u2003\u2002I64 orow ;\u2003\u2003\u2003\u2002\/\/ owner row (opos)"},{"entry":"\u2003\u2003\u2003\u2002I32 owner ;\u2003\u2003\u2003\u2009\/\/ Unit number of owner (Table?)"},{"entry":"\u2003\u2003\u2003\u2002I32 point ;\u2003\u2003\u2003\/\/ Unit number of foreign field"},{"entry":"\u2003\u2003\u2003\u2002U32 fnum ;\u2003\u2003\u2003\u2003\/\/ The function that caused the error"},{"entry":"\u2003\u2003\u2003\u2002I32 err ;\u2003\u2003\u2003\u2002\/\/ Error code"},{"entry":"\u2003\u2003\u2003\u2002U32 bufsz ;\u2003\u2003\u2002\/\/ The actual (malloc) size of buf"},{"entry":"\u2003\u2003\u2003\u2002void *buf ;\u2003\u2003\u2002\/\/ user data"},{"entry":"\/*-------------- The rest is hidden -----------------*\/"},{"entry":"\u2003\u2003\u2003\u2002pATDB_OBJ_t db ;\u2003\u2002\/\/ The database object"},{"entry":"\u2003\u2003\u2003\u2002U32 *pVersion ;\u2003\u2003\/\/ Points to version number in FCP"},{"entry":"\u2003\u2003\u2003\u2002U32 Version ;\u2003\u2003\/\/ Last known version number - compare to pVersion"},{"entry":"\u2003\u2003\u2003\u2002I32 lockstat ;\u2003\u2002\/\/ Is it Read or Write locked"},{"entry":"\u2003\u2003\u2003\u2002void *lock ;\u2003\u2003\/\/ Pointer to lock entry"},{"entry":"\u2003\u2003\u2003\u2002pRESADD_t pRA_Data ; \/\/ Pointer to Data address resolver"},{"entry":"\u2003\u2003\u2003\u2002pRESADD_t pRA_VData ; \/\/ Pointer to VData address resolver"},{"entry":"\u2003\u2003\u2003\u2002pRESADD_t pRA_Index ; \/\/ Pointer to Index address resolver"},{"entry":"\u2003\u2003\u2003\u2002pRESADD_t pRA_Head ; \/\/ Pointer to Head address resolver"},{"entry":"\u2003\u2003\u2003\u2002I32\u2003(*Compare)(struct ST_FP_THIS *fp,U32 row) ; \/\/ Compare for this format & type"},{"entry":"\u2003\u2003\u2003\u2002I32\u2003(*Insert) (struct ST_FP_THIS *fp) ;"},{"entry":"\u2003\u2003\u2003\u2002I32\u2003(*Delete) (struct ST_FP_THIS *fp) ; \/\/ The access functions depend on properties"},{"entry":"\u2003\u2003\u2003\u2002I32\u2003(*Find) (struct ST_FP_THIS *fp) ;"},{"entry":"\u2003\u2003\u2003\u2002I32\u2003(*Get) (struct ST_FP_THIS *fp) ;"},{"entry":"\u2003\u2003\u2003\u2002I32\u2003(*Put) (struct ST_FP_THIS *fp) ;"},{"entry":"\u2003\u2003\u2003\u2002I32\u2003(*Next) (struct ST_FP_THIS *fp) ;"},{"entry":"\u2003\u2003\u2003\u2002I32\u2003(*Pre) (struct ST_FP_THIS *fp) ;"},{"entry":"} FIELD_PROPS_t, *pFIELD_PROPS_t ;"},{"entry":"typedef struct {"},{"entry":"\u2003\u2003\u2003\u2002U32 seg ;\u2003\/\/ Segment number (4 billion!!?)"},{"entry":"\u2003\u2003\u2003\u2002I32 size ; \/\/ size (HEAPUNITS), negative size means inuse"},{"entry":"\u2003\u2003\u2003\u2002U32 loc ;\u2003\/\/ offset in segment (HEAPUNITS) . . . Actual offset = (UXX)loc << HEAPSHIFT"},{"entry":"\u2003\u2003\u2003\u2002U32 next ;\u2003\/\/ heapent for next loc"},{"entry":"\u2003\u2003\u2003\u2002U32 pre ;\u2003\/\/ heapent for pre loc"},{"entry":"\u2003\u2003\u2003\u2002U32 fnext ; \/\/ The next heap entry in the field page table."},{"entry":"} HEAP_NODE_t, *pHEAP_NODE_t ;"},{"entry":"#define ATFMT_HEAP 17"},{"entry":"\/\/ HEAP_TRAN_t used in heap transaction processing."},{"entry":"typedef struct {"},{"entry":"\u2002pFIELD_PROPS_t fpheap ;"},{"entry":"\u2002U32 *list ;"},{"entry":"\u2002U32 sz ;"},{"entry":"\u2002U32 count ;"},{"entry":"} HEAP_TRAN_t, *pHEAP_TRAN_t ;"},{"entry":"\/\/ Red black tree node. Three of these makes an index row"},{"entry":"typedef struct {"},{"entry":"#ifdef ATDB_BIGENDIAN"},{"entry":"\u2003\u2003\u2003\u2002U32 red:1 ;"},{"entry":"\u2003\u2003\u2003\u2002U32 row:31 ;"},{"entry":"#else"},{"entry":"\u2003\u2003\u2003\u2002U32 row:31 ;"},{"entry":"\u2003\u2003\u2003\u2002U32 red:1 ;"},{"entry":"#endif"},{"entry":"}BT_NODE_t, *pBT_NODE_t ;"},{"entry":"#define LEFT 0"},{"entry":"#define RIGHT 1"},{"entry":"#define PARENT 2"},{"entry":"#define NEXT 0"},{"entry":"#define PRE 1"},{"entry":"\/\/ Linked List Node"},{"entry":"typedef struct {"},{"entry":"\u2002U32 next ;"},{"entry":"\u2002U32 pre ;"},{"entry":"} LL_NODE_t, *pLL_NODE_t ;"},{"entry":"\/\/---------------- Paging struct used by atdb_page_parts( ) --------------------"},{"entry":"typedef struct {"},{"entry":"\u2002U64 depth ;"},{"entry":"\u2002U64 epp ;"},{"entry":"\u2002U64 mask ;"},{"entry":"\u2002U64 totN ;"},{"entry":"\u2002U32 width ;"},{"entry":"\u2002U32 shift ;"},{"entry":"\u2002U32 pgsz ;"},{"entry":"\u2002U32 pages ;"},{"entry":"} PAGE_PARTS_t, *pPAGE_PARTS_t ;"},{"entry":"\/\/ page dependent page parts"},{"entry":"typedef struct {"},{"entry":"\u2002U64 epp ;"},{"entry":"\u2002U32 bsh ;"},{"entry":"\u2002U32 width ;"},{"entry":"\u2002U32 pgsz ;"},{"entry":"\u2002U32 pg ;"},{"entry":"} THIS_PAGE_t, *pTHIS_PAGE_t ;"},{"entry":"\/\/--------------- Bin table used for vdata"},{"entry":"typedef struct {"},{"entry":"\u2002LL_NODE_t tab[65] ; \/\/ bins 0 . . . 63 + the wilderness"},{"entry":"\u2002U32 pages ;\u2003\u2003\u2003\/\/ pages allocated (= next page #)"},{"entry":"} BINTAB_t, *pBINTAB_t ;"},{"entry":"\/\/--------------- CData inuse blocks have this header"},{"entry":"typedef struct {"},{"entry":"\u2002U32 chunk:15 ; \/\/ Size of this block in chunks"},{"entry":"\u2002U32 pba:1 ;\u2003\/\/ The previous block is free"},{"entry":"\u2002U32 size:16 ;\u2003\/\/ Actual bytes used for user data (first bit allways 0)"},{"entry":"} INUSE_BLOCK_t, *pINUSE_BLOCK_t ;"},{"entry":"#ifdef _cplusplus"},{"entry":"extern \u201cC\u201d {"},{"entry":"#endif"},{"entry":"I32 atdb_create_database(pATDB_PREFS_t) ;"},{"entry":"\/\/ Heap Management Routines"},{"entry":"I32 atdb_heap_alloc(pFIELD_PROPS_t,U32 size) ; \/\/ Returns HeapEnt (row) (or - err)"},{"entry":"I32 atdb_heap_free(pFIELD_PROPS_t,U32 HeapEnt) ;"},{"entry":"I32 atdb_compare_heapent(pFIELD_PROPS_t fp, U32 row) ;"},{"entry":"I32 bt_build_index(pFIELD_PROPS_t) ;"},{"entry":"I32 atdb_compare_ATFMT_U8(pFIELD_PROPS_t fp,U32 width) ;"},{"entry":"I32 atdb_VCompare(pFIELD_PROPS_t fp,U32 width) ;"},{"entry":"pFPROPS_t atdb_new_fp(pATDB_t) ;"},{"entry":"pFC_PROPS_t atdb_get_fcp(pATDB_t db,I32 unit) ;"},{"entry":"pHEAP_TRAN_t atdb_start_heap_transaction(pATDB_t db) ;"},{"entry":"I32 bt_inuse(pFIELD_PROPS_t) ;"},{"entry":"I32 atdb_ll_inuse(pFIELD_PROPS_t) ;"},{"entry":"I32 atdb_drop_unit(pATDB_t db,I32 unit) ;"},{"entry":"void atdb_page_parts(pPAGE_PARTS_t) ;"},{"entry":"void atdb_this_page(pTHIS_PAGE_t) ;"},{"entry":"I32 atdb_vget(pFIELD_PROPS_t) ;"},{"entry":"I32 atdb_vupdate(pFIELD_PROPS_t) ;"},{"entry":"I32 atdb_fget(pFIELD_PROPS_t) ;"},{"entry":"I32 atdb_fput(pFIELD_PROPS_t) ;"},{"entry":"I32 atdb_fkey_put(pFIELD_PROPS_t) ;"},{"entry":"\/\/ insert key"},{"entry":"I32 bt_insert(pFIELD_PROPS_t) ;"},{"entry":"\/\/delete key"},{"entry":"I32 bt_delete(pFIELD_PROPS_t) ;"},{"entry":"\/\/ find key"},{"entry":"I32 bt_find(pFIELD_PROPS_t) ;"},{"entry":"\/\/ inuse (key)"},{"entry":"I32 bt_inuse(pFIELD_PROPS_t) ;"},{"entry":"\/\/ get (key)"},{"entry":"I32 bt_get(pFIELD_PROPS_t) ;"},{"entry":"\/\/ next on key"},{"entry":"I32 bt_next(pFIELD_PROPS_t) ;"},{"entry":"\/\/ pre on key"},{"entry":"I32 bt_pre(pFIELD_PROPS_t) ;"},{"entry":"\/\/ Link List insert"},{"entry":"I32 atdb_ll_insert(pFIELD_PROPS_t) ;"},{"entry":"\/\/ Link List delete"},{"entry":"I32 atdb_ll_delete(pFIELD_PROPS_t) ;"},{"entry":"\/\/ Link List next"},{"entry":"I32 atdb_ll_next(pFIELD_PROPS_t) ;"},{"entry":"\/\/ Link List pre"},{"entry":"I32 atdb_ll_pre(pFIELD_PROPS_t) ;"},{"entry":"\/\/ Link List link"},{"entry":"I32 atdb_ll_link(pFIELD_PROPS_t) ;"},{"entry":"\/\/ Link List inuse"},{"entry":"I32 atdb_ll_inuse(pFIELD_PROPS_t) ;"},{"entry":"#include \u201cbsrl.h\u201d"},{"entry":"static _inlinevoid *ResAdd(U32 row,pRESADD_t ra)"},{"entry":"{"},{"entry":"\u2002U32 pg, sh ;"},{"entry":"\u2002U32 mask ;"},{"entry":"\u2002void *add ;"},{"entry":"\u2002sh = bsrl(row | (1 << (ra->bsh+2))) \u22122 ;"},{"entry":"\u2002mask = (1 << sh) \u2212 1 ;"},{"entry":"\u2002pg = (row >> sh) + ((sh \u2212 ra->bsh) << 2) ;"},{"entry":"\u2002add = ra->add[pg] ;"},{"entry":"\u2002add += (UXX)(row & mask) * (UXX)ra->width ;"},{"entry":"\u2002return(add) ;"},{"entry":"}"},{"entry":"void *ResHeapAdd(pFIELD_PROPS_t fp_heap,U32 heapent) ;"},{"entry":"typedef struct {"},{"entry":"\u2002U8 m:3 ; \/\/ For e=0, size = m*2"},{"entry":"\u2002U8 e:3 ; \/\/ For e>0, size = (m+8)<<e"},{"entry":"} SZ_TAG_t , *pSZ_TAG_t ;"},{"entry":"#ifdef ATDB_LOCK"},{"entry":"\/\/ Multi lock structures"},{"entry":"typedef struct {"},{"entry":"\u2002pFIELD_PROPS_t fp ;"},{"entry":"\u2002I32 (*Lock)(pFIELD_PROPS_t,U32 *) ;"},{"entry":"} MLCK_t , *pMLCK_t ;"},{"entry":"typedef struct {"},{"entry":"\u2002U32 count ;"},{"entry":"\u2002U32 inuse ;"},{"entry":"\u2002pMLCK_t fpa ; \/\/ array of MLOCK_t structs"},{"entry":"}MULTI_LOCK_t, *pMULTI_LOCK_t ;"},{"entry":"\/\/ MLOCK_t is void * in atdb.h"},{"entry":"\/\/ Spinlock stuff"},{"entry":"#define WRITE_LOCKED 0xffffffff"},{"entry":"#ifdef SMP"},{"entry":"#define smp_machine 1"},{"entry":"#else"},{"entry":"#define smp_machine 0"},{"entry":"#endif"},{"entry":"static void SpinLock(pATDB_SPIN_t spin)"},{"entry":"{"},{"entry":"\u2003\u2003\u2003\u2002int ntries = 0;"},{"entry":"\u2003\u2003\u2003\u2002while(SpinTrylock(spin)) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003spin->collisions++ ;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003ntries=0;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003while(SpinIsLocked(spin)) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002if (smp_machine && ntries++ < MAX_BUSY_LOOPS) continue;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ntries=0;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002yield_cpu( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2002}"},{"entry":"}"},{"entry":"static void SpinReadLock(pATDB_SPIN_t spin)"},{"entry":"{"},{"entry":"\u2003\u2003\u2003\u2002int ntries = 0;"},{"entry":"\u2003\u2003\u2003\u2002while(1) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003SpinLock(spin);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003if ((spin->count {circumflex over (\u2009)} WRITE_LOCKED) != 0) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002spin->count++;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002SpinUnlock(spin);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002return;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003spin->collisions++ ;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003SpinUnlock(spin);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003ntries=0;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003while(spin->count {circumflex over (\u2009)} WRITE_LOCKED) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002if (smp_machine && ntries++ < MAX_BUSY_LOOPS) continue;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ntries = 0;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002yield_cpu( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2002}"},{"entry":"}"},{"entry":"static void SpinWriteLock(pATDB_SPIN_t spin)"},{"entry":"{"},{"entry":"\u2003\u2003\u2003\u2002int ntries ;"},{"entry":"\u2003\u2003\u2003\u2002while(1) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003SpinLock(spin);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (spin->count == 0) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002spin->count = WRITE_LOCKED;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002SpinUnlock(spin);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002return;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003spin->collisions++ ;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003SpinUnlock(spin);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003ntries = 0 ;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003while(spin->count != 0) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002if (smp_machine && ntries++ < MAX_BUSY_LOOPS) continue;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ntries = 0;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002yield_cpu( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2002}"},{"entry":"}"},{"entry":"static void SpinWriteUnlock(pATDB_SPIN_t spin)"},{"entry":"{"},{"entry":"\u2003\u2003\u2003\u2002SpinLock(spin);"},{"entry":"\u2003\u2003\u2003\u2002spin->count = 0;"},{"entry":"\u2003\u2003\u2003\u2002SpinUnlock(spin);"},{"entry":"}"},{"entry":"static void SpinReadUnlock(pATDB_SPIN_t spin)"},{"entry":"{"},{"entry":"\u2003\u2003\u2003\u2002SpinLock(spin);"},{"entry":"\u2003\u2003\u2003\u2002spin->count--;"},{"entry":"\u2003\u2003\u2003\u2002SpinUnlock(spin);"},{"entry":"}"},{"entry":"static _inlineI32 ReadLock(pFIELD_PROPS_t fp, U32 *mylock)"},{"entry":"{"},{"entry":"\u2002if (fp->lockstat) {"},{"entry":"\u2003*mylock = 0 ;"},{"entry":"\u2003return(0) ;"},{"entry":"\u2002}"},{"entry":"\u2002SpinReadLock(fp->lock) ;"},{"entry":"\u2002*mylock = 1 ;"},{"entry":"\u2002fp->lockstat = 1 ;"},{"entry":"\u2002return(0) ;"},{"entry":"}"},{"entry":"static _inlineI32 WriteLock(pFIELD_PROPS_t fp, U32 *mylock)"},{"entry":"{"},{"entry":"\u2002if (fp->lockstat) {"},{"entry":"\u2003\u2002if (fp->lockstat == 1) return(fp->err = ATE_LOCK) ; \/\/ It's read locked!"},{"entry":"\u2003\u2002*mylock = 0 ;"},{"entry":"\u2003\u2002return(0) ;"},{"entry":"\u2002}"},{"entry":"\u2002SpinWriteLock(fp->lock) ;"},{"entry":"\u2002*mylock = 2 ;"},{"entry":"\u2002fp->lockstat = 2 ;"},{"entry":"\u2002return(0) ;"},{"entry":"}"},{"entry":"static _inlineI32 UnLock(pFIELD_PROPS_t fp, U32 *mylock)"},{"entry":"{"},{"entry":"\u2002if (!*mylock) return(0) ;"},{"entry":"\u2002if (fp->lockstat == 1) SpinReadUnlock(fp->lock) ;"},{"entry":"\u2002if (fp->lockstat == 2) SpinWriteUnlock(fp->lock) ;"},{"entry":"\u2002fp->lockstat = 0 ;"},{"entry":"\u2002*mylock = 0 ;"},{"entry":"\u2002return(0) ;"},{"entry":"}"},{"entry":"#endif \/\/ ATDB_LOCK"},{"entry":"#ifdef _cplusplus"},{"entry":"}"},{"entry":"#endif"},{"entry":"#endif \/\/ ATDB_P_INCLUDED"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Utilities","The utilities are standalone programs that implement one or more of the ATDB library functions.\n\n","Synopsis:\n\n","Note: The dbadmin utility may also be used to establish a new database.","atwh\u2014print database usage statistics",{"@attributes":{"id":"p-0069","num":"0000"},"ul":{"@attributes":{"id":"ul0012","list-style":"none"},"li":["synopsis\u201d atwh [dbname]","atwh displays size (depth) and % full values for each table (primary field) in the database. It also displays the shared memory usage and the heap entries usage values."]}},"The default database name is provided in the environment variable ATDB_HANDLE. This may be overridden using a single runstring parameter that indicates the fully qualified database handle file name.\n\n","Synopsis: drop_database <dbnane>\n\n","Synopsis: save_database <filename>\n\n","Synopsis: restore_database <filename>\n\n","(Note: an Enhanced Version is Planned that Will Combine Multiple Memory Segments into a Single Segment.)\n\n","Synopsis: add_segment <size [kKmMgGtT]>\n\n","Synopsis: extend_table <tablename>[newdepth|X]\n\n","Synopsis: dbadmin <schema_file |-\u201csingle command\u201d>","The dbadmin utility is used to create a new database, add to an existing database, or shutdown an existing database. The commands are normally taken from a schema file; however, if the first runstring parameter is a dash (-) than the next parameter will be accepted as a single command. The following commands are allowed in the schema file.",{"@attributes":{"id":"p-0079","num":"0129"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CREATE DATABASE"]},{"entry":[{},"DROP DATABASE"]},{"entry":[{},"OPEN DATABASE"]},{"entry":[{},"CREATE TABLE"]},{"entry":[{},"EXTEND DATABASE"]},{"entry":[{},"EXTEND TABLE"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"ul":{"@attributes":{"id":"ul0020","list-style":"none"},"li":"rdmbuild\u2014database emulation build utility"}},"Synopsis: rdmbuild <old schema file>|<-\u201csingle command\u201d>\n\n","These commands create fields in the ATDB data dictionary. The first character of each attribute may be used. e.g. n=ccc rather than name=ccc.","The width and depth parameters may be omitted or set to 0 (zero). A zero width is interpreted as a variable width flag, as in varchar. Keep in mind that variable width may be applied to any format type (int, float, etc).","A zero depth parameter may be used and will establish 8 Kbytes for the initial data page size. This will establish an initial depth of something like 8192\/width. (For varchar, width will be 4 bytes).\n\n","Synopsis: crkey <KeyName>[Howmany]","This is a simple wrapper for atdb_create_field( ) to create a key in $ATDB_HANDEL database. The default depth is 1000000 rows. The first runstring parameter is the Key field name. It may be a simple string (no dot). The second (optional) parameter sets the number of rows in the Key.\n\n","Synopsis: crll <ListName><Howmany><OwnerKey>","This utility creates an item-linked-list in database TESTDB.","Assorted Benchmark Utilities","A collection of stand alone benchmark utilities are provided including:",{"@attributes":{"id":"p-0089","num":"0144"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"tinsert <keyname> <rows> - add rows to key or linked list"},{"entry":"tfind <keyname> <howmany> - lookup <howmany> random rows"},{"entry":"in <keyname>"},{"entry":"tget <keyname> <howmany> - directly fetch <howmany> random rows"},{"entry":"from column"},{"entry":"tnext <colname> <howmany> - walk in sort orded <howmany> rows"},{"entry":"from <colname>"},{"entry":"tdelins <colname> <howmany> - randomly delete and"},{"entry":"re-insert <howmany> rows."},{"entry":"Pdd - print the data dictionary for TESTDB"},{"entry":"pheap - print the heap entries for TESTDB"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The ATDB runtime library is provided as a statically linked library (libatdb.a) and a shared library (libatdb.so). Data structure definitions are located in the include file atdb.h. A platform dependent include file (PLAT.h) is referenced by atdb.h. The following routines are found in libatdb.a.\n\n",{"@attributes":{"id":"p-0091","num":"0147"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Synopsis:\u2003\u2003\u2003\u2003pATDB_STR_t atdb_new_str( ) ;"]},{"entry":[{},"\u2003\u2003\u2003\u2003void atdb_free_str(pATDB_STR_t st) ;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0092","num":"0148"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"pATDB_STR_t st ;"]},{"entry":[{},"st = atdb_new_str( ) ;"]},{"entry":[{},"free_atdb_str(st) ;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The string object (st) is used to dynamically manage thread safe string parameters. It is used in the atdb_getenv() and atdb_err() functions. The string is stable until the next call that uses the object.\n\n","Synopsis: char *atdb_getenv(const char *tag, pATDB_STR_t st)","The environment variable of interest is supplied (tag) and is not modified (assumed constant). If found, a new string is allocated that is large enough to hold the assigned value and added to the ATDB_STR t object. The char * part of this object is the return value of this function. This string (returned value) is stable until the next call to a function using the ATDB_STR_t object or until atdb_free_str is called.\n\n","Synopsis: char *atdb_err(pFPROPS_t fp, pATDB_STR_t st)","The return value is a printable string of the form:\n\n","Synopsis: pATDB_OBJ t atdb_open(char *dbname, U32 how)\n\n","On success, the routine returns a database object (opaque void *) value.","On failure, a NULL is returned and errno is set to indicate the system error code.\n\n",{"@attributes":{"id":"p-0101","num":"0163"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"pATDB_STR_t st ;"]},{"entry":[{},"pATDB_OBJ_t db ;"]},{"entry":[{},"st = atdb_new_str( ) ;"]},{"entry":[{},"db = atdb_open(atdb_getenv(\u201cATDB_HANDLE\u201d,0) ;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0032","list-style":"none"},"li":"atdb_close\u2014disconnect from an open database"}},"Synopsis: atdb_close(pATDB_OBJ_t db)","Disconnect from the database (db) and free the memory used by the object.\n\n","Synopsis: pFPROPS_t atdb_new_field(pATDB OBJ_t db, char *fname)\n\n","Returns: a newly allocated and initialized FPROPS_t structure pointer.\n\n","Like atdb_new_field( ) but requires a unit number rather than a field name.\n\n","Synopsis: void atdb_free fp(pFPROPS_t)","Frees all memory allocated for the FPROPS_t structure.\n\n","Synopsis: I32 atdb11_insert(pFPROPS_t)","The data buffer must be supplied.","If the format is variable width, the width parameter must be supplied.","For Linked List field types, the owner row (orow) is required.","If row=0, the element is added at the beginning of the list. If row=\u22121, the element is added at the end of the list. Otherwise the element is added after the given row.\n\n","Deletes element from field (column). For Key field types, the data buffer must be supplied. For Linked List field types, the row and owner row (orow) must be supplied.\n\n","Synopsis: I32 atdb_find(pFPROPS_t fp)","A fast search is performed using Key field index. The data buffer is required. If the format is variable width, the width parameter (fp->width) must be supplied.","If the datum is not found, fp->row points to the row that is (lexically) next larger than the supplied buffer.\n\n","Synopsis: I32 atdb_get(pFPROPS_t fp)","Retrieve element from column given the row. For variable width format fields, the width is returned and might be 0 (NULL).\n\n","Synopsis: I32 atdb_put(pFPROPS_t)","Copy the given datum (fp->buf) at the given roe (fp->row). If format is variable width, the width parameter is required and may be 0 (NULL).\n\n","Synopsis: I32 atdb_next(pFPROPS_t fp)","The list is initialized by setting row (fp->row) to 0.","For Key types, the list is traversed in ascending (low to high) sort order.","For Linked List types, the list is traversed in FIFO (first in-first out) order.\n\n","Synopsis: I32 atdb11_pre(pFPROPS_t fp)","The list is initialized by setting row to 0.","For Key types, the list is traversed in descending (high to low) sort order.","For Linked List types, the list is traversed in LIFO (last in-first out) order.\n\n","Synopsis: I32 atdb11_inuse(pFPROPS_t)\n\n","Synopsis: I32 atdb_type(pPROPS_t)\n\n","Synopsis: I32 atdb_fmt(pFPROPS_t)\n\n","Synopsis: I32 atdb_width(pFPROPS_t)","Note: For variable width fields, 0 is returned.\n\n","Synopsis: I64 atdb_depth(pFPROPS_t)","Note: returns a 64-bit depth.\n\n","Synopsis: I32 atdb_lock(pFPROPS_t, U32 how)","Lock a field for reading (find, next, pre, get) (how ATDB_READLOCK) or writing (insert, delete, put) (how=ATDB_WRITELOCK). The field remains locked until atdb_unlock( ) is called.","Only one field may be locked at a time using this routine. Any attempt to lock another field will fail. If more than one field must be locked, use atdb_multilock( ).\n\n","Synopsis: I32 atdb_unlock(pFPROPS_t)\n\n","Synopsis: pMULTI_LOCK_t atdb_new_multi_lock(pATDB_OBJ_t db);\n\n","Synopsis: I32 atdb_multi_lock_prepare(pMULTI_LOCK_t ml, pFPROPS_t fp, U32 opt)","This routine allows many fields to be simultaneously locked. The first call to this routine must supply a NULL MULTI_LOCK_t pointer. The field object is required. The option parameter (opt) is either ATDB_READLOCK or ATDB_WRITELOCK. The actual lock is performed by atdb_multi_lock( )\n\n","Synopsis: I32 atdb_multi_lock(pMULTI_LOCK_t ml)","This routine locks all of the fields associated with the MULTI_LOCK_t object (ml). Deadlocks are avoided by locking all fields in sort order. If a collision (locked field) occurs, this routine will wait (hang) until the collision is removed (unlocked).\n\n","Synopsis: I32 atdb_multi_unlock(pMULTI_LOCK_t ml)\n\n","void atdb_free_multi_lock(pMULTI_LOCK_t ml);","Utility Library Routines",{"@attributes":{"id":"p-0148","num":"0000"},"ul":{"@attributes":{"id":"ul0056","list-style":"none"},"li":"randx\u2014random number generator (thread safe)"}},{"@attributes":{"id":"p-0149","num":"0238"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Synopsis:\u2003\u2003\u2003\u2003void *new_randx(int seed) ;"]},{"entry":[{},"\u2003\u2003\u2003\u2003U32 randx(void *rn) ;"]},{"entry":[{},"\u2003\u2003\u2003\u2003void free_randx(void *rn) ;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"ul":{"@attributes":{"id":"ul0057","list-style":"none"},"li":"xtimer\u2014measure time interval in microseconds."}},{"@attributes":{"id":"p-0150","num":"0240"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Synopsis:\u2003\u2003\u2003\u2003void *new_xtimer( ) ;"]},{"entry":[{},"\u2003\u2003\u2003\u2003void reset_xtimer(void *tm) ;"]},{"entry":[{},"\u2003\u2003\u2003\u2003U32 xtimer(void *tm) ;"]},{"entry":[{},"\u2003\u2003\u2003\u2003free_xtimer(void *tm) ;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":{"@attributes":{"id":"p-0013","num":"0017"},"figref":"FIG. 1"}},"DETDESC":[{},{}]}
