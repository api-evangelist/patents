---
title: Managing topology changes in media applications
abstract: Systems and methods for resolving a partial topology are disclosed. In one embodiment a media engine includes a topology loader module that receives a partial topology from another module associated with the media engine. The topology loader implements logic operations that convert a partial topology into a full topology, which may be returned to the media engine for presentation of the media stream(s) to a user.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07577940&OS=07577940&RS=07577940
owner: Microsoft Corporation
number: 07577940
owner_city: Redmond
owner_country: US
publication_date: 20040308
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION"],"p":["The described subject matter relates to electronic computing, and more particularly to systems and methods for managing topology changes in media applications.","Media content has traditionally been distributed using equipment and protocols that are application-specific, and in some cases proprietary. For example, video content has traditionally been encoded in an analog format and distributed over television networks, cable networks, satellite networks, and video cassette tapes. Special purpose capture and transmission devices are required to generate the content. Similarly, special purpose receivers and display devices are required to access the content.","The widespread digitization of media (including multimedia) content, especially by the consumer segment, coupled with the growth in digital communication networks and easier methods to transfer digital content is changing the nature of media content delivery and usage. Media content can now be captured and encoded in one or more of a plurality of digital formats (e.g., MPEG, Windows Media Format, VCD, etc.) distributed over digital networks such as the Internet or on digital media and accessed using general purpose computing equipment or special purpose equipment.","Digital computing devices play a central role in digital media production, encoding, distribution, and display. Microsoft Corporation of Redmond, Wash., USA, has developed a set of technologies to facilitate the use of digital media and the integration of digital media processing components (both hardware and software) with personal computers. MICROSOFT DIRECTSHOW is a digital media streaming architecture designed for digital audio, video and other types of digital data. DIRECTSHOW provides a high-level application model that enables independent hardware vendors (IHVs) and independent software vendors (ISVs) to develop streaming media applications that combine and use components from possibly different vendors and run on computers using the WINDOWS brand operating system.","Additional infrastructure to facilitate the integration of digital media components is desirable to facilitate continued development in the digital media marketplace and to increase the flexibility that users and developers have to create innovative uses of those components.","Implementations described herein provide systems and methods for managing topology changes in media applications. In an exemplary implementation, a method for managing topology changes in media applications is provided. The method comprises receiving a partial media topology that includes a plurality of nodes including at least a first media source node and at least a first media sink node; retrieving a cached media topology that includes a plurality of nodes including at least a second media source node, at least a second media sink node, and at least one transform node; and copying one or more nodes from the cached media topology to the partial media topology.","In another exemplary implementation, a system is provided. The system comprises one or more computer-readable media; and a media engine embodied on the one or more computer-readable media and configured to communicatively interact with an application to present a media presentation. The media engine is configured to use a media session to generate a partial topology, the partial topology including one or more media sources individual ones of which serving as a source of media content, and one or more media sinks configured to sink a media stream, and a topology loader to resolve the partial topology into a full topology. The topology loader is configured to copy one or more nodes from a cached media topology to the partial media topology.","In another exemplary implementation, one or more computer-readable media comprising computer executable instructions are provided. When executed on a computer, the instructions direct the computer to receive a partial media topology that includes a plurality of nodes including at least a first media source node and at least a first media sink node; retrieve a cached media topology that includes a plurality of nodes including at least a second media source node, at least a second media sink node, and at least one transform node; and copy one or more nodes from the cached media topology to the partial media topology.","In another exemplary implementation, a topology loader module is provided. The topology loader module comprises computer executable instructions that, when executed by a computer, provide means for receiving a partial media topology that includes a plurality of nodes including at least a first media source node and at least a first media sink node; means for retrieving a cached media topology that includes a plurality of nodes including at least a second media source node, at least a second media sink node, and at least one transform node; and means for copying one or more nodes from the cached media topology to the partial media topology.","Described herein are exemplary storage network architectures and methods for managing topology changes in media applications. The methods described herein may be embodied as logic instructions on a computer-readable medium. When executed on a processor, the logic instructions cause a general purpose computing device to be programmed as a special-purpose machine that implements the described methods. The processor, when configured by the logic instructions to execute the methods recited herein, constitutes structure for performing the described methods.","Exemplary Environment",{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 1","FIG. 6"],"b":["100","102","102","102","102","102"]},"The computer  may obtain a variety of media from a variety of media sources. For example, the computer  may locally store a plurality of media (), . . . , (), . . . , (K). The plurality of media ()-(K) may include an assortment of audio and video content having various formats. Further, the media ()-(K) may be obtained from a variety of sources, such as from an input device, from execution of an application, and so on.","The computer , for instance, may include a plurality of applications (), . . . , (), . . . , (N). One or more of the plurality of applications ()-(N) may be executed to provide media, such as documents, spreadsheets, video, audio, and so on. Additionally, one or more of the plurality of applications ()-(N) may be configured to provide media interaction, such as encoding, editing, and\/or playback of the media ()-(K).","The computer  may also include a plurality of input devices (), . . . , (), . . . , (M). One or more of the plurality of input devices ()-(M) may be configured to provide media for input to the computer . Input device (), for instance, is illustrated as a microphone that is configured to provide an input of audio data, such as a voice of the user, a song at a concert, and so on. The plurality of input devices ()-(M) may also be configured for interaction by a user to provide inputs that control execution of the plurality of applications ()-(N). For example, input device () may be utilized to input voice commands from the user, such as to initiate execution of a particular one of the plurality of applications ()-(N), control execution of the plurality of applications ()-(N), and so forth. In another example, input device () is illustrated as a keyboard that is configured to provide inputs to control the computer , such as to adjust the settings of the computer .","Further, the computer  may include a plurality of output devices (), . . . , (), . . . , (J). The output devices ()-(J) may be configured to render media ()-(K) for output to the user. For instance, output device () is illustrated as a speaker for rendering audio data. Output device () is illustrated as a display device, such as a television, that is configured to render audio and\/or video data. Thus, one or more of the plurality of media ()-(K) may be provided by the input devices ()-(M) and stored locally by the computer . Although the plurality of input and output devices ()-(M), ()-(J) are illustrated separately, one or more of the input and output devices ()-(M), ()-(J) may be combined into a single device, such as a television having buttons for input, a display device, and a speaker.","The computer  may also be configured to communicate over a network  to obtain media that is available remotely over the network . The network  is illustrated as the Internet, and may include a variety of other networks, such as an intranet, a wired or wireless telephone network, a broadcast network, and other wide area networks. A remote computer  is communicatively coupled to the network  such that the remote computer  may provide media to the computer . For example, the remote computer  may include one or more applications and a video camera  that provides media, such as home movies. The remote computer  may also include an output device to output media, such as the display device  as illustrated. The media obtained by the computer  from the remote computer  over the network  may be stored locally with the media ()-(K). In other words, media ()-(K) may include locally stored copies of media obtained from the remote computer  over the network .","Thus, the computer  may obtain and store a plurality of media ()-(K) that may be provided both locally (e.g., through execution of the plurality of applications ()-(N) and\/or use of the plurality of input device ()-(M)), and remotely from the remote computer  (e.g., through execution of application and\/or use of input devices). Although the plurality of media ()-(K) has been described as stored on the computer , the media ()-(K) may also be provided in \u201creal-time\u201d. For example, audio data may be streamed from the input device (), which is illustrated as a microphone, without storing the audio data.","The computer  includes a timeline generator  that, when executed on the computer , generates a media timeline . For example, the timeline generator  may be configured as an application that exposes one or more software components that may be used to generate the media timeline , such as through a user interface by a user. As previously described, the media timeline  provides a technique for a user to define a presentation of stored and\/or real-time media from the plurality of media sources. For example, the media timeline  may describe a collection of media that was obtained from the input devices ()-(M), the applications ()-(N), and\/or the remote computer . The user may utilize one or more of the input devices ()-(M) to interact with the timeline generator  to define groupings and\/or combinations of the media ()-(K). The user may also define an order and effects for presentation of the media ()-(K). A timeline source  may then be executed on the computer  to render the media timeline . The media timeline , when rendered, provides the expressed groupings and\/or combinations of the media ()-(K) for rendering by one or more of the plurality of output devices ()-(J). Additionally, the timeline generator  may also programmatically generate the media timeline  as is described in greater detail in the following implementation.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 2","FIG. 1"],"b":["200","200","202","204","206","204","206","206","206","104","1","104","106","1","106","108","1","108","110","1","100"],"i":["g","g","g","g"]},"The application , which may be the same as or different from applications ()-(N) of , interacts with a media engine  to control the media ()-(K). In at least some embodiments, the media engine  serves as a central focal point of the application  that desires to somehow participate in a presentation. A presentation, as used in this document, refers to or describes the handling of media. In the illustrated and described embodiment, a presentation is used to describe the format of the data on which the media engine  is to perform an operation. Thus, a presentation can result in visually and\/or audibly presenting media, such as a multimedia presentation in which both audio and accompanying video is presented to user within a window rendered on a display device, such as output device () of  that is illustrated as a display device that may be associated with a desk-top PC. A presentation can also result in writing media content to a computer-readable medium such as a disk file. Thus, a presentation is not limited to scenarios in which multimedia content is rendered on a computer. In some embodiments, operations such as decoding, encoding and various transforms (such as transitions, effects and the like), can take place as a result of a presentation.","In an embodiment, the media foundation  exposes one or more application program interfaces that can be called by the application  to interact with the media (). For example, the media foundation  may be thought of as existing at an \u201cinfrastructure\u201d level of software that is executed on the computer  of . In other words, the media foundation  is a software layer used by the application  to interact with the media (). The media foundation  may be utilized to control a number of aspects of the media (), such as output, rendering, storage, and so on. Thus, the media foundation  may be utilized such that each application  does not have to implement separate code for each type of media () that may be used in the system . In this way, the media foundation  provides a set of reusable software components to do media specific tasks.","The media foundation  may utilize several components among which include the media timeline , the timeline source , a media source , a media processor , a media session , the media engine , a source resolver , one or more transforms , one or more media sinks , , and so on. One advantage of various illustrated and described embodiments is that the system  is a pluggable model in the sense that a variety of different kinds of components can be utilized in connection with the systems described herein. Also included as a part of system  is a destination , which is discussed in more detail below. In at least one embodiment, however, the destination  is an object that defines where a presentation is to be presented (e.g. a window, disk file, and the like) and what happens to the presentation. That is, the destination may correspond to one or more of the media sinks ,  into which data flows.","The media timeline  employs a timeline object model which provides a way for a user to define a presentation based on media that is rendered by the timeline source . The media timeline  may range from a sequential list of media files to more complex forms. For example, the media timeline  may employ file structures, such as SMIL (Synchronized Multimedia Integration Language) and AAF (Advanced Authoring Format), to express media playback experiences that include transitions between media, effects, and so on. The application , for instance, may be configured as a media player that can play a list of songs, which is commonly referred to as a playlist. As another example, in an editing system a user may overlay one video over the other, clip a media, add effect to the media and so forth. Such groupings or combinations of media may be expressed using the media timeline .","The media source  is utilized to abstract a provider of media. The media source , for instance, may be configured to read a particular type of media from a particular source. For example, one type of media source might capture video from the outside world (a camera), and another might capture audio (a microphone). Alternately or additionally, the media source  may read a compressed data stream from disk and separate the data stream into its compressed video and compressed audio components. Yet another media source  might obtain data from the network  of . Thus, the media source  may be utilized to provide a consistent interface to acquire media.","The media source  provides one or more media presentation  objects (media presentation). The media presentation  abstracts a description of a related set of media streams. For example, the media presentation  may provide a paired audio and video stream for a movie. Additionally, the media presentation  may describe the configuration of the media source  at a given point in time. The media presentation , for instance, may contain information about the media source  including descriptions of the available streams of the media source  and their media types, e.g. audio, video, MPEG, and so on.","The media source  may also provide a media stream  object (media stream) which may represent a single stream from the media source  which can be accessed by the application , i.e. exposed to the application . The media stream  thus allows the application  to retrieve samples of the media ().","In the media foundation , therefore, the media source  is defined as a software component which outputs samples for a presentation. The timeline source  interprets the media timeline , but at the same time, may also act in a manner similar to the media source . For example, the timeline source  may be utilized to hide the intricacies of rendering the media timeline  to provide media described by the media timeline  from other components of the media foundation .","The media processor  manages data flow in a topology . The topology  defines how data flows through various components for a given presentation. A \u201cfull\u201d topology includes each of the components, e.g. software modules, used to manipulate the data such that the data flows with the correct format conversions between different components. When a topology is created, the user might choose to create it partially. This partial topology is not sufficient, by itself, to provide a final presentation. Therefore, a component called the topology loader  may take the partial topology and convert it into a full topology by adding the appropriate data conversion transforms between the components in the partial topology.","In the topology , for example, data generally originates at the media source , flows through one or more transforms , and proceeds into one or more media sinks , . Transforms  can include any suitable data handling components that are typically used in presentations. Such components can include those that uncompress compressed data and\/or operate on data in some way, such as by imparting an effect to the data, as will be appreciated by the skilled artisan. For example, for video data, transforms can include those that affect brightness, color conversion, and resizing. For audio data, transforms can include those that affect reverberation and re-sampling. Additionally, decoding and encoding can be considered as transforms.","Media sinks ,  are typically associated with a particular type of media content. Thus, audio content might have an associated audio sink such as an audio renderer. Likewise, video content might have an associated video sink such as a video renderer. Additional media sinks can send data to such things as computer-readable media, e.g. a disk file and the like.","The media session  is a component which may schedule multiple presentations. Therefore, the media processor  may be used to drive a given presentation, and the media session  utilized to schedule multiple presentations. The media session , for instance, may change topologies that are rendered by the media processor . For example, the media session  may change from a first topology that is rendered on the media processor  to a second topology such that there is no gap between the renderings of samples from the consecutive presentations that are described by the respective topologies. Thus, the media session  may provide a seamless user experience as the playback of the media moves from one presentation to another.","The source resolver  component may be utilized to create a media source  from URLs and\/or byte stream objects. The source resolver  may provide both synchronous and asynchronous ways of creating the media source  without requiring prior knowledge about the form of data product by the specified resource.","In at least one embodiment, the media foundation  is utilized to abstract away the specific details of the existence of and interactions between various components of the media foundation . That is, in some embodiments, the components that are seen to reside inside the media foundation  are not visible, in a programmatic sense, to the application . This permits the media foundation  to execute so-called \u201cblack box\u201d sessions. For example, the media engine  can interact with the media session  by providing the media session certain data, such as information associated with the media (e.g. a URL) and the destination , and can forward the application's  commands (e.g. open, start, stop and the like) to the media session . The media session  then takes the provided information and creates an appropriate presentation using the appropriate destination.","The media foundation  may also include a timeline plugin . The timeline plugin  may be utilized such that different media timeline file formats may be \u201cplugged-in\u201d to the media foundation . For example, a bytestream plugin  may be written for a format in question and registered with the media foundation . The source resolver  may then invoke a bytestream plugin  when a file of that type is opened. In turn the bytestream plugin  can parse the file, create a media timeline  representing the presentation described in the file, and create a timeline source  for it. In general, the bytestream plugin  is responsible for reading the raw bytestream and creating a media source  for it. In an implementation, the remaining components of media foundation  are not made aware that the media source created in this instance is a timeline source . Therefore, the timeline source  is treated like any other media source . In an implementation, a bytestream plugin  that can parse a media timeline  and create a timeline source  is referred to as a timeline plugin.","The timeline plugin  may also provide an interface such that the application  may interact with the timeline plugin directly, such as to load and save the media timeline  from or to a file. For example, the timeline plugin  may be created and then called to initiate a load function to provide a bytestream. The timeline plugin  may then parse the file and create a root node and any additional nodes to create the media timeline . The timeline plugin  may also be used to persist the media timeline  to different formats. For example, the application  may create the media timeline  programmatically. In other words, the application may act as the timeline generator  of . The application  may then create a timeline plugin for ASX (Advanced Stream Redirector) files, and ask the timeline plugin to save the media timeline  in the ASX format. In another example, a user can open an m3u file, i.e. a playlist file format for specifying multiple MP3 files, get the media timeline  from it, and then ask the timeline plugin to save the media timeline  in the ASX format. In this way, the media foundation  may expose a plurality of software components that provide media functionality over an application programming interface for use by the application .","Given the description of the system of , the discussion that follows provides a general overview of a typical multimedia scenario, along with a description of the roles that the media engine  and media session  plays in driving the presentation. In the discussion that follows, each of the media engine (and its role) and media session (and its role) are discussed in sections under their own respective headings\u2014i.e., \u201cMedia Engine Work\u201d and \u201cMedia Session Work\u201d.","Media Engine Work","In accordance with one embodiment, the work that the media engine  performs during a presentation can be categorized, generally, under a number of different headings which appear below. The categories of media engine work include source resolution, setting up the media session, partial topology resolution, topology resolution and activation, presentation control, new presentations, and output changes.","Source Resolution","Source resolution pertains to the process by which the media engine  causes the appropriate media source to be created for the particular type of data that is to be read and subsequently processed by the system. Thus, this process obtains a media source from which the multimedia data can be read. This process is relevant when, for example, the OpenURL or OpenByteStream methods (discussed above and below) are called to open the multimedia. In either case, the media engine  passes the URL or the Byte Stream, respectively, to a component known as a source resolver. If the source resolver is given a URL, then it looks at the scheme of the URL (e.g., file:\/\/, http:\/\/, etc) to create a Byte Stream that will read from the specified location.","In both cases, the source resolver is able to look at the contents of the Byte Stream to determine the format of the bits (e.g., ASF, AVI, MPECA etc) so that a media source can be instantiated that will understand that format. The other Open functions discussed above and below specify the media source directly.","Setting up the Media Session","During this process, the media engine asks the media source that is created for a presentation descriptor. In some embodiments, the presentation descriptor may specify that a custom media session is to be used. In many cases, however, custom media sessions may not be used in which case a default media session can be instantiated.","Partial Topology Creation","During partial topology creation, the media engine  obtains a presentation descriptor from the media source(s)  and notifies the application  of that particular presentation via the event MENewPresentation. If the application is interested in using that event to configure a destination, the media engine  waits for the application to finish handling the event.","The media engine  then negotiates with the application-provided destination and the destination can create one or more media sinks for the outputs of the presentation. In some embodiments, media sinks ,  can have already been created and the destination simply hands them over to the media engine.","The media engine  invokes the media processor  to constructs a \u201cpartial topology\u201d that the media engine indicates the source media streams and the output stream sinks, without necessarily specifying the transforms that will be needed to get there. Thus, referring to the  illustration, at this point in the process, the media engine  has created a partial topology, a media processor  and a media session. Media engine has instantiated or referenced one or more media source(s)  and media sink(s) , .","An exemplary partial topology is depicted in . Referring to , a partial topology  specifies an audio source node  and an audio render node , a video source node  and a video render node .","Full Topology Resolution","In performing the topology resolution process, the media session  can invoke a component referred to herein as a topology loader . The topology loader  implements logic instructions to determine which transforms  are necessary or desirable to provide the data from the media source(s)  to the media sink(s) , .","Transforms  can comprise any suitable data handling components that are typically used in presentations. Such components can include those that uncompress compressed data, and\/or compressed uncompressed data, and\/or operate on data in some way, such as by imparting an effect to the data, as will be appreciated by the skilled artisan. For example, for video data, transforms can include those that affect brightness, color conversion, and resizing. For audio data, transforms can include those that affect reverberation and resampling. Additionally, decoding and encoding can be considered as transforms.","An exemplary full topology is depicted in . Referring to , a full topology specifies an audio source node , an audio decoder , a resampler  and an audio render node . The full topology further comprises a video source node , a video decoder , a color converter , and a video render node .","Topology loader  and its operations are described in detail herein.","Topology Resolution and Activation","In accordance with one embodiment, during topology resolution and activation, the media engine  asks the media session  to resolve the partial topology into a fully specified topology. The media engine  then sets the new fully-specified topology on the media session , which gives it to the media processor . As an example, consider that the media source that is created is one that reads a compressed WMV file. The sinks, on the other hand, are not configured to handle compressed data. Thus, during topology resolution, the media session ascertains which transforms are necessary to provide the compressed data from the WMV file to the sinks and creates the appropriate transforms which, in this case, might comprise a decompressor and possibly resizers, color converters, resamplers, and the like.","In another embodiment, resolution and activation can be combined into a single operation. Specifically, the media engine  can set a partial topology on the media session  and the media session itself can resolve the partial topology into a fully-specified topology which it then provides to the media processor .","Media Processor Creation","The media session  is responsible for creating the media processor . That is, the media session  owns the media processor . When the topology is set on the media session , the media session , in turn, sets the topology on the media processor . The media processor  follows the data flow laid out by the topology to transform data from the media source(s)  to the particular formats that are needed by the media sink(s) , .","Time Source Selection","One of the functions that the media session  can perform pertains to time source selection. Specifically, upon starting a presentation, the media session  can make a determination as to which of the available time sources will be used to drive the presentation. Each component can then run its part of the presentation in synchronization with the time from the time source ascertained by the media session. The time source is also used in the presentation clock (owned by the media engine but given to the media session) for the purposes of reporting progress of the presentation.","Media sinks, such as sinks ,  may optionally offer a time source. Typically, the audio renderer (i.e., audio sink) can offer a time source, and the time on the time source will be dictated by the audio device on the particular machine on which the presentation is presented. It is to be appreciated, however, that other media sinks may do so as well. In addition, a particular media source, e.g., live media sources such as device capture and network sources, may also provide some concept of time. In one embodiment, the media session takes care of attempting to make the time source it chooses run at a similar rate to that of the live media source. In one embodiment, the media session  can decide which of the time sources is the \u201chighest priority\u201d time source, and this time source is used by the main presentation clock, to which all clock-aware components synchronize their presentations.","Presentation Control","As noted above, the media session  can receive method calls to Start, Stop, and Pause from the media engine . These calls typically correspond to the applications calls that are made on the media engine .","The media session  can control the presentation via a Presentation Clock that it receives from the media engine . Starting, stopping and\/or pausing the Presentation Clock results in all media sink(s) ,  receiving notifications thereof and reacting appropriately. The media session  starts, stops, and\/or pauses the media processor  by respectively calling its start, stop, and\/or pause methods directly.","The media session  is configured, in this embodiment, to send an event to the media engine  after a given operation has been completed by all streams.","New Presentations and Output Changes","In accordance with this embodiment, media session  is responsible for forwarding media processor's  notification of an upcoming new presentation to media engine  and participating with topology resolution and activation, as described above in connection with the media engine.","Time Line Processing","In accordance with one embodiment, media session  is configured to reduce glitches at presentation startup time and when transitioning between presentations in a timeline.","In accordance with this embodiment, at startup time, media session  will get the first few samples of media data from media processor  and deliver them to the media sinks ,  before starting the clock associated with the presentation. This process uses a special \u201cprerolling\u201d capability on the media sinks that allows the media sinks to receive data before actually being started. In this embodiment, it is only after the media sinks receive data via the pre-rolling capability that media session  will start the presentation clock.","Because the media sinks ,  have already received the initial data of the data stream, the chances that the media sinks will fall behind (i.e. referred to as a \u201cglitch\u201d) at the beginning of the presentation are greatly reduced if not eliminated all together. This can effectively provide for a generally seamless presentation start.","At presentation transition boundaries (i.e. when changing from one presentation to another), media session  is configured to attempt to make the transition seamless, i.e. without interruption between the end of the first presentation and the beginning of the second. In accordance with this embodiment, the media session  accomplishes this by applying some logic to ensure that the \u201cseamless stream\u201d plays continuously throughout the transition, without waiting for other streams in the presentation to complete (which may cause a glitch during the transition).","Content Protection","In accordance with one embodiment, system  and more generally, systems that employ a media session component as described in this document, can employ techniques to ensure that media content that is the subject of a presentation is protected in accordance with rights that may be associated with the content. This concept is also referred to by some as \u201cdigital rights management\u201d.","Specifically, certain multimedia content may have specific rights associated with it. For example, the content provider may wish to restrict playback of this content to the use of only known, trusted transforms, media sinks and other components. Accordingly, content protection information associated with the media content may, but need not then be embedded in the content as will be appreciated by the skilled artisan. In accordance with this embodiment, media session  is configured to respect any content protection requirements by validating all of the components that are being inserted into the pipeline and by making sure that the components are allowed and will be performing allowed actions on the content. Validation can take place by any suitable measures. For example, in validating the component, the media session can then validate the component's signature, and that the signing authority is a trusted authority.","In accordance with one embodiment, the media session  can create a protected media path for such content. The protected media path is configured to make it very difficult if not impossible for unauthorized third parties to intercept the data flowing through the pipeline.","Desired Media Engine Configuration","One of the more common scenarios in which the above-described systems and methods can be employed pertains to setting up a simple playback of a multimedia presentation. From the application's point of view, it is desirable for the application to be able to accomplish the following steps in order to configure a multimedia presentation. The application should be able to create a media engine and a playback or presentation destination. The application should also be able to provide a handle to the presentation destination, e.g., a window in which a video for the presentation should be rendered. The application should also be able to call IMFMediaEngine::OpenURL, to supply a URL to the multimedia file to be presented, as well as a pointer to the playback destination. With these capabilities, the application can now cause the media presentation to be played back by using the IMFMediaEngine::Start\/Stop\/Pause APIs. In one embodiment, the application does not need to wait for any events to arrive as handing of these events are optional. In another embodiment, the application does handle events from the media engine for the open operation to complete.","Exemplary Topology Loader","In an exemplary implementation topology loader  implements methods for converting a partial topology generated by the media processor  into a full topology. As used herein, the term \u201cfull topology\u201d refers to a topology in which all the requisite intermediate transforms are in the topology, all the input and output media types have been set on every object in the topology, and all the source nodes in the topology are ready to run. When the topology loader  is finished, the full topology may be processed by the media processor .","In an exemplary implementation the topology loader  is a public object, in that it is intended that it will be used by an end-user to find fully specified topologies. By way of overview, a client invokes the topology loader  by calling a load method and providing a partial topology. The topology loader  enumerates all the source nodes in the partial topology and places these nodes into a queue. This queue is then processed node by node to connect each node to its outputs. The internal nodes in the partial topology are added to the queue if and only if all their input connections have been have been resolved. This ensures that the topology loader  does not try to configure the outputs of a component before configuring all of its inputs.","For every partial connection the topology loader  is trying to connect, the outputs of a node are connected to the inputs of a downstream node. If one or more of the nodes are compressed, then intermediate nodes to decompress the stream may be inserted.","Features and operations of an exemplary implementation of a topology loader  are described herein.","External Interfaces and Methods","In an exemplary implementation topology loader  provides a plurality of interfaces that may be called by an external process such as, e.g., the media session  to invoke functions of the topology loader. The following description of exemplary interfaces and accompanying methods are provided by way of disclosure.",{"@attributes":{"id":"p-0092","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"IMFTopoLoader Interface"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003interface IMFTopoLoader : IUnknown"},{"entry":"\u2003\u2003{\u2003 HRESULT"},{"entry":"SetTopologyCallback(IMFTopologyConnectionCallback* pTopoCallback,"},{"entry":"DWORD dwFlags );"},{"entry":"\u2003\u2003\u2003\u2002 HRESULT \u2003\u2003SetPreferredSampleDuration( \u2003\u2003LONGLONG"},{"entry":"\u2003llSampleDuration );"},{"entry":"\u2003\u2003\u2003\u2002 HRESULT Load( \u2003IMFTopology \u2003* \u2003pInputTopo,"},{"entry":"\u2003IMFTopology \u2003** ppOutputTopo );"},{"entry":"\u2003};"},{"entry":"\u2003\u2003\u2003\u2003\u2002SetTopologyCallback( \u2003\u2003IMFTopologyConnectionCallback*"},{"entry":"pTopoCallback, DWORD dwFlags );"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"This method permits an application  to specify a \u201csmart\u201d connector callback to the topology loader . This \u201csmart\u201d connector gives the application the flexibility to influence the topology loader  during the process of constructing a topology. By way of example, the application may be given the chance to connect two nodes before the topology loader  attempts to connect the nodes. Alternatively the application may have the ability chance to create a certain DMO (DirectX Media Objects) before the topology loader  attempts to create the DMO.","Load(IMFTopology*pIn, IMFTopology**ppOut, IMFTopology* pCurrentTopo)","Given an input partial or loaded topology, this method turns converts the partial topology into a fully loaded topology. This method locates the intermediate transforms needed to provide a fully specified pipeline of sources, transforms, and sinks, and sets all the input and output media types on all the objects in the topology. If this method returns successfully, the output topology is ready for processing by the media processor or another processor.","In an exemplary implementation the third parameter pCurrentTopo can be NULL or a pointer to the preceding topology. If pCurrentTopo is specified, then it will be used for object caching, which is described in greater detail below. The objects in the output topology may be the same objects in the input topology. If the Load method completes successfully, then the input topology may be discarded.",{"@attributes":{"id":"p-0097","num":"0096"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"IMFSampleDurationSetter Interface"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"interface IMFSampleDurationSetter : IUnkuown"]},{"entry":[{},"\u2002{HRESULT SetPreferredSampleDuration(LONGLONG"]},{"entry":[{},"\u2002llSampleDuration );"]},{"entry":[{},"\u2003};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"SetPreferredSampleDuration(LONGLONG llSampleDuration);","This method may be used by an application to specify preferred sample duration. Smaller sample duration may be specified to provide lower latency, while bigger sample duration may be specified to provide better quality. In an exemplary implementation llSampleDuration is in 100 ns data units.","CallBack Interface: IMFTopologyConnectionCallback:","In an exemplary implementation topology loader  comprises a callback interface that permits an application such as application  to influence the topology loader  during the process of resolving a topology. Exemplary scenarios in which this callback feature may be useful include:","Codecs: An Application could have knowledge of certain codecs which it does not want to be used or is known as buggy. The callback feature offers a way for the application to reject a codec. An application may also have knowledge of certain codecs which it prefers to use. The callback feature offers a way for the application to specify preferred codecs.","User Specified DMOs: For transform nodes, the application  is allowed to specify a guid on the topology node in the partial topology. Since the application's DMO may potentially be a not a real COM object (i.e., cannot be instantiated through CoCreateInstance) or might require some setup and initialization on creation, the callback should offer the application an opportunity to instantiate its DMO itself.","Topology Loader Override: In some instances an application may need to completely override the topology loader . For example, in some cases, there may be domain specific negotiations between two components of which the topology loader  has no knowledge. The callback feature permits an application to override the topology loader  in a connection and allows the application to resolve the partial topology.","Compatibility Problems: Certain components are known to have problems with certain media types even though they accept them By way of example, some video renderers may accept a media type but have problems rendering it. The callback feature permits an application to have some control on the media types used with the components it uses.",{"@attributes":{"id":"p-0106","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"NotifyDMOCreation Method"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT NotifyDMOCreation ( const CLSID* pGuidDMO,"]},{"entry":[{},"\u2003\u2003TOPOID NodeID, \u2002IUnknown ** pDMOUnk );"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"A partial topology received by the topology loader may have transform nodes which do not have the objects instantiated. In this case the nodes contain the guid of the required DMOs and the topology loader creates it using CoCreateInstance. Since a user-specified transform may not be a COM object, or the application may want to set some setting to the DMO before it is used, the topology loader will first call the topology callback method if it exists with this notification.","Return Codes:\n\n",{"@attributes":{"id":"p-0109","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"NotifyConnectingNodes Method"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003HRESULT NotifyConnectingNodes( \u2003IMFTopology* \u2003pTopology,"},{"entry":"IMFTopologyNode* \u2002pUpNode, \u2002long \u2002lOutIndex, \u2002IMFTopologyNode*"},{"entry":"pDownNode, long lInIndex );"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The topology loader may call this method whenever it attempts to resolve the connection between two nodes in the partial topology. The connection may require any combination of decoders, encoders, color converters, etc. to be added inbetween.","This method may give the application an opportunity to do the work on one of the connections (instead of the topology loader) to enforce the applications specific requirements. The application has two possible approaches: it can either set the preference types it wants on one or both sides of the connection, or it can make the connection itself.","In the first approach, the application only needs to set the preference type on the side of the connection it cares about. The application has to guarantee that the type it sets is acceptable to that component. The topology loader will only use that type when working with this component next. The application will have to realize that some components might be marked unconfigurable if they are components repeated from a previous topology that is currently running. This means that the type on the object should not be changed.","After the application sets the types, it returns an HRESULT of S_TOPO_TYPES_SET, (or another code that indicates that it only set the preferred types).","In the second approach the application may implement the following steps: First, the application will need to discover the type of objects it is connecting by getting the Node type from each of the nodes. The application may need to connect each possible object according to its interface. The application may connect sources, DMOs, splitters, multiplexers, tees, or sinks. Typically the application does not need to understand all of these since in most cases the application probably only cares about a specific connection it wants to handle. For all others it can return E_NOTIMPL indicating that it does not handle connecting this connection.","Second, the application needs to negotiate the media types between the two nodes. The application should take care not to change the type of any node marked as unconfigurable. The application may decide whether any intermediate nodes are necessary.","Third, the application may Insert any intermediate components it decides are necessary to complete this connection by creating new nodes for them, adding these nodes to the topology and setting the components and their guids to the nodes.","Fourth, the application should connect all nodes together and configure all components media types.","Fifth, the application should Return S_OK to indicate that it has completed work on this connection and the topology loader can pass on to the next one.","If the application fails to resolve the connection and wants the topology loader to attempt this, it should clean up all nodes it added to the topology and all connections it made and then return E_NOTIMPL.","Return Values:\n\n",{"@attributes":{"id":"p-0121","num":"0127"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"NotifyCodecCreation Method"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2002HRESULT \u2002NotifyCodecCreation \u2002(CLSID* \u2002pGuidDMO, \u2002CLSID*"},{"entry":"pDMOCategory, TOPOID NodeID, BOOL bLastChance);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Parameters:",{"@attributes":{"id":"p-0123","num":"0129"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"pGuidDMO: Guid of Codec about to be created."]},{"entry":[{},"pDMOCategory: One of the following values"]},{"entry":[{},"DMOCATEGORY_VIDEO_ENCODER"]},{"entry":[{},"DMOCATEGORY_AUDIO_ENCODER"]},{"entry":[{},"DMOCATEGORY_VIDEO_DECODER"]},{"entry":[{},"DMOCATEGORY_AUDIO_DECODER"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":{"@attributes":{"id":"ul0005-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":["NodeID: ID of upstream node whose output is being decoded or downstream node in the case of encoding.","bLastChance: Set to true when this is the last codec available."]}}}},"Return Values:\n\n","NotifyMediaTypeConsidered Method","HRESULT NotifyMediaTypeConsidered (IMFMediaType*pMediatype, IMFTopologyNode*pNode, long lIndex, bool boutput);","Parameters:\n\n","Return Values:\n\n","In an exemplary implementation, this notification is triggered in the following circumstances:","A) When connecting two uncompressed nodes: It would be called for every media type received from the upstream node, and every media type received from the downstream node. The application could restrict the working set and the topology loader may use the remaining types to determine which media type to apply. Thus the notification does not mean the system is definitely going to use this media type, but that it may, so this is the application's opportunity to reject it.","B) When connecting uncompressed to uncompressed with no input types (e.g., a Video Renderer): This method is called with every media type imposed on the downstream node","C) When Connecting Compressed to Compressed: This method is called for every media type tried between the upstream and downstream nodes, e.g., when connecting them directly without decoding and re-encoding.","This method will not notify the application of media types between sources and decoders, encoders and sinks, or internal inserted components such as the media types the topology loader uses for the color converter and resizer etc.","NotifyReceivedPartialTopo Method","HRESULT NotifyReceivedPartialTopo(IMFTopology*pPartialTopo);","Parameters:","pPartialTopo: a pointer to the new partial topology received by the topology loader for resolution","Return Values:","S_OK: Indicates that the application has made the changes it needs to the partial topology, and the Topology loader may proceed with resolving the topology. It is possible that the application could have left the topology unchanged.","AnyErrorCode: Indicates that an unexpected error occurred.","This notification is triggered whenever the Load method is called on the topology loader and gives the application access to the partial topology right before it is resolved. The application can add or remove nodes or configure components already present in the topology. The application may also need this just to gather some information from the topology. It is the application's responsibility not to change the partial topology in an incorrect way causing the resolution to fail.","IMFFopoServices Interface","Overview","This interface is implemented by the media session object . The media session  is the object which creates the topology loader . The topology loader's lifetime is the same as that of the media session  so any settings set to topology loader  though this interface will remain active though the life of the media session . This interface provides topology services such as setting the callback interface to the topology loader and other topology-related services which require knowledge of the current state of the media processor  (e.g., what is the current topology).","The IMFTopoServices interface is accessed by the application through an IMFGetService interface implemented on the media engine object . The application will get the IMFGetService by QIng the media engine . Then application calls IMFGetService::GetService with the guid MF_TOPO_SERVICE and IID_IMFTopoServices. The call is forwarded by the media engine  to the media session  which returns a pointer to this interface. The form of the IMFFopoServices Interface is as follows:",{"@attributes":{"id":"p-0146","num":"0164"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Interface IMFTopoServices: IUnknown"},{"entry":"{"},{"entry":"\u2003HRESULT \u2003SetTopologyCallback("},{"entry":"\u2003\u2003\u2003IMFTopologyConnectionCallback* pTopoCallback,"},{"entry":"\u2003\u2003\u2003DWORD dwFlags );"},{"entry":"\u2003HRESULT GetCurrentFullTopology( IMFTopology** ppFullTopo );"},{"entry":"\u2003HRESULT \u2003SetFullTopology \u2003( \u2003IMFTopology* \u2003pFullTopo,"},{"entry":"\u2003\u2003\u2003BOOL bNeedsResolution );"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Method Descriptions",{"@attributes":{"id":"p-0148","num":"0166"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SetTopologyCallback Method"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"HRESULT \u2002SetTopologyCallback( \u2002IMFTopologyConnectionCallback*"},{"entry":"\u2003\u2003\u2003pTopoCallback, DWORD dwFlags );"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"This method is the same as the one defined for IMFTopoloader above. It forwards the call to the topology loader .",{"@attributes":{"id":"p-0150","num":"0168"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"GetCurrentFullTopology Method"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"HRESULT GetCurrentFullTopology( IMFTopology** ppFullTopo );"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Parameters:","ppFullTopo: Returns the current full topology.","This method will return a pointer to a clone of the current full topology which is running in the media processor . Since the cloned nodes will still have reference to the actual objects, the application has the responsibility not to make changes, such as changing the types on the components, as these changes might disrupt the media processor's operation.","The application may use this to either gather information about the current topology, or make changes to the topology and reset it using the next method.",{"@attributes":{"id":"p-0155","num":"0173"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SetFullTopology Method"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"HRESULT \u2002SetFullTopology \u2002( \u2002IMFTopology* \u2002pFullTopo, \u2002BOOL"},{"entry":"\u2003\u2003\u2003bNeedsResolution );"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Parameters:","pFullTopo: New Topology to be set to the media processor. Usually this will be a topology obtained through GetCurrentFullTopology and modified.","bNeedsResolution: TRUE if the application has modified the topology in a way which requires it to be re-resolved in the topology loader before being set to the media processor. If it is set to false, the topology will be set as is to the media proc.","Internal Interfaces and Methods","In an exemplary implementation topology loader  provides internal interfaces and methods used to convert partial topologies to full topologies. Exemplary interfaces and accompanying methods are as follows:","Connecting Nodes","ConnectNode(IMFTopologyNode*pNode)","The Load method initially adds all the source nodes to a FIFO queue, then calls the ConnectNode interface for each of the nodes in the queue until the queue is empty.","The ConnectNode interface handles every output of a node individually. The ConnectNodes method is called with the current node and the node that should be connected to the output of the current node. If a reference to the previous full topology exists, then ReconnectNodes is called instead of ConnectNodes to attempt to use preconfigured components from the old topology.",{"@attributes":{"id":"p-0165","num":"0183"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"ConnectNodes Method"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"ConnectNodes( \u2002IMFTopologyNode* \u2002pUpNode, \u2002long \u2002lOutIndex,"},{"entry":"\u2003\u2003IMFTopologyNode* pDownNode, long lInIndex)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"This method connects one output on an upstream node to one input on the downstream node. This method implements logic to determine whether the upstream and downstream nodes are compressed, and inserts intermediate components as necessary to deal with compression. Once a connection is established with the downstream node, the downstream node is examined to determine if all its inputs are connected. If so, then the downstream node is added to the end of the FIFO queue. Operations implemented by the ConnectNodes method are described in greater detail in connection with .","ConnectUnCompToUnComp Method","This method gets all output types of an upstream node and stores them in an array. Video and audio types without a MFVideoFormat or MFAudioFormat structure attached for Video and Audio types are rejected.","This method also gets all input types of downstream node and stores them in array. Video and audio types without an MFVideoFormat or MFAudioFormat structure attached for Video and Audio types are rejected.","If there are no input types on the downstream node, then all output types are tried on the downstream node until it accepts one. If the downstream node rejects all output types and is video, then connect to color converter and try all output types of color converter on downstream node. This is the path taken when connecting to a Video Renderer.","If both the upstream node and downstream node have specified types, then an attempt is made to match the types.","GoFromUnCompToComp\/GoFromCompToUnComp Methods","These two methods are similar, except that one is on the decoding side, and the other on the encoding side. These methods use a MF Transform Enumerator to find the Decoder\/Encoder needed according to the type that needs to be decoded or encoded to. If no MF Transform is found, then it attempts to use the acm\/icm codecs.","The nodes are then connected, and in the case of encoding the input type of the encoder is determined and set on that input, to be used in ConnectUnCompToUnComp.","ReconnectNodes Method","This method is called instead of ConnectNodes to connect two nodes with the help of previously created components that are in the previous old topology. If it fails, then ConnectNodes is called, and the code path proceeds normally.","Managing Topology Changes","In an exemplary implementation the topology loader  is configured to manage topology changes which may occur during, e.g., a transition in media play back or a change in media types or media sources.","Regarding media types, a component in a topology (e.g., a splitter, demultiplexer, or a DMO) may change its output format while the topology is running. In this event the particular node must reconnect to all the downstream components in the topology, while updating their media types to the new one.","For example, assume a topology is sourcing from a DV camera. The DV splitter can change the output type of its audio while running from 44.1 KHz, 12 bit audio stereo audio to 44.1 KHz, 16 bit stereo audio. The audio renderer has to be informed of this change, and if it cannot handle the new media type, then a new object that can convert that media type (such as an audio resampler) should be added to the topology.","Regarding changes in media sources,  illustrate an exemplary topology change for transitioning from a first media source to a second media source.",{"@attributes":{"id":"p-0181","num":"0199"},"figref":"FIG. 4A","b":["400","400","410","415","420","410","415","420"]},{"@attributes":{"id":"p-0182","num":"0200"},"figref":"FIG. 4B","b":["400","430","435","400","425","410","430","425","410","430"]},{"@attributes":{"id":"p-0183","num":"0201"},"figref":"FIG. 4C","b":["400","400","430","435","420"]},"It will be apparent that source node  is repeated in the topology illustrated in  and , while source node  is repeated in the topology illustrated in  and . In a media source transition it is desirable to use the same instance of a decoder with the same media source across the topology transition. By way of example, it is desirable to ensure that the same instance of decoder  is used in  and  (e.g., to ensure that the buffer information and state information in the decoder may be maintained as the topology is transitioned). For similar reasons, it is desirable to ensure that the same instance of decoder  is used in  and .","In one implementation the topology loader implements operations to support dynamic topology changes, i.e., topology changes that take place during media operations, in a seamless fashion. These operations are explained in greater detail below.","Object Caching","In an exemplary implementation the topology loader  implements object caching techniques to ensure that the same decoder instance is used if a source node is re-used in a subsequent topology. By way of example, the topology loader  may maintain a table of decoders that contains references to all the decoders used in the previously-loaded topology. The table of decoders is indexed by the ID of the source node with which the decoder is associated. This allows the topology loader to enforce an association between source nodes and decoders, i.e., to ensure that a given source node will always be associated with the same instance of a decoder.","In operation, whenever the topology loader  needs to attach a decoder to a source node, it first searches the decoder table for a decoder associated with the source node ID. If the decoder is found in the decoder table, then this decoder is inserted instead of instantiating a new one.","By way of example, Table 1 illustrates an exemplary decoder table corresponding to the topology illustrated in .",{"@attributes":{"id":"p-0190","num":"0208"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Decoder ID","Source Node ID"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"2","1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"When constructing the topology depicted in , the topology loader  will first reference the decoder table by source node ID. Thus, when source node  is inserted into the topology depicted in , the instance of decoder  identified by ID  may be inserted into the topology depicted in , rather than instantiating a new decoder.","Table 2 illustrates an exemplary decoder table corresponding to the topology illustrated in .",{"@attributes":{"id":"p-0193","num":"0211"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Decoder ID","Source Node"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"2","1"]},{"entry":[{},"6","5"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"When constructing the topology depicted in , the topology loader  may first reference the decoder table by source node ID. Thus, when source node  is inserted into the topology depicted in , the instance of decoder  identified by ID  may be inserted into the topology depicted in , rather than instantiating a new decoder.","Similarly, the topology loader  may also maintain a table of encoders that contains references to the encoders used in the previously-loaded topology. The encoder table need not be indexed by the ID of the output node, as the output nodes could be switched or a tee could be inserted. In operation, whenever the topology loader needs to insert an encoder into a topology, the topology loader searches the encoder table for an encoder which has an output type that matches the media type requested by the media sink. If an encoder is found, then the topology loader  uses the located encoder rather than instantiating a new encoder.","In an exemplary implementation the topology loader  may be configured to use an existing full topology as a cache from which it may obtain components (i.e., objects) with which to build another topology. By way of example, the topology loader  may be configured to use the topology of  as a cache from which to obtain components for constructing the topology of . Similarly, the topology loader  may be configured to use the topology of  as a cache from which to obtain components for constructing the topology of .",{"@attributes":{"id":"p-0197","num":"0215"},"figref":["FIG. 5","FIG. 5"],"b":["500","232","510","232","232"]},"At operation  the topology loader determines whether there are corresponding nodes in the partial topology and the previous full topology. In an exemplary implementation this may be performed by comparing the nodes in the partial topology and the previous full topology received as parameters. If there are no corresponding nodes, then control passes to operation  and object caching operations  terminate. The new topology may then be instantiate using conventional techniques. Exemplary techniques are disclosed in corresponding U.S. patent application Ser. No. 10\/796,505, entitled RESOLVING PARTIAL MEDIA TOPOLOGIES, commonly assigned to Microsoft Corporation of Redmond, Wash., USA, the disclosure of which is incorporated herein by reference.","By contrast, if there are corresponding nodes, then control passes to operation , and matching transform nodes from the previous full topology are transferred to the new topology. In addition, the transform nodes are marked as non-configurable, indicating that their media type cannot be changed.","If, at operation , there are matching upstream and downstream nodes in the partial topology and the previous full topology, then control passes to operation  and the topology loader  clones and inserts the intermediate nodes between the upstream and downstream nodes. This eliminates the need for media type negotiation for any nodes between upstream node and the downstream node. By contrast, if there are not matching upstream and downstream nodes, then control passes to operation  and the topology loader  clones matching nodes. Control then passes to operation  and the remaining nodes are instantiated and inserted into the full topology using conventional techniques.","It will be understood that the previous full topology received with the load call may still be running in the media processor. Thus, reused components cannot be reconfigured. Instead, the topology loader  converts the media stream to the form that the DMO currently takes. Accordingly, nodes in the partial topology which refer to the same nodes in the full topology should be cloned from the full topology, e.g., using the IMFTopologyNode::CloneFrom method.","While the operations of  are concerned with using the previous full topology for object caching, it will be understood that any number of previous topologies could be maintained for object caching. In addition, or in the alternative, only heavily-used components could be maintained for object caching. Increasing the number of topologies or components maintained for caching reduces the time required to construct a full topology but increases the memory requirements of the topology loader, so any specific implementation may select a preferred balance between these competing factors.","Exemplary Operating Environment","The various components and functionality described herein are implemented with a number of individual computers.  shows components of a typical example of a computer environment , including a computer, referred by to reference numeral . The computer  may be the same as or different from computer  of . The components shown in  are only examples, and are not intended to suggest any limitation as to the scope of the functionality of the invention; the invention is not necessarily dependent on the features shown in .","Generally, various different general purpose or special purpose computing system configurations can be used. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, network-ready devices, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The functionality of the computers is embodied in many cases by computer-executable instructions, such as software components, that are executed by the computers. Generally, software components include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Tasks might also be performed by remote processing devices that are linked through a communications network. In a distributed computing environment, software components may be located in both local and remote computer storage media.","The instructions and\/or software components are stored at different times in the various computer-readable media that are either part of the computer or that can be read by the computer. Programs are typically distributed, for example, on floppy disks, CD-ROMs, DVD, or some form of communication media such as a modulated signal. From there, they are installed or loaded into the secondary memory of a computer. At execution, they are loaded at least partially into the computer's primary electronic memory.","For purposes of illustration, programs and other executable program components such as the operating system are illustrated herein as discrete blocks, although it is recognized that such programs and components reside at various times in different storage components of the computer, and are executed by the data processor(s) of the computer.","With reference to , the components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISAA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as the Mezzanine bus.","Computer  typically includes a variety of computer-readable media. Computer-readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer-readable media may comprise computer storage media and communication media. \u201cComputer storage media\u201d includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules, or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer-readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more if its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or software components that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , software components , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as data media interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface.","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer-readable instructions, data structures, software components, and other data for computer . In , for example, hard disk drive  is illustrated as storing operating system \u2032, application programs \u2032, software components \u2032, and program data \u2032. Note that these components can either be the same as or different from operating system , application programs , software components , and program data . Operating system \u2032, application programs \u2032, software components \u2032, and program data \u2032are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard , and pointing device (not shown), commonly referred to as a mouse, trackball, or touch pad. Other input devices may include source peripheral devices (such as a microphone  or camera  which provide streaming data), joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through an input\/output (I\/O) interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port, or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , computers may also include other peripheral rendering devices (e.g., speakers) and one or more printers which may be connected through the I\/O interface .","The computer may operate in a networked environment using logical connections to one or more remote computers, such as a remote device . The remote device  may be a personal computer, a network-ready device, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to computer . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) . Although the WAN  shown in  is the Internet, the WAN  may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the like.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the Internet . The modem , which may be internal or external, may be connected to the system bus  via the I\/O interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote device . By way of example, and not limitation,  illustrates remote software components  as residing on remote device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Although the described arrangements and procedures have been described in language specific to structural features and\/or methodological operations, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or operations described. Rather, the specific features and operations are disclosed as preferred forms of implementing the claimed present subject matter."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3A-3B"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIGS. 4A-4C"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
