---
title: Method, system, and program product for monitoring message flow in a message queuing system
abstract: System, method, and computer program product for automatically monitoring message flow in a message queuing system in an asynchronous messaging network. A message queuing application programming interface appends, in a message descriptor field for recording and monitoring message flow, unique application identification keys of applications that process the message, operation codes applied to the message, and time stamps of operations applied during message processing. The keys are generated by the start-up of the applications and are filled in by each PUT and GET function of the API. After processing of the message, the entries included in the message descriptor field are monitored, and any deviation from a predefined message flow is automatically detected and reported.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07707585&OS=07707585&RS=07707585
owner: International Business Machines Corporation
number: 07707585
owner_city: Armonk
owner_country: US
publication_date: 20051019
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present invention relates to message queuing in an asynchronous messaging network, and in particular to a method, system, and computer program product for monitoring message flow in a message queuing system.","It is increasingly common to distribute a data processing operation over a plurality of data processing units, with each of the units communicating over a data communications network such as the Internet. One reason for this is that a particular data processing unit may be able to do a job better than another, so a first unit makes a request for a second unit to do a particular job and then to return the result to the first unit.","It is also very common to have a large number of intermediate data processing units (also known as \u201cnodes\u201d) between the originating unit that makes a request and the destination unit that is being requested to do the work. Each intermediate unit receives the request, performs some initial processing to determine what to do with it, and then forwards it on to the next unit.","A popular mechanism for carrying out such distributed data processing is called asynchronous message queuing, wherein applications communicate with each other by sending messages to queues, which can then be accessed by the receiving application at a convenient time. IBM's WebSphere MQ (trademark) software product is an example of this type of software. More and more companies are providing services based on message queuing systems as underlying information transportation infrastructure.","A problem in such message queuing systems is to monitor message flow, especially to identify all of the applications involved in processing messages as well as their sequence of involvement. This problem becomes more important when using message queuing systems in a grid architecture, or whenever it is essential to ensure that a message has been processed in a predefined sequence by the authorized applications.","An example would be, as shown in  B, a service provider which provides business-to-business (B2B) services for other companies. A company A (Appl) sends messages to the Service Provider which will be processed and then sent to the other company B (Appl). However, there is no evident way for the two companies to ensure that the agreed applications have been used in the agreed sequence (Appl, Appl, Appl, Appl, Appl) and that no other application has used or read their messages.","The present invention provides a system, method, and computer program product for automatically monitoring message flow in a message queuing system in an asynchronous messaging network. A message queuing application programming interface (API) appends, in a message descriptor field for recording and monitoring message flow, unique application identification keys (ApplIdentKeys) of applications involved in processing the message, operation codes of operations applied to the message, and time stamps of operations applied during processing of the message. The ApplIdentKeys are automatically generated by the start-up of the applications and filled in by each PUT and GET function of the message queuing API. After processing of the message, the content of the entries included in the message descriptor field is monitored, and any deviation from a predefined message flow is automatically detected and reported.","According to an embodiment, a computer program product including a computer readable storage medium has computer readable program code tangibly embodied therein. The computer readable program code may be configured to compute application identification keys during startup of applications, connect the applications to a message queuing system and execute GET message operations for retrieving messages from a queue of the message queuing system initiated by a request from a requesting application. The computer readable program code may also be configured to store content of message descriptor fields of retrieved messages, and update message descriptor fields by appending application identification keys of requesting applications, and operation codes and sequences of the GET operations to message descriptor fields of retrieved messages. The computer readable program code may also be configured to pass messages with the updated message descriptor fields to requesting applications, and process messages by the requesting applications.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1A","b":["11","12","2","6","11","12","11","12","10","22","30","22","22","10","10","22"]},"Queues  Exist independently of the applications that use them. A queue can exist in the main storage if it is temporary, on disk or similar auxiliary storage if it must be kept in case of recovery, or in both places if it is currently being used and must also be kept for recovery.","A message queuing system is a system for asynchronous, assured exchange of information in the form of messages between applications connected to the system. The message descriptor of the message is known and interpretable by the message queuing system, but not the message body whose layout is variable and application dependent. A message queuing system stores and transports messages regardless and without knowledge of the content in the message body.","Multiple message queuing systems can be interconnected in a message queuing network  which allows applications on different platforms and different physical locations to easily exchange data without knowledge of the underlying infrastructure.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1C"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2A","b":["7","8","13","13"]},"The message descriptor field  cannot be modified by the application code because the message queuing API is the interface to the messaging queuing system. The ApplldentKey is also passed to the queue manager with each PUT or GET request. On a roll-back of a GET operation (in case of a roll-back requested by the application or in case of an abend of the application) the queue manager appends the ApplldentKey received with the request to the message descriptor field  with the appropriate operation code and the time stamp of the operation.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 2B","FIG. 1A","FIG. 2A"],"b":["2","3"]},"During initialization (start up of the application) the ApplldentKey may be computed by using the program code of the message processing application  from the file system As input and applying a hash function to that input. The ApplldentKey is preferably stored in the private memory (; volatile memory) of the message queuing API  and inserted by the message queuing API  into message descriptor field of the messages on each PUT and GET operation of each message.","On each message GET or PUT operation, the ApplIdentKey of the application is appended in the message descriptor field including the type of operation and time stamp of operation. Four types of operations are defined and used for the recording. These operations are:\n\n",{"@attributes":{"id":"p-0031","num":"0034"},"figref":["FIG. 2C","FIG. 2B","FIG. 2C","FIG. 2D"],"b":["14","20","30","40","50","100"]},"The content of the message descriptor field of the retrieved message is safely stored in a private memory area of the message queuing API () and is extended by the ApplIdentKey of the application processing the message, GET C operation code, and current time stamp (). The updated message field content is then passed by the message queuing API to the Application (), and the application processes the message (). Finally, the application passes the updated message for putting on another queue to the message queuing API ().","The message queuing API uses the previously safely stored message descriptor field, and appends the ApplIdentKey computed during start up including the PUT operation code and time stamp in the message descriptor field of the message (). The message is then passed to the queue manager of the message queuing system which puts it on the desired queue ().",{"@attributes":{"id":"p-0034","num":"0037"},"figref":"FIG. 2E","b":["15","25","35","45","75","85"]},"If the application needs to check only whether only authorized applications have accessed the message, it reads the content of the message descriptor field and checks whether the ApplIdentKeys are in the predefined list of authorized applications . If not, the application raises an alert  and puts the message in doubt on another queue for further processing. If the check is successful, the application continuous processing .","Several examples of a message flow in a messaging queuing system scenario as shown in  with its content in the message descriptor field according to the present invention are described. The initial application Appl in  is connected to the queue manager of a message queuing system QM. During start-up of the application, the initialization routine of the message queuing API linked to the application reads the application code including all used dynamic loadable libraries and generates the ApplIdentKey. The ApplIdentKey is appended to the message descriptor field for recording and monitoring message flow for every GET and PUT operation on a queue. Appl puts a message on queue Q, and the message queuing API appends the ApplIdentKey, the operation code PUT, and the current time stamp to the message descriptor field.","Content of the message descriptor field (ApplIdentKey, operation code, time stamp)",{"@attributes":{"id":"p-0038","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["DE407645D4BA715429362C2E0F1FF23DDAB72395","PUT","TS1"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":["2","1","2","1"]},"Content of the message descriptor field",{"@attributes":{"id":"p-0040","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["DE407645D4BA715429362C2E0F1FF23DDAB72395","PUT","TS1"]},{"entry":["CC35978824436FFE3C001BF352F996E74E4AC465C","GETC","TS2"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Application ApplDoes its processing and puts the message on Q. Again, the message queuing API appends the ApplIdentKey of Appl to the message descriptor field in conjunction with the operation code PUT.","Content of the message descriptor field",{"@attributes":{"id":"p-0043","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["DE407645D4BA715429362C2E0F1FF23DDAB72395","PUT","TS1"]},{"entry":["CC35978824436FFE3C001BF352F996E74E4AC465C","GETC","TS2"]},{"entry":["CC35978824436FFE3C001BF352F996E74E4AC465C","PUT","TS3"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Now, assuming application Appl is trying to get messages from Q, it gets the message, reads the content, and rolls back that operation. In this case, the message queuing API appends a fourth entry to the message descriptor field consisting of the ApplIdentKey of Appl, the operation code GETR, and the time stamp of that operation.","Content of the message's descriptor field",{"@attributes":{"id":"p-0046","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["DE407645D4BA715429362C2E0F1FF23DDAB72395","PUT","TS1"]},{"entry":["CC35978824436FFE3C001BF352F996E74E4AC465C","GETC","TS2"]},{"entry":["CC35978824436FFE3C001BF352F996E74E4AC465C","PUT","TS3"]},{"entry":["78243CC3549FF56E389C008F996E74E4AC465CADF","GETR","TS4"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Now application Appl gets the message successfully and checks whether this message is from ApplAnd whether it has been processed successfully by Appl and no further application. In this case, Appl detects that Appl did a message GET and rolled back that operation. So Appl generates an intruder alert on the message so that an operator can decide what to do.","Another example of this scenario is a case wherein a second application should have processed the message after ApplAnd before Appl, but not Appl. So again, Appl would generate an alert signaling a processing sequence error.","A further example would be a case wherein a message processing agreement of two business partners and a service provider is checked. The permissible message processing flows are agreed with the service provider. The service provider provides the ApplIdentKeys of the authorized applications to the business partners. Depending on the services the partners want to use from the service provider, the sending partner may add the intended processing flow to the message by adding a list of ApplIdentKeys of the encountered applications to the message. This list is then encrypted by the sender with the public key of the responder. If the responder receives the message from the service provider, he decrypts the list of ApplIdentKeys with its private key and compares it with the content of the message descriptor field. He or she is now able to detect whether the processing steps have been performed in the indented order by the agreed applications and whether other applications have tried to read the message.",{"@attributes":{"id":"p-0050","num":"0053"},"figref":"FIG. 2F"},"Furthermore, each message queuing system may contain a message trace component that administers a message trace queue and add entries in that message trace queue for each operation of a message. Each entry in the message trace queue contains at least the message id, content key, the time stamp of the entry, and source queue as far as the message is not transferred to another message queuing system. If the message is transferred to another queuing system the entry contains additionally the target queue and target queuing system. According to the present invention, the message trace queue may also contain the content of the message descriptor field.","Furthermore, each message queuing system may be extended by the inventive message queuing application programming interface generating the content of the message descriptor field as described in conjunction with .","Finally, each message queuing system may contain a message search component which provides the functionality to search for the current location of the message as well as to retrieve the whole trace of the movement of specified a message in messaging network. This allows an auditor to check the processing flow of a specific message."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":["The invention will be best understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1C"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 2B","FIG. 1A","FIG. 2A"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2C"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2D"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2E"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2F"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2G"}]},"DETDESC":[{},{}]}
