---
title: Protected cryptographic calculation
abstract: In a method for protected execution of a cryptographic calculation in which a key with at least two key parameters is drawn on, an integrity check of the key is performed, in order to prevent a cryptographic attack in which conclusions are drawn as to at least one second key parameter by corrupting at least one first key parameter. A further method serves to determine a key for a cryptographic calculation with at least two key parameters provided for use in the first-mentioned method. A computer program product and a portable data carrier have corresponding features. The methods enable particularly good protection of cryptographic calculations against attacks.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07983414&OS=07983414&RS=07983414
owner: Giesecke & Devrient GmbH
number: 07983414
owner_city: Munich
owner_country: DE
publication_date: 20030909
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EMBODIMENTS OF THE INVENTION"],"p":["1. Field of the Invention","The invention relates in general to the technical domain of cryptography and more especially to a procedure for improved protection of a cryptographic calculation against attacks. The invention is provided in particular for use in portable data carriers, which can be configured as smart cards in different forms of construction or as chip modules, for example.","2. Description of the Related Art","The RSA method, described, e.g. in U.S. Pat. No. 4,405,829, is well known for the exchange of encrypted and\/or signed data. According to the RSA method, a public key is used for encryption or signature verification and a secret private key for decryption or signature generation. Security of the RSA method is based on the fact that currently no efficient way of determining the prime factors p and q of a large number n with n=p\u00b7q is known. Whereas the so-called modulus n is published as part of the public key, the values p and q must be kept secret.","The calculation processes required for executing the RSA method are relatively complicated. For instance, the data to be processed have to be exponentiated with parameters of the private key during decryption or signature generation, for example. In particular for portable data carriers with their limited computing power, an implementation of the RSA method for decryption or signature generation is therefore frequently employed which uses the CRT (Chinese remainder theorem) and therefore is also designated as RSA-CRT method. By using the RSA-CRT method the required computing expenditure is reduced by approximately the factor 4.","The RSA-CRT method provides, instead of one complicated power calculation, to perform two far simpler exponentiations, the results of which are then combined into the decrypted data or the generated signature. Only the secret prime factor p enters into the first of these calculations and only the secret prime factor q into the second calculation.","Attack scenarios have been proposed, in which exactly one of the two named RSA-CRT calculation branches is interfered with, e.g. by deliberate action of heat or radiation or by electrical pulses. If this succeeds, a multiple of the prime factor p, q, whose calculation branch has not been interfered with can be derived from the result of the overall calculation. In other words, conclusions can be drawn as to the private key by means of the described attack. This has potentially catastrophic consequences, because not only the decryption or signature generation just performed, but all the cryptographic operations executed using the private key are compromised.","The attack just mentioned is known by the name \u201cfault attack\u201d or \u201cBellcore attack\u201d and described, e.g., in column 4 of U.S. Pat. No. 5,991,415. Likewise in U.S. Pat. No. 5,991,415 a method is disclosed, in which an additional factor j enters into the calculation to protect against this attack which takes place during the cryptographic calculation. However, as will be shown below, there are further possibilities of attack, against which nothing can be done by the method known from U.S. Pat. No. 5,991,415.","Said possibility of attack is particularly critical if the cryptographic calculation is executed by a processor of a portable data carrier, for example a smart card or a chip module. A first reason for this is that portable data carriers of this kind are often used for security-critical applications, e.g. in connection with financial transactions, access control or the signature of legally binding documents. Secondly, portable data carriers are typically in the possession of the attacker while the cryptographic calculation is being executed, so this person has every opportunity to influence the calculation and to spy on the results of the calculation.","An object of the invention is to provide a technique for particularly good protection of cryptographic calculations against attacks. A further object of the invention is to prevent attacks based on similar principles to the \u201cBellcore attack\u201d described above. Yet a further object in preferred configurations of the invention is that the protection according to the invention should advantageously cooperate with other protection methods.","According to the invention, the above objects are completely or partly achieved by a method for protected execution of a cryptographic calculation in which a key with at least two key parameters is drawn on, wherein an integrity check of the key is performed in order to prevent a cryptographic attack in which conclusions are drawn as to at least one second key parameter by corrupting at least one first key parameter.","Further according to the invention, the above objects are completely or partly achieved by a method for determining a key for a cryptographic calculation with at least two key parameters, the key being adapted to be used in a method for protected execution of a cryptographic calculation wherein an integrity check of the key is performed in order to prevent a cryptographic attack in which conclusions are drawn as to at least one second key parameter by corrupting at least one first key parameter.","Further according to the invention, the above objects are completely or partly achieved by a computer program product which has program commands to cause a processor to execute a method for protected execution of a cryptographic calculation, in which a key with at least two key parameters is drawn on, wherein an integrity check of the key is performed in order to prevent a cryptographic attack in which conclusions are drawn as to at least one second key parameter by corrupting at least one first key parameter.","Further according to the invention, the above objects are completely or partly achieved by a portable data carrier set up for executing a method for protected execution of a cryptographic calculation, in which a key with at least two key parameters is drawn on, wherein an integrity check of the key is performed in order to prevent a cryptographic attack in which conclusions are drawn as to at least one second key parameter by corrupting at least one first key parameter.","The order in which the method steps are listed in the claims should not be interpreted as a limitation of the range of protection; rather, configurations of the invention are provided, in which these method steps are executed completely or partly in a different order or completely or partly parallel or completely or partly interleaved.","The invention starts from the fundamental awareness that an attack similar to the above-described Bellcore attack is possible not only owing to interference with the calculation processes during the cryptographic calculation, but also by the cryptographic calculation being supplied with incorrect parameters. This can be done, for example, by transferring a false pointer address to the calculation routine, or by an external alteration of the contents of memory fields in which key parameters are contained. The inventors have realized that conclusions as to key parameters which need to be kept secret may possibly be drawn from the result of a cryptographic calculation supplied with parameters corrupted in this way.","According to the invention it is provided, to protect against an attack of this kind, to execute an integrity check of the key drawn on for the cryptographic calculation. By this measure the attack can be identified and defended against, in that, e.g. the cryptographic calculation is terminated without issuing a result. The integrity check cannot normally rule out manipulation of the key parameters with absolute certainty; however, it should provide protection against said attack which is adequate for practical purposes. This implies that a simple range check with a fixed lower limit and a fixed upper limit would not be regarded as an integrity check in the sense of the present invention.","The integrity check is preferably configured in such a way that a manipulation in which a monitored key parameter is corrupted in a random way is identified with a probability bordering on certainty, e.g. with a probability greater than 1-10or greater than 1-10or greater than 1-10. While the integrity check in many configurations comprises only individual, particularly critical key parameters, it is preferably provided to monitor all the parameters of a key which needs to be kept secret. Different test methods can be executed in this case for individual parameters or groups of parameters in the course of the integrity check.","The methods used for the integrity check are in each case aimed at identifying corruption of the monitored key parameter or the monitored key parameters. In a preferred configuration, the integrity check effectively determines whether a key parameter is within a range of valid values, wherein the range is non-contiguous in that it has a plurality of gaps. This type of testing usually exists if the key parameter has been calculated during key generation from the value actually required for the cryptographic calculation and an additional, per se redundant safeguard value, as is the case, e.g. with checksum calculations.","While it can be provided that many or all of the key parameters are checked individually in each case, it is preferably determined in the integrity check whether at least two key parameters are in a predetermined relationship to one another. The integrity check can include a multiplicative operation, which in the wording of the present document includes multiplication, division, exponentiation, a modulo calculation and a divisibility test.","It is preferably checked whether a key parameter or a value derived from it is evenly divisible by a safeguard value. In this case the key parameter is preferably extracted during key generation by multiplying the value actually required for the cryptographic calculation by the safeguard value. The safeguard value may be a component of the key or permanently preset.","The method according to the invention is suitable for all cryptographic calculations in which a cryptographic attack enables conclusions as to at least one second key parameter by corruption of at least one first key parameter. The invention is provided in particular for safeguarding the decryption or signature generation in an RSA method, preferably in an RSA-CRT method. In these cases the integrity check relates to the private RSA key. Corresponding possibilities of attack are expected to be found for further cryptographic calculations, which can then likewise be safeguarded in the manner according to the invention.","In preferred configurations, in the integrity check it is determined whether an exponent used in an exponentiation operation is evenly divisible by a safeguard value. These embodiments of the invention can be particularly advantageously combined with an exponent-masking method, as known from the international publication document WO 01\/48974 A1. In further advantageous configurations the prime factors of the RSA method are multiplied by a masking parameter\u2014alternatively or additionally to the exponent masking just mentioned\u2014so that the result of the calculation can be checked for accuracy by means of an equality check modulo the masking parameter.","The computer program product according to the invention has program commands to implement the method according to the invention. A computer program product of this kind may be a physical medium, for example a semi-conductor memory or a diskette or a CD-ROM, on which a program for executing a method according to the invention is stored. The computer program product may, however, also be a non-physical medium, for example a signal communicated via a computer network. The computer program product may be provided in particular for use in connection with the production and\/or initialization and\/or personalization of smart cards or other data carriers.","In preferred configurations the computer program product and\/or the portable data carrier are further developed with features corresponding to the above-described features and\/or those mentioned in the dependent method claims.","The method illustrated in  serves for calculating a public key  and a private key , which are configured for use in an RSA method. The dotted arrows indicate in each case which key parameter is generated by which method step. In connection with use of the pair of keys ,  by portable data carriers (e.g. smart cards), the method can be executed in a secured environment, e.g. in the course of the initialization or personalization of the data carrier. The externally calculated pair of keys is then transmitted into the data carrier as part of the initialization or personalization data. It is alternatively possible for the method of  to be executed by the data carrier itself, in order to determine the pair of keys.","The public key  has as key parameters a modulus n and a public exponent e. The private key  is provided for RSA calculations using the Chinese remainder theorem, also designated here as RSA-CRT calculations. The private key  has as key parameters a first and a second prime factor p, q, a CRT coefficient pinv, a first and a second safeguard value sp, sq and also a safeguarded first and a safeguarded second CRT exponent dp, dq.","The method illustrated in  begins in a way known per se in step  with the random choice of two prime numbers with a length of, e.g. 1024 or 2048 bits each, which are stored in the private key  as the first and second prime factors p, q. In the following step  the modulus n of the public key  is calculated as the product of the two prime factors p, q. The public exponent e is determined in step  as a random number, which is relatively prime to the value (p\u22121)\u00b7(q\u22121). As in the present embodiment example the private key  is tailored to RSA-CRT calculations, in step  the modular inverse of p modulo q is calculated and entered into the private key  as the CRT coefficient pinv.","In step  the value d is calculated as the modular inverse of the public exponent e modulo (p\u22121)\u00b7(q\u22121). In RSA methods which do not use the Chinese remainder theorem d, as the private exponent, would be the main component of the private key. In known RSA-CRT methods the two CRT exponents d mod (p\u22121) and d mod (q\u22121) would be used instead of d. In the present embodiment example the private key , on the other hand, contains values derived from said CRT exponents d mod (p\u22121) and d mod (q\u22121) by an additional safeguarding measure. This safeguarding measure is in this case, by way of example, the multiplication by one safeguard value in each case. Manipulation of the safeguarded values can be detected by a divisibility check. In embodiment alternatives other safeguarding measures are provided, e.g. a checksum formation or multiple passing of at least the important parameters to be passed.","Two random numbers with a length of, for example, 64 bits (8 bytes) each are generated in step  as safeguard values sp, sq. The safeguarded first CRT exponent dp is calculated in step  according to dp:=(d mod (p\u22121))\u00b7sp. Correspondingly, the safeguarded second CRT exponent dq is determined in step  by the calculation dq:=(d mod (q\u22121))\u00b7sq. Said values are all stored as parameters of the private key . This ends the determination of a private key  protected against manipulation.","In the present embodiment example the private key  substantially exists in the form of a data structure RSAPrivateCRTKey according to the conventions of the Java Card application programming interface. These conventions are described in the document \u201cJava Card\u2122 2.1.1 Application Programming Interface\u201d, Revision 1.0, 18 May 2000, published by Sun Microsystems, Inc., USA, currently available at http:\/\/java.sun.com\/products\/javacard\/javacard21.html. The data structure provided there has fields DP and DQ for the unsafeguarded CRT exponents d mod (p\u22121) and d mod (q\u22121). In order to accommodate the private key  according to the present embodiment example in a data structure of this kind, it is provided in the present embodiment example that the values sp and dp are stored together in the field DP of the RSAPrivateCRTKey and that correspondingly the values sq and dq are stored together in the field DQ. In FIG.  this is indicated by dotted lines. In embodiment variants the values sq and dq can also be stored in other fields of the RSAPrivateCRTKey or outside this data structure.","The embodiment examples described here differ slightly from the above-mentioned Java Card specification insofar as in the present case the modular inverse of p modulo q is contained in the private key  as CRT coefficient pinv. According to the Java Card specification, on the other hand, a CRT coefficient PQ is used which is the modular inverse of q modulo p. Modifications of the method described here are provided, in which the CRT coefficient PQ corresponding to the Java Card specification is a component of the private key . The ideas according to the invention can also be used for configurations of this kind without substantial alteration.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 2","b":"12"},"When the method is invoked, a pointer to the private key  is transferred to the invoked decryption or signature generation routine. The inventors have recognized that a cryptographic attack can be executed in that individual parameters of the private key  are manipulated before the start of the decryption or signature generation. This can be done, e.g. by deliberate action on the EEPROM containing the private key  or by transferring an incorrect address to the RSA-CRT routine. An attack of this kind would have the extremely disadvantageous consequence that conclusions could be drawn from the result of the calculation\u2014e.g. the decrypted data or the generated signature\u2014as to the values of the secret key parameters. This would compromise the pair of keys ,  for all previous and future calculations.","In order to prevent a cryptographic attack of this kind, in the method of  an integrity check of the private key  is provided, which includes a series of several partial tests. In  the dotted arrows indicate which key parameters enter into the respective partial tests.","The method begins in step  with the partial test as to whether the CRT coefficient pinv contained in the private key  does actually represent the modular inverse to the first prime factor p modulo the second prime factor q. In other words it is checked whether the fixed relationship p-pinv=1 mod q has been fulfilled. If this is not the case, an error jump takes place and the method is terminated. If the check is successful, it can be assumed that the key parameters p, q and pinv have not been manipulated and the method is continued.","In the calculation module , which now follows, a first auxiliary value y is determined as the result of the first of the two CRT calculation branches. The data x to be decrypted or signed, the first prime factor p and the first CRT exponent d mod p\u22121 enter into this calculation, wherein the latter value is not directly available, but has to be derived from the safeguarded first CRT exponent dp and the first safeguard value sp.","To check whether one of the two values sp, dp has been manipulated, firstly in step  a divisibility check is performed. If the safeguarded first CRT exponent dp is not evenly divisible by the first safeguard value sp, an error jump and termination of the method takes place again. If, on the other hand, the division comes out without remainder, it can be assumed with probability bordering on certainty that at least no random corruption of one of the two key parameters sp and dp has taken place. This divisibility check represents only a small additional computing expenditure, as the safeguard value sp has only a relatively small bit length. Deliberate manipulation of the two parameters sp and dp with knowledge of the safeguarding mechanism provided could not, of course, be discovered by the method described here; though it is not currently imaginable how an attacker could bring about deliberate writing of this kind of new values into individual EEPROM cells of the data carrier.","If the integrity check with respect to parameters sp and dp in step  was successful, in step  the actual calculation of the first auxiliary value y is executed according to y:=(x mod p)^(dp\/sp). With respect to the exponent dp\/sp it is of course normally possible to have recourse to the result of the division already calculated in step . As the safeguarding method in the present embodiment example simply consisted of multiplication by the first safeguard value sp\u2014see step  in FIG. \u2014dp\/sp=d mod (p\u22121) applies and thus y=(x mod p)^(d mod (p\u22121)). This is the desired result of the first CRT calculation branch.","A second calculation module  corresponds to the second CRT calculation branch. The method operates in the same way as in the first calculation module , wherein, however, the second prime factor q, the second safeguard value sq and the safeguarded second CRT exponent dq are drawn on. In step  the integrity check in respect of key parameters sq and dq follows again and in step  the second auxiliary value y is calculated according to the formula y:=(x mod q)^(dq\/sq).","In calculation step  concluding the method the overall result y, in other words the decrypted data or the calculated signature, is determined in a way known per se by combining the two CRT auxiliary values y and y. The calculation performed here can be expressed as a formula as y:=(((y\u2212y)\u00b7pinv) mod q)\u00b7p+y. Different evaluation sequences can of course be chosen for the calculation steps performed by the processor of the data carrier. Different variants of the RSA-CRT calculations of steps ,  and  are generally known from the literature, which differ in particular in the way in which interim results are reduced to the respective modulo ranges. The idea according to the invention of the integrity check and the multiplicative safeguarding of the CRT exponents dp and dq proposed in the present embodiment example can be combined with all these variants.","The integrity check according to the present invention is directed in particular against a cryptographic attack which is executed chronologically before the RSA calculations\u2014at the latest during passing of the parameters to the RSA routine. The check during passing of the parameters can also be done in a simple manner in that, as well as the parameters to be passed, redundant information related thereto, for example in the form of checksums, is also stored and, after the parameters have been passed, a stored checksum is compared with a checksum which has been newly calculated from the passed parameters. Alternatively, at least important parameters to be passed can be multiply passed and checked for identity after passing.","Further methods of attack are known, which aim at spying out the individual calculation steps in order to enable conclusions as to the key parameters which need to be kept secret. The exponent formation in steps  and  is particularly exposed to such attacks, because with normal implementations of the exponentiation operation the processor activity during the course of calculation depends considerably on the bit sequence of the exponent. This processor activity can be spied out by measuring the power consumption (SPA=simple power analysis or DPA=differential power analysis) or other signals, such as, e.g. electrical field strengths.","To protect against attacks of this kind, it was proposed in international patent publication WO 01\/48974 A1 to divide the exponent with remainder by a random number and, instead of a single exponentiation operation, to perform three separate exponentiations, wherein the whole-number quotient, the random number and the remainder determined during the division are used as exponents. This method is described in detail in said patent publication, the contents of which are hereby fully incorporated into the present document.","It is a particular advantage of the safeguarding method according to the present invention that it can easily be combined with the masking method designated as \u201cexponent blinding\u201d according to WO 01\/48974 A1, wherein the division required in any case for the masking method can also be used for the safeguarding method according to the present invention. The method according to the invention can in this way be implemented with very little extra expenditure.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 3","FIG. 2"],"b":["32","32","46","48","1","2","1","2","48"]},"In steps  and  the first two exponentiation operations are now performed, in that the basic value x mod p is first exponentiated by the random number r and the thus obtained interim result y is then exponentiated by the whole-number quotient dp. For the result y, y=((x mod p)^r)^dp=(x mod p)^(r\u00b7dp) thus applies. The safeguard value sp has not entered into steps  and , as to this extent the multiplication serving to safeguard the CRT exponent dp has already been reversed in connection with the division .","In step  a divisibility check now takes place\u2014analogously to step  in FIG. \u2014to ensure the integrity of the key parameters sp and dp. In contrast to step  in , here, however, it is not the safeguarded CRT exponent dp that is divided by sp, but the division remainder dp. As dp differs from dp only by a multiple of r\u00b7sp\u2014and thus by a multiple of sp\u2014the two checks are of equal value. The calculation expenditure arising from execution of step  is, however, considerably less than in the calculation of step  in , owing to the far shorter dividend dp. Moreover, the whole-number division result dp\/sp is required in the following step . The division and divisibility check in step  represents in comparison with the known method according to WO 01\/48974 A1 the only additional computing expenditure.","If dp is not an even multiple of sp, the method is terminated in step  by an error jump. Otherwise, in step  a further interim value y is calculated according to y:=(x mod p)^(dp\/sp). The product y\u00b7y is determined in step  as the result y of calculation module \u2032. This result is identical to the first auxiliary value y according to step  of , because:",{"@attributes":{"id":"p-0056","num":"0055"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":"\u2003","mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},{"mi":"y","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mrow":{"mn":"12","mo":"\u00b7","mi":"y"},"mn":"13"}],"mo":"="}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mi":["x","mod","p"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}},{"mo":["(",")"],"mrow":{"mrow":{"mi":["r","dp"],"mo":"\u00b7"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}],"mo":"^"}},{"mo":["(",")"],"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mi":["x","mod","p"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"1.1em","height":"1.1ex"}}}]}},{"mo":["(",")"],"mrow":{"mi":"dp","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mn":"2","mo":"\/","mi":"sp"}}}],"mo":"^"}}],"mo":"\u00b7"}}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mi":["x","mod","p"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}},{"mo":["(",")"],"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mrow":{"mi":["r","dp"],"mo":"\u00b7"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},{"mo":["(",")"],"mrow":{"mi":"dp","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mn":"2","mo":"\/","mi":"sp"}}}],"mo":"+"}}],"mo":"^"}}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mi":["x","mod","p"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}},{"mo":["(",")"],"mrow":{"mi":["dp","sp"],"mo":"\/"}}],"mo":"^"}}}}]}}}},"br":{}},"The entire RSA-CRT method in the particularly protected embodiment variant described here starts with an integrity check of parameters p, q and pinv by step  shown in . This is followed by the steps of calculation module \u2032 according to  as first CRT calculation branch, in order to determine the first auxiliary value y. The method shown in  is likewise used to calculate the second auxiliary value y, wherein, of course, the key parameters p, sp and dp are replaced by q, sq and dq. The random number r can either be taken over from the first course of the calculation module \u2032 or newly determined. The final result y is finally calculated by combining the two auxiliary values y and y, as in step  of .","The method shown in  provides an additional checking step, in which a further masking parameter j is drawn on. A first calculation block  corresponds approximately to step  in . In step  the masking parameter j is chosen as a random prime number with a length of, for example, 32 bits (4 bytes). The prime factors p and q are multiplied by the masking parameter j in steps  and  to obtain masked prime factors p\u2032 or q\u2032. In step  a test takes place to check the integrity of key parameters p, q and pinv. If p\u2032\u00b7pinv=j mod q\u2032 applies, the method is continued; otherwise an error jump takes place.","In a second calculation block  a first auxiliary value y is determined according to the formula y:=(x^(dp\/sp)) mod p\u2032. The first auxiliary value y substantially corresponds to the first auxiliary value of the embodiment examples of  and , wherein, however, p\u2032 is drawn on instead of p for the modulo calculation. In detail the calculation takes place in different embodiment variants either as in calculation module  of  or as in calculation module \u2032 of . In both cases a divisibility check is performed to ensure the integrity of key parameters sp and dp.","A third calculation block  corresponds to the second calculation block  with the difference that instead of dp, sp and p\u2032, the values dq, sq and q\u2032 are drawn on to calculate a second auxiliary value y. Again the third calculation block  can be configured either like calculation module  in  or analogously to the representation in . The integrity of key parameters sq and dq is checked by a divisibility test in the third calculation block .","Step  relates to the calculation of an interim result y\u2032 according to the formula y\u2032:=[((y\u2212y)\u00b7pinv) mod q\u2032]\u00b7p+y. This corresponds approximately to step  in . In step  a further test takes place, which relates the calculations so far to one another and identifies interfered with calculation sequences. It is checked whether the following equality relationship modulo j applies:\n\n\u2032 mod =[((^())mod \u2212(^())mod )\u00b7pin+(^())mod mod \n\nIf this equation is not fulfilled, an error termination takes place. Otherwise, the method is concluded in step  with the calculation of the final result y according to y:=y\u2032 mod n, wherein n is the modulus with n=p\u00b7q. Even greater improved protection against cryptographic attacks is achieved in the method according to  by further checking of the calculation sequence in step .\n","The particulars contained in the above description of sample embodiments should not be construed as limitations of the scope of the invention, but rather as exemplifications of preferred embodiments thereof. Accordingly, the scope of the invention should be determined not by the embodiments illustrated, but by the appended claims and their legal equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Further features, advantages and objects of the invention emerge from the following detailed description of several embodiment examples and embodiment alternatives. Reference is made to the schematic drawings.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
