---
title: Key interface for secure object manipulation
abstract: A method and system for controlling access to various tiers of functionality of core software are provided. A software developer/vendor can develop a single version of software having one or more limited-access functionalities and provide the single version of the software to various types of customers. Each customer, using the single version of the core software, may develop additional software that utilizes one or more functionalities of the core software as authorized by the software developer/vendor. Access to a certain functionality or set of functionalities by the customer developed software is obtained by adapting the customer developed software to submit a key, provided by the software developer/vendor, to the core software through, for example, an application programming interface (API) of the core software. The core software is adapted to verify the provided key and, if the provided key is correct, allow the customer developed software access to the corresponding one or more functionalities of the core software.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08504479&OS=08504479&RS=08504479
owner: Conexant Systems, Inc.
number: 08504479
owner_city: Newport Beach
owner_country: US
publication_date: 20020829
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["Priority is claimed based on U.S. Provisional Application No. 60\/315,313 entitled \u201cKey Interface for Secure Object Manipulation\u201d filed Aug. 29, 2001.","The invention relates generally to the field of selectively providing secure party access to code, such as functional modules and the like, such as via application programming interfaces (APIs).","Developers and\/or vendors of software often make updates, enhancements, additions, modifications, etc., available to customers, such as by transmission over a network, delivery by mail or courier, and the like. The software made available to customers or potential customers often is contingent upon payment or upon some earlier payment or agreement, such as a purchase and license of some software application. The software made available may include updates, enhancements, additions, and the like, of the software or may be additional functional modules or the like to supplement the performance or capabilities of the core software (herein collectively referred to as \u201cmodifications\u201d of the core software). Further, it is often desirable to provide customers the software in binary form as opposed to source code, when the source code is of a proprietary nature. This allows a customer, through a provided application programming interface (API), to develop additional software and functionality using the provided binary code as a basis without subjecting the underlying operation of the software to scrutiny by the customer as would be possible using the source code.","In many cases, different versions of a software release may include different subsets, or \u201ctiers\u201d, of functionality to accommodate a variety of customers. To illustrate, a software release may have a basic version and an enhanced version that includes additional functionality in excess of the basic version. A typical approach to restrict access to the tiers of functionality is to provide separate versions of the binary code to different customers, each version implementing only the tiers of functionality for which the designated customer is authorized to access. Accordingly, there may be multiple and varied classes of licenses and licensees maintained by a software developer\/vendor for any given software product. Offering multiple variants of code is expensive both in terms of having to test and support multiple variants as well as providing difficulties for customers wanting to add new tiers of functionality in that they are required to integrate a new binary code deliverable in order to change their tiers of functionality. As a result, the developer\/vendor often must expend considerable resources developing, verifying, compiling, maintaining, storing, and\/or servicing the often numerous versions of the core software.","Accordingly, an improved system and a method for restricting access to tiers of functionality in software would be advantageous.","The present invention mitigates or solves the above-identified limitations in known solutions, as well as other unspecified deficiencies in known solutions. A number of advantages associated with the present invention are readily evident to those skilled in the art, including economy of design and resources, greater system performance, flexibility, cost savings, etc.","The present invention provides a method and system that enable software providers or vendors to distribute upgrades, modifications, enhancements, and the like, as well as complete software packages in a secure, controlled manner. The invention enables a software provider to condition the access of its customers or potential customers to the provider's software based on keyed verification via APIs or browsers and other graphical user interfaces (GUIs).","Providers often desire to provide customers with code in binary form as opposed to source code when the source code is of a proprietary nature. One desired benefit of this is to enable the provider's customers, through a given API, to develop additional software and functionality using the provided binary code as a basis, this additional software shall be referred to as a \u201cCustomer Added Service Tier\u201d. Likewise, a provider may establish tiers of functionality in the provided binary code and condition access to each tier separately such as through payment or in accordance with terms of an agreement. Such provider supplied functional tiers shall be referred to as \u201cBinary Service Tiers.\u201d With the Customer Added Service Tiers, customers add their own custom tiers to the binary code based on whether or not they have purchased the right to make such extensions. However, with Binary Service Tiers, the provider supplies its customers with access to additional built-in functionality based on, for example, the customer purchasing access to one or more tiers of functionality. Furthermore, the Customer Added Service Tiers may implement the functionality provided by the Binary Service Tiers.","It is often desirable to prevent access to each tier of functionality (both Customer Added Service Tiers and Binary Service Tiers) by customers who have not paid for that tier of functionality or are otherwise unauthorized. The provider uses Binary Service Tiers to offer separate versions of the same core software, each version implementing only the functional tiers for which that particular customer is to have access. In this manner, the provider can use Binary Service Tiers to restrict customers' ability to create Customer Added Service Tiers, thereby selectively allowing customer extensions or disallow customer extensions.","The processes and methods of the present invention as described herein provide a secure method for controlling access to tiers of functionality. This may be accomplished via a character string and key pair. As part of the API for tier manipulation (contained within the binary code), the customer supplies a tier identifier and a key. The binary code will run a verification process on the tier identifier, generating a verification key. If the customer provided key and the verification key do not match, then the operation is aborted.","The process, program or module for controlling access preferably is contained only in the binary code, thereby preventing the customer from developing new tiers and calculating the associated key. Customers can be provided keys for tiers of functionality for which they have paid or are otherwise authorized to obtain. Although a tier of functionality may be added by a customer, using that new tier can be restricted if the customer has not paid for that capability or is otherwise prohibited.","In one embodiment, a method for controlling access to a certain functionality of a first software is provided. The method comprises the steps of receiving, at the first software, a key associated with at least one desired functionality of the first software, wherein the key is provided by a second software, verifying the key, and allowing the second software to access the at least one desired functionality when the key is verified.","In another embodiment, a system for controlling access to at least one functionality of a first software is provided. The system comprises a key verification module being adapted to verify a key provided by a second software, the key being associated with at least one desired functionality of the first software to be used by the second software and a tier functionality application programming interface (API) being adapted to interface with the second software to provide the at least one desired functionality to the second software. The system further comprises a tier access control module operably connected to the key verification module and the tier functionality API and being adapted to direct the tier functionality API to allow the second software to access the at least one desired functionality of the first software when the key is verified by the key verification module.","In yet another embodiment, a computer readable medium for controlling access to at least one functionality of a first software is provided. The computer readable medium comprises a set of instructions being adapted to manipulate a processor to receive, from a second software, a key associated with at least one desired functionality of the first software. The set of instructions are further adapted to manipulate the processor to verify the key and allow the second software to access the at least one desired functionality of the first software when the key is verified.","In a network gateway of a distributed communications network, a system for controlling access to at least one functionality of a first software of the network gateway is provided in accordance with an additional embodiment. The system comprises a key verification module being adapted to verify a key provided by a second software, the key being associated with at least one desired functionality of the first software to be used by the second software, and a tier functionality application programming interface (API) being adapted to interface with the second software to provide the at least one desired functionality of the first software to the second software. The system further comprises a tier access control module operably connected to the key verification module and the tier functionality API and being adapted to direct the tier functionality API to allow the second software to access the at least one desired functionality when the key is verified by the key verification module.","In another embodiment, an operating system is provided. The operating system comprises a key verification module being adapted to verify a key provided by software external to the operating system, the key being associated with at least one desired functionality of the operating system to be used by the external software, and a tier functionality application programming interface (API) being adapted to interface with the external software to provide the at least one desired functionality of the operating system to the external software. The operating system further comprises a tier access control module operably connected to the key verification module and the tier functionality API and being adapted to direct the tier functionality API to allow the external software to access the at least one desired functionality of the operating system when the key is verified by the key verification module.","In yet another embodiment, a network protocol stack is provided. The network protocol stack comprises a key verification module being adapted to verify a key provided by a component external to the network protocol stack, the key being associated with at least one desired functionality of the network protocol stack to be used by the external component, and a tier functionality application programming interface (API) being adapted to interface with the external component to provide the at least one desired functionality of the network protocol stack to the external component. The network protocol stack further comprises a tier access control module operably connected to the key verification module and the tier functionality API and being adapted to direct the tier functionality API to allow the external component to access the at least one desired functionality of the network protocol stack when the key is verified by the key verification module.","One object of the present invention is to provide a secure method for controlling access to a individual or groups of tiers of functionality that may be used by a customer to develop desired functionality in or as an adjunct to existing base software.","Another object of the invention is to control what tiers of functionality a customer is able to access using provider supplied binary code.","Another object of the present invention is to make it easier for providers to distribute software to their customers in a secure, controlled manner.","Yet another object of the present invention is to allow the customers to access binary code of a provider in a keyed fashion to create customer added service tiers based on accessible binary service tiers.","The present invention may be implemented in graphical user interface (GUI) development kits, such as included in embedded web servers, and may be incorporated into products that include a web-based interface. The present invention may be included in a software package designed to enable a user to create a web-based interface. As such, it might be included in an integrated design employing software in silicon technology, such as products using ISOS\u2122 Software as offered by Globespan Virata Incorporated of Red Bank, N.J., or as an auxiliary part of any software system.","Still further features and advantages of the present invention are identified in the ensuing description, with reference to the drawings identified below.","The following description is intended to convey a thorough understanding of the invention by providing a number of specific embodiments and details involving selectively enabling access via APIs to binary code and its tiers of functionality, such as through the use of keys to gain access to certain functionality. It is understood, however, that the invention is not limited to these specific embodiments and details, which are exemplary only. It is further understood that one possessing ordinary skill in the art, in light of known systems and methods, would appreciate the use of the invention for its intended purposes and benefits in any number of alternative embodiments, depending upon specific design and other needs. The present invention may be used in conjunction with a wide variety of APIs and programming languages, including, but not limited to, Java, C, and C++.","Referring now to , a flow diagram illustrating an exemplary process to control access to various functionalities of a single build of binary code is illustrated. In the illustrated exemplary embodiment, a customer develops software (customer developed software ) to implement a subset of the functionality of core software  provided by a software developer\/vendor. The core software  may be provided to the customer as binary code or other preferred format, thereby limiting the ability of the customer to discern the proprietary processes performed by the core software . The terms \u201ccore software\u201d and \u201ccustomer developed software\u201d are used in the following to distinguish between two sets of software, the \u201ccore software\u201d including software having one or more limited-access tiers of functionality and the \u201ccustomer developed software\u201d including software that utilizes one or more of these tiers. To illustrate, the core software  could include an operating system (OS) and the customer developed software could include a software application external to the OS that is adapted to utilize one or more functionalities of the OS to perform one or more tasks.","As discussed above, tiers of functionality can include Customer Added Service Tiers (i.e., functionality developed and added by a customer as part of the customer developed software ) and Binary Service Tiers (i.e., functional tiers developed in the original core software ). In the example of , the core software  provides two Binary Service Tiers: binary tier  and binary tier . Similarly, in this example, the customer developed software  includes two Customer Added Service Tiers: customer tier  and customer tier . Each tier of functionality includes a subset of the total functionality provided by core software  and\/or customer developed software .","The subset of functionality associated with each tier can be mutually exclusive of the functionality of other tiers; the functionality of tiers may overlap; the functionality of one tier can be a subset of the functionality of another tier; or a combination thereof. For example, assume that the core software  has twenty functions that the customer developed software  can access through one or more APIs. In this case, the binary tier  could include, for example, ten of the functions and the binary tier  could include the remaining ten functions. Alternatively, the binary tier  could include, for example, 12 functions and the binary tier  could include the remaining eight functions in addition to six of the functions also available through the binary tier . Furthermore, the binary tier  could include all twenty functions while the binary tier  could include only five of the functions, thereby making the binary tier  a subset of the binary tier .","By associating various subsets of the overall functionality in different functional tiers, the developer\/vendor of the core software  can provide various subsets of functionality to different customers. In one embodiment, key verification is utilized to limit access to a functional tier to only those customers that are authorized, such as by purchase or by license agreement, to access the corresponding functional tier.  illustrates an exemplary process of accessing the functionality provided by tiers , , , and\/or , described in more detail in the following paragraphs.","Initially, the developer\/provider of the core software  provides one or more keys (key , for example) to the customer for the tiers of functionality purchased by the customer or otherwise assigned to the customer. Using the access to the tiers of functionality afforded by the corresponding keys, the customer then can develop software (customer developed software ) to interface with the public APIs provided by the core software .","Accordingly, in at least one embodiment, the customer developed software  includes a key registration module  adapted to provide an identifier  associated with a desired functional tier and the corresponding key  to the core software  using a key API . The identifier , in one embodiment, includes a reference to the tier of functionality the customer is attempting to access, such as a name, number, or other identifier associated with the desired tier.","To illustrate, the binary tier  could include a functional tier identified as \u201cbasic I\/O\u201d that encompasses a basic set of input\/output (I\/O) related functions and the binary tier  could include a functional tier identified as \u201cenhanced I\/O\u201d that includes the basic set of I\/O functions as well as additional I\/O functions. In this case, the key registration module  could pass the character string \u201cbasic I\/O\u201d as the identifier  and the associated key  provided by the developer to the key API  in order to access the functionality provided by the binary tier  or the key registration module  could pass the character string \u201cenhanced I\/O\u201d as the identifier  and the associated key  to access the functionality of the binary tier . The key  associated with a given functional tier can include any variety of representations of keys known to those skilled in the art, such as a string of characters, a string of numbers, a binary sequence, or a combination thereof. As discussed in greater detail below, the key  can be generated using a random number, generated from the identifier associated with the functional tier, or may be generated using other acceptable techniques.","In this example, the key API  provides the identifier\/key to a key verification module , whereby the key verification module  performs a key verification process using the customer supplied identifier\/key to verify that the supplied key matches the actual key associated with requested tier of functionality. In one embodiment, the key verification process includes generating a verification key based on a calculation performed on the provided identifier  and then comparing the verification key with the passed key  to determine if there is a match. In another embodiment, the key verification module  includes, for example, an array or table of verification keys associated with the different functional tiers. When an identifier  and key  are provided by the customer developed software , the key verification module , in this case, accesses the verification key from the array using the identifier  as the index. The verification key from the array is then compared to the provided key  to determine a match. In either case, if the provided key  and the generated key\/stored key match, the key  is considered verified. Otherwise, the key  is considered unverified.","Since knowledge of the underlying key verification process may enable unauthorized access to the tiers of functionality provided by the core software , it may be desirable to prevent customers or other third parties from understanding the key verification process performed by the key verification module . Accordingly, in at least one embodiment, the key verification process used by the key verification module  is implemented entirely in the core software . The key verification module , in this case, appears as a \u201cblack box\u201d to the customer, whereby an identifier  and\/or key  are input by the customer developed software  and an indicator of the validity (i.e., verified or unverified) of the supplied key is output, without the customer having knowledge of the verification process performed.","In the event that the provided key  is successfully verified by the key verification module , the key verification module  then signals the tier access control module , which then enables access to the tier of functionality represented by the provided identifier  and verified key . In one embodiment, the tier access control module  is adapted to enable access to a functional tier by providing a signal to the tier functionality API . The signal indicates that the customer developed software  is authorized to implement the functionality of the approved tier once authorized access to the appropriate binary tier(s) is achieved.","The tier functionality API  may be implemented in a variety of ways. For example, in one embodiment, a different tier functionality API  is implemented for each functional tier. In this case, the tier access control module  can enable the customer developed software  to use the tier functionality API  of a given functional tier, for example, by changing the value of a variable accessible to both the tier functionality API  and the tier access control module  (e.g., changing the value of a variable \u201cenabled\u201d from \u201cfalse\u201d to \u201ctrue\u201d). In another embodiment, the core software  includes a number of tier functionality APIs , each API  may be associated with a subset of the functionality of a given tier. In this case, each tier of functionality is represented by a combination of one or more tier functionality APIs . The tier access control module  can enable access to a given tier of functionality by enabling each API  associated with the functionality of the given tier. In another embodiment, the tier functionality API  may be implemented to access the functionality of more than one functionality tier. In this case, the tier access control module  can enable access to a given tier of functionality by directing the API  to allow the customer developed software  access to a subset of the functions interfaced via the API , the subset of functions being representative of the functionality of the desired tier.","After the tier access control module  has directed the tier functionality API  to allow the customer developed software  access to the indicated functional tier, the customer developed software  then can exploit the permitted functionality of the core software  using the tier functionality API  as an interface between the customer developed software  and the core software .","As discussed above, the key verification module  is adapted to use one or more key verification processes to verify the key  provided by the key registration module  of the customer developed software . Any of a variety of key verification processes may be implemented. For example, in one embodiment, the developer\/vendor of the core software  can generate keys using, for example, a random number generator and assign each random-number key to a different tier of functionality. In this case, the developer can provide the random-number key associated with a certain functional tier to a customer. The customer may then adapt the key registration module  of the customer developed software  to provide the random-number key (key ) to the key API  in order to gain access to the corresponding functional tier. The key verification module  then compares the provided key to its version of the key to determine a match. However, it will be appreciated that a key verification process using stored keys may require an excessive amount of memory to store the core software , especially in the event that a relatively large number of functional tiers are implemented by the binary code.","In another embodiment, the key verification process is based on a key developed from a calculation or other manipulation performed using the provided identifier  associated with the desired functional tier. An exemplary key verification process using a provided identifier is illustrated in the following pseudocode function \u201cCompareKey\u201d:",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"bool CompareKey (string Name, int ProvidedKey)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"int CalculatedKey = y1;","\/\/initialize CalculatedKey"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ to arbitrary value y1"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int Index;"]},{"entry":[{},"int RNum[8] = { x0, x1, x2, x3, x4, x5, x6, x7 }"]},{"entry":[{},"for (i = 0; i<strlen(Name); i++ )"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Mask off 3 bits to get index into RNum"]},{"entry":[{},"Index = Name[i] & 0\u00d707;"]},{"entry":[{},"CalculatedKey = Calculated Key +(Name[i]*RNum[Index]);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"if (ProvidedKey == CalculatedKey) return True"]},{"entry":[{},"else return False;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} \/\/End CompareKey"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In the above function \u201cCompareKey\u201d, the verification key (the integer \u201cCalculatedKey\u201d) is generated using the identifier  (the character string \u201cName\u201d) provided by the key registration module  and an array \u201cRNum\u201d having eight random numbers x0-x7. The initial value of CalculatedKey is set to an arbitrary number y1. The resulting value of CalculatedKey is then compared with the value of the key  (the integer \u201cProvidedKey\u201d) provided by the key registration module . If the value of CalculatedKey is equal to the value of ProvidedKey (i.e., the provided key  matches the generated verification key), the function CompareKey returns the Boolean value \u201cTrue\u201d, verifying that the provided key  matches the verification key and access to the corresponding functional tier therefore should be granted. Otherwise, the function CompareKey returns the Boolean value \u201cFalse\u201d, indicating that the provided key  does not match the verification key and that access to the functional tier by the customer developed software  should be denied.","The key provided to a customer for gaining access to a certain tier of functionality can be generated using the same process and values for y1 and the array RNum used to generate the CalculatedKey value using the identifier  (the character string \u201cName\u201d) associated with the certain tier. Accordingly, rather than storing a separate verification key for each functional tier, the function CompareKey can be used to verify customer-provided keys for some or all of the functional tiers implemented by the core software . Although a number of exemplary key verification processes have been discussed, other key verification processes may be implemented without departing from the spirit or the scope of the present invention.","The present invention may be implemented in any of a variety of software environments wherein access to certain functionalities of a core software are limited based on the authorization obtained by a user\/customer\/developer of the core software. To illustrate, the exemplary key verification process and system described above may be implemented as part of an operating system (OS) of, for example, customer premises equipment (CPE) in a communications network, such as a DSL modem or optical network termination (ONT). The developer of the OS can generate one or more keys associated with one or more limited-access functionalities of the OS. Other developers desiring to design \u201cexternal\u201d software (i.e., software that is not part of the provided OS software) that expands upon the capabilities of the OS (e.g., by adding a graphical user interface or implementing expanded features of the CPE) can obtain the key(s) associated with the one or more desired limited-access functionalities to be used in the external software. The developer may then adapt its software to provide these one or more keys to the OS to gain access to the desired functionality or set of functionalities for use by the external software. Additional exemplary implementations of the system and method of  are illustrated below with reference to .","Referring now to , an exemplary distributed network  implementing restricted functionality access is illustrated in accordance with at least one embodiment of the present invention. The network  includes one or more network devices - connected to an external network  (e.g., a wide area network) via a network gateway . The network devices - can include any of a variety of user devices adapted to communicate via a communications network, such as a desktop computer, a laptop computer, a wireless personal digital assistant, a cell phone, and the like. The gateway  is adapted to facilitate communication between the network devices - and devices on the external network  and can include any of a variety of network gateway devices implemented to connect devices on one network to another network, such as a digital subscriber line (DSL) modem, a cable modem, a dial-up modem, a router, a switch, a hub, and the like. The gateway  can include a CPE device located at the end-user of the network, such as a DSL modem, or an intermediary device located between the end user and the corresponding device on the external network , such as a router.","The gateway  includes a network processor  (e.g., the HELIUM\u2122  network processor available from Globespan Virata Incorporated of Red Bank, N.J.) adapted to facilitate the transfer of data between the network interface  (e.g., a Utopia interface) connected to the external network  and the network interfaces ,  connected to one or more of the network devices -. The network processor  (or another processor of the gateway ) is further adapted to support the execution of an embedded web server  (one embodiment of the core software  of ).","The embedded web server , in one embodiment, is utilized to generate and provide one or more web pages , such as a hypertext markup language (HTML) page, an extensible markup language (XML) page, and the like, to an administrator or other user. The web page  includes information representing the status and\/or operation of one or more of the components of the gateway  and may include one or more customer-configurable features, such as operation parameters\/indicators, web page logos, and the like. For example, the web page  can include indicators of the status of the network processor , the local interfaces -, the external interfaces , and the like. As such, the administrator or other user can use the web page  provided by the web server  to monitor the operation of the gateway , change various operational parameters, and the like.","As will be appreciated, the embedded web server  and the network processor  may be implemented in a variety of gateways  having different configurations. Therefore, the software developer\/vendor of the embedded web server  typically desires to minimize the effort and expense to develop, maintain, verify, and provide different versions of the embedded web server  for different customers. Accordingly, the developer\/vendor can implement the present invention to provide a core software product for the embedded web server  having the overall functionality to support the wide variety of possible gateway configurations while limiting the developers of the gateway (i.e., the customers of the embedded web server ) to only those subsets\/tiers of functionality to which the gateway developers are authorized to access, such authorization may result from a license agreement or payment to the embedded web server developer.","To illustrate, consider the following example. In this example, assume that the developer of the embedded web server  has incorporated two tiers of functionality, a \u201cstandard\u201d tier and an \u201cenhanced\u201d tier. The standard tier, for instance, includes functional support for a single local interface (interface  in this example, such as an Ethernet interface) whereby the device driver (one embodiment of the customer developed software  of ) of the interface  is allowed to register various classes with a class register  associated with the embedded web server , the classes being representative of various aspects of the operation of the interface . For example, one of the classes could include a \u201cphysical layer\u201d class used to indicate the connection status of the physical layer of the interface. Furthermore, the standard tier of functionality allows the device driver for the interface  to write various class values to the class register , where the class values represent a status or other indicator of the corresponding aspect of the interface . The embedded web server  uses the classes and the class values in the class register  to generate the web page  indicating the operation\/status of the various components of the gateway . For example, using information provided by the device driver of the interface , the web page  can generate an interface status section  of the web page  for displaying information regarding the interface .","While the use of a single local interface  may be sufficient for some implementations of the gateway , in other implementations gateway developers may desire to add an additional local interface , such as a universal serial bus (USB) interface, to the gateway  for use by the network device . Accordingly, in this example, the enhanced tier of functionality implemented by the embedded web server  includes functional support of a second local interface (interface ). In a similar manner as the standard tier of functionality, the enhanced tier of functionality allows the device driver for the interface  to register various classes associated with the interface  to the class register  as well as write\/update values associated with the registered classes. The embedded web server  then can use the information supplied by the device driver of the interface  to the class register  to generate an interface status section  for displaying information relating to the interface .","For any of a variety of reasons, the developer of the embedded web server  may desire to limit access to the enhanced tier of functionality to a select subset of customers. Accordingly, the web server developer can generate an identifier and a key for the enhanced tier of functionality and supply the identifier and\/or key to each of the authorized customers. The authorized customer then can implement the key registry module  () into the device driver (one example of the customer developed software , ) for the local interface . The key registry module  of the device driver supplies the identifier and key to the key verification module  () of the embedded web server  via a key API  () implemented by the embedded web server . The key verification module , using one or more key verification processes described above, verifies the key and informs the tier access control module  () to allow access if the key is verified. The tier access control module  then directs the tier functionality API  () associated with the enhanced tier of functionality to allow access to the class register  by the device driver of the interface .","However, in the event that an unauthorized customer attempts to utilize the functionality of the enhanced tier by providing an incorrect key or no key, the key verification module  detects the incorrect\/nonexistent key and indicates the unverified status of the key to the tier access control module . The tier access control module , noting the key was unverified, can either continue to operate in the default state whereby access to the enhanced tier of functionality is prohibited or the tier access control module  can go even further by directing the tier functionality API  to prohibit access to tiers of functionality that would be otherwise accessible.","After the device driver for the local interface  is allowed access to the class register , the device driver can register classes associated with the local interface  as well as update the values associated with the classes. Accordingly, when the embedded web server  generates the web page , the embedded web server  can use the classes and class values registered by the device driver for the interface  to generate the interface status section  for review by an administrator or other user.","By using core software (the embedded web server ) having multiple tiers of functionality accessible by different classes of customers, the developer of the embedded web server  can provide the same software to each customer regardless of the access profile of the customer. However, those customers authorized to access the enhanced tier of functionality may adapt the device driver for the additional interface  to provide the key and identifier associated with the enhanced tier to the core software to gain access to the functionality of the enhanced tier. As a result, the developer of the embedded web server  has only one version of the software to maintain. Additionally, as discussed above, in one embodiment, the key associated with a functional tier is generated and verified based on a calculation performed on the identifier associated with the functional tier. In this case, it is unnecessary for the developer of the embedded web server  to maintain a list of keys supplied to customers.","Referring now to , a network protocol stack implementing the exemplary method and system of  is illustrated in accordance with at least one embodiment of the present invention. In the illustrated example, the network protocol stack  is implemented as part of an operating system  of a network processor  of the network gateway , where the network gateway  is adapted to facilitate bidirectional communication between the network device  and an external network  via interfaces , . However, the network protocol stack  may be implemented in any of a variety of applications without departing from the spirit or the scope of the present invention.","The network protocol stack  can include one or a combination of network protocol stacks, such as Telecommunications Protocol\/Internet Protocol (TCP\/IP), Voice over IP (VoIP), Simple Network Time Protocol (SNTP), Utopia, and the like. In at least one embodiment, the network protocol stack  includes a standard tier of functionality available to a base set of customers, as well as one or more limited-access functionalities available to authorized customers. Accordingly, the developer can maintain a single version of the OS  while enabling different levels of functionality of the OS  for different customers.","After receiving a build of the OS  used by the network processor , an authorized customer can develop external software  to operate in conjunction with the OS  to implement the selected limited access functionalities of the network protocol stack . The OS  and external software  then can be loaded into the network processor  for use during operation of the network gateway .","To illustrate, the network protocol stack  could include a TCP\/IP stack having the functionality of a typical TCP\/IP stack in addition to a firewall functionality  for filtering packets between the external network  and the network device . Those customers who desire to use the firewall functionality  in addition to the base TCP\/IP functionality can request a key\/identifier pair from the developer of the OS . After receiving the key\/identifier pair, an authorized customer can adapt their external software  to provide the key\/ID pair to the key verification module  () of the network protocol stack  to enable access to\/operation of the firewall functionality . If the key is verified, the key verification module  directs the tier access control module  () of the network protocol stack  to enable the firewall functionality  for use by the protocol stack  and\/or the external software  via, for example, the tier functionality API  (). Alternatively, the firewall functionality  could be implemented as customer developed software utilizing the functionality of the network protocol stack , wherein the customer developed software is adapted to provide the key\/ID pair to the network protocol stack  to gain access to the data stream (i.e., the desired functionality), which can then be filtered and\/or otherwise processed to provide the firewall functionality .","Other embodiments, uses, and advantages of the invention will be apparent to those skilled in the art from consideration of the specification and practice of the invention disclosed herein. The specification and drawings should be considered exemplary only, and the scope of the invention is accordingly intended to be limited only by the following claims and equivalents thereof."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The purpose and advantages of the present invention will be apparent to those of ordinary skill in the art from the following detailed description in conjunction with the appended drawings in which like reference characters are used to indicate like elements, and in which:",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 3","FIG. 1"]}]},"DETDESC":[{},{}]}
