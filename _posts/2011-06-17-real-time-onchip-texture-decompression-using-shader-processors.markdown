---
title: Real time on-chip texture decompression using shader processors
abstract: A processing unit, method, and medium for decompressing or generating textures within a graphics processing unit (GPU). The textures are compressed with a variable-rate compression scheme such as JPEG. The compressed textures are retrieved from system memory and transferred to local cache memory on the GPU without first being decompressed. A table is utilized by the cache to locate individual blocks within the compressed texture. A decompressing shader processor receives compressed blocks and then performs on-the-fly decompression of the blocks. The decompressed blocks are then processed as usual by a texture consuming shader processor of the GPU.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09378560&OS=09378560&RS=09378560
owner: Advanced Micro Devices, Inc.
number: 09378560
owner_city: Sunnyvale
owner_country: US
publication_date: 20110617
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF EMBODIMENTS OF THE INVENTION","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","This disclosure relates generally to graphics processing, and in particular to a processing unit, method, and medium of texture decompression.","2. Description of the Related Art","Computer graphics processing systems process large amounts of data, typically with a graphics processing unit (GPU) performing a large percentage of the processing. A GPU is a complex integrated circuit that is configured to perform, inter alia, graphics-processing tasks. For example, a GPU may execute graphics-processing tasks required by an end-user application, such as a video-game application. The GPU may be a discrete device or may be included in the same device as another processor, such as a central processing unit (CPU).","A GPU produces the pixels that make up an image from a higher level description of its components in a process known as rendering. GPU's typically utilize a concept of continuous rendering by the use of computing elements to process pixel, texture, and geometric data. The computing elements may execute the functions of rasterizers, setup engines, color blenders, hidden surface removal, and texture mapping. These computing elements are often referred to as shaders, shader processors, shader arrays, shader pipes, shader pipe arrays, shader pipelines, or a shader engine, \u201cshader\u201d being a term in computer graphics referring to a set of software instructions or a program used by a graphics resource primarily to perform rendering effects. \u201cShader\u201d may also refer to an actual hardware component or processor used to execute software instructions. A shader processor or program may read and render data and perform any type of processing of the data. GPU's equipped with a unified shader also simultaneously support many types of shader processing, from pixel, vertex, primitive, and generalized compute processing.","Much of the processing involved in generating complex graphics scenes involves texture data. Textures may be any of various types of data, such as color, transparency, lookup tables, or other data. In some embodiments, textures may be digitized images to be drawn onto geometric shapes to add visual detail. A large amount of detail, through the use of textures, may be mapped to the surface of a graphical model as the model is rendered to create a destination image. The purpose of texture mapping is to provide a realistic appearance on the surface of objects. Textures may specify many properties, including colors, surface properties like specular reflection or fine surface details in the form of normal or bump maps. A texture could also be image data, color or transparency data, roughness\/smoothness data, reflectivity data, etc. A \u2018texel\u2019 is a texture element in the same way a \u2018pixel\u2019 is a picture element. The terms \u2018texel\u2019 and \u2018pixel\u2019 may be used interchangeably within this specification.","In 3D computer graphics, surface detail on objects is commonly added through the use of textures. For example, a 2D bitmap image of a brick wall may be applied, using texture mapping, to a set of polygons representing a 3D model of a building to give the 3D rendering of that object the appearance that it is made of bricks. Providing realistic computer graphics typically requires many high-quality, detailed textures. The use of textures can consume large amounts of storage space and bandwidth, and consequently textures may be compressed to reduce storage space and bandwidth utilization.","Texture compression has thus become a widely accepted feature of graphics hardware in general and 3D graphics hardware in particular. The goal of texture compression is to reduce storage and bandwidth costs on the graphics system while retaining as much of the quality of the original texture as possible. The compression and decompression methods described herein may be used to compress various types of texture information including image data, picture data, transparency information, smoothness or roughness data, or any other similarly structured data. As such, the term texture is used broadly herein to refer to the data being compressed or decompressed as part of a GPU.","Fixed-rate compression schemes have traditionally been used to compress textures and may generally suffer from several shortcomings as compared to variable-rate schemes. Unlike fixed-rate compression, variable-rate compression is more flexible and may allow for adjustments to quality as desired. For example, variable-rate compression may be set to achieve lossless compression. In some cases, the use of variable-rate compression schemes may provide better compression than traditional fixed-rate compression schemes. A variable-rate compression scheme, such as Joint Photographic Experts Group (JPEG), is typically not used for texture compression when on-the-fly decompression is desired due to the high complexity and implementation cost. Therefore, there is a need in the art for methods and mechanisms to enable low-cost on-the-fly decompression of variable-rate compressed textures.","In view of the above, improved processing units, methods, and mediums for performing real time decompression of compressed textures are desired.","Various embodiments of processing units, methods and mediums for decompressing texture data are contemplated. In one embodiment, a first shader of a plurality of shaders may require a block of a texture to produce data used by a display device or in further processing. The first shader may be configured to calculate a virtual address of the block within an uncompressed version of the texture and convey the virtual address with a request for the block to a cache memory device. In response to determining an uncompressed version of the block is not stored in the cache, a second shader of the plurality of shaders may be initiated as a decompressing shader and the virtual address of the uncompressed version of the block may be passed to the decompressing shader. Also, in response to determining the uncompressed version of the block is not in the cache, a cache line may be allocated for the requested block.","The second shader may be configured to receive the compressed version of the block from the cache. The cache may be configured to utilize a table which maps a virtual address space of an uncompressed version of the texture to an address space of a compressed version of the texture. The cache and\/or the second shader may be configured to determine the location and size of the compressed version of the block from the table. The table may also contain additional information, such as the value of the DC coefficient of a compressed version of each block of the texture.","After receiving the compressed version of the block from the cache, the second shader may be configured to decompress the compressed version of the block and then write a decompressed version of the block to the cache. After the decompressed version of the block has been written to the cache, the first shader may be configured to receive the decompressed version of the block from the cache. The first shader may then be configured to process the decompressed version of the block such that it may be applied to a rendered surface for display.","These and other features and advantages will become apparent to those of ordinary skill in the art in view of the following detailed descriptions of the approaches presented herein.","In the following description, numerous specific details are set forth to provide a thorough understanding of the methods and mechanisms presented herein. However, one having ordinary skill in the art should recognize that the various embodiments may be practiced without these specific details. In some instances, well-known structures, components, signals, computer program instructions, and techniques have not been shown in detail to avoid obscuring the approaches described herein. It will be appreciated that for simplicity and clarity of illustration, elements shown in the figures have not necessarily been drawn to scale. For example, the dimensions of some of the elements may be exaggerated relative to other elements.","This specification includes references to \u201cone embodiment\u201d or \u201can embodiment.\u201d The appearances of the phrases \u201cin one embodiment\u201d or \u201cin an embodiment\u201d do not necessarily refer to the same embodiment. Particular features, structures, or characteristics may be combined in any suitable manner consistent with this disclosure.","Terminology. The following paragraphs provide definitions and\/or context for terms found in this disclosure (including the appended claims):","\u201cComprising.\u201d This term is open-ended. As used in the appended claims, this term does not foreclose additional structure or steps. Consider a claim that recites: \u201cA GPU comprising a plurality of shaders . . . \u201d Such a claim does not foreclose the GPU from including additional components (e.g., a texture unit, input\/output circuitry, etc.).","\u201cConfigured To.\u201d Various units, circuits, or other components may be described or claimed as \u201cconfigured to\u201d perform a task or tasks. In such contexts, \u201cconfigured to\u201d is used to connote structure by indicating that the units\/circuits\/components include structure (e.g., circuitry) that performs those task or tasks during operation. As such, the unit\/circuit\/component can be said to be configured to perform the task even when the specified unit\/circuit\/component is not currently operational (e.g., is not on). The units\/circuits\/components used with the \u201cconfigured to\u201d language include hardware\u2014for example, circuits, memory storing program instructions executable to implement the operation, etc. Reciting that a unit\/circuit\/component is \u201cconfigured to\u201d perform one or more tasks is expressly intended not to invoke 35 U.S.C. \u00a7112(f), for that unit\/circuit\/component. Additionally, \u201cconfigured to\u201d can include generic structure (e.g., generic circuitry) that is manipulated by software and\/or firmware (e.g., an FPGA or a general-purpose processor executing software) to operate in manner that is capable of performing the task(s) at issue. \u201cConfigure to\u201d may also include adapting a manufacturing process (e.g., a semiconductor fabrication facility) to fabricate devices (e.g., integrated circuits) that are adapted to implement or perform one or more tasks","\u201cFirst,\u201d \u201cSecond,\u201d etc. As used herein, these terms are used as labels for nouns that they precede, and do not imply any type of ordering (e.g., spatial, temporal, logical, etc.). For example, in a processor having eight processing elements or cores, the terms \u201cfirst\u201d and \u201csecond\u201d processing elements can be used to refer to any two of the eight processing elements. In other words, the \u201cfirst\u201d and \u201csecond\u201d processing elements are not limited to logical processing elements 0 and 1.","Referring to , a block diagram of one embodiment of a computer graphics system is shown. Computer graphics system  includes computing system  and display device . Computing system  includes a graphics processing unit (GPU)  for processing graphics data. In some embodiments, GPU  may reside on a graphics card within computing system . GPU  may process graphics data to generate color and luminance values for each pixel of a frame for display on display device . GPU  may include one or more processing cores and\/or an array of shaders to perform pixel manipulations.","Computing system  may include a software program application , an application programming interface (API) , and a driver , which may run on a CPU (not shown). API  may adhere to an industry-standard specification, such as OPENGL\u2122 or DIRECTX\u2122. API  may communicate with driver . Driver  may translate standard code received from API  into a native format of instructions understood by GPU . GPU  may then execute the instructions received from driver .","Textures may be transferred to GPU  from system memory (not shown) or another storage device of computing system . In one embodiment, textures may be compressed using JPEG compression. In other embodiments, other types of variable-rate compression may be used to compress the textures. For the remainder of this specification, examples of JPEG type encoding will be used to describe the various embodiments. However, this is for illustrative purposes only, and other types of variable-rate compression may also be used with the methods and mechanisms described herein.","Driver  may reformat compressed textures as part of a tiling process. This reformatting may entail transcoding a JPEG-compressed texture into a hardware internal JPEG format. In other embodiments, the JPEG-compressed texture may be transcoded into other formats. The hardware internal JPEG format may contain additional information to facilitate the decompression process. For example, the hardware internal JPEG format may include a table with information on the location and sizes of the various blocks of the JPEG-compressed texture. The table may also include information on the DC coefficients of each 8\u00d78 block of the JPEG-compressed texture. The table may further include Huffman codes, quantization tables, and other information to facilitate the decompression of the compressed texture. Driver  may also allocate a virtual address space for each of the compressed textures utilized by computing system . The size of each virtual address space may correspond to the size of the uncompressed texture.","Computing system  will typically have various other devices\/components not shown in , such as a CPU, buses, memory, peripheral devices, etc. For example, computing system  may include an I\/O interface which may be coupled to other devices, such as a keyboard, printer, and mouse, in addition to display device . In some embodiments, computing system  may include a plurality of GPU's.","In another embodiment, a processor, such as GPU , may be defined in software. The software instructions may be stored in a computer readable storage medium and when executed on a computing device, may define the processor. In a further embodiment, processors may comprise GPU's, CPU's, video processing units (VPU's), coprocessors, and\/or other types of processors that are configured to process texture data. In various embodiments, the GPU and CPU may be separate integrated circuit devices\/packages. In various embodiments, the GPU and CPU may be included in a single integrated circuit or package.","Referring to , a block diagram of one embodiment of a GPU  is shown. GPU  may be utilized to perform graphics-processing related tasks (e.g., using vertex shaders, geometry shaders, pixel shaders, etc.) and general-computing tasks (e.g., mathematical algorithms, physics simulations, etc.). In the example shown, GPU  includes shader processor array , command processor , texture memory , and memory controller  which may be configured to support direct-memory access (DMA). It is noted that the embodiment of GPU  depicted in  is for illustrative purposes only, and those skilled in the art will appreciate numerous alternative embodiments are possible. All such alternative embodiments are contemplated. Note also that GPU  may include many other components not shown in .","In the embodiment shown, shader processor array  comprises multiple processing units which may perform in parallel. Command processor  may issue commands and assign processing tasks to individual shader processors of shader processor array . In some embodiments, command processor  may include a dispatch processor (not shown) configured to divide a received workload into threads and distribute the threads among processing units of the shader processor array. Shader processor array  may be configured to perform various types of functions, including processing texture data and performing rendering algorithms to transform 3-dimensional texture objects into a 2-dimensional image. As noted above, shader processor array  may include a plurality of shader processors, and the plurality of shader processors may implement algorithms using a wide range of mathematical and logical operations on vertices and other texture data.","In some embodiments, GPU 200 may be configured to utilize one or more on-chip and\/or off chip memories for temporarily storing data. While such memories may be referred to herein as \u201ccaches\u201d, it is noted that the use of such a term does not necessarily require any particular organization, structure or policies for such memories. For example, while such memories may utilize organizations and policies typically associated with central processing unit (CPU) caches\u2014such as set associative organizations and replacement policies, any desired organization and\/or storage policies may be utilized. In various embodiments, texture memory  is used for storing texture data. In such an embodiment, texture memory  may provide faster access to certain texture data, such as texture data that is frequently used, than would be possible if the texture data were only stored in system memory  or local memory . System memory  may represent memory accessible by both GPU  and a central processing unit (CPU, not shown), while local memory may represent memory which is directly accessible by only GPU . In various embodiments, texture memory  may include multiple levels in a hierarchical arrangement as is commonly known in the cache arts. The number of such cache levels included in texture memory  may vary from one embodiment to the next. Texture memory  may be implemented using a variety of memory technologies, such as static memory (e.g., SRAM), stacked-memory using dynamic memory (e.g., DRAM), or otherwise. Texture memory  may also include caching logic. The caching logic may be configured to cache data into texture memory  and to implement cache management policies that consider the relative latency and\/or bandwidth of cache system  versus system memory .","GPU  may also include memory controller . Memory controller  may be coupled to system memory  and local memory . Memory controller  may access data, such as compressed textures , in system memory . Compressed textures  may include a plurality of textures which may be compressed with any of a variety of variable-rate compression techniques, such as JPEG. Compressed textures , or portions of individual textures within compressed textures , may be transferred to texture memory  and shader processor array  of GPU  (via memory controller ) without first being decompressed. Host driver  may transfer commands and data to GPU  via system memory . Local memory  may be utilized for storing vertex data and other data used by GPU , and GPU  may write frame data to local memory .","Referring now to , a block diagram of one embodiment of a graphics processing system is shown. Graphics processing system  may include shader controller , and shader controller  may assign specific graphics processing tasks to individual shader computing units within shader array . Shader controller  may perform pre-processing on graphics-processing tasks and general-computing tasks, and issue these tasks to shader array . Shader controller  may identify which processing elements of the shader array are available to process new workloads, and shader controller  may send the new workloads to the available processing elements of shader array . Shader controller  may keep track of which workloads are being processed by the different processing elements of the shader array, enabling a plurality of threads to execute in parallel.","Shader array  may include texture consuming shader  and decompressing shader , which are representative of any number and type of shader processors which may be included in shader array . In various embodiments, shader array  may include an additional shader processor which may be configured to generate texture data procedurally. Generally speaking, procedural texture generation refers to the process of generating a texture algorithmically. In various embodiments this procedural generation of texture is performed dynamically rather than in advance. Shader array  may be used for texture mapping and producing image data for a display device, among other tasks. As part of performing these operations, texture consuming shader  may issue a texture request to texture filter . The texture request may be for one or more portions (e.g., blocks, texels) of the texture. Texture filter  may generate a virtual address for the requested texture, and convey the virtual address with the request to cache . Cache  may store textures in the form of texel data associated with pixels. Some of the textures may be compressed, and some of the textures may be uncompressed.","After receiving the virtual address from texture filter , cache  may perform an address check against all known virtual address ranges to determine if the requested texture is stored in cache . If an uncompressed version of the requested texture is stored in cache , cache  may return the uncompressed version of the texture to texture filter . If the uncompressed version of the texture is not stored in cache , the attempted request may result in a cache miss. In response to a cache miss, decompressing shader  may be initiated for the purpose of decompressing a compressed version of the texture. In various embodiments, shader array  may receive a request from cache , or otherwise, to initiate a decompressing shader. Also in response to a cache miss, texture consuming shader  may pass the virtual address of the texture to decompressing shader . Resources for the decompressing shader program may be pre-allocated on decompressing shader  to decrease the shader start latency and simplify resource management. The request may be routed to a particular shader processor of shader array  based on the virtual address of the block being requested.","Cache  may be queried for a compressed version of the texture, and if the compressed version of the texture is stored in cache , the compressed version of the texture may be returned to decompressing shader . If the compressed version of the texture is not stored in cache , the compressed version of the texture may be retrieved from system memory or another location. Decompressing shader  may also receive additional tables, textures, and\/or constants to facilitate the decompression operation. Decompressing shader  may decompress some additional compressed data necessary to decompress the requested texture. In the case of a JPEG-compressed texture, the texture may be transcoded from the original code to a new encoding scheme, and the new encoding scheme may be designed to make decompression more efficient. After decompressing shader  has received and decompressed the compressed version of the texture, texture consuming shader  may utilize the decompressed version of the texture for the appropriate rendering calculations. This process may continue for a plurality of textures and\/or portions of textures. In another embodiment, the functions described as being performed by texture filter  may be performed by shader array , and shader array  may be coupled directly to cache .","Cache  may utilize a table to determine the address to which a given virtual address maps for the compressed versions of textures stored in cache . In various embodiments, the table (or portions thereof) may be stored in cache  or elsewhere. In one embodiment, the table may map a virtual address to another address of the compressed version of a texture. The address to which the virtual address is mapped may or may not itself be a virtual address. Numerous options for the types of addressing schemes utilized are possible and are contemplated. The table may store an offset for each block of the compressed version of the texture, wherein the offset gives the location from the beginning of the compressed version of the texture to the block. In various embodiments, the table may facilitate random access to the blocks of one or more compressed textures. The cache logic of cache  may determine an address of a given block in response to a request for the compressed version of the block. The cache logic may use the table to determine an offset at which the desired block is stored within a page or fetch unit of the cache. The plurality of shaders of shader array  may also use the table to determine the offset of a requested block of a texture. In various embodiments, cache  may utilize a plurality of tables with mapping information on a plurality of textures.","After the texture data has been processed, shader array  may convey the image data to render unit . Render unit  may assign a specific number value that defines a unique color attribute for each pixel of an image frame. The number values may be passed to frame buffer  where they may be stored for use at the appropriate time, such as when they are rendered on display device .","On a subsequent operation, texture consuming shader  may be configured to perform the functions of a decompressing shader, and decompressing shader  may be configured to perform the functions of a texture consuming shader. Each shader processor of shader array  may be configured to perform a variety of functions depending on the requirements of the current operation.","In various embodiments, load balancing may be utilized to assign decompression tasks to underutilized shaders. Also, some space may be reserved in a number of compute units to allow decompression shaders to be launched on a number of compute units. Furthermore, multiple decompression requests may be packed into single instruction multiple data (SIMD) vectors. The SIMD vectors may facilitate the decompression of multiple blocks in one vector. In one embodiment, 16 blocks may be decompressed in one vector, with one block per four lanes.","In various embodiments, graphics processing system  may enable on-the-fly procedural generation of texture data. One shader may generate on-the-fly texture data, and a second shader may utilize the generated texture data for rendering operations. A decompressing shader may access compressed data and another shader may be utilized to decompress additional data, such as one or more tables. Some of the compressed data may be compressed using a variety of compression techniques. In various embodiments, the decompressing shader may request data from the cache, and in response to a cache miss, another shader may be initiated to procedurally generate texture data.","Turning now to , a block diagram of one embodiment of a data cache is shown. Cache  may contain portions of textures  and , which are representative of any number of portions of textures which may be stored in cache . Textures  and  may be compressed textures, while the plurality of textures stored in cache  may be a mix of compressed and uncompressed textures. Texture  may include blocks  and , which are representative of any number of blocks of texture . Texture  may also include table , which may map a virtual address space of texture  to an address space of compressed texture . Texture  may be organized similarly to texture . In another embodiment, table  may be stored separately from texture .","When a texture consuming shader requests a block of a texture from cache , and the request results in a cache miss, cache  may allocate cache line  for the requested block. Cache  may convey the address of the allocated cache line to a decompressing shader. After the decompressing shader has decompressed the compressed block corresponding to the requested block, the decompressing shader may be configured to write the decompressed block to cache line . Alternatively, the decompressing shader may write the decompressed block to various locations within cache . In response to the decompressing shader writing the decompressed block to cache line , the texture consuming shader may be configured to fetch the decompressed block from cache . The corresponding latency compensation queues may need to be extended to accommodate the larger latency resulting from the on-the-fly decompression of the compressed block.","After the decompressed version of the block has been written to cache line , cache  may store the compressed version of the block and the decompressed version of the block. In various embodiments, cache  may execute a retention policy that discards one of the versions of the block in response to determining both versions are stored in cache . In one embodiment, the decompressed version of the block may be discarded after it has been fetched by the texture consuming shader. In another embodiment, the compressed version of the block may be discarded after the decompressed version of the block has been written to cache . In a further embodiment, both the compressed and decompressed version of the block may be maintained in cache  for an extended period of time.","In response to a request for an uncompressed version of a block of a texture, cache  may determine that the uncompressed version is not stored in cache . In various embodiments, in response to such a determination, cache  may automatically search for the compressed version of the block. If the compressed version of the block is stored in cache , cache  may notify a shader or other processing unit and\/or cache  may convey the compressed version of the block to the shader or other processing unit.","In some embodiments, in response to a cache miss on a request for an uncompressed block, a separate software thread may be started, and the thread may initiate a decompressing shader. The texture consuming shader may convey the virtual address of the block to the decompressing shader. In various embodiments, when the shader finishes the decompression task, the decompressing shader may convey the uncompressed block(s) to the cache. In other embodiments, when the decompressing shader finishes the decompression operation, the decompressing shader may convey the shader output to the texture consuming shader.","Referring now to , a block diagram of one embodiment of a block mapping table is shown. Table  may store mapping information for the plurality of blocks of texture  (of ). In various embodiments, table  may be organized in a variety of ways with other types of information in addition to what is illustrated in . For example, in one embodiment, table  may include a DC coefficient value for each block of texture .","Table  may map the virtual address space of texture  to the physical address space of compressed texture  (of ). A decompressing shader (not shown) may fetch or otherwise receive one or more blocks of texture  from cache , and the decompressing shader may determine the location and size of the compressed blocks from table . The size of a compressed block may be determined by calculating the difference between the starting physical addresses of two adjacent blocks. In other embodiments, additional data may be provided to indicate size and\/or location information for blocks. Further, the decompression shader may obtain additional information from table , such as a DC coefficient value of each block.","In some embodiments, the texture may be organized according to superblocks. A superblock may be a set of 16 8\u00d78 blocks, which is a tile of 32\u00d732 pixels, for a total of 1024 pixels. The index table for the texture may include a table entry for each superblock, and each table entry may give the address of the start of each superblock. In one embodiment, this address may be the location of the superblock within the texture. In another embodiment, this address may be an offset from the start of the texture. Each entry may also include a 4-bit index of the first 8\u00d78 block belonging to the superblock. In some embodiments, superblocks may not be aligned with 2 kilobit (Kb) boundaries of the cache. Each entry may also include a 16-bit mask. The 16-bit mask may include one bit per block indicating whether that block starts in the next 2 Kb word.","In some embodiments, the decompressing shader may transform the virtual address of the 8\u00d78 block into the virtual address of a 32\u00d732 superblock to calculate an entry number of the index table for lookup purposes. The decompressing shader may lookup the entry of the index table corresponding to the superblock. The index table may be processed by a shader in a similar manner as other textures. The entries of the index table may be cached and processed.","From each index table entry, the shader may obtain the base address, which may be a virtual address. The base address may be of the first fetch unit of the compressed superblock. The shader may also obtain the offset of the fetch unit containing the requested block which needs to be decompressed. The shader may also calculate if the block is compressed or not based on the address of the block. Certain address ranges may correspond to virtual addresses of uncompressed blocks, and other address ranges may correspond to physical addresses of compressed blocks. The shader may be able to distinguish between the different address ranges.","Referring now to , a block diagram of one embodiment of a virtual address space for an 8\u00d78 block of texels is shown. Each texel may be mapped to a unique address within virtual address space . Texel  may be mapped to address , texel  may be mapped to address , and so on, for all 64 texels of 8\u00d78 block . Block  may be a block within a compressed texture, and virtual address space  may be allocated for block  of the compressed texture. The texture may include a plurality of blocks in addition to block . Virtual address space  may also include a unique address for each texel of the plurality of blocks in the texture.","For purposes of illustration, it will be assumed that an uncompressed texel is a 32-bit value (4 sets of 8-bit values). Other sizes of uncompressed texels may also be utilized with the methods and mechanisms described herein. For example, an uncompressed texel with a 24-bit value may be handled in a similar way. In various embodiments, a texture consuming shader may generate requests for individual texels. First, the shader may compute the virtual address of a texel. Then, the cache may be queried for the virtual address corresponding to the texel.","Turning now to , a block diagram of one embodiment of compressed data is shown. Data portion  may be a unit of fetch of the compressed data, and the size of data portion  may be based on the size of an uncompressed block. In one embodiment, a fetch unit may be of size 2 Kb. In other embodiments, a fetch unit may be any of various sizes. A plurality of compressed blocks may be packed into a fetch unit. In one embodiment, the maximum number of blocks that may be packed into a fetch unit may be assumed to be 16. In other embodiments, other numbers of blocks may be packed into a fetch unit. For one type of cache access scheme, it may be assumed that the data of the blocks do not cross boundaries of fetch units.","A block may be the smallest decodable unit of a compression format, such as JPEG. For JPEG, the block is an 8\u00d78 pixel tile (with 64 pixels). When a texture is compressed, and a block of the texture requested by a shader needs to be decompressed, a cache line may be allocated in the cache for the block. In one embodiment, the cache line size may be 2 Kb to store an entire uncompressed block (32 bits*64=2 Kb). In other embodiments, the cache line size may be any of various sizes.","If a fetch unit contains an uncompressed block, then only one block may fit in the fetch unit. For a fetch unit containing compressed blocks, the fetch unit may also include a 176-bit header. The fetch unit may be assumed to have a capacity of 16 blocks. The header may include 16 11-bit offset values to indicate the locations of the compressed blocks within the fetch unit. The offsets reference the starting bit positions of the blocks. In other embodiments, there may be a variable number of offset indicators in the header.","As shown in , data portion  may include header  and blocks -. Blocks - may be sixteen different blocks of a compressed texture. Header  may include offsets -. Each offset may be an 11-bit offset value corresponding to the location of the corresponding block within data portion . In other embodiments, other bit-sizes of offset values may be utilized. Offset  may represent the starting address of block , offset  may represent the starting address of block , and so on. In some embodiments, there may be an additional offset indicating the last bit of the last block, to reduce unnecessary fetch from the cache.","In some embodiments, compressed 8\u00d78 blocks of the texture may be packed and cross fetch unit boundaries. The corresponding information, showing that the block uses two fetch units, may be stored in an index table, and a decompressing shader may generate two fetches instead of one for blocks that cross fetch unit boundaries.","Turning now to , one embodiment of a method for decompressing a compressed block of a texture is shown. For purposes of discussion, the steps in this embodiment are shown in sequential order. It should be noted that in various embodiments of the method described below, one or more of the elements described may be performed concurrently, in a different order than shown, or may be omitted entirely. Other additional elements may also be performed as desired.","The method  starts in block , and then in block , a first shader of a plurality of shaders may determine the need for a block of a texture as part of the rendering operations for an image. The first shader may be a texture consuming shader. Next, the first shader may calculate the virtual address of the block (block ). The first shader may have an uncompressed view of the texture, corresponding to the uncompressed version of the texture, and the virtual address may correspond to the location of the requested block within the uncompressed view. After block , the first shader may request the block from the cache and convey the virtual address with the request (block ). Next, the cache may determine if an uncompressed version of the block is stored in the cache (conditional block ). If the uncompressed version of the block is stored in the cache, the first shader may receive the uncompressed version of the block from the cache and process the block (block ).","If the uncompressed version of the block is not stored in the cache, a second shader of the plurality of shaders may be initiated as a decompressing shader (block ). The resources for the decompressing shader may be pre-allocated on one or more shader processors to decrease the shader start latency and simplify resource management. Also, the virtual address of the requested block may be passed from the first shader to the second shader. Next, a cache line may be allocated for the requested block (block ). Then, the cache may determine if a compressed version of the block is stored in the cache (conditional block ). In various embodiments, the cache may make this determination in response to a request by the second shader for the compressed version of the block. In other embodiments, the cache may make this determination automatically in response to determining the uncompressed version of the block is not stored in the cache (conditional block ).","If the compressed version of the block is stored in the cache (conditional block ), then the cache and\/or second shader may determine the location and size of the compressed version of the block from the table (block ). If the compressed version of the block is not stored in the cache (conditional block ), then the compressed version of the block may be fetched (e.g., from local or system memory) and stored in the cache (block ). Fetching the compressed version of the block from system memory may entail fetching the entire compressed texture or some portion of the texture. The cache may be configured to utilize a table which maps the virtual address space of an uncompressed version of the texture to an address space of a compressed version of the texture. The cache and\/or second shader may determine the location and size of the compressed version of the block from the table (block ). The table may also contain additional information, such as the value of the DC coefficient of a compressed version of each block of the texture. After block , the compressed version of the block may be conveyed to the second shader from the cache (block ).","In another embodiment, if the compressed version of the block is not in the cache (conditional block ), steps , , and  may be replaced with alternate steps. In the alternate steps, the compressed version of the block may be fetched from system memory and provided directly to the second shader. These alternate steps may be more efficient than having the second shader receive the compressed version of the block from the cache. In a further embodiment, the compressed version of the block may be fetched from system memory and provided directly to the second shader while also being written to the cache.","After the second shader receives the compressed version of the block (block ), the second shader may decompress the compressed version of the block (block ). Next, the second shader may write the decompressed version of the block to the cache (block ). Then, the first shader may receive the decompressed version of the block from the cache and process the block as part of the rendering operations for the current image (block ). After block , the method may end in block . Method  may be repeated for a plurality of blocks from a plurality of textures.","Although the features and elements are described in the example embodiments in particular combinations, each feature or element can be used alone without the other features and elements of the example embodiments or in various combinations with or without other features and elements. The present invention may be implemented in a computer program or firmware tangibly embodied in a non-transitory computer-readable storage medium having machine readable instructions for execution by a machine, a processor, and\/or any general purpose computer for use with or by any non-volatile memory device. The computer-readable storage medium may contain program instructions which are operable to enable the functions, methods, and operations described in this specification. Suitable processors include, by way of example, both general and special purpose processors.","Typically, a processor will receive instructions and data from a read only memory (ROM), a RAM, and\/or a storage device having stored software or firmware. Storage devices suitable for embodying computer program instructions and data include all forms of non-volatile memory, including by way of example semiconductor memory devices, read only memories (ROMs), magnetic media such as internal hard disks and removable disks, magneto-optical media, and optical media such as CD-ROM disks and digital versatile disks (DVDs).","The above described embodiments may be designed in software using a hardware description language (HDL) such as Verilog or VHDL. The HDL-design may model the behavior of an electronic system, and the design may be synthesized and ultimately fabricated into a hardware device. In addition, the HDL-design may be stored in a computer product and loaded into a computer system prior to hardware manufacture.","Types of hardware components, processors, or machines which may be used by or in conjunction with the present invention include Application Specific Integrated Circuits (ASICs), Field Programmable Gate Arrays (FPGAs), microprocessors, or any integrated circuit. Such processors may be manufactured by configuring a manufacturing process using the results of processed hardware description language (HDL) instructions (such instructions capable of being stored on a computer readable media). The results of such processing may be maskworks that are then used in a semiconductor manufacturing process to manufacture a processor which implements aspects of the methods and mechanisms described herein.","Software instructions, such as those used to implement image rendering calculations and shader tasks, may be stored on a computer-readable storage medium. A computer-readable storage medium may include any mechanism for storing information in a form (e.g., software, processing application) readable by a machine (e.g., a computer). The computer-readable storage medium may include, but is not limited to, magnetic or optical media (e.g., disk (fixed or removable), tape, CD-ROM, DVD-ROM, CD-R, CD-RW, DVD-R, DVD-RW, or BLU-RAY\u2122), RAM (e.g., synchronous dynamic RAM (SDRAM), double data rate (DDR, DDR2, DDR3, etc.) SDRAM, low-power DDR (LPDDR2, etc.) SDRAM, Rambus DRAM (RDRAM), static RAM (SRAM)), ROM, non-volatile memory (e.g. Flash memory) accessible via a peripheral interface such as the USB interface, micro-electro-mechanical systems (MEMS), and storage media accessible via a communication medium such as a network and\/or a wireless link.","Although several embodiments of approaches have been shown and described, it will be apparent to those of ordinary skill in the art that a number of changes, modifications, or alterations to the approaches as described may be made. Changes, modifications, and alterations should therefore be seen as within the scope of the methods and mechanisms described herein. It should also be emphasized that the above-described embodiments are only non-limiting examples of implementations."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The above and further advantages of the systems, methods, and mechanisms may be better understood by referring to the following description in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
