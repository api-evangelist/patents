---
title: Applications of an appliance in a data center
abstract: In various embodiments, an appliance may be used to implement various functions. In some embodiments, an appliance may be used with a DBMS server. The appliance may generate a request, and the DBMS server may generate a result. The appliance may transform the result to a different format for return to a requestor corresponding to the request. In still other embodiments, the appliance may be used with a computer system configured to execute other backend applications such as content management systems, filesystems, etc. In other embodiments, the appliance may receive first output data from a first server of a plurality of servers that is to be supplied as first input data to a second server of the plurality of servers. The appliance may be configured to transform the first output data to a first markup language format and to transform the first markup language format to the second format.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07409400&OS=07409400&RS=07409400
owner: Intel Corporation
number: 07409400
owner_city: Santa Clara
owner_country: US
publication_date: 20040712
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims benefit of priority to U.S. Provisional Patent Application Ser. No. 60\/513,850, filed on Oct. 22, 2003, which is incorporated herein by reference in its entirety.","1. Field of the Invention","This invention is related to the field of processing and transforming structured documents, such as extensible markup language (XML), standardized generalized markup language (SGML), hypertext markup language (HTML), and unstructured data and documents in databases and\/or filesystems in a data center.","2. Description of the Related Art","As networking has become ubiquitous, the data center has emerged as an important service to the computing world. Generally, a data center may comprise various servers providing application service to the user, including access to various databases that may be maintained in the data center as well as other application services such as content management services, filesystem services, etc.","Unfortunately, various applications may generate data in different formats and\/or in a different format than that desired by the user. Furthermore, different users may desire different formats for their data. Accordingly, application servers, web servers, and\/or the user's computer system may often be tasked with converting between various formats. The conversion software consumes computing resources, reducing the effectiveness of the servers at the tasks for which they were originally designed. Additionally, the latency experienced by the user when using the services of the data center may be increased.","In some embodiments, an appliance and method is contemplated for use with a computer system executing a database management system DBMS. The appliance is configured to generate a request. The computer system is coupled to the appliance to receive the request, and the DBMS is configured to process the request in at least one of the one or more databases. The computer system is configured to return a result of the request to the appliance in a first format. The appliance is configured to transform the result to a second format for return to a requester corresponding to the request. An apparatus comprising the appliance and the computer system is also contemplated. In still other embodiments, the appliance may be used with a computer system configured to execute other backend applications such as content management systems, filesystems, etc.","In other embodiments, an appliance and method may be used with a plurality of servers. The an appliance coupled to the plurality of servers, and may receive first output data from a first server of the plurality of servers. The first output is to be supplied as first input data to a second server of the plurality of servers, wherein the first output data is in a first format different than a second format used by the second server for the first input data. The appliance is configured to transform the first output data to a first markup language format and to transform the first markup language format to the second format. An apparatus comprising the appliance and a plurality of servers is also contemplated.","In yet further embodiments, the appliance may implement other functions in a datacenter or other computing facility. For example, the appliance may implement a rendering engine, an XML router, a firewall (e.g. virus detection), etc.","While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.","Appliance Overview","Turning now to , a block diagram of one embodiment of an appliance  is shown. In the embodiment of , the appliance  may include a network interface circuit , one or more processors such as processors A and optionally B, a document processor , and a memory . The network interface circuit  is coupled, via one or more network connections, to a network or networks. Various computer systems (not shown in ) may also be coupled to the network or networks. The network interface circuit  is also coupled to the processors A-B. The processors are coupled to the memory  and to the document processor , which is also coupled to the memory . In the illustrated embodiment, the memory  stores a stylesheet compiler , a schema compiler , one or more symbol tables , one or more parse-time expression trees , an instruction table , a whitespace table , document type definition (DTD) tables , an expression list table , a template list table , various document processor data structures , and optionally other software .","Generally, the appliance  may be configured to provide one or more services for other computer systems that may be included in a data center. Various examples given below may include a database proxy, a rendering engine, a data integration switch, a markup language router, and a firewall, although these examples are not intended to be exhaustive. The appliance  may include hardware\/software designed to transform input documents to output documents, in some cases according to a transformation specified by a stylesheet. The various services handled by the appliance  may, in some cases, use the transformation functionality to accomplish the desired services. The appliance  may be used to offload services from servers in a data center, permitting the servers to dedicate more resources to the services that the servers were designed to provide. As used herein, the term \u201cappliance\u201d may refer to any combination of hardware and optionally software that is sold as a unit for installation on a network. The appliance may typically be designed to be installed on the network with relatively little, if any, configuration (as compared to a general purpose computer system such as a server or personal computer, for example), and may typically be designed to operate with relatively little, if any, support. If software is included in the appliance, the software is typically preinstalled in the appliance (although software upgrades may be downloaded to the appliance or additional software may be installed onto the appliance, in some embodiments, via the network). An administrator may access the appliance, in some embodiments, via the network (e.g. a web browser interface may be provided).","As used herein, the term \u201cdocument\u201d refers to any content that has a corresponding defined structure that can be used to interpret the content. The content may be highly structured (such as an XML document, HTML document, pdf document, word processing document, database, etc.) or may be as simple as a plain text document (whose structure may be, e.g., a stream of characters) or data (whose structure may be, e.g., a set of data items arranged in a particular order). Examples of various applications of the appliance  described below may provide document content that comprises a request (e.g. to access a database), data, or other types of documents.","In some cases, the appliance  may receive, via the network connections, stylesheets to be applied to documents, schema to be applied to documents, and\/or the documents themselves (with a request to apply a stylesheet\/schema to the document). In response to a request to apply a stylesheet, the appliance  may apply the stylesheet to the document and generate a transformed document to be transmitted through the network to the request or (or to another destination specified by the request or). In some embodiments, the appliance  may also receive a request to parse a document (e.g. into a defined format such as simple application programming interface (API) for XML (SAX) or document object model (DOM)). In response to a request to apply a schema (or DTD), the appliance  may validate the document according to the schema or DTD and generate a success message or a fail message (with an indication of the failure) to the requestor.","In other cases, the appliance  may receive a request, and may include other software  to interpret the request. The appliance  may generate communications to other network devices (e.g. servers) based on the request, and may also use the transformation functionality to aid in handling the request.","In one embodiment, the transformation functionality may be optimized for XML documents and the corresponding XML stylesheet language for transformation (XSLT). Additional details related to XML and XSLT stylesheets are given below. XSLT is based on the XPath language for expressions. XQuery, an additional language being developed that is based on XPath, may also be used in other embodiments. Still further, other embodiments may be based on any markup language and corresponding expression languages. Generally, a \u201cmarkup language\u201d is any language that may be used to define the structure of a document's content. The markup may generally include various tags that identify content and may provide information about the nature of the content. For example, XML permits element tags to be defined, which may be used to describe the structure of the content. Additionally, elements may include various attributes which further describe the element or provide additional information about the content.","An XML document has a hierarchical tree structure, where the root of the tree identifies the document as a whole and each other node in the document is a descendent of the root. Various elements, attributes, and document content form the nodes of the tree. The elements define the structure of the content that the elements contain. Each element has an element name, and the element delimits content using a start tag and an end tag that each include the element name. An element may have other elements as sub-elements, which may further define the structure of the content. Additionally, elements may include attributes (included in the start tag, following the element name), which are name\/value pairs that provide further information about the element or the structure of the element content. XML documents may also include processing instructions that are to be passed to the application reading the XML document, comments, etc. Generally, a \u201cnode\u201d of a document may include structural definition (e.g. elements and\/or attributes in XML) and\/or document content. In one embodiment, a node may include elements, attributes, processing instructions, comments, and text.","An XSLT stylesheet may be viewed as a set of templates. Each template may include: (i) an expression that selects nodes in the source document's tree structure; and (ii) a body that specifies a corresponding portion of the output document's structure to be instantiated for each matching node of the source document. Applying a stylesheet to a source document may comprise attempting to find a matching template for each node in the source document, and instantiating the body of the matching template in the output document's tree. The body of the template may include one or more of: (i) literal content to be instantiated in the output document; (ii) selection of content from the matching nodes to be copied into the output document; and (iii) statements that are to be evaluated, with the result of the statements being instantiated in the output document. Together, the content to be instantiated and the statements to be evaluated may be referred to as \u201cactions\u201d to be performed on the nodes that match the template. The body of the template may include one or more \u201capply templates\u201d statements, which include an expression selecting one or more nodes and causing the templates in the stylesheet to be applied to the selected nodes, thus effectively nesting the templates. If a match to the apply templates statement is found, the resulting template is instantiated within the instantiation of the template that includes the apply templates statement. Other statements in the body of the template may also include expressions to be matched against nodes (and the statements may be evaluated on the matching nodes). While XSLT stylesheets may be used in one example herein, generally a \u201cstylesheet\u201d may comprise any specification for transforming a source document to an output document. The source and output documents may be in the same language (e.g. the source and output documents may be different XML vocabularies), or may differ (e.g. XML to pdf, etc.). Another example of stylesheets may be cascading stylesheets defined for HTML and\/or XML Query.","The expressions used in a stylesheet may generally comprise node identifiers and\/or values of nodes, along with operators on the node identifiers to specify parent\/child (or ancestor\/descendant) relationships among the node identifiers and\/or values. Expressions may also include predicates, which may be extra condition(s) for matching a node. A predicate is an expression that is evaluated with the associated node as the context node (defined below), where the result of the expression is either true (and the node may match the expression node) or false (and the node does not match the expression). Thus, an expression may be viewed as a tree of nodes to be matched against a document's tree. In XPath, the expression language used in XSLT, an expression may be evaluated in the context of a \u201ccontext node\u201d as well (that is, expressions may be relative to the context node, specifying node names in the expression as ancestors, descendents, parents, or children of the context node as well as relationships to other node names). A given document node may satisfy an expression if the given document node is selected via evaluation of the expression. That is, the expression node identifiers in the expression match the given document node's identifier or document node identifiers having the same relationship to the given document node as specified in the expression, and any values used in the expression are equal to corresponding values related to the given document node. A document node may also be referred to as a \u201cmatching node\u201d for a given expression if the node satisfies the given expression. In some cases in the remainder of this discussion, it may be helpful for clarity to distinguish nodes in expression trees from nodes in a document. Thus, a node may be referred to as an \u201cexpression node\u201d if the node is part of an expression tree, and a node may be referred to as a \u201cdocument node\u201d if the node is part of the document being processed. A node identifier may comprise a name (e.g. element name, attribute name, etc.) or may comprise an expression construct that identifies a node by type (e.g. a node test expression may match any node, or a text test expression may match any text node). In some cases, a name may belong to a specific namespace. In such cases, the node identifier may be a name associated with a namespace. In XML, the namespace provides a method of qualifying element and attribute names by associating them with namespace names identified by a universal resource identifier (URI). Thus, the node identifier may be the qualified name (the optional namespace prefix, followed by a colon, followed by the name). A name, as used herein (e.g. element name, attribute name, etc.) may include a qualified name.","In the illustrated embodiment, applying the stylesheets to documents may be performed in the following manner: The stylesheet compiler  may comprise software (i.e. a plurality of instructions) executed on one of the processors A-B to compile the stylesheet into one or more data structures and code for use by the document processor . The document processor  may apply the data structures to the source document and generate the output document.","Particularly, in one embodiment, the stylesheet compiler  may assign serial numbers to node identifiers so that expression evaluation may be performed by the document processor by comparing numbers, rather than node identifiers (which would involve character string comparisons). The stylesheet compiler  may store a mapping of node identifiers to serial numbers in the symbol tables . Additionally, the stylesheet compiler  may extract the expressions from the stylesheet and generate expression tree data structures to be used by the document processor for expression matching (e.g. the parse-time expression tree ). Still further, the stylesheet compiler  may generate an instruction table  with instructions to be executed for each matching expression (and also instructions to be executed to evaluate run-time predicates, in one embodiment). The instructions in the instruction table, when executed by the document processor , may result in performing the actions defined to be executed when the expression is matched. In some embodiments, the instructions may comprise the actions to be performed (i.e. there may be a one-to-one correspondence between instructions and actions). In other embodiments, at least some actions may be realized by executing two or more instructions. The stylesheet compiler  may also generate whitespace tables  defining how various types of whitespace in the source document are to be treated (e.g. preserved, stripped, etc.), an expression list table  and a template list table .","The schema compiler  may similarly comprise instructions executed on one of the processors A-B. The schema compiler  may compile a schema or DTD to generate one or more symbol tables  (replacing node identifiers with serial numbers) as well as the DTD tables . Generally, a DTD or schema may comprise a definition of both the permissible document structure and the required document structure. An author of the document may thus describe, with a DTD and\/or schema, the required and permitted structure of a valid document. In some cases, the DTD or schema may also include default values for attributes. In one embodiment, the DTD\/schema may include a variety of information: entity declarations that are used to replace entity references in the document, attributes of a given element that are required attributes for a valid document, attribute default values for attributes that may not be specified in a given element of the document, requirements for the structure of the document (e.g. a required minimum\/maximum\/specific number of a certain subelement, etc.), and a definition of the permissible structure of the document. The DTD tables  may include a table of the entity reference replacements, a table of the required attributes, a table of the attribute defaults, and a skeleton tree identifying the permissible structure (and required structure, if applicable).","The document processor  may comprise hardware circuitry to parse the document and to match document nodes to expression nodes in the parse-time expression tree. That is, the hardware circuitry that parses the document and matches document nodes to expression nodes may perform these operations without executing any software instructions. The hardware may generate various data structures storing the parsed content and indications, for each expression, of the matching document nodes. The hardware may then execute the instructions from the instruction table  for a given expression on each matching document node of that given expression, generating results which are then combined to produce the output document. Additional details of one embodiment are provided below.","As mentioned above, in the illustrated embodiment, the stylesheet compiler  and the schema compiler  are implemented in software and the document processor  is implemented in hardware. In some embodiments, the critical factor in the performance of the appliance  may be the processing of the document when a transformation request is made and the document is provided. That is, stylesheets and\/or schemas may, in many cases, change relatively infrequently as compared to the number of documents being processed. A given stylesheet may be applied to multiple documents (e.g. at least on the order of tens of documents) prior to the stylesheets being changed (to an updated stylesheet or to a different stylesheet altogether). A similar relationship may hold for schema and the documents to which they are to be applied. Accordingly, capturing the relatively invariant information from the stylesheets\/schema (using software) into data structures that may be efficiently accessed by dedicated, custom hardware may provide a high performance solution. Additionally, having stylesheet\/schema compilation in hardware may provide, in some embodiments, flexibility to implement different stylesheet\/schema languages and\/or to implement changes in the language specifications without having to change the custom hardware. For example, XSLT, XPath, and XML schema may be still evolving, and new features may be added to these languages in the future. The compilers may be adapted to handle these new features. The stylesheet\/schema to be used may be provided beforehand, and thus the time to compile the stylesheet\/schema may be less critical. However, in other embodiments, one or both of the stylesheet compiler  and the schema compiler  may be implemented in hardware, or a combination of hardware and software.","The network interface circuit  may handle the low-level electrical and protocol details on the network connections, and may pass received packets to the processors A-B for processing. Any type of network may be used. For example, in some embodiments, the network connections may be Gigabit Ethernet connections. More than one connection may be provided, as desired, to achieve a given level of bandwidth and\/or to provide redundancy in the network connections.","The processors A-B may comprise any type of processor. For example, in one embodiment, the processors A-B may be PowerPC network processors. In other embodiments, the processors A-B may implement other instruction set architectures such as ARM, Intel's IA-32, MIPS, etc.","Any interconnect may be used to couple the processors A-B, the document processor , and the memory . Furthermore, the processors A-B may be coupled to the document processor  separate from the connection of the processors A-B and the document processor  to the memory . For example, in one implementation, the processors A-B may be coupled to the document processor  using one or more peripheral component interconnect express (PCI-X) buses.","It is noted that, in some cases, a DTD, schema, or stylesheet may be embedded in a document (either directly or as a pointer to the schema or stylesheet). In such cases the DTD, schema, or stylesheet may be extracted from the document and processed as described for a separately-provided schema or stylesheet.","The memory  may comprise any type of volatile or non-volatile memory. For example, the memory  may include one or more of RAM (e.g. SDRAM, RDRAM, SRAM, etc.), non-volatile memory such as Flash memory or battery-backed RAM, magnetic or optical storage such as disk or CD-ROM, etc. The memory  may comprise multiple memories that are separately accessible (e.g. a partition or partitions accessible only to the processors A-B and another partition or partitions accessible only to the document processor ).",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 1","b":["20","22","28","18","20","22","28"]},"In some embodiments, the computer accessible medium may be included in a separate computer system or systems which may execute the stylesheet compiler  and\/or the schema compiler  to perform the compilation. The data structures\/code resulting from the compilation may be communicated to the appliance  (e.g. through the network connection to the appliance ).","It is noted that, while the description herein may include examples in which a stylesheet is applied to a document, other examples may include applying multiple stylesheets to a document (either concurrently or serially, as desired) and applying a stylesheet to multiple documents (either concurrently with context switching or serially, as desired).","Turning next to , a block diagram of one embodiment of the document processor  is shown. In the embodiment of , the document processor  includes a parser circuit , an expression processor , a transformation engine , an output generator , and a validator circuit . The parser circuit  is coupled to the expression processor  and to the output generator . The expression processor  is coupled to the transformation engine , which is coupled to the output generator . The validator  is coupled to the output generator . Units in  may be coupled to each other directly (e.g. using signal lines between the units), may be coupled through the memory  (e.g. a source unit may write information to be communicated to a destination unit to the memory , and the destination unit may read the information from the memory ), or both.","The parser circuit  may receive a document and parse the document, identifying events for the expression processor  and the validator circuit , and also generating data structures with the parsed content. If the document processor  is to transform the document according to a stylesheet, the parsed content may be stored in data structures in memory  for the transformation engine . Alternatively, if the document is to parsed only, the parser circuit  may provide the output generator  with the parsed content to be output in SAX or DOM format. The parser circuit  may provide the output generator  with the parsed content through memory  as well.","In one embodiment, the parser circuit  may accesses the symbol tables , the DTD tables , and the whitespace tables  from the memory . The parser circuit  parses the document and generates events related to the detected document nodes. More particularly, the parser circuit  converts the node identifiers in the document to the corresponding serial numbers in the symbol tables , and transmits the serial numbers as part of the events to the expression processor  (and the validator circuit ). Additionally, the parser circuit  generates parsed content tables storing the parsed content of the document for the transformation engine .","The expression processor  receives events from the parser circuit  (identifying document nodes parsed from the document), and compares document nodes identified by the parser circuit  against the parse-time expression tree . The expression processor  outputs lists of matching document nodes for each expression to the transformation engine . The transformation engine  receives the data structures of parsed content built by the parser circuit  and the lists of matching document nodes, and executes the corresponding instructions from the instruction table  to generate the results for the output document. The transformation engine  may also evaluate any run-time expressions and eliminate document nodes from the template and expression match lists that do not satisfy the run-time expressions. In some embodiments, each instruction may be independent of the others, and thus execution may occur in any order. The output generator  may reassemble the results in order and may write the output document to the memory  (or may send the output document to the processors A-B without passing through the memory ). The processors A-B may execute software to read the output document and transmit the output document to the requester.","In one particular implementation, the parser circuit  may receive the document inline, and the parser circuit  may transmit events to the expression processor  inline as well. That is, as the portions of the document are received and reassembled (e.g. by the processor A), the processor A passes the portion of the document to the parser circuit . The parser circuit  may thus begin parsing prior to the processor A receiving the entirety of the document. Similarly, the events are passed to the expression processor  as they are identified. On the other hand, the parsed content tables and template\/expression match lists are passed through the memory  (indicated by the dotted oval over the communications to the transformation engine ).","The validator circuit  may also receive the events sent by the parser circuit  and may apply the schema\/DTD (as represented by the skeleton tree and DTD tables ), and may determine if the document is valid as indicated in the schema. If the document is valid, the validator circuit  may generate a success message to be transmitted to the output generator . If the document is not valid, the validator circuit  may generate a fail message (indicating the reason(s) for failure) and may transmit the fail message to the output generator . The output generator  may store the message to the memory  (and the processors A-B may subsequently transmit the message to the request or).","Data Center Overview","Turning now to , a block diagram illustrating one embodiment of a data center in which the appliance  may be used for various purposes is shown. The data center may be coupled to the Internet or to any other desired network (e.g. local area network (LAN), metropolitan area network (MAN), wide area network (WAN), wireless network, etc. or any combination of the above networks). The data center may include a firewall  (that may, in some embodiments, include one or more instances of the appliance ), one or more routers  (that may, in some embodiments, include one or more instances of the appliance ), web servers such as web servers A-B, one or more data integration switches  (that may, in some embodiments, include one or more instances of the appliance ), application servers such as application servers A-B, a database proxy  (that may, in some embodiments, include one or more instances of the appliance ), and a server  running a relational database management system (RDBMS).","The couplings shown in  may be logical. That is, various logical communication paths are illustrated in . Thus, the firewall  may be logically coupled to the router(s) , which may be logically coupled to the web servers A-B (and potentially the application servers A-B). The data integration switches  may be logically coupled to the web servers A-B and the application servers A-B. The application server A may be logically coupled to the database proxy , which is logically coupled to the RDBMS server . Physically, the various devices shown in  may be coupled to a network (e.g. LAN, WAN, MAN, wireless, etc., or combinations thereof), to multiple separate networks that are geographically near or geographically distributed, etc. Exemplary networks may include Ethernet networks, Token Rings, etc.","The firewall  may protect the data center from unauthorized access\/attack from the Internet or other network. In some embodiments, the appliance  may be implemented within the firewall  to detect viruses in documents being provided to the data center. An exemplary embodiment is described below with regard to .","The router(s)  may receive packets that pass through the firewall, and may route the packets within the data center to the appropriate receiver (e.g. a web server, application server, etc.). In some embodiments, the appliance  may be used as an XML router, routing XML packets. An exemplary embodiment is described below with regard to .","The web servers, such as web servers A-B, may generally be responsible for supplying web content (e.g. web pages) in response to requests for the web content from the external network (e.g. Internet or other network). In some cases, the web servers may communicate with the application servers if a portion of the web content is drawn from an application (such as the RDBMS).","The application servers, such as application servers A-B, are configured to provide application services. Generally, application servers provide the interface between the backend applications in the data center (e.g. the RDBMS, a content management system, a filesystem, etc.) and the users making requests (e.g. from the Internet or other network).","As mentioned above, in some cases the web servers A-B may communicate with the application servers A-B and vice versa. However, in some cases, the format of the data output by one server and destined for another server may not match the format expected by that other server. The data integration switches  may be used to convert the data format output by a source server to the format required by the destination server. In some embodiments, the appliance  may be used as a data integration switch . An exemplary embodiment is discussed below with regard to .","Generally, as used herein, a \u201cserver\u201d may comprise a computer system that may include software designed to provide the service(s) assigned to the server.","The application server A in the illustrated embodiment is configured to provide application interface to the RDBMS server . However, in some cases, the application server A may be configured to communicate with the RDBMS server  in a different fashion than the RDBMS server  is configured to communicate. For example, the application server A may view the database as XML, whereas the database may have a relational data format. In another embodiment, the database may store XML objects, wherein the content of the object is the data of interest to an application, but the application server A may expect a relational data formatted output (e.g. records, each record having multiple columns, or fields, of information) or other format for the data.","The database proxy  may be included as a \u201cfrontend\u201d to the RDBMS server . The database proxy  may communicate with the application server A in the manner that the application server A expects, and may communicate with the RDBMS server  in the manner that the RDBMS server  expects. The database proxy  may thus convert the communications from one form to another. In some embodiments, the appliance  may be used as a database proxy . Exemplary embodiments are described below with regard to .","The RDBMS server  executes the RDBMS. While the illustrated embodiment may implement a relational database (in which a record is stored in various related tables, to permit flexibility in searching the database for specific records based on different fields), other embodiments may implement non-relational databases (e.g. flat-file databases), if desired. Exemplary RDBMS's may include structured query language (SQL) databases such as Oracle, DB2, etc. Generally, as used herein, a database management system (DBMS) may comprise software that permits entry of data into the database, permits searching of the database, organizes data in the database, etc. An RDBMS is the DBMS software for a relational database.","In other embodiments, a server may execute a content management system (which may manage access and update to content by multiple users, where content may include software source code, documents, or any other data files), a filesystem, etc. and the proxy  may be used as a frontend similar to the database proxy.","It is noted that, while the appliance  is illustrated in various locations in , various embodiments may implement the appliance  at any of one or more of the illustrated locations, as desired. Furthermore, while the applications of the appliance  in  are shown in the context of the data center, each application may be used outside of a data center, in other environments.","Appliance Applications","Turning next to , various applications of the appliance  are illustrated in more detail.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 4","b":["10","60","62","60","10","70","72","10","74","58","76","62","62","78","10","80","58","70","72","10"]},"The request received by the appliance  may be in any format. For example, the request may be an XPath expression or expressions, if the application server A views the database as an XML database. The appliance  may transform the XPath expressions into SQL requests, and may transmit the SQL requests to the RDBMS server . The input stylesheet  may be used for this transformation. Alternatively, the software  may receive the XPath expression(s), and may generate the corresponding SQL statement(s) for each expression. In still other embodiments, the request from the application server may be in the form of a stylesheet that contains several XPath expressions to be applied to the database. The input stylesheet  may be included as part of the request , in some embodiments.","Alternatively, the request may be one or more SQL statements to access the database. The appliance , in this case, may transmit the SQL statements to the RDBMS server . The result  from the DBMS server  may still be transformed by the appliance  to another desired format for the result , in some such embodiments. In still other embodiments, the request may be provided in another format, and the input stylesheet  may be used to transform the input format to one or more SQL statements.","The appliance  may transmit the SQL statements to the RDBMS . For example, the software  may be configured to transmit the statements, whether they are received directly from the requestor or are generated by the appliance  from the input request received from the requester. The RDBMS server  processes the request  and provides the result  in a relational format. For example, the format of the result  may be tabular: a table of records that result from the SQL statements. Each record may have a set of columns, or fields, as defined in the database(s) managed by the RDBMS server . More particularly, at least one of the columns may contain a primary key of the database. Generally, a \u201ckey\u201d may be a field of the database that may be used to sort data. A \u201cprimary key\u201d may be a key that has a unique value in each record in the database. In some cases, the primary key may be one column in the record. In other cases, the primary key may be a combination of two or more of the columns in the record.","The appliance  may transform the result  from the output format of the RDBMS  to the desired format for the result . The output stylesheet  may be used to specify the desired format, in some embodiments. In other embodiments, a default output format may be supported by the appliance . For example, a default XML format may be supported, which is illustrated in . Other embodiments may support a default format in any markup language, or in any other desired format.",{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 5","b":["82","1","1","2","2"]},{"@attributes":{"id":"p-0074","num":"0073"},"figref":["FIG. 6","FIG. 5"],"b":"84"},"In some embodiments, the appliance  may support predefined services. Each service may be loaded onto the appliance , and may include the SQL statements to be transmitted to the RDBMS server  when the service is invoked. The service may specify one or more triggering conditions that cause the service to be invoked, and the appliance  may monitor the triggering conditions to invoke the service. Alternatively, an external event may be used to invoke the service, or an explicit invocation may be transmitted by a user. The service may also, in some cases, specify the receiver of the result, which may be viewed as the request or of the access to the database. The service may include an output stylesheet  or another specification of the output result format. The software  shown in  may include software to support the predefined services, in some embodiments.","Embodiments similar to the embodiment of  may be used as proxies for content management systems or filesystems.",{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 7","FIG. 4","FIG. 4","FIG. 4"],"b":["10","60","62","60","10","70","72","10","74","58","76","10","74","62","78","10","80","58","70","72"]},"In the embodiment of , a database  is shown in the RDBMS server , and the database stores XML objects such as XML objects A-B. Other embodiments may include other markup language objects. As used herein, a markup language object may be a complete markup language structure. Each markup language object may contain a record, multiple records, or a portion of a record, as desired. The database  may store the XML objects as records, or columns of records.","Accordingly, the result  may comprise one or more XML objects from the database . The output stylesheet  may specify the transformation of the XML objects to the desired result format for the result . For example, the desired format may be the records inside the XML objects, in a relational format (e.g. a table of records). Alternatively, XML in a different form than that stored in the database  may be the desired format. In other embodiments, any other format may be used.","In some embodiments, the request  may include one or more SQL statements to be applied to the database  to generate the result , and the appliance may pass the SQL statements on the to the RDBMS server  unmodified. In some embodiments, the request  may include one or both of the stylesheets  and\/or .","In other embodiments, the database  may store XML data in relational form (e.g. index tables on various elements and attributes, etc.) rather than as objects in the database. The database proxy  may still be used in such embodiments to provide transformation of the output data from the database .",{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 8","b":["10","90","90","10","92"]},"Generally, the rendering engine  may extract portions or all of one or more input documents, and construct one or more output documents from the extracted portions. The output documents are then returned to the request or. In some embodiments, the input documents may be transmitted with a request to apply the stylesheets . In other embodiments, the request and\/or stylesheets may identify the documents (e.g. with a uniform resource locator (URL)) and the appliance  may fetch the documents).","In some embodiments, the appliance  may support predefined services loaded into the appliance , similar to the discussion above of the database proxy . The service may define the input document(s), the output document(s), and the stylesheet(s) to be applied. In some embodiments, if more than one distinct output document is to be generated, the rendering engine  may cache the input documents and apply each stylesheet separately to generate a corresponding output document.",{"@attributes":{"id":"p-0085","num":"0084"},"figref":["FIG. 9","FIG. 3","FIG. 9","FIG. 3"],"b":["58","58","56","10","54","54"]},"Each application server A-D may be configured to output data and input data in various formats. For example, the application server A may output data and input data in a format . Similarly, the application server C may output data and input data in a format ; and the application server D may output data and input data in a format . In some cases, the output data format and input data format for a given application server may differ (e.g. the application server B outputs data in a format  and inputs data in a format ). The formats used by the various application servers A-D may differ from each other. Thus, when an application server A-D outputs data that is to be supplied as input data to another application server A-D, the data integration switch  may transform the data from the source application server's output format to the target application server's input format.","More particularly, the appliance  may perform the transformation of the output format to the input format, passing through XML as an intermediate format. That is, the appliance  may covert the data from the source format to XML, and from XML to the target format. A pair of stylesheets may be used for each transformation, one stylesheet that converts from the source format to XML, and another stylesheet that converts from XML to the target format.","In some embodiments, the source data may comprise a set of separate data items arranged in a fashion dictated by the source data format (e.g. a data structure, or an ordered set of data items, or a document of any desired structure such as: email; word processor formats such as Microsoft Word; spreadsheet formats; portable document format (PDF); postscript format; database formats; electronic data interchange (EDI) formats; etc.). The source-to-XML stylesheet may be applied to a source data item to generate one or more XML constructs corresponding to the source data item, and the XML constructs may then be applied to the XML-to-target stylesheet to generate the corresponding target data item. Application of the XML-to-target stylesheet to the XML construct may be performed independent of the transformation of other source data items to XML constructs. For example, the target data item may be generated prior to the generation of XML constructs for at least some of the other source data items. Viewed in another way, application of the XML-to-target stylesheet may begin prior to completion of applying the source-to-XML stylesheet to all of the source data items.","The application of two stylesheets to a data item prior to completion of all data items through the first stylesheet may, in some embodiments, improve the throughput of the data integration switch  and may reduce the response time when individual data items are being transmitted between application servers A-D.",{"@attributes":{"id":"p-0090","num":"0089"},"figref":"FIG. 10","b":["100","102"]},{"@attributes":{"id":"p-0091","num":"0090"},"figref":["FIG. 11","FIG. 2","FIG. 11","FIG. 11"],"b":["16","56","100","102","1","2","44","1","2"]},"The source data is supplied to the parser circuit , which generates source events to the expression processor . The source events may identify data items within the source data. The expression processor  applies the source events to the PET, and generates corresponding matches for each source data time in the source-to-XML stylesheet  to the transformation engine . The transformation engine  executes the instructions from IT to generate the XML construct corresponding to a given source data item. The transformation engine  may generate XML construct events from the XML construct, and may pass those events to the expression processor . The expression processor  may apply the XML construct events to the PET, generating matches for the XML construct events in the XML-to-target stylesheet . The transformation engine  may execute the instructions from IT to generate the output data to the output generator .","In other embodiments, the transformation engine may apply the XML constructs to the XML-to-target stylesheet (e.g. the XML-to-target stylesheet may be implemented entirely in instructions executed by the transformation engine ). In yet other embodiments, the XML construct may be passed from the transformation engine  to the parser circuit , which may parse the XML construct to generate the XML construct events for the expression processor . The software  () may be used to take the XML constructs output by the transformation engine  and generate the XML construct events to the expression processor , in other embodiments.",{"@attributes":{"id":"p-0094","num":"0093"},"figref":["FIG. 12","FIG. 3"],"b":["10","110","110","52","110","10","112"]},"In the XML router , the appliance receives an input XML document and outputs an output XML document and a routing label or location. The routing label identifies the destination for the XML document. For example, the software  on the appliance  may include software to convert the routing label to a destination IP address or addresses (e.g. through a table lookup), and the appliance  may route the output document to the destination IP address or addresses. Alternatively, the routing label may be used by the router(s)  to lookup the destination IP address or addresses, and the router(s)  may route the XML document to the destination IP address or addresses. In yet another alternative, the routing label may be the destination IP address or addresses.","The stylesheet  may include a set of XPath expressions to be applied to the input document, one of which may match a given input document. A corresponding routing label may be determined from the stylesheet. For example, in the illustrated embodiment, the stylesheet  may include a template for each expression (e.g. Exp, Exp, etc.), with the match attribute equal to that expression. The template body may include outputting the routing label (e.g. Routing Label , Routing Label , etc.). Optionally, a stylesheet may also be included in the template body. If a stylesheet is included, the appliance  may apply the stylesheet to the input document to generate the output document. Otherwise, the input document may be supplied unchanged as the output document. In other embodiments, a transformation stylesheet may be applied unconditionally (i.e. not as a function of which expression is matched).","Turning next to , a flowchart illustrating operation of one embodiment of the appliance  when used in a firewall (e.g. the firewall ). In this embodiment, the appliance  may perform document validation against a DTD\/schema and may also perform intrusion detection (e.g. virus detection). In this context, viruses may include viruses as well as worms, Trojan horse software, etc. Generally, viruses may comprise software written with a nefarious intent for the computer system on which the software executes (e.g. destruction of data or software on the computer system, reduction of computer system resources available for other software, etc.), with the intent to replicate to other computer systems, or to execute on the computer system with nefarious intent for another computer system (e.g. launching a denial of service attack).","XML documents may present additional difficulties for virus detection as compared to standard virus detection. In standard virus detection, the incoming bit stream is compared to a database of bit strings of known viruses and, if a portion of the incoming bit stream matches the database, it is identified as a virus. With an XML document, the virus may be distributed across the XML document. For example, portions of the virus may be in different elements. When the elements are combined (e.g. through processing the document by a stylesheet), the virus is created. Still further, the virus may be partly included in the XML document and partly included in a corresponding DTD\/schema (e.g. in an entity reference or attribute default) and\/or stylesheet to be applied to the XML document. Thus, none of the above contain a virus in isolation, but a virus may be created by processing the XML document with the DTD\/schema and\/or stylesheet. In yet another complication, the XML document, the DTD\/schema, and the stylesheet may arrive at different times, thus making a virus distributed among them difficult to detect. An attacker may even write an XML document that, when processed using existing, valid DTD\/schema and\/or stylesheets, creates a virus.","The appliance  may address the virus creation in a two step process. In the first step, the XML document may be validated using the DTD\/schema and transformed using the stylesheet, as needed. The resulting document may then be passed through the appliance  again in the second step, in which case the validator  may check for viruses in the resulting document. For example, the validator  may be provided within a virus database as described above. In other embodiments, coarser levels of intrusion detection may be applied (e.g. traffic from or two certain addresses may be detected).",{"@attributes":{"id":"p-0100","num":"0099"},"figref":"FIG. 13","b":["48","120","122","48","124","126","10","128","10","122","126","130"]},"Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications."],"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EMBODIMENTS"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The following detailed description makes reference to the accompanying drawings, which are now briefly described.",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 6","FIG. 4"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
