---
title: Manager component for managing input from existing serial devices and added serial and non-serial devices in a similar manner
abstract: A manager component for managing input from legacy and non-legacy devices in a similar manner is disclosed. An inventive manager component receives input from both non-legacy input drivers for non-legacy input devices, and legacy input drivers for legacy input devices. The manager component provides the input to application programs that desirably have previously registered to receive input from one or more types of input devices. The application programs receive this input without directly communicating with the drivers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06895589&OS=06895589&RS=06895589
owner: Microsoft Corporation
number: 06895589
owner_city: Redmond
owner_country: US
publication_date: 20010604
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF INVENTION","SUMMARY OF INVENTION","DETAILED DESCRIPTION"],"p":["This patent application is related to, and claims benefit and priority of, the previously filed provisional patent application entitled \u201cIncorporation of Generic Input and Window Manager,\u201d which was filed on Jun. 12, 2000, and assigned Ser. No. 60\/211,007.","This invention relates generally to input from legacy devices, such as pointing devices and keyboards, and non-legacy Human Input Devices (HID's), such as devices having Universal Serial Bus (USB) connectivity, IEEE-1394 connectivity, or another type of connectivity. More particularly, the invention relates to managing input from both such devices in a similar manner to provide to application programs.","Historically, the primary input devices for computers have been a keyboard and a pointing device, the latter typically being a mouse. Within a graphical user interface, the mouse is used to navigate a cursor, such as a pointer, on the screen. When a cursor is positioned over a desired graphical user interface element, such as a window or a button, one or more different pointing device buttons can be actuated to select the element. For example, pressing the left pointing device button over a button displayed on the screen causes the button to be selected in some operating systems. The keyboard, which has been a primary input device for computers even longer than the pointing device, is used mainly for achieving text entry.","Keyboards and pointing devices have traditionally connected to serial ports on the back of computers. These serial ports may be general-purpose serial ports, but more usually they are special-purpose serial ports, in that there is one serial port dedicated to the keyboard, and another for the pointing device. While serial ports come in many different form factors, currently the most popular form factor is known as PS\/2, such that keyboards and pointing devices are said to have PS\/2 connectors. Because of the ubiquity and long-term use of such keyboards and pointing devices, they are referred to as legacy devices.","Legacy devices are devices that, because of their ubiquity and long-term use in the industry, generally always are supported by operating systems and application programs. Most operating systems, for example, assume that a keyboard and a pointing device is connected to the computer on which they are running for the user to provide input. There are very few, if any, modern operating systems and application programs that do not assume the presence of a keyboard and a pointing device for providing input to the computer. To this extent, driver programs have been written especially for keyboards and pointing devices, and application programs have grown accustomed to dealing with keyboards and pointing devices in a usual way.","However, more recently, other types of input devices have become popular. Generally, these types of input devices are referred to as non-legacy devices. They are non-legacy devices because they are newer than legacy devices, and are not always supported by operating systems and application programs. As a class of devices, they are non-legacy input devices referred to as Human Interface Devices (HID's). Typically, non-legacy devices use a newer connector than the serial ports that are ubiquitous with PS\/2-type keyboards and pointing devices. For example, they may have Universal Serial Bus (USB) connectivity, or IEEE-1394 connectivity, which is also referred to as FireWire or iLink connectivity. Paradoxically, such non-legacy devices may still include keyboards and pointing devices, but where the keyboards and pointing devices have a USB, IEEE-1934, or another type of connector, instead of a PS\/2 connector. Other non-legacy devices include wheels, such as are found on pointing devices, touch-sensitive pads for achieving handwriting input, game controllers, and other types of input devices.","Because of the increasing number of such non-legacy input devices, operating systems and application programs have a difficult time accommodating them. The typical paradigm for managing input from non-legacy input devices is for the application programs to directly communicate with the device drivers for such devices. This is as opposed to how application programs communicate with legacy input devices, where they usually receive input therefrom through a manager component of the operating system. Unfortunately, current state of the art is such that, to accommodate new non-legacy input devices, operating systems have to be revised, where only a new version of an operating system can accommodate a new device. This is problematic for application programs desiring to use the new devices in the context of older versions of the operating systems, because they must then manage input from the drivers themselves, instead of relying on the operating system. This adds complexity to the development of application programs, as well as increased overhead not well suited for application programs.","The diagram of  illustrates a prior art system  in which the divergent approach for managing non-legacy devices is shown. The operating system environment  includes memory divided into a user mode  and a kernal mode . The kernel mode  is the specially protected part of the operating system's memory that is inhabited by special programs like the drivers , , and . Conversely, the user model  is the general part of the operating system's memory in which the application programs  reside, as well as some parts of the operating system itself, such as the prior art manager component .","As shown in , the keyboard  and the mouse  send input to the prior art manager component  through the keyboard driver  and the mouse driver , respectively. The prior art manager component  is the established mechanism for handling input from legacy devices such as the keyboard  and the mouse . The application programs  have come to rely on the existence of the manager component  as the way by which they receive keyboard and mouse input. The prior art manager component  itself includes the necessary overhead for communicating with the legacy device drivers  and , such that the application programs  do not have to concern themselves with this overhead.","Conversely, non-legacy devices, such as the HID's , do not send input to the prior art manager component  through their drivers . Instead, the application programs  must directly interface with the HID drivers  to receive input from the non-legacy devices. This means that the overhead necessary for learning of new non-legacy devices that are plugged in while the computer is running, as is allowed, for example, with USB and IEEE-1394 devices, must be handled by the application programs  themselves. Each of the application programs  must be developed to accommodate this overhead. Furthermore, when more than one of the application programs  tries to receive input from the same one of the devices , problems may arise. This is because some of the application programs  may be developed such that they do not count on other of the programs  attempting to receive input from the same device. Whereas the prior art manager component  manages this situation for legacy devices, it does not for non-legacy devices.","For the reasons described here, therefore, as well as for other reasons, there is a need for the present invention.","The invention relates to a manager component for managing input from both legacy and non-legacy input devices in a similar manner. An inventive manager component receives input from both non-legacy input drivers for non-legacy input devices, and legacy input drivers for legacy input devices. The manager component provides the input to application programs that desirably have previously registered to receive input from one or more types of input devices. The application programs receive this input without directly communicating with the drivers.","The inventive manager component can provide the input from the non-legacy input drivers according to a pre-existing manner in which the application programs had previously received only the input from the legacy input drivers. In this way, the manager component leverages the pre-existing manner for providing the input from the legacy input drivers. The application programs are spared from having to manage the overhead for receiving input from non-legacy input devices. The inventive manager component can provide the input from both the non-legacy and the legacy input drivers such that the application programs receive the input from both types of drivers in an integrated, identical manner. New non-legacy input devices can be added to the system without requiring revision of the manager component, the operating system, or the application programs.","Besides those described in this summary, other aspects, embodiments, and advantages of the invention, will become apparently by reading the detailed description of the invention, and by referencing the accompanying drawings.","In the following detailed description of exemplary embodiments of the invention, reference is made to the accompanying drawings that form a part hereof, and in which is shown by way of illustration specific exemplary embodiments in which the invention may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention. Other embodiments may be utilized, and logical, mechanical, electrical, and other changes may be made without departing from the spirit or scope of the present invention. The following detailed description is, therefore, not to be taken in a limiting sense, and the scope of the present invention is defined only by the appended claims.","Integrated Manner for Managing Input from Legacy and Non-Legacy Input Devices","FIG. () shows a diagram  illustrating the integrated manner for managing input from legacy and non-legacy input devices. The operating system environment  includes memory divided into the user mode  and the kernal mode . The non-legacy input devices , also referred to as human input devices (HID's), send their input to the non-legacy device drivers . Conversely, the legacy devices  and , specifically a keyboard and a pointing device, such as a mouse, respectively, send their input to the legacy drivers  and . The inventive manager component  receives the input from the non-legacy device drivers , as well as the legacy device drivers  and . The component  manages this input, and provides the input to the application programs . The component  provides the input to the application programs  in a similar way, regardless of whether the input is from the non-legacy devices , or the legacy devices  and .","The input is sent from the manager component  to the application programs  as an input message. The input message allows the sending of raw data from the non-legacy devices  and the legacy devices  and  to the application programs . Raw data is data that is received from the devices ,, and  that has not been translated after receipt. The input message used to send input is preferably a pre-existing manner by which input from the legacy devices  and  were sent to the application programs . The invention leverages this pre-existing manner to also send messages regarding input from the non-legacy devices  to the application programs . That is, messages regarding input from the non-legacy devices  are sent in the same way as messages regarding input from the legacy devices  and . The application programs  thus receive input from the non-legacy devices  without directly communicating with the non-legacy device drivers .","In order to receive messages from a type of device, the application programs  initially register as to the type of input device from which they wish to receive input. The registration process is shown as the method  of FIG. (). The registration process is performed by the manager component . First, it is determined whether a given application program, or more specifically a particular process of an application program, has already registered for receiving messages (). An application program can include one or more different processes, where each process is a part of the application program. If the process has not yet registered for receiving messages, then registration is enabled for the process ().","Next, the type of device that the application program wishes to register for is identified (), and this device type is stored (). The type of device that the application wishes to register for in  is also referred to as the top-level collection, where the top-level collection identifies a type of human input device based on the usage page and usage identified in the report descriptor. The device type is stored in  within a global device request list, for example, as well as a per-process request list. The global device request list is a list of all the devices that have been requested by processes of application programs. The per-process request list is a similar list, but is specific to a given process as to the devices that have been requested by that process.","If the process is already registered for this type of device (), then the specific device that the process is registering is identified as a legacy device or a non-legacy device (). If the device is a non-legacy device, then the device is handled as a non-legacy device (). Any parameters associated with the registration for this device are updated accordingly. If the device is a legacy device, then the device is handled as a legacy device (). Any flags associated with the registration for this device are updated accordingly.","If the process is not already registered for this type of device (), then the device is added to the registration list of devices for the process (). It is then determined whether the device is already open for receiving input from the device (). If not, the device is opened, and input is received from the device (). If the device is already open, then the method  is finished ().","For registration purposes, each device, whether a legacy device or a non-legacy device, can have a particular data structure that allows the user to select a device type, or top-level collection. An example of such a structure is:","typedef struct { USHORT usUsagePage;","\/\/Usage page from the HID Usage Table USHORT usUsage;","\/\/Top level usage from the HID Usage Table DWORD dwFlags;","\/\/Flags} RAWINPUTDEVICE, *PRAWINPUTDEVICE;","typedef CONST RAWINPUTDEVICE* PCRAWINPUTDEVICE;","The flags in this structure can be set to one of the following four choices",":#define RIDEV_ADD_OR_MODIFY 0x00000000","#define RIDEV_REMOVE 0x00000001 #define RIDEV_PAGEONLY0x00000020","#define RIDEV_EXCLUDE0x00000010 #define RIDEV_NOLEGACY0x00000030","The first flag is the default option. If this flag is set, the operating system starts sending raw input from devices of the specific device type, or top-level collection, to the registered application program as long as the application program has window focus. The second flag is used to remove a device type, or top-level collection, from the list of registered devices for a process. It is used to indicate to the operating system to stop reading from a device that matches the device type. The third flag is used to inform the operating system that the application program wishes to listen to all devices having a device type, or top-level collection, off a specified page. The fourth flag is used in conjunction with the third flag, to specify particular top-level collections when reading a complete usage page. The last flag is used to block data from keyboard devices, mouse devices, and other legacy devices.","For the registration process of FIG. (), an application program initially creates an array of raw input devices that includes the device types, or top-level collections, from which the application wishes to receive input. Once an application program has constructed this array, it then registers itself for these device types. This is accomplished by following the process of FIG. ().","After registration, an application program receives input messages from devices that have a device type that matches the device type that has been registered. Two different types of approaches can be followed for a process of an application program to receive raw input data from a device: a buffered read approach, and a regular read approach. The buffered read approach allows an application program to receive a number of raw input data from the input device at the same time. Conversely, the regular read approach allows an application program to receive a single raw input data from the input device.","For the buffered read approach, when a process of an application program receives raw input, a status flag is set. The process then knows to call a function to retrieve the raw input. An application programming interface (API) for such a function is:","WINUSERAPIUINTWINAPIGetRawInputBuffer","(PRAWINPUT pRawInput, PUINT pcbsize);","pRawlnput is a pointer to an array of RawInput structures, whereas pcbSize refers to the size of pRawlnput in bytes. The function's return value indicates the number of Rawinput structures written to pRawinput. pRawlnput is an array of Rawinput, which has the following structure:","typedef","struct tagRAWINPUT { UINT cbsize;","DWORD dwType;","HANDLE hDevice;","ULONG_PTR ulReserved;","union { RAWMOUSE mouse;","RAWKEYBOARD keyboard;","RAWHID hid;","} data;","} RAWINPUT, *PRAWINPUT, *LPRAWINPUT;","Each Rawinput structure provides a handle to the device generating the information. This handle is provided to the function to obtain further information on the device. The Rawinput structure also provides an indication of the origin of the information, through the dwType variable. The variable can have the following values:","#define RIM_TYPEMOUSE 0","#define RIM_TYPEKEYBOARD 1","#define RIM_TYPEHID 2","For the regular read approach, a different function may be called. This function operates similarly to the buffered read approach, but only a single raw input data is returned when called, instead of a collection of raw input data.","An application program may also call one of two other functions as desired. The first function determines the registration status for the input devices. The program calls this function to determine which input devices, of which device type, for which it already has registered. The second function provides information regarding the device generating the message.","Besides registering for a device type, an application program may also unregister a device type if it no longer wishes to receive input from devices of that type. The unregistration process is shown as the method  of FIG. (). The method  is performed by the manager component . First, it is verified that the device is registered for the process (). This can be accomplished by determining that the device is listed in what is referred to as the process's request table. If the device is not registered, then the method ends (). Otherwise, it is determined whether the device to be unregistered is a legacy device (). If so, unregistration for the device is handled as unregistration for a legacy device (), such that flags for the legacy device are updated accordingly. For example, the flags are updated so that the process of the application program is no longer registered for the device.","If the device to be unregistered is a non-legacy device, then the device is removed as being registered for the process of the application program (). This can include removing the device from the request table of the process. If any other processes are registered for this device (), then the method  is finished (). Otherwise, no more reading is accomplished from the device, and it is closed ().","Devices may be able to be plugged into the computer and unplugged from the computer while the computer is on. This is referred to as \u201chot-plugging.\u201d In such instances, the manager component  should be able to accommodate the addition of a new device to the computer, as well as the removal of a device from the computer. The processes followed by the manager component  to manage the removal and addition of devices are shown as the method  of FIG. (), and the method  of FIG. (), respectively.","For device removal, the method  of FIG. () first determines whether the device that has been removed is a legacy device (). If not, then the device is removed as a device that can be registered by application program processes (). For example, the device can be removed from the global device request list. Thereafter, the method  stops reading from the device (), which is also accomplished in the case where the device that has been removed is a legacy device.","For device addition, the method  of FIG. () first receives information regarding the device that has been added and stores this information (). For example, the device is queried to receive information regarding the device. The device is added to the list of available devices that can be registered by application program processes (). The information regarding the device, for example, may be added to the global device request list. If the device is a legacy device (), then the device is opened and is read (). If the device is a non-legacy device (), then it is determined whether any process has previously registered for devices of this device type, or top-level collection (). If so, then the device is opened and read (). Otherwise, the device is not yet opened or read (). The method  allows for new devices, and corresponding new device drivers, to be added without having to revise any of the application programs, or the manager component  of the operating system.","Each of the application programs  can have an associated input queue in which input data is placed by the manager component  for reading by the application program. This is shown in the diagram  of FIG. . The manager component  provides device input to the queues , , . . . , for the application programs , , , respectively. The device input is received from the input drivers , , and , which interact directly with the devices ,, and , respectively. Other than the presence of the queues , , . . . , , the embodiment of  operates as the embodiment of FIG. () has been described.","Pre-Processors and Post-Processors","The input from the device drivers ,, and  has been described as being provided untranslated, or raw, to the application programs  by the manager component . However, pre-processors may be inserted between the manager component  and the application programs  to modify the input prior to its receipt by the application programs . This may be accomplished, for example, to have one type of device mimic another. Input from a joystick device, for instance, may be modified to mimic a mouse device. Similarly, post-processors may be inserted after the application programs  to modify the input after its receipt by the application programs .","Pre-processing and post-processing of the input from input devices is shown in the diagram  of FIG. (). The pre-processors  are situated between the manager component  and the application programs . A given pre-processor may be specific to a type of device, a specific device, and\/or a specific application program. The post-processors  are situated after the application programs . A given post-processor may also be specific to a type of device, a specific device, and\/or a specific application program. Other than the presence of the pre-processors  and the post-processors , the embodiment of FIG. () operates as the embodiment of FIG. () has been described.","FIG. () is a flowchart of a method  showing how one embodiment processes messages that are sent by the manager component  and intended for one or more of the application programs . The presence of pre-processors () causes processing of the message by a pre-processor (). If there is more than one preprocessor (), this process continues until each pre-processor has had an opportunity to process the message. Therefore, processing as performed by the preprocessors is accomplished sequentially, with the first pre-processor processing the message first, followed by the second pre-processor, and so on.","If there are no pre-processors (), or once no more pre-processors need to process the message (), then the method  determines whether the current process of the current application program has requested the message (). The current process of the current application program is typically the process that currently is active, such that it has focus. If this process previously registered to receive messages from this type of device, then the process processes the message (). Once this has been accomplished, or if the current process did not request the message via previous registration (), then post-processing is accomplished by the post-processors, if any are present.","The presence of post-processors () causes processing of the message by a post-processor (). If there is more than one post-processor (), this process continues until each post-processor has had an opportunity to process the message. Similar to the case of pre-processors, processing as performed by the postprocessors is accomplished sequentially, with the first post-processor processing the message first, followed by the second post-processor, and so on. If there are no postprocessors (), or once no more post-processors need to process the message (), then the method  is finished ().","Multiple Focus","Usually, the active application program of the programs  is the program that receives input from the devices , , and  through their respective drivers ,, and  via the manager component . In the context of a graphical user interface (GUI), this application program is the current foreground application program, such that the application program has focus. As the user calls up other application programs, or sends the current application program into the background, other application programs become the foreground application program, such that they have focus. These application programs can thus become the active application program that receives input from the input devices ,, and  via the manager component .","Alternatively, however, there are different types of focus. For example, a media application program may have media focus. This means that even if the media application program is not the active application program, it should receive input from media-related devices, such as compact disc (CD) players, multi-media keyboards, buttons on media speakers, and so on. As another example, a telephony application program may have telephony focus. This likewise means that even if the telephony application program is not the active application program, it still receives input from telephony-input devices.",{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 5","b":["500","502","502","504","506","508","510","510","502","112"]},"Normally, the active application program associated with the active window  receives all input from input devices. That is, the program associated with the window  has overall focus, which is also referred to as keyboard focus. However, the media application program associated with the media window  has registered to receive input from media-related devices, even if the program is not the active application program. This means that the media application program has media focus, even if it does not have keyboard focus. Similarly, the telephony application program associated with the telephony window  has registered to receive input from telephony-related devices, even if the program is not the active application program. This means that the telephony application program has telephony focus, even if it does not have keyboard focus.","The application program associated with a background window  is an example of an inactive application program. Background application programs include any program that is not currently the active application program that has keyboard focus. In , such background application programs also include the media application program associated with the media window , and the telephony application program associated with the telephony window . Any background application program can receive pointing device focus, or mouse focus, when the pointer  is positioned over the window associated with the program. For example, the pointer  is positioned over the inactive window . If a button on the pointing device were pressed while the pointer  is positioned over this window, the application program associated with the window  would receive this input, because it currently has pointing device focus. It is noted that there are other ways to change focus than those described here.","Example Computerized Device",{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 6","b":["10","10","10","10","10"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, handor laptop devices, multiprocessor systems, microprocessorsystems. Additional examples include set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computerinstructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","An exemplary system for implementing the invention includes a computing device, such as computing device . In its most basic configuration, computing device  typically includes at least one processing unit  and memory . Depending on the exact configuration and type of computing device, memory  may be volatile (such as RAM), non-volatile (such as ROM, flash memory, etc.), or some combination of the two. This most basic configuration is illustrated by dashed line . Additionally, device  may also have additional features\/functionality. For example, device  may also include additional storage (removable and\/or non-removable) including, but not limited to, magnetic or optical disks or tape. Such additional storage is illustrated in by removable storage  and non-removable storage .","Computer storage media includes volatile, nonvolatile, removable, and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules, or other data. Memory , removable storage , and non-removable storage  are all examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CDROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by device . Any such computer storage media may be part of device .","Device  may also contain communications connection(s)  that allow the device to communicate with other devices. Communications connection(s)  is an example of communication media. Communication media typically embodies computer readable instructions, data structures, program modules, or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. The term computer readable media as used herein includes both storage media and communication media.","Device  may also have input device(s)  such as keyboard, mouse, pen, voice input device, touch input device, etc. Output device(s)  such as a display, speakers, printer, etc. may also be included. All these devices are well know in the art and need not be discussed at length here.","The methods that have been described can be computer-implemented on the device . A computer-implemented method is desirably realized at least in part as one or more programs running on a computer. The programs can be executed from a computer-readable medium such as a memory by a processor of a computer. The programs are desirably storable on a machine-readable medium, such as a floppy disk or a CD-ROM, for distribution and installation and execution on another computer. The program or programs can be a part of a computer system, a computer, or a computerized device.","Conclusion","It is noted that, although specific embodiments have been illustrated and described herein, it will be appreciated by those of ordinary skill in the art that any arrangement is calculated to achieve the same purpose may be substituted for the specific embodiments shown. This application is intended to cover any adaptations or variations of the present invention. Therefore, it is manifestly intended that this invention be limited only by the claims and equivalents thereof."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},"FIG. () is a diagram of a system showing how the invention manages input from legacy input devices and non-legacy input devices in a similar way.","FIG. () is a flowchart of a method showing how one embodiment enables application programs to register for receiving input from devices.","FIG. () is a flowchart of a method showing how one embodiment enables application programs to unregister devices from which they have previously registered to receive input.","FIG. () is a flowchart of a method showing how one embodiment manages the physical removal of an input device.","FIG. () is a flowchart of a method showing how one embodiment manages the physical addition of an input device.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3","b":"2","i":"a"},"FIG. () is a diagram of a system showing an alternative embodiment of the system of FIG. () in which pre-processors and post-processors are present.","FIG. () is a flowchart of a method showing how one embodiment processes messages when pre-processors and\/or post-processors are present, such as in conjunction with the alternative embodiment of FIG. ().",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
