---
title: Preventing general purpose event interrupt storms in a computer system
abstract: A method and system for selectively enabling wake events in software of a computer system to overcome problems arising when hardware devices fail to clear a wake signal. The operating system manages wake events, and also distinguishes between events that are exclusively wake events, exclusively run-time events, and shared wake and run-time events. At boot time, the ACPI driver examines system tables provided by firmware to determine which GPEs are associated with wake-up events, either exclusively or shared with run-time events. These wake event associations are tracked and managed differently from events received on other hardware register pins. When the operating system receives events in a GPE Status hardware register that is enabled in a counterpart Enable register, the operating system runs an associated GPE method. When the GPE method has completed, the operating system selectively determines whether the event needs to be re-enabled.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06931553&OS=06931553&RS=06931553
owner: Microsoft Corporation
number: 06931553
owner_city: Redmond
owner_country: US
publication_date: 20000420
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The present invention relates generally to computer devices, and more particularly to power management in computer-related devices.","ACPI (Advanced Configuration and Power Interface) is an open industry specification that defines a flexible and extensible interface for computer power management and related control operations. In general, the interface enables and supports power management through improved hardware and operating system coordination. ACPI allows the operating system to control the power states of many ACPI-compliant hardware components, and\/or to pass information to and from some hardware components.","The ACPI Specification 1.0b describes how a system vendor can use General Purpose Events (GPE) to inform the operating system that a certain event has occurred. The specification distinguishes between run-time GPEs, which are related to events that occur while the computer is running, (e.g., state changes related to a thermal sensor or the power remaining in a battery), and wake GPEs, which are related to events that occur to possibly wake the computer system (or one or more devices therein) while the computer\/device is in one of a plurality of sleep states. The specification allows the two types of events to be intermixed onto the same hardware signal.","ACPI enables individual devices of the computer system to go into a sleep state, thereby conserving power on the computer system. Device states may range from a D (working state) to D (fully off) state. The computer system as well may go into sleep-relative states, which may range from system state S (working) to S (fully off) with various possible states (e.g., S, light sleep, S deep sleep, S hibernation) in between. Wakeup signaling events, such as the opening of a lid on a laptop computer, the pressing of a keyboard key, moving of a mouse, and so forth, are supposed to wake the devices and the system as necessary, such as to match a user's preferences. More particularly, wake event signals are issued by a corresponding hardware device to a Status register pin, (e.g., a low signal is output to a formerly high signal register location, or vice versa). If the software is enabled for such an event, i.e., in a counterpart Enable register, some action (e.g., a system control interrupt or SCI) will be taken to wake a sleeping computer and\/or a device associated with that register location. For example, one type of wake event that may result in a specific device being woken up is to wake up a modem (move the modem from the D to the D state, as well as wake the computer if necessary) when a telephone ring is detected.","While the ACPI specification thus provides directions for properly waking computer systems and the devices therein, a significant problem is that many system vendors connect certain wake GPEs in a way that violates the specification, thereby potentially confounding the operating system. Normally, when the operating system takes a GPE event, it begins by masking off the GPE Enable register for that event, processing the event, clearing the GPE Status register for that event, and then re-enabling that event in the Enable register. However, if the hardware is implemented incorrectly, the operating system is not able to clear the GPE Status register when it normally should, i.e., when the operating system performs its interrupt handling processing (to run a GPE method) and then attempts to clear the GPE Status register, the underlying hardware event is not dismissed by the hardware as it should be. Then, when the event is re-enabled in the Enable register, the event fires again. In other words, if a hardware signal cannot be cleared in accordance with the ACPI specification, the operating system thinks that the signal is cleared, whereby the signal is re-enabled and the operating system receives another notification that the event has fired and repeats the process. If the signal is still not cleared, then the operating system, which handles interrupts at a higher priority than other processing, is essentially stuck in an infinite loop handling interrupts (a general purpose event (GPE) storm) that cannot be terminated until the signal is clear. As a result, when the operating system tries to wake up from the sleep state, it cannot, because the GPE events will not clear, causing an interrupt storm. This may also occur while the device is in a running state, and an event signal corresponding to waking a device, such as a network card, cannot be cleared. Unfortunately for the owners of such machines, a vast number of machines are \u201cbroken\u201d in precisely this manner, whereby their sleep features cannot be properly used. Further complicating matters is that certain hardware devices use GPE pins that share wake-up and run-time events.","Briefly, the present invention provides a method and system that solves the problem of interrupt storms by selectively enabling wake GPEs (in the Enable register) only when the operating system wants the particular devices associated with the wake GPEs to be able to notify the operating system that a wake event has occurred. The operating system thus intelligently manages wake GPEs. The operating system also distinguishes between events that are exclusively wake, run-time, and shared wake and run-time events.","To this end, in one implementation described herein, the present invention utilizes several algorithms to manipulate and remember various sets of state regarding GPEs. In this implementation, the sets of states are maintained in operating-system-internal structures referred to herein as software registers (a block of storage allocated in the computer's main memory, having an arbitrary location, size and contents), including a GpeWakeHandler software register, which comprises a mask of bits representing GPEs used exclusively for wake-up events, a GpeSpecialHandler software register, which comprises a mask of bits representing GPEs which might be used for wake-up events but should be treated as regular GPEs, and a GpePending software register, which comprises a mask of bits which represent GPEs on which processing has started, but has not yet completed. The ACPI driver uses these masks in combination with a GpeEnable software register, GpeWakeEnable software register (which maintains a list of GPE pins which are enabled because of a wakeup event) and GpeCurEnable software register (which provides a mask of bits which are currently enabled) to intelligently manage the GPEs.","At boot time, the ACPI driver uses an algorithm to examine the system tables\/namespace (built from firmware information) to determine which GPEs are associated with wake-up events, either exclusively or shared with run-time events, so that they can be managed differently from the other pins (which will be managed according to the ACPI specification). In particular, the ACPI driver looks for and specially handles the Lid, PowerButton, SleepButton, and Real-Time-Clock devices because these devices typically use a GPE pin that share wake-up and run-time events. Of course, other such mechanism may be similarly specially handled. Wake only events are enabled when the operating system deems it appropriate for them to be enabled, e.g., while the computer has been in a running state and the operating system has decided that some device needs that wake event enabled because the device needs to be able to wake up the computer.","In general, after the operating system has determined which GPEs are run-time, wake only, or shared, when the operating system receives events in the GPE Status register, the operating system runs an associated GPE method. When the GPE method has completed, the operating system selectively determines whether the event needs to be re-enabled. This is done (in part) by determining if the event is wake only, (e.g., via access and manipulation of the state information in the registers), and if there is no outstanding request for that event to wake up the computer.","A function is described that operates on the various registers to remove completed events from the list of those pending, remove events that are not in the current list of enabled events, remove each event for which there is a wake handler but which is not listed in the list of wake enables, and re-enabling those that remain. In that way, wake only events are enabled only when the operating system determines that they should be active, while shared wake and run-time events are enabled during run-time but handled differently.","Other advantages will become apparent from the following detailed description when taken in conjunction with the drawings, in which:","Exemplary Operating Environments",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1"},"Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations, including hand-held devices, multi-processor systems, microprocessor-based or programmable consumer electronics, network PCs, minicomputers, mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a conventional personal computer  or the like, including a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. The system memory includes read-only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within the personal computer , such as during start-up, is stored in ROM . On an ACPI system, as described herein, the vendor provided ACPI Machine Language (AML) code, generally referred to as the ACPI BIOS, is also ordinarily stored within the ROM. The personal computer  may further include a hard disk drive  for reading from and writing to a hard disk, not shown, a magnetic disk drive  for reading from or writing to a removable magnetic disk , and an optical disk drive  for reading from or writing to a removable optical disk  such as a CD-ROM or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical drive interface , respectively. The drives and their associated computer-readable media provide non-volatile storage of computer readable instructions, data structures, program modules and other data for the personal computer . Although the exemplary environment described herein employs a hard disk, a removable magnetic disk  and a removable optical disk , it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, random access memories (RAMs), read-only memories (ROMs) and the like may also be used in the exemplary operating environment.","A number of program modules may be stored on the hard disk, magnetic disk , optical disk , ROM  or RAM , including an operating system  (such as Microsoft Corporation's Windows\u00ae 2000, formerly Windows NT\u00ae, operating system). The computer  includes a file system  associated with or included within the operating system , such as the Windows NT\u00ae File System (NTFS), one or more application programs , other program modules  and program data . A user may enter commands and information into the personal computer  through input devices such as a keyboard  and pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , personal computers typically include other peripheral output devices (not shown), such as speakers and printers.","The personal computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be another personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the personal computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, Intranets and the Internet.","When used in a LAN networking environment, the personal computer  is connected to the local network  through a network interface or adapter . When used in a WAN networking environment, the personal computer  typically includes a modem  or other means for establishing communications over the wide area network , such as the Internet. The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the personal computer , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","While the present invention is primarily described with respect to the Windows\u00ae 2000 operating system, those skilled in the art will appreciate that other operating systems and\/or file systems may implement and benefit from the present invention.","Illustrative Configuration Management System",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 2","FIG. 1"],"b":["60","20","60"]},"As shown, the application programs  may interface with a kernel , which is a part of the operating system , generally via application programming interface (API) calls or the like. The kernel  can be generally considered as one or more software modules that are responsible for performing many operating system functions. One such function is passing information between the application programs  and the lower level components of the ACPI system , such as the ACPI driver  (described below) and various device drivers (e.g., device driver ).","The kernel  also interfaces with Operating System Power Management (OSPM) system code . The OSPM system code  comprises one or more software modules that may be a part of the operating system  and that may be used to modify the behavior of certain components of the computer system , typically to conserve power in accordance with pre-configured power conservation settings. As is generally known, the various device drivers  interface with and generally control the hardware installed in the computer system . A driver communicates with other drivers and the operating system components (e.g., an I\/O manager), for example in the Windows\u00ae 2000 (and Windows NT\u00ae) operating systems, by passing I\/O request packets, or IRPs.","In general, the ACPI driver  is a module that controls the functioning of much of the ACPI system . The ACPI driver  may be supplied as part of the operating system  or as a separate component. In the described system, the ACPI driver  is loaded during system start-up at the base of a tree of devices, where it acts as an interface between the operating system  and the BIOS . The responsibilities of the ACPI driver  include support for plug and play (PnP) and, in keeping with the present invention as described below, power management. The ACPI driver  is responsible for initiating and maintaining the ACPI system , such as by populating an ACPI namespace  (represented in  and described below) at system startup, loading and unloading description blocks from the ACPI namespace  at run time, handling certain generic events triggered by ACPI-compliant hardware, and handing off other events to modules registered to handle those events.","The ACPI driver  makes use of several components when performing the functions of the ACPI system . One component is the ACPI BIOS , which refers to the portion of system firmware that is compatible with the ACPI specification. Generally stated, the ACPI BIOS  is part of the code that boots the machine (similar to the BIOS present in most conventional computer systems) and implements interfaces for power and configuration operations, such as sleep, wake, and some restart operations. The ACPI BIOS  contains definition blocks used to construct ACPI Tables , as is described in greater detail below. Note that although the BIOS  and the ACPI BIOS  are illustrated as separate components in , they may be implemented as one component in the computer system .","The ACPI Tables , generally known as Differentiated Definition Blocks (DDBs), are composed of as few as one, but most likely many, definition blocks that contain data and\/or control methods. Each set of data and\/or control methods defines and provides access to a respective hardware device. The tables include header data structures that contain information about what the block contains, for example, whether it is a Differentiated System Description Table (DSDT) or a Secondary System Descriptor Table (SSDT). Each table (SSDT or DSDT) contains only one Definition Block. One such definition block, known as a Differentiated System Description Table (DSDT) describes the base computer system, that is, the DSDT contains a Differentiated Definition Block (DDB), which describes the root system. The DSDT is like other Data blocks, except that it cannot be unloaded. Other definition blocks may be provided to describe additional ACPI devices. The definition blocks are written in an interpreted language called ACPI Machine Language (AML), the interpretation of which is performed by an AML interpreter  within the ACPI driver .","As mentioned, the definition blocks may contain control methods. A \u201ccontrol method\u201d is a software module that defines how the ACPI system  performs a hardware-related task. For example, the ACPI system  may invoke a control method to read the temperature of a thermal zone, change the device power state of a modem, and so forth. Control methods are written in AML, are stored in the definition blocks within the ACPI BIOS , and are loaded into the ACPI namespace  (), typically at system boot up. Once in the ACPI namespace , the control methods may be invoked by other components in the ACPI system , such as device drivers or the like, and are then interpreted and executed by a virtual machine in the ACPI driver . The use and structure of the ACPI namespace , and exemplary objects within, are generally described below with respect to .","ACPI registers  are a constrained part of the hardware interface, described (at least in location) by the ACPI Tables . For a more detailed discussion of the ACPI tables , definition blocks, and other functions performed by the ACPI driver, refer to Sections 5 and 16 of the publicly-available ACPI Specification Version 1.0, which is hereby incorporated by reference in its entirety.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 3","b":["70","74","70","20","70","72","35","64","74","72","74","70","64","70","74"]},"Shown in  is one illustrative ACPI namespace , containing a namespace root, several illustrative branches under the root, and several other objects of various types. For example, under the root is a processor tree namespace \\PR. Processor objects, such as the Processor 0 object CPU, are defined under the processor tree \\ PR namespace. For more information about processor objects, see Section 8 of the ACPI Specification.","The \\ SB namespace includes namespace objects that define ACPI-compliant components attached to the system bus. One example of such a namespace object is the PCI bus namespace object. Each namespace object may have other objects as children thereof, such as data objects, control methods, or other namespace objects (e.g., ISA0 namespace object). The objects having a PRW child are those with wakeup capabilities, and the pin number in the ACPI register to which they are wired (described below) is specified therein, along with wakeup information, e.g., the \u201cdeepest\u201d system state from which the device can wake the computer. In general, the ACPI driver locates these devices and may treat them special to facilitate wakeup capabilities in accordance with one aspect of the present invention, as described below.","Several control methods may be loaded in the ACPI namespace in connection with various objects, including the methods run on detection of wakeup events in the \\ GPE namespace. For example, as shown in , a notify control method will execute on a network card (Nic) event wired to pin  of the hardware register . The \\GPE namespace includes additional control methods to handle other general purpose events (including wakeup events) triggered by ACPI-aware components in the ACPI system . For GPE events, the ACPI driver  will execute the control method of the name \\GPE.Exx and \\GPE.Lxx, wherein as used herein, \u2018E\u2019 indicates an edge-triggered event and \u2018L\u2019 a level-triggered event, and xx represents a hex value format of the event that needs to be handled, such as those exemplified in . Note that the format for namespace object is \u201c\\\u201d+4 characters+\u201c.\u201d+4 characters+\u201c.\u201d . . . +\u201c.\u201d+4 characters, where the leading \u201c\\\u201d is optional and can be replaced with a \u201c^\u201d to indicate \u201cone level up,\u201d \u201c^^\u201d to indicate \u201ctwo levels up\u201d and so forth. Further, note that  contains a representation of what the AML does, not the actual AML itself.","As generally shown in , for each device described in the ACPI namespace , the ACPI driver  creates either a filter Device Object (filter DO) or a Physical Device Object (PDO). Note that  is only a partial representation, as ACPI loads itself onto every driver of which it is aware. If the device is capable of being enumerated by an element of another subsystem, such as a Plug-n-Play subsystem, that element of the other subsystem creates a PDO for the device and the ACPI driver  puts a filter DO on top of the PDO. If the ACPI namespace  is the only possible enumeration mechanism, the ACPI driver  creates the PDO. ACPI provides power management features to the device stack by means of these device objects. For more information on filter DOs, PDOs and Functional DOs (FDOs), refer to the Microsoft Windows\u00ae 2000 Driver Development Kit, available from the Microsoft Corporation of Redmond, Wash., and incorporated by reference herein.","Turning to  of the drawings there is shown a general, exemplary architecture underlying the present invention. In , a number of hardware devices, which may include a network card and so forth, connect to a host bridge  (e.g., PCI bridge), wherein PCI power management supports wake events generated by functions on the PCI bus. As represented in , these devices may be wire-ORed together, (in accordance with the PCI Bus Power Management Interface Specification), and are capable of signaling general purpose events to the system, including wake events, by sending a power management event signal (PME#) to a hardware Status register in system I\/O space. Other devices such as a lid switch of a laptop computer system, mouse and keyboard may also signal the Status register of the registers . In general, the Status register is sparsely populated, i.e., not all of the register pins are wired for having signals sent thereto, and those that are not wired (as known from the ACPI namespace ) are not enabled in the Enable register , and should be made inactive in the status register . In other words, because AML\/ASL code may describe to the operating system how to utilize these events that are not actually wired to a device, and thus there should not be a floating pin input that can set the corresponding SCI status bit in the GPE register .","Note that as shown in , the hardware register  may be implemented as two general-purpose register blocks, GPE and GPE. Each register block contains a Status register and an Enable register, e.g., if a machine vendor specifies two, the registers are referred to as GPESTA, GPEEN, GPESTA, GPEEN. Each register block is 32-bit aligned, and is accessed by the ACPI driver  as a byte (regardless of their length), using single byte reads and writes offset from the start of the registers. For example, if the GPESTA register is two bytes long, then the ACPI driver will read a byte from the address of GPESTA, then read another byte from the address of GPESTA+1. For purposes of simplicity herein, the Status and Enable registers will be generally described as a single Status register and single Enable register . The ACPI driver  owns these general-purpose event registers , , and other than the hardware device signaling the input pins of the Status register , the register bits are only manipulated by the ACPI driver . For example, firmware code (e.g., 72) cannot directly adjust these bits. Thus, the ACPI driver manages the bits in the hardware register  directly, although the source to those events is not directly known and is connected into the system by control methods.","To summarize, each available status bit in this register may be set when a corresponding event is active, and is cleared by software (the ACPI driver ) writing a one to its respective bit position. For the general-purpose event registers , unimplemented bits are ignored by the operating system software\/ACPI . Each status bit can optionally wake up the system (and device) if asserted on an enabled pin when the system is in a sleeping state. The general-purpose event Enable register contains the general-purpose event enable bits. Each available enable bit in this register corresponds to the bit with the same bit position in the GPE Status register . In other words, when the enable bit is set, then a set status bit in the corresponding status bit will generate a system control interrupt (SCI) bit.","It is the system hardware's responsibility to restore the host processor subsystem to a state which will permit the operating system to function (e.g., through ACPI or some other like architecture). If the sub-system is already in a D (working state), then the system hardware does not need to take any special action. The system is responsible for notifying the operating system that a PCI Power Management Event (PME) has occurred, via a PME signal, PME#. The PME# signal is expected to generate some form of System Control Interrupt (SCI), but whether this interrupt is handled by a device driver or an operating system service routine is left up to the individual operating system architecture. In an implementation described herein, the ACPI driver  will handle this interrupt, but as can be readily appreciated, the operating system and\/or one or more other drivers may perform the handling.","In general, once the ACPI driver  has been notified that a PCI PME has occurred, it is the driver's responsibility to restore power to the primary PCI bus and to restore the PCI bus to the bus running (or B) state, and also to restore power to any unpowered slots\/devices. Then, the ACPI driver communicates with the PCI driver, which queries the PCI functions that have been configured with PME# enabled (in the Enable register ) to determine which function, or functions, had generated the PME#. More particularly, the ACPI driver tells the PCI driver that it should begin this process by handing back a WaitWake I\/O request packet (W\u2014W IRP) that the PCI driver originally sent to the ACPI driver. If the generating device is a bridge device, the PCI driver should follow this procedure for any subsequent PCI bridges. The PCI driver is capable of handling multiple PME#s generated by different functions simultaneously, devices for which PCI has a concept of a Function #, (since a single device can have multiple functions). Upon identifying the source or sources of the PME#, it is up to the PCI driver to identify the correct course of action with regard to waking the functions and\/or the rest of the system.","In the PCI-based example described herein, before a PCI driver returns a function to the D operating state following a wake event, which will require a re-initialization of the function, it needs to ensure that the ACPI driver  has the information necessary to re-initialize the function, as well as any information necessary to restore the function. Note that this information is often client specific. By way of example, consider a situation in which a modem client has set up a modem function in a specific state in addition to default initialization (error correction, baud rate, modulation characteristics, and so forth). If the client\/function is unused for an extended amount of time, power manager may place the modem in a D or perhaps even a D state. When the client is called upon to interact with the modem (such as a ring-resume event), the ACPI driver  will transition the modem function to the D initialized state. However, restoration of the modem function to D alone may not be sufficient for the function and client to perform the indicated task, but instead additional context may need to be restored for successful restoration of a function. The restoration needs to be transparent, to the extent that the host application is unaware that a power state transition and the associated restoration occurred.","When the ACPI driver receives a general-purpose event, it either passes control to an ACPI-aware driver, or uses a control method (e.g., supplied by an OEM) to handle the event. Note that the ACPI driver also has built-in policy in case there is no control method or separate driver to process the GPE, which is to treat the signal as a Notify(,0\u00d72) on the devices that are on that pin. An OEM can implement between 0 (zero) and 255 general-purpose event inputs in hardware, each as either a level or edge event. Note that if a platform uses an embedded controller in the ACPI environment, then the embedded controller's SCI output is to be directly and exclusively tied to a single GPE input bit. Hardware can cascade other general-purpose events from a bit in the GPE hardware register  through status and enable bits in Operational Regions (I\/O space, memory space, PCI configuration space, or embedded controller space).","Wake Event Handling","In general, one use of general purpose events is to implement device wake events. To this end, when a device (e.g., ) signals its wake signal, the general-purpose status bit used to track that device is set. For example, as shown in , the \u201c5\u201d location in the Status register would be set. While the corresponding general-purpose enable bit is enabled in the Enable register , an SCI interrupt is asserted. If the system is sleeping, this will cause the hardware, if possible, to transition the system into the S state. Once the system is running, the ACPI driver  will dispatch the corresponding GPE handler, according to the information in the \\GPE namespace ().","From the \\GPE namespace, the handler determines which device object has signaled wake, and performs a wake \u201cNotify\u201d operation on the corresponding device object or objects that have asserted wake. In turn the ACPI driver  will notify the driver (or drivers) for each device that will wake its device to service it. However, as described above, in certain systems, a hardware signal is not cleared in response to the appropriate signal from the ACPI driver , whereby another notification that the event has fired is received, and the process repeated until the signal is cleared, which may never occur.","In accordance with one aspect of the present invention, to overcome this problem, there is provided an algorithm that selectively enables GPE events when they should be enabled, and disables them when they should not be enabled. In general, the algorithm first determines which pins (of the Status register ) are used for wake-events, either exclusively or shared with run-time events, and manages those pins differently from the other pins, (which are managed according to the ACPI specification).","To this end, the ACPI driver  maintains a number of sets of state regarding GPEs, in a set of operating-system-internal data structures (a block of storage allocated in the computer's main memory, having an arbitrary location, size and contents) referred to herein as software registers . As shown in , each software register includes a bit corresponding to each hardware register bit. Among the software registers is a GpeEnable software register , providing a mask of bits indicating those events for which there exists a GPE control method. As a general rule, the ACPI driver  will always arm the pins corresponding to this mask , i.e., set the enable bit in the hardware register .","The GpeWakeEnable software register  maintains a list of GPE pins which are enabled because of a wakeup event, as described in more detail below. The GpeCurEnable software register  provides the mask of bits which are currently enabled, and is formed by taking a subset of the GpeEnable mask  and GpeWakeEnable  register.","In keeping with the present invention, the ACPI driver , which is responsible for handling GPEs, maintains other various sets of state regarding GPEs. One register for maintaining this additional state is a GpeWakeHandler software registerGpeWakeHandler software register , which comprises a mask of bits used exclusively for wake-up events. Also maintained is a GpeSpecialHandler , which is a mask of bits which might be used for wake-up events, but should always be treated as regular GPEs. Note that this register tracks likely shared wake-up and run-time events. The ACPI driver  also maintains a GpePending software register , a mask of bits that represent GPEs that have started to be processed, but have not yet completed. Other software registers represented in  include a GpeIsLevel software register , and a GpeHandlerType software register . A GpeRunMethod software register  is also provided for tracking the running of the control method associated with each GPE, and a GpeComplete software register  is provided to track completed events, as generally described below with respect to . In general, one difference between the GpeRunMethod software register and the GpePending software register is that GpeRunMethod is only set until such a time as the ACPI driver is able to run the appropriate method. Once the ACPI driver is in a position to run the proper method, the GpeRunMethod is cleared. In comparison, the GpePending software register is set until the appropriate GPE method has successfully completed. However, as will be described below, GpeRunMethod software register enables the same control method to be run again if needed, such as in the case of a failure.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 7","FIG. 6","FIG. 7"],"b":["64","700","702","704","706","93","708","95","708","714"],"sub":["\u2014","\u2014","\u2014"]},"If at step  the selected PRW object did not correspond to a Lid, PowerButton, SleepButton or Real-Time-Clock, the corresponding pin is not specially treated, and the process instead branches to step , wherein steps  and  set the associated pin in the GpeWakeHandler mask  when the associated pin in the GpeSpecialHandler mask  is not set. This establishes which events are wake only. Then, step  similarly proceeds to step \u2013, to examine\/process any other PRW objects in the above-identified manner.","After the ACPI driver  (or other suitable operating system component) has determined which GPEs are run-time, wake, or shared and saved this information in the software registers , the driver  is ready to enable the GPE events and process them. At this time, various ways to process the GPEs are feasible.  represents two general, alternative ways of those possible, while  represent one other particular implementation. Since  are general in nature, they will be described with respect to an operating system, although as in understood, the ACPI driver  or other component may perform some or all of the described operations.","In , when a GPE has been received, beginning at step  the GpeEnable mask  (and Enable register ) is cleared by the operating system, preventing interrupts from further events during the processing, i.e., until the mask is re-enabled. Then, at step , the GPE Status register is scanned for a list of outstanding events, as others events may have also been signaled at this time. Via steps \u2013, for each event indicated in the GPE Status register , the associated GPE Method is run.","In accordance with an aspect of the present invention, when the GPE Method has completed for the event, a selective determination is made as to whether the driver  needs to re-enable that event. This is done at step by determining if the event is wake only (step ), which, in one implementation is tracked by the GpeWakeHandler mask , and if there is no outstanding request for that event to wake up the computer (step ). Such events will not be not re-enabled in the Enable register (step ), for example, in one implementation by manipulating the information in the registers . For events that have been handled, the GPE status bit is cleared for that event at step . Via step , when all GPEs have been completed, step  re-enables the events that the operating system or the like has determined should be enabled. In one implementation, this is accomplished by manipulating the information in the software registers , as described below with respect to .","Another variation of this algorithm is represented in , beginning at step  wherein the GPE Status register is read. At step , the events that are set in the Status register are masked off via the GPE Enable Register . Via steps \u2013 (and step ), for each event indicated in the GPE Status register, the associated GPE Method is run.","At step , when each associated GPE method has completed, in accordance with an aspect of the present invention, a determination is made as to whether the operating system needs to re-enable that event. This is done by determining if the event is wake only (step ), and if there is no outstanding request for that event to wake up the computer (step ). If so, that event will not be enabled via step . At step , the GPE status bit for that event is cleared. If the event needs to be re-enabled (step ), it is re-enabled as represented in step  by reading in the GPE Enable register , OR-ing in the appropriate bit corresponding to that event, and then writing the result back to the GPE Enable register E. Step  repeats the process for other events.","Note that the logic in  is very similar to that of , except that in , the operating system maintains a list of GPEs that should be enabled, and re-enables all those events simultaneously, whereas in the , the operating system instead turns particular events on and off as appropriate.","In one implementation described herein, the ACPI driver  performs the operations generally described in . Many of these operations are similar to those described above with reference to , and achieve a similar result, but are described herein to provide additional implementation details. As will be understood, the driver generally operates by manipulating the register values to selectively determine which pins should be re-enabled, thereby preventing GPE interrupt storms from locking the computer system in many cases.","As represented in , when the ACPI driver  receives a request that a device should be armed for wakeup, (e.g., via an IRP such as a wait-wake IRP held by the ACPI driver in a list until a corresponding event occurs), at step  the ACPI driver  removes any of the pins in the GpeWakeEnable mask  or GpeWakeHandler mask  from the GpeCurEnable mask . This effectively removes the non-run-time events from the list of GPEs that are enabled to fire. Then, at step , the ACPI driver clears the GpeWakeEnable mask  (i.e., zeroes it out). Note that in the described implementation, the ACPI driver  thus performs the selective enabling of certain wake events, and other, existing components, including those that request the arming of the device for wakeup, need not be modified or even be aware of the selective enabling process.","Via step , for each device wake-up request of which the ACPI driver  is aware, if the pin is not set in the GpeWakeEnable bitmask , as tested for at step , then the pin is set in the GpeWakeEnable software register , and the pin is cleared from the from the GPE Status register at step . The process then continues to step  of .","At step  of , if the pin is not set in the GpeEnable bitmask  (to handle the case there is no GPE control method associated with the pin, in which case the event has to be a wake-only event), and the pin is also not set in the GpeCurEnable bitmask  as evaluated by step , then the pin is set in the GpeCurEnable bitmask  at step . Note that because it is known to be a wake event, it is also noted that the event is Level-triggered, so that is not incorrectly treated as Edge-triggered. The process then returns to step  of .","Returning to the other possibility, if at step  of  the pin was set in the GpeEnable bitmask , which means that the pin has a GPE Control Method associated with it and this there is a possibility that it is a run-time event, then the pin is evaluated in the GpeSpecialHandler bitmask  at step . If at step  the pin is not set in the special handler bitmask , i.e., it is not treated as a special case, then the pin is set in the GpeWakeHandler bitmask . The process then returns to step  of .","At step , the current device has been handled, and the process returns to step  to determine whether every device that is armed for wakeup has been processed in the above manner. If not, steps \u2013 are repeated for those devices, including the steps described above with respect to . If every device that is armed for wakeup has been processed as described above, the process continues to step .","Step  represents the checking as to whether the system is leaving the running state, i.e., is going to sleep. If so, then the process clears the pins in the GpeWakeEnable bitmask  from the GpeCurEnable bitmask  at step . Otherwise, step  is executed to set the pins from the GpeWakeEnable bitmask  in the GpeCurEnable bitmask .","As is understood, the above mechanism ensures that the list of pins in the GpeCurEnable bitmask  are not ones that will cause the operating system an interrupt storm when the system attempts to re-enter the working state. The logic of  further ensures that pins which are associated with a wake-event are not enabled during the system's transition between the working and the sleeping state. This prevents a wake event that occurs after the system begins the transition to the sleeping state from being forgotten or ignored, whereby in such a situation the computer system will not enter the sleep state.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":["FIG. 12","FIG. 12"],"b":["64","1200","1202","1204","1206","90","1208"]},{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 13","FIG. 12","FIG. 13"],"b":["1300","80","94","1302","1304","98","1306","92","96"]},"At step , a \u201cwork-to-be-done\u201d flag is set to tell a second, GPE handling DPC that work needs to be done. If the GPE handling DPC is already running as represented by step , e.g., as known via another flag, then because the work-to-be-done flag was set at step , the GPE handling DPC will not exit, but will rerun and perform the work set up in steps \u2013. Thus there is no need to schedule it to run, and the pre-processing DPC ends via step . Similarly, if the GPE handling DPC is already scheduled to run, e.g., as known via another flag, as tested for at step , there is no need to reschedule the running of the GPE handling DPC. However, if not already running and not scheduled, step  is executed to schedule the GPE handling DPC. Note that the GPE handling DPC may be scheduled in the future, e.g., after an appropriate delay such as a two second pause, such as to give a GPE storm time to subside, e.g., as the PCI driver may clear a PME# event from one of its devices, or some other hardware condition may change.","As represented in , the GPE Handling DPC process (or for example, a thread of execution of a process) first tests to make sure that no other GPE Handling DPC is running. If one is, the process returns, otherwise, step  branches to step  which sets the flag to indicate that the GPE Handling DPC is now running. Step  determines which methods need to be run from the GpeRunMethod software register , and then clears the GpeRunMethod software register  to ensure that the methods will not be run again, unless there is cause to do so, (e.g., the hardware event fires, or the operating system determines that there is a good reason for re-running the method, such as an error during the previous execution). Also, as represented at step , the work-to-be done flag is cleared. At step , the contents of the GpeComplete software register is saved to a list of completed events, and the GpeComplete software register is cleared. Then, via steps  and , the process of  is performed on each pending GPE event.","As represented in , when a pending GPE event is selected, step  tests whether a GPE control method exists for the GPE event. If so, step  branches to step , which runs the appropriate GPE control method. Step  tests whether the GPE control method has finished execution, and if so, continues to step . Otherwise, the DPC stops handling this bit, and continues operating while awaiting a callback, e.g., from another thread. Note that the DPC recognizes that it can do no further processing on this particular GPE at this time, but continues running to possibly work on other GPES, until the callback is invoked, whereby operation will resume on that particular GPE as generally described below with respect to . If the status is finished at step , the \u201cYes\u201d branch continues to step , where, because there is a possibility that the call failed, particularly due to an out of memory condition, success or failure is evaluated. For example, the failure may be detected by evaluating an errorcode or the like. If successfully finished at step , the process adds the GPE event to the list of completed events at step . Step  then continues to step  of  to (possibly) repeat for any pending GPE event.","If the call instead fails as determined by step , step  is executed to re-run the control method by again setting the bit in the GpeRunMethod software register. Then, at step , the DPC is scheduled with a delay, e.g., two seconds or some other appropriate duration, generally to give a chance for memory to be freed during the delay. In this way the DPC will again execute at some later point in time, wherein step , which will pick up the control method that failed and cause it to attempt to re-run again, will be reached if the work-to-be done variable within the current DPC is set (as tested via step ), or when the DPC restarts after the delay and sees that no other DPC is running.",{"@attributes":{"id":"p-0081","num":"0080"},"figref":["FIG. 16","FIG. 15"],"b":["1504","1600","1514","1602","1604","1606","1608","1610"]},"If the control method failed, step  instead branches to step  wherein a bit is set in the GpeRunMethod software register so as to again attempt running of the control method. Note that as described above, this handles the case wherein execution of a control method failed because of a low memory or other condition. Then, step  tests whether the GPE handling DPC is already scheduled, and if not, at step  schedules it, including a pause. Note that the delay is scheduled in the hope that the system will be able to free memory during this time, as low memory is a common cause of failure. Note that the \u201cWork Done\u201d bit is not set at this point, in the hope that if the DPC is currently running, it will not have cause to jump back to step . If it does, however, that will not be a problem because the DPC is doing meaningful work on GPEs that completed successfully. Eventually, however, the only outstanding GPE may be the one that failed, whereby not setting the work-to-be-done flag will prevent the DPC from jumping from  to  and thereby provide the delay for freeing memory.","Returning to the situation wherein at step  there is no GPE control method for the selected GPE event, step  is executed, which tests whether the GPE event is in the GpeWakeEnable bitmask. If so, the GPE event is treated as a wake event at step  such as to wake the system if sleeping, e.g., it is a wake event shared with a run-time event. Then step  continues to step  to add the GPE event to the list of completed events. However, if at step  the GPE event is not in the GpeWakeEnable bitmask, then the target device driver of the GPE event is notified per the ACPI specification (e.g., it is a run-time event) at step , and then the GPE event is added to the list of completed events at step . As represented in , the process then returns to step  of  to repeat for other pending GPE events, if any.","When no more GPE events are pending, step  branches to step , to determine if more work needs to be done (by checking the work-to-be-done flag). If so, the DPC returns to step  and continues to do work, otherwise the DPC continues to step  of  where the GPEs in the list of completed events are processed.","Beginning at step  of , for each GPE (via step  and ), the GPE Status register associated with the event is cleared at step . Note that  this is only an abstraction for Level-triggered GPEs, as Edge-triggered GPEs are cleared earlier, e.g., at approximately steps \/ of . Also, a function is called that determines if the GPE event should be re-enabled or not, as generally described below with reference to . Note that in the event that the GPE control method does not finish execution within the context of the DPC, (step ), the completion routine will also call the same function of  that determines whether the GPE event should be re-enabled, as described below.",{"@attributes":{"id":"p-0086","num":"0085"},"figref":["FIG. 17","FIG. 17"],"b":["86","1700"],"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":"GpePending &=\u02dc(CompletedGpes)."}}}},"Next, at step  any events that are not in the current list of enables are removed, including either wake or run-time events, by the following operation:\n\n","Then, any events for which there is a wake handler, but is not in the list of wake enables, is removed by the following operation as represented in step :\n\n","Lastly, via step  the remaining events are re-enabled:\n\n","Returning to , step  clears the flag to indicate that the DPC is no longer in the running state. Step  then re-enables those GPEs for which it has been determined () that the GPEs should be re-enabled.","As can be seen from the foregoing detailed description, there is provided a method and system wherein selective enabling of wake events prevents the effect of general purpose event interrupt storms in a computer system. The method and system adapt to existing systems, and do not require changes to existing hardware and\/or software other than to a software component that executes the selective enabling algorithms.","While the invention is susceptible to various modifications and alternative constructions, certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood, however, that there is no intention to limit the invention to the specific form or forms disclosed, but on the contrary, the intention is to cover all modifications, alternative constructions, and equivalents falling within the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIGS. 8 and 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 10 and 11"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIGS. 13","b":["14","14","15"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 16","FIG. 14A"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 17"}]},"DETDESC":[{},{}]}
