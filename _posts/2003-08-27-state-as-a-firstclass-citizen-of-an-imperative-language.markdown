---
title: State as a first-class citizen of an imperative language
abstract: A state component saves a present state of a program or model. This state component can be invoked by the program or model itself, thereby making state a first-class citizen. As the state of the program evolves from the saved state, the saved state remains for reflection and recall, for example, for testing, verification, transaction processing, etc. Using a state reference token, the saved state of the program or model can be accessed by the program or model. For example, the program or model by utilizing a state component, can return itself to the saved state. After returning to the saved state, a second execution path can be introduced without requiring re-execution of the actions leading to the saved state. In another example, the state space of an executing model is saved in order to generate inputs required to exercise a program or model.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07584463&OS=07584463&RS=07584463
owner: Microsoft Corporation
number: 07584463
owner_city: Redmond
owner_country: US
publication_date: 20030827
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF INVENTION","COPYRIGHT AUTHORIZATION","BACKGROUND OF INVENTION","SUMMARY","DETAILED DESCRIPTION","Computing Environment","ALTERNATIVES"],"p":["The technology relates generally to determining variable states of an executing program, and more particularly to saving program state for later reflection or recall.","A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","Modem imperative languages have powerful capabilities for reflection which make language elements like types, methods and fields accessible to program developers as first class citizens. Debuggers provide a way to freeze an executing program and examine selected variables at a frozen state. Test developers often introduce write statements into programs under test in order to determine whether write statement outputs reflect expected outputs. In transaction processing, the old value of each changed variable was individually saved when a transaction was declared. This data was then available to write back into the program to return to the pre-transaction state in case of a rollback.","The described technologies provide methods and systems for saving state, accessing state, and reinstating a prior saved states via semantically accessible programming constructs.","One example of the technology provides an application programming interface for creating a state component that saves the present state of a program or model. As the state of the program evolves, the saved state(s) remains in case it is required later. Using a state reference token, the saved state of the program or model can be accessed, or the program or model can be returned to the saved state. After returning to the saved state, a second execution path can be introduced without requiring re-execution of the actions leading to the saved state.","In another example, the technology provides a way to save a present state for rollback if required in exception processing or transaction processing.","In another example, the state space of an executing model is saved in order to generate input conditions required to exercise a program.","In another example, a state component is dynamically linked to an executing program. In another example, a model is run in parallel with a program, and states of the model are saved and recalled in order to determine whether the program follows an expected behavior of the model.","Additional features and advantages will be apparent from the detailed description, which proceeds with reference to the accompanying drawings.","Software testing represents a significant portion of development costs. In addition to other benefits, the described technology provides a method of analyzing program behavior that adds state of a program as a first class citizen in addition to existing first class language elements such as types, methods, and fields. By using state as a first class language construct, a programmer can return to a saved state and explore other exit paths (or actions) from a saved state. For example, in one case, many execution paths of a model program for test case generation are tried.","Some modem imperative languages have powerful capabilities for reflection which makes reflection of language elements like types, methods, and fields, available as first-class citizens. First-class citizenship allows generic algorithms over such entities. However, they lack the capability of dealing with the state of a program as a first-class citizen. State as a first-class citizen is important to analyze a program behavior, for example, exhaustively trying all execution paths of a model program for test case generation.","Analyzing programs and models, in particular for systematic testing, is of importance for obtaining trustworthy software. Depending on the application, more than 50% of the development costs are required for testing. Improving the testing process can gain significant competitive advantage.","An imperative program or a program model is a sequence of (possibly simultaneous) updates on state variables. In any step of the program, the current value of a variable is that of the most recent update looking backwards in the sequence. In a state frame, the state component calculates updates based on the current values of the variables. Making state first class in this setting, amounts to obtaining references to positions in the sequence backward from the current point of execution, and allowing a program execution to continue from a prior saved state, with an alternative sequence of further updates.","A state component represents update sets as frames holding the updates created in the current step linking backwards to frames of earlier updates. When a value for a particular variable is retrieved in the current state, the frames are walked backwards until an update for that variable is found. To speed-up further accesses on the same variable, a cache of the values of variables can be established. In one example, this cache can be realized by copying an update to the present frame from a prior frame when an access occurs. Thus, the next time the same variable is accessed, a walk backwards will only be necessary until the frame is reached where either the variable has been originally updated or has been last accessed.","Notice that there are at least two states being discussed here. A first state is an evolving present state of a program or model. It is the evolving state of a program or model that is defined or referenced as a first class citizen via an imperative program construct or paradigm. Once this program model or state is defined and referenced, it is saved in a data structure and can be accessed as a first class citizen from the program or model. The data structure comprising the saved state, or series of saved states of a program or model, is the second state saved in a state component (i.e., a state process\/thread, state model or state mechanism in this document); and includes the data and methods used to support state as a first class citizen.","One example of a state component supports dealing with sequential and parallel composition of imperative programs, features which support high-level modeling languages such as Abstract State Machine Language (ASML). On sequential composition, a sequence of frames can be collapsed into one frame. In that case, the sequence of frames is merged into a single frame, which contains the most recent updates of variables. In another example, supporting parallel execution, a parallel frame contains a link pointing to a frame it is in parallel with. On composition, parallel frames are merged building the union of updates of both frame chains while checking for racing conditions on updates on variables.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 1","b":["100","1","102","2","104","3","106","1","3","4","4","2","2","3","4","2","3","4","3","4","114"],"i":["a","a","a","a","b ","b","b ","b ","b ","b "]},"Reflection is one way to obtain information about program components. For example, using reflection, information about a program can be obtained such as its types, methods, and their properties. In one case, reflection can retrieve current values of variables of a program. However, present systems provide no method to reflect over partial or entire saved states of an evolving program, or return a program to a prior state using a semantically accessible state binding. By creating a first-class state instance, a program state is saved and a programmer can reflect over the program using a token referring to a saved state.","The current state of a program is defined and saved as a first-class state instance. The state component stores the present state of a program. And then, as the state changes, the state component allows the programmer to refer back to the state variables in prior states or reset the entire program to a prior saved state. Thus, a state component provides a way to reflect over the state of the program, or to return to a prior state and execute over different passes of the program in different states. This allows exploring the behavior of the program, for example, in test case generation or transactions processing.","The technology is not limited to any testing language, e.g. Abstract State Machine Language (ASML), but is available as a construct of any programming language or as a component in a shared library that any programmer could use in a programming framework language (e.g., .NET, Windows, etc.) to incorporate state as a first-class citizen into an application. Thus, any programming language could incorporate this feature via an interface to a dynamic link library, or implement the feature directly into a programming language as a language construct.","For example, Table 1 shows a series of instructions in a transaction processing scenario.",{"@attributes":{"id":"p-0035","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#include state.h"]},{"entry":[{},"State s = capture_state( );"]},{"entry":[{},"try {"]},{"entry":[{},"\u2003op1 ( );"]},{"entry":[{},"\u2003op2 ( );"]},{"entry":[{},"\u2003op3 ( );"]},{"entry":[{},"} on error {"]},{"entry":[{},"\u2003set_state(s);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In such a case, the state component is part of the runtime, e.g., common language runtime (CLR), and is available to other components desiring to utilize state as a first-class citizen.","Table 1 includes three operations op( ), op( ), and op( ) that should be executed automatically (e.g., a transaction processing scenario). Thus, no changes should remain unless all three can be completed successfully. If any of the steps cannot be completed, a failure occurs, and the state should be rolled back as if none of the operations had ever been started. Thus, a copy of the state is saved by capture_state( ) before any operation is conducted, and that saved copy is used to restore the program in the event of a transaction rollback by the operation set_state(s).","Here, conceptually with state as a first class citizen, the state of the program is copied by capture_state( ). In one example, if the program includes a database, it is copied along with variables and other state required to return to the moment the state was saved. In one example, the saved state includes IP, CALL STACK, REGISTERS, HEAP, etc. The saved state can be modified, for example by setting the instruction pointer (IP) to a different address, so that when the saved state is restored the program execution will continue at a different point. In another example, only the REGISTERS and the HEAP are saved.","So without knowing the details of the state of the program, the component user may save or recall all the potential variables at that moment in time, since a request to save the state of the program saves all this information. Additionally, the user requesting the state save can use this feature without calling out or defining which variables to save.","Rather, a programmer uses a function of the state component, capture_state( ) in this example, to requests a save at that point in time and the program declaring the state component is saved (e.g., \u201cSTATE s=capture_state( )\u201d implies state save). Because of the potential resources required to save the entire state of a program, methods and systems for improving the efficiency are discussed herein. The potential amount of saved information or data could be prohibitive for efficient use, so other methods are introduced for efficiency purposes. But semantically, these efficiencies would still have the effect of saving the entire state. Thus, transparent to the application programmer and without naming or individually identifying state, the state component saves the state of the variables.","For example, a transaction class relying on a state component, does not have to know about the individual variables and state of a program. Independent of knowing state, a program or component saves the state of the program using a function of the state component (or a programming mechanism), and then later reads or restores the state if necessary.","Prior to this technology, in transaction processing, each old value of a changed variable was individually saved when a transaction was declared. This data was then available to write back into the program to return to the pre-transaction state in case of a rollback.","Later in Table 6, a class transaction is defined based on a state application programming interface (API). Using the state API, a transaction class creates a transaction, defines a rollback point, and makes a copy of state. The transaction has a commit ( ), and a rollback ( ) function. The commit ( ) means leave the state changes alone, whereas the rollback( ) restores to the pre-transaction state using the rollback ( ) function, which calls the set function on the state class shown later in Table 4.","A state object (or function) is implemented as a feature of ASML, or added as a language construct to any programming language, or it can be a class introduced into a class library for integration into any programming language. Further, the concept can be added to the overall framework (e.g., CLR), or java runtime. Further, the component can be integrated into the system of any computer, so it can be called through its API by any language or other program, as part of the runtime library, and\/or dynamically linked as needed. In one sense, being a first-class citizen means being semantically accessible by a program or modeling language. An instantiated state mechanism or object is given a name that can be referred to in a program. For example, in Table 2, the state object \u201cs\u201d is created, and then later, possibly used in some error condition test to reset the program to the state at the time \u201cs\u201d was declared. In this example, \u201cState.Fork( )\u201d saves the state in \u201cs\u201d, and \u201cs.set ( )\u201d returns the program to the state saved at \u201cs\u201d.",{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"State s = State.Fork ( );"]},{"entry":[{},"X = 3"]},{"entry":[{},"Y = X + 2"]},{"entry":[{},"X = X + Y"]},{"entry":[{},"*"]},{"entry":[{},"*"]},{"entry":[{},"*"]},{"entry":[{},"s.set ( );"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"With previous rollback techniques, a set of values would have to be explicitly identified and written to a log so they could later be restored by systematically unwinding or rolling back one at a time.","As shown in , a tree  of saved states of a test model or program can be created using state as first class citizen. The tree represents saved state spaces of a program. A state is set S, , and an action is taken \u201caction a\u201d to arrive at another state S, and then state can be reset to S, , and then another action is taken \u201caction b\u201d, to arrive at state S. Once actions from state Sare complete, the state can be returned to S, where another action is taken \u201caction c\u201d to arrive at state S. Once state Sis determined, state is returned to state Sin order to determine the affects of\u201caction d\u201d, which causes S.","In this way, by using state as a first class citizen to examine a program state space, testing paths, or test cases, a program developer can elegantly return to a prior state space and introduce a new action on that state. It is desirable to examine and exercise the state space of a program under test. State as a first class citizen allows this to be done elegantly, without requiring a tester to record or individually save variables in the state space of the program.","Additionally, a state object can be used to generate tests for a program. For example, a model of a program can be generated in a modeling language such as ASML, C#, or others. By modeling, the program behavior is observed and test data is created.","For example, in , using a model represented by the tree , a set of actions would be developed as shown in Table 3.",{"@attributes":{"id":"p-0051","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Test #","Actions"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","action a"]},{"entry":["2","action b"]},{"entry":["3","action a, c"]},{"entry":["4","action a, d"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Programmatically, while in state S, the state is saved in a semantic programming construct (e.g., State S=State.save ( )), and later when performing test  and , state is reset to S(e.g., S.reset ( )). Then another set of actions are taken (e.g., Test , action a, c), in order to explore the Test  state space (e.g., S, S, S). In this example, a model is used to develop a state space to run on an actual program, so the action sequences of Table 3 are subsequently run on a real program. So the state object is used in this case to return to states in the model. An example program of how to generate inputs for testing is described in Barnett et al., \u201cConformance Execution of Non-Deterministic Specifications for Components,\u201d filed Feb. 20, 2002, U.S. patent application Ser. No. 10\/081,329.","Another use for a state component is in the development of non-deterministic models. For example, as shown in , a model and an implementation are run in parallel . In one case, the model is a specification indicating how the implementation should perform. The implementation has a state , and an action  causing a transition to a new state . Thus, the model has a model state , a model action causing a transition , and a resulting new modeled state .","In this example, an action  in the implementation takes the square root of 4, and the new state  includes a variable X=2.","Thus, the model includes a state , action  and state  specifying the desired behavior. In this case, the model is smarter than the implementation because it specifies an additional resulting state  for the same behavior .","In this example, the model is running in parallel with the implementation, and if the model arrives at a state  (i.e., X=\u22122) contrary to the implementation result  (i.e., X=2), then before the model determines that the implementation state result is wrong, the model returns to the previous state and tries another action  in order to determine if the implementation has arrived at another specified model state .","Conceptually, in order to preserve states for roll back, a copy of all the data that is in the programs running system is needed. This copy is called the \u201cbindings\u201d and it contains all the assignments of the variables. Optionally, timestamps can be introduced into saved states to show relative time of binding updates.","In an exemplary state class, a variable called bindings holds all of the variables related to the program or model that implements the state class. Additionally, an exemplary state class has a variable called origin which is a timestamp. Suppose in a program or model it is desirable to do some form of parallel paths of processing. This is useful, for example, to model state for two threads or to distinguish state for two paths of execution changing program state in divergent ways.","As shown in , a frame  is created at time tto hold a copy of the variables of the program at a given moment. At time t, parallel processing or other divergent paths record state changes ,  that occur after that moment. Thus, at , the program state is saved in a data structure (e.g., a state frame), changes made by a first thread are stored in frame , and changes made by a second thread are stored in frame .","A method of a state object allows a programmer to \u201cfork\u201d the execution path, whether as a thread or other divergent path through a program that may cause alternative data variable updates. In this example, every variable accessible by the program is saved in a frame , and carried forward into a forked copy of the frame . In this example, while following the divergent path, the Y variable in the new frame  is updated according to the executed instructions in the divergent path (e.g., Y is set to \u201c6\u201d ).","As shown, another frame  is used to represent data when the fork is not taken through a divergent path. In the unforked path , the X variable is updated (e.g., X is set to be \u201c6\u201d ).","It is desirable in some cases to converge two diverged paths back into a single frame. For example, if the two divergent frames represented state changes made by two different threads to a database (e.g., travel agents making changes to airline database), then it is desirable to determine whether the state changes are consistent, so that they can be merged back into one frame  representing the state of the single database. In this example, since one thread or process  changed different state data than the other , a combined or integrated frame can represent changes made to the database by both agents . Thus, the frames would contain the evolving state changes to both X and Y. This form of combining parallel frames ,  that include consistent changes is called parallel composition. In this example, each frame , , ,  includes a copy of the universe of variables. Next, an example of how to reduce the information in each frame is discussed.","When a fork is to an agent running under another processor clock, the agents running according to separate clocks can evolve completely independently, and then joined again later in parallel composition. For timestamps assigned by separate clocks, the parallel composition can be conducted so long as no unresolvable value conflicts occur (e.g., two distributed agents assign different values to same variable).",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 5","b":["502","504","502","506","504","508"]},"As shown in , frames  or individual data updates within frames can include timestamps (e.g., t, t, t, . . . ). In some examples, timestamps can help resolve possibly competing updates made by plural agents, such as in parallel processing and other divergent execution paths where the relative timing of updates are relevant later for parallel composition.","In this example , a first agent forks and the state object creates a divergent frame  to save state for this path\/thread. This first agent first does a read of variable X, and the read method of the state object walks a pointer  back to read the first frame containing the X variable.","In this case, the X variable was updated in the previous frame  at time t(i.e., X=4, t). In this example, as an added efficiency, the read variable is copied into the current frame  so a next read will not have to walk back to read X again.","Next, a second agent creates a divergent path (e.g., forks) and then updates the X and Z variables, which are stored in the divergent path frame  with timestamp t. The state object walked back beyond the  frame to read the Z variable for the update. Finally, when the first agent updates the Y variable, the state object updates the corresponding frame , with the updated value for Y (i.e., Y=7, t), and assigns the timestamp value t. (Notice, if the first agent forked from the executing program, the second agent may not need to fork if it is a continuation of the executing program.)","Finally, when the agents return from separate execution, changes can be merged (i.e., parallel composition) back into a new frame  if desirable. In this case, the timestamps on the competing X value bindings are used to determine which value  or  to assign to X in the composed frame . Since it is know known that the t update happened after the t ,  update, the latest value of the X value  is carried forward  into the composed frame . Thus, timestamps are useful in some cases for parallel composition.","In general time evolves sequentially. So when events are recorded by a state object recording state changes made by one agent, then the steps are sequentially ordered and composition is straight forward. However, once a fork occurs, even if agents maintain independent local time (e.g., separate clocks), they often still include values set with relative original time. This concept is helpful in understanding relative time for local processes and\/or threads versus distributed agents (e.g., distributed computing).","For example, if parallel frames ,  represent agents running with relative deterministic timing (e.g., on a single computer), then the relative time of value updates ,  are deterministic. However, if the parallel frames ,  represent frames for agents that run non-determinable relative timing (e.g., agents running according to different time clocks), then the order of updates may not be deterministic. In this example , that does not matter since timestamp toccurred before the fork. However, if time thad occurred in the forked frame  (instead of the prior frame), then the parallel frames ,  would be uncomposable in some cases because the last update of X is unknown.","Notice that parallel composition is not required for some uses discussed herein such as transaction processing and\/or analyzing program behavior by exhaustively traversing or creating execution paths. In those examples, a state is saved before beginning a transaction or execution path, and the state is reset if the transaction aborts, or the execution path is reset to a prior state before trying another action from the reset state.","As shown in , a tree data structure  is used to represent frames in relative order. In such a case, the tree data structure can also be used to represent relative time for timestamps. In such a case, relative time can be determined by the tree structure and actual timestamps are only optionally employed. Since the relationship of the tree maintains order, the actual timestamp can optionally be displayed to aid in human understanding. In this tree data structure, explicit timestamps are not required since the frames (i.e., the nodes of the tree), have edges (i.e., linked-lists, in this example double linked-lists) pointing to the frames that occurred before and after each frame. In such an implementation, timestamps are not required. As discussed, the backward links are used to obtain bindings to values that occurred earlier in time in the frame chain. However, the conceptual or actual implementation of time values can be valuable in representing relationships to humans.","As shown in , a computer system  includes a hard drive , one or more processors , and main memory . The processor(s)  execute programs  which include instructions , and data and\/or state . A state program or component  includes instructions , and data and\/or state . In one example, a state program or component  is linked (e.g., dynamically linked) into another program or component  to save data or state  of the program or component . In another example, a state program or component  is a model or specification of another program  and is used to generate or specify expected states for the program or component. This would be useful, for example, in generating inputs that exercise the program or component for conformance testing. Additionally, this would be useful for generating expected outputs for testing the program or component . Whether generating inputs for testing or generating outputs for testing, the ability to mark and save status along the way saves time and resources since prior states can be reinstated. Once a state is reinstated, other paths or inputs can be taken from that state thereby examining the state space without starting at the program beginning.","Additionally, if a state component is integrated into a program or component, a prior state in the program can be reinstated without aborting work done by the program before the state was saved (e.g., before transaction processing commenced).",{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 9","b":"900"},"At , a model or program is executing including program instructions and state.","At -, an event causes an action by a state component. In one example, the program has made an application programming interface call on a state component. In another example, a programmer has included certain instructions in an application that causes a compiler to embed certain instructions in the binary code that invokes one of the events. Other scenarios could be used to cause the program to call an instruction or request a system service to perform events or services handled by a state component. However, the program itself has instructions and state, and the frames discussed in light of this method record a copy of the program state at certain times in a state component state frame, and other state frames record state changes occurring in the program in subsequent state frames. Additionally, updates made by the program to its own state are also recorded by the state component in present frames. Present frames containing only updates since a prior save, can themselves hold intermediate states when new save or fork events occur. In light of this example method, many variations of state frame saving chains will become readily apparent to those skilled in the art and are included in the scope and spirit of this technology.","While a program or model executes , a state save request is made . If the state save request is the first state save for this program execution (e.g., an origin state save) , the entire state of the executing program is saved , and a new present frame is created  to hold future updates to this saved frame. If an origin frame already exists, then a present frame is saved as the saved frame , and a new present frame is created  to save updates occurring by the executing program. Whether or not an origin save frame is created, the new present frame has a back pointer to the saved frame . As the program continues , the state changes of the program are stored as updates in the present frame .","At , the event is a fork request for parallel processing (e.g., distributed computing, multiple threads, etc.). The fork request is not an origin save request, so the existing present frame is saved in present form , and a new present frame  is created to save updates made by the forking agent\/processor thread), and a pointer back to the prior state frame  is added to the present forked frame. Then execution returns to the program .","At , a state set request is received from the executing program. The state component sets the program state back to the identified set state , and then a new present frame is created  by the state component to receive updates made by the program after the state is set to the identified prior state.","At , a request to join frames is made by the program. The frames are composed (sequential\/parallel), the composed frame is then saved , and then a new present frame is created  with a pointer back  to the two frames from which it was composed if parallel composition was performed, or back to a single frame  if sequential composition is performed on two adjacent sequential frames. As before, execution returns to the program .","During a state set request , if a request to set state is to a saved state after an origin state, then the origin state and the intermediate saved states leading to the requested set state are accessed (walked) to obtain the entire state information for the requested set state.","At , a variable or state update is made by the program to its own state. This generates an event that causes the state component to record a copy of the update in present state frame of the state component , before the program continues execution. Upon a next save or fork, the present frame contains these updates, and forms the basis for the next frame in the chain.","A save could be called every time a variable is changed, however, this is not efficient. Thus, so long as the present state is not a state that it will be desirable to return to, no save is necessary and the update is simply saved to the present frame. Further, if a save is requested, and later it is determined that the save is unnecessary since there is no need to return to the saved state (e.g., upon completion of a transaction after a commit), then sequential composition is used if it is then desirable to reduce the size of stored state information. In such a case, a join method is called on two frames, and they are sequentially composed into one frame.","In existing imperative programming paradigms, the state of the program is not a semantically accessible program object itself and cannot be reflected and dealt with programmatically without knowing its concrete structure.","Having program state as a first-class citizen and allowing programs to reflect over it has various benefits. For example, transactions are a software-engineering technique which allows grouping a sequence of operations into an atomic operation; if any of the constituting operations fails the entire transaction is rolled back, undoing possible state changes successful constituting operations did before the failure point. Transactions have been desirable as an integral part of recent programming frameworks like the one for .NET or J2EE. With state as first class citizen, powerful and easy to use transactional mechanisms are available as part of a framework library.","Additionally, analyzing program behavior by exhaustively trying all execution paths of a program for model checking or test case generation is more efficient with semantically accessible state objects. State as first-class citizen facilitates this search since it allows representing the frontier of possible programming states during a search. Thus, as the frontier is developed, a search returns to frontier states and explores other execution options without returning to start states.","In one example, state as a first class citizen is integrated into the ASML modeling language or into any programming language as an accessible programming construct.","Although the technology is not limited to any specific API for programming with state as an accessible construct, general concepts are better understood in the context of an example or two. Such examples would include being able to create a copy of the current program state, setting the current state to a previously created copy (essentially continuing execution with the exact state at the time the copy was created), and joining a copied state to the current state, thereby checking whether the states are consistent (two parallel states cannot both have updated a binding to different value at the same times).","An example API for this functionality is shown in Table 4.",{"@attributes":{"id":"p-0092","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 4"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Class State \/\/ represents a state handle"]},{"entry":[{},"\u2003Fork ( ) \/\/ creates a copy of the current state"]},{"entry":[{},"\u2003Set ( ) \/\/ sets the current state to the one of this handle"]},{"entry":[{},"\u2003Join ( ) \/\/ joins the state of this handle to the current state"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"For a programming language including a state component, updates on the program state will be done in the usual way according to the underlying programming language (by assignments to local variables or to fields). However, a compiler upon encountering a state object programming construct in the source code, will emit instructions that have the effect of recording state updates made to the program into a state frame of a state component or data structure. As shown in Table 5, exemplary compiler emitted instructions include an update and a read instruction. The actual location of the state (e.g., state frame) and the value of the update (e.g., data type, field, etc.) will vary based on the programming or modeling language using the technology. In this example, a read or update is of the present or current state. In order to read or update another state, first make that state the current state (i.e., \u201cs.set ( )\u201d).",{"@attributes":{"id":"p-0094","num":"0093"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Class state"},{"entry":"\u2003compilerinternal shared update (location as location, value as value)"},{"entry":"\u2003compilerinternal shared read (location as location) as value"},{"entry":"type location"},{"entry":"type value"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Table 6 is one example of how to implement transactions using an API as a regular framework component.",{"@attributes":{"id":"p-0096","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 6"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class Transaction"]},{"entry":[{},"\u2003rollbackPoint as State \/\/ define rollback as state"]},{"entry":[{},"\u2003Transaction ( )"]},{"entry":[{},"\u2003\u2003rollbackPoint := State.Fork( )"]},{"entry":[{},"\u2003Commit ( )"]},{"entry":[{},"\u2003\u2003Skip \/\/ just do nothing"]},{"entry":[{},"\u2003Rollback ( )"]},{"entry":[{},"\u2003\u2003rollbackPoint.Set ( ) \/\/ rollback to bindings set at state definition"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In another example, an API includes a temporal relationship of state changes with a time stamp. A timestamp identifies a position in a partial ordered domain of time. A state object can include an initial time, and can create new time stamps by the method \u201cForkTimestamp\u201d as shown in Table 7. Given a timestamp t, ForkTimestamp produces two timestamps t and t, such that t and t are incomparable (i.e., two independent branches), and t<t and t<t (i.e., t and t are later in time than t).",{"@attributes":{"id":"p-0098","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 7"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class Timestamp"]},{"entry":[{},"\u2003GetInitialTime ( ) as Timestamp"]},{"entry":[{},"\u2003ForkTimestamp (t as Timestamp) as (Timestamp, Timestamp)"]},{"entry":[{},"\u2003Comparable (t1 as Timestamp, t2 as Timestamp) as Boolean \/\/"]},{"entry":[{},"\u2003\u2003two different timelines are not comparable"]},{"entry":[{},"\u2003Less (t1 as Timestamp, t2 as Timestamp) as Boolean"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As discussed below, time stamps help argue about relative time of updates on variables when joining states. More specifically, if the states contain updates of a variable x at different times t and t, then if t<t (or t<t) one of the updates proceeds the other one and overwrites it. But if the time stamps are incomparable, then a race condition needs to be resolved.","An example state class including timestamps is shown in Table 8. The state class contains bindings and a timestamp. Updates of the current state will be associated with this origin timestamp, in relative order.",{"@attributes":{"id":"p-0101","num":"0100"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 8"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class State"]},{"entry":[{},"\u2003var bindings as Bindings \/\/ of all \u201clocations\u201d that can have values"]},{"entry":[{},"\u2003var origin as Timestamp \/\/ t0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The bindings are a map of locations to their respective values and timestamps indicating their last update, as shown in Table 9. Each location represents a variable of the program.",{"@attributes":{"id":"p-0103","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 9"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type Bindings = Map of Location to (Value, Timestamp)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"There is one distinguished \u201ccurrent state,\u201d where states changes of the executing program apply to the current state. In one example, a current state is initialized by a state with no bindings and the initial time, as shown in Table 10.",{"@attributes":{"id":"p-0105","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 10"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Var currentState as State = new State ({\u2212 >}), Get InitialTime ( ))"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"An exemplary state class includes a fork method that not only creates a copy of the current state, but it also advances the time of the current state and creates an independent time branch for the new copy using ForkTimestamp, as shown in Table 11.",{"@attributes":{"id":"p-0107","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class state"]},{"entry":[{},"\u2003shared Fork ( ) as State\/\/ define rollback as state"]},{"entry":[{},"\u2003\u2003let (t1, t2) = ForkTimestamp (currentState.origin)"]},{"entry":[{},"\u2003\u2003currentState.origin : = t1"]},{"entry":[{},"\u2003\u2003return new State (currentState.bindings, t2)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Any state can be made the current state as shown in Table 12. There is always one \u201ccurrent state\u201d so an executing agent implicitly refers to the state in which he is executing. And the agent running is any program that has included the state object within its program space and declared a state object.",{"@attributes":{"id":"p-0109","num":"0108"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 12"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class state"]},{"entry":[{},"\u2003set ( )"]},{"entry":[{},"\u2003\u2003currentState := me"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As shown at  in , a state can be joined  with the current state, thereby creating a new current state. If a location appears only in either of the two involved bindings , its assignment is taken over into the resulting binding . If a location appears in both , a resolving mechanism is applied .","As shown in the resolve method , if a same location was updated by both of the two involved bindings, and the updates occurred in an order determinable by the timestamps, then the second update to the location  is applied. However, if the updates occurred at temporally indeterminable times, then the conflicting updates are composed according to a method defined according to such factors as the data type and the program function. For example, for a certain program or data type a conflict can be defined by a data type or a user, or presented to a user for clarification upon an occurrence. Additionally, the bindings of the current state can be updated , and the current value of a location can be read .","The resource costs associated with saving the entire state of a program many times could become prohibitive. Thus, as an efficiency option, state frames are implemented at runtime as frames linked by back pointers. In that case, each frame only contains the updates that were applied in the corresponding state. This significantly minimizes the memory needed to represent a state and reduces the time needed to fork a state. When the current or present state is forked or saved, a complete copy of all bindings is not created. Instead, a new empty frame (i.e., new present frame) is created which has a back pointer to the previous state frame. The complete set of bindings of a state can be computed by following the back pointer of the frames. No time stamps are required, as the time tree is implicitly encoded in the tree structure induced by the back pointers . In one example, garbage collection of the runtime takes care of abandoned frames. In one example, if a frame can only be reached by exactly one back pointer, it can be merged with the frame from which the back pointer originates.","Thus, the current value of a location x does not need to be present in the frame of the current state, but it might be necessary to follow the back pointers to find the last update of x. In order to avoid this costly computation every time the current value is read, a cache of current values that have been read previously in is established. Whenever the size of this cache grows above a certain threshold, it is purged. or it can be purged partially as needed (e.g., last used overwritten first). For many applications, such a cache provides fast access to commonly used locations using a minimal memory footprint.","As shown in , a frame data structure  contains a reference pointer  indicating how many frames point back to it (e.g., frame  has reference count  because  and  point back to it). If there is one pointer pointing back to a frame , and that prior frame is not an explicit state or fork frame, then an optimization is to sequentially compose the present frame with the prior frame (e.g., combine  with ). Thus, if a frame has two frames that point back to it, then it represents a fork, and thus the current frame should not be composed with the prior forked frame.","As discussed with respect to , an explicit state frame is saved at Sso that it can be reset to that state in order to travel down several test paths (e.g., action c and action d). Thus, as shown in , when a frame  includes two or more back points to it , , optionally, neither of the frames containing back pointers to that frame should compose content back into that prior frame  since the other fork may later need to return to that state .","Additionally, if a frame is an explicit state save frame  (e.g., a transaction or other explicit state object origination), then that explicit frame , optionally, should not be composed with a subsequent frame , because a set action may later attempt to rollback to that state  explicitly.","When two agents return from a fork, it may be desirable to determine whether their divergent resulting states can be composed into a consistent new state (e.g., ). In cases where two agents attempt to update a variable to two different values, this may not be possible, and one of the agents work may need to be abandoned, if no other conflict resolution as defined by a state component user. However, in other cases based on the date type and operation conducted by the agents, parallel composition is desirable. For example, if a variable is a set of values, and two agents add members to the set, a composed frame would be the union of the set numbers.",{"@attributes":{"id":"p-0118","num":"0117"},"figref":"FIG. 12"},"With reference to , an exemplary system for implementation includes a conventional computer  (such as personal computers, laptops, servers, mainframes, and other variety computers) includes a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The processing unit may be any of various commercially available processors, including Intel x86, Pentium and compatible microprocessors from Intel and others, including Cyrix, AMD and Nexgen; Alpha from Digital; MIPS from MIPS Technology, NEC, IDT, Siemens, and others; and the PowerPC from IBM and Motorola. Dual microprocessors and other multi-processor architectures also can be used as the processing unit .","The system bus may be any of several types of bus structure including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of conventional bus architectures such as Peripheral Component Interconnect (PCI), standards proposed by the Video Electronics Standards Association (VESA), Accelerated Graphics Port, also called Advanced Graphics Port (AGP), Microchannel, Industry Standard Architecture (ISA) and Extended Industry Standard Architecture (EISA), to name a few. The system memory includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS), containing the basic routines that help to transfer information between elements within the computer , such as during start-up, is stored in ROM .","The computer  further includes a hard disk drive , a magnetic disk drive , e.g., to read from or write to a removable disk , and an optical disk drive , e.g., for reading a CD-ROM disk  or to read from or write to other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical drive interface , respectively. The drives and their associated computer-readable media provide nonvolatile storage of data, data structures, computer-executable instructions, etc. for the computer . Although the description of computer-readable media above refers to a hard disk, a removable magnetic disk and a CD, it should be appreciated by those skilled in the art that other types of media which are readable by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, and the like, may also be used in the exemplary operating environment.","A number of program modules may be stored in the drives and RAM , including an operating system , one or more application programs , other program modules , and program data ; in addition to this technology .","A user may enter commands and information into the computer  through a keyboard  and pointing device, such as a mouse . These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor, computers typically include other peripheral output devices (not shown), such as speakers and printers.","The computer  operates in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a server, a router, a peer device or other common network node, and typically includes many or all of the elements described relative to the computer , although only a memory storage device  has been illustrated. The logical connections depicted include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the local network  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications (e.g., via the LAN  and a gateway or proxy server ) over the wide area network , such as the Internet. The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Having described and illustrated the principles of our invention with reference to an illustrated examples, it will be recognized that the examples can be modified in arrangement and detail without departing from such principles. It should be understood that the programs, processes, or methods described herein are not related or limited to any particular type of computer apparatus, unless indicated otherwise. Various types of general purpose or specialized computer apparatus may be used with or perform operations in accordance with the teachings described herein. Elements of the illustrated embodiment shown in software may be implemented in hardware and vice versa. Techniques from one example can be incorporated into any of the other examples.","In view of the many possible embodiments to which the principles of our invention may be applied, it should be recognized that the details are illustrative only and should not be taken as limiting the scope of our invention. Rather, we claim as our invention all such embodiments as may come within the scope and spirit of the following claims and equivalents thereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
