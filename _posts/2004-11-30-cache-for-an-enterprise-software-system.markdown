---
title: Cache for an enterprise software system
abstract: Techniques are described for caching data from a software system, such as an enterprise software system. The techniques may be applied to a computing device connected to the software system via a network. In one example, the cache comprises an elegant, file-based cache that includes an object store that stores the cached data and an allocation table that manages allocation of space in the object store. The caching techniques provide a robust storage system which preserves a previous copy of the allocation table while updating the current table. Moreover, cache management techniques are described that utilize an automatic collapse to keep cache file sizes to a minimum. When multiple software applications are executing on the computing device, the techniques allow concurrent access to the cache by the multiple software applications while maintaining the integrity of the stored data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07418567&OS=07418567&RS=07418567
owner: International Business Machines Corporation
number: 07418567
owner_city: Armonk
owner_country: US
publication_date: 20041130
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The invention relates to software systems and, in particular, techniques for caching data from an enterprise software system.","Enterprise software systems are typically sophisticated, large-scale systems that support many, e.g., hundreds or thousands, of concurrent users. Examples of enterprise software systems include financial planning systems, budget planning systems, order management systems, inventory management systems, sales force management systems, business intelligent tools, enterprise reporting tools, project and resource management systems and other enterprise software systems.","A user may be connected to the enterprise software system via a network. Typically, a user device includes at least one cache to store data requested by the user. In this way, system performance can be improved since future requests for data can be fulfilled locally from the cache without having to repeatedly retrieve the same data from the enterprise software system. Many conventional caching approaches are complex and utilize database applications, such as Access\u2122 from Microsoft Corporation of Redmond, Wash.","In some environments, the user device may concurrently run several software applications, such as modeling tools and reporting tools, in the case of an enterprise planning system. In that case, the cache must be capable of handling concurrent data requests from the multiple software modules. However, conventional caching techniques often have difficulties dealing with software module contention or do not allow concurrent access to the cache at all. Furthermore, as the cache continues to store retrieved data, the large amount of storage space required by the cache may disrupt operation of the user device, often requiring the user to intervene to reduce the size of the cache.","In general, the invention is directed to techniques for caching data from a software system, such as an enterprise software system. For example, the techniques provide efficient storage and retrieval of data in an elegant, file-based cache. The cache includes an object store that stores the cached data and an allocation table that manages allocation of space in the object store. The techniques provide a robust storage system which preserves a previous copy of the allocation table while updating the current table. Moreover, the techniques include automatic collapse to keep cache file sizes to a minimum.","As an example, the techniques may be applied to a computing device connected to the enterprise software system via a network. When software modules executing on the computing device request data from the software system, the data is stored locally in a cache, as described herein. In this way, system performance may be improved as the cache allows the computing system to locally fulfill future requests for previously requested data without having to repeatedly retrieve the same data from the remote enterprise software system.","Multiple software applications may be executing on the computing device. The techniques allow concurrent access to the cache by the multiple software applications while maintaining the integrity of the stored data. For example, the cache provides a mutual exclusion object (mutex) to ensure that each software application retrieves current data from the cache.","In one embodiment, a computer-implemented system comprises a cache and a plurality of software applications. The cache includes an object store to store data and a plurality of allocation tables to manage allocation of storage space in the object store; the allocation tables include an active allocation table and at least one inactive allocation table. The plurality of software applications executing within an operating environment of a computer utilize the active allocation table to access cached data in the object store.","In another embodiment, a method comprises storing data in an object store of a cache on a computing device and managing allocation of storage space in the object store with a plurality of allocation tables. The allocation tables comprise an active allocation table and at least one inactive allocation table. The method further comprises executing a plurality of software applications on the computing device, wherein the plurality of software applications utilize the active allocation table to access cached data in the object store. The method also includes switching the active allocation table to a next one of the allocation tables after a cache operation by one of the plurality of software applications.","In a further embodiment, a computer-readable medium comprises instructions that cause a programmable processor of a computing device to store data in an object store of a cache on a computing device and manage allocation of storage space in the object store with a plurality of allocation tables, wherein the allocation tables comprise an active allocation table and at least one inactive allocation table. The instructions also cause the programmable processor to execute a plurality of software applications on the computing device, wherein the plurality of software applications utilize the active allocation table to access cached data in the object store, and switch the active allocation table to a next one of the allocation tables after a cache operation by one of the plurality of software applications.","In another embodiment, a computer-implemented system comprises a cache and a plurality of software applications. The cache includes an object store and an allocation table. The object store stores data allocations and key allocations and each of the key allocations includes a link table to associate the key allocation with one of the data allocations. The plurality of software applications utilize the allocation table to access the cached data in the object store.","In an additional embodiment, a method comprises storing data in an object store of a cache on a computing device and storing a key in the object store of the cache. The object store stores the data and the key as separate allocations and the key allocation includes a link table to associate the key allocation with the data allocation. The method further comprises managing the allocations in the object store with an allocation table of the cache and executing a plurality of software applications on the computing device. The software applications utilize the allocation table to access the cached data in the object store.","In a further embodiment, a computer-readable medium comprising instructions that cause a programmable processor of a computing device to store data in an object store of a cache on a computing device and store a key in the object store of the cache, wherein the object store stores the data and the key as separate allocations and the key allocation includes a link table to associate the key allocation with the data allocation. The instructions also cause the programmable processor to manage the allocations in the object store with an allocation table of the cache and execute a plurality of software applications on the computing device, wherein the software applications utilize the allocation table to access the cached data in the object store.","In another embodiment, an enterprise planning system comprises a remote database system and a computing device. The database system stores modeling data defining a plurality of nodes and enterprise planning data associated within each of the nodes. The computing device includes a plurality of enterprise planning software applications and a cache that comprises an object store and an allocation table. The enterprise planning software applications access the enterprise planning data and perform an enterprise planning session. The cache stores the enterprise planning data retrieved from the remote database system for use by the enterprise planning software applications.","The details of one or more embodiments of the invention are set forth in the accompanying drawings and the description below. Other features, objects, and advantages of the invention will be apparent from the description and drawings, and from the claims.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 1","FIG. 1"],"b":["4","10","12","12","12","14","14","16","16","16","18","12","14"]},"For exemplary purposes, the invention will be described in reference to an enterprise planning system, such as an enterprise financial or budget planning system. The techniques described herein may be readily applied to other software systems, including other large-scale enterprise software systems. Examples of enterprise software systems include order management systems, inventory management systems, sales force management systems, business intelligent tools, enterprise reporting tools, project and resource management systems and other enterprise software systems.","In general, enterprise planning system  enables and automates the reconciliation of top-down targets with detailed bottom-up forecasts for an enterprise. Enterprise planning system  implements and manages an enterprise planning process, which can be divided into three functions: (1) modeling, (2) contribution, and (3) reconciliation.","Initially, high-level enterprise managers or executives, referred to as analysts, define organizational targets, and build planning models for the enterprise. The analysts may include, for example, financial analysts, such as the chief financial officer, senior financial analysts or product and sales analysts. More specifically, the analysts develop a model having a number of hierarchically arranged nodes representing various cost centers within the organization, such as business units or departments. The analysts specify corporate target data for each node of the organizational hierarchy. Corporate target data may include financial data, revenue data, order data, inventory data, and the like, depending on the particular enterprise planning activity being carried out by the enterprise. The analysts then assign one or more enterprise users to each node, such as managers, supervisors, sales representatives, lab managers, or the like, that are responsible for enterprise planning for the cost center corresponding to the node. Each enterprise user may be designated as a contributor that provides planning data to enterprise planning system , a reviewer that accepts or rejects contributions from the contributors, or both. The contributors and reviewers may be authorized users within the enterprise or within other entities coupled to network , such as suppliers or customers.","Next, enterprise users  that are designated as contributors interact with enterprise planning system  to input detailed forecasts in the form of contribution data. As described above, enterprise users  may provide detailed financial forecasts, revenue forecasts, order forecasts, inventory forecasts, estimated resource requirements, and the like, depending on the particular enterprise planning activity being carried out by the enterprise.","Enterprise planning system  automates the reconciliation of the forecast data with the corporate target data provided by the analysts. In particular, enterprise planning system  operates in accordance with a defined model, i.e., the enterprise planning model created by the analysts, to provide a hierarchical planning process having multiple reconciliation levels. As each of the contributors provides his or her contribution data, enterprise planning system  automatically aggregates the contribution data across the enterprise in real-time, and provides access to the aggregated data to enterprise users  designated as reviewers associated with higher levels of the enterprise. In particular, upon receiving contribution data from the contributors, enterprise planning system  identifies all higher levels of the organizational model affected by the newly received contribution data, and calculates new aggregate totals at each level in real-time.","Consequently, the reviewers view aggregated data across the enterprise in real-time during the enterprise planning session. At each level, enterprise planning system  ensures that the reviewers, as defined by the nodes of the enterprise model, reconcile the target data with the forecast data. Each of the reviewers may, for example, reject or accept the contribution data in view of corporate targets provided by the analysts. This process continues until the contribution data is ultimately approved by the highest level of the organizational hierarchy, thereby ensuring that the contribution data from the contributors reconciles with corporate targets provided by the analysts.","In this manner, enterprise planning system  may provide more accurate enterprise planning than with conventional techniques. For example, enterprise planning system  may improve the accuracy and predictability of enterprise planning by enabling organizations to reconcile corporate models and organizational targets with detailed forecasts. The techniques may provide a platform that delivers collaborative, real-time planning capabilities, without requiring offline consolidation and aggregation of forecasts. Because enterprise planning system  can aggregate contribution data in real-time, all users  can be presented with an accurate, up-to-date view of the numbers. Further, the architecture of enterprise planning system  can readily scale to thousands of users, and may be designed around best planning practices. In addition, the techniques enabling high participation by enterprise users , i.e., the contributors and reviewers, allowing accurate planning cycles to be reduced","Enterprise users  may use a variety of computing devices to interact with enterprise planning system  via network . For example, an enterprise user may interact with enterprise planning system  using a laptop computer, desktop computer, or the like, running a web browser, such as Internet Explorer\u2122 from Microsoft Corporation of Redmond, Wash. Alternatively, an enterprise user may use a personal digital assistant (PDA), such as a Palm\u2122 organizer from Palm Inc. of Santa Clara, Calif., a web-enabled cellular phone, or similar device.","Network  represents any communication network, such as a packet-based digital network like the Internet. In this manner, system  can readily scale to suit large enterprises. Enterprise users  may directly access enterprise planning system  via a local area network, or may remotely access enterprise planning system  via a virtual private network, remote dial-up, or similar remote access communication mechanism.","Enterprise planning system  may utilize a \u201ccut-down\u201d process by which the multidimensional data store is \u201csliced\u201d for each user  in accordance with the defined enterprise model. During this process, enterprise planning system  identifies areas of the defined model to which users  are assigned, either as contributors or reviewers, and \u201cslices\u201d the data store based on the assignments. When a given user  logs in and proceeds with an enterprise planning activity, enterprise planning system  communicates the respective data slice to the respective computing device  for display to the user via the extended spreadsheet application. In this fashion, enterprise planning system  need not communicate the entire model to each of users , thereby reducing communication time as well as resource requirements. Instead, each user  receives only relevant information. Users  interact with computing devices  to capture contribution data, and to reconcile the contribution data with organizational targets.","As described herein, each of computing devices  may maintain at least one cache (not shown in ) to locally store data requested by corresponding user  from enterprise planning system . In accordance with the techniques described herein, each computing device  provides efficient storage and retrieval of data from the cache, which may be implemented in one embodiment as a file-based cache. As further described, the cache includes an object store to store the cached data. In one embodiment, the object store links the stored data with keys, and further includes one or more allocation tables that manage the allocation of space within the object store. In some embodiments, enterprise planning system  may also utilize the techniques described herein to implement an efficient caching scheme.","The caching techniques, described in more detail below, provide a robust storage system, and may automatically collapse the cache as needed to keep cache size to a minimum. Moreover, the client-side caches implemented on computing devices  support concurrent access by multiple software applications that may be executing on each of the computing devices while maintaining the integrity of the stored data.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 2","b":["16","14","16","20","26","28","29","22","24","20"]},"Persistent storage  includes a plurality of caches  such that data required during the planning session may be locally cached. Persistent storage  may comprise a persistent computer-readable medium. In this way, caches  allow computing system A to locally fulfill future requests for the cached data without having to repeatedly retrieve the same data from enterprise planning system  or data cube .","In one embodiment, calculation engine  comprises a forward calculation engine  wrapped in an Active X object built in an array-based language. In the example of enterprise planning, user A may interact with web browser  to enter and manipulate budget or forecast data. Data cube  contains planning data, which may include top-down targets, and bottom-up contribution data, and allows all calculations for an enterprise planning session to be performed locally by computing device A. Therefore, in this example, a contributor can modify his or her respective contribution data, and perform calculations necessary for the enterprise planning process without necessarily accessing enterprise planning system . In other words, calculation engine  and data cube  may be maintained locally (e.g., as ActiveX components) via computing device A. User A may save the planning data locally, and submit the planning data to enterprise planning system  for aggregation with the planning data from other users . Enterprise planning system  automatically aggregates the contribution data across enterprise  in real-time, and provides access to the aggregated data to reviewers associated with higher levels of the enterprise. This process continues until the contribution data is ultimately approved by the reviewers associated with the highest level of the organizational hierarchy, thereby ensuring that the contribution data from the contributors reconciles with corporate targets. In other embodiments, calculation engine  and data cube  may be maintained only at enterprise planning system  and installed locally upon computing devices .","Planning applications  represent software applications that may be simultaneously executing on computing device A. For example, planning applications  may include reporting tools, modeling tools, spreadsheet applications, data collection templates, business intelligence tools, or other types of enterprise planning applications.","As illustrated in , computing device A includes caches  to locally store data requested by planning applications  or user A, e.g., data requested from enterprise planning system  or data cube . Examples of caches  include an online cache for storing data used by on-line planning applications, an offline cache for storing data used by offline planning applications, an extension cache for storing data used by software extensions, and a \u201cjce\u201d cache that is used to store data used by calculation engine .","Computing device A provides efficient storage and retrieval of data from caches . For example, caches  may be implemented as file-based caches, which are not dependent on database applications, such as Microsoft Access. Therefore, caches  may allow for more elegant caching techniques and comprise a smaller footprint than conventional caches.","The cache management techniques applied to caches  provide a robust storage system, and may automatically collapse caches  as needed to keep cache file sizes to a minimum. Computing device A may initiate a collapse when either the number of files within one of caches  or the overall size of the cache reaches an upper limit. User A may set the upper limit. In other cases, computing device A may set the upper limit based on the amount of free space available on computing device A. User A may also be able to initiate a collapse of one or more of caches  at any time. Collapsing one of caches  in effect \u201ccleans up\u201d the cache by removing unused space and reorganizing the file structure to minimize the overall size of the cache.","The caching management techniques allow concurrent access to caches  by planning applications . In order for each of the planning applications  to concurrently access caches , each of caches  may comprise a mutual exclusion object (mutex). The mutex allows one of the planning applications to lock one of caches  from the other planning applications while accessing the cache. In this way, the caching management techniques ensure that each of planning applications  retrieves current data from caches .","Computing device A also includes allocation table manager . As described in more detail below, each of caches  includes an object store to store the cached data and link the cached data with keys. Each of caches  also includes an allocation table that manages the allocation of space in the object store. Each of planning applications  may utilize allocation table manager  to create an instance of the allocation table from each of caches . In addition, allocation table manager  provides an application programming interface (API), which communicates cache operations to caches . Planning allocations  execute the cache operations on the allocation table within each of caches .","In some embodiments, persistent storage  may include one or more plug-ins (not shown), applied to caches  to execute data transformations before the data is persisted to disk. One plug-in may comprise a compression module for automatically compressing the cached data, and decompressing the data when requested by user A. In this way, additional caching may occur since compressing the data relinquishes storage space in caches . Therefore, a compression plug-in may enable computing device A to collapse caches  less frequently. Another plug-in may comprise an encryption module for automatically encrypting the cached data and decrypting the data when requested by user A. In some cases, persistent storage  includes two or more plug-ins to apply to caches . In that case, the two or more plug-ins execute in reverse order when retrieving data than when storing data in caches .",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 3","FIG. 3","FIG. 3","FIG. 2"],"b":["16","28","28","27","27","30","32","30","32","30","30"]},"Each allocation listed in allocation table  corresponds to an allocation of space within object store , and includes a set of properties associated with the allocation. For example, allocation table  may include an offset of the allocation from a first allocation, a size of the allocation, an amount of free space in the allocation, and an indication of whether the allocation is active or inactive. Each key object stored in object store  may include a link table or other data to associate the key with a corresponding cached data object stored elsewhere in object store . In some cases, the link table also associates the key with one or more corresponding metadata objects. The link table may reference allocation table  in order to determine an offset of the desired data object. The offset may then be used to locate the data object within object store . In this way, cache A utilizes an elegant and efficient file-based caching process.","Allocation table manager  may, for example, comprise a dynamic link library (DLL) that includes an allocation table manager class. Each of planning applications  may instantiate a respective allocation table manager object  of the allocation table manager class. Allocation table manager objects A-N (collectively, \u201callocation table manager objects \u201d) each expose an application programming interface (API) by which planning applications  interact with cache A.","In the illustrated embodiment, the APIs comprise communication interfaces A-N (collectively, \u201ccommunication interfaces \u201d). Communication interfaces  communicate connect and disconnect requests as well as cache operations from corresponding planning applications  to cache A. Examples of cache operations available via communication interfaces  include select, insert, update, remove and shrink. Allocation table manager objects  execute the cache operations on allocation table . For example, selecting an allocation for use by one of planning applications , inserting a new allocation, updating an existing allocation, removing an allocation (i.e., marking an allocation inactive) or collapsing allocation table .","In order to connect planning application A, for example, to cache A, communication interface A receives information from cache A and uses the information to establish the connection. Planning application A may remain connected to cache A even when not accessing cache A. Therefore, each of planning applications  may be simultaneously connected to cache A. Once planning applications  are connected to cache A, allocation table manager objects  may respectively create table instances A-N (collectively, \u201ctable instances \u201d) of allocation table  from cache A. Each of allocation table manager objects  reads the contents of allocation table  into memory associated with corresponding planning applications .","Prior to executing cache operations on allocation table , allocation table manager object A compares table instance A with allocation table  for discrepancies. Allocation table  may include a global unique identifier (guid) within a header that changes each time a modification occurs in allocation table . If the guid associated with table instance A does not match the guid associated with allocation table , allocation table manager object A updates table instance A. Each allocation within allocation table  may also include a guid. The guid associated with a particular allocation may be compared to the guid of the corresponding allocation within table instance A. Therefore, allocation table manager object A may reload only those allocations that are different between the two files, i.e., a warm load. However, in some cases allocation table manager object A may reload the entire allocation table  into table instance A, i.e., a cold load.","Allocation table manager object A may then execute cache operations from software application A based on table instance A to modify data stored in object store  within cache A. The cache operations may comprise atomic operations, which open, modify, and close allocation table  for each cache operation performed on table instance A.","In order to allow concurrent access to cache A by planning applications , application table manager objects  utilize a shared mutex to control access to the cache. The mutex allows one of planning applications  to lock cache A from the other planning applications while accessing cache A. In this way, the caching management techniques ensure that each of planning applications  retrieves current data from cache A.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 4","FIG. 3"],"b":["30","30","40","42","44","40","41","44","41","40","42"]},{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 5","FIG. 4"],"b":["41","41","40","42","44","32","32","30","41","40","42","44","41","46","47","48","48","48","42","40","41","48","40","48","41"]},"Each of key object , metadata objects , and data object  are cached in object store  as separate allocations. In order for planning applications  to retrieve data object , allocation table manager objects  traverse through the allocations in object store  to find key object . If the allocation is active and includes key object , allocation table manager objects  use link table  to determine data ordinal . Allocation table manager object  then use data ordinal  to locate the corresponding allocation listing in allocation table . The allocation listing may include an offset of the desired data object . Allocation table manager objects  then use the offset to recover data object  from object store .",{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 6","FIG. 3"],"b":["28","27","36","37","50","36","38","32","27","52"]},"Next, any of allocation table manager objects  may receive a cache operations from the respective one of planning applications , e.g., planning application A, for execution on allocation table  (). Examples of cache operations include select, insert, update, remove, and shrink. Prior to executing the cache operation, allocation table manager object A, in this example, opens allocation table  and reads a header of allocation table . As described above, allocation table  may include a guid within the header that changes each time a modification occurs in allocation table . Allocation table manager object A then compares the guid of table instance A with the guid of allocation table  ().","If the table instance guid is equal to the allocation table guid (yes branch of ), allocation table manager A may access cache A (). In other words, when table instance A is current with allocation table , allocation table manager A may execute cache operations based on table instance A to modify data stored in object store  within cache A. The cache operations may comprise atomic operations, which open, modify, and close allocation table  for each cache operation performed on table instance A.","If the table instance guid does not equal the allocation table guid (no branch of ), allocation table manager object A reads the header of each allocation within allocation table . Each allocation in allocation table  may also include a guid within the header that changes each time a modification occurs to the allocation. Allocation table manager object A then compares the guid of a table instance allocation with the guid of a corresponding allocation table allocation (). This enables allocation table manager object A to only reload the modified allocations to table instance A. In some cases, allocation table manager object A may be unable to perform a warm load of allocation table  to table instance A. Instead, allocation table manager object A may clear table instance A and perform a cold load of allocation table .","If the table instance allocation guid is equal to the allocation table allocation guid (yes branch of ), allocation table manager object A reads the header of the next allocation in allocation table  (yes branch of , ). When all the allocations within allocation table  have been compared to the allocation within table instance A (no branch of ), allocation table manager object A accesses cache A ().","If the header for any table instance allocation is not equal to the allocation table allocation header (no branch of ), allocation table manager object A updates the allocation in table instance A (). When an active allocation is updated in table instance A (yes branch of ) allocation table manager object A loads the object corresponding to the allocation (). The object may comprise a key object, a data object, or a metadata object. Once the object is loaded into table instance A or if the updated allocation is not active (no branch of ), allocation table manager object A reads the header of the next allocation in allocation table  (yes branch of , ). Once all the allocations have been compared (no branch of ), allocation table manager object A access cache A and performs the requested operation based on the updated table instance A ().","In this way, allocation table manager objects  ensure that table instances  contain current allocations without necessarily having to completely reload allocation table  to table instances . Moreover, planning applications  may execute atomic cache operations via allocation table manager objects A based on up-to-date table instances , which modify object store  and allocation table  within cache A.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":["FIG. 7","FIG. 8","FIG. 7","FIG. 3"],"b":["80","80","80","32","80","82","83","82","83"]},"Allocations ,  include a set of properties associated with the allocation. As shown in , the set of properties may include an offset of the allocation from first allocation , a size of the allocation, an amount of free space in the allocation, and an indication of whether the allocation is active or inactive. In this example, the active indication comprises a boolean flag. First allocation  is an inactive allocation of size . Second allocation  is an active allocation of size  and has an offset from first allocation  of .","Referring to , assume a planning application initially adds an allocation of a certain size to allocation table  (). If there are no inactive allocations within allocation table  large enough to accommodate the new allocation (no branch of ), allocation table  creates a new active allocation (). For example, as illustrated in , when a planning application inserts a size  allocation in allocation table , allocation table  creates a third allocation  since the inactive first allocation  is not large enough to accommodate the size of the new allocation. Third allocation  is an active allocation of size  with an offset from first allocation  of .","If allocation table  does comprise an inactive allocation large enough to accommodate the new allocation, (yes branch of ), allocation table  sets the existing allocation to active (). However, the existing allocation may be a larger size than required by the new allocation. In that case, the allocation contains free space. When the free space in an allocation is less than a re-allocation threshold (no branch of ), allocation table  leaves the free space in the allocation ().","For example, as illustrated in , a planning application may insert an allocation of size . In this example, first allocation  is large enough to handle the new allocation. First allocation  then becomes an active first allocation A of size  with 25 units of free space. Allocation table  may comprises a re-allocation threshold of , for example. Therefore, allocation table  keeps the free space in first allocation A.","When the free space in an allocation is greater than the re-allocation threshold (yes branch of ), allocation table  creates a new inactive allocation for the free space (). As an example, a planning application may insert an allocation of size , as illustrated in . Again, first allocation  is large enough to handle the new allocation. In this case, first allocation  becomes an active first allocation B of size  with 75 units of free space. Since allocation table  comprises a re-allocation threshold of , allocation table  creates a fourth allocation  for the free space from first allocation B. Fourth allocation  is an inactive allocation of size  with an offset from first allocation B of . The free space within active first allocation B is then set to zero ().","As illustrated in , the allocations within allocation table  are not necessarily in order based on the offset value. Instead, each allocation comprises an ordinal, as discussed above, which only changes when a collapse is executed on the cache as a clean-up mechanism.","The allocation process described above provides an efficient use of space in the cache. The re-allocation threshold is used to control whether a new allocation for the free space is created within an existing allocation. Since caches are generally geared toward large blocks of data, smaller allocations, i.e., allocation below the re-allocation threshold, are kept in the original allocation. The allocation efficiency of the caching management techniques described herein may reduce how frequently the cache needs to be collapsed. A collapse of the cache may tend to disrupt the ordinals associated with each allocation. Therefore, any table instances created by the planning applications may require a cold load from the allocation table after a collapse occurs.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 9","FIG. 10","FIG. 9","FIG. 3","FIG. 7"],"b":["100","102","104","32","80"]},"In particular, only one of allocation tables , , and  is active during a given period. The header associated with each of the allocation tables , , and  may comprise a byte that switches to selectively set the respective allocation table as the active allocation table.","In this embodiment, allocation table manager objects  employ cache management techniques that automatically select a new allocation table each time an atomic operation is executed on the current table. A single atomic operation may append no more than two allocations to an allocation table. In the case of period , a previous atomic operation has resulted in allocation  and allocation  being appended to first allocation table .","During period , for example, first allocation table  is active, and a planning application may execute an atomic cache operation on the active allocation table ( of ). As a result, allocation table manager objects  copy the currently active table (i.e., allocation table ) to the next allocation table (i.e., allocation table ) (). In this case, the two current allocations within first allocation table  are copied to second allocation table .","Allocation table manger objects  then save any changes occurring from the atomic cache operation executed on currently active allocation table  to second allocation table  (). In the case of period , the atomic operation has resulted in allocation  and allocation  being appended to second allocation table . In this way, the cache management techniques ensure that the currently active allocation table remains intact. Next, allocation table  is set as the active allocation table ().","In the example of , during period , second allocation table  is the active table. The robust storage process continues in a cyclical fashion. For example, during period  the cache is accessed, causing currently active allocation table  to be copied to the next allocation table (i.e., third allocation table ). The cache operation appends allocation  and allocation  to third allocation table . After the execution of the cache operation is completed successfully, third allocation table  becomes the active allocation table for use during period  and contains all the allocations from second allocation table . To continue the example, third allocation table  is copied to first allocation table . After the atomic operation, allocation  and allocation  may be appended to first allocation table  during period . Allocation table manager objects  then set first allocation table  as the active allocation table during period .","As shown in , allocation tables ,  and  may be maintained as one contiguous data block in memory, copying third allocation table  to first allocation table  overwrites first allocation table . In addition, appending allocation  and allocation  to first allocation table  during period  overwrites second allocation table  as well. However, since only two allocations may be appended for each atomic operation, third allocation table  cannot be overwritten. In this way, each time the active allocation table is switched, the previous allocation table remains intact. In the case where a power failure or other disruption corrupts the active allocation table, a copy of the previous allocation table is readily available for use in a recovery process.","Various embodiments of the invention have been described. Although described in reference to an enterprise planning system, such as an enterprise financial or budget planning system, the caching techniques may be readily applied to other software systems, including other large-scale enterprise software systems. Examples of other enterprise software systems include order management systems, inventory management systems, sales force management systems, business intelligent tools, enterprise reporting tools, project and resource management systems and other enterprise software systems. Moreover, the techniques may be implemented on any type of computing device, including servers, user computers, laptops or other devices. These and other embodiments are within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 6","FIG. 3"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 8","FIG. 7"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 10","FIG. 9"]}]},"DETDESC":[{},{}]}
