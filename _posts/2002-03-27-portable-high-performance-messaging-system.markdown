---
title: Portable, high performance messaging system
abstract: A method and implementation is disclosed for messaging between components, preferably the controllers of peripheral devices in a network. The method and implementation includes providing a message from a first process and appending to the message a code indicating at least one descriptive parameter of the message. Steps and implementations are included for transmitting the message to a second process and interpreting the code so as to enable computation of the message by the second process across a plurality of different controller platforms.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06977994&OS=06977994&RS=06977994
owner: Toshiba Corporation
number: 06977994
owner_city: 
owner_country: JP
publication_date: 20020327
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present invention is directed to the field of messaging systems of the type used exchange messages between various types of peripheral office components, including copiers, printers, fax machines and the like. The invention has particular applicability as used in a network where messages are exchanged between components of various makes and models, which may be implemented with different types of operating systems.","In a network messaging has many uses, including the management of peripheral output. For example, if a network printer has a long queue of pending print jobs, messages can be exchanged between peripheral components to identify a suitable printer for off-loading a priority print job. In a typical enterprise roll-out, it is common for a variety of components to be used, having a number of different makes and models, and even employing different operating systems. In these instances, it can be difficult or impossible for these components to exchange messages with each other, resulting in delays, confusion and general inefficiency.","In general, the inter-process communication (IPC) mechanisms deployed by the embedded software controllers of such peripheral devices tend to not be portable across operating system platforms. Performance is also affected by the restrictions imposed by the native IPC mechanisms on the platforms of interest. For example, sockets are too basic to basic to satisfy cross-platform messaging requirements. On the other hand, RPC (remote procedure call) is too complex and slow to be effective. Also, shared memory must reside on the same hardware. Some IPC mechanisms, such as those deployed by Toshiba Controller software SC-2\/3 (used by the present assignee) require the extensive use of the Windows NT registry for event notification and job control, and thus cannot be ported to other types of operating systems.","The difficulties and drawbacks encountered in previous-type systems are satisfied by the method and implementation of the present invention for messaging between components, preferably the controllers of peripheral devices in a network. The method and implementation includes providing a message from a first process and appending to the message a code indicating at least one descriptive parameter of the message. Steps and implementations are included for transmitting the message to a second process and interpreting the code so as to enable computation of the message by the second process across a plurality of different controller platforms.","As will be realized, the invention is capable of other and different embodiments and its several details are capable of modifications in various respects, all without departing from the invention. Accordingly, the drawing and description are to be regarded as illustrative and not restrictive.","The present invention includes an easily portable, high performance, centralized, messaging system that can be implemented as a daemon, service, stand-alone GUI-less application, or any other suitable implementation. The messaging system preferably employs TCP sockets for all IPC communication, making the present system very portable across NT, VxWorks, Linux and other Unix platforms, and can also be adapted to any other operating system or other platforms without departing from the invention. In another aspect of the invention, the invention includes a simple, flexible, object oriented, and operating system-independent messaging interface class compiled and linked into all controller processes to enable the communication between processes via the messaging system.","The present invention as described therefore includes a method and software implementation for messaging between components, preferably the software controllers of peripheral devices in a network, such as printers, copiers and fax machines. The present invention includes providing a message from a first process and appending to the message a code indicating at least one descriptive parameter of the message. Steps and implementations are included for transmitting the message to a second process and interpreting the code so as to enable computation of the message by the second process across a plurality of different controller platforms.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 1","FIG. 1"],"b":["10","12","14","12","14","16","20","22","16","12","14","16","10"]},"The two connections ,  are respectively identified as \u201cNormal\u201d and \u201cUrgent\u201d in . The \u201cNormal\u201d channel  is used for typical inter-process communication such as that required for job control and flow, requesting and receiving status. The \u201cNormal\u201d channel connection to the messaging system is opened once at process startup and remains active until process shutdown. The \u201cUrgent\u201d channel  is used for high-priority messages such as system shutdown messages. Processes should service urgent messages before any normal messages in its queue. Like the Normal Channel, the Urgent Channel connection to the Messaging System is opened once at process startup and remains active until process shutdown. Providing separate channels in this manner insures message delivery and provides congestion control. It also enables a system upgrade whereby a networked collection of messaging systems can be operated with independent controllers.","The system  also includes a high speed \u201cbulk\u201d data channel  for moving large amounts have data (typically greater than 1K) directly between the two processes ,  or when the highest possible communication rate is required. In the high speed \u201cbulk\u201d data channel , the messaging system  supports a dedicated data channel between communicating processes for bulk data transfers to avoid loading the messaging system . Since it is not feasible to open a dedicated channel between all possible process pairs in the system, the messaging system allows each process to create a listening socket. When the data source (i.e. the process that will be transmitting the bulk data) connects to that listening socket, a high speed \u201cbulk\u201d connection is spawned. When the data transmission is finished, the messaging system  closes the socket from both ends. Unlike the \u201cNormal\u201d and \u201cUrgent\u201d channels, the high speed data channel connection  is opened before and closed after each transfer session.","Each controller process ,  contains a respective instance of a message interface class , , which will be responsible for transmitting and receiving messages. In the preferred embodiment, the message interface class is identified as \u201cM. API\u201d as shown in , where M. API is understood to be the \u201cMessaging Application Programming Interface,\u201d a messaging interface class that is compiled and linked into each of the messaging system's client processes.","Prior to transmitting a message between the first process  and the second process , a code is appended to the message indicating at least one descriptive parameter of the message. The descriptive parameters of the appended code can include: an integer message sender; an integer message type; an integer message class; and an integer message priority. The message also contains an integer message length, and a message body. The message sender, type, class and priority are preferably the low-order 32 bits of an encryption string, preferably an MD5 string or the like. This allows the receiving controller process to interpret the code so as to enable computation of the message across a plurality of different controller platforms, thereby permitting independent computation of the message type codes by the transmitter and receiver, without a coordinating central registry of message types.","In the preferred embodiment, the messaging system  places no restrictions on the type of data or text a message body may contain. The messaging system  is isolated from any knowledge of the message body, other than it's size. If the two processes ,  agree to send messages containing XML text, for example, the messaging system  would not be involved in the parsing or constructing the XML text. This would be the responsibility of the sending and receiving processes.","Prior to sending and receiving, the controller processes ,  register with the messaging system  to receive messages. A specific client controller process may register multiple times to receive different subsets of messages. Each registration supplies a message tuple of descriptive parameter codes (sender, type, class, priority). Any of these descriptive parameters may be zero, which implies no filtering on that field. For example, a client controller could optionally register a message tuple (X,0,Z,P) to receive messages from sender X of class Z, and also register (0,Y,0,P) to receive messages of type Y from all senders. In these tuples, the sender field may be \u22121 to receive messages from all senders other than itself.","When a controller process registers to receive messages specified by a particular filter tuple, it can also specify a set of global parameters. The global parameters specified with the most recent registration message are used for defining the client connection. These global parameters include the delivery mode (\u201cguaranteed\u201d or \u201cbest effort,\u201d as explained below), a dead client age D in milliseconds, a stale message age A in milliseconds, a queue limit multiplier QM, and a queue limit divisor QD.","The default is \u201cguaranteed delivery\u201d mode, in which case QM=QD=1 and A is ignored. This mode preferably employs congestion control as described below, and if client using this mode is receiving messages from multiple transmitters it may not receive every message.","In \u201cbest effort\u201d mode, the transmit queue limit uses the QM and QD parameters, and old messages (older than A) are flushed before trying to add new messages to the transmit queue for this client. However, the client is not precluded from receiving messages older than A since messages may spend a long time in the TCP\/IP buffers. This age is only inspected when adding new buffers to the transmit queue, so the queue may contain some very old messages if no new messages arrive to be added to the queue. In this mode, the client can tune the maximum size of the transmit queue. \u201cBest effort\u201d mode is similar to guaranteed delivery mode but where the parameters defined as A=INTMAX, QM=1, QD=1.","In order to provide congestion control, multiple controller processes may send messages of some type to a single controller process that has registered to receive messages of this type. If the receiving process cannot keep up, the buffer space in the Messaging System will fill up and the controller will deadlock. To prevent this, two defensive measures have been design to avoid this. First, each transmitting process is allowed a maximum of N outstanding messages in the buffers. These are messages that have been received from this transmitting process by the messaging system , but have not yet been sent to all the registered processes. Once this limit is reached, the messaging system  will not read from the socket for that transmitting process. This will cause the TCP\/IP buffers for that socket to fill, and eventually the process will be unable to write to the socket. This pushes the congestion back to the transmitting process, which will then block or possibly simply avoid transmitting messages. Depending on the sophistication of the process code, there may be other useful work the process can perform, even though it cannot transmit messages.","Second, each receiving process is allowed at most M outstanding messages in the buffers. These are messages that have been received by the messaging system  from any source, but have not yet been transmitted to this process. Once this limit is reached, the messaging system  will treat new messages for this process as if they have already been delivered. In this case, the receiver will not receive all of the messages. This prevents a single slow receiving process from exhausting the buffer space in the server. The upper level protocols or interpretation of the message bodies must be able to handle dropped messages.","If only a single transmitter\/receiver process pair is considered, simply setting N<=M would guarantee that congestion is pushed back on the transmitting process before starting to drop messages for the receiving process. In this case, no messages would be dropped. However, in the general case, a collection of T processes may all be sending messages of some type that are destined for a single process. If a setting of T*N<=M is applied, the congestion is pushed back on the transmitters before any messages are dropped.","B=total number of buffers","C=total number of active messaging client connections","T=3","N=B\/C","M=T*N*QM\/QD","Any process listening for messages sent by more than T processes may not receive all the messages. Messages may be dropped in this case before any of the transmitting processes sees any congestion control. Note that in best effort mode, each process may specify the QM and QD parameters, so by setting QD=PARMT, the process may specify QM as the number of transmitting processes to which this process may listen without worrying about dropped messages.","The above analysis assumes that the total number of processes connected to the messaging system  is relatively stable. If the messaging system  has only a few processes connected, and the processes almost fill the buffer space, and the messaging system  then gets a large number of new process connections, the system can still deadlock. To avoid this, the messaging system  makes use of the following configuration parameters:","E=estimate of total client connections after startup","C\u2032=total number of active messaging client connections","C=max(E,C\u2032)\/\/effective number of client connections","Certain failure modes are defined. In a \u201cchattering process,\u201d there is a process that is transmitting messages at a very high rate. Such a process won't be able to overwhelm either the messaging system  or any destination processes, since the messaging system  would simply be configured to stop reading from the socket before the buffer space is exhausted. This will eventually result in TCP\/IP buffer exhaustion and force the process to block when writing to the socket. In a \u201cdead process,\u201d there is a process that has registered to receive messages of some type, and the process then never reads from the socket to actually receive any of these messages. Whenever there is a new buffer to be added to the transmit queue, the messaging system  checks if the process is still alive. It is alive if the messaging system  has read bytes from or written bytes to the socket within the last D milliseconds, where D is specified in the process global parameters. Each process is responsible for setting this timer appropriately. In a \u201cslow process,\u201d there is not much difference between a truly \u201cdead\u201d process and one that is very slow. If a process only services a few messages per second it will probably appear to the rest of the system that the process has crashed.","As described hereinabove, the present invention solves many problems associated with previous type systems. However, it will be appreciated that various changes in the details, materials and arrangements of parts which have been herein described and illustrated in order to explain the nature of the invention may be made by those skilled in the area within the principle and scope of the invention will be expressed in the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"}},"DETDESC":[{},{}]}
