---
title: Method for efficient garbage collection based on object type
abstract: A computing apparatus and method classify data objects into at least a first type and alternatively a second type, and allocate a first portion of computer memory to objects of the first type and a second portion of computer memory to objects of the second type. Then the method performs garbage collection of data objects within at least one portion of computer memory while retaining surviving objects within the computer memory. Objects of the first type occur in a computer memory with a frequency that exceeds a selected threshold, and are designated “prolific.” Objects of the second type occur in the computer memory with a frequency that does not exceed the selected threshold, and are designated “non-prolific”.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06892212&OS=06892212&RS=06892212
owner: International Business Machines Corporation
number: 06892212
owner_city: Armonk
owner_country: US
publication_date: 20020307
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["This application is based upon and claims priority from prior U.S. Provisional Patent Application No. 60\/278,060, filed on Mar. 22, 2001, and further is based upon and claims priority from prior U.S. Provisional Patent Application No. 60\/281,759, filed on Apr. 5, 2001, collectively the entire disclosure of which is herein incorporated by reference.","The present patent application is related to co-pending and commonly owned U.S. patent application Ser. No. 10\/094,091, entitled \u201cMethod for Reducing Write Barrier Overhead\u201d, filed on even date with the present patent application, the entire teachings of which being hereby incorporated by reference.","1. Field of the Invention","This invention generally relates to the field of automatic memory management, and more particularly relates to a system and method for efficient garbage collection based on object types.","2. Description of Related Art","The popularity of object-oriented programming languages, such as the Java Programming Language, has rekindled a great deal of interest in automatic memory management. Java does not provide the programmer with an explicit mechanism to deallocate objects, and requires the underlying Java Virtual Machines (JVM) to support garbage collection. Researchers have developed a large number of garbage collection algorithms over the last four decades.","One of the popular approaches to garbage collection is known as generational garbage collection. It is inspired by an observation, known as the weak generational hypothesis, that most objects die young. A simple generational scheme involves partitioning the heap space into two regions\u2014a nursery (or new generation) and an old generation. All new objects are allocated in the nursery. Most collections, termed minor collections, only reclaim garbage from the nursery. Survivors from a minor collection are promoted to the older generation, which is subjected to collection only during infrequent, major collections. In order to support a generational collection, the compiler has to insert a write barrier for each statement that writes into a pointer field of an object, to keep track of all pointers from objects in the old generation to objects in the nursery. These source objects in the old generation are added, as roots for minor collection, so that objects in the nursery that are reachable from those objects are not mistakenly collected. Compared with their non-generational counterparts, generational collectors typically have short pauses, due to the need to look at a smaller heap partition at a time, but lead to lower throughput of applications due to the overhead of executing write barriers.","Problems of the generational garbage collection scheme include:\n\n","Therefore a need exists to overcome the problems with the prior art as discussed above, and particularly for a method of efficient garbage collection based on object types.","A computing apparatus and method classify data objects into at least a first type and alternatively a second type, and allocate a first portion of computer memory to objects of the first type and a second portion of computer memory to objects of the second type. Then the method performs garbage collection of data objects within at least one portion of computer memory while retaining surviving objects within the computer memory. Objects of the first type occur in a computer memory with a frequency that exceeds a selected threshold, and are designated \u201cprolific\u201d. Objects of the second type occur in the computer memory with a frequency that does not exceed the selected threshold, and are designated \u201cnon-prolific\u201d.","The present invention, according to a preferred embodiment, overcomes problems with the prior art by implementing a new approach to garbage collection based on the notion of prolific and non-prolific object types. Relatively few object types, referred to as prolific types, usually account for a large percentage of objects (and heap space) cumulatively allocated by the program. The objects of prolific types have short lifetimes, and therefore, account for a large percentage of garbage that is collectible at various points during program execution. The present invention, according to a preferred embodiment, presents a new approach to garbage collection that relies on finding garbage primarily among prolific objects. The present invention improves upon generational garbage collection by distinguishing between groups of objects based on type rather than age.","In a preferred embodiment of a type-based garbage collector, all objects of a prolific type are assigned at allocation time to a prolific space (P-space). All minor collections are performed on the P-space. All objects of a non-prolific type are allocated to a non-prolific space (NP-space). Unlike generational collection, objects are not \u201cpromoted\u201d from the P-space to the NP-space after a minor collection. This approach leads to several benefits over generational collection:\n\n","The term \u201cprolific type\u201d is used to refer to a type that has a sufficiently large number of instances. More specifically, a type may be prolific with respect to a program if, for example, the fraction of objects of this type exceeds a certain threshold. Preferably, the threshold is simply set to 1% of the total number of objects created by an application. This threshold can be adjusted to control the size of the P-space . All remaining types are referred to as non-prolific. Alternatively, prolific types may also be defined as some \u201ck\u201d popular types with respect to the total number of instances.","The objects of prolific types are expected to have small lifetimes. The present invention is based on the expectation that the objects of prolific types die younger than objects of non-prolific types. It follows that most of the garbage collectible at various stages of the application would consist of objects of prolific types. Accordingly, a preferred embodiment of the present invention is a different way of collecting garbage, which looks for garbage first among objects of prolific types.",{"@attributes":{"id":"p-0021","num":"0031"},"figref":"FIGS. 1 and 2","b":["100","101","120","101","122","101","122","110","110","120","116","114","112","118","204","202","206","208","116","124","120","110","116","106","108","116","101"]},"Glue software  may include drivers, stacks, and low level application programming interfaces (API's) and provides basic functional components for use by the operating system platform  and by compatible applications that run on the operating system platform  for managing communications with resources and processes in the computing system .","Each computer system  may include, inter alia, one or more computers and at least a computer readable medium . The computers preferably include means for reading and\/or writing to the computer readable medium . The computer readable medium  allows a computer system  to read data, instructions, messages or message packets, and other computer readable information from the computer readable medium. The computer readable medium, for example, may include non-volatile memory, such as Floppy, ROM, Flash memory, disk drive memory, CD-ROM, and other permanent storage. It is useful, for example, for transporting information, such as data and computer instructions, between computer systems.",{"@attributes":{"id":"p-0024","num":"0034"},"figref":"FIG. 3","b":["124","100","1","124","302","304","306","308","310","306"]},"A preferred embodiment of the type-based approach in a Java Virtual Machine (JVM)  is now described. The JVM  supports a number of different garbage collectors , which can be used in different configurations.","The JVM  is enhanced to introduce two modes of execution. In one (profiling) mode, as shown in , the type profile  is collected; in the other (production) mode, as shown in , the type profile  collected in the profiling run  is used by the memory allocator  and by the garbage collector  to implement type-based heap management, and by the compiler  to optimize away redundant write barrier code.","In the profiling mode , the type profiler  monitors all allocation requests, collects its type profile, and produces a file (type profile ) with the profile information, including class hierarchy information. In the production mode , the memory allocator , in step , uses the previously collected type profile  to make allocation decisions. Also, in the production mode, the garbage collector , at step , repeatedly collects space occupied by unreachable objects of prolific types. When a triggering event occurs, such as only freeing a small portion of memory, at step , it collects the entire heap in step .","The simplest method of identifying prolific types is to use offline profiling. In an offline run, a runtime system (type profiler ) monitors memory allocation requests issued by an application , at step , and counts the number of objects of each type that are allocated on behalf of an application , at step . The type profile  is saved to a file, at step , for later use. When an application (or a JVM ) exits, the collected type profile  is saved into a file. During an actual run, the runtime system uses a previously collected type profile  to perform various optimizations. Thus, no monitoring overhead is incurred during the production run of the application .","A disadvantage of this approach, as with any offline profiling method, is that it requires a separate profiling run and the type profiles  may vary depending on input data supplied to an application . In addition, an application  may consist of several execution phases with drastically different type profiles . A type profile  of such an application  is going to reflect its \u201caverage\u201d behavior during the entire run. Although imperfect, this \u201cone size fits all\u201d approach still works quite well for many applications .","An adaptive approach, in contrast to the offline profiling approach, attempts to identify prolific types during the actual production run of the application . An obvious adaptive strategy would be to monitor each memory allocation in the application . However, this has the disadvantage of relatively high runtime overhead. It should be possible to reduce the overhead of monitoring object allocations by using sampling techniques.","An alternative approach is to monitor the garbage collections rather than memory allocations to identify prolific types. Most unreachable objects are expected to be of prolific types. Although examining unreachable objects could lead to a fairly accurate characterization of types as prolific or non-prolific, it would be an expensive operation. Again, sampling techniques using weak references, or other techniques, could help reduce the overhead, since only a small subset of the unreachable objects would then be examined.","The type-based memory allocator  partitions heap space  into a prolific space  and a non-prolific space : P-space and NP-space, respectively. Note that the actual allocation mechanism is related to the kind of collector used by the system. When used with a copying (type-based) collector , the memory allocator uses  different regions of the memory  for the P-space and NP-space. With a non-copying collector, the objects of prolific and non-prolific types are tagged differently, but not necessarily allocated in separate memory regions.","When we discuss prolific and non-prolific spaces, we do not necessarily mean two different regions of memory , e.g., of the heap. With a non-copying collector, for example, prolific and non-prolific objects may reside next to each other in memory. As will be obvious to those of ordinary skill in the art in view of the present discussion, a garbage collection system, according to a preferred embodiment of the present invention, could distinguish between prolific and non-prolific objects, such as by using a single bit in an object header or by looking at an object type and checking that type against a type profile.","Given an allocation request for an object of a certain type, the memory allocator  checks the type profile  of the application (with information about whether or not the type is prolific) to decide whether to place the object in the P-space  or NP-space . Hence, compared to a traditional memory allocator, the allocation path of the type-based memory allocator  would have an extra step for checking the type of the object. However, since the prolificacy of types is known at compile-time, the compiler  can avoid the overhead of the type check by simply calling (and possibly inlining) a specialized version of the allocator for prolific or non-prolific types. An alternative embodiment performs this optimization.","It should be noted that the compiler  is typical of many compilers used in object-oriented programming languages in that it may have several modes of operation, including:\n\n","The type-based garbage collector  assumes that most objects of prolific types die young, and performs minor collections only on the P-space . Because objects of prolific types account for most of heap space , a preferred embodiment the invention expects to collect enough garbage on each P-space  collection. A full collection of both P-space  and NP-space  may be induced by a variety of triggering events described in prior art. One such triggering event occurs when a P-space  collection does not yield a sufficient amount of free space. Because enough unreachable objects should be uncovered during a P-collection, the full collections are expected to be infrequent. Objects remain in their respective spaces after both P-space  and full collections\u2014i.e., unlike generational collection, objects that survive a P-space  (minor) collection stay there and are not \u201cpromoted\u201d to the NP-space . This enables the compiler  to eliminate unnecessary write barriers with a relatively simple type check, as described herein below. Given the low survival rates of objects in the P-space , the \u201cpollution\u201d of P-space due to longer-lived objects is not expected to be a significant problem.","In order to ensure that during a P-space  (minor) collection, any object reachable from an object in the NP-space  is not collected, garbage collection in accordance with a preferred embodiment of the invention has to keep track of all such pointers from an object in the NP-space  to an object in the P-space . This is accomplished by executing a write barrier code for pointer assignments during program execution, which records such references and places them in a write buffer . The contents of the write buffer  represent roots used in a P-space  collection.","The type-based scheme requires a write barrier to be executed only upon creation of a reference from the NP-region to the P-region. Write barriers may be executed in other cases but those executions of write barriers will unnecessarily reduce throughput of an application (i.e., useless overhead which can be optimized away). In other words, a write barrier has to be compiled into a code at a point in a program when said program creates a reference from a source object that is non-prolific to a target objects that is prolific. In the presence of a class hierarchy (e.g., programs written in the Java programming language), a write barrier has to be compiled into a code when a source object may be non-prolific and a target object may be prolific.","A compiler can determine on-the-fly whether a write barrier is necessary for a program point when a reference is created and compile a write barrier into a code. If a compiler determines that a write barrier is not necessary for a program point when a reference is created, a write barrier code is not included. Alternatively, a compiler can first identify each place in a program when a write barrier may be necessary and then eliminate an unnecessary write barrier on-the-fly or in a post-processing step.","In the type-based collection, objects are not moved from P-space  to NP-space  or vice versa. Hence, write barriers (which are supposed to keep track of references from NP-space to P-space) can be eliminated at compile time based on a simple type check shown in FIG. . More specifically, given an assignment statement where the pointer of an object of type source is assigned a value corresponding to a pointer of an object of type target, the condition for eliminating a write barrier is expressed as code segment  in FIG. .","In an object-oriented language with polymorphism, such as Java, a code segment  requires analyses like class hierarchy analysis or rapid type analysis, similar to those needed for inlining or devirtualization of methods. This conservativeness is made explicit by redefining code segment  to be code segment . Given a declared type T of an object o, the compiler  checks for MustBeProlifilc(o) by checking that all children of T in the class hierarchy are prolific, and can similarly check for MustBeNonProlific(o).","Dynamic class loading is another feature of languages like Java that forces compile-time analysis to be done more conservatively. Again, the problem is similar to the problem with inlining of virtual methods in the presence of dynamic class loading. Due to dynamic class loading, a program can load a new class that is non-prolific but subclasses a prolific class, unless the prolific class is declared final. Note that with a type prolificacy based methodology, a newly loaded class (which the compiler does not know about) would not be classified as prolific, since no instance of that class would have been seen. Therefore, while the check MustBeNonProlific(target) in code segment  could be done by looking at the existing type hierarchy, the check MustBeProlific(source) would be conservatively set to IsFinalProlific(source), so that the code continues to work correctly after new classes are loaded. In this case, the condition under which a write barrier may be eliminated becomes code segment .","It is possible to use the techniques for inlining virtual methods in the presence of dynamic class loading, like preexistence analysis and extant analysis, to improve the effectiveness of code segment . For example, using extant analysis, if a specialized method in which the source reference is known to be extant (i.e., pointing to an existing object) is created, the test MustBeProlific(source) can be performed based on the existing class hierarchy, without worrying about any new classes that might be loaded. A much simpler technique, described below, is used in the preferred embodiment.","The prolific types are likely to be leaves, or close to leaves, in a type hierarchy. The intermediate classes are typically used for defining a functionality that is common to all of their children classes. The subclasses then refine the behavior of their parent classes and are usually instantiated more frequently than their respective parent classes. While it is possible that a prolific class may have one or more subclasses that are not prolific, all children of prolific types are treated as prolific. This greatly simplifies the test to check if a type is definitely prolific. The test returns true if the declared type of the variable is prolific, and returns false otherwise (without looking any further at the class hierarchy). In particular, code segment  for eliminating redundant write barriers can be done without worrying about any new classes that may be dynamically loaded in the future (because any dynamically loaded class that subclasses a prolific type are regarded as prolific).","There are various extensions to the basic scheme, which can improve the performance of the system. One of the fields in an object header usually points to a special object describing its type (or class) information. For example, in the Java Virtual Machine  of the present invention, this field points to a type information block (TIB) and is called a TIB field. Scanning TIB pointers for every reachable object does not seem to be necessary and can be avoided in the type-based scheme. It is sufficient for only one object of a type to survive a collection to ensure that the TIB of that object is scanned and marked as live. The scanning of TIB fields of all other instances of that type are unnecessary, although the garbage collector will realize after reaching the TIB object that it has already been marked. Since the number of distinct types is small, the number of objects representing them is also small. It follows that such objects can be classified as instances of a non-prolific type and placed in the NP space . As a result, the TIB fields (which now point to the NP-space ) do not have to be scanned during a P-space  collection.","The idea of not scanning TIB objects during a P-space  collection can be taken further by observing that only objects of prolific types need to be scanned in the P-space  collection. In the type-based scheme of the invention, the number of pointers processed can be reduced even further during a P-space  collection.","During the P-space  scanning process, for each object, the garbage collector  requests the list of fields that are references. This list is created when a class is loaded. Normally, the returned list contains all such reference fields. Consequently, all such references are first processed and then some of them (e.g., those pointing to young objects) are scanned. However, in the type-based collector , there is no need to return a complete list of reference fields to the collector  during a P-space  collection. Only the references pointing to objects of prolific types have to be returned (because objects residing in the NP-space  are only scanned during a full collection). To support this extension, the collector is provided with two different sets of methods returning the lists of reference fields: one (returning a partial list) for a P-space  collection and one (returning a full list) for a full collection.","By defining several degrees of prolificacy of types, several P-spaces  can be created. Objects corresponding to different levels of prolificacy will have different lifetimes. Each such space may be collected with a different frequency. This is different from generational garbage collectors employing multiple generations and promoting objects with different ages to different generations.","It would be useful to have a separate sub-space within the NP-space  for objects of non-prolific types that cannot point to objects in the P-space  directly. By partitioning the NP-space  in this manner, the need to maintain card marking data structures for this sub-space can be eliminated because a write barrier cannot be executed on any object in this sub-space.","Combining type-based memory management with lifetime analysis of objects may lead to further performance improvements. Although, most short-lived objects are instances of prolific types, there may be some non-prolific types whose instances are always short lived. It may be advantageous to collocate such objects of non-prolific types with objects of prolific types in the P-space  (and to treat them as if they were instances of prolific types) thereby reducing the pollution of NP-space , albeit only slightly. However, if such short-lived objects can point directly to a P-space , then this collocation can also reduce the pollution of P-space  after a P-space  collection.","The type-based approach is therefore different from the generational approach in a number of ways:\n\n","The present invention can be realized in hardware, software, or a combination of hardware and software. A system according to a preferred embodiment of the present invention can be realized in a centralized fashion in one computer system, or in a distributed fashion where different elements are spread across several interconnected computer systems. Any kind of computer system\u2014or other apparatus adapted for carrying out the methods described herein\u2014is suited. A typical combination of hardware and software could be a general-purpose computer system with a computer program that, when being loaded and executed, controls the computer system such that it carries out the methods described herein.","The present invention can also be embedded in a computer program product, which comprises all the features enabling the implementation of the methods described herein, and which\u2014when loaded in a computer system\u2014is able to carry out these methods. Computer program means or computer program in the present context mean any expression, in any language, code or notation, of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following a) conversion to another language, code or, notation; and b) reproduction in a different material form.","Although specific embodiments of the invention have been disclosed, those having ordinary skill in the art will understand that changes can be made to the specific embodiments without departing from the spirit and scope of the invention. The scope of the invention is not to be restricted, therefore, to the specific embodiments, and it is intended that the appended claims cover any and all such applications, modifications, and embodiments within the scope of the present invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0017"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0014","num":"0018"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0015","num":"0019"},"figref":["FIGS. 4","FIG. 1"],"b":["5","6"]},{"@attributes":{"id":"p-0016","num":"0020"},"figref":["FIG. 7","FIG.1"]}]},"DETDESC":[{},{}]}
