---
title: Update dependency control for multi-master replication
abstract: The invention proposes a directory server system having a master server and a non-master server, each server being capable of storing directory server data comprising updates. The master server is capable of sending selected updates to the non-master server, and the non-master server () has:


url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07584174&OS=07584174&RS=07584174
owner: Sun Microsystems, Inc.
number: 07584174
owner_city: Santa Clara
owner_country: US
publication_date: 20040430
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"p":["This invention relates to distributed computer systems.","In certain fields of technology, complete computer systems, including a diversity of equipments, are optimized for storing and retrieving data. Such systems may provide services to user machines related to a local network, e.g., an Intranet, or to a global network, e.g. the Web network.","It is desirable that network users can access, upon a query, to a large number of data, making it possible for the network users to create their own dynamic web site or to consult a dynamic web site, for example an e-commerce site on a multi platform computer system (Solaris, Windows NT). These queries are directed to a directory, e.g. using the LDAP protocol, and managed by a directory server. It is further desirable that this access to a large number of data be made possible more rapidly for each query arriving after a first query.","A general aim of the present invention is to provide advances in these directions.","Broadly, there is proposed a directory server system having a master server and a non-master server, each server being capable of storing directory server data comprising updates,\n\n","There is also proposed a method of operating a master server in a directory server system, having a master server and a non-master server, each server being capable of storing directory server data comprising updates,\n\n","This invention may also be defined as an apparatus or system, and\/or as software code for implementing the method, or for use in the system, and\/or as portions of such software code, in all their alternative embodiments to be described hereinafter.","Additionally, the detailed description is supplemented with the following Exhibits:\n\n","The Exhibits are placed apart from the description, for the purpose of clarifying the detailed description, and of enabling easier reference.","As they may be cited in this specification, Sun, Sun Microsystems and Sun One are trademarks of Sun Microsystems, Inc.","A portion of the disclosure of this patent document contains material which may be subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright and\/or author's rights whatsoever.","This invention may be implemented in a computer system, or in a network comprising computer systems.  represents an example of the hardware of such computer systems. The hardware comprises:\n\n","Data may be exchanged between the components of  through a bus system , represented as a single bus for simplification of the drawing. Bus systems may include a processor bus, e.g. PCI, connected via appropriate bridges to, e.g. an ISA or a SCSI bus.","The data exchanged are handled by a resource provider using a server to deliver data to user computers, or to store the data provided by the user computers. Browsers, e.g. Internet Explorer, are further provided on user computers, to enable users to make requests, to retrieve or store data. The resource provider makes it possible for user computers on a network to share data of any kind.","iPlanet E-commerce Solutions, now Sun One E-commerce Solutions, has developed a \u201cnet-enabling\u201d platform called the Internet Service Deployment Plateform (ISDP). ISDP includes multiple, integrated layers of software that provide a full set of services supporting application development, e.g. business-to-business exchanges, communications and entertainment vehicles, and retail Web sites.","Sun One\u2122 Directory Server, provides a centralized directory service for an intranet or an extranet. A directory service represents a collection of software, hardware, and processes that are able to deliver and store information. The directory service generally includes one or more directory client programs that can access the data stored in the directory, e.g. names, phone numbers or addresses.","Sun One Directory Server is a general purpose directory that stores all information in a single, network-accessible repository. Sun One Directory Server provides the standard protocol LDAP and an application programming interface (API) to access the information contained by the Sun One Directory Server.","Technically, LDAP is defined as on-the-wire bit protocol (similar to HTTP) that runs over Transmission Control Protocol\/Internet Protocol (TCP\/IP). It specifies the interaction between clients and servers and determines how LDAP queries and responses are carried over the IP network.","Referring to , LDAP defines a communication  between a server  and a client . LDAP also defines a communication  between LDAP server  and servers . to .n, which makes it possible for the server LDAP  to exchange its content (replication service) with servers . to .n or to access the directory of one of the servers . to .n (referral service) and vice versa.","The LDAP protocol is a message-oriented protocol. The client  constructs an LDAP message containing a request and sends the message to the server . The server  processes the request and sends a result, or results, back to the client  as a series of LDAP messages.","Such a client-server communication additionally lies on a specific architecture. LDAP creates a standard defining the way data are exchanged between the client computer and the directory servers and defining the way data are modeled. More specifically, LDAP relies on four basic models:\n\n","The LDAP information model defines the kind of data that can be stored in a directory. LDAP directory is populated with entries. An entry corresponds to real-world objects, such as a person, a printer, or configuration parameters.",{"@attributes":{"id":"p-0040","num":"0058"},"figref":"FIG. 3","b":["30","31","310","311","312","32"]},"An entry contains a set of attributes associated with values. Each entry is uniquely identified by a distinguished name. The distinguished name may be stored in the dn attribute (distinguishedName).","LDAP entries are organized in a hierarchical tree structure, called the Directory Information Tree (DIT). Each node of the tree comprises an entry.  illustrates an organization entry () with the attribute type of domain component dc, an organizational unit entry () with the attribute type of organizational unit ou, a server application entry () with the attribute type of common name cn, and a person entry () with the attribute type of user ID uid. The entries are connected by the directory. Each server has a particular entry called root directory specific entry (rootDSE) which contains the description of the tree and of its content.","The LDAP naming model specifies that directory entries must be hierarchical and organized in an inverted tree structure. As mentioned above, each entry has a unique name called a distinguished name DN. The DN consists of a list of the names of all the parent entries in the directory back to the top of the directory hierarchy, the name of the entry being at the extreme left, e.g., \u201cuid=Joe,ou=people,dc=france,dc=sun,dc=com\u201d, in . The root of the entry is at the extreme right of the DN. The name at the extreme left of the DN, \u201cuid=Joe\u201d in the example, is the relative distinguished name or RDN. Within a set of entries sharing the same parents, the RDN must be unique. This ensures that two entries in the directory tree cannot have the same DN.","The LDAP functional model comprises eight basic functional operations that a user from a client computer can perform on the directory data of a LDAP directory server. In particular, the following operations (indicated hereinafter between the quote signs \u201c \u201d)can be made to make changes on the entries:\n\n","LDAP also provides a replication mechanism to increase the availability and performance of the directory.","Replication allows the same information to exist on more than one server. Each server in a directory server system interacts with a database in which directory server data are maintained. A database which participates in replication form a replica.","A replica can be either a read-write replica or a read-only replica. A read-write replica contains master copies of directory information and can be updated. A read-only replica refers all update operations to read-write replicas. A server can hold any number of read-only or read-write replicas.","A master server holds a read-write replica which is copied to a replica on a different server. A non-master server or slave server holds a read-only replica which is copied from a master server.","A replication session may not only occur between a master server and a slave server but also between two master servers, in certain network topologies.","In a replication session among two servers, the server which holds a replica that is copied to a replica on the other server is called a supplier for that replica and the server that holds a replica that is copied from the other server is called a consumer for that replica.","More specifically, replication is a process by which updates performed by a master server are propagated to all the replicas. A master server can replicate an entire naming context, a subtree, or a particular entry. A master server can also replicate the entire content of an entry, or a subset of attributes to be replicated.","Replication significantly reduces the load of processing requests generated by directory service clients because several servers share the same information, and has the following advantages:\n\n","Sun One\u2122 Directory Server system supports multi-master replication topology in which master copies of the same information can exist on several servers or master servers.","A LDAP multi-master topology is a set of LDAP servers fully or partially meshed among them that collaborate to offer a logically global view to external clients. An external client can launch an update request to any master server of the multi-master topology.","The updates that are locally performed on a master server are then replicated to the other master servers. Therefore, in multi-master topology, a master server can be a supplier or a consumer server. A Supplier server is the source of the updates to be transferred. A Consumer server is the recipient of the updates.","A master server also replicates updates to several slave servers which maintain a read-only replica. Slave servers are only consumer servers.",{"@attributes":{"id":"p-0057","num":"0080"},"figref":"FIG. 6","i":"a "},"The multi-master topology of comprises four master servers M, M, M and M which maintain a read-write replica and four slave servers C, C, C and C which maintain a read-only replica.","Each master server M, M, M or M can exchange updates with another master server, and can send replicate updates to slave servers C, C, C or C which are connected thereto.","If one master is unreachable for some period of time\u2014due to hardware failure, software failure or network failure\u2014the other master servers continue to accept updates and can replicate the updates to the read-only replicas.","Replication relationships, e.g, L, L, L, L, L, Land L, may be established between the master servers M, M, M, and M and the slave servers C, C, C and C. Ldesignates a unidirectional replication relationship from master M to slave server Ck.","Each master server is capable of responding to read requests and update requests from a directory client. Upon receiving an update request form a client, it accordingly modifies an entry and then records the updates made in an update log or replication log.","Each master server may interact with the other master servers to replicate the updates made to its replica. Thus, as seen on , master server M may interact with all the other masters M, M and M in order to replicate updates. Master server M would be acting in this case as a supplier server for the other master servers.","A master server may also receive replication updates from the other master servers, thus playing the role of consumer.","Therefore, replication Relationships, e.g. L, L, L, L, L, and L, may be established between the master servers M, M, M, and M. Ldesignates a bidirectional relationship between master server M and master server Mk.","As a result, a given master server has a knowledge of the updates performed on the other master servers.","Replicate updates may comprise \u201cadd\u201d, \u201cdelete\u201d, \u201cmodify\u201d, and \u201cmodifyRDN\u201d operations.","An \u201cadd\u201d operation has a dn parameter which represents the distinguished name DN of the entry to add in the DIT, and a modlist parameter which represents a list of attributes to be added to that entry. The parent entry of the entry dn must exist.","In the foregoing description, an entry that is identified by a distinguished name dn may be designated as \u201centry dn\u201d to enable easier the reference.","A \u201cdelete\u201d or \u201cdel\u201d operation has a dn parameter which represents the distinguished name DN of the entry to delete. To be successful, this operation requires the entry dn to be a leave entry in the DIT.","A \u201cmodify\u201d or \u201cmod\u201d operation has a dn parameter which represents the distinguished name DN of the entry to modify and a modlist parameter which represents a list of modifications to made to the attributes of that entry. Each element in the modlist may be in the form of (mod_op, mod_type, mod_vals), where mod_op is a string indicating the operation (\u201cadd\u201d, \u201cdelete\u201d or \u201creplace\u201d), mod_type indicates the attribute type name and mod_vals represents a value or a list of values to add, delete or replace respectively.","A \u201cmodifyRDN\u201d or \u201cmodRDN\u201d operation has a dn parameter which represents the distinguished name DN of the entry whose DN is to be changed and a newdn parameter which represents the new distinguished name to give to the entry. To be successful, this operation requires the entry dn to be a leave entry in the DIT and the parent entry newDN to exist.","In the prior art, master servers can sustain a very high rate of updates from clients. More specifically each master server:\n\n","However, in the prior art, a consumer server has to replay the updates received from a master server in the same order as they were initially applied by the supplier server, in such a way that:\n\n","Indeed, the consumer server cannot take advantage of the multithreading capabilities of the host system as a consumer receives an update together with time data which were generated by the master server that originally performed that update. Such time data have to be respected by the consumer server upon replaying the updates in order to properly apply the conflict resolution procedures.","Therefore, by sending the updates toward a slave server in the order they were applied by the master server and by replaying these updates according to that order, this ensures that no update dependency conflicts will happen in the non-master server.","An update dependency conflict would occur in a slave server upon replaying an update that depends on another update that has not yet been replayed.","A dependency is defined for a first update with respect to a second update which has been locally applied in the master server before the first update. Therefore, dependencies are linked to the initial ordering of the updates in the master server.","Update dependencies stem from the operation types of the updates. In a directory having a tree structure, such as LDAP, Update dependencies are also related to the distinguished names of the entries on which the operations applies.","An example of dependency is that an \u201cadd\u201d operation on an entry dn depends on a previous \u201cadd\u201d operation on an entry dn, if the entry dn is an ancestor of entry dn, as it is impossible to add an entry to a parent entry that does not exist.","However, a given update is not necessarily dependent on the updates which have been originally applied in the master server before it. For instance, a \u201cdelete\u201d operation on an entry dn is independent of a previous \u201cdelete\u201d operation on an entry identified by dn, if entry dn has the same parent as entry dn.","In the foregoing description, an operation on an entry identified by a distinguished name dn will be designated either by \u201cop(dn)\u201d, where op may be an \u201cadd\u201d, \u201cdel\u201d or \u201cmod\u201d operation or by \u201cop(dn\u2192dn\u2032)\u201d, where op is a \u201cmodRDN\u201d operation that replaces dn with dn\u2032.","In the prior art, such dependency conflicts are resolved in a replication session between a master server and a slave server both by:\n\n","The present invention proposes to improve replay performances on the consumer side by exploiting dependencies between updates.","In the multi-master topologies of the prior art, a replication session occurs between a supplier and consumer over a connection. In particular, a replication session occurs between a master server acting as a supplier and a slave server acting as a consumer.","The detailed description will be made hereinafter in reference to a replication session between a master server and a slave server. Therefore, the expressions \u201csupplier\u201d or \u201csupplier server\u201d will designate a master server and the expressions \u201cconsumer\u201d or \u201cconsumer server\u201d will designate a slave server.","The replication session may be initiated by the supplier, in which case the supplier starts the replication session by opening a connection to the consumer. The supplier binds using the authentication credentials provided in a replication agreement.","The consumer does not support multiple concurrent replication sessions with more than one supplier. A supplier which attempts to initiate a replication session with a consumer that is already participating to another replication session may receive an appropriate error.","The update transfer protocol defines the operations the supplier should perform to initialize a replication session.","A supplier-initiated replication session will be described below, in reference to ","The supplier  initiates a replication session with a consumer  connected thereto by sending a replication start request Repl_start_Req to the consumer. The parameters of the replication start request identify the replication agreement associated with the session, the update transfer protocol associated with the replication session, and other state information required to initiate the replication session.","The consumer  then sends back a replication start response Replstart_Resp to the supplier . The parameters of the replication start response include a response code, and an optional update vector.","Afterwards, the supplier sends selected updates through a number of request\/response exchanges with the consumer. The update transfer protocol defines the mechanisms for the consumer to receive selected updates based on the current state of replication represented in an update vector.","Upon sending all the selected updates to the consumer, the supplier  sends a replication end request Repl_end_Req to the consumer .","In return, the consumer  sends back a replication end response Repl_end_Resp to the supplier .","The purpose of the replication end request and the replication end response is to secure the state of the update vectors associated with the two replicas which participate to replication.","Upon terminating a replication session, the supplier  can either start a new replication session or release its binding to the consumer .","Each master server may receive updates from clients and from other master servers connected thereto. As a result, the updates applied in the master replica comprise:\n\n","Each original update applied in a master replica is attached a Change Sequence Number CSN uniquely identifying the update. A CSN value is generated for each update made to an entry at the master server at which the update was created and is propagated with the associated update data toward the other servers, upon replication.","In particular, a CSN value is formed of three components:\n\n","An additional reserved field may be provided.","Such CSN composition ensures the uniqueness of every generated CSN. When CSNs are to be compared to determine their ordering, they are compared component by component: first the time indication, then the change count, then the replica identifier and finally the above mentioned reserved field, when provided.","The time indication may be a year-2000-safe representation of the real world time, with a granularity of one second and indicates the time at which the update was locally created.","Because many updates, at a single replica, may be applied to the same data in a single second, the change count component of the CSN may be provided to further order the updates.","Each replica maintains a change count of the updates applied against it. The change count is reset to zero at the start of each second, and is increasing within that second, incremented for each and every update.","If updates occur at different replicas to the same data, within the same single second, and happen to be assigned the same change count number, then the Replica Identifier is used to further order the changes. The Replica Identifier is a unique identifier of a particular replica in the whole topology.","The above mentioned reserved field may be used as a modification number for ordering the LDAP update operations (e.g. \u201cadd\u201d, \u201cdelete\u201d) that are produced in the topology.","Therefore, a change sequence number ensures that:\n\n","A replication log may be maintained by each master server for storing a history of the updates applied in its replica.","A replication log is a record that describes the modifications that have occurred on a replica. When an entry is modified, a change record describing the update that was performed, e.g., a LDAP operation, is recorded in the replication log. A replication log is ordered according to the CSNs attached to the updates.","The supplier may use the consumer update vector received from the consumer to determine the sequence of updates that should be sent to the consumer. Each server maintains an update vector to record the point to which the replica has been updated.","An update vector represents a set of CSN values, each value representing a respective master replica, among the master replicas of the topology. In particular, each CSN value in the update vector corresponds to the most recent update known locally that occurred in the master replica where this CSN value was originated.",{"@attributes":{"id":"p-0113","num":"0149"},"figref":"FIG. 7","b":["50","52","504","502"]},"The updates are stored in the replication log  in the form of update primitives, each defining an update made to the master replica. Each update primitive comprises sufficient data to allow recreation of corresponding state change on the consumer replica (in particular the operation type of the update, the DN of the entry on which the operation applies, and other operation arguments) and a CSN identifying the original update. The replication log is ordered from the earliest to the latest CSN values.","The supplier  selects the updates to send from the replication log  and transmits them to a synchronous sender , in the order they were retrieved. Upon receiving the selected updates, the synchronous sender  sends a replication update request to the consumer for starting the update transfer.","The sender  successively sends the selected updates, according to the replication log order, i.e. from the earliest selected update to the latest selected update.","On sending an update UPD_N to the consumer , the sender  waits for a replay acknowledgment from the consumer  before sending the next update UPD_N+1. More specifically, the consumer  has an update application function or replay function  capable of replaying update UPD_N received from the supplier in the consumer database  and upon replaying update UPD_N, of sending back a replay acknowledgment ACK_N to the synchronous sender .","The synchronous sender  will send the next selected update UPD_N+1 only after the receipt of that acknowledgment ACK_N.","The update transfer from the supplier toward the consumer goes on in this way until all the selected updates are sent.","The fact that the supplier waits for an acknowledgment ACK_N, indicating that update UPD_N has been replayed, before sending update UPD_N+1 ensures that the consumer replays the updates in the order they were retrieved from the supplier replication log, i.e in the order they were applied by the master server. Therefore, in the prior art the update transfer is required to be synchronous and the update replay on the consumer side is required to be serial. As a result, replay performances are not optimized even if dependency conflicts are avoided.","The directory server system and the method according to the invention make it possible to optimize those update performances. Particularly, the directory server system and the method according to the invention make it possible for the consumer to replay multiple updates simultaneously while keeping consistency.",{"@attributes":{"id":"p-0122","num":"0158"},"figref":"FIG. 8","b":["510","512"]},"Like in the prior art, the master server determines the sequence of updates that the consumer needs to be sent, from the consumer update vector and then selects this sequence of updates. The master server may select this sequence of updates in the replication log , which contains a history of the updates applied in the master replica , in order to transmit them to an asynchronous sender .","The asynchronous sender  is arranged to successively send the updates in the replication log order. According to the embodiments of the invention, the asynchronous sender  sends each selected update without caring about the replay of the previously sent update, on the consumer side.","Thus, for example, after sending the update UPD_N to the consumer, the sender  will send the next update UPD_N+1 even if acknowledgment ACK_N has not yet been received from the consumer.","According to the embodiments of the invention, the consumer  will be able to replay a given selected update:\n\n","Accordingly, the consumer  comprises a dependency checker  for determining whether each update UPD received from the master server  depends on other updates {UPD\u2032}, and if not for transmitting the update UPD to the update replay function .","The update replay function  is operable for applying or replaying the updates received from the dependency checker in the consumer replica. The dependency checker  may process multiple updates at the same time, and as well the update replay function  may replay simultaneously multiple updates, thus taking advantage of the multithreading capabilities of the host system.","The dependency checker  is further capable of storing an update UPD in pending update items , if that update depends on other updates {UPD\u2032} and if at least one of these other updates has not yet been replayed in the consumer replica.","In this case, update UPD is stored in the pending update items  until all the other updates {UPD\u2032} on which UPD depends are replayed. Once all the other updates {UPD\u2032} have been replayed, update UPD is retrieved from the pending update items  and transmitted to the update replay function .","The dependency checker may also interact with committed update items  which represent the updates that have been already replayed among the selected updates.",{"@attributes":{"id":"p-0132","num":"0170"},"figref":["FIG. 12","FIG. 12"]},"Upon receiving a selected update UPD from the master server at step , the dependency checker performs operation  for determining whether update UPD depends on other updates {UPD\u2032} among the updates selected by the master server and if not, the consumer sends update UPD to the replay function at operation .","If update UPD depends on other updates {UPD\u2032}, the dependency checker further performs operation  to determine whether all the other updates {UPD\u2032} on which update UPD depends have been applied. If the updates {UPD\u2032} have all been applied, the dependency checker sends update UPD to the update replay function at operation . Otherwise, update UPD is stored in the pending update items, at operation .","Then the dependency checker determines if all the selected updates have been processed and if not processes the other selected updates it has received at operation .",{"@attributes":{"id":"p-0136","num":"0174"},"figref":["FIG. 13","FIG. 13"]},"Upon receiving an update UPD from the dependency checker at step , the replay function applies update UPD to the consumer replica at operation .","The replay function sends afterwards an acknowledgment for that update UPD to the master server to indicate that the update has been replayed.","The replay function may then mark update UPD as committed in the committed update items at operation .","Furthermore, if the pending update items contained an update UPD\u2033 which depends only on update UPD or which depends on update UPD and on further updates that have been already replayed, this pending update UPD\u2033 could also be replayed now. That is why, the replay function finally repeats operations  through  for each update represented in the pending update items at operation .","Turning back to , the master server may have a dependency builder  for computing dependency indications for an update UPD to be sent to the consumer, each dependency indication being associated to another update UPD\u2032 on which update UPD depends.","The dependency builder may interact with a two input array or dependency array for computing the dependency indications. The dependency array is filled according to predefined dependency links between the existing operation types. Upon receipt of a first update at a first input and of a second update at a second input, this dependency array may provide the dependency link of the first update with respect to the second update.","An exemplary dependency array is represented in Exhibit A, for use in a LDAP directory server system. In this array, dn represents the DN of a given entry, dn\u2032 the DN of the parent entry of entry dn, dn\u2033 the DN of a child entry of entry dn, and dn and dn the DN of other entries distinct from the entries dn, dn\u2032 and dn\u2033.","The dependency array of Exhibit A indicates that:\n\n","This dependency array provides the dependency link for a first update comprising one of the operation types in the first raw, with respect to a second update comprising one of the operation types in the first column.","The first input of the dependency array is to receive an update for which it is desired to compute dependencies and the second input of the dependency array is to receive an update, among the selected updates on which the update of the first input is likely to depend. For example, the second input of the dependency array is to receive an update among the selected updates which have been previously sent as will be described later.","In the example of exhibit A, the update received at the first input is compared with the update types stored in the first raw of the dependency array and the update received at the second input is compared with the update types stored in the first column of the dependency array. The dependency array may then determine the dependency value attached to the couple that match the update at the first input and the update at the second input. By way of example, a value \u201c0\u201d is chosen herein to indicate that a given update in the first raw does not depend on an update in the first column and a value \u201c1\u201d to indicate that a given update in the first raw depends on an update in the first column. For instance if the update \u201cadd(dn)\u201d is entered at the first input of the dependency array and if the previous \u201cdel(dn\u2032)\u201d is entered at the second input, dn\u2032 being the DN of the parent entry of entry dn, the dependency array will provide the dependency value 1.","As, in the first column, only the updates which cause dependency for one of the possible updates in the first raw are represented in the dependency array, the dependency array may found no couple matching the update of the first input and the update of the second input and may therefore find no dependency value in the dependency array. This will be interpreted as equivalent to a value 0.","The dependency builder  may also interact with update sending state items maintained by the master server to select the updates to enter at the second input of the dependency array.","Each item in the update sending state items represents an update among the selected updates which have been previously sent to the consumer. Indeed, a dependency may occur if a selected update UPD, depending on another selected update UPD\u2032, is replayed before that other update UPD\u2032. When the asynchronous sender  sends the updates in the order they were applied by the master (the replication log order), the selected update UPD is likely to be in dependency conflict with only one of the previously sent updates which are represented by the update sending state items. Therefore, the dependency builder  can scan the update sending state items to compute the dependency indications attached to an update.","As explained above, dependencies for a selected update may only be related to the previously sent updates. However, as some of those previously sent updates may have been already replayed, they cannot cause a dependency conflict for the selected update anymore.","Therefore, the update sending state items  of the master server  may be alternatively represented by the updates which have not yet been replayed among the previously sent updates.","The master server may obtain information about update replay through replay acknowledgments. When the consumer sends back a replay acknowledgment for an update UPD, this acknowledgment comprises an acknowledgment indication representing that update UPD. The master server may store the acknowledgment indications received from the master during a replication session in an acknowledgment indication storage.","Accordingly, the update sending state items may be maintained from this acknowledgment indication storage. In this case, each item in the update sending state items represents an update among the selected updates which have been previously sent to the consumer and not yet acknowledged.","The following description will be made in reference to update sending state items representing the updates that have been acknowledged among the previously sent updates, by way of example.","According to another embodiment of the invention, the dependency builder  may both interact with the dependency array  and the update state items  to compute the dependency indications for a selected update, as will be described later in reference to .","In complement, upon selecting the updates in the replication log in the order, the master server may attach to each selected update an ordering indication before transmitting it to the dependency builder. In particular, each ordering indication comprises an ordering number or Operation Change Number OCN increasingly attached to the selected updates. Thus, an OCN may be an increasing number starting from 1 for the first change to be sent in a given replication session. The asynchronous sender may send a selected update together with the OCN attached thereto and therefore the consumer will have information about the initial ordering of the updates which is consistent.","According to a suitable protocol, e.g. the Multi-Master Asynchronous Transport Replication Protocol, for each selected update to be sent, the asynchronous sender may send a replication update request to the consumer. The asynchronous sender may send multiple of them without waiting for response from the consumer.","The number of updates the supplier can send at the same time per replication update request may be limited by a group value. The number of replication update requests the supplier can send without waiting for an answer from the consumer may be limited by a credit value.","The group value and the value credit may be negotiated between the supplier and the consumer during the session initiation.","In reference to , an exemplary replication log  is shown, that comprises a history of the updates applied to the master replica. This replication log comprises updates UPD through UPD.","The replication log is ordered according to the respective CSNs attached to the updates, and thus update UPD has the latest CSN while update UPD has the earliest CSN. From the update vector received from the consumer, the master server may have determined for example that the consumer has not yet received the updates comprised inside the dotted frame , i.e. updates UPD through the last update. The supplier selects a subset of these updates, e.g. UPD through UPD and attaches them respectively the numbers 1 through 3.","Thus, a sequence of updates to be sent comprises a number of updates UPD(p) through UPD(n) as represented in .","According to the invention, each update received by the dependency builder may contain the following information, as represented in :\n\n","The dependency builder then computes the dependency indications for each selected update from those information, as will be described hereinafter in reference to .","During a replication session, the supplier keeps track of the updates it has already sent to the consumer in the update sending state items. In particular, the updates represented in the update sending state items further correspond to updates which have been already acknowledged.",{"@attributes":{"id":"p-0167","num":"0228"},"figref":"FIG. 17"},"The dependency builder parses the update sending state items at operation . As explained above, each update sending state item may represent an update which has been sent but not yet acknowledged from the consumer.","For each update sending state item being parsed, which represents an update UPD\u2032, the dependency builder inputs update UPD at the first input of the dependency array and update UPD\u2032 at the second input of the dependency array, at operation . The dependency array provides the dependency link dep of update UPD with respect to update UPD\u2032.","At operation , the dependency builder determines whether the dependency link dep indicates that update UPD does not depend on update UPD\u2032, which may be expressed by a \u201cnull\u201d value or a \u201c0\u201d value for example.","If update UPD depends on update UPD\u2032, the dependency builder generates, at operation , a dependency indication representing update UPD\u2032 inside the dependency indications attached to update UPD.","If update UPD does not depend on update UPD\u2032, the dependency builder determines whether all the update sending state items have been parsed at operation  and if not parses the next update sending state item at operation .","If all the update sending state items have been parsed, the dependency builder scans the contents of the dependency indications at operation . If the dependency indications contain values, the dependency builder transmits update UPD with these dependency indications to the asynchronous sender, at operation . If the dependency indications contain no value, (expressed by \u201cdependency indications=null\u201d), the dependency builder attaches a \u201cno-dependency\u201d value to the dependency indications of update UPD, at operation , before performing operation .",{"@attributes":{"id":"p-0174","num":"0235"},"figref":"FIG. 18"},"According this particular embodiment of the invention, each update which has been previously sent and not yet acknowledged is represented in the update sending state items by its OCN. The update sending state items form a list L which is ordered according to the OCN contained therein.","Upon receiving an update OCN for computing its dependency indications, the dependency builder starts a first parsing of list L at operation , from the lowest ordering number OCN_min to the highest ordering number OCN_max. The first parsing will be stopped as soon as an update OCN\u2032 is found in the list on which update OCN depends or until the end of the list is reached.","For each update being attached an ordering number OCN\u2032, the dependency builder passes update OCN at the first input of the dependency array and update OCN\u2032 at the second input of the dependency array. The dependency array provides the dependency link dep of update OCN with respect to update OCN\u2032.","The dependency builder determines whether this dependency link dep indicates that update OCN does not depend on update OCN\u2032 (\u201cdep=null\u201d) at operation . If update OCN depends on update OCN\u2032, the dependency builder stops the first parsing at operation  and goes to operation  which will be described below in reference to .","If update OCN does not depend on update OCN\u2032, the dependency builder determines whether the end of list L has been reached, i.e. if OCN matches OCN_max, at operation . If not, the dependency builder processes the next update OCN\u2032 in list L, according to operations  through .","If the end of the list L has been reached, i.e. if OCN matches OCN_max, the result of the first parsing is that no dependency indication has been generated and the dependency indications are tagged with a \u201cno-dependency\u201d value at operation . At operation , update OCN is transmitted to the asynchronous sender.",{"@attributes":{"id":"p-0181","num":"0242"},"figref":"FIG. 19","b":["400","400"]},"The flowchart of  is to be implemented in a directory server system having a tree structure with \u201cadd\u201d, \u201cdelete\u201d, \u201cmodify\u201d and \u201cmodifyRDN\u201d operation types.","If update OCN has been found dependent on update OCN\u2032 at operation  of , the dependency builder further determines whether update OCN has the operation type \u201cdelete\u201d at operation  of .","If not, i.e update OCN has one of the operation types \u201cadd\u201d, \u201cmodify\u201d and \u201cmodifyRDN\u201d, the dependency builder will add the change number OCN\u2032 in the dependency indications of update OCN at operation  and transmit update OCN together with its dependency indications to the asynchronous sender at operation .","Otherwise, if update OCN has an operation type \u201cdelete\u201d, the dependency builder starts a second parsing of list L, at operation , but this time, from the highest ordering number OCN_max to the lowest ordering number OCN_min=OCN\u2032. This is because a \u201cdelete\u201d operation on an entry dn is an operation that depends on a previous delete operation on an entry having dn\u2033, where entry dn is a child of entry dn\u2033, the entry dn being likely to have more than one child entry stored in the update sending state items.","During the second parsing, for each update OCN\u2033 in list L, the dependency builder gets the dependency link dep of update OCN with respect to update OCN\u2033 through the dependency array at operation . At operation , the dependency builder determines whether update OCN is independent of update OCN\u2033.","If update OCN is independent of update OCN\u2033, the dependency builder processes the next update OCN\u2033 in list L according to the operations  through  until OCN\u2032 is reached.","If update OCN is found dependent on update OCN\u2033 at operation , the second parsing is stopped and the dependency builder determines whether OCN\u2033 is equal to OCN\u2032, at operation . If OCN\u2033 is equal to OCN\u2032, the dependency builder adds OCN\u2032 in the dependency indications of update OCN at operation  and update OCN is transmitted to the asynchronous sender together with its dependency indications, at operation .","If OCN\u2033 is different from OCN\u2032, the dependency builder adds, in the dependency indications of update OCN, all the operation change numbers which are comprised between OCN\u2032 and OCN\u2033 inside list L, at operation . These dependency indications may be represented in the form of an interval having the limits OCN\u2032 and OCN\u2033, for example [OCN\u2032, OCN\u2033], if OCN\u2033 is higher than OCN\u2032. At operation , update OCN is then transmitted to the asynchronous sender together with its dependency indications.","Therefore, updates may be represented in the dependency indications by their ordering numbers.","The computing of the dependency indications may be very cheap when the update sending state items are limited in size by the credit value.","On the consumer side, such dependency indications may be used to improve the update replay which has been described in reference to .","In particular, the dependency checker may scan the dependency indications for determining whether an update UPD depends on other updates among the selected updates.",{"@attributes":{"id":"p-0194","num":"0255"},"figref":"FIGS. 14 through 16"},"According to this embodiment of the invention, the consumer server comprises an incoming update storage or incoming update queue , represented in , for storing the updates received from the supplier during a replication session. A received update comprises the OCN attached thereto, the state information represented in , and the dependency indications computed by the supplier. The incoming update queue is ordered according to the OCN attached to the updates.","Furthermore, the pending update items maintained by the dependency checker also form a queue or pending update queue, in which the updates are also ordered according to their OCN.","The committed update items maintained by the dependency checker also form a queue or committed update queue, in which the updates are ordered according to their OCN.","The following description will be made in reference to a directory server having a tree structure and comprising the operation types \u201cadd\u201d, \u201cdelete\u201d, \u201cmodify\u201d and \u201cmodifyRDN\u201d, by way of example. According to this example, the dependency indications attached to an update OCN will either contain a single value OCN\u2032, an interval of the type [OCN_low, OCN_up], or a \u201cno_dependency\u201d value.","On the consumer side, an update OCN received by the consumer server may thus have the following dependency indications according to the particular embodiment of the invention:\n\n",{"@attributes":{"id":"p-0200","num":"0264"},"figref":"FIG. 14"},"During a replication session, this dependency checker thread gets the update having the lowest OCN in the incoming update queue at operation . While operation  is performed by this thread, the access to the incoming update queue is locked for the other threads. At operation , the dependency checker thread then determines whether update OCN depends on other uncommitted updates. This operation is described in . If not, the dependency checker thread transmits update OCN to the replay function. The operations performed by the update replay function is described in .","If update OCN depends on other uncommitted updates, update OCN is stored in the pending update queue, at operation .","At operation , the dependency checker thread determines if update OCN is the incoming update queue tail and if not returns to operation .","Otherwise, the dependency checker thread waits until the receipt of another selected update in the incoming update queue at operation  before returning to operation .",{"@attributes":{"id":"p-0205","num":"0269"},"figref":"FIG. 15"},"Upon receiving an update OCN from the dependency checker at step , the replay function thread applies update OCN to the consumer replica at operation .","At operation , the replay function sends afterwards an acknowledgment indication comprising the value \u201cOCN\u201d to the master server in order to indicate that update OCN has been replayed.","The replay function also adds update OCN in the committed update items at operation  to locally indicate that update OCN has been replayed.","The replay function finally repeats operations  through  for each update in the pending update queue, at . As update OCN has been replayed, operation  is performed to check if one of the update in the pending update queue can be now replayed, i.e if one of the update in the pending update queue depends only on update OCN or depends on update OCN and on further updates which have been already replayed.",{"@attributes":{"id":"p-0210","num":"0274"},"figref":["FIG. 16","FIG. 14"],"b":"204"},"At operation , the dependency checker thread gets the dependency indications DEP_OCN attached to update OCN. As seen above, these dependency indications were initially computed by the master server before sending update OCN and may comprise the operation change numbers which represent the updates on which update OCN depends, among the selected updates which were sent by the master server and not yet acknowledged at the computation time.","At operation , the dependency checker thread determines whether the dependency indications DEP_OCN is tagged with \u201cNo_dependency\u201d. If so, the result is that update OCN is independent of uncommitted updates at .","Otherwise, the dependency checker thread gets the committed update queue CUQ at operation  and determines at operation  whether the operation change numbers OCN\u2032 comprised in the dependency indications are further included in the committed update queue CUQ and if not the result is still that update OCN is independent of uncommitted updates at .","If the dependency indications are represented in the form of an interval [OCN_low,OCN_up], operation  may be performed by successively determining whether each update from OCN_low through OCN_up is comprised in the committed update queue, where OCN_low is the lowest limit of the interval and OCN_up is the upper limit of the interval.","The result will be that update OCN is independent of uncommitted updates OCN\u2032 at , if all the OCN values comprised in the interval are found comprised in the committed update queue. However, the result will be that update OCN is dependent on uncommitted updates OCN\u2032 at , as soon as an update is found whose operation change number is not comprised in the committed update queue.","In complement, the dependency checker may further maintain a Next Expected Change Number NECN to improve multithreading replay performances. The NECN represents the next change after the latest operation change number among the updates for which all the previous updates have been replayed.","Thus, an update having an OCN value that matches the NECN value is ensured to have no dependencies and therefore operation  can be performed immediately after operation , without performing operations  and  of .","More specifically, the NECN is set to 1 at the beginning of a replication session. On replaying an update whose OCN matches the NECN value, a dependency checker thread increments a first time the NECN value. If the new NECN value corresponds to an update that has been replayed, i.e. that is comprised in the committed update queue, this new NECN value may be incremented again until the obtained NECN value corresponds to an update that has not yet been replayed.","Moreover, when a NECN value is incremented by a given dependency checker thread, the access to NECN is locked for the other dependency checker threads to avoid conflicting changes on NECN.","An example will be described hereinafter illustrating the particular embodiment of the invention for use in a directory server system having a tree structure. This example will be described in reference to exhibit B.","The supplier may for example select the following updates from the replication log and increasingly attach them an OCN value, represented below in the form of \u201c#i\u201d, where i is an increasing integer:\n\n","It is reminded that an entry cannot be deleted if it has child entries. Therefore, in the example, the entries A, B and C must be deleted before deleting entry z, and the entries AB and AC must be deleted before deleting entry X.","The array B of Exhibit B shows the dependency indications computed by the dependency builder for each entry represented by its ordering indication in the first column.","The value \u201c0\u201d for the dependency indications are equivalent to a \u201cno_dependency\u201d value. The dependency indications for an update \u201c#i\u201d may be either a single value representing an operation change number \u201c#j\u201d or \u201c0\u201d or an interval \u201c[#k, #k+p]\u201d.","The selected updates are sent to the consumer with their ordering number and with the dependency indications attached thereto.","The arrays B through B of exhibit B show different steps of the replay on the consumer side.","The update processing state array contains the updates which can be replayed by the replay function. The pending update queue array contains the updates that are queued up and the committed update queue array contains the updates which have been replayed.","At the first step represented by the arrays B, the consumer may:\n\n","At the next step represented by the arrays B:\n\n","Therefore, the consumer may:\n\n","At the next step represented by the arrays B:\n\n","Therefore, the consumer may:\n\n","At the next step represented by the arrays B:\n\n","Therefore, the consumer may:\n\n","It would be understood by those skilled in the art that this example is a very static view of what could happen during a replication session, as all the updates may not be received in the same time by the consumer.","Exhibit A",{"@attributes":{"id":"p-0236","num":"0321"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},{},{},{},"modRDN"]},{"entry":[{},"ADD(dn)","DEL(dn)","MOD(dn)","(dn\u2192dn2)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["previous ADD(dn)","0","1","1","1"]},{"entry":["previous ADD(dn\u2032)","1","1","0","1"]},{"entry":["previous DEL(dn)","1","0","1","1"]},{"entry":["previous DEL(dn\u2032)","1","1","0","1"]},{"entry":["previous DEL(dn\u2033)","0","1","0","0"]},{"entry":["previous","1","1","0","1"]},{"entry":"modRDN(dn\u2032\u2192dn1)"},{"entry":["previous","1","0","0","0"]},{"entry":"modRDN(dn1\u2192dn\u2032)"},{"entry":["previous","0","0","1","1"]},{"entry":"modRDN(dn\u2192dn1)"},{"entry":["previous","0","0","0","1"]},{"entry":"modRDN(dn1\u2192dn)"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":"where:"},{"entry":"entry dn\u2032 is the parent entry of entry dn,"},{"entry":"entry dn\u2033 is a child entry of entry dn,"},{"entry":"entries dn1 and dn2 represent entries which do not have such relationships with entry dn."}]}}]}},"br":{}},{"@attributes":{"id":"p-0237","num":"0322"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"B.1-"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Ordering indications","dependency indications"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"#1","0"]},{"entry":[{},"#2","0"]},{"entry":[{},"#3","0"]},{"entry":[{},"#4","0"]},{"entry":[{},"#5","#4"]},{"entry":[{},"#6","#4"]},{"entry":[{},"#7","0"]},{"entry":[{},"#8","0"]},{"entry":[{},"#9","[#1, #3]"]},{"entry":[{},"\u2002#10","[#7, #8]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0238","num":"0323"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"B.2-"},{"entry":{"chemistry":{"@attributes":{"id":"CHEM-US-00001","num":"00001"},"img":{"@attributes":{"id":"EMI-C00001","he":"23.20mm","wi":"66.72mm","file":"US07584174-20090901-C00001.TIF","alt":"embedded image","img-content":"table","img-format":"tif"}}}}},{"entry":"B.3-"},{"entry":{"chemistry":{"@attributes":{"id":"CHEM-US-00002","num":"00002"},"img":{"@attributes":{"id":"EMI-C00002","he":"23.20mm","wi":"66.72mm","file":"US07584174-20090901-C00002.TIF","alt":"embedded image","img-content":"table","img-format":"tif"}}}}},{"entry":"B.4-"},{"entry":{"chemistry":{"@attributes":{"id":"CHEM-US-00003","num":"00003"},"img":{"@attributes":{"id":"EMI-C00003","he":"23.20mm","wi":"66.63mm","file":"US07584174-20090901-C00003.TIF","alt":"embedded image","img-content":"table","img-format":"tif"}}}}},{"entry":"B.5-"},{"entry":{"chemistry":{"@attributes":{"id":"CHEM-US-00004","num":"00004"},"img":{"@attributes":{"id":"EMI-C00004","he":"23.20mm","wi":"66.63mm","file":"US07584174-20090901-C00004.TIF","alt":"embedded image","img-content":"table","img-format":"tif"}}}}},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"p":["Other alternative features and advantages of the invention will appear in the detailed description below and in the appended drawings, in which:",{"@attributes":{"id":"p-0010","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0020"},"figref":"FIG. 6","i":"a "},{"@attributes":{"id":"p-0016","num":"0021"},"figref":"FIG. 6","i":"b "},{"@attributes":{"id":"p-0017","num":"0022"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0023"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0024"},"figref":"FIGS. 9","b":"10"},{"@attributes":{"id":"p-0020","num":"0025"},"figref":"FIGS. 11"},{"@attributes":{"id":"p-0021","num":"0026"},"figref":"FIGS. 12","b":"13"},{"@attributes":{"id":"p-0022","num":"0027"},"figref":"FIGS. 14 through 16"},{"@attributes":{"id":"p-0023","num":"0028"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0024","num":"0029"},"figref":"FIGS. 18 and 19"}]},"DETDESC":[{},{}]}
