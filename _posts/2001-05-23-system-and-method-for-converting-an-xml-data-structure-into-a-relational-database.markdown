---
title: System and method for converting an XML data structure into a relational database
abstract: The present invention provides systems and methods for converting between an XML data structure and a relational database. It enables the storage of an XML document in such a way that: the relational data model would not have to change as the document model changes; the structure of the tables is set up in such a way that the entire document can be retrieved with a single query in a linear (i.e. non-recursive) fashion; and, information about specific individual components within an XML document can be retrieved via simple queries that do not require hierarchy traversals or intensive, post-query data parsing.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06915304&OS=06915304&RS=06915304
owner: 
number: 06915304
owner_city: 
owner_country: 
publication_date: 20010523
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED PATENT APPLICATIONS","STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH OR DEVELOPMENT","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application is a continuation-in-part of U.S. Provisional Patent application No. 60\/206,325 filed May 23, 2000.","Not Applicable.","The invention relates generally to the field of software technology and programming and more particularly to the representation and persistent storage of XML documents (or other programming objects that can be represented as XML documents) within a relational database.","Recent advances in software technology and the Internet are responsible for the proliferation of Extensible Markup Language (XML) as a standard for data representation. XML is a technology standard endorsed by the World-Wide-Web Consortium (W3C). Unlike HTML (the Internet standard for displaying information in a browser), which is concerned with the display and format of information, XML is concerned mostly with the structure of the data contained within a document (or other structured data object). For instance, a standard HTML web page contains instructions (or tags) that may instruct a browser to display a heading in bold font. An XML page on the other hand contains tags that allow a specialized browser (or other software) to know where the name of an author may be found within the contents of a document.","XML data is stored in XML documents. An XML document includes 3 main parts: a prolog, a body and an epilog. The prolog and epilog are considered optional parts of the document.","The prolog may include one or more processing instructions, a document type declaration, and one or more comments. The body of the document includes exactly one XML element known as the document element. In one of its simplest forms, an XML element includes a start tag, an end tag and some data therebetween. The epilog of the document may contain processing instructions and comments. Since the prolog and epilog are optional, the body represents the main content of the document.","The simple data contained between start and end tags that is not an element, processing instruction or comment is sometimes called a text node. A text node can be almost any string of characters provided it does not contain characters that would be confused with XML markup. To properly embed an XML parsing instruction in the text node without violating XML rules would require a CDATA section. CDATA sections are special text nodes that tell a parser to ignore any XML parsing instructions it may encounter within a text node.","XML is quickly becoming a standard way in which businesses exchange information electronically. This is due to the fact that XML is evolving into a behind-the-scenes data format for business-to-business data exchange. As a result of this business-to-business data exchange, programmers have extended the usage of XML beyond simply representation of document data. Programmers now find themselves using XML as way to structure data records and complex programming objects.","One example of such general purpose programming usage of XML is in Object Oriented (OO) programming. In Object Oriented programming languages (such as Java, C++ and Smalltalk), programmers can represent data as complex objects including one or more attributes. For instance, a customer object may include a name, gender and date-of-birth. In some cases, objects are made up of smaller objects. An example might be when a customer object includes a shipping address object, which in turn includes a street, city, state and zip code. Such information might also be represented as an XML document.","While the above is helpful in an abstract sense, this alternative representation of the data object only really begins to benefit the programmer when one considers storing the information on a more permanent basis. In general, programming objects are thought of as objects that exist in memory. Their true usefulness is only truly manifest when the information that the objects represent are stored permanently on dynamically accessible magnetic (or some cases, optical) media for later processing, such as on a computer hard drive. This process of storing programming object information on a more permanent basis is often referred to as object persistence.","Conventional computer software uses a variety of techniques to accomplish object (as well as general data) persistence. One of the most common techniques is the use of relational database technology. In an abstract sense, relational databases store objects as inter-related tables of information that are described by rows and columns (much like a spreadsheet). However, the representation of objects can become very complex when considering a relational database structure. While the benefit of the relational data model is in the ability of programmers to query the database to retrieve information about an attribute of an object, the more complicated the objects and the interrelationships become, the more complicated the relational data model becomes. This can increase the time it takes to write and test software.","Accordingly, it would be advantageous to provide techniques that would rely on a general data model for storage that does not change as the object model changes. It would be a further advantage to provide such techniques that employ XML.","One of the problems with the persistence of XML data in a relational database is that XML data is hierarchical in nature. Hierarchical information is inherently recursive. If this information is stored in a relational database, one might have to employ a recursive query algorithm to get an entire document. Recursive querying on a database can be a resource intensive process. Therefore it would be advantageous if a general technique could be devised to represent object data as XML in a relational database in such a way that would not require recursive querying while still maintaining the benefits of a general (non-changing) data model that still maintains the structure of the individual document components.","An aspect of the invention provides a method of forming a relational database from an Extensible Markup Language (XML) document. The XML document includes multiple nodes. The method includes assigning an identifier to every node of the XML document and assigning a respective sequence identifier to each node of the XML document. The respective sequence identifiers identify an order of the nodes in the XML document. The method also includes converting each node of the XML document into a respective row of the relational database.","Another aspect of the invention provides a method of forming a relational database from an Extensible Markup Language (XML) document. The method includes assigning an identifier to the XML document and creating a row of the relational database that includes the identifier, and content of one of the plurality of nodes that makes up the XML document.","Yet another aspect of the invention provides a relational database. The database includes a row containing content from a node of an Extensible Markup Language (XML) document. The row also includes an XML documeni identifier.","The invention will next be described in connection with certain illustrated embodiments and practices. However, it will be clear to those skilled in the art that various modifications, additions and subtractions can be made without departing from the spirit or scope of the claims.","The present invention provides system and method for converting between an XML data structure and a relational database.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1"},"A programming model that supports an in-memory representation such as the one depicted in , would provide methods to traverse the hierarchy of the tree programmatically. Conventional methods exist in the form of Document Object Models (DOM). The W3C defines a standard DOM for XML processing (www.w3c.org\/DOM which is incorporated herein by reference as if fully set forth). In addition, there exist variations on the W3C DOM, such as JDOM\u2122 (described at www.jdom.org which is incorporated herein by reference as if fully set forth), which is another in-memory XML processing model geared towards Java\u2122 programmers. In both cases, the model is object oriented implying that the programmatic representation is more easily implemented in an object oriented programming language such as Java or C++. For the purposes of the present invention, any suitable DOM implementation could be employed to access to the XML document.","Relational data is stored as rows of information where (in most cases) each row is uniquely identified by a certain unique key. A unique key unambiguously identifies an individual data component (or set of related components) within a certain context. On the surface, it would appear that XML does not have such a mechanism for its data components when each component is considered independently. When considered within the context of an entire document, however, it is possible to devise a scheme for mapping a unique key to each data component. The algorithm below describes such a technique. The technique below applies to elements, attributes and text (including CDATA sections) since those are the components that make up the true data components of an XML document. When the XML unique key mapping is applied to an actual database table later in this document, the algorithm will be extended to include other miscellaneous items such as processing instructions and comments. The following is an example of a simple customer object represented as an XML document:",{"@attributes":{"id":"p-0029","num":"0028"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<?XML version=\u201c1.0\u201d?>"]},{"entry":[{},"<customer type=\u201cpreferred\u201d>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<name>John Smith<\/name>"]},{"entry":[{},"<gender>male<\/gender>"]},{"entry":[{},"<phone type=\u201chome>516.555.1234<\/phone>"]},{"entry":[{},"<phone type=\u201coffice\u201d>212.555.1234<\/phone>"]},{"entry":[{},"<hobby name=\u201cskiing\u201d\/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/customer>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Ignoring for a moment the XML processing instruction, in this example, customer is the name of the document element. It is further described by an attribute named type and, in turn, contains child elements named name, gender, phone (2 instances) and hobby. Each of the child elements contain single text nodes and each of the phone elements also contain attributes (also named type). This example also includes an empty element (hobby). An empty element is a special type of element that cannot contain any child nodes (text, elements, processing instructions or comments). If an empty element is to contain anything at all, it will contain attributes only. In the example above, the hobby element is an example of an empty element.","In the above example the element and attribute names are not unique identifiers. If the document is studied as a whole, however, a form of unique identifier could be defined for each data item if the name of each ancestor element is remembered as the tree is traversed. For example:",{"@attributes":{"id":"p-0032","num":"0031"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Name","Value"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"customer\/type\/pcdata","preferred"]},{"entry":[{},"customer\/name\/pcdata","John Smith"]},{"entry":[{},"customer\/gender\/pcdata","male"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Using this scheme it is possible to differentiate between like named attributes (such as type in the above example). To handle repeating elements (such as phone), the mapping will be extended further as in the following example:",{"@attributes":{"id":"p-0034","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Name","Value"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"customer\/type","preferred"]},{"entry":[{},"customer\/name[1]\/pcdata[1]","John Smith"]},{"entry":[{},"customer\/gender\/pcdata","male"]},{"entry":[{},"customer\/phone[1]\/type","home"]},{"entry":[{},"customer\/phone[1]\/pcdata[1]","516.555.1234"]},{"entry":[{},"customer\/phone[2]\/type","office"]},{"entry":[{},"customer\/phone[2]\/pcdata[1]","212.555.1234"]},{"entry":[{},"customer\/hobby[1]\/name","skiing"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In the above example, numeric qualifiers have been added to any item that has the possibility of repeating within an element. This excludes the document element itself as well as all attribute names. The reason is that each is guaranteed to be unique within their respective contexts. Specifically, there is but one document element per XML document instance and, all attribute names must be unique within the context of a given element.","Text nodes have also been numerically qualified. The reason is that XML supports what is known as mixed element content. What this means is that text items and elements can be interspersed within a given parent element. Consider the following example: <paragraph>Please consult the document<reference>A document name<\/reference>for a complete description<\/paragraph>","In the preceding XML fragment, the element paragraph includes 2 text nodes and a single element node named reference. Since there are 2 text nodes, there would need to be mappings for . . . \/paragraph\/pcdata[] and . . . \/paragraph\/pcdata[] which refer to the text appearing to the left and right of the reference element respectively. While such usage is rare in data object modeling, the possibility must be accounted for, for purposes of completeness.","Now that the basic mechanism for uniquely describing XML data items has been described, the complete storage solution shall be described. To do so, the sample XML document will be augmented.",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<?XML version=\u201c1.0\u201d?>"]},{"entry":[{},"<?MyPI \u201csome PI data\u201d?>"]},{"entry":[{},"<customer type=\u201cpreferred\u201d>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<name>John Smith<\/name>"]},{"entry":[{},"<gender>male<\/gender>"]},{"entry":[{},"<phone type=\u201chome>516.555.1234<\/phone>"]},{"entry":[{},"<phone type=\u201coffice\u201d>212.555.1234<\/phone>"]},{"entry":[{},"<hobby name=\u201cskiing\u201d\/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/customer>"]},{"entry":[{},"<!-- this is the end of the document -->"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}],"b":"2","ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":["ID: This is the id associated with the XML document instance. All of the rows of data that correspond to a particular document instance will have the same id. This would imply that, in addition to the table above, there may also be a \u201cmaster document\u201d table containing one row per document which would contain information pertaining to the document as a whole. Such a table would be considered a parent table to the table above.","SEQ: This is a counter used for ordering the data components of the XML document instance. The sequence will ensure that the document data is stored in the order that it should appear if doing a top-down-left-right traversal.","ANCESTORS: This is the unique XML data mapping excluding only the last part (which is broken out and stored in the data_name column).","IMMEDIATE_PARENT: This is the unqualified immediate parent element name. In the case of prolog and epilog information, the words prolog and epilog are used respectively.","DATA_NAME: This is the last portion of the XML data mapping. It will contain one of an attribute name, a numerically qualified text name (either pcdata or cdata) with the counter unique within text type, the target name of a processing instruction node (with no numeric qualification needed) or a null value if the node is a comment node.","DATA_TYPE: Specifies the type of data node as attr for attributes, text for pcdata and cdata nodes, PI for processing instructions and comment for comments.","VALUE: This column will contain the value of the attribute, text data or comment. If the node is a processing instruction, the column will contain the instruction information.","EMPTY: This only applies to attribute rows and will be set to 1 if the attribute is part of an empty element, otherwise it will be set to zero. If the database being used supports Boolean data types, the Boolean values true and false may also be used instead of 1 and 0 respectively."]}},"Turning back to the example data in , the prolog information appears first, followed by the body data and lastly, the epilog information. Also, all of the data in the table appears in substantially the same order that it appears in the document. A simple SQL query for a given document id that orders the data by sequence number (the seq column) will result in the retrieval of all of the data necessary to produce an in-memory XML tree.","Each data component is also stored in its own row of data, providing an efficient mechanism for retrieving certain components of the XML document without having to retrieve the whole document itself.","The Storage Algorithm","Given the technique illustrated above, coupled with an in-memory XML API (application programming interface) such as the W3C DOM or JDOM, the storage algorithm becomes fairly straightforward.","The following pseudo-code demonstrates a technique for a given in-memory XML document instance:\n\n",{"@attributes":{"id":"p-0044","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ID := docId"]},{"entry":[{},"SEQ := sequence"]},{"entry":[{},"ANCESTORS := docName"]},{"entry":[{},"IMMEDIATE_PARENT := \u201cprolog\u201d"]},{"entry":[{},"DATA_NAME := target"]},{"entry":[{},"DATA_TYPE := \u201cPI\u201d"]},{"entry":[{},"DATA_VALUE := instruction"]},{"entry":[{},"EMPTY := 0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":{"@attributes":{"id":"ul0006-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0007","list-style":"none"},"li":{"@attributes":{"id":"ul0007-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0008","list-style":"none"},"li":"4.2.3. If node is a comment, do the following:\n            \n            "}}}}}},{"@attributes":{"id":"p-0045","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ID := docId"]},{"entry":[{},"SEQ := sequence"]},{"entry":[{},"ANCESTORS := docName"]},{"entry":[{},"IMMEDIATE_PARENT := \u201cprolog\u201d"]},{"entry":[{},"DATA_NAME := null"]},{"entry":[{},"DATA_TYPE := \u201ccomment\u201d"]},{"entry":[{},"DATA_VALUE := commentData"]},{"entry":[{},"EMPTY := 0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0010","list-style":"none"},"li":"5. Process the body of the document.\n    \n    "}},{"@attributes":{"id":"p-0046","num":"0079"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ID := docId"]},{"entry":[{},"SEQ := sequence"]},{"entry":[{},"ANCESTORS := ancestors"]},{"entry":[{},"IMMEDIATE_PARENT := parent"]},{"entry":[{},"DATA_NAME := attributeName"]},{"entry":[{},"DATA_TYPE := \u201cattr\u201d"]},{"entry":[{},"DATA_VALUE := attributeData"]},{"entry":[{},"EMPTY := empty"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0014","list-style":"none"},"li":{"@attributes":{"id":"ul0014-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0015","list-style":"none"},"li":{"@attributes":{"id":"ul0015-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0016","list-style":"none"},"li":["5.3.5. Initialize a new hash table of counters in preparation for child node processing. This table will start out with no values but, during child node processing, will be used to store counters corresponding to each unique child element node name, pcdata instance and\/or cdata instance encountered. As instances of each are encountered, counters will be kept for each for purposes of proper numerical qualification. Counters are not needed for processing instructions or comments.","5.3.6. Retrieve all child nodes of XmlElement in the order in which they appear.","5.3.7. Loop through all retrieved child node instances. Assign the current node instance to a local variable called node. For each value of node do the following:\n            \n            "]}}}}}},{"@attributes":{"id":"p-0047","num":"0088"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ID := docId"]},{"entry":[{},"SEQ := sequence"]},{"entry":[{},"ANCESTORS := ancestors"]},{"entry":[{},"IMMEDIATE_PARENT := parent"]},{"entry":[{},"DATA_NAME := target"]},{"entry":[{},"DATA_TYPE := \u201cPI\u201d"]},{"entry":[{},"DATA_VALUE := instruction"]},{"entry":[{},"EMPTY := 0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0018","list-style":"none"},"li":{"@attributes":{"id":"ul0018-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0019","list-style":"none"},"li":{"@attributes":{"id":"ul0019-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0020","list-style":"none"},"li":"5.3.7.3. If node is a comment, do the following:\n            \n            "}}}}}},{"@attributes":{"id":"p-0048","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ID := docId"]},{"entry":[{},"SEQ := sequence"]},{"entry":[{},"ANCESTORS := ancestors"]},{"entry":[{},"IMMEDIATE_PARENT := parent"]},{"entry":[{},"DATA_NAME := null"]},{"entry":[{},"DATA_TYPE := \u201ccomment\u201d"]},{"entry":[{},"DATA_VALUE := commentData"]},{"entry":[{},"EMPTY := 0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0022","list-style":"none"},"li":{"@attributes":{"id":"ul0022-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0023","list-style":"none"},"li":{"@attributes":{"id":"ul0023-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0024","list-style":"none"},"li":"5.3.7.4. If node is a pcdata text type, do the following:\n            \n            "}}}}}},{"@attributes":{"id":"p-0049","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ID := docId"]},{"entry":[{},"SEQ := sequence"]},{"entry":[{},"ANCESTORS := ancestors"]},{"entry":[{},"IMMEDIATE_PARENT := parent"]},{"entry":[{},"DATA_NAME := \u201cpcdata[\u201c + textCount + \u201d]\u201d"]},{"entry":[{},"DATA_TYPE := \u201ctext\u201d"]},{"entry":[{},"DATA_VALUE := textData"]},{"entry":[{},"EMPTY := 0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0026","list-style":"none"},"li":{"@attributes":{"id":"ul0026-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0027","list-style":"none"},"li":{"@attributes":{"id":"ul0027-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0028","list-style":"none"},"li":["5.3.7.5. If node is a cdata text type, do the following:","5.3.7.5.1. Get the text associated with the node and assign it to a variable called cdataTextData.\n            \n            ","5.3.7.6. Create a new row of data with the following column assignments:"]}}}}}},{"@attributes":{"id":"p-0050","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ID := docId"]},{"entry":[{},"SEQ := sequence"]},{"entry":[{},"ANCESTORS := ancestors"]},{"entry":[{},"IMMEDIATE_PARENT := parent"]},{"entry":[{},"DATA_NAME := \u201ccdata[\u201c + cdataCount + \u201d]\u201d"]},{"entry":[{},"DATA_TYPE := \u201ctext\u201d"]},{"entry":[{},"DATA_VALUE := cdataTextData"]},{"entry":[{},"EMPTY := 0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0030","list-style":"none"},"li":[{"@attributes":{"id":"ul0030-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0031","list-style":"none"},"li":{"@attributes":{"id":"ul0031-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0032","list-style":"none"},"li":["5.3.7.7. If node is an XML element, do the following:","5.3.7.7.1. Get the name of node and assign it to a variable called elemName.\n            \n            "]}}}},"6. Process the epilog information, if any.\n    \n    "]}},{"@attributes":{"id":"p-0051","num":"0116"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ID := docId"]},{"entry":[{},"SEQ := sequence"]},{"entry":[{},"ANCESTORS := docName"]},{"entry":[{},"IMMEDIATE_PARENT := \u201cepilog\u201d"]},{"entry":[{},"DATA_NAME := target"]},{"entry":[{},"DATA_TYPE := \u201cPI\u201d"]},{"entry":[{},"DATA_VALUE := instruction"]},{"entry":[{},"EMPTY := 0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0037","list-style":"none"},"li":{"@attributes":{"id":"ul0037-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0038","list-style":"none"},"li":[{"@attributes":{"id":"ul0038-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0039","list-style":"none"},"li":"6.2.3. If node is a comment, do the following:\n            \n            "}},"6.3. Create a new row of data with the following column assignments:"]}}}},{"@attributes":{"id":"p-0052","num":"0120"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ID := docId"]},{"entry":[{},"SEQ := sequence"]},{"entry":[{},"ANCESTORS := docName"]},{"entry":[{},"IMMEDIATE_PARENT := \u201cepilog\u201d"]},{"entry":[{},"DATA_NAME := null"]},{"entry":[{},"DATA_TYPE := \u201ccomment\u201d"]},{"entry":[{},"DATA_VALUE := commentData"]},{"entry":[{},"EMPTY := 0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"As mentioned, the mechanism for document retrieval may be performed with a single linear SQL query to obtain all of the information for a particular document from the database. Since all of the data items are in order, an in-memory XML tree can easily be reconstructed by interrogating each data row and creating the appropriate object that corresponds to the data row.","The pseudo-code below is an example of such a retrieval algorithm. As will the storage algorithm, an appropriate DOM is used for creating the in-memory XML tree.\n\n",{"@attributes":{"id":"p-0055","num":"0124"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"select * from XML_DATA_TABLE"]},{"entry":[{},"where ID = 1"]},{"entry":[{},"order by SEQ"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The above query assumes that the table XML_DATA_TABLE has been named and that an XML document with an ID of 1 is the subject of the search. Note that we order by the SEQ column to ensure that the data appears in the proper order.\n\n","Elements with no data: In all of the examples presented above, the XML document components stored in the database all contained some piece of associated data. This makes sense since XML is a data-centric language. In some rare cases, however, it is sometimes desirable to store an element with no data associated with it. Such an example is an empty element that contains no attributes. In such a case, the mere existence of the element in the markup has some meaning and implication in the associated document. In such a case, one could modify the above algorithm to allow for the storage of elements with no data contained in them by doing the following:\n\n","Minimizing the ancestor specification: an examination of the data in the sample table (FIG. ), illustrates that the reference to \u201ccustomer\u201d appears at the beginning of every data item in the ANCESTOR column. The reason is that this is the name of the one and only document element of the XML document. Since this information is at the document level, it could be non-redundantly stored in a parent table (such as the one mentioned in the ID column).","Doctype declaration storage and other document level information: since the document type declaration is also document level data, it may also be stored in a parent table. Since the document type declaration does not contain specific document instance data, it is not important within the context of this invention and can simply be stored as a single contiguous text stream in the parent table.","It will be understood that changes may be made in the above construction and in the foregoing sequences of operation without departing from the scope of the invention. It is accordingly intended that all matter contained in the above description or shown in the accompanying drawings be interpreted as illustrative rather than in a limiting sense.","It is also to be understood that the following claims are intended to cover all of the generic and specific features of the invention as described herein, and all statements of the scope of the invention which, as a matter of language, might be said to fall there between."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":["The invention will be more clearly understood by reference to the following detailed description of an exemplary embodiment in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIGS. 5 and 5A","FIG. 3"]}]},"DETDESC":[{},{}]}
