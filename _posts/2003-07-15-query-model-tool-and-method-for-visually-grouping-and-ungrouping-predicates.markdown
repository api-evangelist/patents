---
title: Query model tool and method for visually grouping and ungrouping predicates
abstract: A user-friendly query modeling tool and method, for representing, creating, modifying and modeling a query language statement for use in retrieving data from a database. In accordance with the present invention, the tool includes a user interface for receiving or building and manipulating a query, a query model definition for use in populating instances of one or more query models, and a model content provider for receiving query elements from the user interface and providing them to the query model, and conversely, for retrieving query elements from the query model and providing them to the user interface. The user interface enables the user to easily group and ungroup query elements by providing a visual tool for selecting query elements to be grouped and ungrouped.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08458164&OS=08458164&RS=08458164
owner: International Business Machines Corporation
number: 08458164
owner_city: Armonk
owner_country: US
publication_date: 20030715
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The present application is related to the following patent applications which are commonly assigned and filed on the same day, Jul. 15, 2003: application Ser. No. 10\/620,538, entitled \u201cModel Content Provider With Reusable Components for Supporting a Plurality of GUI API's\u201d; application Ser. No. 10\/620,633, entitled \u201cQuery Modeling Tool Having Dynamically Adaptive Interface\u201d; and application Ser. No. 10\/620,856, entitled \u201cA Method and Structure for Representing Complex Query Elements in a Modelling Tool.\u201d","This invention relates in general to database management systems performed by computers, and in particular, an interactive tool and method for graphically representing, creating, modifying and modeling structured language queries.","Databases are computerized information storage and retrieval systems. A Relational Database Management System (RDBMS) is a database management system (DBMS) which uses relational techniques for storing and retrieving data. Relational databases are organized into tables which consist of rows and columns of data. The rows are formally called tuples or records. A database will typically have many tables and each table will typically have multiple tuples and multiple columns. The tables are typically stored on direct access storage devices (DASD), such as magnetic or optical disk drives for semi-permanent storage. Data stored in a database is selectively retrieved using a database query.","The data from a relational database is commonly retrieved using a Structured Query language (SQL) interface which is well known in the art. The SQL interface has been adopted as such by both the American Nationals Standard Organization (ANSI) and the International Standards Organization (ISO), and allows users to formulate relational operations on the tables interactively, in batch files, or embedded in host languages such as C, COBOL, etc. Operators are provided in SQL that allow the user to manipulate the data, wherein each operator operates on one or more tables and produces a new table as a result.","Query languages such as SQL require some expertise to write effectively. Since both users and applications heavily rely on query statements for retrieving information, tools have been developed to assist in the creation of query statements. These tools include a user interface for creating the initial query, and a query model for storing the components of the resulting query in a manner that enables their reconstruction. Once completed, the query is forwarded to the database management system for performing selective data access.","Query tools suffer from numerous shortcomings that have highlighted a need for a more useful and user-friendly query building tool. The assistance they provide is limited to basic query syntax, requiring manual input of more complex queries. Further, while existing query tools enable creation and modification of new query statements, they do not generally provide means for populating the interface and underlying model with existing query statements to enable modification of those statements.","Other shortcomings exist in the query models themselves. For example, existing models provide limited representation of complex query elements in formats that are not readily understandable to the developer. Moreover, they do not provide much flexibility for reconstructing the query and its subelements. In addition, they are often dependent upon the format of a particular user-interface and do not lend themselves well to use by graphical user interfaces of different formats.","In response to the shortcomings of prior query generating tools, the present invention is directed to a user-friendly interactive system and method for representing, creating, modifying and modeling a query language statement for use in retrieving data from a database. According to the system and method of the present invention, a tool is provided that includes an interactive graphical user interface for inputting, creating, and modifying database query statements. The tool further provides an application interface for enabling receipt and manipulation of existing query statements. A modeling schema is defined for storing the query statement elements. The modeling schema provides a high granularity, meaningful representation of complex query elements reflective of the query syntax. As one aspect of the invention, the modeling schema reflects multiple dialects of the query language by representing element types and subtypes from all dialects considered in creating the schema. In a further aspect of the invention, the granularity of the modeling schema enables reconstruction of the query statement or any element thereof with a single call to a node representative of that element. The call returns not only the element represented by the node, but also all elements represented by subnodes of the node.","In one aspect of the invention, queries can be built directly by a user through a user-interface, or by an application through an application programming interface.","In another aspect of the present invention, the interface and model may be populated by newly created query statements, existing query statements, or both.","In a further aspect of the invention, nested search conditions may be created and manipulated through the graphical user interface and the resulting query represented in an understandable manner.","In another aspect of the present invention, the interface is dynamically adaptive to the query element being constructed.","In another aspect of the present invention, any sub-element of a stored query statement may be reconstructed inclusive of all of its child elements.","In a further aspect of the present invention, the query model represents query elements that have historically been difficult to model in a granular and understandable fashion, such as group-by's, predicates, table references, value expressions and iterative and nested elements. In particular, the query model comprises atomic, hierarchical representations of all desired query elements, taking into account the various dialects of the query language, so that any incoming query can be stored within its schema.","In yet another aspect of the invention, a layer comprising a common set of generalized classes is provided between the user interface and the query model for use in retrieving data from the query model and populating user interfaces of different formats.","The present invention will now be described with reference to a specific embodiment. However, it will be understood that various modifications and equivalent substitutions may occur to an implementer of the tool described without parting from the spirit and scope of the invention. Accordingly, the invention is not intended to be limited in any manner by the specific embodiment, and each element described is intended to encompass all reasonable equivalents thereof.","I. System Architecture",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 1","b":["10","12","11","10","11","15","10","16","18","16","10","15","15","11","14","16","10","18","12","16"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 2","FIG. 1"],"b":["14","20","22","24","28","26"]},"The user interface  may be incorporated into an application, thereby enhancing the application interface with query building capabilities. Alternatively, the interface may be part of a separate query building tool.","The application interface  is coupled to a parser , as represented by arrow . Parser  receives the query statement and decomposes it into subelements or model elements (objects) based on the parsing rules. The parsing rules include syntactic rules and semantic rules. The syntactic rules break down the query into syntactic elements that form the basis for creating a query model representation. The semantic rules enable the parser to create and relate the model objects according to the model definition. These semantic rules will be described in further detail subsequently. The parsed statement is then forwarded to a memory-based query model  for storage as represented by arrow . The parser  may also forward the model elements to the user interface . Consequently, queries received through API  may be modified via user interface .","Interface  also communicates with query model  via GUI model infrastructure , as represented by arrows  and . Interface  is designed to be consistent with the query model definition. Accordingly, when a query is created using interface , the interface creates and relates model elements that conform to the query model definition. The queries may be used to populate the model directly as represented by connection  without further parsing.","The user interface  may also include a query input allowing the user the option of typing in a query statement. Such queries are first sent through the parser  so that the model elements and relationships may be created in the same manner as queries received over API . In addition, the user interface of the present invention includes an expression builder which allows a user to type in complex sub-expressions. These sub-expressions are similarly passed to the parser over connection  prior to being stored in the query model .","II. User Interface",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIGS. 3A and 3B"},"SELECT column_list","FROM sourcetable_list","optional WHERE search_condition","optional GROUP BY columname_list HAVING search_condition","optional ORDER BY columname_list","Although the interface of  are illustrated with reference to the SQL syntax, it will be understood that the invention is not limited to queries written in SQL, but can be applied generally to any query language.","The interface portion of the query building tool may be implemented using any known interface generating tool or programming language such as, for example, Visual Basic or Java.","As illustrated in , the query building tool of the present invention provides an interface for building a query by providing a set of display areas for specifying query elements. In a first OUTLINE region , elements of a query statement are represented in an outline format as shown. A general header is entitled \u201cStatement Properties\u201d. Under this heading is a category entitled \u201cSELECT statement\u201d, and all supported elements of a SELECT clause are listed as its subcategories, e.g., \u201cFROM\u201d, \u201cWHERE\u201d, \u201cGROUP BY\u201d, \u201cHAVING\u201d and \u201cORDER BY\u201d. The user begins construction of a SELECT statement by opening the \u201cSelect statement\u201d folder to display the subcategories. He then proceeds to select one of the displayed subcategories, e.g., by highlighting his selection with a mouse, and specifying the parameters of that subcategory in the input region  and\/or .","Alternatively, the interface may be populated with an existing query statement stored in the underlying query model. This is achieved by each portion of the interface retrieving and displaying the elements of the underlying query model that are appropriate for that portion.","The \u201cDetails\u201d section  enables the user to specify the parameters for his selected subcategory. The format of region  changes for each subcategory selection made in region . For example, if the user selects subcategory \u201cFROM\u201d, the interface makes a call to the underlying database for a list of available source tables, and then displays these as selectable options. The user then selects from the displayed tables, e.g., by highlighting. Similarly, if the user selects the \u201cSELECT\u201d subcategory, the details region  displays the columns of the selected table(s) for further selection by the user. Selection of the \u201cWHERE\u201d subcategory causes the \u201cDetails\u201d section to display a \u201cPredicate\u201d region  and a \u201cSearch Conditions\u201d region  as shown.","The predicate region  allows the user to build one or more predicates by selecting an operator (AND, OR or NOT) using buttons A and B for connecting multiple predicates, a column name , a column operator , and an operator value , e.g. by pull down menu, field select or other comparable means. The resulting predicate is displayed in editing window  and \u201cSearch condition\u201d window , described in more detail subsequently.","As an aspect of the present invention, the format of the value input area  in the predicate region  changes dynamically in response to selection of a column operator . For instance, in  the column operator selected is an equals sign (=). In response to that selection the screen definition is modified to display a single value pull down menu in region . The pull-down menu lists all possible values for the column name  \u201cJOB\u201d specified by the user.","Another example of the dynamic aspect of the predicate region  is shown in . Here, the user has selected a column name  of \u201cHIREDATE\u201d from a list of possible options, and the \u201cBETWEEN\u201d column operator . In response, minimum and maximum value input regions are displayed in input area . The selectable minimum and maximum values represent all possible values of column \u201cHIREDATE\u201d .","When all predicate options have been specified in field , the user confirms his selection, e.g. by clicking his mouse on button . Confirmation causes the query model to be populated or updated with the new predicate as previously described. It also causes the new predicate to appear in search condition display area  and in \u201cSQL code\u201d editing window .","In the example of , three user-specified search conditions are displayed in region : \u201cEMPLOYEE.WORKDEPT IN (\u2018E\u2019, \u2018E\u2019, \u2018E\u2019)\u2019\u201d; \u201cEMPLOYEE.JOB=\u2018MANAGER\u2019\u201d; and \u201cEMPLOYEE.JOB=\u2018SALESREP\u2019\u201d. They are connected by operators \u201cAND\u201d and \u201cOR\u201d, respectively.","Another aspect of the present invention is the ability to group or nest predicates in region  to control the order in which they are evaluated. In , the user has elected to group \u201cEMPLOYEE.JOB=\u2018MANAGER\u2019\u201d; and \u201cEMPLOYEE.JOB=\u2018SALESREP\u2019\u201d, as indicated by the parenthesis around these predicates and their indentation with respect to the \u201cEMPLOYEE.WORKDEPT IN (\u2018E\u2019, \u2018E\u2019, \u2018E\u2019)\u201d predicate. Grouping is effected by highlighting the desired predicates in window  and then clicking on \u201c(..)\u201d button . The action of clicking on button  again causes the parenthesis and indentation, or similar indicia of grouping, to appear in window . It also causes the query model to be updated with the change to the displayed search condition. Grouped predicates may also be ungrouped by highlighting a set of grouped predicates and clicking on \u201cRemove\u201d button .","The grouping function described above is illustrated by flow diagram D. In a first step , the user select rows in search condition area  such that first and last rows are at same level of indentation. Such selection causes the grouping button  to be enabled, as shown in step , so that the user may activate it (step ). Activation causes the query model  to be updated to reflect new grouping of conditions, as represented in step . The GUI-Model Infrastructure  is notified of query model change in step  and in response, GUI-Model Infrastructure  updates User I\/F  as shown in step .","The Where Clause user interface design proved a challenging undertaking. The current design provides a tremendous amount of functionality masked by a simple and intuitive user interface. Many query builders do not support the full syntax of the Where Clause in the GUI due to the complex nature of this clause, and the inventors are not aware of any that provide the functionality of the present invention.","A Where Clause consists of a search condition that limits the number of rows the database will return after executing a SQL query. A search condition, which may be nested, consists of a set of predicates combined with logical operators. Each predicate, which may be negated, specifies a condition that may be true, false or unknown. There are many types of predicates that may be expressed using a different syntax for each.","The Where Clause user interface design of the present invention allows the user to build the search condition one predicate at a time. It allows for easy creation, insertion, nesting, negation and removal of predicates. It supports most of the different forms of predicates available. It allows the user to insert each predicate anywhere in the search condition.","To make the search condition more readable and understandable, the predicates are indented to show the level of nesting. This flexible design is not only applicable to a Where Clause in SQL, but it may be applied anywhere one has a need to build a potentially nested object (search condition in this case) which is made up of other well-formed, complex objects (predicates in this case).","Moving on, the \u201cSQL code\u201d editing window  displays the query substatements as they are built and confirmed. Confirmation occurs, e.g., by clicking on \u201c>\u201d button  with a mouse, and causes the underlying query model to be populated or updated with the new\/updated query substatement as previously described.","Editing window  allows the user to directly modify the displayed query statement, and on completion, to update the query model. Updating is effected by clicking on \u201cCheck\u201d button  or similar means. The user also has the option of undoing his edits by clicking on \u201cUndo Edit\u201d button , or running the displayed query by clicking on \u201cRun\u201d button .",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 3C","b":["81","33","33","82","35","83","84","35","35","85","86"]},"Next, the user presses one of the center buttons to either insert or replace the predicate in the Predicate area  into the Search condition area as follows.","The insert buttons, \u201cAND>\u201d A and \u201cOR>\u201d B, are enabled (block ) if the predicate in the Predicate area  is complete and any line is selected in the Search condition area . Pressing these buttons (block ) adds two lines to the Search condition area  after the selected line. The first is either the logical operator AND or OR, respectively. The second line added to the Search condition area is the predicate in the Predicate area .","The replace button, \u201c>\u201d , is enabled (not shown) anytime a predicate is selected in the Search condition area  or the Search condition area  is blank. As represented generally in block , if pressed when a predicate is selected in the Search condition area  and the predicate in the Predicate area  is complete, the selected predicate in the Search condition area  is replaced with the predicate in the Predicate area . If button \u201c>\u201d  is pressed when the Search condition area  is blank and the predicate in the Predicate area  is complete, the predicate in the Predicate area  is added as the first predicate in the Search condition area . If button \u201c>\u201d  is pressed when the Search condition area  is blank and the predicate in the Predicate area  is incomplete, a message will appear indicating that the user must first complete the predicate.","Pressing the replace button \u201c>\u201d also causes the query model to be updated, as further indicated by block .","As noted above, many more user interactions can occur on this panel such as nesting, negating and removing predicates.","III. Parsing a Query","What is described next is a program algorithm for resolving column references and value expression datatypes in a parsed query language statement, an SQL statement for example. The process involves three phases: syntactic parsing, resolution of table and column references, and resolution of all other value expressions. Each phase operates on a model of the syntactic structure of the QUERY LANGUAGE statement.","A query parser can handle the syntactic aspect of parsing a query language string by using information contained in the input query string alone. However, the parser cannot handle some of the more semantic aspects of parsing without extra information that is not contained in the query language statement itself. These semantic aspects include associating column references that are contained in the query language with the tables to which the columns belong, and assigning a datatype to each value expression contained in the query language. Value expressions include column references, literal values such as 2 or \u2018Smith\u2019, numeric expressions such AGE +10, string expressions such as LASTNAME CONCAT \u2018,\u2019 CONCAT FIRSTNAME, and the like.","The three phases of the process are defined as follows.","Phase 1","In the first phase, the input QUERY LANGUAGE string is syntactically parsed into an internal model form. As will be described subsequently, the model used is a tree-structured representation of the syntactic elements of the QUERY LANGUAGE statement. For example, the following QUERY LANGUAGE statement,\n\n",{"@attributes":{"id":"p-0067","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SQLQueryStatement"]},{"entry":[{},"\u2003\u2003\u2002SQLSelectClause"]},{"entry":[{},"\u2003\u2003\u2002\u2003\u2003\u2002SQLExpressionColumn (name: NAME)"]},{"entry":[{},"\u2003\u2003\u2002\u2003\u2003\u2002SQLExpressionCombined (operator: *)"]},{"entry":[{},"\u2003\u2003\u2002\u2003\u2003\u2002\u2003\u2003\u2002SQLExpressionColumn (name: SALARY)"]},{"entry":[{},"\u2003\u2003\u2002\u2003\u2003\u2002\u2003\u2003\u2002SQLExpressionLiteral (value: .05)"]},{"entry":[{},"\u2003\u2003\u2002SQLFromClause"]},{"entry":[{},"\u2003\u2003\u2002\u2003\u2003\u2002SQLTableReference (name: EMPLOYEES)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"At the same time that the parser is producing this tree-structured model, it builds a simple list that contains references (or pointers) to the value expressions that it encounters. For the example after the SQL above is parsed, the value expression list contains the following elements.\n\n","In the second phase of the process, the value expressions that are of type SQLExpressionTable and SQLExpressionColumn in the expression list are semantically resolved by associating them with table (or view) and column entities in a provided information catalog. (In a typical scenario this catalog is the relational database in which the SQL statement is intended to be executed.) First, expressions of type SQLExpressionTable are matched with table entities in the catalog based on attributes of the SQLExpressionTable, such as table name and schema name (if present). Next, information about the columns belonging to each table are obtained from the catalog. This information includes not only the column names, but their datatypes as well (such as INTEGER and VARCHAR). Then, using the column name attribute of the SQLExpressionColumn objects, the SQLExpressionColumns are associated with their corresponding table and column entities in the catalog. This enables datatypes to be assigned to each SQLExpressionColumn. For example, in the query above, after phase 2 the column expression objects in the model (and in the expression list) have been updated to become:","SQLExpressionColumn (name: NAME, table: EMPLOYEES, datatype: VARCHAR(20))","SQLExpressionColumn (name: SALARY, table: EMPLOYEES, datatype: DECIMAL(7, 2))","Phase 3","In the third phase, all remaining value expressions in the expression list are resolved as to their datatype. The technique used to do this varies depending on the kind of value expression and on the type of query structure that contains it. Here are illustrations of the processing required in this phase for several types of value expression.","SQLExpressionLiteral: the datatype is determined by inspecting the value directly. For example a simple numeric value becomes INTEGER. A decimal value gets the datatype DECIMAL(precision, scale) where the precision and scale are determined by length of the decimal value and the location of the decimal point. A quoted string value gets datatype VARCHAR(length) where the length is the length of the value inside the quotes.","SQLExpressionCombined: the datatype is determined by recursively examining the left and right side components of the expression object to find a value expression whose datatype has already been resolved, and using that datatype for the datatype of the SQLExpressionCombined object as a whole. For example, if the SQLExpressionCombined encompasses \u201cSALARY*0.05\u201d, the datatype of the expression can be determined by looking at the left side, which contains a SQLExpressionColumn object (SALARY) whose datatype (DECIMAL) is known. The semantic check that the two sides of a combined expression are \u201ccombinable\u201d datatypes can be done at the same time.","SQLExpressionFunction: The method for determining the datatype of a SQL function object varies depending on the particular function involved. For some functions, the datatype is simply the return datatype defined for the function (such as the return type INTEGER for the cast function INTEGER( )). For other functions, the datatype of the function depends on the datatype of its arguments. (For example, the function MAX takes on the datatype of its argument. The datatype of MAX(SALARY) is DECIMAL, while the datatype of MAX(AGE) would be INTEGER.)","Resolving the datatypes of all the value expressions may take several passes through the value expression list. For the query given above, the expression list at the end of phase 3 might look like this:","SQLExpressionColumn (name: NAME, table: EMPLOYEES, datatype: VARCHAR(20))","SQLExpressionCombined (operator: *, datatype DECIMAL(7, 2))","SQLExpressionColumn (name: SALARY, table: EMPLOYEES, datatype: DECIMAL(7, 2))","SQLExpressionLiteral (value: 0.05, datatype DECIMAL(2, 2))","SQLExpressionTable (name: EMPLOYEES)","IV. Model Content Provider","The GUI Model Infrastructure (GMI) of the present invention is shown in . It is preferably a software architecture represented by functional block  and resides between the user interface  and the query model .","More specifically, user interface  is shown to include a plurality of GUI API's, GUI API and GUI API. GUI Applications A, B, C and D run on the user interface and are written to a specific GUI API. For example, as shown, GUI applications A and B are written to run on GUI API. Similarly, GUI applications C and D are written to a different GUI API.","The GMI  includes Model Content Providers (MCP) , which translate Query Model (QM)  information into collections of information that are independent of structure type. The MCP interfaces with Content Viewers  (CV's , , ) which take the MCP collections and manipulate the collections for specific structures such as tables, trees, lists, etc. The CV's  are a hierarchical set of classes, from the more abstract structures  at the top, to the GUI-specific structures ,  at the bottom.","The Non GUI API specific components of the GMI  reside to the right of the dashed line and are created w\/o regard to which GUI API will be used. The beauty of this architecture is that the non-specific CV's  are reusable, API-independent components. Thus, they provide scalability to diverse, subsequently added GUI API's.","In contrast, the GUI-specific CV's ,  to the left are written specifically to the GUI API they communicate with. In the present , CV  comprises wrapper code for API , and CV  comprises wrapper code for API . Each GUI Application A, B, C and D interfaces with a GUI-specific CV , , informing the CVs about user actions. This approach enables any new GUI application using the same GUI API to reuse the same wrapper code. A new GUI application using a different GUI API can write its own wrapper code and still reuse the common, more abstract, GUI API independent Content Viewers .","Stepping back for a moment, the content viewers  of the present invention are defined by a hierarchical set of classes. Previously, content viewers were designed for a single GUI API as might be represented by blocks  and .","Due to the lower levels of this hierarchy being GUI API specific, and the higher levels of the hierarchy being non GUI specific, the designers were able to clearly divide the Content Viewers  into reusable and non reusable components able to support multiple API's. Lower level GUI API specific classes were rewritten to enable reuse of the higher levels of the Content Viewer classes as well as the tightly coupled Model Content Providers.","The Model Content Provider  of the present invention performs several functions. It creates objects, called item providers, that are instances of the model elements representing the current SQL Statement. These objects are created dynamically as the user builds the statement. The query model relationships (e.g. hierarchy, dependencies, etc.) that the Query Model  contains are also contained in the item provider objects. Thus, for a specific statement, its \u201cmodel\u201d is actually a set of item provider objects whose relationships are dictated by the overall Query Model .","MCP  obtains information from the Query Model  and translates this information into data for use by Content Viewers. The higher layers of the Content Viewers, block , passes on this data to lower layer viewers (blocks  or ). It receives information from the GUI applications via the Content Viewers, independent of the specific structure (e.g. table, tree, list, etc) of the data.","In addition, MCP  is able to discern if the information it gets from the viewers is an addition, a modification, or a deletion of any element in the current model. In the case of an addition, the MCP is able to discern if additional model elements need to be created. It has a \u201cfactory\u201d class that takes care of creating additional item providers corresponding to these new model elements. For example, the GUI application gave a request to add a table to the query. One of the content viewers passes this information to the MCP . The MCP  is aware that it will need to get the \u201cchildren\u201d of this model element, so it calls on its \u201cfactory\u201d class to create the children of this particular model element, a table, which happen to be the columns of the table. Once these elements are created and properly linked in the Query Model , the MCP instructs the Content Viewers to refresh the information that they have. Only the Content Viewers affected by the addition of the table, will be refreshed. Once refreshed, the Content Viewers will inform the GUI application to update what is displayed to the user.","Similarly, in the case of a deletion, when a model element that has children is deleted, the Content Viewers send the request to delete this element to the MCP . The MCP  takes care of determining where the child elements are linked to in the entire query model and performs the removal of these objects from the Query Model . Again, when the deletions are complete, the MCP  informs the Content Viewers  to refresh themselves.","The MCP provides both data and image information to the viewers. Special classes, called label provider classes contain text and image information and are tied to specific model elements of the query. This allows for easy translation of labels or revision of icons.","To save an existing query, the Query Assist tool of the present invention provides a set of hierarchical models for storing the query elements, as will be described subsequently.","V. The Query Model","The query model of the present invention is designed with the actual syntax of the query language in mind, mirroring each element of the query statement and its relationships to the other elements. Since a number of dialects of a query language such as SQL may be in use, the model is optionally designed to reflect syntax common for multiple dialects. Further, it provides a more detailed representation of query components than is currently available. To this end, detailed representations of various query components are provided.",{"@attributes":{"id":"p-0096","num":"0101"},"figref":"FIG. 5"},"The present invention provides both a modeling methodology and examples of actual models produced using the described methodology. Once a query element has been selected for modeling, the steps outlined in  are followed to create a tree structure representative of that element. In a first step , at least one type associated with the query element is identified. Next, a \u201cparent\u201d node representing the element is defined in step , and in step , a \u201cchild\u201d node is defined for each identified type. Thereafter, each child node is examined in step  to determine if it has any subtypes, and if so, a child node of that node is defined for each determined subtype in step . This process may continue for as many levels of the tree structure that the modeler desires. By proceeding until no further subtypes remain, as represented by the loop including steps  and  and decision diamond , a highly granular query model is obtained.",{"@attributes":{"id":"p-0098","num":"0103"},"figref":"FIGS. 6A-10"},"A. Combined Structures to Represent Query Elements","A first challenge to the modeler is to completely and accurately depict the iterative and nesting capabilities of the query language. In particular, a query statement may contain a complex query expression that includes an atomic query element \u201cAQE\u201d, i.e., noniterative and unnested query element. It may further include a combined operator \u201cCO\u201d. The CQE includes right and left subelements related by a combined element operator. These subelements may in turn be either AQE's or CQE's, and furthermore, the structure of a CQE is shown below:\n\nCQE=((LQE CO RQE)\n\nwhere LQE is the left query element, RQE is the right query element, CO is a combined operator such as AND\/OR, and where LQE and RQE can either be atomic or combined query elements.\n","Previous models have often been simplistic and inefficient at representing such expressions, and have therefore been of limited usefulness. This present invention provides a representation that succinctly and accurately reflects the true picture of both the data and underlying structure of the query language.","Accordingly, the present invention provides a \u201cCombined Structure\u201d model as shown in  to represent complex query. The structure includes an abstract \u201csuperclass\u201d shown as parent node  and first and second classes ,  to represent, respectively, the atomic and combined query elements.","As an example, consider the following query:",{"@attributes":{"id":"p-0103","num":"0108"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"SELECT DEPARTMENT.DEPTNAME, EMPLOYEE.LASTNAME"},{"entry":"\u2003\u2003\u2002FROM DEPARTMENT, EMPLOYEE"},{"entry":"\u2003\u2003\u2002WHERE"},{"entry":"\u2003\u2003\u2002\u2003\u2003\u2002DEPARTMENT.DEPTNO IN (\u2018D01\u2019, \u2018D11\u2019, \u2018D21\u2019) AND"},{"entry":"\u2003\u2003\u2002\u2003\u2003\u2002(EMPLOYEE.SALARY > 50000 OR"},{"entry":"\u2003\u2003\u2002\u2003\u2003\u2002EMPLOYEE.JOB = \u2018MANAGER\u2019)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"We will use the above example to map a query into an instance of the model structure shown in . The statement \u201cWHERE DEPARTMENT.DEPTNO IN (\u2018D\u2019, \u2018D\u2019, \u2018D\u2019) AND (EMPLOYEE.SALARY>50000 OR EMPLOYEE.JOB=\u2018MANAGER\u2019,\u201d is the query element to be modeled and will be represented by an instance of parent node . The clause \u201cDEPARTMENT.DEPTNO IN (\u2018D\u2019, \u2018D\u2019, D\u2018\u2019) is an atomic query element or subclass (AQE) and is represented by an instance of node . The clause \u201c(EMPLOYEE.SALARY>50000 OR EMPLOYEE.JOB=\u2018MANAGER\u2019)\u201d is an example of a combined query element or subclass (CQE) within that statement and is represented by an instance of node . The atomic and combined query elements are related by a combined operator (CO), in this instance \u201cAND\u201d. Thus, the query element to be","modeled may be represented as:",{"@attributes":{"id":"p-0105","num":"0000"},"ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":{"@attributes":{"id":"ul0005-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":["WHERE CQE\n\nCQEhas the following internal structure:\n","AQECOCQE\n\nAs previously noted, the combined query element's subelements (LQE and RQE, above) may in turn be either AQE's or CQE's. In the present example, the subelements of CQEare \u201cEMPLOYEE.SALARY>50000\u201d and \u201cEMPLOYEE.JOB=\u2018MANAGER\u2019 which can be represented as AQEand AQE, respectively, and are related by another combined operator \u201cOR\u201d. Accordingly, the present example may further be represented as:\n"]}}}},"WHERE AQECO(AQECOAQE)","The representation of the example query above is depicted in .","According to the present invention, the generalized combined structure of  may be used at any level of the model's hierarchy to represent the existence of an atomic subclass and a combined query related by a query operator element. The iterative nature of this structure thus provides a simple and intuitive representation of what in the past has been considered a very complex query structure.","B. Representing Predicates",{"@attributes":{"id":"p-0108","num":"0114"},"figref":"FIG. 7"},"C. Representing Table References",{"@attributes":{"id":"p-0109","num":"0115"},"figref":"FIG. 8"},"D. Representing Value Expressions",{"@attributes":{"id":"p-0110","num":"0116"},"figref":"FIG. 9"},"E. Representing Group-By",{"@attributes":{"id":"p-0111","num":"0117"},"figref":"FIG. 10"},"F. Generating a Query Language Element from the Query Model Inclusive of its Children","An advantage of the top-down modeling approach of the present invention is the ability to recreate any query language element such as a clause or substatement of the query downward, not just at the root level. That is, a call can be made to a particular subnode, and as a result of the call the subnode and its children return a reconstructed query language element representing the value of the subnode and its children.","As an example, consider the following select statement:\n\nSELECT NAME, DEPT, SALARY+BONUS FROM EMPLOYEES\n\nA call may be made to the subnode of the model that represents the third result column of the select clause of the query and as a result, the \u201cSALARY+BONUS\u201d query language element would be reconstructed and returned. The portion of the model instance that represents the third result column is shown in . A call to the model element or node representing SQLResult returns the query statement for that element of the statement, i.e., the query element and all of its children.\n\nG. Maintaining Model Independence Within a Larger Collection of Models\n","Applications may involve multiple models which may have a domain different from the one described above. This can be a problem when there are dependencies between models so that even minor changes to one model can affect the other models and require updating to the latter. More specifically, in a typical code generating environment, when models used to generate code have dependencies between them, then modifying one model requires code to be regenerated for all the related models.","The present invention helps to overcome this problem by providing a greater degree of independence among models. Within the code-generating environment, dependencies between models are removed such that changes to one model do not force the regeneration of code by other models.","This is achieved by adding proxy objects to a model to replace references to other models, and then reestablishing the references amongst the models after the code generation step.","An example is illustrated in . Model  needs to reference an element of model  (\u201cClassC\u201d). Instead of creating a reference directly from Model  to ClassC in Model , an extra element Class_C is added to Model  that tales the place of ClassC. Therefore all references are contained within Model . After code is generated from the models, the generated code is modified to connect element Class_C and ClassC. This is shown with the dotted line in .","Although the present invention has been described with reference to a specific embodiment, various substitutions and modifications may occur to the developer in implementing the invention without departing from its spirit and scope. Accordingly, the invention is not to be limited by the specification set forth, but is to be accorded its broadest interpretation as claimed, below."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIGS. 3A and 3B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIGS. 3C and 3D","FIGS. 3A and 3B"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIGS. 6A and 6B"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIGS. 7 to 10","FIGS. 6A and 6B"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
