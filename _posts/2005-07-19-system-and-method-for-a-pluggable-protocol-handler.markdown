---
title: System and method for a pluggable protocol handler
abstract: Embodiments of the invention are generally directed to a system and method for pluggable protocol handlers to route message traffic between communication partners. In an embodiment, a protocol independent connection manager receives a message from a communication partner over a network connection. The connection manager calls a dynamically loadable protocol handler to process and route the received message to a subsequent communication partner. In one embodiment, the network connection is a multiplexed network connection.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07966412&OS=07966412&RS=07966412
owner: SAP AG
number: 07966412
owner_city: Walldorf
owner_country: DE
publication_date: 20050719
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Overview","Pluggable Protocol Handlers","Additional Comments"],"p":["The field of invention pertains generally to the software arts; and, more specifically to a system and method for a pluggable protocol handler.","Even though standards-based application software (e.g., Java\u2122 based application software) has the potential to offer true competition at the software supplier level, legacy proprietary software has proven reliability, functionality and integration into customer information systems (IS) infrastructures. Customers are therefore placing operational dependency on standards-based software technologies with caution. Not surprisingly, present day application software servers tend to include instances of both standard and proprietary software suites, and, often, \u201cproblems\u201d emerge in the operation of the newer standards-based software, or interoperation and integration of the same with legacy software applications.","The prior art application server  depicted in  provides a good example.  shows a prior art application server  having both an Advanced Business Application Programming\u2122 (ABAP) legacy\/proprietary software suite  and a Java 2 Enterprise Edition\u2122 (J2EE) standards-based software suite . A connection manager  routes requests (e.g., HyperText Transfer Protocol (HTTP) requests and HTTP with secure socket layer (HTTPS) requests) associated with \u201csessions\u201d between server  and numerous clients (not shown in ) conducted over a network . A \u201csession\u201d can be viewed as the back and forth communication over a network  between computing systems (e.g., a particular client and the server).","The back and forth communication typically involves a client (\u201cclient\u201d) sending a server  (\u201cserver\u201d) a \u201crequest\u201d that the server  interprets into some action to be performed by the server . The server  then performs the action and if appropriate returns a \u201cresponse\u201d to the client (e.g., a result of the action). Often, a session will involve multiple, perhaps many, requests and responses. A single session through its multiple requests may invoke different application software programs.","For each client request that is received by the application server's connection manager , the connection manager  decides to which software suite ,  the request is to be forwarded. If the request is to be forwarded to the proprietary software suite , notification of the request is sent to a proprietary dispatcher , and, the request itself is forwarded into a request\/response shared memory . The proprietary dispatcher  acts as a load balancer that decides which one of multiple proprietary worker nodes through are to actually handle the request.","A worker node is a focal point for the performance of work. In the context of an application server that responds to client-server session requests, a worker node is a focal point for executing application software and\/or issuing application software code for downloading to the client. The term \u201cworking process\u201d generally means an operating system (OS) process that is used for the performance of work and is also understood to be a type of worker node. For convenience, the term \u201cworker node\u201d is used throughout the present discussion.","When the dispatcher  identifies a particular proprietary worker node for handling the aforementioned request, the request is transferred from the request\/response shared memory  to the identified worker node. The identified worker node processes the request and writes the response to the request into the request\/response shared memory . The response is then transferred from the request\/response shared memory  to the connection manager . The connection manager  sends the response to the client via network .","Note that the request\/response shared memory  is a memory resource that each of worker nodes through has access to (as such, it is a \u201cshared\u201d memory resource). For any request written into the request\/response shared memory  by the connection manager , the same request can be retrieved by any of worker nodes through . Likewise, any of worker nodes through can write a response into the request\/response shared memory  that can later be retrieved by the connection manager . Thus the request\/response shared memory  provides for the efficient transfer of request\/response data between the connection manager  and the multiple proprietary worker nodes through .","If the request is to be forwarded to the standards-based software suite , notification of the request is sent to the dispatcher  that is associated with the standards-based software suite . As observed in , the standards-based software suite  is a Java based software suite (in particular, a J2EE suite) that includes multiple worker nodes through .","A Java Virtual Machine is associated with each worker node for executing the worker node's abstract application software code. For each request, dispatcher  decides which one of the N worker nodes is best able to handle the request (e.g., through a load balancing algorithm). Because no shared memory structure exists within the standards-based software suite  for transferring client session information between the connection manager  and the worker nodes through , separate internal connections have to be established to send both notification of the request and the request itself to the dispatcher  from connection manager  for each worker node. The dispatcher  then forwards each request to its proper worker node.","Various problems exist with respect to the prior art application server  of . For example, the establishment of connections between the connection manager and the J2EE dispatcher to process a client session adds overhead\/inefficiency within the standards-based software suite . For example, establishing connections between the connection manager and the J2EE dispatcher typically include copying data to and from the network stack. In addition, the J2EE dispatcher opens a separate select thread for each connection. Opening a number of separate threads can add overhead to the system because each thread uses resources such as memory. This increased overhead reduces the efficiency and scalability of application server .","Embodiments of the invention are generally directed to a system and method for pluggable protocol handlers to route message traffic between communication partners. In an embodiment, a protocol independent connection manager receives a message from a communication partner over a network connection. In another embodiment messages are received from a communication partner via a connection oriented shared memory region. The connection manager calls a dynamically loadable protocol handler to process and route the received message to a subsequent communication partner. In one embodiment, the network connection is a multiplexed network connection.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2"},"Comparing , first, note that the role of the connection manager  has been enhanced to at least perform dispatching  for the standards-based software suite  (so as to remove the additional connection overhead associated with the prior art system's standards-based software suite dispatching procedures).","Also, the connection manager is protocol independent. A protocol handler can be plugged into the connection manager to support any one of a number of protocols by which a request can be conveyed to the connection manager. For example, handlers for protocols such as the hypertext transfer protocol (HTTP), secure HTTP (HTTPS), the simple mail transfer protocol (SMTP), the network news transfer protocol (NNTP), the TELNET protocol, the P4 protocol of SAP AG, and the Internet Inter-Object Request Broker Protocol (IIOP) may be provided at the connection manager so that it can receive a request conveyed from a client in accordance with any of these protocols. The advantages of pluggable protocol handlers include: easy extendibility of connection managers with additional protocols; and small and independent software components that can be developed, tested, maintained, and replaced independently, e.g., in the case of an error in one protocol handler, only this part needs to be replaced, not the complete program.","In addition, in one embodiment, the role of a shared memory has been expanded to at least include: a) a first shared memory region  that supports request\/response data transfers not only for the proprietary suite  but also the standards-based software suite ; b) a second shared memory region  that stores session objects having \u201clow level\u201d session state information (e.g., information that pertains to a request's substantive response such as the identity of a specific servlet invoked through a particular web page); and, c) a third shared memory region  that stores \u201chigh level\u201d session state information (e.g., information that pertains to the flow management of a request\/response pair within the application server (e.g., the number of outstanding active requests for a session)).","Regarding request notification queues  Q through QM, one queue for each of the worker nodes through has been implemented within the standards-based software suite . In an embodiment, the shared memory structures , ,  and request notification queues  help implement a fast session fail over protection mechanism in which a session that is assigned to a first worker node can be readily transferred to a second worker node upon the failure of the first worker node.","Shared memory is memory whose stored content can be reached by multiple worker nodes. Here, the contents of the shared memory region  can be reached by each of worker nodes in  and . Additionally, the contents of shared memory regions  and  can be reached by each of worker nodes through . In one embodiment, shared memory region  supports shared cache  that can be reached by each of worker nodes through .","Different types of shared memory technologies may be utilized within the application server  and yet still be deemed as being a shared memory structure. For example, shared memory region  may be implemented within a \u201cconnection\u201d oriented shared memory technology while shared memory region  may be implemented with a \u201cshared closure\u201d oriented shared memory technology.","The connection oriented request\/response shared memory region  effectively implements a transport mechanism for request\/response data between the connection manager and the worker nodes. That is, because the connection manager is communicatively coupled to the shared memory, and because the shared memory is accessible to each worker node, the request\/response shared memory \u2014at perhaps its broadest level of abstraction\u2014is a mechanism for transporting request\/response data between the connection manager and the applicable worker node(s) for normal operation of sessions (e.g., no worker node failure) as well as those sessions affected by a worker node crash.","Although the enhancements of the application server  of  have been directed to improving the reliability of a combined ABAP\/J2EE application server, it is believed that architectural features and methodologies described in more detail further below can be more generally applied to various forms of computing systems that manage communicative sessions, whether or not such computing systems contain different types of application software suites, and whether any such application software suites are standards-based or proprietary. Moreover, it is believed that such architectural features and methodologies are generally applicable regardless of any particular type of shared memory technology employed.","In operation, the connection manager  forwards actual request data to the first shared memory region  (request\/response shared memory ) regardless of whether the request is to be processed by one of the proprietary worker nodes  or one of the standards-based worker nodes . Likewise, the connection manager  receives response data for a request from the request\/response shared memory  whether a proprietary worker node or a standards-based worker node generates the response.","With the exception of having to share the request\/response shared memory  with the worker nodes  of the standards-based software suite , the operation of the proprietary software suite  is essentially the same as that described in the background, in one embodiment of the invention. That is, the connection manager  forwards request notifications to the proprietary dispatcher  and forwards the actual requests to the request\/response shared memory . The proprietary dispatcher  then identifies which one of the proprietary worker nodes  is to handle the request. The identified worker node subsequently retrieves the request from the request\/response shared memory , processes the request and writes the response into the request\/response shared memory . The response is then forwarded from the request\/response shared memory  to the connection manager  who forwards the response to the client via network .","In an alternative embodiment, the ABAP dispatcher  is integrated into the connection manager, just as the J2EE dispatcher . Indeed, it is contemplated that a single dispatcher may encompass the functionality of both dispatchers  and . In the case where the dispatcher  is integrated into the connection manager , the connection manager identifies which one of the proprietary worker nodes  is to handle a request and via its integrated dispatcher capabilities, forwards the request to the request\/response shared memory . The identified worker node subsequently retrieves the request from the request\/response shared memory , processes the request and writes the response into the request\/response shared memory . The response is then forwarded from the request\/response shared memory  to the connection manager  who forwards the response to the client via network .",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 3","b":["300","300","310","340","340","310","324","326","320","330","322","332"],"sub":["1","M"]},"In one embodiment, network connections  and  are multiplexed network connections. A \u201cmultiplexed network connection\u201d refers to a network connection in which the messages from more than one client are multiplexed over the same network connection. Since the connections are multiplexed, there is no need to set-up separate network connections for each client, in an embodiment of the invention. This reduces the network connection overhead for connection manager .","Connection manager  receives messages (e.g.,  and ) from one or more clients (clients  and ) on a network connection endpoint (e.g., network connection endpoints  and ). Network connection endpoints - (and also ) are identifiable endpoints for a network connection such as the combination of a network layer address (e.g., an Internet Protocol address) and port number.","In one embodiment, connection manager  is protocol independent. In such an embodiment, connection manager  accesses one or more dynamically pluggable protocol handlers - through, for example, an Application Programming Interface (API) (e.g., APIs -) to process the received messages. The term \u201cdynamically\u201d refers to pluggable protocol handlers that can be loaded (and removed) at runtime.","Pluggable protocol handlers - process the received messages  and  in accordance with the appropriate protocol to determine an appropriate communication partner. Determining an appropriate communication partner for a received message typically includes selecting one of worker nodes through to process the message. Selecting the appropriate worker node can be based on a number of factors including session management information and\/or load distribution schemes. The pluggable protocol handler forwards the received message (e.g., message ) to the selected worker node via, for example, network connections -or connection oriented shared memory.","After processing the message , the worker node may provide a response message . Connection manager  receives message  on network connection endpoint . If a session communication protocol is being used within the server, then connection manager  first processes the session information and then calls an appropriate pluggable communication protocol handler -. The pluggable communication protocol handler - selects the appropriate client (e.g., standards-based protocol client  or propriety protocol client ) and forwards the message to the selected client.","As shown in , connection manager  calls pluggable protocol handlers - to process messages from communication partners that are both external to application server  (e.g., clients -) and internal to application server  (e.g., worker nodes -). For ease of reference, the term \u201cinternal communication partners\u201d refers to entities that are within the same application server (or cluster) as connection manager . Similarly, the term \u201cexternal communication partners\u201d refers to entities that are external to the application server in which connection manger  resides.","The messages sent by (and to) external communication partners (e.g., clients -) are formatted according to either a standards-based protocol or a proprietary protocol. These messages typically have a protocol header and message data. For example, message  includes protocol header  and data . In an embodiment, pluggable communication protocol handlers - determine an appropriate communication partner for a message based, at least in part, on the protocol header (e.g., protocol header ).","An example of a standards-based protocol used in an embodiment of the invention is IIOP.  shows selected portions of one example of an IIOP protocol header . IIOP protocol header  includes protocol magic , Global Inter-ORB Protocol (GIOP) version , flag , message type , and message size . Protocol magic  is a four-byte portion of the message header whose value is the four upper-case characters \u201cGIOP.\u201d GIOP version  is a two-byte element of the message header that specifies the version number of the GIOP protocol being used in the message. Flag  is an eight-bit octet to provide various flags for the message. Message type  specifies a message type for the message (e.g., request, reply, cancel request, locate request, locate reply, close connection, message error, fragment, etc.). Message size  specifies the size of the message that follows the message header.","An example of a proprietary protocol used in an embodiment of the invention is P4.  shows selected portions of one example of a P4 protocol header . P4 protocol header  includes version , size , server identifier , and broker identifier . Version  is a two-byte element of the message header species the version of P4 protocol for the message. Size  is a four-byte element that specifies the size of the message. Service identifier  is a four-byte element that specifies an identifier to uniquely identify a server, for example, within a cluster of servers. Broker identifier  is a four-byte field that can be used to identify a cluster in which the server resides.","Referring again to , in an embodiment, the communication between connection manager  and the internal communication partners is session based. In such an embodiment, session communication data  is prepended to messages between connection manager  and the internal communication partners. Session logic associated with the internal communication partners (-) and connection manager  (not shown) processes session communication data .",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 6","FIG. 3","FIG. 3"],"b":["600","610","620","626","610","610","640","640","630"],"sub":["1","M "]},"Shared memory  is a memory resource that each of worker nodes through can access to exchange messages and other information with connection manager . In the illustrated embodiment, shared memory  includes request\/response shared memory  and request notification queues . Connection manager  writes request data into (and reads response data from) request\/response shared memory . Any of worker nodes -can retrieve the request data from request\/response shared memory . Likewise, any of worker nodes -can write a response into request\/response shared memory  that can later be retrieved by connection manager .","Connection manager  uses request notification queues  to notify worker nodes -that request data is available in request\/response shared memory . In an embodiment, each of worker nodes -has a separate request notification queue within request notification queues . In such an embodiment, connection manager  may store a handle in the appropriate queue of a worker node to notify the worker node that request data is available. The worker node can then retrieve the handle and use it to access request\/response shared memory  and obtain the request data.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 7","b":["702","704"]},"Over time, connection manager  calls pluggable protocol handler  to process messages implemented according to either a standards-based protocol (e.g., IIOP) or a proprietary protocol (e.g., P4). In an embodiment, pluggable protocol handler  (or, for ease of reference, handler ) handles a connection oriented protocol on a multiplexed connection (e.g., multiplexed connections , , and , shown in ). Handler  registers a number of callback functions at connection manager  to respond to various events including: new client connection available, connection to communication partner established, data available, write to connection possible, and connection closed. The registered function is called if the associated event is occurring on a connection. Table 1 illustrates selected functions for handler  according to an embodiment of the invention.",{"@attributes":{"id":"p-0052","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Function","Event"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Connect","Connect to a communication partner on"]},{"entry":[{},{},"a multiplexed connection."]},{"entry":[{},"Accept","Accept incoming connection from"]},{"entry":[{},{},"external or internal communication"]},{"entry":[{},{},"partner (e.g. 620, 626)."]},{"entry":[{},"Read","Read from a multiplexed connection."]},{"entry":[{},{},"In an embodiment network"]},{"entry":[{},{},"fragmentation is supported. That is, for"]},{"entry":[{},{},"each read operation, either a complete"]},{"entry":[{},{},"message or a portion of the message"]},{"entry":[{},{},"can be read."]},{"entry":[{},"Write","Write to a multiplexed connection. For"]},{"entry":[{},{},"each write operation, either a complete"]},{"entry":[{},{},"message or a portion of the message"]},{"entry":[{},{},"can be written."]},{"entry":[{},"AllocBuf","Allocate a buffer for writing on a"]},{"entry":[{},{},"multiplexed connection."]},{"entry":[{},"Close","Close a multiplexed connection."]},{"entry":[{},"GetInfo","Retrieve information about the"]},{"entry":[{},{},"connection."]},{"entry":[{},"FindConn","Determine whether there is already a"]},{"entry":[{},{},"connection on a specified network"]},{"entry":[{},{},"connection endpoint (e.g., as specified"]},{"entry":[{},{},"by a protocol, hostname, and port"]},{"entry":[{},{},"number)."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In an embodiment, PlugInInit function  is called after handler  is loaded into connection manager . PlugInInit function  provides handler specific initialization for handler . Initialization may include providing version information of connection manager , supported protocol information, hostname, port number, and the like.","Handler  registers one or more input\/output functions with multiplex select thread . Multiplex select thread  calls these functions if an associated event occurs on a network connection. In one embodiment, the functions registered for handler  include read , accept , write , and connect .","In an embodiment, read  allows handler  to read from a multiplexed connection. Reading from the multiplexed connection may include reading an entire message or only reading a fragment of the message. If only a fragment of the message is read, then read  may be repeatedly called until the entire message has been read. Pseudo-code listing  illustrates read data processing, according to an embodiment of the invention. Pseudo-code listing  is directed to read data processing for data implemented according to the P4 protocol (implementing a state machine). It is to be appreciated that similar read data processing may be used for other protocols (either standards-based protocols or proprietary protocols).",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"LISTING 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"state == read request:"]},{"entry":[{},"\u2003\u2003\u2003\u2002Read( ) -> buffer, buffer length"]},{"entry":[{},"\u2003\u2003\u2003\u2002if buffer length >= P4 header length (fixed size)"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002process P4 header"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002state = P4 body"]},{"entry":[{},"\u2003\u2003\u2003\u2002else"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002store buffer locally"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002store buffer length locally"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002state = header fragmented"]},{"entry":[{},"\u2003\u2003\u2003\u2002end"]},{"entry":[{},"state == header fragmented:"]},{"entry":[{},"\u2003\u2003\u2003\u2002Read( ) -> buffer, buffer length"]},{"entry":[{},"\u2003\u2003\u2003\u2002if length + stored length >= P4 header length"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002state = P4 body"]},{"entry":[{},"\u2003\u2003\u2003\u2002else"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002append buffer to stored buffer"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002add buffer length to stored buffer length"]},{"entry":[{},"\u2003\u2003\u2003\u2002end"]},{"entry":[{},"state == P4 body:"]},{"entry":[{},"\u2003\u2003\u2003\u2002Read( ) -> buffer, buffer length"]},{"entry":[{},"\u2003\u2003\u2003\u2002if buffer length >= P4 message length"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002message is complete"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002forward message to server node"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002state = read request"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In an embodiment, write  allows handler  to write data to a multiplexed connection. Writing to the multiplexed connection may include writing an entire message or only writing a fragment of the message. If only a fragment of the message is written, then write  may be repeatedly called until the entire message has been written.","Connect  allows handler  to connect to a communication partner on a multiplexed connection. The communication partner may be either an internal communication partner (e.g., worker nodes -, shown in ) or an external communication partner (e.g., clients  and , shown in ). Accept  allows the connection manager  to accept new incoming connections from an external or internal client. Multiplex select thread  can either accept or reject the request to connect to a communication partner based, at least in part, on whether sufficient resources exist to form the connection.","Reference number  illustrates handler  requesting a connection with connect function . Similarly, reference number  illustrates handler  reading data from a multiplexed connection. Other handlers for other protocols (not shown) can access multiplex select thread  to perform similar input\/output functions as shown by reference number .","Turning now to , the particular methods associated with embodiments of the invention are described in terms of computer software and hardware with reference to a flowchart. The methods to be performed by a computing device (e.g., an application server) may constitute state machines or computer programs made up of computer-executable instructions. The computer-executable instructions may be written in a computer programming language or may be embodied in firmware logic. If written in a programming language conforming to a recognized standard, such instructions can be executed on a variety of hardware platforms and for interface to a variety of operating systems. In addition, embodiments of the invention are not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement embodiments of the invention as described herein. Furthermore, it is common in the art to speak of software, in one form or another (e.g., program, procedure, process, application, etc.), as taking an action or causing a result. Such expressions are merely a shorthand way of saying that execution of the software by a computing device causes the device to perform an action or produce a result.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 8","FIG. 7","FIG. 7","FIG. 7","FIG. 7","FIG. 7"],"b":["810","706","702","710","712","711","714"]},"Referring to process block , the dynamically loadable protocol handler receives an indication that a network connection endpoint is available for an input\/output function. The received indication may be, for example, a return from a select thread (e.g., multiplex select thread , shown in ) indicating that a network connection is ready for an input\/output function, or may be an indication on the connection oriented shared memory indicating that data is ready for processing.","Referring to process block , an input\/output function of the dynamically loadable protocol handler is performed. Examples of input\/output functions include read functions, write functions, and connect functions. In an embodiment, the fragmentation of network messages is supported. In such an embodiment, read\/write functions may read\/write either an entire message or only a portion of the message (e.g., a message fragment). The read\/write function may be repeatedly called until the entire message is read from the connection or written to the connection. The process can be repeated as shown by .","The architectures and methodologies discussed above may be implemented with various types of computing systems such as an application server that includes a Java 2 Enterprise Edition (\u201cJ2EE\u201d) server that supports Enterprise Java Bean (\u201cEJB\u201d) components and EJB containers (at the business layer) and\/or Servlets and Java Server Pages (\u201cJSP\u201d) (at the presentation layer). Of course, other embodiments may be implemented in the context of various different software platforms including, by way of example, Microsoft .NET, Windows\/NT, Microsoft Transaction Server (MTS), the Advanced Business Application Programming (\u201cABAP\u201d) platforms developed by SAP AG and comparable platforms.","Processes taught by the discussion above may be performed with program code such as machine-executable instructions which cause a machine (such as a \u201cvirtual machine\u201d, a general-purpose processor disposed on a semiconductor chip or special-purpose processor disposed on a semiconductor chip) to perform certain functions. Alternatively, these functions may be performed by specific hardware components that contain hardwired logic for performing the functions, or by any combination of programmed computer components and custom hardware components.","An article of manufacture may be used to store program code. An article of manufacture that stores program code may be embodied as, but is not limited to, one or more memories (e.g., one or more flash memories, random access memories (static, dynamic or other)), optical disks, compact disks-read only memory (CD-ROMs), digital versatile\/video disks (DVD ROMs), erasable programmable read-only memory (EPROMs), electrically erasable programmable read-only memory (EEPROMs), magnetic or optical cards or other type of computer-readable media suitable for storing electronic instructions.",{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIG. 9","FIG. 9"],"b":["900","902","905","903","905","906","906"]},"It is believed that processes taught by the discussion above can be practiced within various software environments such as, for example, object-oriented and non-object-oriented programming environments, Java based environments (such as a Java 2 Enterprise Edition (J2EE) environment or environments defined by other releases of the Java standard), or other environments (e.g., a .NET environment, a Windows\/NT environment each provided by Microsoft Corporation).","In the foregoing specification, the invention has been described with reference to specific exemplary embodiments thereof. It will, however, be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"FIGURES","p":["The present invention is illustrated by way of example and not limitation in the figures of the accompanying drawings, in which like references indicate similar elements and in which:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
