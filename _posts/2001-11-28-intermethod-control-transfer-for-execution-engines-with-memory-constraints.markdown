---
title: Inter-method control transfer for execution engines with memory constraints
abstract: A bytecode execution system and method for increasing the execution speed of invoking and returning from Methods while minimizing the memory footprint required to support this. The system includes a virtual machine with a class loader and an interpreter or, alternatively, a hardware accelerator. Speed and memory enhancements are realized by establishing an activation stack frame template with a set of criteria. Each Method from subject code is examined to determine whether the Method conforms to the criteria of the stack frame template. If the Method conforms, an activation frame for that Method based on the activation stack frame template is created when the Method is invoked. Otherwise, an activation frame based on standard virtual machine criteria is created. An access structure is associated with each Method and a Method routing structure is created for each class.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06976254&OS=06976254&RS=06976254
owner: Esmertec AG
number: 06976254
owner_city: Dubendorf
owner_country: CH
publication_date: 20011128
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The present invention relates to software execution machines. More particularly, the invention relates to a method and a device to improve execution of method invocations and returns.","As is known, object oriented programming involves three major concepts: encapsulation, inheritance, and polymorphism. Classes are software modules and contain data (e.g., data members) and processing functions that manipulate that data (e.g., methods (hereinafter \u201cMethods\u201d)). Encapsulation involves making the internal details of the data and Methods used inaccessible (by language access restrictions) to other classes and providing an official interface for accessing the class. Thus, some Methods and data are visible externally to the class, and others are hidden. Objects are instances of a class. Every object of the same class has exactly the same data layout, though the contents of the data may vary between objects. Methods can act on data defined or initialized within the object or they may also receive data through parameter passing. A Method is executed by using its name in a process often referred to as an invocation or invoke. Methods may provide result or output data using a return statement. Inheritance allows Methods and data in one class, that are part of the official interface to that class, to be automatically available to sub-classes without any need for the sub-class to define them further. The subclass is free to add its own features and also override inherited Methods with its own Methods to specialize that behavior for its own class. For example, a class \u201cMultiMediaPlayer\u201d may define a Method \u201cPlay\u201d which is made part of its official interface. Another Method in this class invokes \u201cPlay,\u201d using a MultiMediaPlayer object. There may be two subclasses, a VideoPlayer class and an AudioPlayer class, that inherit \u201cPlay\u201d from \u201cMultiMediaPlayer\u201d but choose to override it with their own Method, appropriately redefined to reflect the differences in video player and audio player playback. When an object of type VideoPlayer is used in MultiMediaPlayer's invoke on \u201cPlay,\u201d this results in VideoPlayer's \u201cPlay\u201d Method receiving control. Similarly, when an object type AudioPlayer is used in MultiMediaPlayer's invoke on \u201cPlay,\u201d this results in AudioPlayer \u201cPlay\u201d Method receiving control. The MultiMediaPlayer's invoke exhibits polymorphism, as different object shapes can be used with it (so long as they are correctly related by class hierarchy).","Java is one type of object-oriented language and is often implemented as an interpreted language. One feature of Java is that the overall process of executing Java source code involves a conversion of the Java source code into an intermediate form called bytecode. (This process may be carried out by a Java compiler). Bytecode is executed by an interpreter in a Java virtual machine. In simple terms, the Java virtual machine is so named because while it performs bytecode processor or machine functions (i.e., execution of bytecode instructions) it most commonly consists of software (often written in the C programming language) rather than hardware. Thus, it is a virtual implementation of a bytecode processor or machine. There are also Java hardware accelerators (actual hardware) capable of directly executing some of the bytecodes. Ultimately, an actual hardware processor or combination of hardware processor and Java hardware accelerator executes the virtual machine.","The semantics of bytecode are specified by the Java Virtual Machine (\u201cJVM\u201d) specification (available from Sun Microsystems and other publishers). Bytecode was originally designed to execute on a stack-based abstraction of a computer processor, i.e., a virtual machine. As noted above, a virtual machine may be implemented through pure software, or a combination of software and hardware. When a Java virtual machine is implemented with software and hardware, the hardware component is referred to as a Java hardware accelerator. The accelerator can exist as a separate coprocessor, or as an extension to the core of existing processor architecture. However, Java Method invocations and returns are typically handled by software, regardless of the presence of a hardware accelerator. The complex semantics of invocations and returns may require several lines of C code, which in turn amounts to roughly 100\u2013150 machine instructions for invokes and about 50\u201360 machine instructions for returns.","There is a growing demand for Java applications for devices (such as cell phones, PDA's, and the like) having relatively limited processing power, limited memory, or both. However, the limited capabilities of these devices make it difficult to execute all but the shortest and simplest Java programs. And, even where execution is possible, the speed of execution is often unacceptably slow.","Accordingly, there is a need for improved methods and devices for executing software programs on devices having limited capabilities, and particularly limited memory. The inventor has found that improved inter-Method control transfer methods and devices can reduce execution engine overhead and improve overall execution time of applications run on devices having limited capabilities.","In functional terms, invokes and returns require several basic processing steps. These steps include: 1) relinquishing control to the software (only when a Java hardware accelerator is used); 2) determination of destination address; 3) frame creation (and destruction); and 4) relinquishing control from the software (hardware accelerator only). The impact and importance of these steps is illustrated by the following example. Suppose a Java Method contains twenty bytecodes which include one invoke and one return. Suppose the bytecode execution engine is an optimized assembler interpreter, capable of implementing simple bytecodes in 3 to 4 CPU instructions, but falls back to C code to handle the invoke and return. Executing this Method consumes about 54 to 72 CPU cycles in the interpreter and about 200 CPU cycles within the C layer. Approximately 22%\u201326% of the cycles executed are attributed to the simple bytecodes. Using Java to model object-oriented techniques such as encapsulation and polymorphism can result in moderate percentages of invokes and returns being executed, which in turn scales up considerably in terms of CPU cycles executed. If an additional invoke is added to the Method, about 350 CPU cycles are consumed in the C layer. In this case, about 14% to 17% of the cycles executed are attributed to the simple bytecodes. With a Java hardware accelerator, these proportions are generally less, since the accelerator drives down the number of cycles taken to execute the simple bytecodes, while leaving the C layer consumption unchanged.","If the overhead for supporting invokes and returns is reduced to about 60 cycles in total, total execution cost can be reduced to about half the original cycle count in the above assembler-interpreter example. That is, a doubling of speed can be achieved compared to the original implementation. Again, a Java hardware accelerator solution benefits further from this approach.","In one embodiment, the invention is designed to support the Java2 Micro Edition (\u201cJ2ME\u201d) platform as applied to the Connected, Limited Device Configuration (\u201cCLDC\u201d) product category. The J2ME\/CLDC runtime environment is targeted at low-end consumer devices, which have limited memory and processor capabilities. An extension of the J2ME\/CLDC environment is the mobile information device profile\/protocol (\u201cMIDP\u201d) application programming interface (\u201cAPI\u201d). This API allows applications (referred to as \u201cMIDlets\u201d) to be downloaded into the device after it has been shipped. This enables new functionality to be added to a device without the need to add or change hardware and supports new services as they are developed. However, the capability comes at a cost, both in terms of memory footprint and power consumption. Yet, as noted, it is crucial to keep memory and processing demands of low-end devices small.","The inventor has observed that certain bytecode operations are semantically complex, and even a low dynamic frequency of these bytecodes executing at runtime can add large performance overheads, particularly if the bytecodes are not supported by suitable runtime data structures. The inventor has also observed that the typical Method only requires a small number of words on the Java stack. To achieve the objectives of low memory footprint and lessened processing demands, the invention provides a compact internal representation of classes and, in particular, of Methods. The internal representation of a Method, the fast Method access structure, is spatially optimized with special attention to Methods whose Java stack requirements fit within a standard or predefined activation frame size. This results in increased execution speeds for costly bytecodes (such as invokes and returns) while reducing memory requirements.","Among other things, the invention provides a bytecode execution system and method. The system includes a virtual machine and an interpreter or, alternatively, a hardware accelerator. It also may include a dynamic adaptive compiler. The execution speed of invokes is increased and memory requirements decreased by establishing an activation stack frame template with a set of criteria. Each Method from subject code is examined to determine whether the Method conforms to the criteria of the stack frame template. If the Method conforms, an activation frame for that Method based on the set of criteria is created. Otherwise, an activation frame based on standard virtual machine criteria is created. A fast Method access structure is spatially associated with each Method and a Method routing structure is created for each class. The Method routing structure can have misaligned pointers to indicate processor executable Method access structures and aligned pointers to indicate software-interpreted Method access structures. Invocation bytecodes are rewritten to include an indication of an entry in the Method routing structure.","Other features and advantages of the invention will become apparent to those skilled in the art upon review of the following detailed description, claims, and drawings.","Before any embodiments of the invention are explained in full detail, it is to be understood that the invention is not limited in its application to the details of construction and the arrangement of components set forth in the following description or illustrated in the following drawings. The invention is capable of other embodiments and of being practiced or of being carried out in various ways. Also, it is to be understood that the phraseology and terminology used herein is for the purpose of description and should not be regarded as limiting. The use of \u201cincluding,\u201d \u201ccomprising,\u201d \u201chaving,\u201d and variations thereof herein is meant to encompass the items listed thereafter and equivalents thereof as well as additional items. It is assumed that the reader has familiarity with computer programming and architecture and, in particular, familiarity with Java and virtual machines. Further, as used herein the term \u201ccode\u201d is used broadly to include, among things, both bytecode and compiled representations of bytecode.","The invention lowers the overhead costs for invokes and returns and improves the speed of Java bytecode execution using a stack frame template, a Method access structure, a Method routing structure, and certain bytecodes. While the invention is effective in achieving improved speed, these speed improvements can be counteracted if a Java program spends a lot of time within native Methods (Methods in an application specifically designed to run on a particular computing environment, such as a graphical user interface of operating system software for a specific processor), or within the operating system of the processor hosting the virtual machine.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1","b":["10","11","12","13","13","14","15","15","16","16","15","17","15","18","19"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3","b":["20","20","22","0","7","24","26","26"]},"A subject Method may execute with an activation frame conforming to the stack frame template  provided it meets certain criteria. In one embodiment of the invention, that criteria includes the following requirements:\n\n","The requirements noted above are merely examples of criteria that may be used and the number of words allotted may be varied depending on the specific application of the invention at hand. Regardless of the exact values, Methods that conform to the specified criteria are so identified or otherwise designated as being conformant. This analysis can be readily performed in the class loader A or by a ROMising tool at system build time. When the runtime environment selects such a Method for execution, an activation frame conforming to the template  is created. Activation frames for non-conforming Methods are created (consistent with well-known processes) according to the requirements of the subject Method. The categorization of Methods as conforming or non-conforming reduces memory requirements. Memory savings are realized, in part, from the utilization of the conformance to standard template frames with a fast Method access structure (described in greater detail below). During any invocation, the fast Method access structure of the called Method must be determined. If a Method's stack requirements conform to the standard template , this access structure need only have a single-bit flag or similar marker to indicate this fact in the structure of the Method. Otherwise, three bytes of data are required to specify the stack requirements (a byte each for nParamWords, nLocalWordsTotal, and nEstkWords). The savings in memory can be substantial. For example, storing system classes in non-volatile memory requires several Kbytes less memory using the standard template single-bit flag than what would be required using known techniques.","As was suggested above, various operations such as bytecode resolution, exception handling, stack frame handling, and others require knowledge of the Methods being executed. Similarly, when the runtime environment selects a Method for execution (i.e., the Method is being invoked) the structure of the destination Method must be ascertained to determine its stack requirements and whether a monitor is to be entered (e.g., if the destination Method is a synchronized Method). According to the invention, Method information is provided by a fast Method access structure (\u201cFMAS\u201d)  (). Each access structure  is positioned spatially contiguous to the representation of the application Method. In a highly preferred embodiment, the Method access structure immediately precedes bytecodes  (if any) of the subject Method, spatially. (Some Methods such as abstract and native Methods do not have any bytecode). When compiled code is available, the position of the Method access structure remains unchanged, but the bytecodes are replaced by target code. Due to the spatial relationship, the Method access structure and representation of the Method can be viewed as a single structure.","Each Method access structure  is associated with a pointer , which in the embodiment shown is referred to as a fast Method access structure pointer (\u201cFMASP\u201d). According to the invention, the pointer  is defined as addressing the first byte of where any code would reside. This allows the same value to be used as an indicator of where any code resides for implementing the Method, and to denote the Method itself. Typically, two separate pointers are used, which requires more memory than the use of a single pointer. Thus, the invention provides a significant reduction in memory requirements. For the example of storing system classes in non-volatile memory, a further memory reduction of several Kbytes may be realized. Negative offsets off the pointer  are used to access items within the Method access structure.","The Method access structure  is a variable size structure. One reason for designing the Method access structure in this manner is that Methods vary in architecture. For example, not all Methods have exception handler tables. To accommodate the variable size aspect of the structure  and the fact that classes usually include several Methods, each Method access structure  in a specific class is linked to the next access structure within that class.","If a subject Method can execute with the standard stack template , then the FMAS  is laid out in the compact form set out in Table 1. The best case encoding only requires 32 bits of information, and may be applied when the Method has no exception handler, no need of the name and signature to be exported (however, the garbage collector still needs to know about the stack state at Method entry, so this can only be omitted if a convention is adopted on what Method signature is implied when the name and signature field is absent), and no runtime requirement of a constant pool pointer due to the nature of the bytecode or due to bytecode rewriting.",{"@attributes":{"id":"p-0029","num":"0031"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Optional 32-bit pointer to exception handler table (bytecode only)"]},{"entry":[{},"Optional 32-bit description of name and signature for the Method."]},{"entry":[{},"Optional 32-bit constant pool pointer"]},{"entry":[{},"32-bit flags encoding. See Table 2."]},{"entry":[{},"Bytecode for the Method follows, if any . . . FMASP points here"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0030","num":"0032"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Name","Bit(s)","Semantics"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Link","<31:17>","FMASP of next structure in"]},{"entry":[{},{},"chain is given by this"]},{"entry":[{},{},"FMASP + Link."]},{"entry":[{},{},"Details of access flags such"]},{"entry":[{},{},"as private, protected etc."]},{"entry":[{},{},"are omitted for clarity."]},{"entry":["FMASNARGSFLD","<8:6>","If FMASSTDSTK is set,"]},{"entry":[{},{},"this field encodes the"]},{"entry":[{},{},"number of argument words"]},{"entry":[{},{},"for the subject Method"]},{"entry":[{},{},"(0\u20137)"]},{"entry":["FMASNAMESIG","<5>","If set, the name and signa-"]},{"entry":[{},{},"ture field is present."]},{"entry":["FMASSTDSTK","<4>","If set, the Method's im-"]},{"entry":[{},{},"plementation can execute"]},{"entry":[{},{},"on a standard stack"]},{"entry":[{},{},"template"]},{"entry":["FMASHANDLERABSTRACT","<2>","<0> set"]},{"entry":[{},{},"<2> set => exception table"]},{"entry":[{},{},"pointer present."]},{"entry":[{},{},"<0> clear"]},{"entry":[{},{},"<2> set => abstract"]},{"entry":[{},{},"Method; else native Method"]},{"entry":["FMASENGINECPOOL","<1:0>","Method implementation"]},{"entry":[{},{},"with overloaded constant"]},{"entry":[{},{},"pool pointer bit. (Native"]},{"entry":[{},{},"and abstract Methods do"]},{"entry":[{},{},"not have a constant pool"]},{"entry":[{},{},"pointer)"]},{"entry":[{},{},"00"]},{"entry":[{},{},"Compiled. Bits <31:2> are"]},{"entry":[{},{},"back-pointer to bytecode"]},{"entry":[{},{},"MSP"]},{"entry":[{},{},"x1"]},{"entry":[{},{},"Bytecode. Bit <1> set"]},{"entry":[{},{},"indicates constant pool"]},{"entry":[{},{},"pointer present in"]},{"entry":[{},{},"structure (may be NULL)"]},{"entry":[{},{},"10"]},{"entry":[{},{},"Native or abstract. See bit"]},{"entry":[{},{},"<2>"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"If the subject Method does not conform to the standard stack template , i.e., if FMASSTDSTK is clear, then stack requirements for the Method are encoded using standard practices and the Method access structure  is laid out in the form set forth in Table 3.",{"@attributes":{"id":"p-0032","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Optional 32-bit pointer to exception handler table (bytecode only)"]},{"entry":[{},"Optional 32-bit description of name and signature for Method."]},{"entry":[{},"#.bytes storage needed for non-parameter locals. (bytecode only)"]},{"entry":[{},"#.bytes storage needed for entire activation frame. (bytecode only)"]},{"entry":[{},"#.bytes storage needed for parameter locals."]},{"entry":[{},"Pad byte for alignment"]},{"entry":[{},"Constant pool pointer. NULL for abstract and native."]},{"entry":[{},"The flags encoding word (FMASSTDSTK clear)"]},{"entry":[{},"Bytecode for Method follows, if any . . ."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Since the set of Methods for a class are linked, an end of set marker is provided according to Table 4.",{"@attributes":{"id":"p-0034","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 4"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"The flags encoding word, set to zero"]},{"entry":[{},"32-bit pointer to the class that these Methods are declared in"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"If runtime compilation occurs, (for example, if no hardware accelerator is present on the device ) then the FMAS  is encoded as shown in Table 5.",{"@attributes":{"id":"p-0036","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"FMASP for bytecode equivalent Method structure. Note that bits <1:0>"},{"entry":"are clear, and hence denote this as a compiled Method"},{"entry":"Translated Method body (understands how to create frame). The FMASP"},{"entry":"value for the compiled Method points here."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Method access structures associated with dynamically compiled code are maintained in a runtime code buffer storage area, separate from any non-processor executable Method access structures (those associated with bytecode) in the system. (The code storage area can be recycled). Since compiled Methods, by definition, have all the information needed to enable their execution, there is no need for further information provided by an access structure. However, if the system supports compiled code deletion, mechanisms used to revert back to using bytecode must be supported. The back pointer to the original FMAS mentioned above supports such reversions.","The above Method access structures can be generated by a ROMising tool when building the system or dynamically, as classes are loaded. With the above structures in place, a savings of at least about 40 Kbytes may be achieved for the set of CLDC\/MIDP Methods. Bytecode rewriting and other techniques can be used to achieve even greater memory savings.","The above aspects of the invention are not fully useful unless FMASP's can be found during runtime. Where the system includes runtime compilation, determination of the FMASP for the compiled code needs to be found quickly. In preferred embodiments of the invention, a Method routing structure (\u201cMRS\u201d) is used to support these operations. An exemplary MRS  is shown in . The MRS  includes a number of entries , which are illustrated as Entry  through Entry N+2. Each entry is a pointer value to a Method access structure. In , two exemplary Fast Method access structures are shown, FMAS  and FMAS .","For a given class C, the FMASP's for all its Methods are grouped into one data structure, the MRS, which preferably resides in RAM  to allow runtime compilation the ability to update FMASP's to point at processor executable Method structures (compiled code), and code deletion to reset the FMASP's back to point at processor non-executable Method structures (bytecode) again. An MRS is partitioned into two sets of FMASP's: those that denote inheritable Methods of class C, and those that are non-inheritable.","Class C's MRS is initialized with a copy of the inheritable portion of C's superclass (unless this is java.lang.Object). Each of C's inheritable Methods (i.e., a Method that is none of the following: static, private, or a constructor) is examined. If a given inheritable Method M has the same name and signature as another Method, e.g., Method Q, whose FMASP is in the superclass's copy, and Q can be overridden according to the semantics specified by the language specification, then the FMASP for Q is replaced by the FMASP for M. Otherwise, the FMASP for M is appended to the current end of the MRS. Once all the inheritable Methods of C are processed; the non-inheritable Methods (their FMASPs) are appended to the end of C's MRS. The inheritable portion of the MRS is analogous to a well-known data structure, called a vtab or virtual function table or dispatch table.","The MRS supports both compiled and interpreted bytecode by using only one 32-bit entry per Method. In the example shown in , Entry  has a misaligned pointer value of 0x403002 for a FMAS pointer , which has an actual value of 0x403000. The misaligned pointer value of 0x403002 indicates that the subject Method, which as noted above follows the FMAS spatially, is directly executable by the processing device , with the machine code entry point at FMASP-. The Method following the FMAS  is shown having bytecode. The use of misaligned pointer values enables the system to quickly pass control to compiled code, and the fact that a single 32-bit entry may be used to designate both compiled and interpreted bytecode allows the MRS to be half the size of other representations, where the system supports dynamically compiled code.","The MRS  is read for all styles of invokes. When an object of type C is created at runtime, it contains a pointer to the MRS for C. A pointer from the MRS back to the class C is also provided. When an invoke bytecode is resolved, the pointer P to the entry in the appropriate MRS of the declaring class is stored or otherwise noted for later use. Equivalently, the entry number N within the MRS can be derived from the pointer.","Two new bytecodes are used to take advantage of the structures noted above and also to enable removal of the original constant pool entries for these. These bytecodes are defined in Table 6 and are new forms of the invokevirtual bytecode (as defined by the Java specification).",{"@attributes":{"id":"p-0045","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Invokevret32","Bc[1] = MRS entry #. Bc[2] <6:0> = #.32-bit"]},{"entry":[{},"args,"]},{"entry":[{},"Bc[2]<7> = Method return type bit (1 = ref, 0 ="]},{"entry":[{},"nonref)."]},{"entry":["Invokevret64void","Bc[1] = MRS entry #. Bc[2] <6:0> = #.32-bit"]},{"entry":[{},"args,"]},{"entry":[{},"Bc[2]<7> = Method return type bit (1 = 64-bit,"]},{"entry":[{},"0 = void)."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"sub":["\u2014","\u2014","\u2014"],"b":["32","64"]},"A lot of what has been described so far relates to accessing an invoked Method. Part of the overall process of invoking a Method involves executing the actual transfer of control to the invoked or destination Method, given an FMASP. The mechanisms in the invention used to transfer control to a destination Method take advantage of the FMAS and the probability of a standard stack template being applicable to the destination Method.",{"@attributes":{"id":"p-0047","num":"0049"},"figref":"FIG. 5","b":["70","72","20","70","72","22","24","26","0","72","70"]},"The frame linkage structure  within each activation frame is used to store state information about the caller. The state information may include the following items:\n\n","As part of the control transfer process, the runtime environment must check that the activation frame required for the callee can be satisfied from the current stack region, and take suitable action if the stack overflows. To simplify this check, a stack limit value is stored. The stack limit value is equal to the size of the applicable Java stack limit minus the size of a standard stack frame. As noted above, the size of the standard frame template may vary depending on the specific application at hand.","Another part of the control transfer process involves manipulating register states. In general, register states are available in processor registers and, for preferred embodiments of the invention, it is assumed the following values are available in processor registers:\n\n","Preferably, the order of the registers and frame linkage structures  are matched so that efficient frame management may be realized. This is particularly important for those implementations where the device  is implemented with a reduced instruction set computer (\u201cRISC\u201d) processor used to directly execute the virtual machine along side existing operating system, middleware, and application code. An ARM\u2122 CPU is an example of such a processor. When such a processor is used, matching the order of registers and frame linkage structure elements allows the use of the LDM\/STM instructions.","Having defined the overall process of invoking and returning from Methods more detailed examples are now provided. First, an invoke is described. Second, a return is described.","The initial part of an invoke involves fetching the FMASP for the destination Method into the register \u201ccalleeMeth\u201d. The exact nature of this step depends upon the kind of invoke bytecode being executed. For an invokevret32, assuming currBc has been updated to point after the invoke, the number of parameter words may be fetched from currBcode-, bits <6:0>, and the MRS entry number may be obtained from currBcode-. The code sequence set out below demonstrates the interpreter executing both the invoke and the destination Method, taking advantage of the FMASP and the standard stack template. For the example shown, it is assumed that register \u201cmrsEntry\u201d holds the MRS entry number extracted from the bytecode.",{"@attributes":{"id":"p-0054","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["sub estk, estk, #((nParamWords-1) * 4)","\/\/ address first argument"]},{"entry":["ldr tmp, [estk]","\/\/ fetch \u201cthis\u201d for callee"]},{"entry":["ldr tmp, [tmp. # \u2212 4]","\/\/ fetch pointer to MRS of"]},{"entry":[{},"class of dest."]},{"entry":["ldr calleeMeth, [tmp, mrsEntry, LSL #2]","\/\/ fetch FMASP for"]},{"entry":[{},"dest.Method"]},{"entry":["ldr link, [pc, = resumeAfterInvokeRet32]","\/\/ for post-Java return"]},{"entry":[{},"processing"]},{"entry":["tst calleeMeth, METHISCOMPILED","\/\/ test for misaligned pointer"]},{"entry":["sub.ne pc, calleeMeth,","\/\/ and branch to dest, possibly"]},{"entry":"METHISCOMPILED"},{"entry":["ldr tmp, [calleeMeth-4]","\/\/ fetch flags encoding word in"]},{"entry":[{},"FMAS"]},{"entry":["tst tmp, FMASSTDSTK","\/\/ test for standard stack"]},{"entry":[{},"template"]},{"entry":["beq NonStdStack","\/\/ handle non-standard"]},{"entry":[{},"size . . ."]},{"entry":["cmp estk, jstackLimit","\/\/ stack overflow ??"]},{"entry":["bge overflow","\/\/ handle overflow . . ."]},{"entry":["add estk, estk, #((8 \u2212 1) * 4)","\/\/ point to local7 (just before"]},{"entry":[{},"linkage)"]},{"entry":["stmib estk!, {link, currBc, locals,","\/\/ create frame linkage"]},{"entry":["currMeth}","structure"]},{"entry":[{},"\/\/ estk points at callee's"]},{"entry":[{},"estk[\u22121]."]},{"entry":[{},"\/\/ I.e., empty"]},{"entry":["sub locals, estk, #((8 \u2212 1 + 4) * 4)","\/\/ point at local0 for callee"]},{"entry":["mov currMeth, calleeMeth","\/\/ update current Method"]},{"entry":["mov currBc, currMeth","\/\/ and point at its first"]},{"entry":[{},"bytecode"]},{"entry":["b INTERPloop","\/\/ and start executing Method"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The initial step in a return operation involves fetching the return value. The code sequence below demonstrates this and the remaining steps carried out in a return. For this example, it is assumed that a 32-bit value is returned, that the return address is to the label resumeAfterInvoke32, and that the return value will be in register retVal.",{"@attributes":{"id":"p-0056","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["mov retVal, [estk]","\/\/ fetch return value"]},{"entry":["ldr tmp, [currMeth-4]","\/\/ fetch flags encoding word in FMAS"]},{"entry":["tst tmp, FMASSTDSTK","\/\/ test for standard stack template"]},{"entry":["beq NonStdStackRet32","\/\/ handle non-standard size . . ."]},{"entry":["add tmp, locals, #((8 + 4) * 4)","\/\/ point to return address"]},{"entry":["mov estk, locals","\/\/ set up estk for caller"]},{"entry":["ldmdb tmp, {pc, currBc, locals,","\/\/ and return"]},{"entry":"currMeth}"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"As can be seen from the above, the invention provides new data structures and bytecodes to improve the speed of invokes and returns while minimizing the memory footprint required to support this. Various features and advantages of the invention are set forth in the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 5","FIG. 2"]}]},"DETDESC":[{},{}]}
