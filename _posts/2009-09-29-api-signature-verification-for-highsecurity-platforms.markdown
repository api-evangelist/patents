---
title: API signature verification for high-security platforms
abstract: A system and method is disclosed for verifying whether a test API of a high-security software platform implements a reference API when a verification tool has insufficient permissions to detect one or more members of the test API. A signature is determined for a reference API implementation, which includes multiple API members. Determining the signature involves identifying a proper subset of the API members, where the subset excludes one or more API members that are not programmatically detectable by a given verification tool executing on a high-security platform that implements the reference API. The member may not be detectable by the verification tool because the tool has insufficient permission to programmatically detect the member on the high-security platform. The signature is then configured to indicate the members of the subset and not the excluded members. The signature is then stored.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08341738&OS=08341738&RS=08341738
owner: Oracle America, Inc.
number: 08341738
owner_city: Redwood City
owner_country: US
publication_date: 20090929
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF EMBODIMENTS"],"p":["Many modern software systems are built on standard, third-party software platforms, such as Java. Such platforms provide standard and frequently used functionality, which a given application may access through a programmatic interface (API). For example, the Java software platform includes a variety of classes, methods, and utilities including a runtime environment and frequently used functions and data structures for quickly developing and deploying applications.","Often times, different parties each implement their own version of a given platform. For example, BlueRay\u2122 video players are often produced and loaded with a custom version of a given software platform, such as a custom Java platform. In order to ensure that software applications written to execute on a given platform interoperate properly with versions of the platform written by different parties, it is sometimes desirable to verify that a given platform implementation (test API) exposes at least a minimum set of functionality, as defined by a reference API. Such checking may be referred to as API verification.","The minimum functionality of a given platform may be defined by a specification or reference implementation of the platform. A variety of products is available for determining the conformance of a test API exposed by one platform with a reference API. These include both commercially and freely available products, such as the SigTest tool, which verifies that a given Java platform implementation includes a reference API. Such tools may include a setup step wherein a reference API is defined (e.g., in a reference signature file) and a test phase, wherein a verification tool is executed on a platform under test and, using the reference signature file, determines whether the API exposed by the platform under test (test API) conforms to the given reference API.","To perform the test phase, verification tools, such as SigTest, may use various utilities (e.g., Java Reflection) to discover the members that constitute the API under test. However, if the platform under test comprises a high-security platform, traditional verification tools may not have sufficient permissions to discover all members of the test API, and may therefore fail. For example, during the test phase, the SigTest tool relies on reflection methods such as getDeclaredClasses( ), getDeclaredConstructors( ), getDeclaredFields( ), and getDeclaredMethods( ) for discovering the test API. However, in high-security platforms, such methods may require a higher level of permissions than is granted to the SigTest application. Therefore, SigTest and similar tools traditionally fail when attempting to verify whether high-security platforms, such as Java\u2122 high-security sandbox platforms, conform to a given reference API.","A system and method is disclosed for verifying whether a test API of a high-security software platform (e.g., a high-security sandbox Java\u2122 platform) implements a reference API when a verification tool has insufficient permissions to detect one or more members of the test API. A signature is determined for a reference API implementation, which includes multiple API members. Determining the signature involves identifying a proper subset of the API members, where the subset excludes one or more API members that are not programmatically detectable by a given verification tool executing on a high-security platform that implements the reference API. The member may not be detectable by the verification tool because the tool has insufficient permission to programmatically detect the member on the high-security platform. The signature is then configured to indicate the members of the subset and not the excluded members. The signature is then stored, such as in a file.","After this initial phase, the method may further comprise executing the API verification tool on a high-security platform that implements a test API that includes a number of test API members. The API verification tool may have insufficient permissions to programmatically detect at least one of the plurality of test API members. Executing the tool may involve scanning the test API to determine a subset of the test API members, where the subset excludes any of the test API members that the API verification tool has insufficient permissions to programmatically detect.","In some embodiments, the method may further include determining a partial signature for the test API, where the partial signature identifies the test API members in the subset and excludes any test API members not in the subset. The tool may then verify whether the subset of test API members contains the members of the subset of reference API members, such as by comparing the signature of the reference API with that of the test API.","While the invention is described herein by way of example for several embodiments and illustrative drawings, those skilled in the art will recognize that the invention is not limited to the embodiments or drawings described. It should be understood that the drawings and detailed description hereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the invention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims. Any headings used herein are for organizational purposes only and are not meant to limit the scope of the description or the claims. As used herein, the word \u201cmay\u201d is used in a permissive sense (i.e., meaning having the potential to) rather than the mandatory sense (i.e. meaning must). Similarly, the words \u201cinclude\u201d, \u201cincluding\u201d, and \u201cincludes\u201d mean including, but not limited to.","Quality testing of software platforms may include verifying that an API exposed by the platform under test (test API) includes that described by a given specification and\/or reference implementation (reference API). A reference API may describe a minimum API that each implementation must expose to meet a given standard. For example, for a given Java platform, such testing may include verifying that the test API includes the same set of classes as the reference API, with each class having the same set of members (e.g., fields, methods, constructors, nested classes, etc.).","For API verification of high-security platforms, various access restrictions may exist which may prevent traditional tools from fully inspecting the platform under test and thus from determining the test API. For example, the known SigTest tool, used for verifying Java-based APIs, may not have sufficient permissions to interrogate a high-security Sandbox Java\u2122 Platform for members using the interrogation mechanisms on which it relies. For example, a SigTest verification tool may rely on methods of the Java Refection API (e.g., getDeclaredXXX( )) that require a certain level of runtime permission to be granted to the application. However, on some high-security platforms, the verification tool may have insufficient permissions to execute such methods. In one example, a BlueRay\u2122 player built by a third party may implement an API in a high-security platform, such that the SigTest tool cannot interrogate the API. In such a case, if SigTest is used to verify whether a test API of the BlueRay player (i.e., the high-security platform) conforms to a reference API, the verification tool may abort in error, due to the tool having insufficient runtime permissions. In many cases, since the high-security platform was produced and configured by a different party than that who is executing the verification too, the party executing the verification tool may not be able to grant the tool sufficient runtime access.","According to various embodiments, API verification of a high-security platform may be performed by first determining a subset of reference API members that, if present in a test API, would be programmatically detectable by the verification utility, given its level of permissions. The subset may exclude members that would not be programmatically detectable. In some embodiments, the API verification may then include determining whether the determined subset of the reference API members is present in the test API. For example, in some embodiments, when performing an API verification of a high-security sandbox Java\u2122 platform, a verification mechanism may determine the set of public members in the reference API and then determine whether that set of public members is present in the test API. Since the verification mechanism needs only to inspect the members of the platform under test that are public, it may have sufficient runtime permission to do so even if the platform comprises a high-security platform.","The example of performing API verification for a high-security sandbox Java platform is used throughout this disclosure and is intended to serve for illustrative purposes, and not to limit embodiments to only this case. The teachings in this disclosure may also be applied to the verification of other platforms, applications, components, and\/or objects implemented using Java or various other programming languages such as C, C++, etc.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},"As illustrated in , during an initial setup phase, the verification tool may determine a signature for the reference API that may identify the programmatically detectable members of the reference API, as in . A programmatically detectable API comprises only programmatically detectable members, that is, members of the API that would be detectable by a computer program (e.g., the verification tool) when the API is of a high-security sandbox platform. As described above, members of an API may include any elements that make up the programming interface, including classes, methods, fields, constructors, nested classes, and\/or other elements. Programmatically detectable members may refer to those of the members that may be detected by a software component (e.g., the verification tool) by querying the API (e.g., using reflection mechanisms) when the API is of a high-security platform.","Some test API members may not be visible to an API verification tool on the test platform due to various security policies and mechanisms employed by the high-security test platform and\/or its runtime environment. For example, if the test platform comprises a high-security sandbox Java platform, then only public members of the test API (e.g., API members marked with the \u201cpublic\u201d access modifier) may be programmatically detectable by the verification tool during the test phase, while members of the test API with protected, private, or package scope may not be detectable. Therefore, if the verification tool is to be used for API verification of a high-security sandbox Java platform, then in , the verification tool may determine the public members of the reference API and ignore members with protected, private, and\/or package scope. In other embodiments, other member scopes may be appropriate, depending on the security policy of the test platform and\/or its runtime environment. As used herein, the term detectable may refer to any member of the reference API that can be detected by the verification tool while executing on the test platform. The term undetectable may refer to any member of the reference API that cannot be detected by the verification tool while executing on the test platform, such as those for which the verification tool does not have sufficient runtime permissions to interrogate the platform under test.","According to the illustrated embodiment, once the signature (including the programmatically detectable members) of the reference API is determined (i.e., initial setup of ), the verification tool may store an indication of the signature (as in ), such as in a signature file.","In some embodiments, the verification tool or another tool may then be used to execute a test phase, wherein the tool may execute on the high-security platform under test. In this test phase, the tool may detect the members of the test API for the platform that the tool has sufficient permission to detect, as in . Once the detectable reference API is determined (as in ) and the detectable members of the test API are determined (as in ), the two sets of members may be compared as in . If the test API contains all the members of the detectable reference API, as indicated by the affirmative exit from , then the tool may determine that the test API implements (i.e., conforms to) the reference API, as in . Conversely, if the tool has detected that any member of the reference API does not exist in the test API, as indicated by the negative exit from , then the tool may determine that the test API does not implement (i.e., does not conform to) the reference API, as in . In either case, the verification tool may output its determination, as in , and\/or store the result (e.g., in system memory, disk, etc.). In various embodiments, the output may comprise any indication to a user of the determination of  or . In some embodiments, if the verification tool determines that the test API does not implement the reference API, the output may include further analysis regarding which API member or members are missing from the test API.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 2","FIG. 1","FIG. 2","FIG. 1","FIG. 1"],"b":["200","200","100","110","150"]},"According to the embodiment of , API verification tool  may comprise a reference API determination module, such as . In various embodiments, determination module  may be configured to scan a reference platform implementation and determine any detectable API members of the reference platform's API. For example, reference API determination module  may be configured to scan a reference Java platform implementation to determine the public members of the API, while not recording members with different scopes of visibility (e.g., private, protected, package, etc.).","In various embodiments, reference API determination module  may be configured to output the results of each scan in various formats. For example, in some embodiments, determination module  may output the detectable members of the reference API as a plain-text file, which may be human readable. In one such example, the plain-text file may be in a format used by one or more other API verification applications, such as the \u201cGolden Signature File\u201d format used in the SigTest tool or in another format. In some embodiments, determination module  may output the reference API as one or more serialized Java objects. In yet other embodiments, the output of determination module  may not be written to file at all, but rather remain in memory and passed to other components as an in memory object or objects.","In the illustrated embodiment of , API verification tool  may further include test API determination module . In various embodiments, determination module  may be configured to scan a high-security test platform and detect one or more API members of the platform. In some embodiments, test API determination module  may be configured to detect test API members using only mechanisms for which the verification tool has sufficient permissions to execute. For example, in one embodiment, if a high-security sandbox Java platform is to be verified, the tool may avoid using forbidden Reflection API methods (e.g., getDeclaredMethod( ), etc.) for which it has insufficient permissions to execute. Rather, in such an embodiment, the verification tool may instead use methods for which it has permissions, such as those that return only public API members (e.g., getClasses( ), getContructors( ), getFields( ), getMethods( ), etc.). As with the reference API determination module , test API determination module  may output the test API according in formats.","According to the embodiment of , API verification tool  may include comparator , which may be used to compare the outputs from reference API determination module  and test API determination module , and output module  for recording this determination and\/or otherwise informing a user about the results of the API verification test, as in . In some embodiments, comparator  may perform the determination of , as shown in . In various embodiments, comparator  may accept as input the output from determination modules  and . In some embodiments, the output of determination modules  and  may be manipulated by one or more other components into various formats before the final format is input to comparator . For example, in some embodiments, the output from an API determination module such as  may be a serialized object, which may be deserialized by another component before being input to comparator  as an in-memory object. In some cases, this may be useful for cross-compatibility between test and reference APIs implemented with different versions of a technology, such as different versions of Java.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 3","FIG. 3"],"b":["300","100","110","150","300","335","200"]},"According to the illustrated embodiment, the setup phase  may begin by examining a reference platform API implementation, such as . The reference API implementation may implement the minimum functionality (i.e., members) that a platform implementation may implement to be considered complete for interoperating with applications built for the platform.","According to the illustrated embodiment, a reference API scanner  may interrogate the reference API implementation  to derive a reference model  of reference API members that would be detectable from a high-security platform. In elements of , the * symbol is used to denote elements that exclude undetectable members of the reference API for the platform under test. In various embodiments, the reference API scanner  may use various methods for interrogating the reference API . For example, if the reference implementation comprises a Java platform, reference API scanner  may use Java Reflection functionality to discover the classes, method, member variables, and\/or other members of the reference implementation.","In some embodiments, the reference API scanner may filter out API members that would not be visible to the verification tool during the test phase, as described earlier. For instance, if reference implementation  comprises a Java platform, reference API scanner  may include in detectable reference model only API members that are designated as public in the API and exclude API members designated with protected, private, or default access scopes. In various embodiments, detectable reference model may be implemented as an in-memory object and\/or as a file.","According to the illustrated embodiment of , once reference model  is derived, the model may be passed as input to a writer component , which may convert the reference model of detectable API members into a signature file  (sometimes known as a \u201cgolden\u201d signature file). In various embodiments, the signature file may be a plain text and\/or human-readable file that may describe the detectable API members included in reference model .","According to the embodiment of , the resulting data product of setup phase  is signature file , which summarizes the detectable members of reference implementation . In various embodiments, signature file  may then be distributed to one or more parties for testing different platforms. For example, the author of a reference implementation may execute setup phase  to produce a signature file (such as ) and distribute that file to various parties that wish to verify the API of different implementations of the platform.","A party that receives the signature file  may use it to verify a platform under test, such as by executing test phase . In some embodiments, test phase  may be executed by a test-side verification tool executing on the test platform. In different embodiments, the test-side verification tool may be a different or the same tool as the setup-side verification tool used to execute setup phase . In some embodiments, the test platform may comprise a high-security platform. Therefore, the verification tool executing on the test platform may not have full permission to interrogate the test platform for all of its API members.","According to the illustrated embodiment, test phase  may begin when a signature file reader (e.g., ) reads an input signature file (e.g., ) and converts it into a reference model, such as , which is readable by comparator . Reference model  may comprise a representation of the reference API members identified in signature file , but in a format readable by comparator . For example, in some embodiments, reference model  may comprise an in-memory object usable by comparator . In other various embodiments, reference model  may be in any format that is readable by comparator , including the format of the original signature file. Thus, reference model  may comprise a representation of the detectable members of reference API  in a format that is readable by comparator .","In addition to converting signature file  to reference model , test phase  may also include the verification tool deriving a similar model for the test API. For example, the verification tool may utilize a test API scanner (e.g., ) to scan the detectable API members of the platform under test (e.g., test API implementation ).","Recall that since the test platform may comprise a high-security platform, components of the verification tool (e.g., test API scanner ) may have insufficient permissions for scanning some members of test API implementation . Therefore, in some embodiments, test API scanner  may scan only the API members of test API  for which scanner  has permissions (e.g., the detectable members of test API ). For example, if the platform under test comprises a high-security sandbox Java platform, the verification tool (including test API scanner ) may be run in user mode and thus have insufficient permissions for interrogating private, protected, or package level API members. Therefore, in such an embodiment, test API scanner  may be configured to only scan test API  for public API members (i.e., members identified with the \u201cpublic\u201d access modifier). In some embodiments, this may be accomplished by invoking one or more methods of the Java Reflection API for which the verification tool has runtime permissions (e.g., getClasses( ), getConstructors( ), getFields( ), getMethods( ), etc.)","According to the illustrated embodiment of , test API scanner  may produce a test model  that indicates the detectable API members of test API . In some embodiments, test model  may be in the same format as reference model . For example, reference model  and test model  may both be in-memory objects, such as two different instances of the same data type. Thus, according to various embodiments, reference model  may comprise an indication of only the detectable members of reference API implementation  while test model  may comprise an indication of only the detectable members of test API implementation .","According to the illustrated embodiment, comparator  may compare reference model  and test model  to determine whether test model  includes all of the API members of reference model . If the test model does include all of the API members of reference model , then comparator  may determine that test API implementation  implements reference API . Otherwise, if comparator  detects that one or more members of reference model  are not present in test model , it may determine that test API  does not implement reference API .","Comparator  may output the result of its analysis, as in . Result  may include recording the API comparison results to memory and\/or any other computer-readable storage medium (e.g., magnetic disk). In some embodiments, result  may comprise displaying an indication of the result on a computer display. In some embodiments, an indication of the result may be recorded and\/or communicated to a user using various other mechanisms.","In some embodiments, a verification tool (e.g.,  in ) may be built to include some components from other verification tools, such as the SigTest verification utility. In some cases, such component reuse may allow for faster development of different components of the verification tool. For example, the SigTest API verification tool is traditionally executed using a setup phase in which a \u201cgolden signature file\u201d is produced and a subsequent test phase on the test platform, in which the test API is interrogated and compared to the reference API described by the golden signature file. These phases may be analogous in purpose to setup and test phases  and  of . In various embodiments, the setup phase of the SigTest utility may be extended to be used in the API verification of high-security sandbox Java platforms, according to various embodiments.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 4","FIG. 4"],"b":["200","400","410","405","410","415","415","425","420"]},"According to the illustrated embodiment, elements - in  may be components borrowed from and\/or analogous to those of the original SigTest application. Components - may be analogous in purpose to elements - of , but since components - may be borrowed from the SigTest application, unlike -, in the embodiment of , member filtering is not performed based on the ability to detect an API member on the platform under test. For example, in some embodiments, reference API scanner  may be configured to scan for all API members of the reference API implementation , as is done in the traditional SigTest tool. Therefore, reference model  and the resulting golden signature file  may contain both detectable and undetectable members of reference API . As described above, in some embodiments, elements - may be elements of the traditional SigTest tool.","According to the illustrated embodiment, the traditional SigTest setup phase of - may be extended for API verification of high-security sandbox Java platforms, as shown in . According to the illustrated embodiment, the verification tool may include a reader component , which may convert the golden signature file  into a reference model, such as . In some embodiments, reference model  may comprise an in-memory data structure or object.","According to the illustrated embodiment, reference model  may comprise only members of the reference API that are detectable from a high-security test platform, such as the test platform. In some embodiments, reader  may be configured to filter out the API members in golden signature file  that would not be detectable by an API verification utility on the test platform. For example, if the platform under test were a high-security sandbox Java platform, as discussed earlier, reader  may be configured to include only public members of reference API  in reference model . As in , the * symbol is used to denote elements of  that exclude undetectable members of the reference API.","One difficulty with the traditional SigTest workflow, wherein a golden signature file, such as , is used as input to the test phase, is that a reader component for reading the golden signature file (such as  in ) may require special libraries. For example, a reader component may require various text parsing and\/or regular expression utilities that may only be available on a given platform, such as Java 1.5. If such utilities are not available on the test platform, this may cause the SigTest test phase to fail. However, such platforms may still be tested using the embodiment of , since, in the pictured embodiment, the reader component  is executed during the setup phase, which may be on a platform other than the test platform. Thus, even in the case where the test platform does not provide the required utilities for parsing the golden signature file , test phase  may still be executed successfully.","According to the illustrate embodiment, reference model  may be serialized by serializer component  into a flat file, such as serialized reference model . In different embodiments, various serialization mechanisms may be used for converting reference model  to serialized reference model , including standard Java Serialization API. Serialized reference model  may comprise a plain text file and\/or may be usable by a deserializer component to reconstitute an in-memory instance of reference model .","As with signature file  of , serialized reference model  may be distributed to one or more parties for testing different platform implementations. For example, the author of a reference implementation may execute setup phase  to produce a serialized reference model (such as ) and distribute that model to various parties that may use it in verifying the API of different implementations of the platform by executing a test phase, such as  on a platform under test.","According to the illustrated embodiment, a test API implementation (e.g., ) of a platform under test may be verified against a reference API implementation (e.g., ) by executing a test phase such as  on the platform under test with a serialized reference model (e.g., ) as input. According to the illustrated embodiment, a test API scanner  may scan the test API implementation  to detect API members and create test model , which is indicative of the detectable members of test API . The scanning of test API  may be analogous to the scanning of test API  by scanner  in .","According to the illustrated embodiment, serialized reference model  may be given as input to deserializer component , which may use serialized reference model  to reconstitute an in-memory reference model (e.g., ) of the detectable reference API members. Reference model  may then be compared to test model  by a comparator component  and the result recorded and\/or displayed, as in . In various embodiments, the model comparison and output phases of , , , and  may be analogous those of  (, , , and ) and any variations described in regard to the embodiment of  may apply also to those of .",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 5","b":["500","500"]},"Computer system  may include one or more processors , each of which may include multiple cores, any of which may be single or multi-threaded. The computer system  may also include one or more persistent storage devices  (e.g. optical storage, magnetic storage, hard drive, tape drive, solid state memory, etc), which may store one or more of the data products produced for API verification, such as golden signature file . Computer system  may include one or more memories  (e.g., one or more of cache, SRAM, DRAM, RDRAM, EDO RAM, DDR 10 RAM, SDRAM, Rambus RAM, EEPROM, etc.). Computer system  may include one or more display devices  for providing a user interface and\/or reporting results for API verification tests, as described herein. Various embodiments may include fewer or additional components not illustrated in  (e.g., video cards, audio cards, network interfaces, peripheral devices, a network interface such as an ATM interface, an Ethernet interface, a Frame Relay interface, etc.)","The one or more processors , storage device(s) , network interface  and system memories  may be coupled to system interconnect . One or more of the system memories  may contain program instructions . Program instructions  may be encoded in platform native binary, any interpreted language such as Java\u2122 byte-code, or in any other language such as C\/C++, Java\u2122, etc or in any combination thereof.","Program instructions  may include program instructions executable to implement one or more API verification tools and\/or components  for performing API verification of high-security platforms, as described herein. In some embodiments, API verification tool  may be implemented as an application or utility for implementing the setup and\/or test phases of the API verification process, as described herein. The API verification tool  may contain various components no pictured in , such as API scanners, readers, serializers, deserializers, comparators, output modules, etc., as described herein.","According to the illustrated embodiment, memory  may also comprise program instructions executable to implement a reference platform implementation  and\/or a high-security test platform . In some embodiments, the computer system would contain only reference platform  or only high-security test platform . Program instructions  may also include one or more operating systems , such as Windows\u2122, Solaris\u2122, Linux, etc.","The API verification systems as described herein may be provided as a computer program product, or software, that may include a computer-readable storage medium having stored thereon instructions, which may be used to program a computer system (or other electronic devices) to perform a process according to various embodiments. A computer-readable storage medium may include any mechanism for storing information in a form (e.g., software, processing application) readable by a machine (e.g., a computer). The machine-readable storage medium may include, but is not limited to, magnetic storage medium (e.g., floppy diskette); optical storage medium (e.g., CD-ROM); magneto-optical storage medium; read only memory (ROM); random access memory (RAM); erasable programmable memory (e.g., EPROM and EEPROM); flash memory; electrical, or other types of medium suitable for storing program instructions. In addition, program instructions may be communicated using optical, acoustical or other form of propagated signal (e.g., carrier waves, infrared signals, digital signals, etc.)","Although the embodiments above have been described in considerable detail, numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
