---
title: Optimizing communication of system call requests
abstract: Provided herein is a method for optimizing communication for system calls. The method includes storing a system call for each work item in a wavefront and transmitting said stored system calls to a processor for execution. The method also includes receiving a result to each work item in the wavefront responsive to said transmitting.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08752064&OS=08752064&RS=08752064
owner: Advanced Micro Devices, Inc.
number: 08752064
owner_city: Sunnyvale
owner_country: US
publication_date: 20111130
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY OF EMBODIMENTS","DETAILED DESCRIPTION"],"p":["This application claims the benefit of U.S. Provisional Application No. 61\/422,953, filed on Dec. 14, 2010, which is incorporated herein by reference in its entirety.","1. Field of the Invention","The present invention is generally directed to computing systems. More particularly, the present invention is directed to an architecture for unifying the computational components within a computing system.","2. Background Art","The desire to use a graphics processing unit (GPU) for general computation has become much more pronounced recently due to the GPU's exemplary performance per unit power and\/or cost. The computational capabilities for GPUs, generally, have grown at a rate exceeding that of the corresponding central processing unit (CPU) platforms. This growth, coupled with the explosion of the mobile computing market and its necessary supporting server\/enterprise systems, has been used to provide a specified quality of desired user experience. Consequently, the combined use of CPUs and GPUs for executing workloads with data parallel content is becoming a volume technology.","However, GPUs have traditionally operated in a constrained programming environment, available only for the acceleration of graphics. These constraints arose from the fact that GPUs did not have as rich a programming ecosystem as CPUs. Their use, therefore, has been mostly limited to two dimensional (2D) and three dimensional (3D) graphics and a few leading edge multimedia applications, which are already accustomed to dealing with graphics and video application programming interfaces (APIs).","With the advent of multi-vendor supported OpenCL\u00ae and DirectCompute\u00ae, standard APIs and supporting tools, the limitations of the GPUs in traditional applications has been extended beyond traditional graphics. Although OpenCL and DirectCompute are a promising start, there are many hurdles remaining to creating an environment and ecosystem that allows the combination of the CPU and GPU to be used as fluidly as the CPU for most programming tasks.","Existing computing systems often include multiple processing devices. For example, some computing systems include both a CPU and a GPU on separate chips (e.g., the CPU might be located on a motherboard and the GPU might be located on a graphics card) or in a single chip package. Both of these arrangements, however, still include significant challenges associated with (i) separate memory systems, (ii) efficient scheduling, (iii) providing quality of service (QoS) guarantees between processes, (iv) programming model, and (v) compiling to multiple target instruction set architectures (ISAs)\u2014all while minimizing power consumption.","For example, the discrete chip arrangement forces system and software architects to utilize chip to chip interfaces for each processor to access memory. While these external interfaces (e.g., chip to chip) negatively affect memory latency and power consumption for cooperating heterogeneous processors, the separate memory systems (i.e., separate address spaces) and driver managed shared memory create overhead that becomes unacceptable for fine grain offload.","In another example, some commands cannot execute on a GPU efficiently. For example, a GPU cannot effectively execute commands which involve an operating system (\u201cOS\u201d) such as, for example, instructions that allocate memory or printing data to a computer screen can only be processed using a CPU. Because the GPU cannot perform these tasks, the GPU makes a request to the CPU to perform those tasks. These requests are known as system calls (syscalls).","Syscalls are expensive for the CPU to process. Often, syscalls are high-priority commands that require CPU's immediate attention. Each time the CPU receives a syscall request, the CPU stops processing its current processes, invokes the OS, processes the syscall, and then returns to processing its work.","When a GPU processes a wavefront, each work item can require a syscall for memory allocation or other instructions that the GPU cannot process (or cannot process readily). In a conventional system, a GPU makes a separate syscall request to the CPU for each work item. Because the work items execute in parallel, each work item makes the same syscall request to the CPU.","Each time a syscall request arrives to the CPU, the CPU stops processing its work, invokes the OS, processes the GPU's request, and returns to processing its own work. When multiple work items make separate syscall requests at the same time, the CPU wastes processing time as repeatedly pauses its own work, invokes the OS and attempts to processes syscall requests from the GPU.","What is needed, therefore, are systems and methods for optimizing (i.e., improving) communication between a CPU and a GPU involving syscalls.","Although GPUs, accelerated processing units (APUs), and general purpose use of the graphics processing unit (GPGPU) are commonly used terms in this field, the expression \u201caccelerated processing device (APD)\u201d is considered to be a broader expression. For example, APD refers to any cooperating collection of hardware and\/or software that performs those functions and computations associated with accelerating graphics processing tasks, data parallel tasks, or nested data parallel tasks in an accelerated manner with respect to resources such as conventional CPUs, conventional GPUs, and\/or combinations thereof.","Embodiments of the present invention include a system, method and article of manufacture for optimizing communication for system calls. The method includes storing a system call for each work item in a wavefront and transmitting said stored system calls to a processor for execution. The method also includes responsive to said transmitting, receiving a result to each work item in the wavefront.","Further features and advantages of the invention, as well as the structure and operation of various embodiments of the invention, are described in detail below with reference to the accompanying drawings. It is noted that the invention is not limited to the specific embodiments described herein. Such embodiments are presented herein for illustrative purposes only. Additional embodiments will be apparent to persons skilled in the relevant art(s) based on the teachings contained herein.","In the detailed description that follows, references to \u201cone embodiment,\u201d \u201can embodiment,\u201d \u201can example embodiment,\u201d etc., indicate that the embodiment described may include a particular feature, structure, or characteristic, but every embodiment may not necessarily include the particular feature, structure, or characteristic. Moreover, such phrases are not necessarily referring to the same embodiment. Further, when a particular feature, structure, or characteristic is described in connection with an embodiment, it is submitted that it is within the knowledge of one skilled in the art to affect such feature, structure, or characteristic in connection with other embodiments whether or not explicitly described.","The term \u201cembodiments of the invention\u201d does not require that all embodiments of the invention include the discussed feature, advantage or mode of operation. Alternate embodiments may be devised without departing from the scope of the invention, and well-known elements of the invention may not be described in detail or may be omitted so as not to obscure the relevant details of the invention. In addition, the terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. For example, as used herein, the singular forms \u201ca\u201d, \u201can\u201d and \u201cthe\u201d are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms \u201ccomprises,\u201d \u201ccomprising,\u201d \u201cincludes\u201d and\/or \u201cincluding,\u201d when used herein, specify the presence of stated features, integers, steps, operations, elements, and\/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and\/or groups thereof.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1A","b":["100","102","104","102","100","102","104","104","102","102","104"]},"In one example, system  also includes a memory , an operating system , and a communication infrastructure . The operating system  and the communication infrastructure  are discussed in greater detail below.","The system  also includes a kernel mode driver (KMD) , a software scheduler (SWS) , and a memory management unit , such as input\/output memory management unit (IOMMU). Components of system  can be implemented as hardware, firmware, software, or any combination thereof. A person of ordinary skill in the art will appreciate that system  may include one or more software, hardware, and firmware components in addition to, or different from, that shown in the embodiment shown in .","In one example, a driver, such as KMD , typically communicates with a device through a computer bus or communications subsystem to which the hardware connects. When a calling program invokes a routine in the driver, the driver issues commands to the device. Once the device sends data back to the driver, the driver may invoke routines in the original calling program. In one example, drivers are hardware-dependent and operating-system-specific. They usually provide the interrupt handling required for any necessary asynchronous time-dependent hardware interface. Device drivers, particularly on modern Windows platforms, can run in kernel-mode (Ring 0) or in user-mode (Ring 3).","A benefit of running a driver in user mode is improved stability, since a poorly written user mode device driver cannot crash the system by overwriting kernel memory. On the other hand, user\/kernel-mode transitions usually impose a considerable performance overhead, thereby prohibiting user mode-drivers for low latency and high throughput requirements. Kernel space can be accessed by user modules only through the use of system calls. End user programs like the UNIX shell or other GUI based applications are part of the user space. These applications interact with hardware through kernel supported functions.","CPU  can include (not shown) one or more of a control processor, field programmable gate array (FPGA), application specific integrated circuit (ASIC), or digital signal processor (DSP). CPU , for example, executes the control logic, including the operating system , KMD , SWS , and applications , that control the operation of computing system . In this illustrative embodiment, CPU , according to one embodiment, initiates and controls the execution of applications  by, for example, distributing the processing associated with that application across the CPU  and other processing resources, such as the APD .","APD , among other things, executes commands and programs for selected functions, such as graphics operations and other operations that may be, for example, particularly suited for parallel processing. In general, APD  can be frequently used for executing graphics pipeline operations, such as pixel operations, geometric computations, and rendering an image to a display. In various embodiments of the present invention, APD  can also execute compute processing operations, based on commands or instructions received from CPU .","For example, commands can be considered a special instruction that is not defined in the ISA and usually accomplished by a set of instructions from a given ISA or a unique piece of hardware. A command may be executed by a special processor such as a dispatch processor, command processor, or network controller. On the other hand, instructions can be considered, e.g., a single operation of a processor within a computer architecture. In one example, when using two sets of ISAs, some instructions are used to execute x86 programs and some instructions are used to execute kernels on APD\/GPU compute unit.","In an illustrative embodiment, CPU  transmits selected commands to APD . These selected commands can include graphics commands and other commands amenable to parallel execution. These selected commands, that can also include compute processing commands, can be executed substantially independently from CPU .","APD  can include its own compute units (not shown), such as, but not limited to, one or more single instruction multiple data (SIMD) processing cores. As referred to herein, a SIMD is a math pipeline, or programming model, where a kernel is executed concurrently on multiple processing elements each with its own data and a shared program counter. All processing elements execute a strictly identical set of instructions. The use of predication enables work-items to participate or not for each issued command.","In one example, each APD  compute unit can include one or more scalar and\/or vector floating-point units and\/or arithmetic and logic units (ALUs). The APD compute unit can also include special purpose processing units (not shown), such as inverse-square root units and sine\/cosine units. In one example, the APD compute units are referred to herein collectively as shader core .","Having one or more SIMDs, in general, makes APD  ideally suited for execution of data-parallel tasks such as are common in graphics processing.","Some graphics pipeline operations, such as pixel processing, and other parallel computation operations, can require that the same command stream or compute kernel be performed on streams or collections of input data elements. Respective instantiations of the same compute kernel can be executed concurrently on multiple compute units in shader core  in order to process such data elements in parallel. As referred to herein, for example, a compute kernel is a function containing instructions declared in a program and executed on an APD\/GPU compute unit. This function is also referred to as a kernel, a shader, a shader program, or a program.","In one illustrative embodiment, each compute unit (e.g., SIMD processing core) can execute a respective instantiation of a particular work-item to process incoming data. A work-item is one of a collection of parallel executions of a kernel invoked on a device by a command. A work-item can be executed by one or more processing elements as part of a work-group executing on a compute unit.","A work-item is distinguished from other executions within the collection by its global ID and local ID. In one example, a subset of work-items in a workgroup that execute simultaneously together on a single SIMD engine can be referred to as a wavefront . The width of a wavefront is a characteristic of the hardware SIMD engine. As referred to herein, a workgroup is a collection of related work-items that execute on a single compute unit. The work-items in the group execute the same kernel and share local memory and work-group barriers.","All wavefronts from a workgroup are processed on the same SIMD engine. Instructions across a wavefront are issued one at a time, and when all work-items follow the same control flow, each work-item executes the same program. An execution mask and work-item predication are used to enable divergent control flow within a wavefront, where each individual work-item can actually take a unique code path through the kernel. Partially populated wavefronts can be processed when a full set of work-items is not available at wavefront start time. Wavefronts can also be referred to as warps, vectors, or threads.","Commands can be issued one at a time for the wavefront. When all work-items follow the same control flow, each work-item can execute the same program. In one example, an execution mask and work-item predication are used to enable divergent control flow where each individual work-item can actually take a unique code path through a kernel driver. Partial wavefronts can be processed when a full set of work-items is not available at start time. For example, shader core  can simultaneously execute a predetermined number of wavefronts , each wavefront  comprising a predetermined number of work-items.","Within the system , APD  includes its own memory, such as graphics memory . Graphics memory  provides a local memory for use during computations in APD . Individual compute units (not shown) within shader core  can have their own local data store (not shown). In one embodiment, APD  includes access to local graphics memory , as well as access to the memory . In another embodiment, APD  can include access to dynamic random access memory (DRAM) or other such memories (not shown) attached directly to the APD  and separately from memory .","In the example shown, APD  also includes one or (n) number of command processors (CPs) . CP  controls the processing within APD . CP  also retrieves commands to be executed from command buffers  in memory  and coordinates the execution of those commands on APD .","In one example, CPU  inputs commands based on applications  into appropriate command buffers . As referred to herein, an application is the combination of the program parts that will execute on the compute units within the CPU and APD.","A plurality of command buffers  can be maintained with each process scheduled for execution on the APD .","CP  can be implemented in hardware, firmware, or software, or a combination thereof. In one embodiment, CP  is implemented as a reduced instruction set computer (RISC) engine with microcode for implementing logic including scheduling logic.","APD  also includes one or (n) number of dispatch controllers (DCs) . In the present application, the term dispatch refers to a command executed by a dispatch controller that uses the context state to initiate the start of the execution of a kernel for a set of workgroups on a set of compute units. DC  includes logic to initiate workgroups in the shader core . In some embodiments, DC  can be implemented as part of CP .","System  also includes a hardware scheduler (HWS)  for selecting a process from a run list  for execution on APD . HWS  can select processes from run list  using round robin methodology, priority level, or based on other scheduling policies. The priority level, for example, can be dynamically determined. HWS  can also include functionality to manage the run list , for example, by adding new processes and by deleting existing processes from run-list . The run list management logic of HWS  is sometimes referred to as a run list controller (RLC).","In various embodiments of the present invention, when HWS  initiates the execution of a process from RLC , CP  begins retrieving and executing commands from the corresponding command buffer . In some instances, CP  can generate one or more commands to be executed within APD , which correspond with commands received from CPU . In one embodiment, CP , together with other components, implements a prioritizing and scheduling of commands on APD  in a manner that improves or maximizes the utilization of the resources of APD  and\/or system .","APD  can have access to, or may include, an interrupt generator . Interrupt generator  can be configured by APD  to interrupt the operating system  when interrupt events, such as page faults, are encountered by APD . For example, APD  can rely on interrupt generation logic within IOMMU  to create the page fault interrupts noted above.","APD  can also include preemption and context switch logic  for preempting a process currently running within shader core . Context switch logic , for example, includes functionality to stop the process and save its current state (e.g., shader core  state, and CP  state).","As referred to herein, the term state can include an initial state, an intermediate state, and a final state. An initial state is a starting point for a machine to process an input data set according to a program in order to create an output set of data. There is an intermediate state, for example, that needs to be stored at several points to enable the processing to make forward progress. This intermediate state is sometimes stored to allow a continuation of execution at a later time when interrupted by some other process. There is also final state that can be recorded as part of the output data set","Preemption and context switch logic  can also include logic to context switch another process into the APD . The functionality to context switch another process into running on the APD  may include instantiating the process, for example, through the CP  and DC  to run on APD , restoring any previously saved state for that process, and starting its execution.","Memory  can include non-persistent memory such as DRAM (not shown). Memory  can store, e.g., processing logic instructions, constant values, and variable values during execution of portions of applications or other processing logic. For example, in one embodiment, parts of control logic to perform one or more operations on CPU  can reside within memory  during execution of the respective portions of the operation by CPU . The term \u201cprocessing logic\u201d or \u201clogic,\u201d as used herein, refers to control flow commands, commands for performing computations, and commands for associated access to resources.","During execution, respective applications, operating system functions, processing logic commands, and system software can reside in memory . Control logic commands fundamental to operating system  will generally reside in memory  during execution. Other software commands, including, for example, KMD  and software scheduler  can also reside in memory  during execution of system .","In this example, memory  includes command buffers  that are used by CPU  to send commands to APD . Memory  also contains process lists and process information (e.g., active list  and process control blocks ). These lists, as well as the information, are used by scheduling software executing on CPU  to communicate scheduling information to APD  and\/or related scheduling hardware. Access to memory  can be managed by a memory controller , which is coupled to memory . For example, requests from CPU , or from other devices, for reading from or for writing to memory  are managed by the memory controller .","Referring back to other aspects of system , IOMMU  is a multi-context memory management unit.","As used herein, context (sometimes referred to as process) can be considered the environment within which the kernels execute and the domain in which synchronization and memory management is defined. The context includes a set of devices, the memory accessible to those devices, the corresponding memory properties and one or more command-queues used to schedule execution of a kernel(s) or operations on memory objects. On the other hand, process can be considered the execution of a program for an application will create a process that runs on a computer. The operating system can create data records and virtual memory address spaces for the program to execute. The memory and current state of the execution of the program can be called a process. The operating system will schedule tasks for the process to operate on the memory from an initial to final state.","Referring back to the example shown in , IOMMU  includes logic to perform virtual to physical address translation for memory page access for devices including APD . IOMMU  may also include logic to generate interrupts, for example, when a page access by a device such as APD  results in a page fault. IOMMU  may also include, or have access to, a translation lookaside buffer (TLB) . TLB , as an example, can be implemented in a content addressable memory (CAM) to accelerate translation of logical (i.e., virtual) memory addresses to physical memory addresses for requests made by APD  for data in memory .","In the example shown, communication infrastructure  interconnects the components of system  as needed. Communication infrastructure  can include (not shown) one or more of a peripheral component interconnect (PCI) bus, extended PCI (PCI-E) bus, advanced microcontroller bus architecture (AMBA) bus, accelerated graphics port (AGP), or such communication infrastructure. Communications infrastructure  can also include an Ethernet, or similar network, or any suitable physical communications infrastructure that satisfies an application's data transfer rate requirements. Communication infrastructure  includes the functionality to interconnect components including components of computing system .","In this example, operating system  includes functionality to manage the hardware components of system  and to provide common services. In various embodiments, operating system  can execute on CPU  and provide common services. These common services can include, for example, scheduling applications for execution within CPU , fault management, interrupt service, as well as processing the input and output of other applications.","In some embodiments, based on interrupts generated by an interrupt controller, such as interrupt controller , operating system  invokes an appropriate interrupt handling routine. For example, upon detecting a page fault interrupt, operating system  may invoke an interrupt handler to initiate loading of the relevant page into memory  and to update corresponding page tables.","Operating system  may also include functionality to protect system  by ensuring that access to hardware components is mediated through operating system managed kernel functionality. In effect, operating system  ensures that applications, such as applications , run on CPU  in user space. Operating system  also ensures that applications  invoke kernel functionality provided by the operating system to access hardware and\/or input\/output functionality.","By way of example, applications  include various programs or commands to perform user computations that are also executed on CPU . The unification concepts can allow CPU  to seamlessly send selected commands for processing on the APD . Under this unified APD\/CPU framework, input\/output requests from applications  will be processed through corresponding operating system functionality.","In one example, KMD  implements an application program interface (API) through which CPU , or applications executing on CPU  or other logic, can invoke APD  functionality. For example, KMD  can enqueue commands from CPU  to command buffers  from which APD  will subsequently retrieve the commands. Additionally, KMD  can, together with SWS , perform scheduling of processes to be executed on APD . SWS , for example, can include logic to maintain a prioritized list of processes to be executed on the APD.","In other embodiments of the present invention, applications executing on CPU  can entirely bypass KMD  when enqueuing commands.","In some embodiments, SWS  maintains an active list  in memory  of processes to be executed on APD . SWS  also selects a subset of the processes in active list  to be managed by HWS  in the hardware. Information relevant for running each process on APD  is communicated from CPU  to APD  through process control blocks (PCB) .","Processing logic for applications, operating system, and system software can include commands specified in a programming language such as C and\/or in a hardware description language such as Verilog, RTL, or netlists, to enable ultimately configuring a manufacturing process through the generation of maskworks\/photomasks to generate a hardware device embodying aspects of the invention described herein.","A person of skill in the art will understand, upon reading this description, that computing system  can include more or fewer components than shown in . For example, computing system  can include one or more input interfaces, non-volatile storage, one or more output interfaces, network interfaces, and one or more displays or display interfaces.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 1B","FIG. 1A","FIG. 1B","FIG. 1A","FIG. 1B"],"b":["104","124","124","124","124","124","125","0","124","162","1","2","124","124","160","166","128"],"i":["a","b","c","a","b ","c"]},"In , graphics pipeline  can include a set of blocks, referred to herein as ordered pipeline . As an example, ordered pipeline  includes a vertex group translator (VGT) , a primitive assembler (PA) , a scan converter (SC) , and a shader-export, render-back unit (SX\/RB) . Each block within ordered pipeline  may represent a different stage of graphics processing within graphics pipeline . Ordered pipeline  can be a fixed function hardware pipeline. Although other implementations that would be within the spirit and scope of the present invention can be used.","Although only a small amount of data may be provided as an input to graphics pipeline , this data will be amplified by the time it is provided as an output from graphics pipeline . Graphics pipeline  also includes DC  for counting through ranges within work-item groups received from CP pipeline . Compute work submitted through DC  is semi-synchronous with graphics pipeline .","Compute pipeline  includes shader DCs  and . Each of the DCs is configured to count through compute ranges within work groups received from CP pipelines and ","The DCs , , and , illustrated in , receive the input ranges, break the ranges down into workgroups, and then forward the workgroups to shader core .","Since graphics pipeline  is generally a fixed function pipeline, it is difficult to save and restore its state, and as a result, the graphics pipeline  is difficult to context switch. Therefore, in most cases context switching, as discussed herein, does not pertain to context switching among graphics processes. The exception is for graphics work in shader core , which can be context switched.","Shader core  can be shared by graphics pipeline  and compute pipeline . Shader core  can be a general processor configured to run wavefronts.","In one example, all work within compute pipeline  is processed within shader core . Shader core  runs programmable software code and includes various forms of data, such as state data. Compute pipeline , however, does not send work to graphics pipeline  for processing. After processing of work within graphics pipeline  has been completed, the completed work is processed through a render back unit , which does depth and color calculations, and then writes its final results to graphics memory .","It would be apparent to one of skill in the art that the present invention, as described below, can be implemented in many different embodiments of software, hardware, firmware, and\/or the entities illustrated in the figures. Any actual software code with the specialized control of hardware to implement the present invention is not limiting of the present invention. Thus, the operational behavior of the present invention will be described with the understanding that modifications and variations of the embodiments are possible, given the level of detail presented herein.","Additionally, and as will be apparent to one of skill in the art, the simulation, synthesis and\/or manufacture of the various embodiments of this invention may be accomplished, in part, through the use of computer-readable code (as noted above), including general programming languages (such as C or C++), hardware description languages (HDL) including Verilog HDL, VHDL, Altera HDL (AHDL) and so on, or other available programming and\/or schematic capture tools (such as circuit capture tools). This computer-readable code can be disposed in any known computer usable medium including semiconductor, magnetic disk, optical disk (such as CD-ROM, DVD-ROM) and as a computer data signal embodied in a computer-usable (e.g., readable) transmission medium (such as a carrier wave or any other medium including digital, optical, or analog-based medium).","As such, the code can be transmitted over communication networks including the Internet and intranets. It is understood that the functions accomplished and\/or structure provided by the systems and techniques described above can be represented in a core (such as an APD core and\/or a CPU core) that is embodied in program code and may be transformed to hardware as part of the production of integrated circuits.","Embodiments of the present invention allow programmers to write applications that seamlessly transition processing of data between CPUs and APDs, benefiting from the best attributes each has to offer. A unified single programming platform can provide a strong foundation for development in languages, frameworks, and applications that exploit parallelism.","The embodiments of the present invention allow programmers to write applications that seamlessly transition processing of data between CPUs and APDs, benefiting from the best attributes each has to offer. A unified single programming platform can provide a strong foundation for development in languages, frameworks, and applications that exploit parallelism.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 2","b":["200","200","136","208","210"]},"Wavefronts  are processed sequentially by shader cores . Each wavefront includes multiple work items . Each work item  is assigned a task or a portion of a task to process. Shader core  processes work items  in wavefront  in parallel and with the same set of instructions. As a result, each work item  in wavefront  may issue a syscall to CPU  at the same time.","Unlike conventional systems, where an APD separately sends a syscall request from each work item to a CPU, APD  sends a request using a SIMD vector  thus grouping the syscall requests into a single data structure. SIMD vector  includes SIMD elements . Each SIMD elements includes a syscall data structure. The syscall data structure includes a function selector parameter (a particular syscall request), a list of arguments, and a memory space to return a result of the syscall request to APD . One embodiment, an exemplary syscall data structure, is described herein.","When work items  require a process that involves an OS, APD  stores a syscall request from each work item  in a corresponding SIMD element . For example, in , work item WI stores syscall SC in SIMD element , work item WI stores syscall SC in another SIMD element , and so forth. APD  saves the type of the syscall request from each work item  into the function selector parameter. APD  can also insert a list of arguments in the argument list section, if needed. APD  can also store syscalls from work items from multiple wavefronts  in one SIMD vector .","Queue  is a high-priority public memory queue. A queue operates according to the first-in, first-out (\u201cFIFO\u201d) principle. A public queue is a queue visible to CPU  and APD  processors. Namely, the workload that are first enqueued onto a queue, is the workload that are first dequeued from a queue. Additionally, a person skilled in the art will appreciate that example using a queue data structure is given by way of example and not limitation and that other data structures for may be used.","APD  enqueues queue  with SIMD vector . After APD  enqueues SIMD vector , in one embodiment APD stalls and waits for CPU  to process SIMD vector  (i.e., receive the SIMD vector , process the syscalls stored therein and transmit the results of each syscall to APD ). In another embodiment, after APD  enqueues queue , APD  saves the state of the wavefront in memory  and begins to process another wavefront. When APD  receives a signal from CPU  that the processing is complete, APD  retrieves the original wavefront  from memory  and reinstates the processing.","CPU  processes tasks received form a high-priority queue ahead of its other processes. Thus, when CPU  receives a request from a high-priority queue, such as queue , it saves its current process and processes the received request. The example using a high-priority public queue described herein is given by way of example, and not limitation, and a person skilled in the art will appreciate that other memory storage structures can be used.","CPU  dequeues SIMD vector  from queue  and begins to processes SIMD elements . CPU  invokes an OS and begins to processes the syscall requests stored in the function selector parameter in each SIMD element . CPU  also reads the argument list stored in SIMD element , if required. After CPU  completes each syscall request, CPU  writes the result into a memory address allocated in each SIMD element .","After CPU  completes processing all SIMD elements , in one embodiment, it enqueues SIMD vector  onto a queue  and returns SIMD vector  to APD . Typically, CPU  enqueues SIMD vector  onto a memory queue  that is visible to APD .","In another embodiment, when CPU  completes processing SIMD vector , it sends a signal to APD  using a semaphore mechanism. A person skilled in the art will appreciate that a semaphore mechanism ensures that APD  does not process other wavefronts while it waits for CPU  to complete processing requested syscalls.","After APD  dequeues SIMD vector  or receives a signal from CPU  that syscalls were processed, APD  begins to process the wavefront  using the results of the requested syscall. In an embodiment where APD  can process another wavefront while waiting for CPU to process SIMD vector , APD  retrieves wavefront  from APD memory , prior to continuing processing.","One example of a syscall can be a request for memory, such as a malloc( ) function. A malloc( ) request allocates memory for a particular process or function in system memory . APD  cannot process a malloc( ) request because APD  does not have access to an OS. APD , therefore, sends a syscall for a malloc( ) request to CPU .","APD  makes a malloc( ) request when work item  in wavefront  requests memory. Unlike conventional systems, where an APD sends a separate malloc( ) request from each work item to a CPU, APD  sends one SIMD vector  to CPU  that includes a malloc( ) request for each working item  in wavefront . APD  stores information necessary for a malloc( ) request for each work item in a corresponding SIMD element . The necessary information includes a function selector, which is a memory address to the malloc( ) function, a list of arguments, which includes a memory size that CPU  needs to allocate to each work item , and an empty parameter where CPU  stores the address of the allocated space.","Once each work item includes malloc( ) parameters necessary to process each syscall, APD  enqueues SIMD vector  onto queue  as described herein. CPU  retrieves SIMD vector  from queue , and begins to process SIMD elements . When CPU  processes the malloc( ) requests in SIMD vector , CPU  makes one call to the OS. CPU  then proceeds to allocate memory for each work item  in the call to OS. Subsequently, CPU , stores the address to the memory space allocated for each work item  in SIMD element . After CPU  completes all syscall requests, CPU  returns the SIMD vector  to APD .","SIMD elements  include multiple structures for passing syscalls to CPU . In one embodiment, each SIMD element  can include a data structure for storing the function selector parameter, the argument list, and the result of the syscall. In a non-limiting example, an exemplary data structure is described as:",{"@attributes":{"id":"p-0099","num":"0098"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","struct MyTask {"]},{"entry":[{},"\u2002MyPtr _myCodePtr"]},{"entry":[{},"\u2003\u2002\u2002\u2002myCPUCodePtr : pointer to code (e.g., x86 binary format)"]},{"entry":[{},"\u2003\u2002\u2002\u2002myAPDCodePtr :"]},{"entry":[{},"\u2003\u2003\u2002\u2002\u2002\u2002\/\/GPR usage in kernel"]},{"entry":[{},"\u2003\u2003\u2002\u2002\u2002\u2002\/\/LDS required by kernel"]},{"entry":[{},"\u2003\u2003\u2002\u2002\u2002\u2002\/\/Pointer to code (e.g., shader binary format)"]},{"entry":[{},"\u2003\u2003\u2002\u2002\u2002\u2002\/\/other parameters"]},{"entry":[{},"\u2002MyPtr _myDataPtr :"]},{"entry":[{},"\u2003\u2002\u2002\u2002myExecRange:"]},{"entry":[{},"\u2003\u2003\u2002\u2002\u2002\u2002\/\/Global grid dimensions"]},{"entry":[{},"\u2003\u2003\u2002\u2002\u2002\u2002\/\/Local grid dimensions"]},{"entry":[{},"\u2003\u2002\u2002\u2002myArgSize"]},{"entry":[{},"\u2003\u2002\u2002\u2002myArgs {(variable size)}"]},{"entry":[{},"\u2002MyNotification"]},{"entry":[{},"\u2002\u2002\/\/Notification mechanism"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The MyTask structure includes a MyPtr myAPDCodePtr pointer for processing instructions on APD , a MyPtr myCPUCodePtr pointer for processing instructions on CPU , and a data pointer myPtr_myDataPtr. When work item  requests a syscall from CPU , the myAPDCodePtr and myCPUCodePtr pointers point to the memory address of a particular syscall function. The mtDataPtr pointer includes parameters for the argument list and a pointer to the memory address in main memory  that contains the result of each syscall.","Additionally, the MyTask structure includes an MyNotification mechanism. APD  uses the notification mechanism to notify CPU  that MyTask exists in queue  that requires processing. Similarly, CPU , uses the MyNotification to notify APD  that CPU  completed processing the syscall.",{"@attributes":{"id":"p-0102","num":"0101"},"figref":"FIG. 3","b":["200","100","206","302","104","206","204","136","102","304","204","208","306","104","206","210","308","102","206","210","102","206","102","208"]},"At step , CPU  writes the result of each syscall into SIMD element . A person skilled in the art will appreciate that step  may be performed with step . At step , CPU  notifies APD  that syscalls have been processed. In one embodiment, CPU  sends the SIMD vector  back to APD , using queue  visible to APD . In another embodiment, CPU  signals APD  using a semaphore. At step , APD  dequeues SIMD vector  from queue  and continues to process wavefront .","Various aspects of the present invention can be implemented by software, firmware, hardware, or a combination thereof. For example, the methods illustrated by flowchart  of  can be implemented in unified computing system  of . Various embodiments of the invention are described in terms of this example unified computing system . It would be apparent to a person skilled in the relevant art how to implement the invention using other computer systems and\/or computer architectures.","In this document, the terms \u201ccomputer program medium\u201d and \u201ccomputer-usable medium\u201d are used to generally refer to media such as a removable storage unit or a hard disk drive. Computer program medium and computer-usable medium can also refer to memories, such as system memory  and graphics memory , which can be memory semiconductors (e.g., DRAMs, etc.). These computer program products are means for providing software to unified computing system .","The invention is also directed to computer program products comprising software stored on any computer-usable medium. Such software, when executed in one or more data processing devices, causes a data processing device(s) to operate as described herein or, as noted above, allows for the synthesis and\/or manufacture of computing devices (e.g., ASICs, or processors) to perform embodiments of the present invention described herein. Embodiments of the invention employ any computer-usable or -readable medium, known now or in the future. Examples of computer-usable mediums include, but are not limited to, primary storage devices (e.g., any type of random access memory), secondary storage devices (e.g., hard drives, floppy disks, CD ROMS, ZIP disks, tapes, magnetic storage devices, optical storage devices, MEMS, nanotechnological storage devices, etc.), and communication mediums (e.g., wired and wireless communications networks, local area networks, wide area networks, intranets, etc.).","While various embodiments of the present invention have been described above, it should be understood that they have been presented by way of example only, and not limitation. It will be understood by those skilled in the relevant art that various changes in form and details can be made therein without departing from the spirit and scope of the invention as defined in the appended claims. It should be understood that the invention is riot limited to these examples. The invention is applicable to any elements operating as described herein. Accordingly, the breadth and scope of the present invention should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS\/FIGURES","p":["The accompanying drawings, which are incorporated herein and form part of the specification, illustrate the present invention and, together with the description, further serve to explain the principles of the invention and to enable a person skilled in the pertinent art to make and use the invention. Various embodiments of the present invention are described below with reference to the drawings, wherein like reference numerals are used to refer to like elements throughout.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 1B","FIG. 1A"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2","b":"200"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3","b":"300"}]},"DETDESC":[{},{}]}
