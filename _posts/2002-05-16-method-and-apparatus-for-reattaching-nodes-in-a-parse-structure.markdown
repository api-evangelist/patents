---
title: Method and apparatus for reattaching nodes in a parse structure
abstract: A method is provided for forming a reconstructed parse structure for an initial parse structure. Under the method, at least one rule used to form the initial parse structure and at least one additional rule are executed to form the reconstructed parse structure. In many embodiments, the reconstructed parse structure differs from the initial parse structure in that a node is located in a different position in the reconstructed parse structure than in the initial parse structure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07634398&OS=07634398&RS=07634398
owner: Microsoft Corporation
number: 07634398
owner_city: Redmond
owner_country: US
publication_date: 20020516
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS"],"p":["The present invention relates to natural language processing. In particular, the present invention relates to syntactic parsing of text.","A natural language parser is a program that takes a text segment, usually a sentence, of natural language (i.e., human language, such as English) and produces a data structure, usually referred to as a parse tree. This parse tree typically represents the syntactic relationships between the words in the input segment.","In general, natural language parsers build the parse trees by applying syntax rules to the input text segment. Parsers apply these rules in either a \u201ctop-down\u201d or a \u201cbottom-up\u201d manner.","In a bottom-up parser, all of the possible parts of speech for the individual words of the input text are first identified to form a set of word tokens. The parser then attempts to combine the individual word tokens into larger syntactic structures, such as noun phrases and verb phrases, by applying syntax rules to the tokens. The resulting larger structures represent candidate nodes for the parse tree. The parser continues to try to build larger and larger structures by applying syntactic rules to previously identified candidate nodes. A full parse is achieved when a node spans the entire text segment.","During the construction of the nodes, attribute-value pairs that describe the structure represented by the node are created. For example, a first token attribute and a last token attribute are associated with each node to indicate the first token and the last token that the node spans. Additionally, attributes such as \u201chead\u201d, which indicate the primary element of a noun phrase or a verb phrase, and \u201cpsmods\u201d, which indicates the modifiers found after the head can be included for a node. The number and type of attributes that are associated with a node is unlimited and is controlled by the rule used to form the node.","The computational complexity of forming the parse is a function of the number of candidate nodes that are formed. To limit the number of candidate nodes, some systems adopt a minimal attachment strategy that prevents certain candidate nodes from being formed if other candidate nodes have already been formed or are expected to be formed.","Although this minimal attachment strategy reduces the complexity of forming an initial parse structure, it can result in parse trees that are less than optimal. To address this, many parsing systems walk through the initial parse tree to determine if it can be changed to provide a better parse.","One technique for improving a parse is to move a node in the parse tree to a different location within the tree. In the past, such reattachment was performed by executing a set of rules and functions to change the attribute-value pairs of the nodes affected by the reattachment so that the attribute-value pairs reflected the new location for the moved attribute-value pairs, they are different from the rules and functions used to form the initial parse tree. As a result, when attribute-value pairs are added or altered by a parse rule or when the use of attribute-value pairs changes, the rules and functions used to reattach nodes must be modified separately. This can create errors in the parser system as a whole and increases the cost of improving the parser.","As such, a reattachment method is needed that does not require separate rules for reattachment.","A method is provided for forming a reconstructed parse structure for an initial parse structure. Under the method, at least one rule used to form the initial parse structure and at least one additional rule are executed to form the reconstructed parse structure. In many embodiments, the reconstructed parse structure differs from the initial parse structure in that a node is located in a different position in the reconstructed parse structure than in the initial parse structure.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1","b":["100","100","100","100"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general-purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer .","Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, FR, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in , provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies.","A user may enter commands and information into the computer  through input devices such as a keyboard , a microphone , and a pointing device , such as a mouse, trackball or touch pad. Other input devices (not shown) may include a joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a hand-held device, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 2","b":["200","200","202","204","206","208","210"]},"Memory  is implemented as non-volatile electronic memory such as random access memory (RAM) with a battery back-up module (not shown) such that information stored in memory  is not lost when the general power to mobile device  is shut down. A portion of memory  is preferably allocated as addressable memory for program execution, while another portion of memory  is preferably used for storage, such as to simulate storage on a disk drive.","Memory  includes an operating system , application programs  as well as an object store . During operation, operating system  is preferably executed by processor  from memory . Operating system , in one preferred embodiment, is a WINDOWS\u00ae CE brand operating system commercially available from Microsoft Corporation. Operating system  is preferably designed for mobile devices, and implements database features that can be utilized by applications  through a set of exposed application programming interfaces and methods. The objects in object store  are maintained by applications  and operating system , at least partially in response to calls to the exposed application programming interfaces and methods.","Communication interface  represents numerous devices and technologies that allow mobile device  to send and receive information. The devices include wired and wireless modems, satellite receivers and broadcast tuners to name a few. Mobile device  can also be directly connected to a computer to exchange data therewith. In such cases, communication interface  can be an infrared transceiver or a serial or parallel communication connection, all of which are capable of transmitting streaming information.","Input\/output components  include a variety of input devices such as a touch-sensitive screen, buttons, rollers, and a microphone as well as a variety of output devices including an audio generator, a vibrating device, and a display. The devices listed above are by way of example and need not all be present on mobile device . In addition, other input\/output devices may be attached to or found with mobile device  within the scope of the present invention.","The present invention is a natural language parser. Such parsers are used in a number of contexts including a natural language processing (NLP) system such as NLP  of .","NLP system  converts a text  into a logical form , which represents the semantic meaning of the text in a generalized form. To produce logical form , a natural language parser  generates a syntactic parse tree  from a text . Syntactic parse tree  provides a hierarchical representation of the syntactic structure of the text. Syntactic parse tree  is then generalized by a logical form generator  to produce logical form .",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 4","b":["400","400","403","402","404","306","405"]},"An initial parse tree is then constructed through an iterative process. During each iteration, a single candidate node is promoted from candidate list  to a node chart  by a node selector . The promoted node is then tested against rules in a rule grammar  by a rule engine  to see if the promoted node can be transformed into a higher level node using one of the rules. This can occur by applying a unary rule to the promoted node by itself or by applying a rule that combines the promoted node with one or more of the nodes in node chart .","During testing, the phrase types of the nodes under consideration are compared to the phrase types required by a rule. For example, a rule may take a verb phrase and a noun phrase to form a larger verb phrase. For such a rule, the promoted node and at least one other node in the node chart must provide the phrase types of noun phrase and verb phrase in order for the conditions of the rule to be satisfied. If the appropriate phrase types are not present in the node chart, the next rule in rule set  is examined.","Note that under some embodiments, the rules have additional conditions beyond the phrase types. For example, a rule may require number agreement (singular or plural) between a noun phrase and a verb phrase. In addition, the rule may require a particular phrase level for one or more of the constituent nodes.","When the node chart contains nodes that satisfy a rule, the rule is executed to form a new node. This execution includes determining the values for a set of attributes that describe the structure of the node as well as the values for attributes that define relationships found in the clause represented by the node. For example, the subject, object, indirect object, and lemma form of a head verb in a clause may be determined as well as the first token and last token spanned by the node.","The new node formed by executing the rule may then be scored using a metric calculator . The score, if any, assigned to a node, is then used to determine which node to promote next to the chart. Any of a large number of different metrics may be used to score the node. For example, the frequency of the node type, the parts of speech of the tokens to the immediate left and right of the node, the headword associated with the node, the phrase level of the node and the syntactic history of the node may all be used. One type of metric, known as a Statistical Goodness Measure (SGM), determines a score for the node based on probabilities associated with one or more of the factors listed above.","The scored node is inserted into candidate list . Under some embodiments, candidate list  is sorted based on the score of each node, so that the node with the highest score is at the top of the candidate list. At the beginning of the next iteration, this top-most candidate node is promoted to the node chart.","The iterations described above continue until one or more nodes are formed in node chart  that span the entire input segment. At least one of these final nodes is then selected as an initial parse tree .","A tree refinement module  then walks through the tree, typically from top-to-bottom, to determine if the tree can be improved. In particular, tree refinement module  looks for nodes that can be reattached in different positions in the tree to improve the tree. If tree refinement module  locates a node that should be moved within the tree, it passes this reattachment information to a reattachment module . In particular, refinement module  passes the initial parse tree, the identity of the node to be moved (referred to as the reattach node), the identity of the node that the reattach node should be attached to (referred to as the target node), and the rule to use to combine the reattach node and the target node.","Under the present invention, reattachment module  reattaches the reattach node to the target node by first selectively deconstructing the parse tree using a deconstruct unit . This produces an ordered list of nodes and rules that is placed in a deconstruct queue . A reconstruct unit  then executes the rules in the deconstruct queue to form a reconstructed tree . A queue is a data structure that maintains the order in which elements are added, such that the first element added to the tail of the queue will be the first element removed from the head of the queue. Note that other data structures may be used with the present invention instead of a queue.","The operation of deconstruct unit  is best understood by first examining the operation of reconstruct unit .",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 5","FIG. 5"],"b":"424"},{"@attributes":{"id":"p-0055","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["ENTRY",{},{}]},{"entry":["NUMBER","NODE\/RULE ID","NODE OR RULE"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","BEGIN1","NODE"]},{"entry":["2","NP5","NODE"]},{"entry":["3","VP1","NODE"]},{"entry":["4","AJP1","NODE"]},{"entry":["5","NP2","NODE"]},{"entry":["6","NPwDet","RULE"]},{"entry":["7","VPwNPobj1","RULE"]},{"entry":["8","PP2","NODE"]},{"entry":["9","VPwPPcomp","RULE"]},{"entry":["10","VPwNPsubj","RULE"]},{"entry":["11","CHAR1","NODE"]},{"entry":["12","Sent","RULE"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"This queue is produced for the sentence \u201cHe gave the book to John\u201d, which has an initial parse tree as shown in .","At step  of , the entry at the head of the queue is selected. For the queue shown above, this involves selecting the node BEGIN1.","At step , the selected entry is examined to determine if it is a rule or a node. If it is a node, it is placed in a working stack at step . After a node has been placed at the top of the working stack, the deconstruct queue is examined at step  to determine if there are any additional entries. If there are more entries at step , the process returns to step , and the next entry at the head of the deconstruct queue is selected. Thus, for the deconstruct queue listed above, five iterations through steps , , , and , produces a working stack containing the following list, where NP2 is at the top of the working stack:\n\n","If the entry selected from the head of the deconstruct queue is identified as a rule at step , the number of nodes, N, required by the rule is determined at step . At step , the N topmost nodes are removed from the top of the working stack, and the rule is then executed using its definition in rule grammar  and the N topmost nodes as input. The resulting node formed by the rule is placed at the top of the working stack.","For example, when the rule NPwDet is read from the head of the deconstruct queue, nodes NP2 and AJP1 are removed from the top of the working stack, and the rule NPwDet is applied using these two nodes as its input. This results in the formation of parse structure  shown in , in which NP6 is the newly formed node created by the execution of the rule. Note that as shown in , in most embodiments, the nodes appear in the structure in a left-to-right manner based on their ordering in the working stack. Thus, since AJP1 was below NP2 in the working stack, it appears to the left of NP2 in the parse structure. After execution of the rule, the working stack contains:\n\n","The process of  continues until there are no more entries in the deconstruct queue. At that point, the reconstructed parse tree is fully formed.","For example, after parse structure  is formed, rule VPwNPobj1 is removed from the head of the deconstruct queue at step . When this rule is executed, nodes NP6 and VP1 are applied to the rule producing parse structure  of  and modifying the working stack so that it becomes:\n\n","During the next iteration through the loop of , node PP2 is added to the working stack. Rule VPwPPcomp is then executed using node PP2 and VP4 to produce parse structure  of . After parse structure  is formed, the working stack appears as:\n\n","Rule VPwNPsubj is then executed on the next iteration using nodes VP5 and NP5. This results in parse structure  of  and changes the working stack to:\n\n","During the next iteration, node CHAR1 is added to the working stack. The following iteration takes the rule Sent from the head of the deconstruct queue and executes the rule using the three entries in the working stack. This produces parse structure  of . At this point, there are no further entries in the deconstruct queue and the process of  ends at step  with parse structure  representing the reconstructed parse tree.","Note that when executing rules, reconstruct unit  uses the definition of the rules in rule grammar . As a result, when a rule is modified in rule grammar  to implement a change in the formation of initial parse trees, the change is automatically propagated to the formation of reconstructed parse trees.","Also note that since the reconstructed parse tree is formed in the same manner as the initial parse tree, the nodes in the reconstructed tree are as formally correct as any initially formed trees. In particular, the attribute-value pairs defined for a node by the rule used to construct the node are assured to be as correct as in an originally constructed tree. This also means that post processing may be performed on the reattached trees in the same manner that it is performed on trees without reattachment. In particular, a reconstructed parse tree can be scored by metric calculator  in the same manner that nodes in the initial parse trees are scored. This allows initial parse trees and reconstructed parse trees to be compared in a meaningful way.","Note that under some embodiments, not all of the rules used in initial attachment are used during reattachment. Likewise, under some embodiments, there are rules that are only executed as part of reattachment.","As shown above, under many embodiments of the present invention, reconstruct unit  does not make decisions about how the nodes should be combined to form the reconstructed parse tree. Instead, it simply follows the order of the nodes and rules provided by deconstruct unit . As such, deconstruct unit  must populate the deconstruct queue so that the reattach node is connected properly to the target node in the reconstructed parse tree.","The manner in which the deconstruct queue is populated depends on the type of reattachment being performed. In general, there are two types of reattachment. In the first type, the target node spans the reattachment node such that the target node must be redefined as part of moving the reattachment node. In the second type, the tokens spanned by the reattachment node are next to the tokens spanned by the target node such that the reattachment node can be moved without redefining the target node.",{"@attributes":{"id":"p-0071","num":"0087"},"figref":["FIG. 12","FIG. 11"],"b":"1100"},"In initial parse tree , the sentence has been parsed as \u201cHe (gave (the book to John))\u201d. However, a more accurate parse would be \u201cHe (gave (the book)(to John))\u201d. Thus, given initial parse tree , tree refinement unit  will identify node  for the prepositional phrase \u201cto John\u201d as the reattach node, and node  for the verb phrase \u201cgave the book to John\u201d as the target node. As can be seen in , reattach node  is spanned by target node .","The process of  begins by setting the top node of the parse tree as a current node. A constituent of the current node is then selected at step . In most embodiments, selection step  is performed in a left-to-right manner such that the left-most constituent is selected first.","At step , the selected constituent is examined to determine if its span includes the reattach node. In other words, are all of the tokens beneath the reattach node also found beneath the selected constituent node. If the span of the constituent node does not include the reattach node, the constituent will not be affected by the reattachment. As a result, the constituent node can be placed at the tail of the deconstruct queue at step .","If the constituent node spans the reattach node, the constituent node is examined at step  to determine if it is the reattach node. If it is the reattach node, a \u201cFOUND\u201d flag is set at step  for the current node (the constituent node's parent). This \u201cFOUND\u201d flag is used later in step  to control whether a rule should be added to the tail of the deconstruct queue.","If the constituent node is not the reattach node at step , the constituent node is examined to determine if it is the target node at step . If it is the target node, and the span of the reattach node shares the same first token as the target node (in other words, the reattach node is on the left edge of the target node), the reattach node is added to the tail of the deconstruct queue at step . The reattach node is added to the tail of the deconstruct queue at step  to maintain the left-to-right relationship of the reattach node and the target node when the tree is reconstructed by reconstruct unit .","After the reattach node is added at step  or if the constituent node is not the target node or the reattach node is not on the left edge of the target node at step , the process of  continues at step . In step , a recursion is performed by setting the constituent node as the current node and returning to step . This moves the process down one level in the tree toward the reattach node, which is known to be below the constituent node because of the examinations performed in step .","At each level of the recursion, the constituents are examined in a left-to-right manner. If a constituent does not span the reattach node, it is added to the tail of the deconstruct queue at step  and if there are more constituents at that level at step , the next constituent is selected at step . Similarly, if a constituent node is the reattach node at step , the \u201cFOUND\u201d flag is set at step  for the current node and the next constituent at the current level, if any, is examined.","Since the recursion moves down a level when it encounters a constituent that spans the reattach node, not all constituents on a level will necessarily be considered before moving down to the next level. These constituents will be examined, however, after the reattach node is found as discussed further below.","When the process reaches the node that has the reattach node as a constituent, the \u201cFOUND\u201d flag will be set and all of the other constituents of the node will be added to the tail of the deconstruct queue through step .","The process of moving down through the initial parse tree as described above can be seen in detail by examining initial parse tree  of . At first, the current node is set to top node . At step , constituent  of the top node is selected and examined at step . Because constituent node  does not span reattach node , it is added to the tail of the deconstruct queue at step  creating a deconstruct queue of:\n\n","At step , it is determined that there are additional constituents under node  and at step , constituent  is selected. Constituent node  does span reattach node , however it is not the reattach node itself and it is not the target node. As a result, the process moves to step  through steps , , and . At step , a recursion is performed such that node  becomes the current node and the first constituent of that node, node  is selected at step .","Constituent node  does not span the reattach node, and as such is added to the tail of the deconstruct queue at step  to produce a queue of:\n\n","The next constituent of node  is then selected, which is node . Since node  spans the reattach node but is not the reattach node, the process moves to step  where node  is compared to the target node. Since node  is the target node, the starting token of the reattach node and the starting token of the target node are examined to determine if the reattach node is on the left edge of the target. It is clear from  that the reattach node is not along the left edge of the target but instead is along the right edge. As such, the reattach node does not have to be added to the tail of the deconstruct queue at this point and a second recursion is performed at step .","With the second recursion, node  becomes the current node and its first constituent, node  is selected at step . This constituent does not span the reattach node, so it is added to the tail of the deconstruct queue at step  to form a queue of:\n\n","The next constituent, node , is then selected at step . This constituent does span the reattach node, but is not the reattach node nor the target node. As a result, another recursion is performed without adding anything to the tail of the deconstruct queue.","The first constituent of node  is node , which does not span the reattach node. As a result, node  is added to the tail of the deconstruct queue at step  to produce:\n\n","The next constituent of node  is node , which does span the reattach node but is not the reattach node nor the target. Thus, an additional recursion is performed at step  to make node  the current node without changing the deconstruct queue.","The first constituent of node  is node . Since this node does not span the reattach node, it is added to the tail of the deconstruct queue at step  to produce a queue of:\n\n","The next constituent of node  is node . This node spans the reattach node at step  and is found to be the reattach node at step . As a result, the \u201cFOUND\u201d flag is set to true for node  at step .","Returning to step , there are no further constituents for current node . When each of the constituents at a level have been processed, step  will indicate that there are no more constituents and the process will continue at step  where the \u201cFOUND\u201d flag is examined to determine if the current node has the reattach node as a constituent.","If the \u201cFOUND\u201d flag is set, the process continues at step , where the current node is examined to determine if it is the top node. If it is not the top node, the process is moved up one level in the tree at step  by making the parent node of the current node the new current node.","Note that if the \u201cFOUND\u201d flag is set, the rule used in the initial parse tree to combine the reattach node with its siblings is not added to the tail of the deconstruct queue before moving up to the next level. The reason for this is that since the reattach node is being moved, the rule for combining it with its siblings is not needed to form the reconstructed parse tree.","The new current node is examined at step  to determine if there are any other constituent nodes that have not been processed. Such constituent nodes, if they are present, would not have been processed if they were to the right of a node that spanned the reattach node.","In the case of the parse tree of , there are no further constituent nodes for node . As a result, the process returns to step  to determine if the \u201cFOUND\u201d flag has been set for node . Note that although the \u201cFOUND\u201d flag was set for node , it has not been set for node . Thus, when the \u201cFOUND\u201d flag is set for a current node it does not propagate upwards to the parent nodes of the current node. As such, the process moves from step  to step  where the rule used to form the current node is added to the tail of the deconstruct queue. This produces a queue of:\n\n","At step , the current node is examined to determine if it is the target node. Since node  is not the target node, the process continues at steps  and  where the process moves up one level by selecting the parent of the current node, node , as the new current node.","Since node  does not have any constituents that have not been processed, the process moves through step  and back to step . At step , the \u201cFOUND\u201d flag is not true for node , so the process moves to step  where the rule for forming node  is added to the tail of the deconstruct queue to produce:\n\n","After step , node  is examined at step  and is determined to be the target node. When the target node is reached while moving up through the parse tree, the deconstruct queue includes a new definition for the target node that does not include the reattach node. For example, in the deconstruct queue produced thus far for initial parse tree :\n\n","As such, to reattach the reattach node to the target node, the rule for reattachment must be added to the tail of the deconstruct queue when the target node is encountered during the movement up through the parse tree. Before adding the reattach rule, the process of  determines at step  if the reattach node has already been added to the tail of the deconstruct queue. This would have occurred at step  on the way down through the parse tree if the reattach node was found on the left edge of the target node. Thus, to determine if the reattach node is already in the deconstruct queue, the reattach node and the target node are examined to determine if the reattach node is on the left edge of the target. If the reattach node is on the left edge of the target node at step , only the rule for reattachment has to be added to the tail of the deconstruct queue at step . However, if the reattach node is not on the left edge of the target, both the reattach node and the reattach rule must be added to the tail of the deconstruct queue at step . In the example of , step  produces a deconstruct queue of:\n\n","After step  (or step ), the process continues at steps  and , where the parent node of the current node is made the new current node. Thus, node  becomes the new current node.","Node  does not have any more constituents to process and the \u201cFOUND\u201d flag is not set for the node. As a result, the rule for forming node  is added to the tail of the deconstruct queue at step  to produce a queue of:\n\n","Since node  is not the target node at step , the process continues at steps  and  where the node  is made the current node.","Node  does have a constituent node that has not been processed. As a result, constituent node  is selected at step . Since this node does not span the reattach node, it is added to the tail of the deconstruct queue at step  to produce a queue of:\n\n","After step , all of the constituents for current node  have been processed. Thus, the method continues at step  where the \u201cFOUND\u201d flag is determined to have not been set for current node . As a result, the rule for forming node  is added to the tail of the deconstruct queue at step  to produce a queue of:\n\n","Since node  is not the target node, the process continues through step  to step  where it is determined that node  is the top node. As a result, the deconstruct process ends at step  with the deconstruct queue in a final condition of:\n\n","Note that this deconstruct queue is the same deconstruct queue that was used above to describe the operation of reconstruct unit . Thus, this deconstruct queue produces the reconstructed parse tree of  in which it can be seen that the PP2 reattach node has been reattached to the VP4 target node, where VP4 represents target node  of  as redefined without the PP2 reattach node.",{"@attributes":{"id":"p-0107","num":"0217"},"figref":["FIG. 13","FIG. 13","FIG. 14","FIG. 12","FIG. 13"],"b":["1400","1402","1404"]},"Beginning with the top node as the current node, the process of  first selects the left-most constituent node of the current node at step . Using the parse tree of , this involves selecting node . At steps  and , the selected node is examined to determine if it is the target node or the reattach node. If it is neither, the node is examined at step  to determine if it spans either the target node or the reattach node. If it does not span either of these nodes, it will not be affected by the reattachment and may be added directly to the tail of the deconstruct queue at step . Thus, using the example of , the queue becomes:\n\n","After the constituent has been added, the method determines if there are any other constituents for the current node at step . If there are more constituents, the next constituent is selected at step . Using the example of , this involves selecting constituent .","Since node  is not the target node or the reattach node, the process moves through steps  and  to , where it is determined that constituent node  spans the target node and the reattach node. The process then attempts to locate the target node and\/or reattach node by recursively moving down the parse structure at step . This is done by setting the constituent node as the new current node and returning to step  to select the first constituent of the new current node. Thus, in step , node  becomes the new current node and node  is selected as the constituent node in step .","Since node  is not the target node, is not the reattach node and does not span either of these nodes, it is added to the tail of the deconstruct queue at step  to produce a queue of:\n\n","Returning to step , the next constituent node, node  is selected. This node is neither the target node nor the reattach node but does span both the target node and the reattach node. As a result, the process moves down a level at step  to make node  the current node. At step , constituent node  is then selected.","Constituent node  is determined to be the target node at step . Since the target node is not affected by the movement of the reattach node, it must be explicitly added to the tail of the deconstruct queue when it is encountered. In addition, the reattach node and the rule for attaching the reattach node to the target node must also be added to the tail of the deconstruct queue.","The order in which the reattach node and the target node are added to the tail of the deconstruct queue must maintain the left-to-right relationship between the reattach node and the target node. Thus, at step , the process determines if the reattach node is to the left of the target node. If the reattach node is to the left of the target in the initial parse tree, the reattach node is added to the tail of the deconstruct queue before the target and the reattach rule at step . If the reattach node is to the right of the target, the target node is added to the tail of the deconstruct queue before the reattach node and the reattach rule at step .","In the example of , step  produces a queue of:\n\n","After the target node, reattach node and reattach rule have been added to the tail of the deconstruct queue at steps  or , the next constituent of the current node is selected. For the example of  this involves selecting constituent .","Constituent  is neither the target node nor the reattach node but it does span the reattach node. Thus, the process follows steps , , and  to step , where it moves down to make node  the current node. At step , constituent node  is selected.","Since constituent node  is the reattach node, the process follows step  to step , where the \u201cFOUND\u201d flag is set for current node . The next constituent, node , is then selected at step .","Since node  is not the target node, is not the reattach node, and does not span either of these nodes, it is not affected by the reattachment and can be added to the tail of the deconstruct queue at step . This produces a queue of:\n\n","After step , there are no further constituents of current node . As a result, the process continues from step  to step  where the current node is examined to see if the \u201cFOUND\u201d flag has been set. For node , the \u201cFOUND\u201d flag has been set. This means that the reattach node is a constituent of the current node in the initial parse tree. Since the reattach node is being moved, the rule for attaching the reattach node to another constituent to form node  needs to be removed. As such, it is not added to the tail of the deconstruct queue and the process continues at step .","At step , the method determines if the current node is the top node in the initial parse tree. If it is not the top node, the process moves up a node in the parse tree by making the parent of the current node the new current node. For the example in , this involves making node  the current node. The process then returns to step  to see if there are any constituent nodes of the new current node that were not processed on the way down the parse tree. If there are no further constituent nodes, the process continues at step  where the \u201cFOUND\u201d flag is examined.","For node , the \u201cFOUND\u201d flag has not been set even though it was set for node . As a result, the process continues at step , where the rule for forming node  is added to the tail of the deconstruct queue. This produces a queue of:\n\n","After the rule has been added to the tail of the deconstruct queue at step , the process moves up another node at step  and returns through steps  and  for new current node . At step , the rule for forming node  is added to the tail of the deconstruct queue to form a queue of:\n\n","The process then moves up to node  and returns to step . At step , constituent  of current node  has not been processed yet. As such, constituent  is selected at step . Since constituent  is not the target node, is not the reattach node, and does not span either of these nodes, the constituent is added to the tail of the deconstruct queue at step  to form a queue of:\n\n","Upon returning to step , there are no more constituents for current node  and the process continues at step  where it is determined that the \u201cFOUND\u201d flag has not been set for node . As a result, the rule for forming node  is added to the tail of the deconstruct queue at step  to produce a queue of:\n\n","At step , it is determined that node  is the top node and the deconstruct process ends at step .","The resulting deconstruct queue can be used to form a reconstructed parse tree as shown in . Stepping through the deconstruct queue from head to tail, the first rule that is encountered is VPwAVPr which combines VP1 and AVP1 of the deconstruct queue to form node . This is the reattachment of reattach node  of  to target node . Rule VPwPPcomp then combines node  with PP2 from the deconstruct queue to form node . Rule VPwNPsubj then combines NP2 from the deconstruct queue with node  to form node . Node BEGIN1 from the deconstruct queue is then combined with node  and node CHAR1 from the deconstruct queue by rule Sent to form top node .","Although the method of deconstructing parse trees has been shown as two separate methods, the invention can be practiced using a more integrated single method. In addition, the present invention is not limited to the particular steps used to form the deconstruct queue. Any series of steps that forms a data structure in which the left-to-right relationship of the tokens in the initial parse tree is maintained in the reconstructed tree and the bottom-to-top ordering of the rules is maintained can be used within the scope of the present invention.","In addition, although two examples of reattachment have been shown above, other types of reattachment may be performed with the present invention including reattachment to a right cousin, and reattachment along the left edge.","Because the reconstructed parse trees are formed by executing rules from the same rule grammar used to form the initial parse trees, the reconstructed parse trees can be scored in the same manner that the initial parse trees are scored. This means that the resulting scores for trees with and without reattachment can be compared in a meaningful way during sentence generation.",{"@attributes":{"id":"p-0131","num":"0289"},"figref":"FIG. 16","b":["1600","1600","1602","1604","1606","1608","1610","1606","1604"]},"Once parse tree  has been identified, a sentence generator  selects words for the child nodes of the parse tree to form a generated sentence .","Although the present invention has been described with reference to particular embodiments, workers skilled in the art will recognize that changes may be made in form and detail without departing from the spirit and scope of the invention. In particular, although the examples above use a token that represents a single word, in other examples of the invention a token can represent a phrase."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIGS. 6-10","FIG. 5"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 15","FIG. 14"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
