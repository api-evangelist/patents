---
title: Program flow control in computer systems
abstract: Application programs supporting multiple contexts on a computer system having an operating system supporting threads. The method comprises processing a context processing instruction from the run-time application program, evaluating said instruction in relation to program-flow control yielding context-defining processing parameters, analyzing the context-defining processing parameters from the execution context of the context processing instruction in regard of program flow management by threads, mapping the context-processing instruction to a selected thread managing instruction, or to a selected set of thread managing instructions, having a respective program flow control effect equivalent to that of context-processing instruction, invoking the selected thread managing instruction or the set thereof, together with selected parameters so that that during runtime of the application program only one thread is allowed to execute at a time, and the program state of a thread is stored at a given point in time and is restored later from the point in time.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07559063&OS=07559063&RS=07559063
owner: International Business Machines Corporation
number: 07559063
owner_city: Armonk
owner_country: US
publication_date: 20050603
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","OBJECTIVES OF THE INVENTION","SUMMARY AND ADVANTAGES OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT","EXAMPLES","Example 1","Example 2","Example 3"],"p":["1. Field of the Invention","The present invention relates to program flow control in computer systems, and in particular to a method for running application programs on a computer system having an operating system, supporting threads, semaphore mechanisms and long-jumps, wherein said operating system does not support context processing due to the lack of a mechanism to access the central processing unit (CPU) state.","2. Description and Disadvantages of Prior Art","The general purpose computer, a finite approximation of the universal Turing machine, maintains state only in a finite set of transistors and optionally in a limited magnetic storage. A specific portion of the state of a program running within a computer is defined herein a context as used in prior art terminology. A context may be regarded as a snapshot of the runtime flow of a program as seen by the CPU. In large, this snapshot contains the set of CPU computational registers, the instruction pointer, a record of the execution path of the program, ie the invocation stack and the possibly separate but associated automatic storage and function call parameters residing along the execution path, ie the parameter stack. A context does not encapsulate memory allocated from heap and does not maintain a copy of the static storage used in runtime of the application program.","Maintaining multiple contexts is useful for programs wishing to sustain multiple concurrent runtime states but where only one state is active at a time. Discrete simulation is a typical example; modeled entities might maintain state by running as separate computational tasks. In this case in prior art computer systems supporting context processing a simulation manager orchestrates, which entity performs each discrete simulation step. After each step, the entity returns control to the manager.","For example, on UNIX platforms, so-called \u201cu-context\u201d functions are provided as part of the operating system. Such u-context functions may be seen herein as a standard Application Programming Interface (API) for storing and restoring a program's runtime context. Any reference thereto is to be understood broadly and shall include also implementations other than UNIX.","The API set consists of four functions. All functions operate on a structure defined as ucontext_t. The information in ucontext_t is sufficient for restoring the CPU to a precise program execution state. In alphabetical order:\n\n","In general, the need to keep multiple program flows active and interacting with one-another while each flow is independent is best satisfied in prior art by the use of \u201ccontext processing\u201d. Prior art contexts also provide a basic infrastructure needed for co-operative multitasking. One prior art approach to task orchestration is to rely on a sort of context-to-context messaging to provide the context switch triggering events.","Disadvantageously, in many business environments there are many platforms in use that do not support context processing while applications increasingly require the ability to process multiple contexts. The basic structure of the prior art thread-based program control is depicted in . A runtime version of an application program depicted left in  comprises exemplarily a number of three tasks A, B, C. Each task is executed in a respective thread A, B C. At the end of the thread run, which flows in a direction from bottom to top as indicated by the arrow, a respective semaphore mechanism A, B, C indicates the end of the thread to the CPU . The application itself must control the sequence of the threads, e.g. by prior art semaphore mechanisms.","Generally, such environments are platforms in which the operating system does not offer any instruction which enables updating the CPU state as described above. Examples for such platforms are the IBM iSeries server, which is used in enterprises successfully since more than 15 years, further, platforms, on which interpretive languages run, on which platform-independent languages like Java run.","A prior art approach discloses a mechanism to swap contexts between threads. Disadvantageously, this prior art approach does not offer full context compatibility, as it does not provide a \u201csetcontext\u201d and \u201cgetcontext\u201d capability.","It is thus an objective of the present invention to offer the ability to run application programs designed for context processing on above mentioned platforms which per se do not support context processing.","This objective of the invention is achieved by the features stated in enclosed independent claims. Further advantageous arrangements and embodiments of the invention are set forth in the respective subclaims. Reference should now be made to the appended claims.","According to the basic aspect of the present invention a method is disclosed for running application programs supporting multiple contexts on a computer system having an operating system supporting threads and not supporting multiple context processing instructions,","which is characterized by the steps of:","a) processing a context processing instruction from said run-time application program,","b) evaluating said instruction in relation to program-flow control yielding context-defining processing parameters,","c) analyzing said context-defining processing parameters from the execution context of said context processing instruction in regard of program flow management by threads,","d) mapping said context-processing instruction to a selected thread-managing instruction or to a selected set of thread managing instructions, having a respective effect of program flow control equivalent to that of said context-processing instruction,","e) invoking said selected thread managing instruction or said set thereof, together with selected parameters for guaranteeing that during runtime of said application program:","e1) only one thread is allowed to execute at a time, and","e2) the program state of a thread may be stored at a given point in time and may be restored later from said point in time.","The state of a program may be understood in here to comprise the values of sp (stack pointer), fp (frame pointer), and pc (program counter). A program state is thus completely defined by these set of registers and the contents of the memory, which includes e.g. the heap and the stack.","In simpler words the inventional method performs a mapping of semantics and syntax of existing prior art context processing functionality, and in particular of the so-called \u201cucontext\u201d API functionality used for prior art context processing to said threads, semaphore mechanisms and long-jumps for emulating context semantics, wherein the context semantic is defined as the ability to store the current state of a processor in any point of runtime of the application program and to restore any previous processor state. Thus, above measures e) and e) provide for successful mapping between context processing and thread management either in single threaded but in particular in multi-threaded environments.","Thus, the general advantage is achieved that applications which are designed for context processing may be run on platforms, which do not support context processing. The present invention allows to use application programs using prior art context processing in multi-threaded operation environments without needing to change the application code. For the sake of concreteness, the context processing is herein described exemplarily by aid of u-context processing instructions.","The idea behind this inventional approach is that the information in a context is a superset of that which is required by prior art \u201csetjmp\u201d or \u201csigsetjmp\u201d operating system operations: The setjmp interface provides a method to return to any previous point in a program. The ucontext interface, in contrast, is able to manage separate and complete invocation paths.","The difference between threads and contexts is semantic; contexts are serial in nature, whereas threads are parallel; only one context is active at a time. Like threads, contexts provide the ability for a program to contain multiple execution flows; though unlike threads, contexts guarantee serial access to resources.","Further advantageously, the execution of a thread may be stopped by a semaphore instruction, when in the the run-time application program execution a getcontext instruction is executed.","Further advantageously, a thread is encapsulated by a class providing invocation, suspend, and resume methods.","According to the invention contexts and threads may coexist. A thread itself can contain multiple contexts such that any single thread is \u201cexecuting\u201d only one context at a time, but multiple threads could be executing \u201ctheir\u201d current contexts in parallel.","The \u201cu-context\u201d interface in particular has the ability for a context switch to return to any previous \u201csave\u201d-point inside a context. The \u201cprogram sequence\u201d initiating the switch can select to switch to any \u201csave\u201d-point inside another context. This is an advantageous feature not intrinsically possible with threads alone.","Thus, the above-mentioned prior art by Novell may be greatly improved by the inventional context-to-thread-mapping mechanism. Further, in existing applications, which only use makecontext( ) and swapcontext( ) APIs, the swapping context reduces to simple semaphore control without the need to record CPU state in \u201csigjmp_buf\u201d buffer structures. During swapcontext( ) the current thread is thus stopped, and the one to be activated, is released.","With general reference to the Figures an exemplary implementation of the inventional method will be described in more detail.","With reference to , a system diagram is given first representing the most important structural elements used in the inventional method. With concurrent reference to  respective basic steps of the control flow during the inventional method are depicted.","Again the Application program is depicted left. It is designed for context processing and thus comprises the prior art context processing APIs, and in particular those mentioned earlier, ie \u201cset context ( )\u201d and \u201cgetcontext( )\u201d instructions depicted by reference sign .","The currently active context  is depicted logically \u201cwithin\u201d the Application program, which is dependent on context processing as a mechanism for internal process flow control. The application program profits from the advantages inherent of context processing. The context is defined to comprise the elements as known from prior art, namely invocation stack, parameter stack, storage call parameters, instruction pointer, etc.","The before-mentioned prior art application program is designed for context processing, and may be assumed to be linked with an inventional program implementing the before-mentioned mapping or conversion layer between context and thread instruction.","Then the resulting executable program may be assumed to specify at any given point of run-time a u-context-specific instruction. The inventional method processes this instruction by reading it, step . Then an evaluation step  is performed, aiming at exactly emulating the context processing with thread processing. Thus, the read context instruction is interpreted in this sense, and in a subsequent step  the thread processing is prepared by generating the thread-specific parameters  required to run a thread instead of the context originally planned by the application programmer.","So, for example, a getcontext invocation done by the application program takes a snapshot of the current context, ie computing state, whereas a setcontext invocation requires a context specified by either \u201cmakecontext( )\u201d API or \u201cgetcontext( )\u201d API, and switches the CPU to start executing in the new context.","According to the invention this is realized by thread switching, step , as well as by setjmp, see step , and longjmp calls which are thread-specific instructions , see step , and the box , which thus provides for a kind of u-context emulating layer between the Application and the CPU, as it converts the u-context requests issued by the Application program code to thread managing instructions, as in particular to setjmp and longjmp calls, and semaphore mechanisms, or whatever control functions the operating system offers for thread control.","Those calls ,  , however, instruct the CPU  to execute the new threads, see step , as defined by said calls. Thus, the CPU behaves as if executing in a new context. As visible from the drawing a thread can be stopped according to the inventional method by semaphores  advantageously at any desired location within a thread , which is symbolically indicated in box . In  the context C is depicted to be executed by the CPU  after being invoked by the instruction \u201csetcontext (C) in the Application code (left side). A Thread buffer is used comparable to prior art use in order to store the processor state relevant to the point in time, when the getcontext invocation, see e.g. getcontext (C) was done. The setcontext () invocation thus triggers a read out of the data collected in the thread pool for context C and a respective executing thereof with CPU .","Thus, a thread provides the invocation stack for a context. Further, \u201csemaphores\u201d, i.e., program instructions implementing a prior art semaphore-mechanism, are advantageously used to control, which one of the threads is active at any point in time. It should be noted that the semantics of the \u201ccontext APIs\u201d make prior art thread switching using only semaphores insufficient as described above in the description of prior art, as the application programmer is free to call the getcontext( ) function at any time in his program. As, by definition, it must be thus possible to \u201cjump\u201d into any active execution point stored by getcontext( ), a setcontext( ) must first switch to the thread to be activated using semaphores, then it must restore the \u201cin-the-thread\u201d context.","Next, the definition of the prior art ucontext_t structure is given in order to improve clarity, which is used to record and transfer the CPU state. Many elements familiar to the Unix implementation remain advantageously for the reason of compatibility; most notably, the member uc_stack is typically set by Unix applications to allocate a call stack for new contexts before the call to makecontext( ).",{"@attributes":{"id":"p-0054","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _ucontext_t"]},{"entry":[{},"\u2003\u2003{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003const _ucontext_t *uc_link;","\/\/ Parent context"]},{"entry":[{},"\u2003\u2003const _ucontext_t *uc_dest;","\/\/ Child context"]},{"entry":[{},"(ucontextTX only)."]},{"entry":[{},"\u2003\u2003sigset_t uc_sigmask;"]},{"entry":[{},"\u2003\u2003stack_t uc_stack;","\/\/ Unused. For"]},{"entry":[{},"compatiblity."]},{"entry":[{},"\u2003\u2003mcontext_t uc_mcontext;","\/\/ Unused. For"]},{"entry":[{},"compatiblity."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003sigjmp_buf jmpbuf;"]},{"entry":[{},"\u2003\u2003_uContext_Thread *uc_thread;"]},{"entry":[{},"\u2003\u2003} ucontext_t;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"According to the invention within the ucontext_t structure two independent sets of flow control information are present:","first, a pointer to a class that represents a thread;","second, a buffer to store the processor state.","This processor state buffer is advantageously the standard sigjmp_buf buffer used by sigsetjmp( ) and siglongjmp( ) functions . For C (programming language) runtime programs that do not maintain masks for asynchronous signals the buffer \u201cjmp_buf\u201d as known to a skilled reader is sufficient.","The three APIs getcontext( ), makecontext( ) and setcontext( ) are described next by flow chart diagrams in ,  and , respectively, wherein the direct mapping to thread control instructions according to this inventional embodiment is disclosed, where applicable.","With reference to  the getcontext( ) instruction mapping is disclosed next in more detail using a C-macro (left portion calling a C-function (right portion):","The main purpose is to record a snapshot of the CPU and of the signal state. This function_getcontext(ucontext_t *ucp) initializes the ucontext_t structure passed into the function, retrieves the current signal mask, and then calls the function sigsetjmp  (left portion) to acquire the register set. In this specific implementation the portion of the function that invokes sigsetjmp must be contained within a C-language macro as it needs to run in the stack frame of the caller.","With reference to  the inventional makecontext( ) instruction mapping is disclosed in a similar way. This function builds up an ucontext_t structure such that a specified function with specified parameters is invoked when the context is made active.","According to the inventional embodiment a \u201cthread\u201d is encapsulated by a class providing invocation, suspend, and resume methods. An instance of the thread class is created at this point and the pointer is assigned to the uc_thread of the input argument to makecontext( ). Then the thread is started.","With further reference to , which may be subsumed under the step  in , started by makecontext( ), the thread's bootstrap function immediately suspends the thread\u2014awaiting to be awoken by setcontext( ) at a later point in time. with reference to  a call from another context to setcontext( ) has made the context referenced in  active (this context had been suspended at the end of ), signals are unblocked by applying the signal mask of the parent context acquired during getcontext( ).","A user function passed to makecontext is awarded control; see the right portion in the Figure. The user function is the \u201cmain\u201d routine of this new context. Until the user function returns, or the user function invokes another setcontext( ) function, this context will remain active. When this context runs to completion (user function returns), the bootstrap function activates the parent context\u2014the other context that had last invoked setcontext( ) to make this context active\u2014so that it appears the parent returned from setcontext( )\u2014see Part  in setcontext( ) as defined further below and shown in .","With reference to ,  and , which may be subsumed under the step  in , the setcontext( ) instruction mapping according to this inventional embodiment is disclosed next in more detail:","The setcontext( ) function may be regarded as the \u201cvery core\u201d of the u-context routines. It performs three tasks in sequence, depicted in ,  and , respectively. In words, setcontext( ) suspends the thread of the active context, releases the thread of the destination context, then loads the CPU with the register set stored in the CPU snapshot by calling longjmp with the information recorded by the associated getcontext( ).","As revealed from , Part , setcontext( ) activates the destination context thread by releasing its semaphore. The activated thread (context) starts executing at Part  () or begins executing the function specified to makecontext( ). As revealed in , Part  the context that had invoked setcontext( ) suspends itself by acquiring its own semaphore.","Note that the steps in the flow chart involving signal masks and blocking signals are included for completeness\u2014it is necessary to block asynchronous signals while in the midst of the context switch\u2014though, under normal conditions, asynchronous signals would not be sent to the application process.","As revealed in  part , if the destination thread context has not yet ended (NO branch), it loads the CPU with the snapshot from getcontext( ), or in the YES branch, it returns regularly if the function passed to makecontext( ) ended normally. In the case where the destination thread context ended (the user's context function passed to makecontext( ) returned), any thread resources allocated during makecontext( ) are freed.","It should be noted that setcontext( ) might be active in two threads simultaneously for a short moment; the setcontext( ) least recently invoked is the first to complete; as Part  and  above executes in one thread and Part  executes in another thread. The context executing in Part  may be a context either 1) suspended by a previous call to setcontext( ) or 2) built during a call to makecontext( ) and suspended in ThreadMain( ), the new context's bootstrap ()","According to , an inventional swapcontext( ) function implementation is disclosed for showing the advantageous feature of swapping between contexts.","Basically, this is a combination of getcontext( ), followed by setcontext( ). A Boolean on the local stack flags the procedure to initiate setcontext( ), or to return directly from getcontext( ).","With reference back to the general aspects of the invention without a specific figure in reference, according to a preferred aspect of the invention two pointers maintain state information between different contexts. One is the global current context pointer. It is set to the context thread that is currently active. The other is the uc_link field within each ucontext structure that points to the parent context. The uc_link is not typically modified by the application. By modifying this field, however, an application could modify to which context control is returned when an active context ends by way of returning from the user defined function previously passed to makecontext ().","In other words, the uc_link is either set to current_context, when getcontext( ) is called or could be assigned by hand to construct a parent-child relationship in order to obtain an atypical return sequence when context were to end, see the description for  above).","As the astute reader might recognize, further optimizations can be made and some extensions may be incorporated, as for example:","With a slight modification of the concept shown above it is also possible for a program that is itself multithreaded in the typical sense\u2014referred here to a program containing a set of primary threads\u2014to use contexts independently within each primary thread. Supporting this paradigm requires that \u201ccurrent-context\u201d information that is global in the single threaded case, be stored in thread-local-storage (the appended pseudo code example demonstrates multi-threading capable code). The multi-threading supporting implementation is transparent to the application using the u-context APIs and is merely an enhancement that overcomes the single threading restriction of the before-mentioned description.","The present invention can be realized in hardware, software, or a combination of hardware and software. A tool according to the present invention can be realized in a centralized fashion in one computer system, or in a distributed fashion where different elements are spread across several interconnected computer systems. Any kind of computer system or other apparatus adapted for carrying out the methods described herein is suited. A typical combination of hardware and software could be a general purpose computer system with a computer program that, when being loaded and executed, controls the computer system such that it carries out the methods described herein.","The present invention can also be embedded in a computer program product, which comprises all the features enabling the implementation of the methods described herein, and which\u2014when loaded in a computer system\u2014is able to carry out these methods.","Computer program means or computer program in the present context mean any expression, in any language, code or notation, of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following","a) conversion to another language, code or notation;","b) reproduction in a different material form.","Finally, an exemplary C-code example is appended in order to assure the completeness of the present disclosure.","Beginning of Code:",{"@attributes":{"id":"p-0085","num":"0088"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ UContext - Coroutines - via Threads: ucontext.h"},{"entry":"\/\/"},{"entry":"\/\/"},{"entry":"\/\/ \u2003Link with: ucontext.obj - For programs where only one non-context"},{"entry":"\/\/ \u2003\u2003\u2003\u2003\u2003\u2003thread makes calls to setcontext( ) and"},{"entry":"\/\/ \u2003\u2003\u2003\u2003\u2003\u2003swapcontext( ). That is their are not"},{"entry":"\/\/ \u2003\u2003\u2003\u2003\u2003\u2003concurrent threads using coroutines."},{"entry":"\/\/"},{"entry":"\/\/ \u2003\u2003\u2003ucontextTX.obj - For multi-threaded programs."},{"entry":"\/\/"},{"entry":"\/\/ \u2003\u2003\u2003ucontextSX.obj - For multi-threaded programs, but"},{"entry":"\/\/ \u2003\u2003\u2003\u2003\u2003\u2003without setcontext( ) support."},{"entry":"\/\/"},{"entry":"\/\/"},{"entry":"#ifndef Thread_UContext_Emulator"},{"entry":"\u2003\u2003#define Thread_UContext_Emulator"},{"entry":"#include <assert.h>"},{"entry":"#include <signal.h>"},{"entry":"#include <setjmp.h>"},{"entry":"#ifdef _WIN32"},{"entry":"typedef int sigset_t;"},{"entry":"#define sigjmp_buf jmp_buf"},{"entry":"#define sigsetjmp(env,sigmask) setjmp(env)"},{"entry":"#define siglongjmp longjmp"},{"entry":"#endif"},{"entry":"typedef void _uContext_Thread; \u2003\u2003\/\/ Proxy for uContext_Thread."},{"entry":"typedef int mcontext_t; \u2003\u2003\u2003\/\/ For compatiblity."},{"entry":"typedef struct \u2003\u2003\u2003\u2003\/\/ For compatiblity."},{"entry":"\u2003{"},{"entry":"\u2003void *ss_sp;"},{"entry":"\u2003size_t ss_size;"},{"entry":"\u2003int ss_flags;"},{"entry":"\u2003} stack_t;"},{"entry":"typedef struct _ucontext_t"},{"entry":"\u2003{"},{"entry":"\u2003const _ucontext_t *uc_link; \u2003\/\/ Parent context"},{"entry":"\u2003sigset_t uc_sigmask;"},{"entry":"\u2003stack_t uc_stack; \u2003\u2003\u2003\/\/ Unused. For compatiblity."},{"entry":"\u2003mcontext_t uc_mcontext; \u2003\u2003\/\/ Unused. For compatiblity."},{"entry":"\u2003sigjmp_buf jmpbuf;"},{"entry":"\u2003_uContext_Thread *uc_thread;"},{"entry":"\u2003} ucontext_t;"},{"entry":"#ifdef cplusplus"},{"entry":"extern *C* {"},{"entry":"#endif \/* cplusplus *\/"},{"entry":"void makecontext(ucontext_t *ucp, void (*func)( ), int argc, ...);"},{"entry":"int swapcontext(ucontext_t *oucp, const ucontext_t *ucp);"},{"entry":"int _getcontext(ucontext_t *ucp);"},{"entry":"int setcontext(const ucontext_t *ucp);"},{"entry":"#define getcontext(ucp) \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002\\"},{"entry":"\u2003(_getcontext(ucp) == 0 ? sigsetjmp((ucp)->jmpbuf,1) : \u22121)"},{"entry":"#ifdef cplusplus"},{"entry":"\u2003}"},{"entry":"#endif \/* cplusplus *\/"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Notes:","Version II","The original version had a dependency on the uc_link field that it had to point to a context containing a thread. This required that the thread context that a uc_link was pointing had not to be deleted until all children referencing the context were deleted (or at least not activated).","API:\n\n",{"@attributes":{"id":"p-0089","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#include <stdio.h>"]},{"entry":[{},"#include <stdlib.h>"]},{"entry":[{},"#include <ucontext.h>"]},{"entry":[{},"ucontext_t home_context;"]},{"entry":[{},"void func2( )"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003printf(\u201cFunc2\\n\u201d);"]},{"entry":[{},"\u2003return;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"void func1( )"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003printf(\u201cFunc1\\n\u201d);"]},{"entry":[{},"\u2003ucontext_t context2;"]},{"entry":[{},"\u2003getcontext(&context2);"]},{"entry":[{},"\u2003makecontext(&context2,func2,1);"]},{"entry":[{},"\u2003setcontext(&context2);"]},{"entry":[{},"\u2003setcontext(&home_context);"]},{"entry":[{},"\u2003return;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"main( )"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003bool Started = false;"]},{"entry":[{},"\u2003getcontext(&home_context);"]},{"entry":[{},"\u2003if (!Started)"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003Started = true;"]},{"entry":[{},"\u2003\u2003ucontext_t context1;"]},{"entry":[{},"\u2003\u2003getcontext(&context1);"]},{"entry":[{},"\u2003\u2003makecontext(&context1,func1,1);"]},{"entry":[{},"\u2003\u2003setcontext(&context1);"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003printf(\u201cFinished\\n\u201d);"]},{"entry":[{},"\u2003return 0;"]},{"entry":[{},"\u2003}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"From the web: http:\/\/paul.rutgers.edu\/\u02dcjarai\/416\/uc_yield.c",{"@attributes":{"id":"p-0090","num":"0107"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#include <stdio.h>"},{"entry":"#include <stdlib.h>"},{"entry":"#include <ucontext.h>"},{"entry":"ucontext_t auc,buc,mainuc;"},{"entry":"void a( )"},{"entry":"\u2003{"},{"entry":"\u2003int i;"},{"entry":"\u2003for (i=0; i<10; i++) {"},{"entry":"\u2003\u2003printf(\u201ca\u201d);"},{"entry":"\u2003\u2003swapcontext(&auc,&buc);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003swapcontext(&auc,&mainuc);"},{"entry":"\u2003}"},{"entry":"void b( )"},{"entry":"\u2003{"},{"entry":"\u2003int i;"},{"entry":"\u2003for (i=0; i<10; i++) {"},{"entry":"\u2003\u2003printf(\u201cb\u201d);"},{"entry":"\u2003\u2003swapcontext(&buc,&auc);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"int"},{"entry":"main(int argc, char *argv )"},{"entry":"\u2003{"},{"entry":"\u2003printf(\u201cstart\\n\u201d);"},{"entry":"\u2003getcontext(&auc);"},{"entry":"\u2003if((auc.uc_stack.ss_sp=malloc(auc.uc_stack.ss_size))==NULL)"},{"entry":"\u2003\u2003perror(\u201cmalloc\u201d),exit(1);"},{"entry":"\u2003auc.uc_stack.ss_sp=(char*)"},{"entry":"\u2003auc.uc_stack.ss_sp+auc.uc_stack.ss_size;"},{"entry":"\u2003auc.uc_stack.ss_flags=0;"},{"entry":"\u2003makecontext(&auc,a,1);"},{"entry":"\u2003getcontext(&buc);"},{"entry":"\u2003if((buc.uc_stack.ss_sp=malloc"},{"entry":"\u2003(buc.uc_stack.ss_size))==NULL)"},{"entry":"\u2003\u2003perror(\u201cmalloc\u201d),exit(1);"},{"entry":"\u2003buc.uc_stack.ss_sp=(char*)"},{"entry":"\u2003buc.uc_stack.ss_sp+buc.uc_stack.ss_size;"},{"entry":"\u2003buc.uc_stack.ss_flags=0;"},{"entry":"\u2003makecontext(&buc,b,1);"},{"entry":"\u2003getcontext(&mainuc);"},{"entry":"\u2003swapcontext(&mainuc,&auc);"},{"entry":"\u2003printf(\u201c\\ndone\\n\u201d);"},{"entry":"\u2003return 0;"},{"entry":"\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0091","num":"0108"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#include <signal.h> #include <stdio.h> #include <stdlib.h> #include <sys\/time.h>"},{"entry":"#include <unistd.h> #include <ucontext.h>"},{"entry":"static volatile int expired; static ucontext_t uc[3]; static int switches;"},{"entry":"static void f(intn)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{int m = 0;"]},{"entry":[{},"while (1)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{\/\/This is where the work would be done"]},{"entry":[{},"printf(\u201cf(%i)\\n\u201d,n); fflush (stdout);"]},{"entry":[{},"\/\/The alarm sets the expired flag."]},{"entry":[{},"if (expired)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"252pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ if (++switches == 5) return; \/\/Quit after awhile."]},{"entry":[{},"printf (\u201c\\nswitching from %d to %d\\n\u201d, n, 3-n);"]},{"entry":[{},"expired = 0; swapcontext(&uc[n], &uc[3-n]); }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"sleep (1); } }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"void AlarmHandler (int signalnum)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{printf (\u201cIn Alarm (signal number %d)\\n\u201d,signalnum);"]},{"entry":[{},"expired = 1; alarm(1); return; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"void SetAlarm( )"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{struct sigaction sact; sigemptyset(&sact.sa_mask);"]},{"entry":[{},"sact.sa_flags = 0; sact.sa_handler AlarmHandler;"]},{"entry":[{},"sigaction(SIGALRM, &sact,NULL); return; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"int main(void)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{char st[1]; char st[2]; \/\/For Unix, not needed"]},{"entry":[{},"Pause( ); SetAlarm( ); alarm(1); getcontext(&uc[1]);"]},{"entry":[{},"uc[1].uc_lin &uc[0];\u2003\u2003\/\/For Unix don't need to do this"]},{"entry":[{},"uc[1].uc_stack.ss_sp_sp = st1;\u2003\u2003\/\/For Unix don't need to do this"]},{"entry":[{},"uc[1].uc_stack.ss_size = sizeof(st1);"]},{"entry":[{},"makecontext(&uc[1], (void(*)(void))f,2,1); getcontext(&uc[2]);"]},{"entry":[{},"uc[2].uc_link = &uc[0]; uc[2].uc_stack.ss_sp_sp = st2; \/\/For Unix don't need to do this"]},{"entry":[{},"uc[2].uc_stack.ss_size = sizeof(st2);"]},{"entry":[{},"makecontext(&uc[2], (void(*)(void))f,2,2); swapcontext(&uc[0],&uc[1]);"]},{"entry":[{},"printf(\u201c\\n\u201d); return 0; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"**********************************************************\/ #endif"},{"entry":"\/\/UContext - Coroutines - via Threads (Threadsafe): ucontextTX.cpp"},{"entry":"\/\/\u2003WARNING: This module must only be linked in ONCE. Their may be only one instance"},{"entry":"of the global CurrentContextKey"},{"entry":"\/\/****Context Pointers****"},{"entry":"\/\/ucp->uc_link - Points to parent context. This value is never NULL,"},{"entry":"\/\/DestinationContext - Points to the destination (child) context."},{"entry":"\/\/GetCurrentContext - Thread local storage holds \u201cthis\u201d context. Analogous to the static"},{"entry":"current_context in ucontext.cpp. For the programs primary process thread or any thread not"},{"entry":"invoked via makecontext (\u201cmain\u201d thread), the GetCurrent( ) function creates a context structure"},{"entry":"to represent this main context."},{"entry":"\/\/ucp->uc_thread - Points to the thread for this context. Multiple contest may contain pointers to"},{"entry":"the same thread if getcontext( ) had been issued from within the same context."},{"entry":"\/\/ActiveSemaphore - Semaphore to prevent more than one real thread from switching in a"},{"entry":"context concurrently."},{"entry":"\/\/**********************************************************"},{"entry":"#include <stdarg.h> #include <stdlib.h> #include <string.h> #include <ASThread.h>"},{"entry":"#include <ucontext.h>"},{"entry":"Typedef unsigned int STACKWORD;"},{"entry":"\/\/****Thread for \u201cnew\u201dcontext (makecontext)****"},{"entry":"Class uContext_Thread : public ASThread"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{private:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"bool Done; int argc; STACKWORD *argv; ucontext_t *ucp;"]},{"entry":[{},"Semaphore ActiveSemaphore; Semaphore ContextSemaphore;"]},{"entry":[{},"const ucontext_t *DestinationContext;"]},{"entry":[{},"void (*func)(int argc, . . . );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"protected:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"int ThreadMain( );"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"uContext_Thread(ucontext_t *this ucp); ~uContext_Thread)( );"]},{"entry":[{},"bool IsDone( ) {return Done;}"]},{"entry":[{},"void SetFunction(void (*func)( ), int argc, STACKWORD *argv);"]},{"entry":[{},"Void Release (const ucontext_t *DC)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"252pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ActiveSemaphore.Take( ); \/\/Not already active."]},{"entry":[{},"DestinationContext = DC;"]},{"entry":[{},"Context Semaphore.Release( ); }\u2003\u2003\/\/ Run . . ."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Const ucontext_t* Suspend( ) \/\/Returns DC."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"252pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ ActiveSemaphore.Release( );\u2003\u2003\/\/Mark not active."]},{"entry":[{},"ContextSemaphore.Take( );\u2003\u2003\u2003\/\/Stop."]},{"entry":[{},"Return DestinationContext; } };"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/****Signal Control****"},{"entry":"static bool BlockSignals( )"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{#ifndef_WIN32"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"static sigset_t all; static boot initialized = false;"]},{"entry":[{},"if (!initialized) sigfillset(&all);"]},{"entry":[{},"return sigprocmask (SIG_BLOCK, &all,NULL) ==0;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"#else return true; #endif }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"static bool GetSignalMask(sigset_t *sigmask)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ #ifndef_WIN32 return sigprocmask (0,NULL,sigmask)==0; #else return true; #endif }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"static bool SetSignalMask (const sigset_t *sigmask)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ #ifndef_WIN32 return sigprocmask (SIG_SETMASK, sigmask, NULL)==0;"]},{"entry":[{},"#else return true; #endif }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/****Current Context (Thread Local Storage)****"},{"entry":"static Mutex CurrentContextKeyMutex;"},{"entry":"static STLSKey_t CurrentContextKey = INVALID_TLSKEY;"},{"entry":"static void SetCurrentContext(const ucontext_t *ucp)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{CurrentContextKeyMutex.Take( );"]},{"entry":[{},"If (CurrentContextKey ==INVALID_TLSKEY)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{CurrentContextKeyMutex.Release( ); throw Error_Memory( ); } }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CurrentContextKeyMutex.Release( );"]},{"entry":[{},"If (!SetTLS(CurrentContextKey, ucp)) throw Error( ); return; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"static const ucontext_t* GetCurrentContext( )"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ucontext_t *ucp; CurrentContextKeyMutex .Take( );"]},{"entry":[{},"if (CurrentContextKey == INVALID_TLSKEY)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{CurrentContextKey = CreateTLS( );"]},{"entry":[{},"If (CurrentContextKey == INVALID_TLSKEY)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"252pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{CurrentContextKeyMutex.Release( ); throw Error_Memory( ); } }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CurrentContextKeyMutex.Release( );"]},{"entry":[{},"ucp = (ucontext_t *)GetTLS(CurrentContextKey);"]},{"entry":[{},"if (!ucp)\u2003\u2003\/\/Main or new \u201cmain\u201d thread. Context will be a memory leak."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{\u2003\u2003\u2003\/\/Shouldn't be so many."]},{"entry":[{},"ucp = (ucontext_t *)malloc(sizeof(ucontext_t));"]},{"entry":[{},"if (!ucp) throw Error_Memory( );"]},{"entry":[{},"memset(ucp, 0, sizeof(ucontext_t));"]},{"entry":[{},"ucp->uc_thread new uContext_Thread(ucp);\u2003\u2003\/\/Just need"]},{"entry":[{},"if (!ucp->uc_thread) throw Error_Memory( );\u2003\u2003\u2003\/\/ContextSemaphore."]},{"entry":[{},"SetTLS (CurrentContextKey, ucp); } return ucp; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/****Thread for \u201cnew\u201d context (makecontext)****"},{"entry":"uContext_Thread::uContext_Thread(ucontext_t *this_ucp)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},":"]},{"entry":[{},"ActiveSemaphore(0), ContextSemaphore(0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{argc = 0; argv = NULL; func = NULL; Done = false; ucp = this_ucp; return; }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"uContext_Thread::~uContext_Thread( ) { if (argv) free(argv); return; }"},{"entry":"void uContext_Thread::SetFunction(void (*func)( ), int argc, STACKWORD *argv)"},{"entry":"{this->argc = argc; this->argv = argv;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"this->func = (void (*)(int, . . .))func; return; }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"uContext_Thread::ThreadMain( )"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{SetCurrentContext(ucp); Done false; Suspend( ); SetCurrentContext(ucp);"]},{"entry":[{},"ucontext_t *uc_parent = (ucontext_t *)ucp->uc_link;"]},{"entry":[{},"\/\/****Unmask signals, call thread function****"]},{"entry":[{},"SetSignalMask(&ucp->uc_sigmask);"]},{"entry":[{},"switch (argc)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{case 0: ((void (*)( ))func)( ); break;"]},{"entry":[{},"case 1: func(argv[0]);break;"]},{"entry":[{},"case 2: func(argv[0], argv[1]);break;"]},{"entry":[{},"case 3: func(argv[0], argv[1], argv[2]);break;"]},{"entry":[{},"case 4: func(argv[0], argv[1], argv[2], argv[3]);break;"]},{"entry":[{},"case 5: func(argv[0], argv[1], argv[2], argv[3], argv[4]);break;"]},{"entry":[{},"case 6: func(argv[0], argv[1], argv[2], argv[3], argv[4], argv[5]);break;"]},{"entry":[{},"case 7: func(argv[0], argv[1], argv[2], argv[3], argv[4], argv[5], argv[6]);break;"]},{"entry":[{},"case 8: func(argv[0], argv[1], argv[2], argv[3], argv[4], argv[5], argv[6],"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"argv[7]) ;break;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case 9: func(argv[0], argv[1], argv[2], argv[3], argv[4], argv[5], argv[6], argv[7],"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"argv[8]) ;break;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case 10: func(argv[0], argv[1], argv[2], argv[3], argv[4], argv[S], argv[6], argv[7],"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"argv[8], argv[9]);break;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"default: throw Error( ); }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"BlockSignals( ); Done = true;"]},{"entry":[{},"\/\/****Return from parent setcontext( ) - goto parent****"]},{"entry":[{},"SetCurrentContext(NULL);"]},{"entry":[{},"((uContext_Thread *)uc_parent->uc_thread)->Release(uc_parent); return 0; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/****ucontext functions****"},{"entry":"void makecontext(ucontext_t *ucp, void (*func)( ), int argc, . . . )"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{va_list params;"]},{"entry":[{},"if (!ucp \u2225 !argc) return;"]},{"entry":[{},"ucp ->uc_thread = new uContext_Thread(ucp);"]},{"entry":[{},"if (!ucp->uc_thread) throw Error_Memory( );"]},{"entry":[{},"\/\/****Acquire the parameters to pass to \u2018func\u2019****"]},{"entry":[{},"STACKWORD *argv = NULL;"]},{"entry":[{},"if (argc-1)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ argv = (STACKWORD *)malloc(sizeof(STACKWORD)*(argc\u22121));"]},{"entry":[{},"if (!argv) throw Error_Memory( );"]},{"entry":[{},"va_start(params, argc);"]},{"entry":[{},"for (int i=0; i<argc\u22121, i++) {argv[i] = va_arg(params, STACKWORD); }"]},{"entry":[{},"va_end(params); }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"((uContext_Thread *)ucp->uc_thread)->SetFunction(func, argc\u22121, argv);"]},{"entry":[{},"\/\/****Start Thread - just until it synchronizes****"]},{"entry":[{},"((uContext_Thread *)ucp->uc_thread)->Start( ); return; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"int setcontext(const ucontext_t *ucp)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{if (!ucp) return \u22121;"]},{"entry":[{},"uContext_Thread *this_thread, *target_thread"]},{"entry":[{},"const ucontext_t *this_context = GetCurrentContext( );"]},{"entry":[{},"this_thread (uContext_Thread *)this_context->uc_thread;"]},{"entry":[{},"target_thread = (uContext_Thread *)ucp->uc_thread;"]},{"entry":[{},"assert(this_context); assert(this_thread); assert(target_thread);"]},{"entry":[{},"if (target_thread == this_thread)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ \/\/****Same thread -> just jump to the saved stack position****"]},{"entry":[{},"BlockSignals( ); SetCurrentContext(ucp);"]},{"entry":[{},"Siglongjmp(((ucontext_t*)ucp)->jmpbuf,1); }"]},{"entry":[{},"sigset_t this_sigmask; GetSignalMask(&this_sigmask);"]},{"entry":[{},"BlockSignals( ); target_thread->Release(ucp);"]},{"entry":[{},"\/\/****Stop****"]},{"entry":[{},"this_context = this_thread->Suspend( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/****Revived****"]},{"entry":[{},"assert(this_context); SetCurrentContext(this context);"]},{"entry":[{},"If (target_thread->IsDone( ))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ \/\/****Previous context ended, cleanup and return****"]},{"entry":[{},"delete target_thread; ((ucontext_t *)ucp->uc_thread = NULL;"]},{"entry":[{},"SetSignalMask(&this_sigmask); }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{\/\/****Return to getcontext( )****"]},{"entry":[{},"Siglongjmp(((ucontext_t*)this_context)->jmpbuf, 1); } return 0; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"int swapcontext(ucontext_t *oucp, constucontext_t *ucp)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{bool Returning = false; int rc = getcontext(oucp);"]},{"entry":[{},"if (rc != 0) return rc;"]},{"entry":[{},"if (!Returning)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{Returning = true; setcontext(ucp); } return 0; }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"int _getcontext(ucontext_t *ucp)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{if (!ucp) return \u22121;"]},{"entry":[{},"Const ucontext_t *current*context = GetCurrentContext( );"]},{"entry":[{},"if (ucp != current_context) \/\/ Not current active thread so initialize the structure"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ memset(ucp,0,sizeof(ucontext_t));"]},{"entry":[{},"ucp->uc_link current_context; ucp->uc_thread = current_context->uc_thread;"]},{"entry":[{},"ucp->ucstack.ss_size = 1; \/\/For compatibility. Get the current signal mask for"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"stating up new thread contexts created by makecontext( )."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"GetSignalMask(&ucp->uc_sigmask); } return 0; }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"End of Code"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example and is not limited by the shape of the Figures of the drawings in which:",{"@attributes":{"id":"p-0035","num":"0038"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0036","num":"0039"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0037","num":"0040"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0038","num":"0041"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0039","num":"0042"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0040","num":"0043"},"figref":"FIGS. 5 and 6"},{"@attributes":{"id":"p-0041","num":"0044"},"figref":"FIGS. 7","b":["8","9"]},{"@attributes":{"id":"p-0042","num":"0045"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
