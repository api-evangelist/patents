---
title: Motion control systems and methods
abstract: A motion control system comprising a source application program, a target device, a parser, an emitter, a program engine, and a parser interface. The source application program is defined by a source language specification. The target device creates motion under control of application programs defined by a target language specification. The parser component contains logic for converting application programs defined by the source language specification into a generic format. An emitter component containing logic for converting application programs in the generic format into application programs defined by the target language specification. The program engine component directs the parser component to convert the source application program into a generic application program. The program engine component further directs the emitter component to convert the generic application program into a target application program defined by the target language specification. The parser interface defines communications between the parser component and the program engine component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07024666&OS=07024666&RS=07024666
owner: Roy-G-Biv Corporation
number: 07024666
owner_city: Bingen
owner_country: US
publication_date: 20030128
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND OF THE INVENTION","PRIOR ART","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application claims priority of U.S. Provisional Application Ser. No. 60\/352,302 filed Jan. 28, 2002, which is incorporated herein by reference, and U.S. Provisional Application Ser. No. 60\/353,366 filed Jan. 31, 2002, which is also incorporated herein by reference.","The present invention relates to motion control systems and, more particularly, to a software system that facilitates the creation of motion control commands.","The purpose of a motion control device is to move an object in a desired manner. The basic components of a motion control device are a controller and a mechanical system. The controller controls the mechanical system to move in a desired manner based on an application program comprising a sequence of instructions. While the mechanical system commonly comprises a drive and an electrical motor, other systems can be used to cause movement of an object based on a control signal. Additionally, it is possible for a motion control device to comprise a plurality of drives and motors to allow multi-axis control of the movement of the object.","Motion control devices are typically classified as general motion devices or computer numeric control (CNC) devices. General motion devices are general-purpose machines typically characterized by low cost controllers. CNC devices are relatively specialized, high level systems employing a high cost controller. The term \u201cmotion control system\u201d will be used in the following discussion to refer to any system employing one or both of a general motion device and a CNC device. A motion control system is often used in conjunction with a host computer or programmable logic controller (PLC). The host computer or PLC allows the use of a high-level programming language to generate control commands that are passed to the controller. Application programs may be stored at various locations in a motion control system, including directly on the controller of a target device such as a general motion device or CNC device.","The present invention is of particular importance in the context of a motion control system in which multiple programming languages and language variants are used. Companies that manufacture motion control devices are, traditionally, hardware oriented companies that manufacture software dedicated to the hardware that they manufacture. These software products may be referred to as low-level programs. Low-level programs usually work directly with the motion control command language specific to a given motion control device. While such low-level programs offer the programmer substantially complete control over the hardware, these programs are highly hardware dependent.","In contrast to low-level programs, high-level software programs, referred to sometimes as factory automation applications, allow a factory system designer to develop application programs that combine large numbers of input\/output (I\/O) devices, including motion control devices, into a complex system used to automate a factory floor environment. These factory automation applications allow any number of I\/O devices to be used in a given system, as long as these devices are supported by the high-level program. Custom applications, developed by other software developers, cannot be developed to take advantage of the simple motion control functionality offered by the factory automation program.","Additionally, these programs do not allow the programmer a great degree of control over the each motion control device in the system. Each program developed with a factory automation application must run within the context of that application.","The present invention also optionally has more specific application to an environment in which a general motion device is used to implement an application program written for a CNC device. The principles of the present invention are, however, generally applicable to any target motion control device that generates movement based on an application program.","A typical motion control system created for a particular task may use one or more application programs written in any number of different programming languages. The need thus exists for systems and methods that facilitate the generation of motion control commands in a multi-language environment. In addition, because of the relatively low cost of controllers for general motion devices, the need exists for systems and methods that convert programs written for CNC devices into control commands for general motion devices.","A number of software programs currently exist for programming individual motion control devices or for aiding in the development of systems containing a number of motion control devices.","The following is a list of documents disclosing presently commercially available high-level software programs: (a) Software Products For Industrial Automation, iconics 1993; (b) The complete, computer-based automation tool (IGSS), Seven Technologies A\/S; (c) OpenBatch Product Brief, PID, Inc.; (d) FIX Product Brochure, Intellution (1994); (e) Paragon TNT Product Brochure, Intec Controls Corp.; (f) WEB 3.0 Product Brochure, Trihedral Engineering Ltd. (1994); and (g) AIMAX-WIN Product Brochure, TA Engineering Co., Inc. The following documents disclose simulation software: (a) ExperTune PID Tuning Software, Gerry Engineering Software; and (b) XANALOG Model NL-SIM Product Brochure, XANALOG.","The following list identifies documents related to low-level programs: (a) Compumotor Digiplan 1993\u201394 catalog, pages 10\u201311; (b) Aerotech Motion Control Product Guide, pages 233\u201334; (c) PMAC Product Catalog, page 43; (d) PC\/DSP-Series Motion Controller C Programming Guide, pages 1\u20133; (e) Oregon Micro Systems Product Guide, page 17; (f) Precision Microcontrol Product Guide.","The Applicants are also aware of a software model referred to as WOSA that has been defined by Microsoft for use in the Windows programming environment. The WOSA model is discussed in the book Inside Windows 95, on pages 348\u2013351. WOSA is also discussed in the paper entitled WOSA Backgrounder: Delivering Enterprise Services to the Windows-based Desktop. The WOSA model isolates application programmers from the complexities of programming to different service providers by providing an API layer that is independent of an underlying hardware or service and an SPI layer that is hardware independent but service dependent. The WOSA model has no relation to motion control devices.","The Applicants are also aware of the common programming practice in which drivers are provided for hardware such as printers or the like; an application program such as a word processor allows a user to select a driver associated with a given printer to allow the application program to print on that given printer.","While this approach does isolate the application programmer from the complexities of programming to each hardware configuration in existence, this approach does not provide the application programmer with the ability to control the hardware in base incremental steps. In the printer example, an application programmer will not be able to control each stepper motor in the printer using the provided printer driver; instead, the printer driver will control a number of stepper motors in the printer in a predetermined sequence as necessary to implement a group of high level commands.","The software driver model currently used for printers and the like is thus not applicable to the development of a sequence of control commands for motion control devices.","The Applicants are additionally aware of application programming interface security schemes that are used in general programming to limit access by high-level programmers to certain programming variables. For example, Microsoft Corporation's Win32 programming environment implements such a security scheme. To the Applicants' knowledge, however, no such security scheme has ever been employed in programming systems designed to generate software for use in motion control systems.","The present invention is a motion control system comprising a source application program, a target device, a parser component, an emitter component, and a program engine component. The source application program is defined by a source language specification. The target device creates motion under control of application programs defined by a target language specification. The parser component contains logic for parsing application programs defined by the source language specification. The emitter component contains logic for translating application programs defined by the source language specification into application programs defined by the target language specification. The program engine component sends at least a portion of a source application program to the parser component to be parsed into a parsed application. The program engine component then sends the parsed application to the emitter component to be translated into a target application defined by the second language specification. The program engine then sends the target application either directly or indirectly to the target device.","Referring initially to , depicted therein is a translation system  constructed in accordance with, and embodying, the principles of the present invention. The translation system  generates commands based on one or more application programs  written in one or more source languages. The commands may be sent in real time to a motion device (not shown) but will more typically be sent to a motion services module  and\/or stored in a command file  for use at a later time.","The translation system  comprises a program engine , a parse engine , and an emit engine . Generally speaking, the parse engine  parses a source application program to obtain a parsed program, and the emit engine  converts the parsed program into a target program comprising one or more target commands. The commands may be machine specific but are more likely to conform to one or more hardware independent application programming interfaces (APIs) associated with the motion services module . In either case, the target application program conforms to a different language specification than the source application program. The target program is then sent either directly or indirectly to a target device .","All logic for translating a source application program to a target application program may be included in one or more parser components  and emitter components . Preferably, however, the parse engine  and emit engine  contain logic that is universal to the conversion of all source languages, while the parser components  and emitter components  contain only the logic required to perform the parsing and converting operations for a particular language. As new languages are developed or adopted, new parser components  and emitter components  may be developed and \u201cplugged into\u201d the parse engine  and the emit engine .","The motion services module  is or may be conventional and will be described herein only to the extent necessary for a complete understanding of the present invention. The motion services module  defines at least one and typically a plurality of APIs . As generally described above, the target commands conform to one or more of the APIs . For example, a first API represents a standardized API to which hardware manufacturers may conform when designing motion control devices. A second API represents a proprietary API as described, for example, in U.S. Pat. Nos. 5,691,897, 5,867,385, and 6,209,037. As discussed above, the motion services module  is not required in all of the scenarios in which the translation system  may be used and implemented.","The details of construction and operation of the translation system  will now be described in further detail.","The program engine  is designed to run any type of ASCII based application program regardless of its internal format. To do this, the program engine  uses the parser component  and emitter components  to understand (and optionally export) any application program written in a supported source language. The motion services module  is then used to run any target programs in an online or offline manner. When run in an online mode, motions occur immediately as the program is run; when running in an offline mode, the command file  is generated based on whatever target is in use by the motion services module .","The program engine , parse engine , and emit engine  work together to run programs in an online, offline or translated manner. Clients of the motion services module  can select or pre-configure the mode for which the program engine  runs when processing a source program.","The program engine  component is the main component used by the client. The program engine  coordinates all other components to carry out tasks necessary to process a given application program file. STEP, RS274D or other program files (ASCII or Binary) are example program file formats that may be passed to the program engine  for processing.","The parse engine  is responsible for managing all specific data parser component . A primary purpose of the exemplary parse engine  is to provide a universal base of functionality within the parse engine . Each specific parser component  may be as slim and simple as possible to create. As described above, a separate parse engine  and parser component  is not mandatory; however if the parse engine  is not used, the parser component  must then implement all parse functionality, including the universal base functionality that would otherwise be provided in the parse engine .","The parser components  are responsible for parsing the contents of the data format that the parser component  understands. For example, a standard EIA-274 parser component  would be expected to parse all standard EIA-274 based programs, whereas GE Fanuc G&M Code specific parser component  would be expected to parse a GE Fanuc G&M Code variant of the EIA-274 language (or other G&M code language). On another extreme, a STEP-238 parser component  would be expected to parse STEP-238 programs.","Like the parse engine , the emit engine  manages a set of components with the overall task of outputting a specific program format or directly performing actions that represent the actions requested by each line in a program previously parsed. Like the parse engine , the emit engine  is not required. If the emit engine  is not used, each emitter component  is expected to implement all specific emit functionality for a given output type and also to implement all generic functionality normally implemented by the emit engine .","Each emitter component  is responsible for outputting a specific output format. For example, a GE Fanuc type of emitter component  may output a GE Fanuc G&M Code variant. On the other hand, a direct emitter type of emitter component  may make direct calls to the XMC Motion Service to carry out the operations requested.","The application programs  are each associated with a particular language such as G&M Code files or STEP Code files. G&M Code files are CNC program files based on the EIA-274 ANSI standard format and variants thereof. STEP Code files are STEP program files designed to replace the need for G&M Code Files.","Referring now to , depicted therein is an online run scenario in which the translation system  may be used. When programs are run in an online manner, the actions specified in each line of the program are immediately run by the motion services module . This mode can be useful when single-stepping and\/or testing programs where immediate feedback is needed.","The following steps occur when running a program in the on-line mode. First the source application program or a portion of the program (via a program buffer) is sent to the program engine . Next, the program engine  directs the parse engine  to parse each line of the program (or program buffer). Optionally, a parser component  may take over the operations of the parse engine . In this case, the program engine  would communicate directly to the appropriate parser component .","When using the parse engine , the parse engine  performs all generic operations (such as file management, etc) and passes the data to the parser component  in a data buffer for the parser component  to parse. During the process, the parser component  tokenizes the data and parses out all parameter data into a universal format.","The tokens and universal data format created by the parse engine  and parser component  are then used by the program engine  to direct the XMC Motion Services (via the XMCAPI or OMAC compliant API) to carry out each operation corresponding to each token.","Referring now to , depicted therein is an offline run scenario. When running a program in an offline mode, physical motion may not occur; instead, a target program  defining the physical motions that are to take place is created. This new target program  is generated based on the specific target driver (not shown) used by the motion services module . In addition, the target driver used by the motion services module  determines the location of the target program . For example, the target program generated may end up residing on the target hardware motion controller in a native program format \u2018known\u2019 by that controller.","The following steps occur when running a program in the on-line mode. First, the source program or a portion thereof is sent (via a program buffer) to the program engine . Next, the program engine  directs the parse engine  to parse each line of the program (or program buffer). As above, one of the optional parser components  may take over the operations of the parse engine . In this case, the program engine  would communicate directly to the parser component .","When the parse engine  is used, the parse engine  performs all generic operations (such as file management, etc) and passes the data to the parser component . The data is stored in a data buffer and parsed by the parser component . During the process, the parser component  tokenizes the data and parses out all parameter data into a universal format. The tokens and universal data format created by the parse engine  and parser component  are then passed to the emit engine  for processing.","When processing the universal tokens, the emit engine  first directs the XMC Motion Services to \u2018Define\u2019 a new program or sub-program (for each specified in the universal data). After defining the program (or sub-program) the emit engine  calls one of the APIs , such as the industry standard first API or the proprietary second API as necessary to perform the actions specified by each token. As described above, the emit component  may be used to replace the emit engine  and perform specific algorithms (or improvements therein) that the existing emit engine  does not perform.","Referring now to , depicted therein is a translation run scenario in which the system  may be used. The following steps occur when running a program in the on-line mode. First the source program  or a portion thereof is sent (via a program buffer) to the program engine . Next, the program engine  directs the parse engine  to parse each line of the program (or program buffer). As above, an optional parser component  may take over the operations of the parse engine . In this case, the program engine  would communicate directly to the parser component .","When using the parse engine , the parse engine performs all generic operations (such as file management, etc) and passes the data to the parser component  in a data buffer for the parser component  to parse. During the process, the parser component  tokenizes the data and parses out all parameter data into a universal format. The tokens and universal data format created by the parse engine  and parser component  are then passed to the emit engine  for processing.","When processing the universal tokens, the emit engine  directs the emitter component  to output each token in the format that it supports. The output information is passed back to the emit engine . As above, a specific emit component  may be used to replace the emit engine  and perform specific algorithms (or improvements therein) that the existing emit engine  does not perform.","When the specific data format is received from the emitter component , the emit engine  then outputs the data buffer to the target data format (i.e. a file, data buffer, or other target). Again, a specific emit component  may be used to replace the emit engine  and perform specific algorithms (or improvements therein) that the existing emit engine  does not perform.","Referring now to , it can be seen that the translation system  exposes one and encapsulates several other components. In the exemplary system , these components are based on a component technology such as OLE\/COM from Microsoft Corporation. Bundling each object within one module is not required as they may be located at any location (i.e. across a network, and so forth), but doing so optimizes all communication between modules. The following diagram shows an example organization of all components making up the translation system , where all are housed within a single module such as a DLL (dynamic link library), executable, .NET package or other binary organization.","In the example above, the program engine , parse engine  and emit engine  are all contained within one module. This organization is not required but optimal for overall performance. The specific parser components  and specific emitter components  will more than likely be housed in separate binary modules to allow third party support for such modules. Again, the location of each component can vary as the program engine  can also implement and house specific parser component  and emitter components within the main program module. As shown with both the parser engine  and emit engine  in the diagram above, all specific parser components  and emitter components  preferably expose the IXMCDirect interface to allow seamless communications between all other modules.","The IXMCDirect interface is used for most communications between all components making up the program engine . The IXMCDirect interface comprises the following methods as specified in the standard OLE\/COM IDL format:\n\n","A more detailed description of each method implemented by the object is described below.","IXMCDirect::GetProperty:",{"@attributes":{"id":"p-0055","num":"0000"},"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":["Syntax HRESULT GetProperty(LPCTSTR pszPropName, LPXMC_PARAM_DATA rgData, DWORD dwCount);","Parameters LPCTSTR pszPropName\u2014string name of the property to query. LPXMC_PARAM_DATA rgData\u2014array of XMC_PARAM_DATA types that specify each parameter corresponding to the property. For example, a certain property may be made up of a number of elements\u2014in this case an array of XMC_PARAM_DATA items is returned, one for each element making up the property. In most cases a property is made up of a single element, thus a single element array is passed to this method. For more information on the XMC PARAM DATA type, see below.\n    \n    ","Return Value HRESULT\u2014NOERROR on success, or error code on failure."]}},"The IXMCDirect::GetProperty method is used to query the property corresponding to the property name \u2018pszPropName\u2019. Each component defines the properties that it supports.","IXMCDirect::SetProperty",{"@attributes":{"id":"p-0057","num":"0000"},"ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":["Syntax HRESULT SetProperty(LPCTSTR pszPropName, LPXMC_PARAM_DATA rgData, DWORD dwCount);","Parameters LPCTSTR pszPropName\u2014string name of the property to set.\n    \n    ","Return Value HRESULT\u2014NOERROR on success, or error code on failure."]}},"The IXMCDirect::SetProperty method is used to set a property in the component corresponding to the \u2018pszPropName\u2019 property. For the set of properties supported by the component, see the specific component description.","IXMCDirect::InvokeMethod",{"@attributes":{"id":"p-0059","num":"0000"},"ul":{"@attributes":{"id":"ul0007","list-style":"none"},"li":["Syntax HRESULT InvokeMethod(DWORD dwMethodIdx, LPXMC_PARAM_DATA rgData, DWORD dwCount);","Parameters DWORD dwMethodIdx\u2014number corresponding to the specific method to invoke. For more information on the method indexes available, see the set of namespaces defined for the component.\n    \n    ","Return Value HRESULT\u2014NOERROR on success, or error code on failure."]}},"The IXMCDirect::InvokeMethod method is used to call a specific method implemented by the motion services module . For more information on the methods supported, see the description of the specific component.","The following discussion describes the specific methods and properties that each component supports.","The program engine  component exposes the following properties and methods via the IXMCDirect interface described above.","Property Summary","No properties are specified for this component at this time.","Methods Summary","The following methods are implemented by the program engine  component:",{"@attributes":{"id":"p-0063","num":"0000"},"ul":{"@attributes":{"id":"ul0009","list-style":"none"},"li":["SetComponents\u2014used to set specific parser component  and emitter components.","SetInputPath\u2014used to set the root path for all programs that do not specify a path in their name.","SetInputProgram\u2014used to set the active program for which the program engine  is to process.","SetInputProgramBuffer\u2014used to set a program buffer (as an alternative to setting the program name) for the program engine  to process. When setting a program buffer, previous calls to SetProgram are ignored.","SetOutputPath\u2014used to set the root path for all programs that do not specify a path in their name.","SetOutputProgram\u2014used to set the active program for which the program engine  is to process.","SetOutputProgramBuffer\u2014used to set a program buffer (as an alternative to setting the program name) for the program engine  to process. When setting a program buffer, previous calls to SetProgram are ignored.","SetBreak\u2014used to set a break-point within a program. Break-points are used when running a program with the \u2018debug\u2019 option enabled.","SetInputProgram\u2014returns the name of the program currently set as the active program in the program engine .","GetOutputProgram\u2014returns the name of the program currently set as the active program in the program engine .","GetState\u2014returns the state of the program engine . For example the run state (single step, run, or idle) are returned.","Run\u2014runs a program (and all sub-programs) from star to finish. If the debug option is enabled, the program is run from the current location to the next break point (if one exists) or to the end of the program.","Reset\u2014resets the current location of the program to the beginning of the program.","RemoveBreak\u2014removes a break-point from the program.","RemoveAllBreaks\u2014removes all break-points from the program.\n\nIDX_XMC_PROGENG_SetComponents\n","Namespace IDX_XMC_NS_PROGENGINE","Syntax IDX_XMC_PROGENG_SetComponents, rgData, dwCount=2","Parameters rgData[0]\u2014(string) prog-id or CLSID (in string format) of the parser component  to use.\n    \n    ","Return Val NOERROR on success, or an error code on failure."]}},"The IDX_XMC_PROGENG_SetComponents method is used to set specific parser component  and emitter components used to process both input and output data.","IDX_XMC_PROGENG_SetInputPath",{"@attributes":{"id":"p-0065","num":"0000"},"ul":{"@attributes":{"id":"ul0011","list-style":"none"},"li":["Namespace IDX_XMC_NS_PROGENGINE","Syntax IDX_XMC_PROGENG_SetInputPath, rgData, dwCount=1","Parameters rgData[0]\u2014(string) name of the program path in standard UNC format. Unless otherwise specified in the specific program name, the path specified by this method is used as the root path for all programs.","Return Val NOERROR on success, or an error code on failure."]}},"The IDX_XMC_PROGENG_SetInputPath method is used to set the root path for all programs. Unless a program name already has a path pre-pended to it, the path specified by this method is used to reference all programs and sub-programs.","IDX_XMC_PROGENG_SetInputProgram",{"@attributes":{"id":"p-0067","num":"0000"},"ul":{"@attributes":{"id":"ul0012","list-style":"none"},"li":["Namespace IDX_XMC_NS_PROGENGINE","Syntax IDX_XMC_PROGENG_SetInputProgram, rgData, dwCount=1","Parameters rgData[0]\u2014(string) name of the program to set as the active program.","Return Val NOERROR on success, or an error code on failure."]}},"The IDX_XMC_PROGENG_SetInputProgram method is used to set the active program that the program engine  is to process.","IDX_XMC_PROGENG_SetInputProgramBuffer",{"@attributes":{"id":"p-0069","num":"0000"},"ul":{"@attributes":{"id":"ul0013","list-style":"none"},"li":["Namespace IDX_XMC_NS_PROGENGINE","Syntax IDX_XMC_PROGENG_SetInputProgramBuffer, rgData, dwCount=2","Parameters rgData[0]\u2014(string) pointer to the string buffer containing the program data.\n    \n    ","Return Val NOERROR on success, or an error code on failure."]}},"The IDX_XMC_PROGENG_SetInputProgramBuffer method is used to set the active program buffer that the program engine  is to process. Any previous calls to SetInputProgram are overridden after making this call.","IDX_XMC_PROGENG_SetOutputPath",{"@attributes":{"id":"p-0071","num":"0000"},"ul":{"@attributes":{"id":"ul0015","list-style":"none"},"li":["Namespace IDX_XMC_NS_PROGENGINE","Syntax IDX_XMC_PROGENG_SetOutputPath, rgData, dwCount=1","Parameters rgData[0]\u2014(string) name of the program path in standard UNC format. Unless otherwise specified in the specific program name, the path specified by this method is used as the root path for all programs.","Return Val NOERROR on success, or an error code on failure."]}},"The IDX_XMC_PROGENG_SetOutputPath method is used to set the root path for all output programs. Unless a program name already has a path pre-pended to it, the path specified by this method is used to reference all programs and sub-programs.","IDX_XMC_PROGENG_SetOutputProgram",{"@attributes":{"id":"p-0073","num":"0000"},"ul":{"@attributes":{"id":"ul0016","list-style":"none"},"li":["Namespace IDX_XMC_NS_PROGENGINE","Syntax IDX_XMC_PROGENG_SetOutputProgram, rgData, dwCount=1","Parameters rgData[0]\u2014(string) name of the program to set as the active output program.","Return Val NOERROR on success, or an error code on failure."]}},"The IDX_XMC_PROGENG_SetOutputProgram method is used to set the active output program that the program engine  is to create.","IDX_XMC_PROGENG_SetOutputProgramBuffer",{"@attributes":{"id":"p-0075","num":"0000"},"ul":{"@attributes":{"id":"ul0017","list-style":"none"},"li":["Namespace IDX_XMC_NS_PROGENGINE","Syntax IDX_XMC_PROGENG_SetOutputProgramBuffer, rgData, dwCount=2","Parameters rgData[0]\u2014(string) pointer to the string buffer to be used for program output.\n    \n    ","Return Val NOERROR on success, or an error code on failure."]}},"The IDX_XMC_PROGENG_SetOutputProgramBuffer method is used to set the active output program buffer that the program engine  is to process. Any previous calls to SetOutputProgram are overridden after making this call.","IDX_XMC_PROGENG_SetBreak",{"@attributes":{"id":"p-0077","num":"0000"},"ul":{"@attributes":{"id":"ul0019","list-style":"none"},"li":["Namespace IDX_XMC_NS_PROGENGINE","Syntax IDX_XMC_PROGENG_SetBreak, rgData, dwCount=2","Parameters rgData[0]\u2014(string) program name for the break (i.e. sub-program, or main program).\n    \n    ","Return Val NOERROR on success, or an error code on failure."]}},"The IDX_XMC_PROGENG_SetBreak method is used to set a break-point in either the main program or a sub-program used by the main program.","IDX_XMC_PROGENG_GetInputProgram",{"@attributes":{"id":"p-0079","num":"0000"},"ul":{"@attributes":{"id":"ul0021","list-style":"none"},"li":["Namespace IDX_XMC_NS_PROGENGINE","Syntax IDX_XMC_PROGENG_GetProgram, rgData, dwCount=1\u20134","Parameters rgData[0]\u2014(string) the active program name is returned in this parameter.\n    \n    ","Return Val NOERROR on success, or an error code on failure."]}},"The IDX_XMC_PROGENG_GetInputProgram method is used to retrieve the current program and sub-program (if available) names. If a buffer is used instead of a program, a value of \u201cinternal buffer\u201d is returned.","IDX_XMC_PROGENG_GetOutputProgram",{"@attributes":{"id":"p-0081","num":"0000"},"ul":{"@attributes":{"id":"ul0023","list-style":"none"},"li":["Namespace IDX_XMC_NS_PROGENGINE","Syntax IDX_XMC_PROGENG_GetOutputProgram, rgData, dwCount=1\u20134","Parameters rgData[0]\u2014(string) the active output program name is returned in this parameter.\n    \n    ","Return Val NOERROR on success, or an error code on failure."]}},"The IDX_XMC_PROGENG_GetOutputProgram method is used to retrieve the current output program and sub-program (if available) names. If a buffer is used instead of a program, a value of \u201cinternal buffer\u201d is returned.","IDX_XMC_PROGENG_GetState",{"@attributes":{"id":"p-0083","num":"0000"},"ul":{"@attributes":{"id":"ul0025","list-style":"none"},"li":["Namespace IDX_XMC_NS_PROGENGINE","Syntax IDX_XMC_PROGENG_GetState, rgData, dwCount=1","Parameters rgData[0]\u2014(number:DWORD) the current state of the program engine  is returned in this parameter where valid date values are as follows:\n    \n    ","Return Val NOERROR on success, or an error code on failure."]}},"The IDX_XMC_PROGENG_GetState method is used to retrieve the current state of the program engine .","IDX_XMC_PROGENG_Run",{"@attributes":{"id":"p-0085","num":"0000"},"ul":{"@attributes":{"id":"ul0027","list-style":"none"},"li":["Namespace IDX_XMC_NS_PROGENGINE","Syntax IDX_XMC_PROGENG_Run, rgData, dwCount=1","Parameters rgData[0]\u2014(number:DWORD) the current mode for which the program should be run.\n    \n    ","Return Val NOERROR on success, or an error code on failure."]}},"The IDX_XMC_PROGENG_Run method is used to run the active program currently set in the program engine .","IDX_XMC_PROGENG_Reset",{"@attributes":{"id":"p-0087","num":"0000"},"ul":{"@attributes":{"id":"ul0029","list-style":"none"},"li":["Namespace IDX_XMC_NS_PROGENGINE","Syntax IDX_XMC_PROGENG_Reset, rgData=NULL, dwCount=0","Parameters No parameters","Return Val NOERROR on success, or an error code on failure."]}},"The IDX_XMC_PROGENG_Run method is used to stop running a program and reset the current position in the active program to the beginning of the program.","IDX_XMC_PROGENG_RemoveBreak",{"@attributes":{"id":"p-0089","num":"0000"},"ul":{"@attributes":{"id":"ul0030","list-style":"none"},"li":["Namespace IDX_XMC_NS_PROGENGINE","Syntax IDX_XMC_PROGENG_RemoveBreak, rgData, dwCount=2","Parameters rgData[0]\u2014(string) program name for the break (i.e. sub-program, or main program).\n    \n    ","Return Val NOERROR on success, or an error code on failure."]}},"The IDX_XMC_PROGENG_RemoveBreak method is used to remove a break-point in either the main program or a sub-program used by the main program.","IDX_XMC_PROGENG_RemoveAllBreaks",{"@attributes":{"id":"p-0091","num":"0000"},"ul":{"@attributes":{"id":"ul0032","list-style":"none"},"li":["Namespace IDX_XMC_NS_PROGENGINE","Syntax IDX_XMC_PROGENG_RemoveAllBreaks, rgData=NULL, dwCount=0","Parameters No parameters","Return Val NOERROR on success, or an error code on failure."]}},"The IDX_XMC_PROGENG_RemoveAllBreaks method is used to remove all break-points previously set.","The parser engine component  exposes the following properties and methods via the IXMCDirect interface described above.","Property Summary","No properties are specified for this component at this time.","Methods Summary","The following methods are implemented by the parser engine component:\n\n","The IDX_XMC_PARSEENG_SetInputRoot method is used to set the root path for all programs. Unless a program name already has a path pre-pended to it, the path specified by this method is used to reference all programs and sub-programs.","IDX_XMC_PARSEENG_SetInput",{"@attributes":{"id":"p-0097","num":"0000"},"ul":{"@attributes":{"id":"ul0034","list-style":"none"},"li":["Namespace IDX_XMC_NS_PROGENGINE","Syntax IDX_XMC_PARSEENG_SetInput, rgData, dwCount=2","Parameters rgData[0]\u2014(number:DWORD) flag specifying the input type. The following input flags are supported:\n    \n    ","Return Val NOERROR on success, or an error code on failure."]}},"The IDX_XMC_PARSEENG_SetInput method is used to set the active program, program buffer, or other program source that the parse engine  is to process.","IDX_XMC_PARSEENG_GetInput",{"@attributes":{"id":"p-0099","num":"0000"},"ul":{"@attributes":{"id":"ul0036","list-style":"none"},"li":["Namespace IDX_XMC_NS_PROGENGINE","Syntax IDX_XMC_PARSEENG_GetInput, rgData, dwCount=1","Parameters rgData[0]\u2014(number:DWORD) flag specifying the input type. The following input flags are supported:\n    \n    ","Return Val NOERROR on success, or an error code on failure."]}},"The IDX_XMC_PARSEENG_GetInput method is used to retrieve the current program or sub-program (if available) name.","IDX_XMC_PARSEENG_Step",{"@attributes":{"id":"p-0101","num":"0000"},"ul":{"@attributes":{"id":"ul0038","list-style":"none"},"li":["Namespace IDX_XMC_NS_PROGENGINE","Syntax IDX_XMC_PARSEENG_Step, rgData, dwCount=0\u20131","Parameters rgData[0] [optional]\u2014(number:DWORD) flags specifying how to make the step operation. Currently this flag is reserved and should be set to 0 (zero).","Return Val S_OK on success, S_FALSE at end of data, or an error code on failure."]}},"The IDX_XMC_PARSEENG_Step method is used to step to the next line in the active program currently set in the parse engine .","IDX_XMC_PARSEENG_Reset",{"@attributes":{"id":"p-0103","num":"0000"},"ul":{"@attributes":{"id":"ul0039","list-style":"none"},"li":["Namespace IDX_XMC_NS_PROGENGINE Syntax IDX_XMC_PARSEENG_Reset, rgData=NULL, dwCount=0","Parameters No parameters","Return Val NOERROR on success, or an error code on failure."]}},"The IDX_XMC PARSEENG_Reset method is used to reset the current position in the active program to the beginning of the program.","IDX_XMC_PARSEENG_ParseLine",{"@attributes":{"id":"p-0105","num":"0000"},"ul":{"@attributes":{"id":"ul0040","list-style":"none"},"li":["Namespace IDX_XMC_NS_PROGENGINE","Syntax IDX_XMC_PARSEENG_ParseLine, rgData=NULL, dwCount=1 to 1024 max","Parameters rgData[0]\u2014(out-number) this out parameter contains the actual number of tokens returned for the line.\n    \n    ","Return Val NOERROR on success, or an error code on failure."]}},"The IDX_XMC_PARSEENG_ParseLine method is used to parse the current line into a universal token and associated parameters.","The XMC emit engine component  exposes the following properties and methods via the IXMCDirect interface described above.","Property Summary","No properties are specified for this component at this time.","Methods Summary","The following methods are implemented by the emit engine  component:\n\n","The IDX_XMC_EMITENG_SetOutputRoot method is used to set the root path for all programs. Unless a program name already has a path pre-pended to it, the path specified by this method is used to reference all programs and sub-programs.","IDX_XMC_EMITENG_SetOutput",{"@attributes":{"id":"p-0111","num":"0000"},"ul":{"@attributes":{"id":"ul0043","list-style":"none"},"li":["Namespace IDX_XMC_NS_PROGENGINE","Syntax IDX_XMC_EMITENG_SetOutput, rgData, dwCount=2","Parameters rgData[0]\u2014(number:DWORD) flag specifying the output type. The following input flags are supported:\n    \n    ","Return Val NOERROR on success, or an error code on failure."]}},"The IDX_XMC_EMITENG_SetOutput method is used to set the active output program, program buffer, or other program source that the emit engine  outputs all program data to.","IDX_XMC_EMITENG_GetOutput",{"@attributes":{"id":"p-0113","num":"0000"},"ul":{"@attributes":{"id":"ul0045","list-style":"none"},"li":["Namespace IDX_XMC_NS_PROGENGINE","Syntax IDX_XMC_EMITENG_GetOutput, rgData, dwCount=1","Parameters rgData[0]\u2014(number:DWORD) flag specifying the output type. The following input flags are supported:\n    \n    ","Return Val NOERROR on success, or an error code on failure."]}},"The IDX_XMC_EMITENG_GetOutput method is used to retrieve the current program or sub-program (if available) name.","IDX_XMC_EMITENG_EmitLine",{"@attributes":{"id":"p-0115","num":"0000"},"ul":{"@attributes":{"id":"ul0047","list-style":"none"},"li":["Namespace IDX_XMC_NS_PROGENGINE","Syntax IDX_XMC_EMITENG_EmitLine, rgData=NULL, dwCount=1 to 1024 max","Parameters rgData[0]\u2014(out-string) this out parameter contains the resulting line of instructions in the native format produced by the emitter.\n    \n    ","Return Val NOERROR on success, or an error code on failure."]}},"The IDX_XMC_EMITENG_EmitLine method is used to emit the current line based on a universal token set and associated parameters.","Each parser component component  exposes the following properties and methods via the IXMCDirect interface described above.","Property Summary","No properties are specified for this component at this time.","Methods Summary","The following methods are implemented by each parser component  component:\n\n","The IDX_XMC_PARSEENG_ParseLine method is used to parse the current line into a universal token and associated parameters.","Each emitter component  exposes the following properties and methods via the IXMCDirect interface described above.","Property Summary","No properties are specified for this component at this time.","Methods Summary","The following methods are implemented by each emitter component :\n\n","The IDX_XMC_EMITENG_EmitLine method is used to emit the current line based on a universal token set and associated parameters.","The following discussion contains the definitions of all special types used by the methods and properties of each component making up the program engine .","XMC_PARAM_DATA Structure","All methods exposed by each component in the program engine  system use the standard XMC parameters set to describe data used to set and query properties as well as invoke methods. The standard parameters are in the following format:","pObj->InvokeMethod(LPXMC_PARAM_DATA rgData, DWORD dwcount); Each element in the rgData array corresponds to a parameter, with the first element in the array corresponding to the first parameter.","The XMC_PARAM_DATA structure can contain either a numerical or a string value and is defined as follows:",{"@attributes":{"id":"p-0129","num":"0342"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct tagXMC_PARAM_DATA"]},{"entry":[{},"{"]},{"entry":[{},"\u2003LNG_PARAM_DATATYPEadt;"]},{"entry":[{},"\u2003union"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003double df;"]},{"entry":[{},"\u2003\u2003LPTSTR psz;"]},{"entry":[{},"\u2003};"]},{"entry":[{},"}XMC_PARAM_DATA;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The \u2018adt\u2019 member of the XMC_PARAM_DATA structure describes the data contained within the XMC_PARAM_DATA structure. The values are described below:\n\n","When querying and setting boolean TRUE\/FALSE values, any non-zero value is considered TRUE, whereas a zero value is considered FALSE.","The following discussion contains examples of the three methods that the program engine  processes program data: online, offline and translation.","All examples shown in this section (including the online, offline and translation examples) use the same input data. For this reason, the first step of translating the input data to the intermediate universal tokenized data is presented in this section. Each following example, builds on the tokenized data presented in this section for the main difference in each is in how the output data and\/or actions are produced.","The following source code is used as the G&M Code ASCII text file input to the program engine .\n\n","When processing the input data, the following is an example of the intermediate universal tokens (and associated parameters) that represent the program after it is parsed.",{"@attributes":{"id":"p-0136","num":"0363"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Input Line","Tokens Generated"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["O0003","rgData[0] = 2"]},{"entry":[{},"rgData[1] = TOK_PROGNAME"]},{"entry":[{},"rgData[2] = 1"]},{"entry":[{},"rgData[3] = \u201cO0003\u201d"]},{"entry":[{},"rgData[4] = TOK_ENDLINE"]},{"entry":[{},"rgData[5] = 0"]},{"entry":["N005 G91 G28 X0 Y0 Z0","rgData[0] = 7"]},{"entry":[{},"rgData[1] = TOK_LINEID"]},{"entry":[{},"rgData[2] = 1"]},{"entry":[{},"rgData[3] = 5"]},{"entry":[{},"rgData[4] ="]},{"entry":[{},"TOK_MOVE_SETINCMODE"]},{"entry":[{},"rgData[5] = 0"]},{"entry":[{},"rgData[6] = TOK_MOVE_TOHOME"]},{"entry":[{},"rgData[7] = 1"]},{"entry":[{},"rgData[8] = 3 (use next 3 tokens)"]},{"entry":[{},"rgData[9] = TOK_POS_X"]},{"entry":[{},"rgData[10] = 1"]},{"entry":[{},"rgData[11] = 0"]},{"entry":[{},"rgData[12] = TOK_POS_Y"]},{"entry":[{},"rgData[13] = 1"]},{"entry":[{},"rgData[14] = 0"]},{"entry":[{},"rgData[15] = TOK_POS_Z"]},{"entry":[{},"rgData[16] = 1"]},{"entry":[{},"rgData[17] = 0"]},{"entry":[{},"rgData[18] = TOK_ENDLINE"]},{"entry":[{},"rgData[19] = 0"]},{"entry":["N010 G54","rgData[0] = 3"]},{"entry":[{},"rgData[1] = TOK_LINEID"]},{"entry":[{},"rgData[2] = 1"]},{"entry":[{},"rgData[3] = 10"]},{"entry":[{},"rgData[4] ="]},{"entry":[{},"TOK_MOVE_SETZEROPOS"]},{"entry":[{},"rgData[5] = 0"]},{"entry":[{},"rgData[18] = TOK_ENDLINE"]},{"entry":[{},"rgData[19] = 0"]},{"entry":["N015 G90 S1300 M03 T02","rgData[0] = 6"]},{"entry":[{},"rgData[1] = TOK_LINEID"]},{"entry":[{},"rgData[2] = 1"]},{"entry":[{},"rgData[3] = 15"]},{"entry":[{},"rgData[4] ="]},{"entry":[{},"TOK_MOVE_SETABSMODE"]},{"entry":[{},"rgData[5] = 0"]},{"entry":[{},"rgData[6] = TOK_SPINDLE_SETRATE"]},{"entry":[{},"rgData[7] = 1"]},{"entry":[{},"rgData[8] = 1300"]},{"entry":[{},"rgData[9] = TOK_SPINDLE_ON"]},{"entry":[{},"rgData[10] = 1"]},{"entry":[{},"rgData[11] = 1 (1 = CW, \u22121 = CCW)"]},{"entry":[{},"rgData[12] = TOK_TOOL_SELECT"]},{"entry":[{},"rgData[13] = 1"]},{"entry":[{},"rgData[14] = 2"]},{"entry":[{},"rgData[15] = TOK_ENDLINE"]},{"entry":[{},"rgData[16] = 0"]},{"entry":["N020 G00 X1. Y1.","rgData[0] = 5"]},{"entry":[{},"rgData[1] = TOK_LINEID"]},{"entry":[{},"rgData[2] = 1"]},{"entry":[{},"rgData[3] = 20"]},{"entry":[{},"rgData[4] = TOK_MOVE_SETRAPID"]},{"entry":[{},"rgData[5] = 0"]},{"entry":[{},"rgData[6] = TOK_POS_X"]},{"entry":[{},"rgData[7] = 1"]},{"entry":[{},"rgData[8] = 1"]},{"entry":[{},"rgData[9] = TOK_POS_Y"]},{"entry":[{},"rgData[10] = 1"]},{"entry":[{},"rgData[11] = 1"]},{"entry":[{},"rgData[12] = TOK_ENDLINE"]},{"entry":[{},"rgData[13] = 0"]},{"entry":["N025 G43 H01 Z.1","rgData[0] = 5"]},{"entry":[{},"rgData[1] = TOK_LINEID"]},{"entry":[{},"rgData[2] = 1"]},{"entry":[{},"rgData[3] = 25"]},{"entry":[{},"rgData[4] = TOK_OFFSET_TOOL_LEN"]},{"entry":[{},"rgData[5] = 1"]},{"entry":[{},"rgData[6] = 1 (use next 1 tokens)"]},{"entry":[{},"rgData[7] = TOK_OFFSET_SELECT"]},{"entry":[{},"rgData[8] = 1"]},{"entry":[{},"rgData[9] = 1"]},{"entry":[{},"rgData[10] = TOK_POS_Z"]},{"entry":[{},"rgData[11] = 1"]},{"entry":[{},"rgData[12] = 0.1"]},{"entry":[{},"rgData[13] = TOK_ENDLINE"]},{"entry":[{},"rgData[14] = 0"]},{"entry":["N030 M08","rgData[0] = 3"]},{"entry":[{},"rgData[1] = TOK_LINEID"]},{"entry":[{},"rgData[2] = 1"]},{"entry":[{},"rgData[3] = 25"]},{"entry":[{},"rgData[4] = TOK_COOLANT_ON"]},{"entry":[{},"rgData[5] = 0"]},{"entry":[{},"rgData[6] = TOK_ENDLINE"]},{"entry":[{},"rgData[7] = 0"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The following pseudo code demonstrates how the program engine  is used to convert the input data file shown above into a the intermediate universal tokenized data and associated parameters above.",{"@attributes":{"id":"p-0138","num":"0365"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["IXMCDirect*","pProgEng;"]},{"entry":["HRESULT","hr;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"XMC_PARAM_DATA rgData[128];"},{"entry":"hr = CoCreateInstance(CLSID_ProgEng, . . . ,"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IID_IXMCDirect,"]},{"entry":[{},"(LPVOID)&pProgEng);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"rgData[0].adt = LNG_ADT_STAT_STRING;"},{"entry":"rgData[0].psz = \u201cXMC.PARSER.GCODE.RS274\u201d;"},{"entry":"hr = pProgEng\u2212>InvokeMethod"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(IDX_XMC_PROGENG_SetComponents, rgData, 1);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"rgData[0].adt = LNG_ADT_STAT_STRING;"},{"entry":"rgData[0].psz = \u201cc:\\temp\u201d;"},{"entry":"hr = pProgEng\u2212>InvokeMethod(IDX_XMC_PROGENG_SetInputPath,"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"rgData, 1);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"rgData[0].psz = \u201ctest.cnc\u201d;"},{"entry":"hr = pProgEng\u2212>InvokeMethod"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(IDX_XMC_PROGENG_SetInputProgram, rgData, 1);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"rgData[0].adt = LNG_ADT_NUMBER;"},{"entry":"rgData[0].df = 0.0;"},{"entry":"hr = pProgEng\u2212>InvokeMethod(IDX_XMC_PROGENG_Run, rgData,"},{"entry":"1);"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Internally, when directed to run the program via the"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"IDX_XMC_PROGENG_RUN method, the following pseudo code"},{"entry":"follows."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["IXMCDirect*","m_pParser;"]},{"entry":["IXMCDirect*","m_pEmitter;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"XMC_PARAM_DATA m_rgData[128];"},{"entry":"."},{"entry":"."},{"entry":"."},{"entry":"\/\/ note, the parser component 40 and emitter are created when the program"},{"entry":"engine"},{"entry":"\/\/ received the _SetComponents call."},{"entry":"\/\/"},{"entry":"\/\/ In addition, the input root and input program name should have"},{"entry":"\/\/ already been set during the previous calls to _SetInputPath and"},{"entry":"\/\/ _SetInputProgram as shown above."},{"entry":"IDX_XMC_PROGENG_RUN - method start"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"hr = m_pParser\u2212>InvokeMethod(IDX_XMC_PARSEENG_Reset,"]},{"entry":[{},"NULL, 0);"]},{"entry":[{},"hr = S_OK"]},{"entry":[{},"while (hr == S_OK)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"hr = m_pParser\u2212>InvokeMethod"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(IDX_XMC_PARSEENG_ParseLine, m_rgData, 128);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ m_rgData now contains the tokenized data for the current"]},{"entry":[{},"\/\/ line of data."]},{"entry":[{},"hr = processTokens(m_rgData, 128);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"HRESULT processTokens(LPXMC_PARAM_DATA rgData, DWORD"},{"entry":"dwCount)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ specific to online, offline or translate modes."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"@"}]}}]}}},"In the online processing example, a standard RS274D G&M Code ASCII text file is used as input and run using the XMC Motion Services. The same input data presented in the \u2018Preparation Example\u2019 is used for this example and, for that reason, this example will use the same intermediate universal tokenized data shown above.","The following pseudo code represents the actions output (i.e. the motions that occur) when running the input file with the program engine .",{"@attributes":{"id":"p-0141","num":"0368"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Tokens Generated","Pseudo code actions"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["rgData[0] = 2","No action taken for the program"]},{"entry":["rgData[1] = TOK_PROGNAME","will run immediately in online"]},{"entry":["rgData[2] = 1","mode."]},{"entry":"rgData[3] = \u201cO0003\u201d"},{"entry":"rgData[4] = TOK_ENDLINE"},{"entry":"rgData[5] = 0"},{"entry":"rgData[0] = 7"},{"entry":"rgData[1] = TOK_LINEID"},{"entry":"rgData[2] = 1"},{"entry":"rgData[3] = 5"},{"entry":["rgData[4] =","Set incremental move mode."]},{"entry":"TOK_MOVE_SETINCMODE"},{"entry":["rgData[5] = 0","Set MoveToHome action."]},{"entry":"rgData[6] ="},{"entry":"TOK_MOVE_TOHOME"},{"entry":["rgData[7] = 1","Set X position for action."]},{"entry":"rgData[8] = 3 (use next 3 tokens)"},{"entry":"rgData[9] = TOK_POS_X"},{"entry":["rgData[10] = 1","Set Y position for action."]},{"entry":"rgData[11] = 0"},{"entry":"rgData[12] = TOK_POS_Y"},{"entry":["rgData[13] = 1","Set Z position for action."]},{"entry":"rgData[14] = 0"},{"entry":"rgData[15] = TOK_POS_Z"},{"entry":["rgData[16] = 1","Perform the previous action."]},{"entry":["rgData[17] = 0","Wait for action to complete."]},{"entry":"rgData[18] = TOK_ENDLINE"},{"entry":"rgData[19] = 0"},{"entry":"rgData[0] = 3"},{"entry":"rgData[1] = TOK_LINEID"},{"entry":"rgData[2] = 1"},{"entry":"rgData[3] = 10"},{"entry":["rgData[4] =","Set zero position on all axes."]},{"entry":"TOK_MOVE_SETZEROPOS"},{"entry":"rgData[5] = 0"},{"entry":"rgData[6] = TOK_ENDLINE"},{"entry":"rgData[7] = 0"},{"entry":"rgData[0] = 6"},{"entry":"rgData[1] = TOK_LINEID"},{"entry":"rgData[2] = 1"},{"entry":"rgData[3] = 15"},{"entry":["rgData[4] =","Set absolute move mode."]},{"entry":"TOK_MOVE_SETABSMODE"},{"entry":["rgData[5] = 0","Set rotation rate for axis"]},{"entry":["rgData[6] =","designated as the spindle axis."]},{"entry":"TOK_SPINDLE_SETRATE"},{"entry":["rgData[7] = 1","Start rotating the spindle axis in"]},{"entry":["rgData[8] = 1300","CW direction."]},{"entry":"rgData[9] = TOK_SPINDLE_ON"},{"entry":["rgData[10] = 1","Run the tool-select \u2018canned\u2019"]},{"entry":["rgData[11] = 1 (1 = CW, \u22121 = CCW)","program to select tool #2."]},{"entry":"rgData[12] = TOK_TOOL"},{"entry":"SELECT"},{"entry":"rgData[13] = 1"},{"entry":"rgData[14] = 2"},{"entry":"rgData[15] = TOK_ENDLINE"},{"entry":"rgData[16] = 0"},{"entry":"rgData[0] = 5"},{"entry":"rgData[1] = TOK_LINEID"},{"entry":"rgData[2] = 1"},{"entry":"rgData[3] = 20"},{"entry":["rgData[4] =","Set rapid move action."]},{"entry":"TOK_MOVE_SETRAPID"},{"entry":["rgData[5] = 0","Set X position for the action."]},{"entry":"rgData[6] = TOK_POS_X"},{"entry":"rgData[7] = 1"},{"entry":["rgData[8] = 1","Set Y position for the action."]},{"entry":"rgData[9] = TOK_POS_Y"},{"entry":"rgData[10] = 1"},{"entry":["rgData[11] = 1","Perform the previous action."]},{"entry":"rgData[12] = TOK_ENDLINE"},{"entry":"rgData[13] = 0"},{"entry":[{},"Set rapid move action (modal"]},{"entry":[{},"state previously set)."]},{"entry":"rgData[0] = 5"},{"entry":"rgData[1] = TOK_LINEID"},{"entry":"rgData[2] = 1"},{"entry":"rgData[3] = 25"},{"entry":["rgData[4] =","Select the Z axis offset array."]},{"entry":"TOK_OFFSET_TOOL_LEN"},{"entry":"rgData[5] = 1"},{"entry":["rgData[6] = 1 (use next 1 tokens)","Add the tool offset #1 to the Z axis"]},{"entry":["rgData[7] =","offset array."]},{"entry":"TOK_OFFSET_SELECT"},{"entry":["rgData[8] = 1","Set Z position for the action"]},{"entry":["rgData[9] = 1","making sure to add all active"]},{"entry":["rgData[10] = TOK_POS_Z","offsets in the Z axis offset array."]},{"entry":"rgData[11] = 1"},{"entry":["rgData[12] = 0.1","Perform the previous action."]},{"entry":"rgData[13] = TOK_ENDLINE"},{"entry":"rgData[14] = 0"},{"entry":"rgData[0] = 3"},{"entry":"rgData[1] = TOK_LINEID"},{"entry":"rgData[2] = 1"},{"entry":"rgData[3] = 25"},{"entry":["rgData[4] = TOK_COOLANT_ON","Run the tool-select \u2018canned\u2019"]},{"entry":["rgData[5] = 0","program to turn the coolant on."]},{"entry":"rgData[6] = TOK_ENDLINE"},{"entry":"rgData[7] = 0"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"When processing the input file, the following communications occur between the program engine  and its associated components.",{"@attributes":{"id":"p-0143","num":"0370"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/... continued from Process Flow example shown in the Preparation"},{"entry":"\/\/ Example above."},{"entry":"HRESULT processTokens( LPXMC_PARAM_DATA rgData, DWORD"},{"entry":"dwCount )"},{"entry":"{"},{"entry":"\u2003XMC_PARAM_DATA rgParams[128];"},{"entry":"\u2003DWORD \u2003dwParams;"},{"entry":"\u2003DWORD \u2003dwTokens = (DWORD)rgData[0].df;"},{"entry":"\u2003DWORD \u2003dwIdx \u2003= 1;"},{"entry":"\u2003DWORD \u2003dwTokenIdx = 0"},{"entry":"\u2003while (dwTokenIdx < dwTokens && dwIdx < dwCount)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003dwToken = (DWORD)rgData[dwIdx].df;"},{"entry":"\u2003\u2003dwIdx += 1;"},{"entry":"\u2003\u2003dwParams = (DWORD)rgData[dwIdx].df;"},{"entry":"\u2003\u2003dwIdx += 1;"},{"entry":"\u2003\u2003for (DWORD dwPdx=0; dwPdx<dwParams && dwPdx<128;"},{"entry":"\u2003\u2003dwPdx++)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003rgParams[dwPdx] = rgData[dwIdx+dwPdx];"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003dwIdx += dwPdx;"},{"entry":"\u2003\u2003switch (dwToken)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003case TOK_MOVE_SETINCMODE:"},{"entry":"\u2003\u2003\u2003\u2003\/\/ store move mode as incremental."},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case TOK_MOVE_SETABSMODE:"},{"entry":"\u2003\u2003\u2003\u2003\/\/ store move mode as absolute."},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case TOK_MOVE_SETRAPID:"},{"entry":"\u2003\u2003\u2003\u2003\/\/ store move action as rapid."},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case TOK_MOVE_TOHOME:"},{"entry":"\u2003\u2003\u2003\u2003\/\/ set move action to move home"},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case TOK_POS_X:"},{"entry":"\u2003\u2003\u2003\u2003\/\/ store X position."},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case TOK_POS_Y:"},{"entry":"\u2003\u2003\u2003\u2003\/\/ store Y position."},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case TOK_POS_Z:"},{"entry":"\u2003\u2003\u2003\u2003\/\/ store Z position."},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case TOK_MOVE_SETZEROPOS:"},{"entry":"\u2003\u2003\u2003\u2003\/\/ set action to set the zero axis."},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case TOK_SPINDLE_SETRATE:"},{"entry":"\u2003\u2003\u2003\u2003\/\/ store the spindle value as velocity (or rotation) for"},{"entry":"\u2003\u2003\u2003\u2003\/\/ the axis designated as the spindle axis."},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case TOK_SPINDLE_ON:"},{"entry":"\u2003\u2003\u2003\u2003\/\/ set action as \u2018run program\u2019."},{"entry":"\u2003\u2003\u2003\u2003\/\/ set target caned program to \u2018spindle_on\u2019."},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case TOK_TOOL_SELECT:"},{"entry":"\u2003\u2003\u2003\u2003\/\/ set action as \u2018run program\u2019."},{"entry":"\u2003\u2003\u2003\u2003\/\/ set target canned program to \u2018tool_select\u2019."},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case TOK_OFFSET_TOOL_LEN:"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Set active offset array to Z axis and if any"},{"entry":"\u2003\u2003\u2003\u2003\/\/ offsets are in the pending queue, add them to the"},{"entry":"\u2003\u2003\u2003\u2003\/\/ offset array and clear them from the queue."},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case TOK_OFFSET_SELECT:"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Add selected offset to active offset array, and if"},{"entry":"\u2003\u2003\u2003\u2003\/\/ no offset array is active, add to pending offset queue."},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case TOK_COOLANT_ON:"},{"entry":"\u2003\u2003\u2003\u2003\/\/ set action as \u2018run program\u2019."},{"entry":"\u2003\u2003\u2003\u2003\/\/ set target canned program to \u2018coolant_on\u2019."},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case TOK_ENDLINE:"},{"entry":"\u2003\u2003\u2003\u2003\/\/ perform the action previously stored using the stored"},{"entry":"\u2003\u2003\u2003\u2003\/\/ positions, offsets and\/or program names (to run) as"},{"entry":"\u2003\u2003\u2003\u2003\/\/ appropriate."},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The offline example is similar to the on-line example. The major difference between these examples is that, when the program name token is received (TOK_PROGNAME), the program engine  directs the XMC Motion Services to \u2018Define\u2019 a program using the given program name. In addition, just after processing the final token, the program engine  directs the XMC Motion Services to \u2018End\u2019 the program thus creating a new program on the current motion target used by the XMC Motion Services. For more information on defining and ending motion programs, see the XMC C++ Reference documentation contained within the XMC for Visual Studio product.","When running in translation mode, the universal tokens and associated parameters are passed to the emit engine  that uses the tokens to create a new program output based on the target emitter used. The following pseudo code demonstrates how the program engine  is used to convert the intermediate universal tokenized data and associated parameters above into a newly formatted output program file.",{"@attributes":{"id":"p-0146","num":"0373"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IXMCDirect* pProgEng;"]},{"entry":[{},"HRESULT \u2003\u2002hr;"]},{"entry":[{},"XMC_PARAM_DATA rgData[128];"]},{"entry":[{},"hr = CoCreateInstance( CLSID_ProgEng, ...,"]},{"entry":[{},"\u2003\u2003\u2003IID_IXMCDirect,"]},{"entry":[{},"\u2003\u2003\u2003(LPVOID)&pProgEng);"]},{"entry":[{},"rgData[0].adt = LNG_ADT_STAT_STRING;"]},{"entry":[{},"rgData[0].psz = \u201cXMC.PARSER.GCODE.RS274\u201d;"]},{"entry":[{},"rgData[1].adt = LNG_ADT_STAT_STRING;"]},{"entry":[{},"rgData[1].psz = \u201cXMC.EMITTER.GCODE.OKUMA\u201d;"]},{"entry":[{},"hr = pProgEng\u2212>InvokeMethod( IDX_XMC_PROGENG"]},{"entry":[{},"\u2003\u2003\u2003\u2003SetComponents, rgData, 1 );"]},{"entry":[{},"rgData[0].adt = LNG_ADT_STAT_STRING;"]},{"entry":[{},"rgData[0].psz = \u201cc:\\temp\u201d;"]},{"entry":[{},"hr = pProgEng\u2212>InvokeMethod( IDX_XMC_PROGENG"]},{"entry":[{},"\u2003\u2003\u2003\u2003SetInputPath, rgData, 1 );"]},{"entry":[{},"hr = pProgEng\u2212>InvokeMethod( IDX_XMC_PROGENG"]},{"entry":[{},"\u2003\u2003\u2003\u2003SetOutputPath, rgData, 1 );"]},{"entry":[{},"rgData[0].psz = \u201ctest.cnc\u201d;"]},{"entry":[{},"hr = pProgEng\u2212>InvokeMethod( IDX_XMC_PROGENG"]},{"entry":[{},"\u2003\u2003\u2003\u2003SetInputProgram, rgData, 1 );"]},{"entry":[{},"\u2003rgData[0].psz = \u201cnewtest.min\u201d;"]},{"entry":[{},"\u2003hr = pProgEng\u2212>InvokeMethod( IDX_XMC_PROGENG"]},{"entry":[{},"\u2003\u2003\u2003\u2003SetOutputProgram, rgData, 1 );"]},{"entry":[{},"\u2003rgData[0].adt = LNG_ADT_NUMBER;"]},{"entry":[{},"\u2003rgData[0].df = 0.0;"]},{"entry":[{},"\u2003hr = pProgEng\u2212>InvokeMethod( IDX_XMC_PROGENG_Run,"]},{"entry":[{},"\u2003rgData, 1 );"]},{"entry":[{},"\u2003\u2003Internally, when directed to run the program via the"]},{"entry":[{},"IDX_XMC_PROGENG_Run method, the following pseudo code"]},{"entry":[{},"follows."]},{"entry":[{},"\u2003IXMCDirect* m_pParser;"]},{"entry":[{},"\u2003IXMCDirect* m_pEmitter;"]},{"entry":[{},"\u2003XMC_PARAM_DATA m_rgData[128];"]},{"entry":[{},"\u2003:"]},{"entry":[{},"\u2003\/\/ note, the parser component 40 and emitter are created when the"]},{"entry":[{},"\u2003program engine"]},{"entry":[{},"\u2003\/\/ received the_SetComponents call."]},{"entry":[{},"\u2003\/\/"]},{"entry":[{},"\u2003\/\/ In addition, the input root and input program name should have"]},{"entry":[{},"\u2003\/\/ already been set during the previous calls to_SetInputPath,"]},{"entry":[{},"\u2003\/\/ _SetOutputPath,_SetInputProgram and_SetOutputProgram."]},{"entry":[{},"\u2003IDX_XMC_PROGENG_Run \u2212 method start"]},{"entry":[{},"\u2003hr = m_pParser\u2212>InvokeMethod( IDX_XMC_PARSEENG"]},{"entry":[{},"\u2003Reset, NULL, 0 );"]},{"entry":[{},"\u2003hr = S_OK"]},{"entry":[{},"\u2003while (hr == S_OK)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003hr = m_pParser\u2212>InvokeMethod( IDX_XMC_PARSEENG"]},{"entry":[{},"\u2003\u2003\u2003\u2003ParseLine, m_rgData, 128 );"]},{"entry":[{},"\u2003\/\/ m_rgData now contains the tokenized data for the current"]},{"entry":[{},"\u2003\/\/ line of data."]},{"entry":[{},"\u2003hr = m_pEmitter\u2212>InvokeMethod( IDX_XMC_EMITENG"]},{"entry":[{},"\u2003\u2003\u2003\u2003EmitLine, M_rgData, 128 );"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Using the universal tokens, the emitter converts the tokens into the appropriate output corresponding to the format supported by the emitter. For example, in the example above, the Okuma emitter would output a MIN file in the Okuma variant of the G-Code language.","The translator system  described above is designed to translate one type of program format to another type of program format where a program format can be either an off-line program format or an online format where a driver is called immediately as the program is translated. In another example a one-program format may be translated into a universal \u2018meta\u2019 format that is hardware independent yet supported by the motion services module . In particular, when the meta format is run the format is interpreted into direct calls into the motion services module which are then run on the current driver.","Referring now to , depicted therein is example of a CNC proxy system  constructed in accordance with, and embodying, the principles of the present invention. As shown, the CNC proxy system  is preferably used in conjunction with the motion services module  as described above. In addition, the motion services module  is preferably used in conjunction with the translator system  as described above. The CNC proxy system  may, however, be used without either the motion services module  or the translator system . As shown, the CNC proxy system  may be arranged between the motion services module  and the target device .","The CNC proxy system  is used to map CNC functionality onto a general motion control driver . When used with the translator system  and the motion services module , the CNC proxy system  supports translated programs that use CNC functionality. For example, feedrate override, spindlerate, etc are functions that are not normally supported by general motion controllers. To allow the translator system  to run on a motion services module  connected to a general motion system, the CNC proxy system  handles the required mapping between CNC functionality and the general motion functionality provided by a general motion controller functioning as the target device .","As shown in , the CNC proxy system  comprises a CNC proxy driver component . The CNC proxy system further optionally comprises one or more of a bridge driver component , an emulation component , a driver extension component , and a stream component .","The CNC proxy driver component  is the main module used to make the link between a CNC system and a general motion controller. CNC functions are very specific to the types of operations that occur on a CNC machine, and a General Motion Controller applies to a very broad set of applications. The CNC proxy driver component  comprises a set of special algorithms and mapping to allow the use of a general motion controller to implement a CNC based solution.","The emulation driver component  is an optional component used to emulate driver operations and defines a broader set of motion functionality that, when combined with the native motion driver, provides the client application  with access to a richer set of motion functionality.","The bridge driver component  is an optional component used to handle all common driver functionality. The bridge driver component  thus makes each target driver  very simple and focused primarily on performing the motion operations implemented by the target device  or general motion controller (including software, hardware and even remote or network based motion controllers).","The driver component  is the native motion control driver that embodies the native motion controller language (or API calls) needed to control the target motion control system.","The exemplary CNC proxy driver component  is a module that implements the XMCCNC API function calls and uses internal algorithms to map those CNC operations to the functionality provided by the target driver  and\/or the emulation driver . For example, the feedrate of a tool-head may be calculated using the actual velocities along three axes in three space. When queried, the XMC CNC Proxy Driver would first query the target driver for the actual velocity along the three axes, then calculate the feedrate and return the calculated value.","The driver extension component  is an optional component that allows third parties to expand the functionality of the CNC proxy driver component  with custom algorithms.","The stream component  is an optional component that encapsulates how a driver  communicates with the target motion hardware. Optionally, the driver component  may handle all communication with the target motion system, therefore eliminating the need for the stream component .","The CNC proxy system  is used in several common scenarios. When the proxy system  is first used, it must be initialized. Once initialized, CNC operations (functions or properties) are performed on the overall motion system. The following sections describe these scenarios in detail.","Referring now to , when initializing the system, the link between the CNC functionality provided by the CNC proxy system  and the target general motion controller is made. The following steps occur when initializing the CNC proxy system .","First, the motion services module  queries the target driver  for information describing the Service Provider Interface (SPI) support that the driver  implements. When queried, the driver  returns a table of information describing whether each function in the SPI is implemented, should be emulated, or is not supported.","Next, the motion services module  builds an internal Service Provider Interface table that contains pointers to all functions making up the SPI. Depending on how the target driver implements each SPI, a pointer in the table either points to the SPI function implemented by the Driver (when the driver implements the function) or the Emulation component (when the driver does not implement or requests emulation of the function).","Next, the motion services module  passes the SPI function table to the CNC proxy driver component ; the CNC proxy driver component  later uses the SPI function table when mapping the CNC functions and properties to the general motion functionality.","Next the motion services module  initializes the bridge driver  and passes a pointer to the CNC proxy driver component  a general proxy. And finally, any existing driver extension modules  are created and registered with the CNC proxy driver component .","Once initialized, the entire system is ready to perform CNC operations as shown in . When performing each operation, all requests are first routed to the CNC proxy driver component . The CNC proxy driver component  then uses internal algorithms to map each requested operation to the specific general motion control functionality provided by the target driver  and by the functionality provided by the emulation component .","The following steps occur when performing a CNC operation on the XMC system. When the client application  requests any CNC type operations from the motion services module , the motion services module  in-turn directs the calls to the CNC proxy driver component . Upon receiving the request, the CNC proxy driver component  uses the SPI function table, which points to either emulation component  or the SPI functions implemented by the driver component , to perform general motion operations needed to carry out the requested CNC operation.","If the SPI function called is implemented by the emulation component , the emulation component  in-turn uses the target driver  to carry out the general motion operation or operations that emulate the CNC operation.","When requested to perform general motion operations, the driver component  performs any language translations (or direct memory access operations, or API calls) necessary to perform the general motion operation. If used, the stream component  allows communication with the target motion system. If the stream component  is not used, the driver component  may optionally directly communicate with the target motion system .","In the event that the CNC proxy driver component  does not implement the CNC operation requested, the request is routed to any registered driver extension modules  to give them a chance to perform the requested operation. The driver extension modules  are normally used when a third party implements additional CNC functionality not supported by the current CNC operations. Upon receiving the request, the driver extension component  can optionally use the stream component  to communicate with the target motion control system. As another alternative, the driver extension  may also talk directly to the target motion system .","All driver level modules other than the General Driver Proxy, are required to implement the IXMC_DrvCore_Direct interface. Most communications between drivers occur through this interface.","The IXMC_DrvCore_Direct interface is used for most communications between all driver level components. The following methods make up this interface (as specified in the standard OLE\/COM IDL format):","Method Summary","The IXMC_DrvCore_Direct interface is made up of the following functions.\n\n","A more detailed description of each method implemented by the object is described below.","IXMC_DrvCore_Direct::SetTargetStream",{"@attributes":{"id":"p-0174","num":"0000"},"ul":{"@attributes":{"id":"ul0057","list-style":"none"},"li":["Syntax HRESULT SetTargetStream(IXMC_Stream* pStrm);","Parameters IXMC_Stream* pStrm\u2014pointer to the target stream used by all drivers.","Return Value HRESULT\u2014NOERROR on success, or error code on failure.\n\nThe IXMC_DrvCore_Direct::SetTargetStream method is used to set the target stream on the component implementing this method.\n\nIXMC_DrvCore_Driver::InvokeMethod\n","Syntax HRESULT InvokeMethod(DWORD dwSPIIdx, LPXMC_PARMA_DATA rgData, DWORD dwCount);","Parameters DWORD dwSPIIdx\u2014index of the function to run on the driver.\n    \n    ","Return Value HRESULT\u2014NOERROR on success, or error code on failure."]}},"The IXMC_DrvCore_Driver::InvokeMethod method is used to run a method on the component implementing the method.","The following discussion describes special algorithms used when mapping the CNC functionality to the general motion driver used to eventually implement portions of the CNC functionality.","Function mapping is an important concept used to make the link between the CNC proxy driver component  and the target motion control driver and emulation modules. When making this link, the motion services component  passes to the CNC proxy driver component  a function table with entries that correspond to each of the functions in the general motion SPI. This table is used to access each general motion function, which are then used by the implementation of the CNC operations.","Referring now to , the function table containing entries that correspond to each of the functions in the general motion SPI will now be described in further detail. The table passed to the CNC Proxy is made up of entries that contain, as shown in , both the SPI function index and a pointer to the IXMC_DrvCore_Direct interface on the module that actually implements the function.",{"@attributes":{"id":"p-0179","num":"0415"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"XMC_SPI_FNTABLE_ENTRY Structure"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Syntax","typedef struct_XMC_SPI_FNTABLE_ENTRY"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"DWORD","dwFnldx;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IXMC_DrvCore_Direct* pDirect;"]},{"entry":[{},"} XMC_SPI_FNTABLE_ENTRY;"]},{"entry":["Field","DWORD dwFnldx - index of the function to run on the"]},{"entry":[{},"module pointed to by the pDirect interface pointer."]},{"entry":[{},"IXMC_DrvCore_Direct* pDirect - pointer to the module"]},{"entry":[{},"implementing the IXMC_DrvCore_Direct interface."]},{"entry":[{},"Depending on whether or not the native driver supports the"]},{"entry":[{},"function specified by the dwFnldx field, this pointer will"]},{"entry":[{},"either point to the Emulation module or the native driver."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The XMC_SPI_FNTABLE_ENTRY structure defines each entry in the SPI table passed to the CNC proxy driver component .","When first initialized, the CNC proxy driver component  is sent the SPI table so that this table can be used later when running CNC type operations. To initialize the CNC proxy driver component , the table is passed to the CNC Proxy by the Motion component through an array of XMC_PARAM_DATA elements. The following source code sample demonstrates pseudo code of the initialization process.",{"@attributes":{"id":"p-0182","num":"0418"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class CNCProxyImpl"},{"entry":"{"},{"entry":"public:"},{"entry":"CNCProxylmpl(void);"},{"entry":"HRESULT InvokeMethod( . . . );"},{"entry":"private:"},{"entry":"LPXMC_SPI_FNTABLE_ENTRY m_rgSPITable;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["DWORD","m_dwSPITableCount;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":"."},{"entry":"."},{"entry":"."},{"entry":"HRESULT CNCProxyImpl::InvokeMethod(DWORD dwSPIIdx,"},{"entry":"LPXMC_PARAM_DATA rgData,"},{"entry":"DWORD dwCount,"},{"entry":"DWORD dwFlags)"},{"entry":"{"},{"entry":"if (dwSPIIdx == IDX_XMC_CNCPROXY_INITIALIZE)"},{"entry":"{"},{"entry":"LPXMC_SPI_FNTABLE_ENTRY rgSPITable;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["DWORD","dwSPITableCount;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"if (rgData[0].adt != LNG_ADT_STAT_STRING \u2225"},{"entry":"rgData[1].adt != LNG_ADT_NUMBER)"},{"entry":"return(E_INVALIDARG);"},{"entry":"rgSPITable\u2003= (LPXMC_SPI_FNTABLE_ENTRY)rgSPITable.psz;"},{"entry":"dwSPITableCount = (DWORD)rgSPITableCount.df;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["m_rgSPITable","=","new"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"XMC_SPI_FNTABLE_ENTRY[dwSPITableCount];"},{"entry":"m_dwSPITableCount = dwSPITableCount;"},{"entry":"for (DWORD dwldx=0; dwldx<dwSPITableCount; dwldx++)"},{"entry":"{"},{"entry":"m_rgSPITable[dwldx].dwSPIIdx = rgSPITable[dwldx].dwSPIIdx;"},{"entry":"m_rgSPITable[dwldx].pDirect = rgSPITable[dwldx].pDirect;"},{"entry":"if (m_rgSPITable[dwldx].pDirect != NULL)"},{"entry":"m_rgSPITable[dwldx].pDirect\u2212>Add Ref( );"},{"entry":"}"},{"entry":"}"},{"entry":"return(NOERROR);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Once the CNC proxy driver component  is initialized, it will hold a copy of the full SPI Table containing all SPI functions implemented by either the target Driver or Emulation component.","Once the CNC proxy driver component  is initialized it is ready to perform CNC operations. When performing CNC operations, the CNC proxy driver component  uses the functions pointed to by the entries of the SPI Table to complete the CNC operations requested. The following example, demonstrates how to call methods contained within the XMC SPI function table.",{"@attributes":{"id":"p-0185","num":"0421"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/NOTE: m_rgSPITable is defined by the class, see above source."},{"entry":"."},{"entry":"."},{"entry":"."},{"entry":"HRESULT CNCProxyImpl::InvokeMethod(DWORD dwSPIIdx,"},{"entry":"LPXMC_PARAM_DATA rgData,"},{"entry":"DWORD dwCount,"},{"entry":"DWORD dwFlags)"},{"entry":"{"},{"entry":"if(dwSPIIdx == IDX_XMC_CNCPROXY_FEEDRATE)"},{"entry":"{"},{"entry":"XMC_PARAM_DATA rgSpiData[3];"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["HRESULT","hr;"]},{"entry":["DWORD","dwFnldx ="]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"IDX_XMC_GENERALMOTION_GET_VELOCITY;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["double","dfFeed = 0;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"hr = m_rgSPITable[dwFnldx]\u2212>InvokeMethod(dwFnldx,"},{"entry":"rgSpiData,"},{"entry":"3,"},{"entry":"0);"},{"entry":"if (FAILED(hr))"},{"entry":"return(hr);"},{"entry":"dfFeed = rgData[0].df * rgData[0].df +"},{"entry":"rgData[1].df * rgData[1].df +"},{"entry":"rgData[2].df * rgData[2].df;"},{"entry":"dfFeed = _sqrt(dfFeed);"},{"entry":"rgData[0].adt = LNG_ADT_NUMBER;"},{"entry":"rgData[0].df = dfFeed;"},{"entry":"}"},{"entry":"return(NOERROR);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The following discussion contains the definitions of all special types used by the methods and properties of each component making up the program engine  system.","All methods exposed by each component in the system  use the standard XMC parameters set to describe data used to set and query properties as well as invoke methods. The standard parameters are in the following format: pObj->InvokeMethod (LPXMC_PARAM_DATA rg Data, DWORD dwCount);","Each element in the rgData array corresponds to a parameter, with the first element in the array corresponding to the first parameter.","The XMC_PARAM_DATA structure can contain either a numerical or a string value and is defined as follows:",{"@attributes":{"id":"p-0190","num":"0426"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct tagXMC_PARAM_DATA"]},{"entry":[{},"{"]},{"entry":[{},"LNG_PARAM_DATATYPE adt;"]},{"entry":[{},"union"]},{"entry":[{},"{"]},{"entry":[{},"double df;"]},{"entry":[{},"LPTSTR psz;"]},{"entry":[{},"}XMC_PARAM_DATA;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The \u2018adt\u2019 member of the XMC_PARAM_DATA structure describes the data contained within the XMC_PARAM_DATA structure. The values are described below:",{"@attributes":{"id":"p-0192","num":"0428"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["LNG_PARAM_DATATYPE","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["LNG_ADT_NUMBER","Use this value when passing a"]},{"entry":[{},"numerical value via the \u2018adt\u2019 member of"]},{"entry":[{},"the XMC_PARAM_DATA structure."]},{"entry":["LNG_ADT_STAT_STRING","Use this value when passing a static"]},{"entry":[{},"string value via the \u2018psz\u2019 member of the"]},{"entry":[{},"XMC_PARAM_DATA structure."]},{"entry":[{},"Static strings do not need to be"]},{"entry":[{},"freed from memory."]},{"entry":["LNG_ADT_MEM_STRING","Use this value when passing a string"]},{"entry":[{},"value via the \u2018psz\u2019 member of the"]},{"entry":[{},"XMC_PARAM_DATA structure."]},{"entry":[{},"LNG_ADT_MEM_STRING denotes"]},{"entry":[{},"that the string must be freed from"]},{"entry":[{},"memory during cleanup."]},{"entry":["LNG_ADT_NOP","This value is used to ignore items"]},{"entry":[{},"within the XMC_PARAM_DATA"]},{"entry":[{},"array. When specifies, this parameter"]},{"entry":[{},"is not used."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"When querying and setting boolean TRUE\/FALSE values, any non-zero value is considered TRUE, whereas a zero value is considered FALSE."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIGS. 2\u20134","FIG. 1"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 5","FIG. 1"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIGS. 7\u20138","FIG. 6"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
