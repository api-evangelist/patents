---
title: Convergence analysis in multithreaded programs
abstract: A basic block within a thread program is characterized for convergence based on mapping the basic block to an indicator subnet within a corresponding Petri net generated to model the thread program. Each block within the thread program may be similarly characterized. Each corresponding Petri net is enumerated to generate a corresponding state space graph. If the state space graph includes an exit node with an odd execution count attribute, such as by Petri net coloring, then the corresponding basic block is divergent. The corresponding basic block is convergent otherwise. Using this characterization technique, a thread program compiler may advantageously identify all convergent blocks within a thread program and apply appropriate optimizations to the convergent blocks.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09134979&OS=09134979&RS=09134979
owner: NVIDIA Corporation
number: 09134979
owner_city: Santa Clara
owner_country: US
publication_date: 20130206
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","The invention relates generally to compiler systems and, more specifically, to convergence analysis in multithreaded programs.","2. Description of the Related Art","Certain computer systems include a parallel processing subsystem that may be configured to concurrently execute plural program threads that are instantiated from a common program. Such systems are referred to in the art as having single instruction multiple thread (SIMT) parallelism. An application program written for execution in an SIMT model may include sequential C language programming statements and calls to a specialized application programming interface (API) used for configuring and managing parallel execution of program threads. A function within an SIMT application that is destined for concurrent execution on a parallel processing subsystem is referred to as a \u201cthread program\u201d or \u201ckernel.\u201d An instance of a thread program is referred to as a thread, and a set of concurrently executing threads may be organized as a thread group. Each thread may follow a different execution path based on certain identifying index variables or computational results.","During the course of following different execution paths, one set of threads may execute one branch of a conditional statement, while another set of threads may execute a different branch of the same conditional statement. In such a scenario, the two different sets of threads execute divergent paths that need to converge at some point later during execution. A synchronization barrier may be used as an explicit convergence point and may implicate a certain portion of a thread program as convergent. Other techniques are known in the art for detecting convergence based on certain ad-hoc rules, but a general technique for identifying all convergent basic blocks is not presently known in the art. Each basic block includes one entry point and one exit point in execution flow. A given basic block may be represented as a corresponding node in a control flow graph (CFG).","Certain beneficial optimizations may be applied to convergent basic blocks. In one exemplary optimization, a convergent basic block may have related data allocated to common storage for greater access efficiency. In another exemplary optimization, a convergent basic block may be scheduled to run on a specific thread processor for greater execution efficiency. Identifying each convergent basic block generally represents an opportunity to better optimize a thread program. However, as alluded to above, thread program compilers are conventionally unable to fully detect all convergent basic blocks in a general thread program and are therefore unable to fully optimize certain thread programs undergoing compilation.","As the foregoing illustrates, what is needed in the art is a technique for identifying convergent basic blocks in a thread program.","One embodiment of the present invention sets forth a computer-implemented method for characterizing a thread program, the method comprising selecting a basic block within a control flow graph corresponding to the thread program, wherein the control flow graph includes one or more block nodes corresponding to basic blocks within the thread program, generating a Petri net representation of the control flow graph that includes an indicator subnet corresponding to the selected basic block, enumerating a state space graph from the Petri net representation, wherein the state space graph includes a plurality of state nodes corresponding to a state enumeration of the Petri net representation; and determining whether the basic block is convergent based on the state space graph.","Other embodiments of the present invention include, without limitation, a computer-readable storage medium including instructions that, when executed by a processing unit, cause the processing unit to perform the techniques described herein as well as a computing device that includes a processing unit configured to perform the techniques described herein.","One advantage of the disclosed technique is that a thread program compiler is able to advantageously detect all convergent basic blocks within a thread program. This is in contrast to prior art solutions that are only able to detect certain subsets of convergent blocks. Thus, by implementing the disclosed technique, the execution of a thread program can be more fully optimized relative to prior art approaches.","In the following description, numerous specific details are set forth to provide a more thorough understanding of the invention. However, it will be apparent to one of skill in the art that the invention may be practiced without one or more of these specific details. In other instances, well-known features have not been described in order to avoid obscuring the invention.","System Overview",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","102","104","105","105","106","107","107","108","102","106","105","112","105","113","112","110","103","113","112","110","114","107","116","107","118","120","121","107"]},"In one embodiment, the parallel processing subsystem  incorporates circuitry optimized for graphics and video processing, including, for example, video output circuitry, and constitutes a graphics processing unit (GPU). In another embodiment, the parallel processing subsystem  may be integrated with one or more other system elements, such as the memory bridge , CPU , and I\/O bridge  to form a system on chip (SoC).","It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology, including the number and arrangement of bridges, the number of CPUs , and the number of parallel processing subsystems , may be modified as desired. For instance, in some embodiments, system memory  is connected to CPU  directly rather than through a bridge, and other devices communicate with system memory  via memory bridge  and CPU . In other alternative topologies, parallel processing subsystem  is connected to I\/O bridge  or directly to CPU , rather than to memory bridge . In still other embodiments, I\/O bridge  and memory bridge  might be integrated into a single chip. Certain embodiments may include two or more CPUs  and two or more parallel processing systems . The particular components shown herein are optional; for instance, any number of add-in cards or peripheral devices might be supported. In some embodiments, switch  is eliminated, and network adapter  and add-in cards ,  connect directly to I\/O bridge .","In one embodiment, a thread program is compiled for execution by parallel processing subsystem  by a thread program compiler . The thread program compiler translates a source representation of the thread program into a compiled representation of the thread program. For example, the source representation may comprise original source code, such as source code written by a developer, and the compiled representation may comprise an intermediate code easily translated for execution by parallel processing subsystem . The compiled representation may also comprise an executable thread program suitable for direct execution by parallel processing subsystem . Thread program compiler  may be implemented within a driver module for the parallel processing subsystem that compiles the executable thread program, or as an application level module that generates either the intermediate code or executable thread program.","In addition to generating the compiled representation of the thread program, thread program compiler  also performs convergence analysis, described below in greater detail. In one embodiment, a convergence analysis function  performs convergence analysis, which allows the thread program compiler to statically determine when threads within a basic block are known to be convergent or divergent. Such analysis is significant for both program correctness and performance. In particular, thread program compiler  may use uniform (or \u201cscalar\u201d) operations for thread-invariant values when threads are known to be convergent. Uniform operations may include uniform loads, scalar register accesses, and scalar instructions. Convergence analysis may enable scalarization to factor out uniform work from single instruction multiple thread (SIMT) threads. The uniform work may then be advantageously assigned to shared scalar resources to improve utilization efficiency of resources within parallel processing subsystem . Persons skilled in the art will recognize that convergence analysis techniques described herein are broadly applicable to many different multi-threaded system architectures, including any processor system that provides or models multi-threaded execution in combination with scalar resources.","One way of interpreting thread convergence in a basic block is that all or none of the threads within a given basic block will be collected at the barrier, which represents a convergence point. On exemplary type of barrier implemented in the CUDA\u2122 runtime from NVIDIA\u2122 is a _syncthreads( ) call, which blocks all associated threads until all the threads execute the same _syncthreads( ) call.","Basic block convergence analysis begins with thread program compiler  identifying basic block boundaries within a thread program. Each basic block is then represented as a node within a control flow graph (CFG). Each CFG node is annotated to reflect whether the corresponding basic block includes a synchronization barrier, such as the _syncthreads( ) call.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2A","b":["210","212","210","1","220","2","222","212","1","230","1","232","2","234","1","230","1","220","2","234","2","222","1","232","212","1","220","1","230"]},"Persons skilled in the art will recognize that a PN constructed with two tokens in an entry basic block faithfully captures the complete dynamic behavior of a corresponding thread program executed by two threads. An initial marking of the entry basic block may include two tokens.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2B","b":["240","242","240","1","250","242","1","250","1","262","1","242","1","260","262","1","260","1","262","1","264","242"],"sub":["\u2014","\u2014","\u2014","\u2014","\u2014"],"i":["i","o","i ","i ","o "]},"In general, a CFG may be modeled as a corresponding PN. For CFG nodes having a synchronization barrier, the mapping illustrated in  may be applied in generating portions of the corresponding PN. For CFG nodes without a synchronization barrier, the mapping illustrated in  may be applied in generating remaining portions of the corresponding PN.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 3A","b":["300","300","1","310","314","312","300"]},"A state space graph of a PN, such as the corresponding PN, represents instantaneous state of the PN. A marking is associated with each node of the state space graph. The marking is a list of places and a token count for each place. In general, a place may have an arbitrary number of tokens, however embodiments of the present invention limit each place in the corresponding PN to two tokens. Each one of the two tokens is associated with one of two different threads. A state space graph marking of the form \u201cpi pk\u201d is used herein, where pi and pk each indicate the presence of one token in the indicated place within the corresponding PN. For example, a state space graph marking of \u201cp p\u201d on a particular node indicates place p and place p within the corresponding PN each have one token. The state space graph is therefore a state graph with nodes comprising all possible states of the PN and edges comprising all possible state transitions within the PN.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 3B","FIG. 3A","FIGS. 2A and 2B"],"b":["302","300","302","302"]},"As shown, state space graph  includes an entry node  and an exit node . Exit node  is marked \u201cp p\u201d representing an instance in time when both of two executing threads have arrived at node p within CFG . Equivalently, marking \u201cp p\u201d indicates that both of two possible tokens are in place p within the corresponding PN.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 4","FIG. 3A","FIG. 3B"],"b":["400","3","300","3","4","5","4","5","4","5","302","4","5","302","3","4","5","3"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 5","FIGS. 2A and 2B","FIGS. 6 and 7"],"b":["500","500","500"]},"Indicator subnet  introduces an input place p_i , an output place p_o , two indicator places q  and q , and two transitions t , t . Input place p_i  and output place p_o  respectively indicate arrival at and departure from the basic block as executed by a thread. Indicator place q  and indicator place q  together track how many times (modulo ) the basic block was traversed by two different threads during execution. Indicator place q  indicates an odd number of traversals, while indicator place q  indicates an even number of traversals. At some instant in time, if indicator place q  has a marking of 1, then the basic block was traversed an odd number of times by the two different threads. In one embodiment, indicator place q  starts with an initial marking of [1], indicating the basic block was traversed zero times or an even number of times.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 6","FIG. 3A","FIG. 5","FIG. 2A","FIG. 2B","FIG. 2B"],"b":["600","2","300","2","300","500","300","4","312"]},"Markings that include por parise because node p of CFG  was modified in a corresponding PN (not shown) to an include input (\u201c_i\u201d) place and output (\u201c_o\u201d) place, as illustrated in . Markings that include por parise because node p of CFG  includes a synchronization barrier and is mapped to include an input place and an output place, as illustrated in . Entry node  is marked \u201cp p\u201d to indicate both threads start in p  of CFG .","Each node of state space graph  is designated as being either a \u201cred\u201d node or \u201cgreen\u201d node. A \u201cred\u201d node is depicted herein using a hash fill, while a \u201cgreen\u201d node does not include a hash fill. A green node indicates that indicator place q  of the modified node p in the corresponding PN had a [1] marking just before the thread program reached a state for the green node. That is, just before the thread program reached a state associated with the node, the basic block associated with p had been executed an even number of times by both threads. Similarly, a red node indicates that just before the thread program reached a state associated with the red node, the basic block associated with p had been executed an odd number of times by both threads.","Exit node p  has two different corresponding exit nodes in state space graph . Node  is a red node while node  is a green node. Both nodes  and  have marking \u201cp p,\u201d indicating both of two different threads arrived at node p. However, in the process, node p was executed an odd number of times by one of the two different threads, while node p was executed an even number of times by the other of two different threads. In other words, the execution count of the basic block associated with node p is different for each of the two different threads, indicating the basic block is not convergent.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 7","FIG. 3A","FIG. 5","FIG. 2B"],"b":["700","5","300","5","300","2","500","4","312","700","710","720","6","6","700","300","5","5"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 8","FIG. 1","FIG. 1"],"b":"102"},"As shown, method  begins in step , where a convergence analysis function, such as convergence analysis function  within thread program compiler , generates a control flow graph (CFG) from a thread program. The CFG may be generated for a thread program using any technically feasible technique. In alternative embodiments, a function other than the convergence analysis function generates the CFG. The thread program may be specified as source code, tokenized code, an intermediate code, or any other technically feasible representation. In step , the convergence analysis function selects a basic block from the CFG. In step , the convergence analysis function generates a modified Petri net (PN) for the CFG based on the selected basic block. The modified PN represents the selected basic block as an indicator subnet, such as indicator net  of . In one embodiment, the modified PN represents basic blocks within the CFG other than the selected basic block according to mappings illustrated in  or . In step , the convergence analysis function generates a state space graph based on the modified PN.","If, in step , the state space graph includes a red exit node, then the method proceeds to step , where the convergence analysis function marks the selected basic block as divergent. Otherwise, if the state space graph does not include a red exit node, then the method proceeds to step , where the convergence analysis function marks the selected basic block as convergent. Assessing whether the state space graph includes a red exit node may be implemented using any technically feasible technique, such as performing a graph search or identifying the red exit node upon generating the state space graph.","If, in step , the convergence analysis function is done, then the method terminates in step . Otherwise, the method proceeds back to step , previously described herein. In one embodiment, the convergence analysis function is done after all basic blocks within the CFG have been selected and marked as either divergent or convergent.","In sum, a technique for characterizing each basic block within a thread program as being either convergent or divergent is disclosed. The technique involves representing the thread program as a control flow graph having one or more basic blocks, which are then individually analyzed for convergence. Analysis involves representing a selected basic block as an indicator subnet within a Petri net mapping of the control flow graph. State information for the Petri net is then enumerated to generate a state space graph corresponding to the selected basic block. If the state space graph includes a red exit node, then the selected basic block is identified as divergent, otherwise the selected basic block is identified a convergent.","One advantage of the disclosed technique is that a thread program compiler is able to advantageously detect all convergent basic blocks within a thread program. This is in contrast to prior art solutions that are only able to detect certain subsets of convergent blocks. Thus, by implementing the disclosed technique, the execution of a thread program can be more fully optimized relative to prior art approaches.","While the foregoing is directed to embodiments of the invention, other and further embodiments of the invention may be devised without departing from the basic scope thereof. For example, aspects of the present invention may be implemented in hardware or software or in a combination of hardware and software. One embodiment of the invention may be implemented as a program product for use with a computer system. The program(s) of the program product define functions of the embodiments (including the methods described herein) and can be contained on a variety of computer-readable storage media. Illustrative computer-readable storage media include, but are not limited to: (i) non-writable storage media (e.g., read-only memory devices within a computer such as CD-ROM disks readable by a CD-ROM drive, flash memory, ROM chips or any type of solid-state non-volatile semiconductor memory) on which information is permanently stored; and (ii) writable storage media (e.g., floppy disks within a diskette drive or hard-disk drive or any type of solid-state random-access semiconductor memory) on which alterable information is stored. Such computer-readable storage media, when carrying computer-readable instructions that direct the functions of the present invention, are embodiments of the invention.","In view of the foregoing, the scope of the invention is determined by the claims that follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features of the invention can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to embodiments, some of which are illustrated in the appended drawings. It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 3B","FIG. 3A"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
