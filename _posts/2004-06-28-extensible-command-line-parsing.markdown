---
title: Extensible command line parsing
abstract: An extensible generic command line parser may receive a list of options associated with an application and a command line to parse. A new command line option may be added to the options that can be parsed by adding the new command line option to the list of options. By receiving a modifiable list of valid options from an application, the parser is extensible, that is, instead of having to modify or recode the parser when a new option is added to the application, the new option may be added to the option file. When the parser receives the option list with the new option or options, any option in the file (including any new ones) may be automatically parsable by the parser.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07617492&OS=07617492&RS=07617492
owner: Microsoft Corporation
number: 07617492
owner_city: Redmond
owner_country: US
publication_date: 20040628
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS","Overview"],"p":["The invention relates to command line parsers and in particular to providing extensibility in command line parsing.","Before the advent of the graphical user interface (GUI), in which a command is typically issued by moving a pointer (e.g., a mouse cursor) and\/or pressing a key (i.e., \u201cclicking\u201d, often on a key mounted on a mouse), the predominant way a user interacted with a computer was by entering a command on a command line. Although seemingly more \u201cprimitive\u201d, this means of communication is more direct, and is often more powerful and more flexible than the directed pathways defined by a GUI. Most new applications that are written are still written to be accessible directly by entering a textual command at a command prompt.","The command line entered at a command line prompt (e.g., \u201cC:\\>\u201d) is frequently complex. Sometimes the command line is of the form:",{"@attributes":{"id":"p-0005","num":"0004"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<DoSomething> <how> <ToASomething>"},{"entry":"or"},{"entry":"<DoSomething> <how> <ToAnInputFile> > <CreatingAnOutputFile>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"where DoSomething corresponds to an action, how describes how the action should be executed, for instance, and ToASomething corresponds to the object acted upon (often one or more files). The fourth \u201c>\u201d in the second example is a redirection character, telling the operating system to send the output of the previous commands (i.e., those to the left of the fourth \u201c>\u201d) to some other place (i.e., that place indicated by the characters to the right of the fourth \u201c>\u201d, in this case, to the OutputFile).","Because of the complexity of command lines, the command line is often validated or parsed by the application to determine if it has been entered correctly before the application attempts to execute the command. Parsing usually is done by breaking down text into recognized strings of characters and analyzing the grammatical structure of the strings, with respect to a given formal grammar.","Frequently, however, applications and therefore the commands that execute the applications change. This usually requires the parsing code to change, a nontrivial programming exercise. It would be helpful if there were a way to make a generic parser that could be used by many different applications over their lifetimes, without requiring recoding of the parser.","An extensible generic command line parser may receive a list of options associated with an application and a command line to parse. A new command line option may be added to the options that can be parsed by adding the new command line option to the list of options. By receiving a modifiable list of valid options associated with an application, the parser is extensible, that is, instead of having to modify or recode the parser when a new option is added to the application, the new option may be added to the option file. When the parser receives the option list with the new option or options, any option in the file (including any new ones) may be automatically parsable by the parser.","The extensible generic parser may read and parse out an option from the command line. The extensible generic command line parser may determine whether the command line includes a valid option by comparing the command line option with the list of options. If a match occurs, the parser may determine that the option is valid.","The parser may receive an option list that includes for each option, a minimum number of characters that uniquely identifies the option. When the parser reads and parses out an option from the command line, it may determine if the number of characters in the input received for the option are enough to uniquely identify the option, and if so, may recognize the option by the minimum number of characters specified for the option. If the minimum number of characters has been received for the option, an exact match may be required for a valid option result to be returned by the parser. If more than the minimum number of characters are received, then all the characters specified may be required to match for a valid option result to be returned by the parser.","The parser may also determine if an argument is required for the option. If the option requires an argument, the parser may determine if the required argument is present or missing. The parser may return a failure or success result and may receive and respond to queries concerning the parsed command line.","The extensible generic parser may be used in almost any application that needs to parse a command line. It may simplify development and reduce development time because the same parser may be used by many different applications merely by sending the parser a different list of options.","A command line application may have a number of different options that modify the behavior of the application when it is executed. Each option may take one or more arguments that provide information that the command line application needs to execute. A command line is often quite long and complex and therefore is often validated or parsed before it is executed. Typically this processing is performed within the application itself. It is the nature of an application to change. Options once used are no longer used, new options are added and so on. Typically whenever an option in an application changes, so too must change the validation and parsing. Unfortunately, coding or modifying a parser is a non-trivial programming exercise.","In accordance with the invention, the parsing function is separate from the processing of the application. Hence the parser can be used by many different applications to parse their command lines. Upon receiving a list of allowable options and a command line, the parser parses the command line and returns a result. The parser may receive and respond to queries concerning the command line.","Exemplary Computing Environment",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1"},"Although not required, the invention can be implemented via an application programming interface (API), for use by a developer, and\/or included within the network browsing software which will be described in the general context of computer-executable instructions, such as program modules, being executed by one or more computers, such as client workstations, servers, or other devices. Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations. Other well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers (PCs), automated teller machines, server computers, hand-held or laptop devices, multi-processor systems, microprocessor-based systems, programmable consumer electronics, network PCs, minicomputers, mainframe computers, and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1","b":["100","100","100","100"]},"With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus).","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CDROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared, and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation, illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only, illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB).","A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . A graphics interface , such as Northbridge, may also be connected to the system bus . Northbridge is a chipset that communicates with the CPU, or host processing unit , and assumes responsibility for accelerated graphics port (AGP) communications. One or more graphics processing units (GPUs)  may communicate with graphics interface . In this regard, GPUs  generally include on-chip memory storage, such as register storage and GPUs  communicate with a video memory . GPUs , however, are but one example of a coprocessor and thus a variety of coprocessing devices may be included in computer . A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface , which may in turn communicate with video memory . In addition to monitor , computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation, illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","One of ordinary skill in the art can appreciate that a computer  or other client device can be deployed as part of a computer network. In this regard, the present invention pertains to any computer system having any number of memory or storage units, and any number of applications and processes occurring across any number of storage units or volumes. The present invention may apply to an environment with server computers and client computers deployed in a network environment, having remote or local storage. The present invention may also apply to a standalone computing device, having programming language functionality, interpretation and execution capabilities.","Extensible Command Line Parsing",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2","b":["200","200","204","200","202","204","206","207","202","202"]},"Extensible parser  may include a streamer  that receives a string of characters and abstracts characteristics of the input (e.g., a command line) received, delivering a single character at a time to the extensible parser . For example, streamer  may handle reading the command line input from a file, understanding the format of the command line and so on.","Application  in some embodiments of the invention, in response to receiving a command line input, instantiates extensible parser  and sends extensible parser  a list of valid options . In some embodiments of the invention, the list of options  includes one or more of the following data elements for each allowable option:","a command line option string","the minimum number of characters that uniquely identifies the command line option","a command line option identifier (a pneumonic or variable name that represents, for example, a unique number that the application understands to refer to the command line option, (e.g., OPTION_ID=1 for command line option \u201cfile\u201d), or global unique identifier (GUID)). Alternatively, the command line option identifier may represent an entire command line option and argument.","a parameter providing additional information about the type of allowable arguments for the option, such as for example, the number of arguments required for the option.","In some embodiments of the invention, a value of \u201c0\u201d for the parameter may indicate that no argument is allowed, a value of \u201c0 or 1\u201d may indicate that an argument is allowed but not required and a value of \u201c1\u201d may indicate that an argument is required. It will be understood, that the invention is not limited to this scheme, any suitable scheme may be devised.","In some embodiments of the invention, option list  may be an external file or other data structure that can be modified by a word processing program or a text editor. Hence option list  may be easily modified without requiring any programming expertise or any change to application  code.","In some embodiments of the invention, application  may send extensible parser  a command line . An exemplary command line may include one or more sets of the following data elements, delimited by a separator such as but not limited to a slash (\/):","an option of the application to execute and\/or","an argument for the option of the application to execute.","An exemplary command line may be:","\/file c:\\temp\\mypkg.dtsx","In the above command line, the \u201c\/\u201d (slash) may indicate that a new option is starting, the option name is \u201cfile\u201d and the argument for option \u201cfile\u201d is \u201cc:\\temp\\mypkg.dtsx\u201d. The appearance of a second slash as in the following command line:","\/file c:\\temp\\mypkg.dtsx\/[option2]","may signal the beginning of a second option, here indicated by \u201c[option2]\u201d.","The extensible parser  may receive the list of allowable options and the command line. In some embodiments of the invention, the extensible parser  may read and parse out an option from the command line. The extensible parser  may then compare the parsed out option with the option list to determine if there is a match. The string specified for the option (\u201cfile\u201d in the above example) may be used to find the matching string in the option list. If there is no match, a failure result may be returned to the application.","In some embodiments of the invention, if the command line or an option on the command line received is a string of blanks, (i.e., the option is blank), an error message is returned. Alternatively, a message indicating that no options have been received may be returned.","In some embodiments of the invention, if the minimum number of characters that uniquely identifies the command line option has not been specified for the option, the entire name of the option is specified on the command line and is matched against the entire name of the option in the option list. If there is no match, a failure result may be returned to the application. If there is a match, processing may continue.","In some embodiments of the invention, if the minimum number of characters that uniquely identifies the command line option has been specified for the option in the option list and the number of characters specified on the command line is less than the minimum for the option, a failure result is returned. If the minimum number of characters that uniquely identifies the command line option has been specified for the option in the option list and the number of characters specified on the command line is at least equal to the minimum for the option, the characters specified may be matched against the option name. If there is no match, a failure result may be returned to the application. If there is a match, processing may continue.","In order for a success result to be returned by the parser, there must be an exact match of at least the minimum number of unique characters. Furthermore, if more than the minimum number of characters is specified then all the characters specified may be required to match exactly. For example, in some embodiments of the invention, given the options: MyFirstOpt, and MySecondOpt, three characters are needed to uniquely identify between the options. Therefore, in this case, the option list provided to the parser may be: MyFirstOpt, 3, MySecondOpt, 3 (option name, number of minimum characters required to disambiguate, option name, number of minimum characters required to disambiguate). This option list input indicates that the parser is able to validate the options with a minimum of three characters, however, more than three characters (up to the number of characters in the option) may optionally be specified.","Suppose the command line specified \u201cMy\u201d. In this case, the parser may return an invalid result (i.e., failure) because not enough characters were specified (2 instead of 3) to disambiguate between MyFirstOpt and MySecondOpt. Suppose the command line specified \u201cMyF\u201d, in this case, the parser may return a valid result (i.e., success) because the minimum number of characters (i.e., three characters) have been received and the three characters received match exactly the first three characters of \u201cMyFirstOpt\u201d. Suppose the command line specified \u201cMySec\u201d. The parser may return a valid result because at least three characters were received and all five characters received match exactly the first five characters of \u201cMySecondOpt\u201d. Suppose the command line specified \u201cMySection\u201d. An invalid result may be returned because the sixth letter (i.e., \u201ct\u201d) does not match the sixth letter of \u201cMySecondOpt\u201d. Suppose the command line specified \u201cMyFirstOpt\u201d, a valid result may be returned because the entire option matches an option in the list. Suppose \u201cMyFirstOption\u201d were received. An invalid result may be returned because too many characters were received to match the entire \u201cMyFirstOpt\u201d option name, and so on. In some embodiments of the invention, the matching logic is case sensitive. In some embodiments, the matching logic is case insensitive.","If an argument for the option number is received, the argument may be compared with the parameter providing additional information about the type of allowable arguments for the option.","If the argument is not allowable, a failure result may be returned. If the argument is allowable, this set of command line input data elements is correct and the next set of command line input data elements may be parsed. This processing continues until an error is detected or until the entire command line is parsed. If the entire command line is parsed and no errors are found, the extensible parser  may return a success result. Alternatively, the extensible parser  may return a list of valid options and the arguments for the options, a list of errors, or any other suitable information.","Application , upon receiving the success result from the extensible parser , may request the parser  to send the application  all the options entered on the command line. Alternatively, the application  may request the parser  for a specific command line option and its arguments or for particular information concerning one of the options and\/or its argument(s). Application  may request information about a specific command line option by specifying the string (e.g., \u201cfile\u201d) or by specifying the command line identifier (e.g., \u201c1\u201d). Similarly parser  may return requested information about a specific command line option by specifying the string (e.g., \u201cfile\u201d) or the command line identifier (e.g., \u201c1\u201d).","In some embodiments of the invention, intelligence concerning dependencies between options may be included within the parser. For example, suppose three options for a command line are \u201cfile\u201d, \u201cdts\u201d and \u201cSQL\u201d. Suppose any one of the three does not necessarily have to be specified but one and only one of the three must be specified. Parser  may include the logic required to determine whether the above conditions were met in a command line.","In some embodiments of the invention, the application is a command line utility that transforms data. A package may be created (e.g., in a designer), specifying the input source, the data transformations to be performed and the output destination. In some embodiments of the invention, the command line data transformation utility may include a number of command line options (e.g., an option to specify the source, the name of the package to execute, and so on).",{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 3","b":"302"},"At step  the parser may receive a list of options. The list of options may be sent to the parser by the application. Alternatively, the parser may access a specified location for the list of options. The list of options may include entries for one or more options. Each option may include one or more of the following data elements:","a command line option","the minimum number of characters that uniquely identifies the command line option","an identifier (a sequence of characters that represents a unique number that the application understands to refer to the command line option)","a parameter providing additional information about the type of allowable arguments for the option.","At step  the parser may receive the command line (e.g., from the application). Alternatively, the list of allowable options and the command line may be received in one step.","At step  the parser may parse the command line received and at step  may return the result (e.g., to the application). In some embodiments of the invention, the result the parser returns may be success or failure. In some embodiments the parser may return the entire command line. In some embodiments the parser may return a single command line option and its arguments one at a time. In some embodiments the parser may return its results in response to a query received (e.g., from the application).",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 4","FIG. 3"],"b":["308","310"]},"In , at step , the extensible parser may determine if an option has been received on the command line. If no option has been received, a failure result may be returned at . In some embodiments of the invention, if the command line or an option on the command line received is a string of blanks, (i.e., the option is blank), an error message is returned. Alternatively, a message indicating that no options have been received may be returned. If an option was received, at , the parser may check to see if a minimum number of characters to uniquely identify the option has been received in the option list for that option. If a minimum number of characters to uniquely identify the option has not been received in the option list for that option, processing continues at step . At step , all the characters received on the command line may be matched against the complete names of the options in the option list. If a match is not found a failure result may be returned at step . If a match is found, processing may continue at step .","If a minimum number of characters to uniquely identify the option has been received in the option list for that option, at step , the parser may determine whether the number of characters received for the option on the command line is equal to or greater than the minimum number of characters required to uniquely identify the option. If the minimum required number of characters has not been received for the option on the command line, the parser may return a failure result at step . If the minimum required number of characters has been received, all the characters specified for the option on the command line may be matched against the same number of characters of the option in the option list at step . If there is a match processing may continue at step . If there is no match, a failure result may be returned at step .","At step , the parser may determine if an argument for the option is required by consulting the parameter data element of the option file record. If an argument is not permitted and none has been received, a success result may be returned at step . If an argument is not permitted but an argument is received, a failure result may be returned at step .","At step , if the parser determines that an argument is required for the option, processing may continue at step . At step , if no argument exists on the command line, a failure result may be returned at step . If an argument is required and an argument is received for that option a success result may be returned at step . If an argument is required or allowed, the argument may be further parsed according to rules associated with that argument. If an error is found, a failure result may be returned to application. If an error is not found, a success result may be returned for this option.","If an argument for the option number is received, in some embodiments, the argument is compared with the parameter providing additional information about the type of allowable arguments for the option.","If the argument is not allowable, a failure result may be returned. If the argument is allowable, this set of command line input data elements is correct and the next set of command line input data elements may be parsed. In some embodiments, this processing continues until an error is detected or until the entire command line is parsed. If the entire command line is parsed and no errors are found, the extensible parser  may return a success result.","The various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the present invention, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers, the computing device will generally include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may utilize the creation and\/or implementation of domain-specific programming models aspects of the present invention, e.g., through the use of a data processing API or the like, are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","While the present invention has been described in connection with the preferred embodiments of the various figures, it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiments for performing the same function of the present invention without deviating therefrom. Therefore, the present invention should not be limited to any single embodiment, but rather should be construed in breadth and scope in accordance with the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of illustrative embodiments, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating the invention, there is shown in the drawings exemplary constructions of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. In the drawings:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 4","FIG. 3"]}]},"DETDESC":[{},{}]}
