---
title: Scalable java servers for network server applications
abstract: A system for providing Java-implemented Application Servers to a plurality of clients. Each of the Java-implemented Application Servers is configured to execute on a processing element of a server which has multiple independent processing elements arranged such that a failure of one processing element does not affect the operability of the other processing elements. A Distributor is provided to enable making connections with the clients and then determine which of the Application Servers actually services the clients requests. The Distributor attempts to choose the Application Server that has the fewest number of clients as the server for a new client request. A monitoring program restarts the Distributor if it fails. The system thus provides a scalable and available set of Java-implemented Application Servers without requiring any change to the Java-implemented application itself.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07139805&OS=07139805&RS=07139805
owner: Hewlett-Packard Development Company, L.P.
number: 07139805
owner_city: Houston
owner_country: US
publication_date: 20010530
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","DESCRIPTION OF THE RELATED ART","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application is related to and claims the benefit of the filing date of a U.S. provisional application entitled \u201cSCALABLE IP FOR NONSTOP SERVER FOR JAVA\u201d, filed on May 30, 2000, and having Ser. No. 60\/208,021, which application is hereby incorporated by reference into the instant application.","The present invention generally relates to providing a reliable operating environment for an application program and more specifically to providing a scalable and available operating environment for network applications written in the Java programming language.","The Java programming environment is an attractive environment for developing and running programs. The environment includes a programming language, a set of application programming interfaces and a virtual machine. The programming language is an object-oriented language that is architecturally neutral and portable and has multi-threaded support. The API provides support for I\/O, networking and graphics. The Java Virtual Machine (JVM) includes a class loader and interpreter or just in time compiler and executes the compiled class files from a user program and the APIs. The JVM is usually implemented on top of a particular operating system and is system specific. Java programs have rapidly become the standard for implementing a wide range of enterprise-level, server-side business applications.","However, despite the favorable features listed above, the Java technology suffers from several disadvantages chief among which are a lack of scalability and availability. Lack of scalability means that the Java environment does not provide a computing solution if there are more client threads than the Java Virtual Machine and the Application program can handle. In this case, the client threads receive poor service. Lack of availability means that the Java environment does not provide a way to continue the processing of the Java Application if the Application or the JVM encounters a fatal error. In this case, manual intervention is required to reestablish the Java environment and restart the failed application, resulting in a severe interruption to the service provided by the Java program. Given the critical nature of the Java e-commerce applications, the lack of scalability and availability in the Java environment is simply unacceptable. Thus, there is a need for a modified Java environment which supplies scalability and availability without sacrificing portability and architectural-neutral features of Java technology. The present invention is directed towards such a need.","Briefly, the present invention configures a system to provide a distributor module and one or more Java Network Server Applications such that the Network Sever Applications inherit the scalability and availability properties of the system. One system, in accordance with the present invention, is a system for providing Java-implemented Application Servers to a plurality of clients. The system includes a computing system having a plurality of processing elements, each element configured such that, despite a failure of one processing element, the remaining processing elements continue to function, a plurality of Java-implemented Application Servers, where at least one Server assigned to execute on one or more processing elements, and a distributor module that is configured: (i) to capture connection requests from a client on a port, (ii) to select one of the plurality of Application Servers to communicate with the requesting client during the connection and (iii) to assign the connection request to the selected one of the plurality of Application Servers, such that, after the assignment, the selected Application Server communicates directly with the client.","A method in accordance with the present invention includes a method for providing Java-implemented Application Servers to a plurality of clients. The method includes providing a plurality of processing elements, where each element is configured such that, despite a failure of one processing element, the remaining processing elements continue to function. The method further includes causing a plurality of Java-implemented Application Servers to execute on the processing elements, where at least one Server assigned to execute on one or more of the processing elements, receiving incoming client connection requests at at least one port managed by a distributor module, selecting one of the Application Servers to communicate with the client during the connection, and assigning, by the distributor module, the connection request to the selected Application Server such that, after the assignment, the selected Application Server communicates with the client directly.","One advantage of the present invention is that Java-implemented Application Servers need not be rewritten or modified to obtain scalability and availability properties. This maintains the portability of the Java Program.","Another advantage is that a Java-implemented Application Server can be used in applications that demand high levels of scalability. Simply by adding more CPUs to the server, the number of Application Servers can be increased.","Yet another advantage is that the client load on the Java-implemented Application Server can be controlled. A separate Application Server on the same CPU or a different CPU can be added to relieve an Application Server of a client load that is too high. This improves the response times of clients that are connected to the Application Server.","Yet another advantage is that Java-implemented Application Servers can be used in environments that demand little or no down time. An Application Server that fails is restarted on its original CPU or another CPU to maintain a given number of Application Servers present to service client requests.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1","b":["10","12","14","16","18"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2","b":["20","22","24","26","28","30"]},"In addition to the protocol, the operating system on the server typically employs a standard set of transport service primitives to access the transport service. A standard set of primitives for a server includes primitives such as a SOCKET call, in which a server first establishes a communication endpoint, a BIND call in which a server assigns an address to the socket, a LISTEN call, by which the server sets up storage for incoming client connection requests, an ACCEPT call to await an incoming connection, SEND and RECEIVE primitives to transmit and receive data over the connection and a CLOSE primitive to end the connection. A client also makes use of these primitives, with the exception of the ACCEPT, BIND and LISTEN calls.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3","b":["32","32","32","32","34","34","36","36","34","34","38","38","38","40","40","42","42","34","34","38","38","44","44","46","46"],"i":["a","b ","a","b ","a","b ","a","b","a ","b","a","b ","a ","a","b","a","b","a","b","a","b ","a","b","a","b "]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 4","FIG. 3","FIG. 3"],"b":["50","52","52","52","52","54","56","50","50","34","38","34","38"],"i":["a, ","b","c ","d","a\u2013d","a\u2013b","a\u2013b ","a\u2013b","a\u2013b "]},"The Distributor module , in accordance with the present invention, acts as a router that receives client connection requests for the Java-implemented Network Application. The Distributor  listens on the ports  that the Network Application would listen on if there were no Distributor , thus acting as a proxy for the Network Application. The Distributor performs load balancing by routing, when possible, client connection requests to the Network Application Server that is least busy.","The Java-implemented Network Application Server modules , in accordance with the present invention, and, with them, Java Virtual Machines, are configured to receive client connection requests and to complete the connections to one of the clients . Once the connection is established, one of the Network Application Servers performs services requested by the client until the client disconnects from the Network Application Server to which it was connected. A modified Java Virtual Machine is configured to assist in the establishing of the connection.","A set of configuration tools, in accordance with the present invention, is provided to allow the system manager to configure, reconfigure and manage the Java-implemented Network Application Server.","The Distributor Module","As mentioned above, the Distributor module  acts as a router for the Network Application Server Modules. More particularly, the Distributor module is an instance of a server class process. The Distributor executes a BIND call to assign ports to a socket of the Distributor. The ports that are assigned are the ports that the Network Application Server Modules would otherwise listen on. The Distributor module then executes a LISTEN call to set up a data buffer for client connection requests and then an ACCEPT to accept the incoming requests. Once a connection request is received, the Distributor uses a modified round-robin mechanism to find the least busy Network Application Server Module. If a suitable Network Application Server module is found, the Distributor forwards the client connection request to the found server, after which the client and the found server continue their conversation without the Distributor involved, until the connection is closed.  shows a flow chart for the set up of the Distributor module of the present invention. The Distributor has an Initialization phase , a main operating phase  and a restart phase  (if and when a failure  occurs), each of which is described in more detail below.","Initialization of the Distributor","To get started, the Distributor  obtains or collects information about the Network Application Servers in  associated with the Distributor , the maximum number of clients for each Network Application Server and the ports to listen on.  shows a flow chart for the initialization of the Distributor module.","Step  sets forth the information obtained by the Distributor at Initialization. The obtained information includes the server class name of the Distributor, the server class name of the Application Servers associated with the Distributor, the maximum number of clients of each Application Server, the number of static Application Servers running in the Application Server class, the number of dynamic Application Servers running in the Application Server class, and the assigned ports on which to listen.","In step , the Distributor opens $RECEIVE, (a system wide file which acts as a message queue for many interprocess communication messages) and awaits the client connections. The modified Java Virtual Machine (JVM) assists in the $RECEIVE operation and the second phase of the accept method (i.e., accept_nw2 ( ), a method that creates a new socket for data transfer, and accepts a connection on the new socket), discussed below. If $RECEIVE is successful, in step , the Distributor then creates, in step , the ServerStatus structure (table). The ServerStatus structure is an internal structure that contains an entry for each of the static Application Servers in the server class associated with the Distributor. The Distributor stores the ServerStatus information about each Application Server in a linked list of these structures: {serverId, dialogId, numClients, sendOutstanding, tag, reqBuf}, where serverId holds a unique identifier for an Application Server, dialog_id holds an identifier for the dialog established with an Application Server, numClients is the number of clients the server is currently handling, sendOutstanding is a Boolean indicating whether a SERVERCLASS_DIALOG_SEND is outstanding for the Application Server, tag indicates the port associated with an outstanding dialog, if any, and reqBuf is a pointer to a request buffer allocated for the Application Server.","Next, in step , the SERVERCLASS_DIALOG_BEGIN, a procedure call to initiate a dialog with a server, is invoked for each server. After this function is invoked for all servers as determined by step , the PortInfo structure (table) is created for a port, in step . The PortInfo structure is an internal structure that contains information associated with the ports on which the Distributor is listening. The Distributor creates a linked list of such structures: {portNumber, fileNum, listenFromSocketAddr, acceptFromSocketAddr}, where portNumber is the port number, fileNum is the file number of the socket that is bound to the port, and listenFromSocketAddr is a pointer to storage that contains the remote address and port number for the connection when the first phase of the accept (accept_nw ( )) completes, and acceptFromSocketAddr contains the remote address and port number of a new connection.","Next, in step , the listen( ) function is invoked for the port, and then, in step , the accept_nw( ) (the first part of a two-phase accept process) for each port, which places the module in a state in which it is ready to receive client connections. This continues until all ports, in step , are ready to receive client connections.","Distributor Operation",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 7","b":"120"},"If a client_connection_request is received, the Distributor, in step , attempts, in step , to find the server process that is currently handling the fewest number of clients. In step , if a qualifying server is found, the Distributor performs a SERVERCLASS_DIALOG_SEND function , which initiates a data transfer to an Application Server with an established dialog, to send a message containing the address of the client requesting a connection to the found Application Server. If a qualifying server is not found, as determined in step , the client connection request is placed on a waiting list, in step , for the next available Application Server that meets the qualification and in step , the Distributor reissues an accept_nw( ), a method that listens for connects on an existing socket, to accept the next message.","If a server process message is received, in step , the Distributor, in step , finds the Application Server and updates the number of current clients for that Application Server, because the message is a disconnect message from the Application Server. If there are any clients waiting to connect to the Application Server that just disconnected from a client, as determined in step , then a SERVERCLASS_DIALOG_SEND function, in step , is performed to send to the Application Server the address of the client waiting for a connection to that Application Server.","If a system message is received, in step , the Distributor, in step , checks to determine whether the message is either an open, close or SIGNALTIMEOUT message. The SIGNALTIMEOUT procedure sets a timer to a given number of units of elapsed time, as measured by the processor clock. When the timer expires, the calling process receives an indication in the form of a system message on $RECEIVE.","If the received message is a close message as determined in step , the operation phase of the Distributor is ended. Otherwise, the Distributor takes the appropriate steps based on the message and returns to the AWAITIOX call, in step , which completes a previously initiated I\/O operation, to look for another message.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 8"},"Referring to , the Distributor executes a AWAITIOX call in step  and waits for a new message to arrive in step . By testing the fileNum parameter that is returned, the Distributor can determine the message type. If the fileNum parameter matches RECEIVE_FILENUM, then a message from the Application Server is received in step . Responding to the message may require that the ServerStatus structure be updated because a disconnect has occurred. If the fileNum parameter matches the scsend_op_num in step , then the ServerStatus structure is updated, in step , by calling the updateServerStatus function.","If fileNum does not match either RECEIVE_FILENUM or scsend_op_num, in step , then the message is determined to be a client connection request (this is the default case). Upon making this determination, a ConnectionRequest ( ) function  is called to verify that the port at which the accept_nw ( ) function was just completed  is valid. The distributor then calls findBestServer ( )  to find a server to accept the new connection. This routine uses the ServerStatus linked lists to find the best available server. The best server available is the one that will be handling the fewest number of clients after the client connection is assigned. The best server available also will not have an outstanding dialog because this would mean that the server had received a previous client connection request but had not yet responded to the distributor that it had accepted the request. If no such server is available, the Distributor performs a SERVER_CLASS_DIALOG_BEGIN in step , a procedure call to initiate a dialog with a server, to force the PATHMON module to start an new Application Server (assuming that not all dynamic servers are running). If the SERVER_CLASS_DIALOG_BEGIN fails, in step , then findBestServer ( ) returns a dialog_id value of (\u22121). Because there are no available servers, the client request is next put on a waiting list, in step , accept_nw ( ) is invoked, in step , and the Distributor returns to wait for another message in step .","If findBestServer ( ) succeeds, in step , then findBestServer ( ) returns with a dialog_id value for the server and a buffer pointer to the request buffer allocated from memory, in step , for the Application Server. Next, the Distributor performs a SERVERCLASS_DIALOG_SEND, in step , to commence communication between the client and the Application Server.","Distributor Restart",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 9"},"The Application Servers","An Application Server includes any Java-implemented program that uses the java.net.ServerSocket class accept method. This class is normally used to wait for connections from clients. An Application Server using the ServerSocket class, creates a ServerSocket object and calls the class's accept ( ) method to wait for a client connection. When the connection arrives, the accept ( ) method then creates a socket object which the Application Server uses to actually communicate with the client.","In one embodiment of the present invention, a customized ServerSocket class is provided for the Application Server to simplify and include a two-phase accept protocol without altering the API of the object. In the customized ServerSocket class, an interprocess communications routine $RECEIVE is opened, and the code that performs a LISTEN, BIND and ACCEPT is disabled. Instead, when the accept method is invoked, the Application Server employing the customized ServerSocket class waits on $RECEIVE for a message from the Distributor containing the address of the client to accept. Next, the Application Server replies with a message containing the current number of clients being serviced by the Application Server and a new threads routine (accept_nw ( )) is called which returns a socket that the Application Server can use to communicate with the client. When the client disconnects from the Application Server, the custom ServerSocket class performs a SERVERCLASS_SEND to the Distributor with a message than contains the current number of clients. The Distributor responds with an acknowledge which the Application Server receives and discards.","Additionally, an Application Server of the present invention, preferably communicates with a client until the client's request is fully processed. After the communication with the client has terminated, the Application Server closes the socket it used to communicate with the client. The Application Server should not retain a client's state after the client disconnects from the Application Server, because the Distributor cannot guarantee that a particular client will reconnect to the same Application Server.","In accordance with the present invention, a Java-implemented server becomes an Application Server by means of a configuration tool. A program can have several types of Application Servers, with each type performing a different service. Each different Application Server runs in a different server class. As mentioned above, for each server class there is one Distributor in that class.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 10","b":["54","34","38","180","65","34","50","34","50","4049","52","4049","54","54"],"i":["a\u2013d ","a\u2013b","a\u2013b ","a ","b","a ","a ","e "]},{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 11","FIG. 10"],"b":["52","54","52","50","56","54","54","52"],"i":["e ","e ","e ","e ","e","e. "]},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 12","b":["34","56","54","34","52","50","50","54","34","54","52"],"i":["c ","f ","b","c","f ","b","f ","c. "]},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 13","b":["180","182","52","54","52","53","182","50","51","180","182","50","4049","51","6157"],"i":["a ","a ","b ","c "]},"Configuration Utility","The Configuration Utility aids in the capture, from the user, of critical information for configuring and starting the Distributor and the Application Servers. This information includes a","name for the PATHMON process;","the primary CPU and backup CPUs for PATHMON;","a log file directory for stderr and stdout files;","the number of Application Server classes;","the location of the Java Virtual Machine to be used;","the number of static Application Servers;","the number of dynamic Application Servers; and","for each type of Application Server the following:\n\n","After receiving this information the configuration tool creates a configuration file and a start file which is used to start the Application Servers. The configuration file provides the Distributor the information it needs to begin listening and accepting client connection requests. The configuration also provides an Application Server the information it needs to run as a Application Server in a specific server class.","Although the present invention has been described in considerable detail with reference to certain preferred versions thereof, other versions are possible. Therefore, the spirit and scope of the appended claims should not be limited to the description of the preferred versions contained herein."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["These and other features, aspects and advantages of the present invention will become better understood with regard to the following description, appended claims, and accompanying drawings where:",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 11","FIG. 10"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
