---
title: Instruction set emulation for guest operating systems
abstract: The described implementations relate to virtual computing techniques. One implementation provides a technique that can include receiving a request to execute an application. The application can include first application instructions from a guest instruction set architecture. The technique can also include loading an emulator and a guest operating system into an execution context with the application. The emulator can translate the first application instructions into second application instructions from a host instruction set architecture. The technique can also include running the application by executing the second application instructions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09495183&OS=09495183&RS=09495183
owner: Microsoft Technology Licensing, LLC
number: 09495183
owner_city: Redmond
owner_country: US
publication_date: 20110516
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION"],"p":["Computer applications are often programmed to interface with an operating system that provides various functions to the applications. For example, operating systems can provide lower-level services such as device drivers and memory management routines, or higher-level services such as graphical user interface application programming interfaces (\u201cAPIs\u201d). In some cases, a particular application may only be provided for a particular operating system. For example, an application may be implemented on one or more versions of Windows\u00ae, but may not have been ported to Unix\u00ae or other operating systems.","Computer applications are also often limited to certain instruction set architectures. For example, an application can be compiled into binary code for one instruction set architecture, e.g., x86. This binary code generally will not execute on a different instruction set architecture, e.g., a PowerPC processor. Rather, different compiled binaries normally need to be generated for each instruction set architecture on which the application is expected to run.","Traditional techniques to allow application portability across operating systems and instruction set architectures tend to be relatively inefficient and cumbersome. For example, virtual machine monitors can allow a copy of a guest operating system to execute on a computer system with a different underlying host operating system. However, this approach generally involves executing full copies of both the guest operating system as well as the underlying host operating system. Likewise, central processing unit (\u201cCPU\u201d) emulators can be used to translate code into different instruction sets at runtime instead of using precompiled binaries. However, these emulators generally have a substantial memory and processor footprint that do not lend them to efficient integration with a guest operating system executing on a virtual machine.","This document relates to virtual computing techniques. One implementation is manifested as a technique that can include receiving a request to execute an application. The application can include first application instructions from a guest instruction set architecture. The technique can also include loading an emulator and a guest operating system into an execution context with the application. The emulator can translate the first application instructions into second application instructions from a host instruction set architecture. The guest operating system can provide at least one guest operating system interface that is called by the application. The technique can also include running the application by executing the second application instructions.","Another implementation is manifested as a system that can include an emulator configured to receive a request from a guest operating system to load first instructions in a guest instruction set architecture. The emulator can also be configured to check a translation table to determine whether corresponding second instructions are available in a host instruction set architecture, and, in a first instance when the second instructions are available, load the second instructions. The emulator can also be configured to, in a second instance when the second instructions are not available, delay translating the first instructions until a request to execute the first instructions is received. The system can also include at least one processing device configured to execute the emulator.","Another implementation is manifested as a computer-readable storage media that can include instructions. The instructions can be executed by one or more processing devices, which can cause the one or more processing devices to perform receiving a request to execute an application on a host device. The host device can have a host instruction set architecture and a host operating system. The application can include one or more application binaries. The acts can also include checking application metadata associated with the application to identify an instruction set architecture and an operating system for the application. When the instruction set architecture for the application corresponds to the host instruction set architecture and the operating system for the application is the host operating system, the application can be loaded in an execution context. When the instruction set architecture for the application corresponds to the host instruction set architecture and the operating system for the application is different than the host operating system, the application can be loaded together with a guest operating system for the application an execution context. When the instruction set architecture for the application is different than the host instruction set architecture and the operating system for the application is different than the host operating system, the application, an emulator, and a guest operating system for the application can be loaded together in an execution context.","The above listed examples are intended to provide a quick reference to aid the reader and are not intended to define the scope of the concepts described herein.","Overview","This document relates to virtual computing techniques performed on a host device, and more particularly to implementing a guest operating system (\u201cOS\u201d) and\/or an application in a different instruction set architecture (\u201cISA\u201d) than that of the host device. Generally speaking, the host device can have a host OS operating thereon, which can execute in the native ISA of the host device. The host OS can interact directly with the hardware of the host device to provide normal OS functionality. For example, the host OS can provide functionality such as memory management, thread creation, thread synchronization, input\/output streams, creating windows and\/or dialog boxes, etc.","Generally speaking, the host OS can provide this functionality to various applications via one or more interfaces such as APIs or application binary interfaces (\u201cABIs\u201d). The host OS interfaces are collectively referred to herein as the \u201chost OS application interface set.\u201d In many cases, applications are configured to make calls to functions provided by a particular OS. If these functions are supported by the host OS application interface set, the application can generally interface directly with the host OS. If not, the application can have limited or no compatibility with the host OS. For example, a Unix\u00ae machine may not implement any Windows\u00ae application interfaces, and thus a Windows\u00ae application typically will not run directly on a Unix\u00ae machine. Even different versions of an operating system may deprecate individual functions, implement them in unexpected ways, or otherwise render the operating system incompatible with the application. For example, an application that is configured to run on Windows\u00ae 98 may attempt to call various application interfaces that are deprecated in a newer OS such as Windows\u00ae 7. This may render the application partially or completely inoperable on a machine that is running Windows\u00ae 7.","One way to handle this problem is to implement a guest operating system that runs on the host operating system. The guest OS can also implement a set of application interfaces (API's or ABI's), referred to herein collectively as the \u201cguest OS application interface set.\u201d If the guest operating system implements individual application interface calls as expected by the application, the application can interface with the guest operating system and function properly. This is generally true regardless of whether the host OS application interface set also supports the functions called by the application. However, as mentioned above, running two full copies of different operating systems concurrently can often be quite inefficient. Moreover, this problem can be compounded when the application executes in a different instruction set than the hardware of the host device.","The disclosed implementations provide a guest operating system that can support applications that execute in a different ISA than the host device. The guest OS can interface to an OS virtualization monitor (\u201cOS VM\u201d) that provides a relatively small set of abstractions to the guest OS. These abstractions can be built via individual binary calls from the guest OS to the OS virtualization monitor. Collectively, the individual binary calls implemented by the OS virtualization monitor are referred to herein as the \u201cOS VM interface set\u201d or \u201cVM interface set.\u201d","The guest OS can make calls to implement the guest OS interface set in a manner that is consistent with the expectations of applications that are configured to use individual guest OS interfaces. If the application is in a different instruction set than the host device, the application and the guest OS can execute on a CPU emulator. The guest OS can make calls to the VM interface set to implement the guest OS application interface set as expected by the application. From the perspective of the application, the guest OS is supporting the application via memory management, thread creation, thread synchronization, input\/output streams, creating windows and\/or dialog boxes, etc. In some implementations, the application can execute on the CPU emulator in the same execution context as the guest OS, e.g., a single user-mode process.","Using the above-described architecture, the application can execute using both a different instruction set and a different OS application interface set than is provided by the underlying host device and OS. Moreover, because the application can execute together with the guest OS in a user-mode process, the guest OS can be implemented in user-mode instructions that share security permissions with user-mode instructions of the application. This can also substantially reduce the resource footprint of the guest OS and CPU emulator, because the guest OS and CPU emulator do not need to provide support for kernel mode instructions in the guest ISA. Instead, only the host OS needs to execute kernel mode instructions in the native ISA.","Example System","For purposes of explanation, consider introductory .  shows an exemplary architecture of a host computing device  that is configured to accomplish the concepts described above and below. Host computing device  can include a central processing unit (\u201cCPU\u201d)  that is operably connected to a memory . For example, CPU  can be a reduced instruction set computing (RISC) or complex instruction set computing (CISC) microprocessor that is connected to memory  via a bus. Memory  can be a volatile storage device such as a random access memory (RAM), or a non-volatile memory such as FLASH memory. Although not shown in , host computing device  can also include various input\/output devices, e.g., a keyboard, a mouse, a display, a printer, etc. Furthermore, the host computing device can include one or more non-volatile storage devices, such as a hard disc drive (HDD), optical (compact disc\/digital video disc) drive, tape drive, etc. Generally speaking, any data processed by host computing device  can be stored in memory , and can also be committed to non-volatile storage. As used herein, the term \u201ccomputer-readable media\u201d can include transitory and non-transitory instructions. In contrast, the term \u201ccomputer-readable storage media\u201d excludes transitory instances, and includes volatile or non-volatile storage devices such as random access memory, optical disks, hard drives, flash drives, etc.","Memory  of host computing device  can include various components that implement certain processing described herein. For example, memory  can include a host operating system . Generally speaking, host operating system  can be a fully functional operating system such as found on a modern personal computer, server, tablet, cell phone, or other computing device. For example, host operating system  can be a version of Windows\u00ae, Unix\u00ae (including related operating systems such as OS X\u00ae), Linux\u00ae (including related operating systems such as Android\u00ae), a real-time and\/or embedded operating system, etc. Host operating system  can include one or more binary files that are in the native or host ISA for CPU .","Memory  can also include an operating system virtualization monitor  and an execution context . Execution context  can include a process, thread, task, or other execution context that includes an emulator , a guest operating system , and an application . Note that host OS  and\/or OS virtualization monitor  can generally be implemented via one or more other execution contexts. In some implementations, execution context  includes a single address space that is shared by emulator , guest OS , and application . Said another way, execution context  includes memory that is allocated specifically for use by any of emulator , guest OS , and application , and that is not available for use by other execution contexts on host computing device .","Generally speaking, guest operating system  can be configured to provide a guest OS application interface set for applications such as application . Operating system virtualization monitor  can be configured to provide a set of virtualization interfaces to guest operating system , e.g., the OS VM interface set. Host OS  can be configured to provide a host OS application interface set to OS VM . Generally speaking, emulator , OS VM , and host OS  can be implemented in the host ISA. Application  and guest operating system  can each include one or more binary files that include instructions in the guest ISA which can be different than the host ISA.","Emulator  can be configured to provide instructions that are translated from the guest ISA to the host ISA so that the translated instructions can be executed on CPU . For example, emulator  can be configured to compile a set of instructions from the guest ISA into the host ISA. Emulator  can also be configured to obtain a previously-translated set of instructions in the host ISA. For example, emulator  can be configured to track instructions from the guest ISA that have already been compiled into the host ISA and use the previously-compiled instructions rather than recompiling them. Emulator  can also interpret and\/or just-in-time compile guest ISA instructions into the host ISA, as set forth in more detail below.","In some implementations, CPU  can have different levels of privileges for individual instructions. For example, an x86 processor can have certain instructions that can only be executed in a \u201ckernel mode\u201d that are not available to \u201cuser mode\u201d programs. In such implementations, host operating system  can include binaries that execute in kernel mode, but only allow access to CPU  via user mode instructions for execution context . Said differently, execution context  can be a user mode execution context, whereas host operating system  can include at least one kernel mode execution context, e.g., a Windows\u00ae system process. More generally, host operating system  can include at least one privileged execution context that has at least some higher privileges than execution context .","In some implementations, host operating system  can implement lower-level operating system functionality such as timers, interrupts, input\/output, virtual memory (e.g., accessing a page table maintained by CPU ), pointer validation, and\/or context switching by switching to the privileged execution context, e.g., kernel mode. Host operating system  can also implement \u201crich\u201d operating system functionality via one or more interfaces for application configuration, graphical user interfaces, etc., in a non-privileged execution environment such as a user mode process. Host operating system  can provide both the lower-level and rich functionality via the host OS application interface set.","However, because application  is generally configured to interface with guest OS  instead of host OS , application  may not be configured to use the host OS application interface set. Instead, guest operating system  can provide such operating system functionality via a guest OS application interface set. The guest OS application interface set can include at least some application interfaces that are particular to guest operating system  and that may not be provided by host operating system . Because these interfaces are provided by guest OS , application  does not need to be ported, recompiled, or otherwise modified to interface directly with host operating system . Moreover, because guest operating system  and application  are operable on emulator , application  can also execute binary code that is in a different ISA than the native ISA for CPU . Thus, application  can run directly within execution context  even though application  may have originally been built for both a different operating system and a different architecture than host computing device .","Note, however, that in some implementations, part or all of guest OS  and application  can run in a kernel mode process, e.g., execution context . OS VM  can cause the kernel mode process to appear to application  as a user-mode process. For example, OS VM  can prevent application  from executing any kernel mode instructions, while OS VM  can allow guest OS  to execute kernel mode instructions.","OS VM  can also service certain requests by application  with responses that are consistent with application  executing in a user-mode process. For example, application  can execute an instruction in the guest ISA that reads a register value from emulator . The register value can represent the privilege mode in which application  executes in the guest ISA. OS VM  can respond to application  with a value that indicates that application  is executing in a non-privileged mode. This can be true even when execution context  is actually a privileged execution context provided by host OS  and can execute privileged instructions in the host ISA.","As a specific example, consider a scenario where the guest ISA is an x86 instruction set. Application  can execute an x86 PUSHFD instruction and receive a response indicating that application  is executing in Ring 3 of the x86 ISA. However, execution context  (e.g., guest OS  and\/or emulator ) may actually have access to Ring 0x86 functionality. Note that this may also mean that corresponding host ISA instructions can be executed by guest OS  and\/or emulator , but not application .","Furthermore, note that, in some implementations, guest operating system  does not need to fully implement certain lower-level operating system functionality discussed above with respect to host operating system . Rather, guest operating system  can be built to use calls to the VM interface set to provide such functionality to application . OS VM  can translate these calls into corresponding calls from the host OS application interface set and host OS  can handle the calls in the host ISA. This implementation can reduce the footprint of guest operating system  while still providing the flexibility to support the complete guest OS application interface set.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 2","b":["100","108","106","101"]},"However, some or all of the application binaries may use calls to the guest OS application interface set. These calls are also generally in the guest ISA, but rely on guest OS  to perform some functionality for application . Guest OS  can include one or more binaries in the guest ISA that implement the functions provided via the guest OS application interface set. Some of these binaries can also be translated by emulator  into the host ISA and execute directly on CPU . For example, in some implementations, guest OS  can draw a window for application  using only its own translated code via emulator . Guest OS  may be able to do so because the window can be drawn without using privileged instructions such as kernel mode instructions.","However, in some cases, application  may make a guest OS interface call that guest OS  cannot satisfy directly. For example, application  may request to access a file or create a new thread. Guest OS  may need to interface with OS virtualization monitor  to implement these operations, because these operations may require privileged (e.g., kernel mode) instructions and\/or file system access privileges. Guest OS  can access files, create new threads, etc. by making calls to the VM interface set in the guest ISA. Emulator  can translate these calls into the host ISA. The translated VM interface calls can be provided to OS VM , which can execute them in the host ISA.","In some cases, the VM interface calls are implemented by OS VM  via one or more calls to host OS application interfaces. Indeed, some VM interface calls are simply wrappers for the underlying host OS calls, e.g., creating threads or allocating virtual memory. In other cases, the guest OS can add a layer of functionality on top of host OS  calls to OS VM . To do so, OS VM  can make calls to high level services provided by host OS , such as file input\/output, threading, synchronization, etc.","For example, OS VM  can enforce permissions for application , guest OS , and\/or emulator . OS VM  can do so using a single set of permissions associated with execution context  for various operations. Thus, for example, OS VM  can prevent application  from accessing a particular file by not allowing any instructions from execution context  to access the file. This implementation allows guest OS  and application  to share a common set of permissions.","Guest OS  can also provide device support for devices such as displays, printers, keyboards, mice, etc. via a remote desktop protocol (\u201cRDP) instead of using a conventional device driver. Guest OS  can do so by receiving calls to the guest OS application interface set from application  and communicating with the devices via the RDP protocol. The RDP protocol can be implemented via communication pipes that are routed through OS VM  to host OS . Host OS  can receive the RDP calls and control the devices via device drivers that are part of host OS . Note that the communication pipes can cross machine boundaries, e.g., over a network or other type of communication link.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 3","b":["106","106","107","108","106","301","302","303"]},"Using precompiler , CPU emulator  can translate binary files of guest OS  and\/or application  from the guest ISA to the host ISA. Generally speaking, precompiler  can translate the binaries before the binaries are invoked for execution, e.g., precompiler  can translate binaries for guest OS  offline before guest OS  is loaded into execution context . Likewise, precompiler  can translate the binaries for application  before application  is loaded into execution context . For example, precompiler  can load one or more binaries of application  and\/or guest OS  from storage into memory , translate them from the guest ISA to the host ISA, and store the corresponding host ISA binaries for later usage.","Under some circumstances, precompilation is not necessarily suitable. For example, a user may request to initiate application  and\/or guest operating system  on host computing device  before precompiled binaries in the host ISA are obtained by emulator . As another example, application  may generate code at runtime in the guest ISA which needs to be translated into the host ISA while application  and guest OS  are already running. Under such circumstances, the binaries can be translated at runtime by just-in-time compiler  and\/or interpreter .","Generally speaking, just-in-time compiler  compiles a group of instructions (binary) in the guest ISA the first time they are executed, caches the compiled instructions as one or more binaries in the corresponding host ISA, then executes the cached host ISA binaries each time the corresponding binaries in the guest ISA are invoked afterwards. In contrast, interpreter  translates guest ISA instructions into host ISA sequentially and generally does not compile or cache the translated host ISA instructions. Rather, each time the guest ISA instructions are invoked, interpreter  performs the translation and executes the host ISA instructions, but does not retain the translated host ISA instructions for later use.","Note that, in some implementations, the translation techniques mentioned above can be performed using source files instead of binaries. For example, one or more source files of guest OS  and\/or application  can be compiled and\/or linked by precompiler , just-in-time compiler , and\/or interpreter  instead of performing the translation of binaries. Generally speaking, however, many applications and operating systems are distributed only as binaries and the techniques disclosed herein can be performed without access to source code for either guest OS  or application .","Note that there may be certain performance trade-offs associated with which of the above-mentioned techniques is used for translation. When possible, precompiling can provide good performance because the host ISA binaries are available when application  and\/or guest OS  begins execution. This is because there is no need to translate the guest ISA instructions at runtime, the precompilation process can be performed offline prior to their execution. Furthermore, the precompiled binaries can be resident in shared memory. This can be particularly useful in circumstances where multiple applications execute the same binary code on emulator , because the applications themselves may have different address spaces in their respective execution contexts. By storing the precompiled host ISA binary in shared memory, the applications sharing the host ISA binary do not need to each have a copy of the host ISA binary in the address space for their respective execution contexts. Rather, the host ISA binary can be shared between multiple execution contexts, each of which can include an application and\/or guest OS.","Just-in-time compiling, on the other hand, generally occurs while application  and\/or guest OS  is already executing. Moreover, just-in-time compiling generally results in a host ISA binary that is stored in the private address space for the application, e.g., in memory that is allocated to the application's execution context. The first time a given set of instructions is executed by application , the instructions are compiled into the host ISA. This can result in a certain amount of latency because the compilation can use a substantial amount of computational resources, e.g., heavy processor loading on CPU , substantial usage of memory , and\/or the time to read the guest ISA binary from storage into memory .","However, when using just-in-time compiler , once a given set of instructions has been compiled into the host ISA, they do not need to be recompiled each time the corresponding guest ISA instructions are invoked. In contrast, interpreter  generally translates guest ISA instructions sequentially and does not cache translated instructions. This can prevent the one-time latency issue mentioned above for just-in-time compilation. However, because the host ISA instructions are not cached for later use by interpreter , the host ISA instructions need to be generated each time the corresponding guest ISA instructions are invoked. Also, many interpreters produce code that is not optimized or is otherwise relatively inefficient in comparison to code that is compiled by precompiler  and\/or just-in-time compiler .","Emulator  can also maintain a translation table . For example, translation table  can be used by emulator  to check whether a particular set of guest ISA instructions have been translated into host ISA instructions and loaded for execution. By doing this check before translating the guest ISA instructions with precompiler , just-in-time compiler , or interpreter , emulator  can avoid unnecessary compilation overhead. Note that the term \u201ctable\u201d is used generically to refer to many different data structures and that translation table  can be implemented using arrays, structures, classes, linked lists, trees, etc.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 4A-4C","FIG. 4A","FIG. 4B","FIG. 4C"],"b":["304","106","304","108","304","108","1","304","108","2","107","1","2","105"]},"As shown in , translation table  can include a file name column , a guest ISA address column , and a host ISA address column . File name column  is provided to illustrate logical names for the binaries provided by guest operating system  and\/or application  discussed herein. For example, guest operating system  can provide interfaces to functions that create and close a window via GuestOS_DLL_, and interfaces to functions that create or manage virtual memory via GuestOS_DLL_. These binaries can have addresses in the guest ISA shown at guest ISA address . The binaries can be translated into the host ISA, e.g., by precompiler , prior to executing guest OS  and\/or application  on host computing device . The corresponding host ISA binaries can be loaded into memory and have host ISA addresses as shown in host ISA address column .","Application  can make calls to the guest OS application interface set by linking to the guest OS binaries at runtime. From the perspective of application , these binaries are located at the guest ISA addresses at column . When they are loaded by emulator , however, emulator  updates translation table  with the corresponding host ISA address . Note that host ISA address  can be a virtual memory address within the address space allocated to execution context , and may actually correspond to different physical addresses in memory . In such implementations, CPU  and\/or host OS  can translate the virtual addresses to actual physical addresses on memory .","As described below, each time a load request for a guest ISA binary is received, emulator  can check translation table  to determine whether the corresponding host ISA binary has been previously compiled and loaded into memory. If so, emulator  does not need to translate the binary into the host ISA. Instead, emulator  can simply wait until the binary at the corresponding host ISA address  is executed and run the translated code at that time.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 4B","b":["304","108","1","105","108","1","106","108","108","107","304"]},"If the host ISA binary has already been loaded, the binary is ready to execute. If the host ISA binary has already been compiled but not loaded, e.g. precompiled and available in storage, them emulator  can load the precompiled binary and update translation table . If the host ISA binary is not yet available on storage, emulator  can wait until execution time and use just-in-time compiler  to translate App_DLL_ into the host ISA. At that time, emulator  can make a new entry in translation table  that includes the guest ISA address for App_DLL_ as well as the corresponding host ISA address where the translated binary is loaded. Then, emulator  will not need to recompile App_DLL_ if application  attempts to load this file again. Rather, emulator  can receive the guest ISA address for this file from application , determine that there is a corresponding host ISA address that is already loaded with a host ISA binary by checking translation table , and later execute the corresponding host ISA binary without needing to translate the file into the host ISA again.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 4C","b":["304","108","2","2","304","302","106","304","2"]},"To the extent feasible, it can be useful to precompile as many binaries as possible for guest OS  and\/or application . For example, if host computing device  is intended to permanently support the guest OS , it can be desirable to precompile all of the binaries for the guest OS, or at least those binaries that are most likely to be used at runtime by applications. Then, the binaries are available to be loaded and updated in translation table  responsive to receiving the corresponding guest ISA load instruction. Likewise, if application  is expected to remain on host computing device  for any sustained period of time, it can also be desirable to precompile all binaries associated with application . In some implementations, emulator  and\/or OS VM monitor  can track usage statistics associated with individual guest OS binaries and\/or application binaries and precompile more frequently-used binaries while leaving other binaries to be compiled at runtime by just-in-time compiler  and\/or interpreter . This can reduce the amount of memory required for execution context  except in instances where the infrequently-used binaries are actually loaded by application  and\/or guest OS .","However, in some implementations, it may be more feasible or desirable to not precompile all, or even any, of the binaries associated with guest OS  and\/or application . For example, if the execution of guest OS  and\/or application  is intended to be temporary, e.g., a single use, it can be more efficient to interpret and\/or just-in-time compile all of the binaries into the host ISA.","Furthermore, certain binaries may be particular to certain hardware. For example, sometimes two different processors can implement the same basic host ISA. One of the processors may use an arithmetic logic unit (\u201cALU\u201d) to emulate floating point operations with integer operations, while the other may have an additional piece of hardware, e.g., a floating-point unit, that accepts certain floating-point instructions that are not in the basic host ISA. Under such circumstances, it is generally not desirable to compile binaries with the floating point instructions for the processor that does not have a floating point unit. Instead, these binaries would generally be compiled with the corresponding integer operations to implement the emulated floating point operations.","To accommodate these distinctions, emulator  can be configured to precompile all of the binaries for application  and\/or guest OS  without the floating point instructions. At runtime, emulator  can perform a check to see whether CPU  includes the floating point unit. If so, binaries that include floating point operations can be just-in-time compiled or interpreted at runtime instead of executing the precompiled binaries. Otherwise, the precompiled floating point emulation integer operations can be executed instead. Alternatively, the binaries can be precompiled both with and without the floating point instructions ahead of time, and emulator  can load the appropriate binary at runtime after determining whether CPU  supports the floating point instructions.","Furthermore, note that guest operating system  may be substantially reduced in size relative to a \u201ctypical\u201d full operating system. In some implementations, guest operating system  may even have a smaller memory, disk, and\/or processor footprint than application . Accordingly, in some implementations, guest operating system  and\/or application  can be configured together in an installer that installs both guest OS  and application  together on host computing device . In such implementations, the installer may check to ensure that host computing device  has an appropriate emulator  for the guest ISA before going ahead with the installation. The installer can also check CPU  to see whether CPU  supports certain instructions, such as the aforementioned floating point instructions, and install different binaries for application  and\/or guest OS  depending on whether the instructions are supported.","Using the techniques introduced above, it is possible to support applications configured for various instruction sets and operating systems concurrently on host computing device .  illustrates memory  in such a configuration. As shown in , another execution context  can reside in memory , and include another guest operating system  as well as another emulator . Guest operating system  can be the same operating system as guest OS , e.g., can provide the same application interface set, or can be a different operating system. Likewise, emulator  can support the same ISA as emulator  or a different ISA.","Memory  can also include an execution context  with an application  and a guest OS . Note, however, that execution context  is shown without an emulator. Execution context  may be appropriate when guest OS  and application  are implemented in the host ISA, but application  is configured for guest OS  instead of host OS . Each of execution context , , and  can be configured to communicate to host OS  via OS virtualization monitor .","Execution context  can include an application . Generally speaking, execution context  may be appropriate for applications that are in the host ISA and are implemented in the host ISA. Note that, because application  is configured for host OS , execution context  may communicate directly with host OS  instead of with OS virtualization monitor .",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 5","b":["105","104","106","108","107","106","104","103"]},"Furthermore, using OS VM  can allow different emulators and\/or guest operating systems the flexibility to run on other host devices with different underlying host operating systems and\/or instruction sets. This is because OS VM  provides a layer of abstraction between the emulators\/guest OS's and the underlying host device. Generally speaking, the guest OS and\/or emulators use calls to the OS VM interface set instead of directly using the host OS application interface set. Thus, all that is needed for a given emulator and\/or guest OS to run on a different host OS is an OS VM monitor that properly implements the OS VM interface set. Even if the other host device uses a different instruction set, the emulator and\/or OS can simply be recompiled to the ISA for the host device where they will run.","The following is an exemplary interface set that can be provided by OS VM :",{"@attributes":{"id":"p-0067","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Virtual Memory"]},{"entry":[{},"DKSTATUS"]},{"entry":[{},"DkVirtualMemoryAllocate("]},{"entry":[{},"\u2003inout PVOID *BaseAddress,"]},{"entry":[{},"\u2003inout PSIZE_T RegionSize,"]},{"entry":[{},"\u2003in ULONG AllocationType,"]},{"entry":[{},"\u2003in ULONG Protect);"]},{"entry":[{},"DKSTATUS"]},{"entry":[{},"DkVirtualMemoryFree("]},{"entry":[{},"\u2003in PVOID BaseAddress,"]},{"entry":[{},"\u2003in SIZE_T RegionSize,"]},{"entry":[{},"\u2003in ULONG FreeType);"]},{"entry":[{},"DKSTATUS"]},{"entry":[{},"DkVirtualMemoryProtect("]},{"entry":[{},"\u2003inout PVOID BaseAddress,"]},{"entry":[{},"\u2003inout SIZE_T RegionSize,"]},{"entry":[{},"\u2003in ULONG NewProtect,"]},{"entry":[{},"\u2003out PULONG OldProtect);"]},{"entry":[{},"\/\/ IPC"]},{"entry":[{},"BOOL"]},{"entry":[{},"DkPipeFork("]},{"entry":[{},"\u2003in HANDLE Handle,"]},{"entry":[{},"\u2003out PULONG64 Token,"]},{"entry":[{},"\u2003out PHANDLE NewHandle);"]},{"entry":[{},"BOOL"]},{"entry":[{},"DkSelfPipeCreate("]},{"entry":[{},"\u2003out PHANDLE Handle1,"]},{"entry":[{},"\u2003out PHANDLE Handle2,"]},{"entry":[{},"\u2003out PULONG64 Token);"]},{"entry":[{},"ULONG"]},{"entry":[{},"DkPipeRead("]},{"entry":[{},"\u2003in HANDLE Handle,"]},{"entry":[{},"\u2003in BOOL Async,"]},{"entry":[{},"\u2003in PVOID AsyncToken,"]},{"entry":[{},"\u2003inout PVOID *Buffer,"]},{"entry":[{},"\u2003in ULONG Length,"]},{"entry":[{},"\u2003in_opt PLONG64 Timeout);"]},{"entry":[{},"ULONG"]},{"entry":[{},"DkPipeWrite("]},{"entry":[{},"\u2003in HANDLE Handle,"]},{"entry":[{},"\u2003in BOOL Async,"]},{"entry":[{},"\u2003in PVOID AsyncToken,"]},{"entry":[{},"\u2003in PVOID Buffer,"]},{"entry":[{},"\u2003in ULONG Length);"]},{"entry":[{},"ULONG"]},{"entry":[{},"DkPipeSelect("]},{"entry":[{},"\u2003in ULONG Count,"]},{"entry":[{},"\u2003in const HANDLE *Handles,"]},{"entry":[{},"\u2003in_opt PLONG64 Timeout);"]},{"entry":[{},"ULONG"]},{"entry":[{},"DkPipePeek("]},{"entry":[{},"\u2003in HANDLE Handle);"]},{"entry":[{},"\/\/ Isolated File Access"]},{"entry":[{},"PVOID"]},{"entry":[{},"DkFileOpen("]},{"entry":[{},"\u2003in PUNICODE_STRING pUri,"]},{"entry":[{},"\u2003in_opt PVOID DesiredAddress,"]},{"entry":[{},"\u2003in ACCESS_MASK DesiredAccess,"]},{"entry":[{},"\u2003in ULONG ShareMode,"]},{"entry":[{},"\u2003in ULONG CreateDisposition,"]},{"entry":[{},"\u2003in ULONG CreateOptions,"]},{"entry":[{},"\u2003in SIZE_T Offset,"]},{"entry":[{},"\u2003inout_opt PSIZE_T ViewSize);"]},{"entry":[{},"BOOL"]},{"entry":[{},"DkFileTruncate("]},{"entry":[{},"\u2003in PUNICODE_STRING Uri,"]},{"entry":[{},"\u2003in SIZE_T Length);"]},{"entry":[{},"DKSTATUS"]},{"entry":[{},"DkFileUnmap("]},{"entry":[{},"\u2003in PVOID addr);"]},{"entry":[{},"BOOL"]},{"entry":[{},"DkFileSync("]},{"entry":[{},"\u2003in PVOID addr);"]},{"entry":[{},"BOOL"]},{"entry":[{},"DkFileUnlink("]},{"entry":[{},"\u2003in PUNICODE_STRING Uri);"]},{"entry":[{},"DKSTATUS"]},{"entry":[{},"DkFileAttributesQuery("]},{"entry":[{},"\u2003in PUNICODE_STRING Uri,"]},{"entry":[{},"\u2003out PDK_FILE_ATTRIBUTES Attrs);"]},{"entry":[{},"\/\/ Threading"]},{"entry":[{},"BOOL"]},{"entry":[{},"DkThreadCreate("]},{"entry":[{},"\u2003in SIZE_T StackSize,"]},{"entry":[{},"\u2003in PDK_THREAD_START Address,"]},{"entry":[{},"\u2003in_opt PVOID Parameter,"]},{"entry":[{},"\u2003in ULONG CreationFlags,"]},{"entry":[{},"\u2003out_opt PHANDLE Pipe,"]},{"entry":[{},"\u2003out_opt PULONG64 PipeToken);"]},{"entry":[{},"VOID"]},{"entry":[{},"DkThreadExit( );"]},{"entry":[{},"BOOL"]},{"entry":[{},"DkProcessCreate("]},{"entry":[{},"\u2003in_opt PUNICODE_STRING Appl,"]},{"entry":[{},"\u2003in_opt PUNICODE_STRING CmdLin,"]},{"entry":[{},"\u2003out_opt PHANDLE Pipe,"]},{"entry":[{},"\u2003out_opt PULONG64 PipeToken);"]},{"entry":[{},"VOID"]},{"entry":[{},"DkProcessExit( );"]},{"entry":[{},"\/\/ Other"]},{"entry":[{},"BOOL"]},{"entry":[{},"DkSystemTimeQuery("]},{"entry":[{},"\u2003out PLONG64 SystemTime);"]},{"entry":[{},"BOOL"]},{"entry":[{},"DkRandomBitsRead("]},{"entry":[{},"\u2003in out PVOID Buf,"]},{"entry":[{},"\u2003in SIZE_T BufSize);"]},{"entry":[{},"BOOL"]},{"entry":[{},"DkDebugOutput("]},{"entry":[{},"\u2003in PUNICODE_STRING Message);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As mentioned above, each guest OS can use calls to the VM interface set instead of implementing the guest OS functionality directly. In some cases, a guest OS application interface is a simple wrapper for an underlying VM interface call. This can be the case for virtual memory allocation, thread creation, etc. For example, guest OS  and guest OS  may use different calling conventions for their respective memory allocation interfaces, e.g., different number, order, or names of parameters, etc. However, both guest OS  and guest OS  can implement virtual memory allocation with calls to DkVirtualMemoryAllocate.","Other guest OS functionality may be built using non-trivial binaries that still can utilize the underlying VM interfaces. For example, files, locks, timers, etc., can all be built inside of each individual guest OS. Furthermore, recall that each guest OS can also have one or more binaries that execute directly and do not necessarily use calls to the VM interface set. For example, guest OS  and guest OS  can support different interface calls for creating graphical windows. These interface calls may be implemented directly by executing the corresponding guest OS binaries which may not involve directly calling the VM interface set. In other words, unmodified guest OS binaries may be executed directly instead of modifying the guest OS to use calls to the VM interface set.","In some implementations, this is accomplished by providing modified versions of some binaries that would normally be associated with the guest OS. For example, a Windows\u00ae guest OS may include a binary called comctl32.dll that provides various graphical features such as toolbars and tabs. Comctl32.dll may, in turn, rely on calls to another binary, kernelbase.dll. Typically, guest OS  is distributed with both of these .dll files. In some disclosed implementations, comctl32.dll runs in execution context , and calls from comctl32.dll are passed to a customized version of kernelbase.dll that runs in OS VM  to support guest OS . This version of kernelbase.dll may rely on calls to the VM interface set. This is a particular example of how user mode operating system functionality can be moved into an execution context along with a supported application and an appropriate emulator.","In some implementations, applications can migrate across device boundaries to execute on a different host device. If the other host device implements the VM interface set and the host OS thereon supports the RDP protocol, this can be accomplished by copying the address space and execution context  over to the other host device. For example, one or more pages of memory used by guest OS  and\/or application  as well as register values or other state information can be provided to the other host device.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 6","b":["600","600","100","610","620","610"]},"Although not shown in , host computing device  can have similar components as those set forth above with respect to host computing device . However, host computing device  can have a different native ISA than host computing device , and can also have a different host OS than host OS . If host computing device  correctly implements the VM interface and the RDP protocol, application  can be copied directly to host device  as shown in . For example, at a first time , execution context can be executing on host computing device  as discussed above. At any time, the execution state of application  and\/or guest OS  can be shared by transmitting execution context  over network , as shown at a second, subsequent time . Host computing device  can receive execution context , instantiate a new execution context thereon, and copy execution context  into the new execution context. Host computing device  can have an emulator  that can function as discussed above and below with respect to emulator . In some implementations, state information (e.g., register values, program counter, etc.) for emulator  can be copied to host device  and used to initialize emulator . This may be particularly useful when host computing device  and host computing device  share a common ISA that is different than the ISA for application .","In the manner described above, application  can seamlessly transition across different ISA's and host operating systems in mid-execution. Note that, in some implementations, host computing device  can be preconfigured with precompiled binaries for guest OS . This can reduce the amount of time it takes for application  to be migrated.","Method Implementations",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 7","b":["700","100","700"]},"A request to start an application can be received at block . For example, OS virtualization monitor  can receive a request to run an application such as application , , , and\/or .","Application metadata can be checked at block . For example, OS VM  can check a manifest associated with application  to determine what ISA and\/or operating system application  is configured to run. In some implementations, the application manifest can be written in a markup language such as extensible markup language (\u201cXML\u201d).","If the application manifest indicates that the application is in the host ISA and is configured to run on the host operating system, method  can move to block . At block , the application can run directly on the host OS without an emulator. For example, OS VM  can pass the application to host OS . Host OS  can create a new execution context and run the application directly within the context. This configuration is generally illustrated by execution context  in .","If the application manifest indicates that the application is in the host ISA but is configured to run on a different operating system than the host OS, method  can move to block . At block , the appropriate guest OS is loaded into an execution context with the application. Next, at block , the application is executed in the execution context with the guest OS. This configuration is generally illustrated by execution context  in .","If the application manifest indicates that the application is in a different ISA than the host ISA and is also configured to run on a different operating system than the host OS, method  can move to block . At block , the appropriate emulator is loaded into an execution context. Next, at block , the appropriate guest OS is loaded into the execution context with the emulator. Next, at block , the application can run on the guest OS in the guest ISA in the execution context with the emulator and the guest OS. This configuration is generally illustrated by execution contexts  and  in .",{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 8","b":["800","100","800"]},"A request to load a file is received at block . For example, emulator  can receive a request from application  and\/or guest OS  to load a DLL or other binary file at runtime. The request can include one or more instructions in the guest ISA.","A translation table is checked at decision block . For example, emulator  can check translation table  using the guest ISA address of the file that application  and\/or guest OS  is requesting to load. This enables emulator  to see if the file has already been loaded into memory, e.g., execution context .","If the file has already been compiled into the host ISA and loaded into memory, method  moves to block . At block , the file is in memory and ready to execute.","If the file has not yet been loaded (e.g., has no corresponding host ISA address in translation table ) and has yet to be compiled (e.g., a compiled version is not available in storage), method  moves to block . At block , the method waits to compile the file until the file is executed. For example, in the case of a .dll file, the method can wait until at least one function from the .dll is called and then compile the file with just-in-time compiler  and\/or interpreter .","If the file has already been compiled but has not yet been loaded (e.g., a compiled binary is available in storage but the file has no corresponding host ISA address in translation table ), method  moves to block . At block , the file is loaded into memory. Next, at block , the table is updated with the address where the compiled host ISA version of the file is loaded. Next, at block , the file is ready to execute.",{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 9","b":["900","100","900"]},"A request to execute code is received at block . For example, emulator  can receive a request from application  and\/or guest OS  to execute code at runtime. The request can include one or more instructions in the guest ISA.","A translation table is checked at decision block . For example, emulator  can check translation table  using the guest ISA address of the code that application  and\/or guest OS  is executing. Emulator  can thus determine whether the code that will execute is included in a file that has already been loaded into memory.","If the code has already been loaded into memory, method  moves to block . At block , the code is executed.","If the code has not been loaded and just-in-time compiling is not supported or otherwise not being used, method  moves to block . At block , the code is interpreted into the host ISA. At block , the interpreted code is executed.","If the code has not yet been loaded into memory and just-in-time compiling is supported, method  moves to block . At block , the code that will be executed is compiled into the host ISA and loaded into memory. Next, at block , the translation table is updated to reflect the loaded binary is loaded in memory. Next, at block , the code is executed.","Note that the above discussion is largely illustrated at a file level of granularity. In other words, translation table  includes host ISA addresses for individual .dll files. However, note that each file can include multiple functions as well as data. In some implementations, more refined granularities can be used. For example, addresses of each function in a file can be tracked individually rather than tracking the file as a whole.","Although techniques, methods, devices, systems, etc., pertaining to the above implementations are described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described. Rather, the specific features and acts are disclosed as exemplary forms of implementing the claimed methods, devices, systems, etc."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings illustrate implementations of the concepts conveyed in the present document. Features of the illustrated implementations can be more readily understood by reference to the following description taken in conjunction with the accompanying drawings. Like reference numbers in the various drawings are used wherever feasible to indicate like elements. Further, the left-most numeral of each reference number conveys the figure and associated discussion where the reference number is first introduced.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIGS. 1 and 5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4A-4C"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 7-9"}]},"DETDESC":[{},{}]}
