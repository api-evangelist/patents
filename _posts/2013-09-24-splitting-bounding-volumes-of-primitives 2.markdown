---
title: Splitting bounding volumes of primitives
abstract: A system, method, and computer program product are provided for splitting primitives. A plurality of primitives is received for a scene and a pre-determined plane that intersects the scene is identified. Bounding volumes of the plurality of primitives that are intersected by the pre-determined plane are split, where a bounding volume that encloses each intersected primitive of the plurality of primitives is split into a first bounding volume and a second bounding volume at an intersection of the bounding volume and the pre-determined plane.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09547932&OS=09547932&RS=09547932
owner: NVIDIA Corporation
number: 09547932
owner_city: Santa Clara
owner_country: US
publication_date: 20130924
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CLAIM OF PRIORITY","FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","High-Quality BVH Construction Through Treelet Restructuring","Splitting Bounding Volumes of Primitives","Processing System"],"p":["This application claims the benefit of U.S. Provisional Application No. 61\/833,411, filed Jun. 10, 2013, the entire contents of which is incorporated herein by reference.","The present invention relates to graphics processing, and more particularly to splitting bounding volumes of primitives.","To promote high efficiency processing of graphics primitives, large primitives may be subdivided into a plurality of smaller primitives prior to construction of a high-quality bounding volume hierarchy (BVH). High-quality BVHs are essential for performing efficient ray tracing on a graphics processing unit (GPU). One conventional technique splits bounding boxes of triangle primitives along a longest axis of the bounding box if the surface area of the bounding box exceeds a pre-defined threshold as described by Ernst and Greiner [2007]. A similar scheme to split triangle primitive edges based on the volume of the axis-aligned bounding boxes of the triangle primitives is proposed by Dammertz and Keller [2008]. However, neither of these techniques has been proven to reliably improve ray tracing performance in practice. Instead, for some scenes, the ray tracing performance decreases. Another problem is that the amount of memory needed to store the data generated when the bounding boxes are split is difficult to predict. Thus, there is a need for addressing the issue of splitting bounding boxes of primitives to improve ray tracing performance and\/or other issues associated with the prior art.","A system, method, and computer program product are provided for splitting bounding volumes of primitives. A plurality of primitives is received for a scene and a pre-determined plane that intersects the scene is identified. Bounding volumes of the plurality of primitives that are intersected by the pre-determined plane are split, where a bounding volume that encloses each intersected primitive of the plurality of primitives is split into a first bounding volume and a second bounding volume at an intersection of the bounding volume and the pre-determined plane.","Rather than splitting primitive bounding boxes based on surface area or volume, bounding volumes of primitives are split based on pre-determined split planes. The split planes may be spatial split planes that are aligned with an axis of a three-dimensional scene space defined by (x,y,z) coordinates. For example, a split plane may be aligned relative to the plane formed by the x and z axes, the plane formed by the x and y axes, or the plane formed by the y and z axes. The bounding volume of each primitive may be split prior to construction of a BVH to improve ray tracing performance that relies on the BVH. The pre-determined split planes may correspond to partitioning planes used to construct the BVH, so that, when a hierarchical tree data structure is constructed from the resulting bounding volumes, the overlap between sibling nodes is effectively minimized. The number of splits that are performed may be bounded so that the amount of memory needed to store the data generated during the splitting is known. The splits may be performed recursively for bounding volumes of primitives that are intersected by one or more pre-determined planes. The splitting technique using pre-determined split planes is described in detail in conjunction with -F, A, and B.","A low-quality hierarchical tree data structure may be constructed, and the node topology of the low-quality hierarchical tree data structure may be restructured, at least in part, in a parallel manner to produce a higher-quality hierarchical tree data structure. In one embodiment, the hierarchical tree data structure is a bounding volume hierarchy (BVH) that may be used to perform ray tracing. A restructured BVH is capable of performing ray casts significantly faster and may be produced at interactive rates. The interactive rates are needed to support application programs for product and architectural design and movie rendering that require high quality images at interactive rates.","In contrast, conventional techniques either generate low-quality BVHs at interactive rates or high-quality BVHs at non-interactive rates. The restructured BVH that is produced achieves \u02dc96% of the ray tracing performance compared to a very high-quality BVH constructed using a conventional CPU-based top-down construction method. However, the conventional CPU-based top-down construction technique cannot typically be performed at interactive rates. Techniques for constructing a low-quality BVH may be much faster compared with the conventional CPU-based top-down construction technique, but the low-quality BVH is typically only capable of producing 67% of the ray tracing performance compared to the conventional CPU-based top-down construction technique. In contrast, using the techniques described further herein, the time needed to construct the restructured BVH is only 2-3\u00d7 compared to the fastest BVH construction techniques and the ray tracing performance of the restructured BVH is 96% of the highest-quality BVH.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 1","b":["100","105","110"]},"At step , the treelets are restructured to produce an optimized hierarchical tree data structure. As a result, the topology of the hierarchical tree data structure is modified. In one embodiment, multiple treelets can be processed in parallel, and it is also possible to employ multiple threads to process a given treelet. At step , post-processing is performed on the optimized hierarchical tree data structure to collapse subtrees into leaf nodes to prepare the optimized hierarchical tree data structure for ray-tracing operations. In one embodiment, steps  and  may be repeated multiple times to produce the optimized hierarchical tree data structure.","More illustrative information will now be set forth regarding various optional architectures and features with which the foregoing framework may or may not be implemented, per the desires of the user. It should be strongly noted that the following information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described.","Ray tracing performance is most commonly estimated using the SAH model, first introduced by Goldsmith and Salmon in 1987 and later formalized by MacDonald and Booth in 1990. The classic approach for constructing BVHs is based on greedy top down partitioning of primitives that aims to minimize the SAH cost at every step. The SAH cost of a given acceleration structure is defined as the expected cost of tracing a non-terminating random ray through the scene:",{"@attributes":{"id":"p-0034","num":"0033"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"msub":{"mi":["C","i"]},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":["n","I"],"mo":"\u2208"},"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mfrac":{"mrow":[{"mi":"A","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},{"mi":"A","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"root"}}]}}},{"msub":{"mi":["C","l"]},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":["l","L"],"mo":"\u2208"},"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mfrac":{"mrow":[{"mi":"A","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"l"}},{"mi":"A","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"root"}}]}}},{"msub":{"mi":["C","t"]},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":["l","L"],"mo":"\u2208"},"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mfrac":{"mrow":[{"mi":"A","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"l"}},{"mi":"A","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"root"}}]},"mo":"\u2062","mrow":{"mi":"N","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"l"}}}}}],"mo":["+","+"]}},{"mrow":{"mo":["(",")"],"mn":"1"}}]}}}},"br":{},"sub":["i ","l ","t ","i","l","t"]},"During construction of a BVH using the conventional technique by MacDonald and Booth 1990, the primitives at each node are classified to either side of an axis-aligned split plane according to the centroids of their axis-aligned bounding boxes (AABBs). The split plane is chosen by evaluating the SAH cost of the resulting child nodes for each potential plane, and selecting the one that results in the lowest cost. Leaf nodes are created when the SAH cost can no longer be improved through partitioning, i.e., the benefit of creating a new internal node is outweighed by its cost. As previously explained, the technique is slow and while a high-quality BVH may be constructed, the construction time is too long for interactive applications.","Local tree rotations (i.e., node swaps) are proposed by Kensler in 2008 to improve the SAH cost of an existing BVH. Kensler's technique modifies the set of children (i.e., child nodes) of at most two nodes of the tree for each tree rotation. Recently, an alternative algorithm based on iteratively removing nodes from the tree and inserting them back at optimal locations has been described by Bittner et al. in 2013. Since there are a large number of options for modifying the tree at each step, the algorithm is able to improve the quality significantly before getting stuck. However, since the technique is fundamentally serial, it is unclear whether the technique can be made to run at interactive rates. In the technique, a single removal-reinsertion operation may modify the set of children of at most three nodes of the tree.","A new approach for constructing high-quality BVHs as quickly as possible begins with an existing low-quality BVH and modifies the low-quality BVH to substantially equal the quality of a BVH constructed using conventional CPU-based top-down construction techniques. Instead of looking at individual nodes, neighborhoods of nodes referred to as treelets are formed and restructured. While the treelet constitutes a valid binary tree on its own, the treelet does not necessarily have to extend all the way down to the leaf nodes of the BVH. In other words, the children of every internal node of the treelet must be contained in the treelet, but a treelet leaf can act as a representative of an arbitrarily large subtree.","The restructuring technique repeatedly forms treelets for each root node and restructures the nodes within each treelet to minimize the overall SAH cost. The treelet leaf nodes and associated subtrees are kept intact during the restructuring, which means that the contents of the subtrees are not relevant as far as the optimization is concerned\u2014only properties of the treelet leaf nodes themselves (e.g., AABBs) are considered during the restructuring. Thus, the processing of each treelet is a perfectly localized operation, so that multiple treelets may be restructured in parallel.","Restructuring a given treelet can be viewed as discarding the existing internal nodes of the treelet and then constructing a new binary tree for the same set of treelet leaf nodes. A treelet internal node has two child nodes that may each be either a treelet internal node or a treelet leaf node. A treelet leaf node can represent a subtree including at least two child nodes, as described further herein, or a treelet leaf node may be an actual leaf node that does not have any child nodes. As the number of treelet leaf nodes remains unchanged, there will also be the same number of treelet internal nodes in the new treelet. The only thing that really changes, in addition the connectivity of the nodes, is the set of bounding volumes stored by the treelet internal nodes. In other words, restructuring provides a mechanism to reduce the surface area of the treelet internal nodes, which in turn translates directly to reducing the overall SAH cost of the BVH (equation 1).","Finding the optimal node topology for a given treelet is believed to be a non-deterministic polynomial-time (NP)\u2014hard problem, and the best known algorithms are exponential with respect to n. However, in practice, a high-quality BVH may be generated from a low-quality BVH using small size treelets. For example, n=7 provides (2n\u22123)!!=10395 (k!! denotes the double factorial, defined for odd k as k*(k\u22122)*(k\u22124)* . . . *3*1) unique ways for restructuring each treelet, and there are also many ways of forming the treelets. A small size treelet of n\u22675 provides enough freedom during restructuring to prevent the optimization of the BVH from getting stuck prematurely.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 2A","b":["200","260","210","205","206","208","212","207","209","215","217","260","260","227","229","225","243","232","244","250","236","237","239","233","232","232","245","247","244","244","253","255","250","250","210","220","224","230","240","242","260"]},"After the tree  representing a BVH is constructed, the treelet  is formed, and the topology of the treelet  and additional treelets may be restructured to produce the tree shown in . The first step is to receive a treelet root node then through a \u201cgrowing\u201d process, the treelet leaf nodes are identified (e.g., internal, actual leaves, subtrees) to form a treelet, such as the treelet . Then, in a second step, the treelet may be restructured to produce a restructured treelet, as shown in .","To form the treelet , the root node  of the treelet  is identified and the child nodes  and  of the treelet root node  are designated as initial treelet leaves. For the purpose of treelet restructuring, the surface area of a treelet's internal nodes may provide a good indicator of the potential for reducing the SAH cost. Therefore, a goal of the treelet formation is to produce a treelet that maximizes the total surface area of the internal nodes. The formation may start with a small treelet including a treelet root and two treelet leaf nodes. The treelet is then grown iteratively, by choosing the treelet leaf node with the largest surface area and turning the chosen treelet leaf node into a treelet internal node. The treelet leaf node is converted into an internal node by removing the chosen treelet leaf node from the set of treelet leaf nodes and using the two children of the chosen node as new treelet leaf nodes. When this process is repeated, 5 iterations are needed to reach n=7.","The treelet  is grown by the following sequence of steps:\n\n",{"@attributes":{"id":"p-0045","num":"0050"},"figref":"FIG. 2B","b":["200","260","260","230","220","224","240","242","260","225","227","229","232","244","243","250","260"]},"Descendants of a treelet leaf node are kept intact, even when the location of the leaf node in the treelet  changes. For example, the topology of a first subtree  that includes the treelet leaf node  and the descendant nodes , , , and  is kept intact. Similarly, the topology of a second subtree  that includes the treelet leaf node  and the descendant nodes  and  is kept intact. The topology of a third subtree  that includes the treelet leaf node  and the descendant nodes  and  is also kept intact.",{"@attributes":{"id":"p-0047","num":"0052"},"figref":"FIG. 2C","b":["200","260","260","210","230","220","240","224","242"]},"For example, as shown in , the set of children for the treelet root node  includes treelet internal nodes  and . In , the set of children for the treelet root node  includes treelet internal nodes  and . As shown in , the set of children for the treelet internal node  includes treelet leaf node  and treelet internal node  and in , the set of children for the treelet internal node  includes treelet internal nodes  and . As shown in , the set of children for the treelet internal node  includes treelet leaf node  and treelet internal node  and in , the set of children for the treelet internal node  includes treelet internal nodes  and . As shown in , the set of children for the treelet internal node  includes treelet leaf node  and treelet internal node  and in , the set of children for the treelet internal node  includes treelet leaf nodes  and . As shown in , the set of children for the treelet internal node  includes treelet leaf nodes  and  and in , the set of children for the treelet internal node  includes treelet leaf nodes  and . As shown in , the set of children for the treelet internal node  includes treelet leaf nodes  and  and in , the set of children for the treelet internal node  includes treelet leaf nodes  and .","The order of the treelet leaf nodes in the restructured treelet shown in  is changed compared with the initial treelet  shown in . For example, the depth-first order of the treelet leaf nodes in  is , , , , , , and  and the depth-first order of the treelet leaf nodes in  is , , , , , , and .",{"@attributes":{"id":"p-0050","num":"0055"},"figref":"FIG. 3","b":["300","300","300","305"]},"At step , a set of nodes to be used as treelet roots is identified. To identify the roots, the parallel bottom-up traversal algorithm presented by Karras in 2012 may be used. The algorithm works by traversing paths from the hierarchical tree data structure leaf nodes to the root in parallel, using atomic counters to terminate a first execution thread to enter any given node while allowing a second execution thread to proceed. The algorithm guarantees that the nodes are visited in a strict bottom up order: when a particular node is visited during the traversal, all of the node's descendants have already been visited. Therefore, the descendants may be restructured without the danger of other execution threads trying to access the descendants during the restructuring. The bottom-up traversal also provides a very natural way to propagate SAH costs of each node up the tree.","Step  includes steps , , , and . Step  may be performed by the processor in parallel to simultaneously form and restructure multiple treelets. At steps  and , the processor forms treelets of node neighborhoods in the hierarchical tree data structure (i.e., BVH), based on the treelet roots identified at step . Treelet formation includes identification of the treelet internal nodes and the treelet leaf nodes, including treelet leaf nodes representing subtrees, of each treelet. In one embodiment, each node of the hierarchical tree data structure is included in at most one of the multiple treelets that may be restructured concurrently.","At steps  and , a treelet and additional treelets are restructured in parallel by the processor to produce an optimized hierarchical tree data structure. The restructuring operates by first constructing a new binary tree (i.e., a restructured treelet) for the same set of treelet leaves. The new binary tree may replace the original treelet according to a cost function to produce an optimized treelet in the hierarchical data structure. The goal of the optimization is to minimize the SAH cost of the final tree that is produced by the optimization. Therefore, the new binary tree replaces the original treelet if a cost function (e.g., SAH cost) indicates that the optimized treelet improves the hierarchical tree data structure. Otherwise, the original treelet is retained. At step , the processor determines if the optimization of each treelet in the hierarchical tree data structure is complete, and, if so, the processor proceeds to step . The completion at step  may be based on, for example, a pre-defined number of iterations or changes in a cost metric of the hierarchical tree data structure.","Because the number of primitives in the leaf nodes of the hierarchical tree data structure is known to have a significant impact on ray tracing performance, any individual subtrees within a treelet are collapsed into treelet leaf nodes during the post-processing step .","The SAH cost, C(n) of a given subtree associated with a node may be calculated as the minimum over the two possible outcomes:",{"@attributes":{"id":"p-0056","num":"0061"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"C","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},{"mi":"min","mo":"\u2062","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":[{"mrow":{"mrow":[{"msub":{"mi":["C","i"]},"mo":"\u2062","mrow":{"mi":"A","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}}},{"mi":"C","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["n","l"]}}},{"mi":"C","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["n","r"]}}}],"mo":["+","+"]}},{"mrow":{"mo":["(",")"],"mrow":{"mi":["n","I"],"mo":"\u2208"}}}]},{"mtd":[{"mrow":{"msub":{"mi":["C","t"]},"mo":["\u2062","\u2062"],"mrow":[{"mi":"A","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},{"mi":"N","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}}]}},{"mrow":{"mo":["(",")"],"mrow":{"mi":["n","L"],"mo":"\u2208"}}}]}]}}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"2"}}]}}}},"br":{},"sub":["l ","r "],"b":"305"},"The main benefit of selecting the alternative that yields the lowest SAH cost, is that the processing of leaf nodes and internal nodes is unified so that the same algorithm may be used for optimizing both\u2014moving nodes in the treelets of the intermediate tree effectively enables refinement of the leaf nodes of the final hierarchical tree data structure that is produced by the optimization.","In one embodiment, the optimized hierarchical tree data structure that is produced should be readily usable with existing ray tracing kernels, such as the ray tracing kernel described by Aila et al. in 2012, the final post-processing stage performs several operations. At step , the post-processing should identify the subtrees to be collapsed into leaf nodes, collect the triangles of the identified subtrees into linear lists, and output the linear lists. In one embodiment, the triangles are represented in a format suitable for processing using Woop's intersection test. The subtrees may be identified by looking at the value of C(n) for each node. If the value corresponds to the second case in Equation 2, but the same is not true for the ancestors of n, the node is collapsed into a leaf node. The collapsing operation may be accomplished by traversing the subtree to identify the individual triangles, and then using an atomic counter to place them in the output array to produce the linear list.","Several different methods may be used to find the optimal topology for the nodes in the treelet for given treelet root during the optimization process. A na\u00efve algorithm is described first, and then incremental refinements are made to the na\u00efve algorithm to arrive at an efficient GPU implementation. Throughout the following description, a fixed treelet size of n=7 leaf nodes is used to illustrate various algorithmic details in concrete terms. However, in other embodiments, different values of n may be used, including values that are smaller or larger than 7.",{"@attributes":{"id":"p-0060","num":"0065"},"figref":["FIG. 4A","FIG. 3"],"b":["400","330","320","325","330","330","300"]},"As shown in , a recursive function ConstructOptimalTree may be used to implement the function. The example code  constructs the optimal binary tree (T) that minimizes the SAH cost (c) for a given set of treelet leaf nodes (S). Each way of partitioning the leaf nodes is tried, so that some of the leaf nodes (P) are assigned to the left subtree of the root node while the rest of the leaf nodes (S\\P) are assigned to the right subtree. The subtrees are, in turn, constructed by repeating the same process recursively.","The function ConstructOptimalTree takes set of treelet leaf nodes S as a parameter and returns the optimal tree Talong with its SAH cost c. If S consists of a single leaf, the function looks up the associated SAH cost and returns (lines 3-6). Otherwise, the function tries each potential way of partitioning the leaf nodes into two subsets (line 9). A partitioning is represented by set P that indicates which leaf nodes should go to the left subtree of the root; the rest will go the right subtree. For P to be valid, neither subtree can be empty (line 10).","For each partitioning, the algorithm proceeds to construct the subtrees in an optimal way by calling itself recursively (lines 12-13). It then calculates the SAH cost of the full tree obtained by merging the subtrees (lines 15-16). This corresponds to the first case of Equation 2, where the AABB of the root is calculated as the union of the AABBs in S. The algorithm maintains the best solution found so far in Tand c(line 8), and replaces the best solution with the current solution if the current solution results in an improved SAH cost (lines 18-21).","In the end, ccorresponds to the lowest SAH cost that can be obtained by creating at least one internal node, but it does not account for the possibility of collapsing the entire subtree into a single leaf node. As per the policy of maintaining one primitive per leaf node throughout the optimization, the collapsing is not performed until the final post-processing stage. However, the possibility of collapse is accounted for by evaluating the second case of Equation 2 at the end, and returning whichever of the two costs is lower (lines 25-28).","While the na\u00efve algorithm shown in  is straightforward, it may be inefficient. For instance, n=7 results in a total of 1.15 million recursive function calls and an even larger number of temporary solutions that are immediately discarded afterwards. To transform the algorithm into a more efficient form that produces an identical result, the following three important modifications may be made:\n\n","The three modifications lead to a bottom-up dynamic programming approach. Because solutions to all subproblems are needed in order to solve the full problem, the small subproblems are solved first and the results are used to solve the larger problems. Given that the solution for subset S depends on the solutions for all P\u2282S, a natural way to organize the computation is to loop over k=2 . . . n and consider subsets of size k in each iteration. Each subset of size k is a subproblem that is solved. In this manner, every iteration depends on the results of the previous iteration, but there are no dependencies within the iterations themselves.",{"@attributes":{"id":"p-0067","num":"0075"},"figref":["FIG. 4B","FIG. 3"],"b":["420","330","420","400"],"o":["s","p"]},"The algorithm handles subsets corresponding to individual leaf nodes as a special case (lines 6-8). It then proceeds to optimize the remaining subsets in increasing order of size (lines 10-11). The optimal SAH cost of each subset is stored in array cand the corresponding partitioning is stored in an array, . Keeping track of the different partitionings of the leaf nodes avoids the need to construct temporary trees\u2014once all subsets have been processed, reconstructing the optimal tree is a matter of backtracking the choices recursively starting from [2\u22121].","Processing a given subset is very similar to the naive algorithm. Each possible way of partitioning the leaf nodes (lines 14-17) is tried, maintaining the best solution found so far in temporary variables cand  (line 13). Then, the final SAH cost is calculated and the results are recorded in cand (lines 19-21). As an optimization, it may be observed that the first term of the SAH cost, C\u00b7a[], does not actually depend on which partitioning is chosen. Therefore, the first term of the SAH cost is omitted from the computation in the inner loop (line 15), and is instead included in the final cost (line 20).","Most of the computation happens in the inner loop (lines 14-17) of the example code . For each iteration of the loop two values are looked up from cand the temporary variables c and  are updated. The complement of , corresponding to S\\P, may be obtained conveniently through a logical XOR operation, because  can only contain bits that are also set in  (line 15). Looping over the different partitionings of the leaf nodes entails enumerating all integers that have the property that they only contain bits that are set in  (line 14). However, in addition to excluding 0 and , partitionings whose complements have already been tried should also be excluded. Complement partitionings result in mirror images of the same trees, and are thus irrelevant for the purposes of minimizing the SAH cost.",{"@attributes":{"id":"p-0071","num":"0079"},"figref":"FIG. 4C","b":["440","440","420"],"sup":"k-1"},"The idea of the example code  is to clear the lowest bit of  and then step through the bit combinations of the resulting value . Clearing the lowest bit (line 1) means that the first leaf represented by  is assigned to the right subtree of the root, which is enough to avoid enumerating complements of the same partitionings of the leaf nodes. The successor of a given value is determined by utilizing the borrowing rules of integer subtraction in two's complement arithmetic (line 6). The initial value of  can be thought of as being the successor of zero (line 2). For a subset of size k, the loop executes 2\u22121 iterations in total, after which  wraps back to zero.","As previously explained, splitting the bounding volumes of primitives may improve ray tracing performance. The splitting operations may be performed before construction of a BVH or during construction of the BVH. Dynamic splitting during BVH construction is a robust approach, and typically achieves high ray tracing performance. An approach for generating a split bounding volume hierarchy (SBVH), proposed independently by Stich et al. [2009](SBVH) and Popov et al. [2009], is to incorporate triangle splitting directly into a top-down BVH construction algorithm. SBVH, which yields among the highest ray tracing performance to date, works by considering spatial splits in addition to conventional partitioning of triangles. Spatial splits correspond to duplicating triangles that intersect a given split plane, so that each resulting triangle reference lies strictly on either side of the plane. The choice between spatial splits and triangle partitioning is made on a per-node basis according to which alternative is the most effective in reducing the surface area heuristic (SAH) cost. However, dynamic splitting approaches, such as SBVH, rely on a specific kind of top-down construction method that runs well only on a CPU. While GPU-accelerated construction techniques can offer significant improvements in BVH construction time compared with the CPU-based construction techniques, incorporating dynamic splitting into GPU-accelerated construction techniques is challenging.","Pre-process splitting, on the other hand, is GPU-friendly and can be used in conjunction with any BVH construction technique. However, conventional pre-process splitting techniques suffer from the difficulty of being able to predict how a given split decision will affect the BVH that is constructed. As a consequence, conventional techniques require considerable manual effort to select the right parameters for each particular scene, and the conventional techniques can decrease ray tracing performance if the number of splits is too high.",{"@attributes":{"id":"p-0075","num":"0083"},"figref":"FIG. 5A","b":["500","500","500","502"]},"In the context of the following description, at least one pre-determined plane may be a spatial split plane that is aligned with two axes of a three-dimensional scene space defined by (x,y,z) coordinates. For example, a pre-determined plane may be aligned with the x and z axes, the x and y axes, or the y and z axes. The pre-determined plane may correspond to a partitioning plane used to construct the BVH, so that nodes of a hierarchical tree data structure are associated with bounding volumes that do not overlap the partitioning plane. In other embodiments, the scene may an N-dimensional scene where N is an integer greater than zero. The resulting set of bounding volumes that is produced by the splitting operation is used as the input for the BVH construction. Steps , , , and  are performed as previously described in conjunction with .","Splitting large triangles is important for achieving high ray tracing performance in scenes where the distribution of triangle sizes is non-uniform. In prior art techniques, each axis-aligned bounding box (AABB) is associated with a pointer to the triangle from which the AABB originated. Therefore, some triangles may be referenced by multiple AABBs of the BVH. The triangles themselves are not modified.",{"@attributes":{"id":"p-0078","num":"0086"},"figref":["FIG. 5B","FIG. 5B"],"b":["505","503","503","505","505","504"]},{"@attributes":{"id":"p-0079","num":"0087"},"figref":["FIG. 5C","FIG. 5C"],"b":["505","503","506","507","503","506","507","506","507","503"]},{"@attributes":{"id":"p-0080","num":"0088"},"figref":["FIG. 5D","FIG. 5C","FIG. 5E","FIG. 5D","FIGS. 5B, 5C, 5D, and 5E"],"b":["508","509","510","511","506","507","520","521","522","523","524","525","526","527","508","509","510","511"]},{"@attributes":{"id":"p-0081","num":"0089"},"figref":["FIG. 6A","FIG. 7A","FIG. 7B"],"b":["600","600","600","605","610","615","605","650"]},"The primitive splitting technique performed using the method  reduces node overlap by splitting a large group of primitives using the same pre-determined split plane. For example in the case of method , by virtue of constructing an initial BVH using spatial median partitioning, the split planes that are going to be the most relevant are known. For example the root node of the initial BVH partitions the scene into two equal halves according to the spatial median of its x-axis. When a bounding volume of a given primitive is intersected by a spatial median plane used to construct the BVH, the two children of the root node will overlap. Since the nodes near the root are likely to have a significant impact on the ray tracing performance, it is beneficial to avoid overlap of bounding volumes between two or more sibling nodes.",{"@attributes":{"id":"p-0083","num":"0091"},"figref":["FIG. 6B","FIG. 6B"],"b":["620","625","620","625","620","625","620","620","625","621","622","623","625","620","625","625"]},{"@attributes":{"id":"p-0084","num":"0092"},"figref":["FIG. 6C","FIG. 6C"],"b":["620","621","622","623","625","635","645","635","645","625","622","625","625","625","635","645"]},"Bounding volumes of the primitives , , and  are split and each bounding volume that is generated references the corresponding primitive , , and . Splitting the primitive  is described in detail in conjunction with . When a BVH is constructed, a first subtree whose root corresponds to the bounding volume  references the primitives that are at least partially included within the bounding volume  and a second subtree whose root corresponds to the bounding volume  references the primitives that are at least partially included within the bounding volume . The primitives , , and  are referenced by both the first and second subtrees.",{"@attributes":{"id":"p-0086","num":"0094"},"figref":["FIG. 6D","FIG. 6B"],"b":["620","625","642","644","646","640","648","620","625","640","642","644","646","648"]},"The set of pre-determined planes may correspond to the spatial median planes. In one embodiment, when a given primitive that is intersected by multiple pre-determined spatial median planes, the most important pre-determined spatial median plane is identified and used to split the bounding volume of the primitive. For example, for a scene extending over the range [0,1] along each axis (x,y,z), the spatial median planes in the set of pre-determined planes are given by x=j\u00b72where i,j\u03b5 and similarly for y and z. The value of i is negative, and values closer to zero correspond to more important planes. In practice, an efficient way to choose the split plane is to form two Morton codes based on the minimum and maximum coordinates of the bounding volume, and then find the highest bit that differs between them, as described by Karras [2012]. In one embodiment, the spatial median planes in the set of pre-determined planes correspond to x=0.5, y=0.5, z=0.5, then x=0.25, x=0.75, y=0.25, . . . , then x=0.125, x=0.375, and so on. Because neighboring primitives are likely to intersect the same spatial median planes in the set of pre-determined planes, splits that are performed for a given primitive are likely to be performed for neighboring primitives.","As shown in , the primitive  is intersected by the pre-determined planes  and  and is split by the pre-determined plane  (level 0) before being split by the pre-determined plane  (level 3). The primitive  is intersected by the pre-determined planes , , and  and is split by the pre-determined plane  (level 0) before being split by the pre-determined plane  (level 1) and then being split by the pre-determined plane  (level 2). A pre-determined plane at a lower level is considered more important and is dominant relative to a pre-determined plane at a higher level. Therefore, each time a primitive will be split, the dominant pre-determined plane is identified to perform the split.","As shown in step  of the method  in , after the splits for a scene are distributed among the primitives, each primitive is recursively split.  illustrates a bounding volume  of the primitive  that is split by the pre-determined plane  of , in accordance with one embodiment.  illustrates two bounding volumes  and  that are generated when the primitive  of  is split, in accordance with one embodiment. When more than one split is allocated to the primitive , the bounding volume  and\/or  is also split to generate additional bounding volumes. Splitting the primitive  reduces the size of the bounding volumes that enclose the primitive  so that the number of ray-primitive intersection tests that are performed during ray traversal is reduced, improving ray tracing performance.","The number of splits that are allocated to a primitive in a scene is based on the calculated heuristic priority for the primitive and can be as low as zero. A given primitive should be split if it crosses an important pre-determined plane or if the surface area of the bounding volume of the primitive can be significantly decreased. Therefore, these two factors are combined into the priority calculation that is used to compute a heuristic priority value, p, for each primitive. Because pre-process splitting is fundamentally an underdetermined problem, it is difficult to define the priority in a principled way. However, in one embodiment, the following formula has been found to be robust.\n\n=(\u00b7()),\n\nwhere i is the importance of the dominant spatial median plane intersected by the primitive, Ais the surface area of the original bounding volume, and X and Y are free parameters. In one embodiment, X=2 and Y=\u2153 have been found to produce satisfactory results.\n","To estimate how much the representation of a particular primitive can be improved, the lowest total surface area Aof the representative bounding volumes that can be reached through splitting is calculated. Assuming that the number of splits is taken to the limit, the primitive is essentially represented as a collection of infinitesimal bounding volumes. For any axis-aligned projection (\u00b1x, \u00b1y, \u00b1z), the surface area of a projected triangle equals the sum of surface areas of the corresponding face of the bounding volumes assuming the bounding volumes are AABBs. The total surface area of the bounding volumes may be expressed as A=\u2225d\u00d7d\u2225, where dand dare edge direction vectors of the triangle and \u2225\u00b7\u2225indicates the Lnorm. Each component of the cross product is equal to twice the area of a particular 2D projection. As a consequence, the result essentially represents the sum of 6 such areas, one for each face of the AABB.","Most of the splits should be concentrated on primitives for which both i and A\u2212Aare high. In general, a fairly low value should be used for Y to avoid spending the entire split budget for the scene on a few large primitives in pathological cases. The entire split budget for the scene should not exceed the fixed maximum number of splits that is determined at step  of the method  shown in .","The fixed maximum number of splits, s, may be determined using a parameter \u03b2 using the following equation:\n\n\n\nwhere m is the number of primitives in the scene. Limiting the total number of splits for a scene results in predictable memory consumption, and also avoids the need for dynamic memory allocation for animated scenes.\n","To determine how to distribute the fixed maximum number of splits among the primitives, the heuristic priority pfor a particular primitive is multiplied with an appropriately chosen scale factor D and the result is rounded to compute the number of splits for the primitive, s. In one embodiment, the equation for computing sis:\n\n\u2518.\n\nTo fully utilize the fixed maximum number of splits, D is chosen to be as large as possible while still satisfying \u03a3s\u2266s.\n",{"@attributes":{"id":"p-0095","num":"0103"},"figref":["FIG. 7A","FIG. 6A","FIG. 7A","FIG. 7A"],"b":["615","720"],"sub":["min ","max","min ","max ","min ","min","min ","max ","min","max","t ","max","min","max","min","t"],"br":[{},{}],"in-line-formulae":[{},{},{},{}],"i":["D","=s","\/\u03a3p","D","=D","\u00b7s","\/\u03a3\u2514D","\u00b7p"]},"At step , an average of the range of the scaling factor D is calculated, where D=(D+D)\/2. At step , a value equal to the total number of splits that will be performed based on distributing the splits using Dand the priority values is computed. In one embodiment, the value may be computed as \u03a3\u2514D\u00b7p\u2518. At step , the processor determines if the value is greater than fixed maximum number of splits s. When the value is not greater than s, at step , Dis set to D. When the value is greater than s, at step , Dis set to D.","At step , the processor determines if the computation of D is complete. In one embodiment, six rounds of bisection are performed to compute D so that the number of splits performed is within 1% of s. When the computation of D is complete, D is set equal to D. At step , the processor distributes the total number of splits to the primitives by allocating a number of splits to each primitive in the scene. The number of splits allocated to each primitive is based on D and the computed priority for the primitive.","The splits may be performed by maintaining a set of split tasks, each specifying how many times a particular bounding volume for a primitive should be split. To process a task, the bounding volume is split according to a heuristically chosen pre-determined plane. The remaining splits allocated to a primitive are then distributed amongst the two resulting bounding volumes proportional to the lengths of the longest axes of the two resulting bounding volumes. Denoting these lengths with wand wand the original number of splits allocated to the primitive with s,",{"@attributes":{"id":"p-0099","num":"0107"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["s","a"]},"mo":"=","mrow":{"mo":["\u230a","\u230b"],"mrow":{"mfrac":{"mrow":[{"mrow":{"mo":["(",")"],"mrow":{"mi":"s","mo":"-","mn":"1"}},"mo":"\u2062","msub":{"mi":["w","a"]}},{"msub":[{"mi":["w","a"]},{"mi":["w","b"]}],"mo":"+"}]},"mo":"+","mrow":{"mn":["1","2"],"mo":"\/"}}}}}},"br":{},"sub":["b","a ","a ","b"]},{"@attributes":{"id":"p-0100","num":"0108"},"figref":["FIG. 7B","FIG. 6A","FIG. 7B","FIG. 7B"],"b":["650","755","760","765"]},"At step , the primitive is split by splitting a bounding volume that encloses the primitive using the selected pre-determined plane to generate two bounding volumes that enclose the primitive. At step , bounding volumes resulting from the split are determined. At step , any remaining splits are distributed among the bounding volumes resulting from the split. The processor then returns to step  for each resulting bounding volume in a recursive fashion, to determine if another split will be performed. The steps , , , , and  are repeated until the remaining number of splits allocated to the primitive is reduced to zero to recursively split the primitive.","The primitive splitting technique reduces node overlap by splitting a large group of primitives using the same pre-determined split plane. Bounding volumes that are intersected by multiple pre-determined split planes are recursively split by the multiple pre-determined split planes according to the relative importance of the multiple pre-determined split planes. Therefore, node overlap is avoided for the nodes corresponding to the bounding volumes that are closest to the root node and have a greater impact on the ray tracing performance.",{"@attributes":{"id":"p-0103","num":"0111"},"figref":["FIG. 8","FIG. 9"],"b":["800","800","800","850","850","850"]},"In one embodiment, the PPU  includes an input\/output (I\/O) unit  configured to transmit and receive communications (i.e., commands, data, etc.) from a central processing unit (CPU) (not shown) over the system bus . The I\/O unit  may implement a Peripheral Component Interconnect Express (PCIe) interface for communications over a PCIe bus. In alternative embodiments, the I\/O unit  may implement other types of well-known bus interfaces.","The PPU  also includes a host interface unit  that decodes the commands and transmits the commands to the grid management unit  or other units of the PPU  (e.g., memory interface ) as the commands may specify. The host interface unit  is configured to route communications between and among the various logical units of the PPU .","In one embodiment, a program encoded as a command stream is written to a buffer by the CPU. The buffer is a region in memory, e.g., memory  or system memory, that is accessible (i.e., read\/write) by both the CPU and the PPU . The CPU writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit  provides the grid management unit (GMU)  with pointers to one or more streams. The GMU  selects one or more streams and is configured to organize the selected streams as a pool of pending grids. The pool of pending grids may include new grids that have not yet been selected for execution and grids that have been partially executed and have been suspended.","A work distribution unit  that is coupled between the GMU  and the SMs  manages a pool of active grids, selecting and dispatching active grids for execution by the SMs . Pending grids are transferred to the active grid pool by the GMU  when a pending grid is eligible to execute, i.e., has no unresolved data dependencies. An active grid is transferred to the pending pool when execution of the active grid is blocked by a dependency. When execution of a grid is completed, the grid is removed from the active grid pool by the work distribution unit . In addition to receiving grids from the host interface unit  and the work distribution unit , the GMU  also receives grids that are dynamically generated by the SMs  during execution of a grid. These dynamically generated grids join the other pending grids in the pending grid pool.","In one embodiment, the CPU executes a driver kernel that implements an application programming interface (API) that enables one or more applications executing on the CPU to schedule operations for execution on the PPU . An application may include instructions (i.e., API calls) that cause the driver kernel to generate one or more grids for execution. In one embodiment, the PPU  implements a SIMD (Single-Instruction, Multiple-Data) architecture where each thread block (i.e., warp) in a grid is concurrently executed on a different data set by different threads in the thread block. The driver kernel defines thread blocks that are comprised of k related threads, such that threads in the same thread block may exchange data through shared memory. In one embodiment, a thread block comprises 32 related threads and a grid is an array of one or more thread blocks that execute the same stream and the different thread blocks may exchange data through global memory.","In one embodiment, the PPU  comprises X SMs (X). For example, the PPU  may include 15 distinct SMs . Each SM  is multi-threaded and configured to execute a plurality of threads (e.g., 32 threads) from a particular thread block concurrently. Each of the SMs  is connected to a level-two (L2) cache  via a crossbar  (or other type of interconnect network). A color blend unit  is configured to perform blend functions, such as the blend function used to accumulate shaded sample color values into a color buffer that may be stored in the memory  and cached in the L2 cache .","The L2 cache  is connected to one or more memory interfaces . Memory interfaces  implement 16, 32, 64, 128-bit data buses, or the like, for high-speed data transfer. In one embodiment, the PPU  comprises U memory interfaces (U), where each memory interface (U) is connected to a corresponding memory device (U). For example, PPU  may be connected to up to 6 memory devices , such as graphics double-data-rate, version 5, synchronous dynamic random access memory (GDDR5 SDRAM).","In one embodiment, the PPU  implements a multi-level memory hierarchy. The memory  is located off-chip in SDRAM coupled to the PPU . Data from the memory  may be fetched and stored in the L2 cache , which is located on-chip and is shared between the various SMs . In one embodiment, each of the SMs  also implements an L1 cache. The L1 cache is private memory that is dedicated to a particular SM . Each of the L1 caches is coupled to the shared L2 cache . Data from the L2 cache  may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs .","The PPU  may be included in a desktop computer, a laptop computer, a tablet computer, a smart-phone (e.g., a wireless, hand-held device), personal digital assistant (PDA), a digital camera, a hand-held electronic device, and the like. In one embodiment, the PPU  is embodied on a single semiconductor substrate. In another embodiment, the PPU  is included in a system-on-a-chip (SoC) along with one or more other logic units such as a reduced instruction set computer (RISC) CPU, a memory management unit (MMU), a digital-to-analog converter (DAC), and the like.","In one embodiment, the PPU  may be included on a graphics card that includes one or more memory devices  such as GDDR5 SDRAM. The graphics card may be configured to interface with a PCIe slot on a motherboard of a desktop computer that includes, e.g., a northbridge chipset and a southbridge chipset. In yet another embodiment, the PPU  may be an integrated graphics processing unit (iGPU) included in the chipset (i.e., Northbridge) of the motherboard.",{"@attributes":{"id":"p-0114","num":"0122"},"figref":["FIG. 9","FIG. 8","FIG. 9"],"b":["850","850","905","910","920","950","951","952","953","980","970","990"]},"As described above, the work distribution unit  dispatches active grids for execution on one or more SMs  of the PPU . The scheduler unit  receives the grids from the work distribution unit  and manages instruction scheduling for one or more thread blocks of each active grid. The scheduler unit  schedules threads for execution in groups of parallel threads, where each group is called a warp. In one embodiment, each warp includes 32 threads. The scheduler unit  may manage a plurality of different thread blocks, allocating the thread blocks to warps for execution and then scheduling instructions from the plurality of different warps on the various functional units (i.e., cores , DPUs , SFUs , and LSUs ) during each clock cycle.","In one embodiment, each scheduler unit  includes one or more instruction dispatch units . Each dispatch unit  is configured to transmit instructions to one or more of the functional units. In the embodiment shown in , the scheduler unit  includes two dispatch units  that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments, each scheduler unit  may include a single dispatch unit  or additional dispatch units .","Each SM  includes a register file  that provides a set of registers for the functional units of the SM . In one embodiment, the register file  is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment, the register file  is divided between the different warps being executed by the SM . The register file  provides temporary storage for operands connected to the data paths of the functional units.","Each SM  comprises L processing cores . In one embodiment, the SM  includes a large number (e.g., 192, etc.) of distinct processing cores . Each core  is a fully-pipelined, single-precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. In one embodiment, the floating point arithmetic logic units implement the IEEE 754-2008 standard for floating point arithmetic. Each SM  also comprises M DPUs  that implement double-precision floating point arithmetic, N SFUs  that perform special functions (e.g., copy rectangle, pixel blending operations, and the like), and P LSUs  that implement load and store operations between the shared memory\/L1 cache  and the register file . In one embodiment, the SM  includes 64 DPUs , 32 SFUs , and 32 LSUs .","Each SM  includes an interconnect network  that connects each of the functional units to the register file  and the shared memory\/L1 cache . In one embodiment, the interconnect network  is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file  or the memory locations in shared memory\/L1 cache .","In one embodiment, the SM  is implemented within a GPU. In such an embodiment, the SM  comprises J texture units . The texture units  are configured to load texture maps (i.e., a 2D array of texels) from the memory  and sample the texture maps to produce sampled texture values for use in shader programs. The texture units  implement texture operations such as anti-aliasing operations using mip-maps (i.e., texture maps of varying levels of detail). In one embodiment, the SM  includes 16 texture units .","The PPU  described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing, data compression, biometrics, stream processing algorithms, and the like. In particular, parallel computing may be used to construct a tree and restructure multiple treelets in parallel.","The bottom-up traversal algorithm that may be used to perform step  shown in  during restructuring of multiple treelets in parallel, may have very low SIMD utilization because most of the threads terminate quickly while only a few survive until the end of the optimization. The reduction in parallelism is problematic because the optimization is computationally expensive and would ideally be performed at full utilization of an SM . Instead of performing the optimization independently by each thread, a group of 32 threads (e.g., warp) may be used to collaboratively process each treelet. The algorithm used to perform the restructuring should allow parallel execution, such as the algorithm shown in . Since every treelet occupies 32 threads instead of one, it is enough to have only a modest number of treelets in flight to employ an entire PPU . Therefore, more on-chip memory is available for processing each treelet, and the scalability of the algorithm is also improved.","Compared to the code example 400, the code example 420 represents roughly a thousand-fold improvement in terms of execution speed resulting from increased parallelism. However, as a practical matter, the memory space consumed during execution of the example code  or  for a tree should also be considered. With n=7, the example code  executes (3+1)\/2\u22122=966 inner loop iterations and stores 2n\u22121=127 scalars in each of the arrays a, c, and .","In one embodiment, the PPU  includes 14 SMs , and each SM  can accommodate 64 warps, has a 256 KB register file , and 48 KB of fast shared memory in the shared memory\/L1 cache . Assuming that one treelet is processed by a warp at full occupancy, 32 scalar registers are available per thread and 768 bytes of shared memory are available per treelet. Placing variables a, c, and in shared memory using 4 bytes per element would exceed the available shared memory by a factor of 2. However, because a[] is only needed for calculating c[], a[] and c[] can be overlayed into the same array. Therefore, the array elements initially represent a until line 7 or 20 of the example code  when the array elements are turned into c. Additionally, the elements of are 7-bit integers, so memory can be saved by storing the 7-bit integers as bytes. By using a single array for a and cand storing the elements of as bytes, the arrays may be stored in 636 bytes of shared memory which is within the 768 bytes of shared memory that is available.","In addition to the arrays, the bounding volumes, SAH costs, primitive counts, node children, and identities of the nodes are also tracked, summing to a total of 11 values per node that are stored in the register file, so that one thread stores the values of one node. In one embodiment, each thread in a warp may read values for any node in the treelet, but only the thread assigned to a particular node may modify values of the node.","The most computationally intensive part of processing a treelet is finding the optimal partitioning for each subset of the treelet leaf nodes, corresponding to lines 10-23 in the example code . Since there are no dependencies between subsets of the same size, one technique to parallelize the optimization would be to repeatedly pick one subset for each thread until all subsets of the given size have been processed. TABLE 1 shows the statistics for each subset size with n=7. The first three columns correspond to the loops on lines 10, 11, and 14 of the example code , respectively. Total work indicates the number of inner loop iterations that are executed for the given k in total, and the last column shows the overall distribution of the workload.",{"@attributes":{"id":"p-0127","num":"0135"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Statistics for each subset size in example code 420 with n = 7"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Size(k)","Subsets()","Partitionings()","Total Work","%"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["2","21","1","21","2"]},{"entry":["3","35","3","105","11"]},{"entry":["4","35","7","245","25"]},{"entry":["5","21","15","315","33"]},{"entry":["6","7","31","217","22"]},{"entry":["7","1","63","63","7"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"As shown in TABLE 1, most of the work is concentrated on sizes 4-6, whereas size 2 is practically free. The number of subsets tends to be very uneven, which means that parallelizing the computation over subsets of the same size alone will necessarily lead to low SIMD utilization. In particular, sizes 6 and 7 have the highest amount of work per subset, but offer only a few subsets to process in parallel.","Even though it is necessary for all subsets of size k\u22121 to be ready before the subsets of size k can be processed to completion, it is still possible to process some subsets of size k earlier. Thus, the SIMD utilization can be improved by allowing the processing of multiple subset sizes to overlap. One approach is to process sizes 2 . . . n\u22122 in a unified fashion, and treat sizes n\u22121 and n as special cases.","For sizes 2 . . . n\u22122, a pre-generated schedule may be used as shown in TABLE 2 for n=7. The schedule consists of a fixed number of processing rounds, and identifies which subset each thread should process in each round, if any. The schedule can be generated for any treelet size and SIMD width using a simple algorithm that considers the rounds in reverse order and greedily includes as many subsets in the current round as possible without violating the dependency rules.",{"@attributes":{"id":"p-0131","num":"0139"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1","tabstyle":"monospace"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"center"}},"thead":{"row":{"entry":"TABLE\u20032"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Pre-generated\u2003schedule\u2003for\u2003n\u2003= 7"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"245pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Round","Subset\u2003sizes\u2003processed\u2003by\u200332\u2003threads","Active"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["1","2\u20032\u20032\u20032\u20032\u20032\u20032\u20032\u20032\u20032---------------------------------------","10"]},{"entry":["2","3\u20033\u20033\u20033\u20033\u20033\u20033\u20033\u20033\u20032\u20032\u20032\u20032\u20032\u20032\u20032\u20032\u20032\u20032\u20032-------------------","20"]},{"entry":["3","4\u20034\u20034\u20033\u20033\u20033\u20033\u20033\u20033\u20033\u20033\u20033\u20033\u20033\u20033\u20033\u20033\u20033\u20033\u20033\u20033\u20033\u20033\u20033\u20033\u20033\u20033\u20033---","29"]},{"entry":["4","4\u20034\u20034\u20034\u20034\u20034\u20034\u20034\u20034\u20034\u20034\u20034\u20034\u20034\u20034\u20034\u20034\u20034\u20034\u20034\u20034\u20034\u20034\u20034\u20034\u20034\u20034\u20034---","32"]},{"entry":["5","5\u20035\u20035\u20035\u20035\u20035\u20035\u20035\u20035\u20035\u20035\u20035\u20035\u20035\u20035\u20035\u20035\u20035\u20035\u20035\u20035-----------------","21"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Since there are only a few subsets of size n\u22121 and n, each subset may be parallelized over multiple threads. For n\u22121, 4 threads are used per subset, and for n, all 32 threads may be used to process the single subset. Parallelization of the subsets is advantageous when the number of partitionings is high enough that the inner loop completely dominates the processing cost. One approach is to consider only a fraction of the partitionings by each thread, and then use parallel reduction to merge the results at the end. Since  has a very specific bit pattern with k\u2267n\u22121, enumerating the partitionings considered by each thread is straightforward compared to the general case.","In addition to optimizing the partitioning, the AABB calculation for each value of  on lines 2-4 of example code  may also be parallelized. The minimum or maximum for the 6 scalar components of up to n individual AABBs is computed in parallel by assigning a group of 2consecutive subsets to each thread. These subsets share the same 5 highest bits of , so an intermediate AABB is calculated first, considering only the leaf nodes that correspond to the 5 highest bits. To obtain the final AABBs, the result is augmented with each combination of the remaining leaf nodes.","Forming the initial treelet is accomplished by expanding the treelet one node at a time in sequential fashion starting with the root node, maintaining a one-to-one mapping between nodes and threads. Even though only the first 2n\u22121 threads are employed, the overall process is still relatively efficient. At each step, the treelet leaf node with the largest surface area is selected using parallel reduction, and then the two children of the selected leaf node are assigned to two vacant threads. To avoid having to fetch full AABBs from memory for the selection, the values of A(n) may be maintained in a separate array throughout construction of the initial treelet and also during optimization of the treelet.","Reconstruction of the optimal treelet from can be performed in a similar manner as formation of the initial treelet, except that the identities of the original internal nodes are reused for the newly created internal nodes. After the reconstruction, new AABBs are calculated for the internal nodes based on their children, the process is repeated in parallel until the results have propagated to the treelet root. Finally, the nodes of the treelet are stored back to memory, bypassing the L1 cache in order to ensure that the results are visible to all SM s. As a minor optimization, the output part of the algorithm may be skipped in case it was not possible to improve the SAH cost, i.e., c[2\u22121]\u2267C(root).","The main loop of the BVH optimization kernel may be organized according to a parallel bottom-up traversal algorithm. Each thread starts from a given BVH leaf node and then walks up the tree, terminating as soon as the thread encounters a node that has not been visited by any other thread. The goal is to form a treelet for each node encountered during the traversal, if the node's corresponding subtree is large enough to support the particular choice of n. In practice, the processing switches from per-thread processing (traversal) to per-warp processing (optimization) at the end of each traversal step, and the set of valid treelet roots is broadcast to the entire warp.","To determine whether a given subtree is large enough to support a treelet with n leaf nodes, the fact that the intermediate BVH always stores one primitive per leaf may be utilized. Since the number of primitives is tracked for the purposes of Equation 2, the same information may be used to decide whether to accept a given node as a treelet root. However, the choice does not necessarily have to be made based on n\u2014any \u03b3\u2267n may be used, and only nodes whose respective subtrees contain at least \u03b3 primitives may be chosen as a treelet root.","A full binary tree with m leaf nodes can contain at most 2m\/\u03b3\u22121 subtrees with \u03b3 or more leaf nodes, and practical BVHs also tend to exhibit similar behavior. Given that the optimization kernel is virtually always dominated by treelet processing, the execution time may be described as O(m\/\u03b3) to a sufficient degree of accuracy. This means that \u03b3 provides a very effective way to trade BVH quality for reduced construction time by concentrating less effort on the bottom-most nodes whose contribution to the SAH cost is low.","In practice, multiple rounds of bottom-up traversal and treelet optimization are executed in order for the SAH cost to converge. However, in practice, the bottom part of the BVH generally tends to converge faster that the top part. This is not surprising considering that modifying the topmost nodes can potentially have a large impact on the entire tree, whereas modifying the bottom-most ones usually only affects small localized parts of the scene.","Based on this observation, it makes sense to vary the value of \u03b3 between rounds. In one embodiment, doubling the value of \u03b3 after each round may be very effective in reducing the construction time while having only a minimal impact on BVH quality. Using \u03b3=n=7 as the initial value and executing 3 rounds in total has proven to be a good practical choice for many test scenes.",{"@attributes":{"id":"p-0141","num":"0149"},"figref":"FIG. 10","b":["1000","1000","1001","1002","1002","1000","1004","1004"]},"The system  also includes input devices , a graphics processor , and a display , i.e. a conventional CRT (cathode ray tube), LCD (liquid crystal display), LED (light emitting diode), plasma display or the like. User input may be received from the input devices , e.g., keyboard, mouse, touchpad, microphone, and the like. In one embodiment, the graphics processor  may include a plurality of shader modules, a rasterization module, etc. Each of the foregoing modules may even be situated on a single semiconductor platform to form a graphics processing unit (GPU).","In the present description, a single semiconductor platform may refer to a sole unitary semiconductor-based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi-chip modules with increased connectivity which simulate on-chip operation, and make substantial improvements over utilizing a conventional central processing unit (CPU) and bus implementation. Of course, the various modules may also be situated separately or in various combinations of semiconductor platforms per the desires of the user.","The system  may also include a secondary storage . The secondary storage  includes, for example, a hard disk drive and\/or a removable storage drive, representing a floppy disk drive, a magnetic tape drive, a compact disk drive, digital versatile disk (DVD) drive, recording device, universal serial bus (USB) flash memory. The removable storage drive reads from and\/or writes to a removable storage unit in a well-known manner.","Computer programs, or computer control logic algorithms, may be stored in the main memory  and\/or the secondary storage . Such computer programs, when executed, enable the system  to perform various functions. For example, a compiler program that is configured to examiner a shader program and enable or disable attribute buffer combining may be stored in the main memory . The compiler program may be executed by the central processor  or the graphics processor . The main memory , the storage , and\/or any other storage are possible examples of computer-readable media.","In one embodiment, the architecture and\/or functionality of the various previous figures may be implemented in the context of the central processor , the graphics processor , an integrated circuit (not shown) that is capable of at least a portion of the capabilities of both the central processor  and the graphics processor , a chipset (i.e., a group of integrated circuits designed to work and sold as a unit for performing related functions, etc.), and\/or any other integrated circuit for that matter.","Still yet, the architecture and\/or functionality of the various previous figures may be implemented in the context of a general computer system, a circuit board system, a game console system dedicated for entertainment purposes, an application-specific system, and\/or any other desired system. For example, the system  may take the form of a desktop computer, laptop computer, server, workstation, game consoles, embedded system, and\/or any other type of logic. Still yet, the system  may take the form of various other devices including, but not limited to a personal digital assistant (PDA) device, a mobile phone device, a television, etc.","Further, while not shown, the system  may be coupled to a network (e.g., a telecommunications network, local area network (LAN), wireless network, wide area network (WAN) such as the Internet, peer-to-peer network, cable network, or the like) for communication purposes.","While various embodiments have been described above, it should be understood that they have been presented by way of example only, and not limitation. Thus, the breadth and scope of a preferred embodiment should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIG. 2B","FIG. 2A"]},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIG. 2C","FIG. 2A"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 4A","FIG. 3"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 4B","FIG. 3"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4C"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 5B-E"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6C"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 6D","FIG. 6B"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 6E","FIG. 6B"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 6F","FIG. 6E"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7B"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 9","FIG. 8"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
