---
title: Method for configuration SOA-based automation devices and for developing an orchestration machine, production method and production system in service-oriented architecture having embedded service orchestration engine
abstract: A method for configuring an automation device or simulator for controlling mechatronics components of an automation system, including: generating HLPN component models for each type of the mechatronic components of the automation system, creating a component instance model from an HLPN component model for each physically present mechatronic component, creating a layout configuration file, which describes relationships of the component instance models to be connected, composing the component instance models into a system model based on the layout configuration file, wherein logic ports of the component instance models are connected/linked to each other, generating configuration files based on a system model and device description files and WSDL files of the component instance models, loading the configuration files into the automation device or simulator containing the HLPN orchestration machine, and executing the configuration files by the HLPN orchestration machine of the automation device or the simulator.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09134726&OS=09134726&RS=09134726
owner: SCHNEIDER ELECTRIC AUTOMATION GMBH
number: 09134726
owner_city: Seligenstadt
owner_country: DE
publication_date: 20100909
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"p":["This application is a 371 of PCT\/EP2010\/063264 filed on Sep. 9, 2010, which claims priority to German patent application number 10 2009 043 968.4, filed Sep. 9, 2009, which is incorporated herein by reference.","The invention relates to a method for configuration of SOA-based automation devices and for developing an orchestration machine, and a production method and production system in service-oriented architecture having an embedded service orchestration engine.","WO-A-2009\/053472 describes a method for orchestration of services of a service-oriented automation system as well as an orchestration machine. System components offer their functionalities as services and are capable of querying services of other system components, such that the behavior of the automation system is controlled through orchestration of the services of the system components by means of an orchestration machine. To achieve orchestration of services at the device level, it is provided that the orchestration machine will use high-level Petri Nets tailored to service-oriented systems and that the orchestration of the services on the gate level is accomplished by interpretation and execution of various HLPN models representing the behavior of the automation system and\/or the system components.","WO-A-2009\/101212 relates to a method and a system for embedding service-oriented automation components of a production shop in a flexible IT enterprise architecture. To configure flexible production shops in the form of an orchestration method and to specify elements, it is provided that the service-oriented automation components are coupled to the higher level via orchestration middleware and the services offered by the service-oriented automation components are integrated into the higher level by using a vectorial function and a layout based on orchestration of service-oriented automation components.","In addition, a service-oriented automation device and method for specifying a service-oriented automation device are described in WO-A-2009\/103811. The following process steps are proposed for describing the operating performance of autonomous and collaborative automation devices and production shops with a service-oriented architecture:","Original setup of the automation device including configuration, explanation of services, establishment of links to other automation devices and transfer of the setup to awaiting original status, receipt of the results about service operations, internal device interfaces generated by inputs\/outputs and\/or directly by the control unit, analyzing the results received, implementing the results and the change in status of the model-based middleware shell, wherein the system reaches the next state and is capable of receiving additional results.","Modern industrial production systems are characterized by distributed systems, operators, products and information. These systems must be suitable for mass production and specific adjustments on a larger scale. A large number of factors are required for effective operation of such flexible production lines, including the number of product options, the production sequence for the respective product, the type of product, the capacity of the workstations, the processing time of the production processes at each workstation, the material processing capacity at each workstation and the total material processing capacity. The data thereby obtained and data to be processed later may therefore be subject to constant changes regardless of the large volume of data.","Components of distributed software are already being used in the form of distributed objects, function blocks and services, the latter in the form of a service-oriented architecture (SOA) and a service-oriented computing (SoC), which is currently growing in popularity in industrial automation systems. The dominant view of the future will be based on the idea of \u201cservice-oriented computing\u201d which offers a way to create a new architecture and reflects the trend in components toward autonomy and heterogeneity.\u201d Its growing usability in the business world and in e-commerce is seen as a step toward achieving a seamless integration of resources from different levels. Numerous efforts are currently being undertaken to research these fields more thoroughly, e.g., the SOCRADES project (http:\/\/www.socrades.eu).","In general, SoA considers the system only from the standpoint of its services, whereas a lower importance is assigned to its providers and users. These entities may be automation devices, software components and the like and have the special ability to encapsulate resources within services. They represent a new approach and are fundamentally different from memory programmable controllers (PLC, programmable logic controllers) in the field of automation.","These entities have occasionally been referred to as intelligent devices, and although they have also been named differently under some circumstances, they are similar in the property of being service-oriented autonomous control units, devices, actuators and sensors. Service computing and service orientation are therefore regarded not only as a form of communication but rather as a philosophy that should be assumed by the software entities by sharing their resources and expressing their requirements. This is the new design approach and style of thinking of automation technicians, enterprise managers and software developers who are tasked with the job of creating important tools and methodologies. Service-oriented automation software entities which are used in approaches of this type require a number of methodologies and software devoted to the specification of computer systems as well as embedded automation devices. These applications also contribute toward a shortening of development times and a reduction in the interdependence of the components, so that adequate flexibility for automatic reconfiguration of production arrangements is achieved.","With regard to the technology, the Device Profile for Web Services (DPWS) has been stipulated as the standard in this project. Since it describes only a few specific protocols, a compatible framework must be used to ensure communication of the software components in a service-oriented manner in the same language. One of the systems implemented is the SOA4D system (Service-Oriented Architecture for Devices) (https:\/\/forge.soa4d.org\/), which is targeted at larger computer systems (e.g., PCs) and embedded devices.","Against this background, the problem on which the present invention is based is to further develop a method for configuration of SOA-based automation devices and for developing an orchestration machine, such that there will be the possibility of modeling each component of a system individually and equipping them with logic interfaces, and wherein an automated composition of the models of the components to form a static overall model of the system is made possible.","In addition, the object of the invention is to make available a manufacturing method and a manufacturing system based on an implemented orchestration machine that supplies conflict resolution mechanisms.","This object is achieved according to the present invention by a method for configuration of an automation device having an orchestration machine by means of the features of claim , among others.","The production system (DAS) comprises:\n\n","The orchestration engine (OE) is preferably linked to a Decision Support System (DSS) via the network (N), this Decision Support System being implemented in the Production Execution System, such that decision support can be queried when conflicts occur at the conflict nodes on execution of the orchestration model and\/or behavior model implemented in the orchestration engine (OE).","The model-based service orchestration machine utilizes a Petri Net dialect as the modeling language and logic language: high-level Petri Net (HL-PN). The HL-PN has been expanded by elements to map web service-specific properties directly onto the HL-PN model: service and data contracts as well as configuration of the DPWS discovery. However, the models can also be expanded by additional properties. In addition to DPWS-compatible web services, other message-oriented and event-oriented communication layers can also be configured.","Petri Nets are suitable for mapping of competing and concurrent processes with distributed resources, which operate on a limited set of software and hardware resources. The fundamental approach is to model each component of a system individually and to furnish it with logic interfaces which allow (automated) composition of the model components to form a static overall model of the system. The model instances are interconnected according to the real topology of the system. Due to the fact that the component models supply all the interfaces, the overall model contains all the sequence paths that are possible in principle. On the example of a material flow system, this means that a system consisting of shipping components will contain all flow paths which enable physical conveyance of material by connecting the transport elements. In the trivial case, the system may contain linear paths and thus the process may take place more or less sequentially, but in more complex compositions, the process might contain a few paths with multiple bifurcations and connections, so that alternative sequence paths can be selected in run time. The bifurcations and connections in such complex processes are modeled as conflict nodes in the Petri Net. Conflicts in a Petri Net model may have different meanings in a real system. For example, a pallet on a transport element could be transported in different directions, or two subprocesses may \u201ccompete\u201d for the same resource.","A few problems could be solved by simple algorithms, e.g., random selection of a process path, but such approaches are inefficient when seen from a global standpoint or may even be harmful for certain topologies because deadlocks occur there and the process is blocked. It is thus clear that subprocesses should not only be synchronized locally to a limited extent but should also be synchronized in an expanded context. These problems are not new and have already been solved at least in part through Enterprise Resource Planning ERP\/Manufacturing Execution System (MES).","For the orchestration machine and an \u201corchestrated\u201d system of services, an architecture was selected that would permit a separation of the decision algorithms and the service orchestration. There is a special interface between the orchestration machine and the so-called Decision Support System (DSS) for exchanging decision questions, answers and method data for decision-making. At the orchestration level, so-called local decisions are made which are based on simple algorithms and then intervene to resolve conflicts quickly if the higher-level Decision Support System (DSS) has not yet made a decision. At a lower level, decisions are thus made based purely on knowledge of the models and the current status of the models.","From the standpoint of orchestration (bottom-up), the DSS encapsulates the upper systems as a service for decision-making without knowing which algorithms the decision is based on.","From the standpoint of Enterprise Resource Planning (ERP) (top-down), the DSS encapsulates the production system, i.e., manufacturing system, as a Manufacturing Execution System (MES) service with interfaces for receiving production orders and for monitoring production. The ERP system does not have a detailed knowledge of the automation processes but instead only has information about production orders and their status.","A concept of an application scenario is described below.",{"@attributes":{"id":"p-0062","num":"0066"},"figref":"FIG. 1","b":["1","3","5","6","9","4","6","1","2"]},{"@attributes":{"id":"p-0063","num":"0067"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0064","num":"0068"},"figref":"FIG. 3","b":["1","11","1","2","1","2"]},"The central part of the transfer system (units C-C) consists of nine transfer units C-C (conveyors, unidirectional and\/or cross-conveying) as shown in  () and (). The unidirectional transfer unit C has an input port and an output port PORT, PORT; the cross-conveyor unit C, C permits transfer not only in the longitudinal direction but also in the direction perpendicular to that and includes the input and output ports PORT-PORT. These units have an optical sensor S and an output for a conveyor motor M. Furthermore, a cross-conveyor unit C, C may be regarded as a combination of two devices, namely first a unidirectional transfer unit C, C, C and a lifter L, L with the possibility of executing directional transfers.","The cross-conveyor units C, C have two optical sensors S, S to detect the presence of a pallet P and two other sensors S, S to detect whether a cross-connection CC is in the upper or lower position. The four outputs are used for control of motors M\u2014one for the normal conveyor motor M, another motor M to lift the central directional cross-connection module and two motors M, M, one for the directional transfer clockwise and another for the directional transfer counterclockwise.","The lower transfer units C, C have the same behavior as the normal unidirectional transfer units, e.g., unit C, but are longer.","Lifters are identified by units L and L, as shown in  and  (). In addition to their function as an interface between the upper and lower parts of the system, they are also responsible for the transfer of pallets P into and out of a manufacturing cell. One transfer unit TE in the lifter L, L has two optical sensors S, S for detecting the presence of a pallet P. Photoelectric beams are provided at both ends of the units. The transfer unit TE may additionally be moved in two directions (by analogy with the central unit CC of the cross-conveyor unit C, C), so there is an output PORT-PORT for each direction. One lifter motor HM is controlled by a Telemecanique (registered trademark) Altivar 71 in combination with a Controllerinside card (frequency convertor for lift control), which counts the instantaneous position of the conveyor and calculates it. The ControllerInside card was selected instead of the Advantys (registered trademark) EHC3020 fast counter module because at the time of selection the required precision for the lift position (<1 mm) was not ensured.","The characteristics of the individual components of the transfer units in the system are summarized in the following table.",{"@attributes":{"id":"p-0070","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},{},{},"Pallet OUT"]},{"entry":["Unit ID","Type and functions","Pallet IN port","port"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["C1, C3,","across","3 available, only one","3 available,"]},{"entry":["C7, C9",{},"used","only one"]},{"entry":[{},{},{},"used"]},{"entry":["C2, C8","unidirectional user","1","1"]},{"entry":[{},"panel, workplace,",{},{}]},{"entry":[{},"RFID",{},{}]},{"entry":["C4, C6","across, RFID","3 available, only two","3 available,"]},{"entry":[{},{},"used","only two"]},{"entry":[{},{},{},"used"]},{"entry":["C5","unidirectional","1","1"]},{"entry":["C10-C11","unidirectional (long)","1","1"]},{"entry":["L1, L2","starting and ending","2 available, only one","2 available,"]},{"entry":[{},"lifter","used","only one"]},{"entry":[{},{},{},"used"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"left","id":"FOO-00001"},"sup":"(1)"}},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"left","id":"FOO-00002"},"sup":"(2)"}},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"left","id":"FOO-00003"},"sup":"(3)"}}]}}}}},"The pallets P are deployed manually into the system with the help of the units C and C and are conveyed on alternative paths to the workstations W and W. In this very small cell, a pallet P circulates in the system until it is directed to one of the workstations. The path is determined at the cross units as a function of the production processes required for the product placed on a certain pallet and this depends on the site and on the availability of the production services in the system (at W and W here). A workstation may offer more than one production mode, and one production mode may be possible from more than one workstation.","As soon as a pallet P is directed to a given workstation W, W to receive a certain production process, the line control system (a service orchestration in the present case) stops the pallet P at the transfer unit C, C until the production process has been triggered by the operator. The signal of the operator is transmitted by a simple HMI (human-machine interface) application.","To identify the pallet P, the cross units C, C and the workstation units C, C are each equipped with an identification unit, i.e., such as an RFID device (radio frequency identification), which has the ability to read data from\/write data to labels on the pallets P. The identification unit IE is used by the line orchestration to \u201cquestion\u201d an external Production Execution System (PES) about the next production step provided. Alternatively, this query may not be made at each cross-connection but instead the production sequence can be stored on the production label and read off from it.","The automation and control sequence is explained below.","Numerous automation devices STB are used for controlling the mechanical parts of the production system and form the interface with a Production Execution System PES of a higher level by offering and utilizing services.\n\n","The integration of the control devices STB into mechatronic components\/modules of the electromechanical modular system yields a \u201ccollaborative automation unit\u201d as diagrammed schematically in .","The following connection between individual devices is used (see ):",{"@attributes":{"id":"p-0078","num":"0086"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Unit ID\/Device","Devices","Firmware\/Tools"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["C1-C3, C7-C9 (line of","2 + 1 STB","ControlBuild"]},{"entry":["workstations)",{},{}]},{"entry":["C4-C6 (mainline)","3 STBs","ControlBuild"]},{"entry":["C10, C11 (return line)","1 STB","ControlBuild"]},{"entry":["L1, L2 (lifter)","1 + 1 STB","ControlBuild"]},{"entry":["RFID antennas for C2,","TSX ETG 100","DPWS-to-ModbusTCP"]},{"entry":["C4, C6 and C8",{},"Gateway"]},{"entry":["Combined services","3 STBs","Petri Net Engine, Continuum"]},{"entry":["1, 2 and 3",{},"Development Tools"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"left","id":"FOO-00004"},"sup":"(1)"}},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"left","id":"FOO-00005"},"sup":"(2)"}},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"left","id":"FOO-00006"},"sup":"(3)"}}]}}}}},{"@attributes":{"id":"p-0079","num":"0087"},"figref":"FIG. 8"},"Each workstation W, W is equipped with a user panel having two buttons and one switch. The user panel is not used in the production system shown here; its actual use was to activate and deactivate the workstation W, W plus the possibility of the user sending two commands, e.g., OK and ERROR. This functionality is enabled by a PC-based HMI, which displays the product data and gives the user an opportunity to enter the results of the procedure. Without these buttons, the workplace has the same properties as a simple unidirectional transfer unit.","The approach for creating complex flexible and reconfigurable production systems is that these systems are composed of reusable modular components, which offer their production properties as a number of different services. This approach to assembly is valid for most levels in production. Simple devices are assembled to form complex devices or machines, which are themselves reconstructed to create cells or lines of a production system. The same thing is also true of designing service-oriented production systems and assembling complex services from simpler services.","The model-based orchestration engine OE together with the orchestration tools CDS is part of a system architecture, which is referred to in  as a general orchestration engine box. This figure also gives an overview of the relationships with other integrated components, e.g., the Decision Support System DSS and the design and simulation of service-oriented systems with 2D\/3D engineering environments CDS.","Based on hardware and overall project requirements, it has been decided that the fundamental building blocks which constitute the distributed system should be configurable software components for different tasks. Software components have therefore been drafted as bots that have a so-called \u201corchestration engine\u201d internally and are capable of coordinating their activities (in a service-oriented manner) and also taking over collaboration processes with other components in the system.","In the example according to , the autonomy range of the bot is a transfer unit (conveyor). The communication with other software components in the system (e.g., other bots) is implemented via the offer of services and utilization of the required services of other components. For the design, configuration and maintenance of the bots, various tools are required and must be user friendly and must accelerate development by using a program approach at a higher level (visual languages).","Since services are not isolated entities using directly linked software components, a logic unit which creates the interaction is to be provided. The selected modeling language is obtained from Petri Net specifications with expansions at a higher level, such as time considerations, a property system and an adaptable token engine. This is referred to below as a Petri Net of a higher level (high-level Petri Net, HLPN). The expandable property mechanism of the HLPN is used as an interface for configuration of the properties associated with the web service.","Additional requirements include the use of the Decision Support System (DSS), which is capable of making correct data available to the Petri Net model at each decision point. This DSS is the most important interface between the model-based approach for the transport system and the production planning system.","Additional details about the scientific approaches used are disclosed in the following publications (all of which refer to the SOCRADES project). The full content of these publications is herewith referenced:\n\n","Since SOA-based automation systems do not have the respective user software and methodologies, efforts have been undertaken in the field of software development and several software packages have been created for the production system being used. In each case, system engineering and the associated tools should facilitate the work of the developer. With regard to the Petri Net, there is only limited practical benefit due to the lack of computer tools which would enable simple utilization of large and complex networks.","This project has been referred to as Continuum Development Tools in accordance with the continuum concept known from physics and philosophy. The first developments were achieved by integration of software components that had already been developed, in particular the PndK (Petri Nets Development ToolKit) under the same name. With this integration, the demand for numerous software packages became obvious, including: a framework for development of bots, engineering tools for creating and managing bots and numerous additional aids (mainly libraries) to support tasks such as communication and interfaces for devices.",{"@attributes":{"id":"p-0090","num":"0106"},"figref":"FIG. 11"},"The support package includes several reusable software libraries and tools. Some of these were developed internally and others were added from external sources, e.g., the SAO-4D-DPWS library (available at https:\/\/forge.soa4d.org) for the development of web services and the QT Toolkit (see http:\/\/qtsoftware.com) which is used mainly as a graphic toolkit for human interaction in CDS.","The main development languages are C and C++. The development environment was generated and managed with the help of multiple tools; the versioning system used was Subversion (http:\/\/subversion.tigris.org). CMake (http:\/\/www.cmake.org) was selected as the building system (allows development and generation beyond a given platform). In addition, the documentation is generated with the aid of Doxygen (http:\/\/www.doxygen.org\/). No special software project management tool is used because the group consists of only a few people, and development can normally be conducted at one location.","To meet the necessary requirements, bots intended for implementation of multiple functions must have a consistent anatomy for the functionality of the various function modules (\u201corgans\u201d). Modules running asynchronously, possible data inconsistencies and processes and threads running in parallel may cause problems. In general, module integration into a completely functioning bot may be considered. By analogy with what takes place in almost all creatures having a nervous system, the \u201cpulses\u201d or signals generated by the modules must be directed correctly to the destination and interpreted. This may be considered a loose form of integration in event-based integration in particular, in which modules interact with one another by reporting on events and reacting to events.","The Continuum Bot Framework is the basis for the development of bots.  shows a class diagram, focusing on the CBF and implementations of the modules and bots. A module may be defined by inheritance of the CBF Abstract Module Class and specific functionalities may thereby be added to it. For example, the Petri Net Kernel Module uses the functions and structures of the Continuum Petri Nets Kernel Library. For the DPWS module, the external SOA4D-DPWS library was used to generate a communication module. This can be used by bots for communicating with other bots by offering their own services or by using the services of the others. An independent Bot (integrated as a stand-alone application or as a library) can be achieved by modification of the CBF AbstractBot by adding a special code and combining the modules required.  shows an example of a mechatronic bot which depends on several modules.","Signals are used for the intraspecific communication of a bot, i.e., there is an event-based interaction between the modules. A signal is generated by the CBF signal class and several parameters and user data can be defined with the instances of the signal. Signals are sent by a module and relayed over an intermediate CBF module manager, which is connected to each module. Reception and analysis of the signals are performed by each module asynchronously. When a signal is received, it is stored in the local queue of the module. Internally a module represents a thread loop which analyzes the local queue of received signals. When a signal is taken from the queue, this triggers the execution of a program code corresponding to this event. The signal mechanism used may be compared with the signal\/slot principle of the QT Toolkit with regard to function.","However, it may also be appropriate to use Petri Nets for typical systems with a defined behavior or also for more complex systems with distributed participants. In any case, system engineering and the respective tools should facilitate the work of the developer. With regard to the Petri Net, it has only limited practical benefit due to the lack of computer tools which would enable simple utilization of large and complex networks. Continuum Development Studio (CDS) therefore intends to offer a user-friendly environment for multiple engineering tasks of service-oriented automation systems, from specification and configuration of the automation bot, analysis and simulation, to starting operation of the system.  shows a screenshot of CDS simulating a Petri Net test model.","This development has been based on a port and the natural further development of the previous PndK, which was provided additionally with a Multi-Document\/View-type framework (like the structural template of the Model View Controller) plus additional tools. The framework was created on the inadequate basis of the QT Toolkit that was used (which actually supports Model View programming in class form but does not have a framework for its administration and integration into an application). Essentially, the framework has a document manager class for monitoring documents and their views, a Project Explorer for adding documents in a logical manner and the abstract classes, with which developers can furnish personalized documents and views. The document manager allows the creation of document instances and view instances in the manner of the factory method and also offers personalization of their tools, e.g., toolbars and other widgets. File management (through operations such as New, Open, Save, etc.) is also handled in an integrated manner for all types of documents. At the present time, only Petri Net types and text document types (and corresponding views) are implemented.","Petri Net Document\/View allows design, analysis and independent simulation of Petri Nets. In addition, a personalized property system has been developed, which provides for the addition of Petri Nets and their elements with information which can be used so that a Petri Net model can be associated with the behavior of an automation bot, for example. It is also possible to import a WSDL data file that has already been configured and assign it to the transitions of the modeled Petri Net, so that the transitions actively participate in the message sequences when the model is used in a bot. There is a built-in orchestration engine which can coordinate and synchronize the services in accordance with the Petri-Net-defined workflow (using the SOA4D-DPWS library). Configuration of the bots (with the Petri Net Kernel Module) is performed mainly by describing the expected behavior based on a Petri Net model, including the utilization of external services, providing one's own services and by device access.","The previous sections have explained how a Petri Net designer can specify models for mechatronic components or even larger systems.","According to a first idea of the invention, the invention is based on a method and a software product for configuring HLPNs in SOA-based automation devices.","The next section will describe and explain a tool chain for compiling systems SYS, the creation of configuration files DF (descriptor files) and the use of these files on devices STB or on simulators SIM.  shows the complete sequence of component design or system design as well as the compilation and use of the devices STB.","As already explained above, a system SYS may comprise a plurality of mechatronic components C-C, L, L, W, W, which are embodied as a unit of mechanics, electronics, controllers and an interface such as, for example, communication by means of web services. Examples of mechatronic components include the lifters L, L and the transfer units C-C, each with the respective automation device STB.","Taking into account WSDL files and device templates DT, so-called Component Instance Models CIM, which have an instance name and reference name, are formed from the component models. The Component Instance Model CIM describes a certain mechatronic component such as lifters L, L in the system SYS, for example, the lifter L of a local system.","A component model is understood to be an HLPN model of a mechatronic component without instance names or reference names. A component model CM describes all the components of one type, for example, lifters L, L.","Other extremely important tools include:\n\n","Additional tools:\n\n","Prerequisite:\n\n","Preparations in detail:","The Composition Tool CT is used for semiautomatic composition of a system model SM from a set of Component Instance Models CIM. The composition runs according to a Layout Configuration File LCF (XML-based XRC files) which describes the relationships of the Component Instance Models CIM to be connected. The file is generated with the help of a text editor or by means of external tools, e.g., Delmia. In addition, the user must generate a single-model CIM for each physical component C-C, L, L (copy and insert) even if the same models CIM are used. Each Component Instance Model CIM must then be configured with a correct and binding reference name. This must be performed by the designer or by replacing character strings in the text editor.","Device Descriptor Files DDF are needed for creating the configuration files CF; these Device Descriptor Files establish a 1:1 link between the binding reference name in the models CIM and the real DPWS devices\/services. The user can start a network scan procedure for detecting all DPWS devices which write Device Descriptor Files, including the device type, operational use, address, descriptor name, etc. The user next generates the connection to the binding name by renaming the respective Device Descriptor File.","A DPWS device is understood to be a logic device (visible as a service endpoint in the network) which offers certain services for discovery and metadata access. A DPWS device is a container for the actual functional services (DPWS services).","DPWS is a standard which defines a separate resource model with DPWS devices and services. The DPWS standard requires that a DPWS device must be available as the service endpoint in the network and must offer WS Discovery and WS Metadata Exchange as services. DPWS services may thus be queried and addressed by the device. For example, the lifter L is a DPWS device of the lifter type which offers the DPWS services such as \u201clifting\u201d and \u201ctransfer.\u201d","A DPWS service is a DPWS-compatible dedicated service of the \u201clifting\u201d or \u201ctransfer\u201d type, for example. Furthermore, WS metadata exchange and optionally also WS eventing are required and supported by the DPWS standard.","Metadata of a service that is used refers to additional information of a service (endpoints) which can be downloaded by the device via DPWS services.","A system model SM that should be used is represented as a DPWS device. Therefore a Device Descriptor File is also needed for this purpose. The creation of a new descriptor file is generated by the template generator batch file which therefore needs a binding name as input. The binding name must correspond to the project name of the model (name of the XPN file).","An HTTP web server is used to allow access all files via the URL, so that each tool of each computer that can read the metadata of the services used can also interpret the WSDL memory site properties and can thus download the WSDL without user intervention. Materna Explorer can automatically download and generate clients, for example. Another advantage is that these files can be administered centrally in this way.","The current implementation of the general communication module, which is configured by rewritten WSDL files, causes certain restrictions on the WSDL files. Only DPWS-compatible definitions can be used, which means that only operations with a SOAP-HTTP connection and document style and literal encoding may be used. Messages may either be blank or may include only a message part. The message part must be based on an XML element and must not be based on a type. The types are to be specified in the same WSDL file. Xsd:sequence may be used, but all specifications for events must be of a fixed size; \u201cunbounded\u201d must not be used. Xsd:choice, Xsd:union, xsd:any must not be used. All basic types are handled as strings and no type testing is performed. Restrictions and facets such as enumerations (Xsd:enumeration) may be used, but here again, there is no type testing. SOAP coding and array types are not supported.","The following steps are to be performed individually, and you must be sure that all preparations have been made ():\n\n","The goal of the method described here is to show the gain in flexibility by using a service-oriented architecture by executing a production order of an ERP (Enterprise Resource Planning) system ERP directly in the production shop PS, as shown in . In addition, there are only minimal prerequisites of the specific composition of the production line throughout the entire system. However, to be able to offer a coherent application, a specific setup is selected. The detailed production steps are saved in a Production Execution System PES.","This Production Execution System PES is integrated between the Petri-Net-based Decision Support module DSS, which is connected to the intelligent devices STB, and the ERP system ERP (Enterprise Resource Planning), as shown in . It registers the New Order Entry in the ERP by means of the Local Discover Unit LDU. When a New Order Entry is received, additional details are queried by the ERP system. To this end, a Get Order Details message is used, identifying the Production Execution System PES itself with a machine ID representing the production unit.","The Production Execution System PES sends the status message READY with the number of producible units back to the system ERP. This response is based on internally stored data with regard to the production time required for an individual product. Production starts after receipt of the Start message. The production execution [command] is sent to the system ERP after each change in order status until the request has been completely executed.",{"@attributes":{"id":"p-0122","num":"0158"},"figref":"FIG. 18"},"A production step is terminated after a Service Completed message has been sent from the Production Execution System. This leads to the next step of the service. When the last step of the production list has been executed, the product is completed. Completion of a single product increases the number of products produced by one and triggers a status update, which is sent to the ERP system.","A more extensive sequence for production of a single product is shown in , which follows. This example relates to a product for which the process description is as follows:","1. A new pallet is deployed into the production workflow at the workstation W.","2. The individual production step is executed at the workstation W.","3. Finally, the product is terminated again at workstation W.","The workflow begins within the Petri Net Engine STB_PNE, which requests the decision to continue with production. To identify the pallet Pzu that is to be processed, the engine OE accesses the RFID number of the connected RFID reader OSI and thereby uses the respective service. This connection is modeled according to a specific physical topology in the Petri Net.","This pallet ID is used to obtain the next service from the Production Execution System PES. Due to the service sent back, the Petri Net Engine STB_PNE can continue. Next the pallet P is moved to the intended site, e.g., to the workstation W. On reaching the destination of the pallet, the production unit W, which has been guided there, receives the Execute Service command for the given pallet ID. Next the production unit W performs the service.","For this application, a PC-based HMI is used as the production unit. This is a program which displays a text message with the production step queried for the user. The text displayed is supplied by the production execution. In a real system, the Production Execution System may supply additional information for performing production steps, e.g., a program for operating a manipulator or the like.","The production unit used is confirmed by the operator after the production step has been terminated by pushing a button. This button may either be part of the HMI or may then be a physical button. In  the Production Execution System is notified that the service \u201cws\u201d for the pallet ID=10721 is concluded. With this message, the result of the production step can also be supplied, for example, if the service has been performed successfully, the result=\u201cOK\u201d is used. The next time a service is requested for this pallet ID, another service is sent back. Thus the pallet is conveyed to the next service. The times for completion of each individual production step and for producing the overall product are measured and stored in a database.","To demonstrate the workflow over a longer period of time, the production unit may be configured so that it runs automatically. In this case, the service is concluded after a certain period of time. It is thus also possible for the system to produce units and execute orders automatically without human intervention.","To simulate additional scenarios, production steps may be provided with other results than OK, e.g., FAILURE, PROCESSING, DEFECT, NOTONSTOCK.","The Production Execution System stores the data in a corresponding database (). The data may be divided into two parts. The first part is the definition of the production process used in the application. It can define the production steps required for a given URI, for example. The second part serves to receive and execute the individual orders. Time-relevant data is also stored in this part.","The Process Description tables with the Production Step\/Production Step List and Provider\/Provider List constitute the first part. The production order and product tables are used for the second part.","Various operating modes can be used in the ERP system with the order details. The following table shows the processes that can be used initially with the production steps executed.",{"@attributes":{"id":"p-0134","num":"0170"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["No.","Name","URI","Production steps"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","out","is given","\u201ccome to a stop\u201d (ws1)"]},{"entry":["2","one-step","is given","\u201cdeploy pallet\u201d (ws1), \u201cexecute"]},{"entry":[{},"operation",{},"production\u201d (ws2), \u201ccome to a stop\u201d (ws1)"]},{"entry":["3","three-step","is given","\u201cdeploy pallet\u201d (ws1), \u201cconnect housing"]},{"entry":[{},"operation",{},"and electronic parts\u201d (ws2), \u201cattach"]},{"entry":[{},{},{},"antenna and close the housing\u201d (ws1),"]},{"entry":[{},{},{},"\u201cperform quality check\u201d (ws2), \u201ccome to a"]},{"entry":[{},{},{},"stop\u201d (ws1)"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"The tools used and the engineering methodology were added to the production system with the goal of transporting pallets to the workstations and creating flexibility in the design and maintenance of the system.","As soon as the software is completely concluded and ready for operation, the question arises as to how it is used for specification of the automation system. The numerous engineering steps required from system design to operation and reconfiguration are described in the following section (see ).","The design phase currently allows the use of virtual display in a 3D simulation tool, mainly to export the connection data in XML format for the Continuum Development System CDS. The CDS is used for the design and analysis of the Petri Net model for describing the behavior of the bot (FIG. .). If the device\/connection information is imported by the 3D simulation tool, then several steps are performed by the CDS: 1) creating instance models CIM of the Petri Net model SM for each bot based on the models generated, 2) creating the required properties of the Petri Net model SM, so that multiple parameters of the given information are written by a 3D simulation tool into the model (e.g., bot\/device data, connections, . . . ) and 3) based on the \u201cexpansion\u201d of the Petri Net model, the model composition may be used to create a connection logic and for the overall system analysis (FIG. .).","After analysis and simulation (can be performed with the CDS and also with the 3D simulation tool, which supply the services of virtual devices), the bots must then be configured. The process of deployment a service which encapsulates its logic as a Petri Net model to form a bot having an embedded Petri Net Kernel Template model is shown in FIG. .. The deployment functionality is a standard feature of the DPWS and is offered as a dynamic deployment service. The goal and the deployment service can be found through a Stacks Built-In Discovery Service. After the deployment, a new service endpoint is added and the execution of the service logic is initiated. The deployment data comprises data on the Petri Net behavior model, connections to neighbors (required services), services offered by the bot and also additional configuration data for the additional modules of the bot. The bot will self-configure (and will configure its modules) and is then ready for operation.","Operation here means autonomous behavior of the bots according to their defined model plus internal handling of exceptions and the offer and utilization of services by different bots and other software components belonging to the system (FIG. .). Features for higher levels in the service approach also include combining multiple services into one (simplification of the external view), lateral collaboration between bots (offering services), decentralization in comparison with a hierarchical control approach. Business integration (and in general, integration of higher levels) of the production cell is achieved through service orientation. Business requirements are expressed through the production planning and the management of the production cells by monitoring their work status (by means of specific series), deactivation\/activation of various routing paths of the production, etc.","During operation, a new configuration may be necessary if a control model for a bot is no longer valid or if production strategies have been changed. In these cases, the bots affected must be stopped (without bringing the system to a standstill), and then the services would no longer be available. During this period of time, new models can be created to achieve a new desired behavior. These models are then transferred to the bots and operation can ultimately be resumed.","This section describes the automation bots (with an embedded orchestration engine) which are used in control devices STB for coordination of the production activities of the scenario. Depending on the distribution of the automation devices during use, each device should have an embedded automation bot that is responsible for its activity. As an example and in view of , one bot may be responsible for all lifter units, while another bot may be responsible for the central part of the conveyor system. A modular system (but necessarily with more devices and therefore more bots) would be the definition of one bot for each of the 12 units and the two workstations.","A bot consists of three main modules:\n\n","The properties of the automation bot specified for the method described here can be summarized in the following bullet points:\n\n","Additional information about these components and modules can be found in the research reports.","The goals of application for all physical systems explained in the preceding section and for the software tools and components are as follows:\n\n","The following subpoints describe the application procedures step by step.","According to another idea of the invention, the invention is based on an HL-PN-based approach and tools for development and application of orchestration engines embedded in automation systems.","Physical devices such as conveyors C-C and lifters L, L are presented to the network N as logic devices LD. These logic devices LD and their services S run on the STB controllers (even running on a few of them when defined at the PC gateway, e.g., RFIDs). The specification of the services S of the logic devices LD and their control logic CL is achieved by multiple procedures:\n\n","To start these services, a BootP\/DHCP server must be used to assign IP addresses to the devices. In this case, a BootP server was used with a configuration file comprising all STBs.","The following table summarizes all the available logic devices and their properties:",{"@attributes":{"id":"p-0151","num":"0208"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Physical Device","Logic Device","Service"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ID","Procedure","Descriptor Name","Type","WSDL"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["C1-C11","ControlBuild","01MDST#1, 02MDSC#2, 03MDST#3,","transfer type\/control","Transfer.wsdl"]},{"entry":[{},{},"04MDST#4, 05MDSC#5, 06MDST#6,",{},{}]},{"entry":[{},{},"07MDST*7, 08MDSC#8, 09MDST#9,",{},{}]},{"entry":[{},{},"10MDSC#10, 11MDSC#11",{},{}]},{"entry":["L1, L2","ControlBuild","01LIFTER#1, 02LIFTER#2","Lifter type\/control","Lifter.wsdl"]},{"entry":["RFIDs","PC Gateway","02_OSITrack#2, 04_OSITrack#4,","OSITrack","OSITrack.wsdl"]},{"entry":[{},{},"06_OSITrack#6, 08_OSITrack#8"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"To describe the services and make them usable for clients, more than one WSDL v1.1 (Web Services Descriptor Language) is used. The endpoints EP of the logic devices LD are associated with the corresponding service data listed below:",{"@attributes":{"id":"p-0153","num":"0210"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":["WSDL","Operation","Type","Input Parameter","Output Parameter","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Transfer.wsdl","TransferIn","In\/Out","direction(int) = 1,","response(int)","Starts a \u201cTransfer In\u201d"]},{"entry":[{},{},{},"2, 3 or 4","= 0 (OK)","procedure from the port"]},{"entry":[{},{},{},"(input port)","= 1 (occupied)","indicated. Immediately"]},{"entry":[{},{},{},{},"= 2 (unknown direction)","sends confirmation of"]},{"entry":[{},{},{},{},"= 3 (no pallet loaded)","whether or not a query is"]},{"entry":[{},{},{},{},"= 4 (pallet loaded)","possible."]},{"entry":[{},{},{},{},"= 5 (answer error)",{}]},{"entry":[{},"TransferStatus","Evout",{},"transferstatus(int)","An event is sent when a"]},{"entry":[{},{},{},{},"= 1 (occupied)","\u201cTransfer In\u201d process is"]},{"entry":[{},{},{},{},"= 5 (finished)","started or terminated."]},{"entry":[{},{},{},{},"= 666 (error)",{}]},{"entry":[{},"TransferOut","In\/Out","direction(int) = 1,","response(int)","Starts a \u201cTransfer Out\u201d"]},{"entry":[{},{},{},"2, 3 or 4","= 0 (OK)","process toward a stated"]},{"entry":[{},{},{},"(output port)","= 1 (occupied)","port. Sends confirmation"]},{"entry":[{},{},{},{},"= 2 (unknown direction)","immediately about"]},{"entry":[{},{},{},{},"= 3 (no pallet loaded)","whether or not a query is"]},{"entry":[{},{},{},{},"= 4 (pallet loaded)","possible."]},{"entry":[{},{},{},{},"= 5 (answer error)",{}]},{"entry":[{},"TransferStop","In\/Out",{},"response(int) = 0","Stops a \u201cTransfer In\/Out\u201d"]},{"entry":[{},{},{},{},"(OK)","process. Reason: The"]},{"entry":[{},{},{},{},{},"devices does not have any"]},{"entry":[{},{},{},{},{},"sensor capabilities to"]},{"entry":[{},{},{},{},{},"detect whether a pallet has"]},{"entry":[{},{},{},{},{},"left the conveyor of the device."]},{"entry":[{},"GetStatus","In\/Out",{},"response(int)","Stops a \u201cTransfer In\/Out\u201d"]},{"entry":[{},{},{},{},"= (3 no pallet loaded)","process. Reason: The"]},{"entry":[{},{},{},{},"= (4 pallet loaded)","device does not have any"]},{"entry":[{},{},{},{},{},"sensor capabilities to"]},{"entry":[{},{},{},{},{},"detect whether a pallet has"]},{"entry":[{},{},{},{},{},"left the conveyor of the device."]},{"entry":["Lifter.wsdl","IFtransferOUT","In\/Out","IPtransferOutParam(short) = 1,","OPtransferOutStatus(short)","Starts a \u201cTransfer Out\u201d"]},{"entry":[{},{},{},"2, 3 or 4","= 1, 2, 3 or 4 (ok)","process toward a given"]},{"entry":[{},{},{},{},"= 111 (no pallet loaded)","port. Sends confirmation"]},{"entry":[{},{},{},{},"= 700 (occupied)","immediately of whether"]},{"entry":[{},{},{},{},{},"or not a query is possible"]},{"entry":[{},"IFgetStatus","In\/Out","IPgetStatusParam(short) = 0","OPgetStatusResponse(short)","To receive the status from"]},{"entry":[{},{},{},{},"= 0 (no pallet loaded)","two conveyor sensors."]},{"entry":[{},{},{},{},"= 11 (pallet loaded)","Therefore it is possible to"]},{"entry":[{},{},{},{},"= 15 (1 sensor)","check on whether a"]},{"entry":[{},{},{},{},"= 51 (1 sensor)","completely loaded pallet"]},{"entry":[{},{},{},{},{},"(two sensors on), a"]},{"entry":[{},{},{},{},{},"partially loaded pallet"]},{"entry":[{},{},{},{},{},"(one sensor on) or no"]},{"entry":[{},{},{},{},{},"pallet (all sensors off) is"]},{"entry":[{},{},{},{},{},"present."]},{"entry":[{},"OFlifterA\/","Evout",{},"OPlifterAstatus(short)\/","An event is sent when an"]},{"entry":[{},"OFlifterB",{},{},"OPlifterBstatus(short)","operating process is"]},{"entry":[{},{},{},{},"= 10 (finished)","started or terminated."]},{"entry":[{},{},{},{},"= 700 (occupied)",{}]},{"entry":[{},{},{},{},"= 500 (manual)",{}]},{"entry":[{},{},{},{},"= 800 (terminated)",{}]},{"entry":[{},"IFinitialize","In\/Out","IPinitializeParam(short) = 0","OPinitializeStatus(short)","Reference movement is"]},{"entry":[{},{},{},{},"= 1 (OK)","executed. Should be"]},{"entry":[{},{},{},{},"= 10 (finished)","performed each time at"]},{"entry":[{},{},{},{},"= 500 (manual)","the start of the lifter"]},{"entry":[{},{},{},{},"= 700 (OK)","operation."]},{"entry":[{},{},{},{},"= 800 (terminated)",{}]},{"entry":[{},"IFtransferStop","In\/Out","IPtransferStopParam(short) = 0","OPtransferStopStatus(short) = 10","Stops a \u201cTransfer In\/Out\u201d"]},{"entry":[{},{},{},{},"(OK)","process."]},{"entry":[{},"IFtransferin","In\/Out","IPtransferInParam(short) = 1,","OPtransferInStatus(short)","Starts a \u201cTransfer In\u201d"]},{"entry":[{},{},{},"2, 3 or 4","= 1, 2, 3 or 4 (ok)","process from a given port."]},{"entry":[{},{},{},{},"= 333 (pallet loaded)","Sends notification"]},{"entry":[{},{},{},{},"= 700 (occupied)","immediately of whether"]},{"entry":[{},{},{},{},{},"or not a query is possible."]},{"entry":[{},"IFlifting","In\/Out","IPliftingPos(short) = 1,","OPliftingStatus(short)","The conveyor is raised or"]},{"entry":[{},{},{},"2, 3 or 4 (input\/output","= 1, 2, 3 or 4 (ok)","lowered depending on the"]},{"entry":[{},{},{},"port)","= 500 (manual)","port selected."]},{"entry":[{},{},{},{},"= 700 (occupied)",{}]},{"entry":[{},{},{},{},"= 800 (terminated)",{}]},{"entry":["OSITrack.wsdl","GetID","In\/Out",{},"id(string) = unique","Sends a command to the"]},{"entry":[{},{},{},{},"ID of the RFID label","module to read out the IP"]},{"entry":[{},{},{},{},{},"addresses."]},{"entry":[{},"Write","In\/Out","Registers2(Start(int),","Response(Identifier(int),","Writes to multiple"]},{"entry":[{},{},{},"Amount(int),","Info(string))","registers (0-55 free on the label)"]},{"entry":[{},{},{},"Value (string))",{},{}]},{"entry":[{},"Read","In\/Out","Registers(Start(int),","Response(Identifier(int),","Read multiple registers (0-55 free on"]},{"entry":[{},{},{},"Amount(int))","Info(string))","label)"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":"Notes:"},{"entry":"When using identification systems such as OSITrack, it is impossible to read\/write multiple registers with the current PC gateway implementation. However, no data except for the ID of the label is used for this application and no user-defined data is written to or read out of the label."},{"entry":"Lifters must first be initialized before they can use other operations (even in Event Subscription)."},{"entry":"TransferIn\/TransferOut operations are stopped automatically (and send an event accordingly) if the pallet has been completely loaded\/unloaded."},{"entry":"Manual placement of a pallet on a conveyer unit does not generate an event. The user must therefore initialize the process by retrieving the TransferOut(0) operation out of the orchestrator for the unit after the pallet has been placed."},{"entry":"After manual removal of a pallet from the conveyor unit, the TransferStop operation must be retrieved from the orchestrator to reset it at the device status."},{"entry":"WSDL, which was exported from ControlBuild tools, must be adapted because the type of port specified in the WSDL and the port offered by the service description are not the same."},{"entry":"The Device Descriptor Files DDF exported from ControlBuild are modified directly in the file system of the STB after deployment in order to set user-defined values for the device range and type."}]}}}}},"The message sequence of the transfer units (conveyors) C-C is expressed in  for the two operations TransferIn and TransferOut.","The message sequence of the lifters L, L is supplied in  for the three operations IFtransferIn, IFtransferOut and IFlifting.",{"@attributes":{"id":"p-0156","num":"0213"},"figref":"FIG. 25"},"Behavior models are generated as a function of the available elementary services S (and their operational procedures) as well as the assumed behavior of the devices. Editing processes of the control models were performed with the help of Continuum Development Studio.","The device approach and the interaction for each element are explained in .",{"@attributes":{"id":"p-0159","num":"0216"},"figref":["FIG. 27","FIG. 27"],"i":["a","b"]},"Notes on  ) and ):\n\n",{"@attributes":{"id":"p-0161","num":"0224"},"chemistry":{"@attributes":{"id":"CHEM-US-00001","num":"00001"},"img":{"@attributes":{"id":"EMI-C00001","he":"24.05mm","wi":"60.88mm","file":"US09134726-20150915-C00001.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}},"ul":{"@attributes":{"id":"ul0024","list-style":"none"},"li":{"@attributes":{"id":"ul0024-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0025","list-style":"none"},"li":["The manual placement\/removal of the pallets must be preceded by a \u201cget status\u201d query to reset the sensor data of the conveyor units.","When there are multiple input ports and output ports, provide branch connections according to  ).","In decisions at the workstations (either allow the pallet to pass through or perform an operational procedure on it) and the conflict points at C\/C (which path to select), changes must be made in the central part at the site of the conflict.  ) shows an example of the workstation W."]}}}},"Conflicts are nodes in the Petri-Net-modeled system, where alternative paths are to be selected. This means that more than one transition may actually be switched. This corresponds to a situation in which decisions must be made.","In general, to retrieve the Decision Support System DSS at a point in the net, the pallet ID must first be queried via the OSITrack service procedure GetID. The parameter of the query (id>p\u201cloaded\u201d.conflict_id) of the \u201cloaded\u201d part must be replaced with the ID of the location of the conflict (characterized in the example as \u201cloaded\u201d). Then the first places of each branch connection resulting from the conflict has a \u201cservices\u201d property with values of the services leading to this branch, separated by commas. This example shows the service \u201cws\u201d which stops the pallet and waits until a TransferOut is given by the workstation W (after conclusion of the operational procedure involving the pallet) and a \u201cstandard\u201d service for all other pallets which do not have any relationship to workstation . The responsible orchestration engine will stop at the \u201cloaded\u201d conflict in run time, will forward the pallet data to the Decision Support System DSS and will wait on a response (indicating which transition associated with a certain service is to be performed).\n\n","The following table shows the details for modeling each Petri Net model and the corresponding device.",{"@attributes":{"id":"p-0165","num":"0238"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},{},"Workstation",{},{}]},{"entry":[{},{},"(+manual",{},{}]},{"entry":[{},{},"placement\/",{},{}]},{"entry":[{},"Type of","removal of",{},{}]},{"entry":["Model","model","pallets)","Multiple I\/O","Conflicts"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["C1, C3, C5, C7,","transfer unit","no","no","no"]},{"entry":["C9, C10, C11",{},{},{},{}]},{"entry":["C2, C8","transfer unit","yes","no","yes"]},{"entry":["C4, C6","transfer unit","no","yes","yes"]},{"entry":["L1, L2","lifter","no","no","no"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"Analysis and validation of models are performed by means of the analysis function of the Continuum Development Studio. The analysis is based on a check and confirmation of static and dynamic model properties. The validation is based on an isomorphism between the model properties and specifications of the modeled service-oriented automation and production components and processes. If the model has a transition invariance, for example, and a \u201cliveliness property\u201d then the transition invariance corresponds to the existence of a basic path (basic service composition\/orchestration).","A separate inventive method for connecting behaviors\/orchestration models and generating orchestration services is described below.","The orchestration models may be interconnected in two different ways via the ports:\n\n","The connection strategy illustrated in  is used in this system. The composition tool is used to generate the model orchestration write (based on the models CM of the components C-C), orchestration middle (based on the models CM of the components C-C, L, L, C, C) and orchestration left (based on the models CM of the components C-C). The generated models communicate with one another (to perform transfer operational procedures of the pallets) by means of service retrieval (\u201cTransferIn\/TransferOut\u201d mechanism).","For the sake of simplicity and also to demonstrate the composition function in a standard and reusable manner, the generated orchestration service implements the same transfer interface as the conveyors with a few particular features (see [orch] device,  ) and )). Therefore, the orchestration services can be created just as progressively as the transfer units before them.","As soon as models are generated and validated, they can be used for configuration of the orchestration engine devices STB_PNE. This takes place by means of the Continuum Development System CDS and additional support to apply the data to the devices.","For the setup, only the application which responds in real time to the queries of the orchestration engine is executed.","The execution of the model is started on the basis of a service (transfer service) offered by the orchestration engine. Normally the execution starts immediately after deployment.",{"@attributes":{"id":"p-0174","num":"0249"},"figref":"FIG. 31"},"Details on the use cases:\n\n","The following table shows the functions that can be executed with the given approach and the proposed tools.",{"@attributes":{"id":"p-0177","num":"0264"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Functions"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"1. EMBEDDING WEB SERVICES IN INDUSTRIAL CONTROLS:"},{"entry":"1.1. Encapsulated device functionality through web services and embedded"},{"entry":"industrial controls (Schneider STB I\/O device) through DPWS stack."},{"entry":"1.2. Control of obsolete devices with service gateways (PC-based, for"},{"entry":"OSITrack RFID readers)."},{"entry":"2. SERVICE ORCHESTRATION:"},{"entry":"2.1. Model-based orchestration engines (Petri Net, higher level)"},{"entry":"embedded in industrial controls (Schneider STB I\/O device)."},{"entry":"2.2. Service orchestration at a low level while maintaining the topology"},{"entry":"of the mechatronic devices hosting these services."},{"entry":"3. CONFLICT RESOLUTION BY A PRODUCTION EXECUTION"},{"entry":"SYSTEM:"},{"entry":"3.1. Decision support at the point of conflict based on local data (services"},{"entry":"offered by mechatronic devices) and on the basis of data of a higher level"},{"entry":"(services offered pertaining to ongoing production orders and requests)."},{"entry":"4. BUSINESS INTEGRATION THROUGH WEB SERVICE"},{"entry":"INTERFACES:"},{"entry":"4.1. Updates of production orders and order status are sent from the"},{"entry":"ERP\/MES system to the work system."},{"entry":"4.2. Multi-corporate integration through cross layer and event-based"},{"entry":"architecture (SIA) for devices embedded in networks."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"According to a third inventive idea, the invention is based on a model-based Service Orchestration Engine associated with a Decision Support System.","The model-based Service Orchestration Engine utilizes a Petri Net dialect as the modeling and logic language: High-Level Petri Net (HL-PN). The HL-PN was expanded by adding elements for MAPPING web-service-specific properties directly ONTO the HL-PN model: service and data contracts as well as configuration of the DPWS discovery. However, these models may also be expanded by adding additional properties. In addition to DPWS-compatible web services, other message- and\/or event-oriented communication layers may also be configured.","Petri Nets are suitable for mapping competing and concurrent processes with distributed resources, which operate on a limited amount of hardware and software resources. The fundamental approach is to model each component of a system individually and furnish it with logic interfaces that allow (automated) composition of the model components to form an overall static model of the system. The model instances are then interconnected in accordance with the actual topology of the system. Due to the fact that the component models supply all the interfaces, the overall model contains all possible sequence paths in principle. On the example of a material flow system, this means that a system consisting of transport components will contain all flow paths that also permit physical transport of material by connecting the transport elements. In the trivial case, the system may contain linear paths and the process may thus take place more or less sequentially, but in more complex compositions, the process might contain a few paths having multiple bifurcations and connections, so that alternative sequence paths may be selected in run time. The bifurcations and connections in such complex processes are modeled as conflict nodes in the Petri Net. Conflicts in a Petri Net model may have different meanings in a real system. For example, a pallet could be transported on a transport element in various directions or two subprocesses might \u201ccompete\u201d for the same resource.","Some problems can be solved by simple algorithms, e.g., random selection of a process path, but such approaches are not efficient from a global standpoint or they may even be harmful for certain topologies because deadlocks occur there and the process is blocked. It is thus clear that subprocesses may be synchronized to a limited extent not only locally but also in an expanded context. These problems are not new and are at least partially solved by Enterprise Resource Planning ERP\/Production Execution System (MES) [sic; PES].","For the orchestration engine and an \u201corchestrated\u201d system of services, an architecture that enables a separation of the decision algorithms and the service orchestration was selected. There is a special interface between the orchestration engine and the so-called Decision Support System to exchange decision questions, answers and metadata for decision making. At the orchestration level, so-called local decisions are made based on simple algorithms and they intervene, for example, to resolve conflicts quickly when the higher-level Decision Support System (DSS) has not made a decision. Thus at a lower level decisions which are based purely on knowledge of the models and the current status of the models are made.","From the standpoint of orchestration (bottom-up), the DSS encapsulates the upper systems as a service for decision making without knowing which algorithms the decision is based on.","From the standpoint of Enterprise Resource Planning (ERP) (top-down), the DSS encapsulates the production, i.e., manufacturing system as a Manufacturing Execution System (MES) service with interfaces for receipt of production orders and for production monitoring. The ERP system has no detailed knowledge of the automation processes but has knowledge only about production orders and their status.","Example according to : For an electronic assembly production system PS a Production Execution System PES component (production execution=PE) which supplies an interface DSS_I for the service orchestration OE and the interface ERP_I for an Enterprise Resource Planning System ERP was developed. An ERP system is thus capable of sending production orders to the Production Execution System PES. The production system uses pallets P, which can send unfinished products to various workstations W, W for processing. The \u201cconflict nodes\u201d in the model refer to, among other things, the locations where transport elements C-C have multiple inputs and outputs and can carry pallets P to different workstations W, W. The production system PS detects and identifies pallets P based on RFID tags OSI containing the pallet ID. With the help of the pallet ID, at conflict points, the production system PS can ask the Production Execution System PES via the DSS interface where the pallet is to be sent. The Production Execution System PES has identified the product belonging to the pallet P, its processing status and the next working steps on the basis of knowledge of all ongoing orders, all production processes, the utilization of the workstations (instantaneous and planned), the availability of production resources, so the Production Execution System PES can decide to which workstation the product is to be sent.",{"@attributes":{"id":"p-0186","num":"0000"},"ul":{"@attributes":{"id":"ul0032","list-style":"none"},"li":["API Application Programming Interface","BPEL Business Process Execution Language","BPML Business Process Management Language","CMIP Common Management Information Protocol","CMIS Common Management Information Services","CPU Central Processing Unit","DPWS Devices Profile for Web Services","DSS Decision Support System","DTD Document Type Definition","ERP Enterprise Resource Planning","FIPA Foundation for Intelligent Physical Agents","HTTP Hypertext Transfer Protocol","IP Internet Protocol","MAS Multi-Agent System","OPC Open Connectivity, ehemals \u201cOLE for Process Control\u201d","OPC-UA OPC Unified Architecture","OWL Web Ontology Language","OWL-S Upper Ontology for Semantic Web Services","QoS Quality of Service","RFID Radio-Frequency IDentification","SOA Service-oriented Architecture","SOAP ehemals Simple Object Access Protocol","SWRL Semantic Web Rule Language","SWS Semantic Web Services","SWSO Semantic Web Service Ontology","TCP Transport Control Protocol","UDP User Datagram Protocol","UML Unified Modeling Language","URI Uniform Resource Identifier Web Based Enterprise Management","WS\u2014Business Process Execution Language","BPEL for Web Services","WSCI Web Services Choreography Interface","WSDL Web Service Description Language","WSDM Web Services Distributed Management","WSMO Web Service Modeling Ontology","WSO Web Service Orchestration","WSOL Web Service Orchestration Language","XML eXtensible Markup Language"]}}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"p":["Additional details, advantages and features of the invention are derived not only from the claims and the features to be derived from them\u2014individually or in combination\u2014but also from the following description of preferred exemplary embodiments to be derived from the drawings.","They show:",{"@attributes":{"id":"p-0026","num":"0030"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0027","num":"0031"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0028","num":"0032"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0029","num":"0033"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0030","num":"0034"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0031","num":"0035"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0032","num":"0036"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0033","num":"0037"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0034","num":"0038"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0035","num":"0039"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0036","num":"0040"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0037","num":"0041"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0038","num":"0042"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0039","num":"0043"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0040","num":"0044"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0041","num":"0045"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0042","num":"0046"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0043","num":"0047"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0044","num":"0048"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0045","num":"0049"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0046","num":"0050"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0047","num":"0051"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0048","num":"0052"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0049","num":"0053"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0050","num":"0054"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0051","num":"0055"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0052","num":"0056"},"figref":"FIG. 27","i":["a","d"]},{"@attributes":{"id":"p-0053","num":"0057"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0054","num":"0058"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0055","num":"0059"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0056","num":"0060"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0057","num":"0061"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0058","num":"0062"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0059","num":"0063"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0060","num":"0064"},"figref":"FIG. 35"}]},"DETDESC":[{},{}],"heading":"ABBREVIATIONS"}
