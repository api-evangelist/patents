---
title: Push pull adaptive capture
abstract: In various embodiments, a screen image may be divided into rectangles, and a capture component may track changed rectangles and capture the screen upon receiving an indication. For small screen updates, the capture rate may be set to Ëœ30 captures per second to provide a lower latency. As the screen update size increases, the capture rate may be decreased to match an allocated bandwidth. The capture rate may be increased when available bandwidth increases and decreased as bandwidth decreases. For example, the capture rate may be decreased when downstream back pressure meets predefined criteria. The capture rate change may be effected gradually to avoid jerks and jumps. Varying the capture rate by also enable audio/video synchronization with varying bandwidth variations. Some embodiments may be extended to multiple monitor solutions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09146884&OS=09146884&RS=09146884
owner: Microsoft Technology Licensing, LLC
number: 09146884
owner_city: Redmond
owner_country: US
publication_date: 20091210
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Computing Environments in General Terms"],"p":["Remote computing systems can enable users to remotely access hosted resources. Servers on the remote computing systems can execute programs and transmit signals indicative of a user interface to clients that can connect by sending signals over a network conforming to a communication protocol such as the TCP\/IP protocol. Each connecting client may be provided a remote presentation session, i.e., an execution environment that includes a set of resources. Each client can transmit signals indicative of user input to the server and the server can apply the user input to the appropriate session. The clients may use remote presentation protocols such as the Remote Desktop Protocol (RDP) to connect to a server resource.","In a server-based computing environment, the rendering and management of the client desktops and the subsequent transmission to the remote client requires a great deal of resources. Such resources include computational cycles, memory for frame buffers, and network bandwidth. Furthermore, current systems may not effectively address network bandwidth issues. For example, in some systems every captured frame may be compressed. If the network is congested, then frames may be dropped and queued frames may only be sent when the network resources are eventually freed. As the server scalability continues to increase, better and more efficient ways of managing this process is needed. Thus, other techniques are needed in the art to solve the above described problems.","In various embodiments, methods and systems are disclosed for adjusting the rate at which graphics data is processed as a function of downstream conditions. The user experience for clients using a remote presentation session may be improved in areas such as: low latency when entering text; responsive mouse and cursor movement; responsive window pop-up, dragging, minimize and maximize; improved scroll experience on documents; synchronized audio and video; and minimization of choppy\/jerky screen updates.","In an embodiment, a screen image may be divided into rectangles, and a capture component may track changed rectangles and capture the screen upon receiving an indication. For small screen updates, the capture rate may be set to \u02dc30 captures per second to provide a lower latency. As the screen update size increases, the capture rate may be decreased to match an allocated bandwidth. The capture rate may be increased when available bandwidth increases and decreased as bandwidth decreases. For example, the capture rate may be decreased when downstream back pressure meets predefined criteria. The capture rate change may be effected gradually to avoid jerks and jumps in the rendered image. Varying the capture rate may also enable audio\/video synchronization with varying bandwidth variations. Some embodiments may be extended to multiple monitor solutions.","In addition to the foregoing, other aspects are described in the claims, drawings, and text forming a part of the present disclosure. It can be appreciated by one of skill in the art that one or more various aspects of the disclosure may include but are not limited to circuitry and\/or programming for effecting the herein-referenced aspects of the present disclosure; the circuitry and\/or programming can be virtually any combination of hardware, software, and\/or firmware configured to effect the herein-referenced aspects depending upon the design choices of the system designer.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter. Furthermore, the claimed subject matter is not limited to implementations that solve any or all disadvantages noted in any part of this disclosure.","Certain specific details are set forth in the following description and figures to provide a thorough understanding of various embodiments of the disclosure. Certain well-known details often associated with computing and software technology are not set forth in the following disclosure to avoid unnecessarily obscuring the various embodiments of the disclosure. Further, those of ordinary skill in the relevant art will understand that they can practice other embodiments of the disclosure without one or more of the details described below. Finally, while various methods are described with reference to steps and sequences in the following disclosure, the description as such is for providing a clear implementation of embodiments of the disclosure, and the steps and sequences of steps should not be taken as required to practice this disclosure.","It should be understood that the various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the disclosure, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the disclosure. In the case of program code execution on programmable computers, the computing device generally includes a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may implement or utilize the processes described in connection with the disclosure, e.g., through the use of an application programming interface (API), reusable controls, or the like. Such programs are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","A remote desktop system is a computer system that maintains applications that can be remotely executed by client computer systems. Input is entered at a client computer system and transferred over a network (e.g., using protocols based on the International Telecommunications Union (ITU) T.120 family of protocols such as Remote Desktop Protocol (RDP)) to an application on a terminal server. The application processes the input as if the input were entered at the terminal server. The application generates output in response to the received input and the output is transferred over the network to the client","Embodiments may execute on one or more computers.  and the following discussion are intended to provide a brief general description of a suitable computing environment in which the disclosure may be implemented. One skilled in the art can appreciate that computer systems ,  can have some or all of the components described with respect to computer  of .","The term circuitry used throughout the disclosure can include hardware components such as hardware interrupt controllers, hard drives, network adaptors, graphics processors, hardware based video\/audio codecs, and the firmware\/software used to operate such hardware. The term circuitry can also include microprocessors configured to perform function(s) by firmware or by switches set in a certain way or one or more logical processors, e.g., one or more cores of a multi-core general processing unit. The logical processor(s) in this example can be configured by software instructions embodying logic operable to perform function(s) that are loaded from memory, e.g., RAM, ROM, firmware, and\/or virtual memory. In example embodiments where circuitry includes a combination of hardware and software an implementer may write source code embodying logic that is subsequently compiled into machine readable code that can be executed by a logical processor. Since one skilled in the art can appreciate that the state of the art has evolved to a point where there is little difference between hardware, software, or a combination of hardware\/software, the selection of hardware versus software to effectuate functions is merely a design choice. Thus, since one of skill in the art can appreciate that a software process can be transformed into an equivalent hardware structure, and a hardware structure can itself be transformed into an equivalent software process, the selection of a hardware implementation versus a software implementation is trivial and left to an implementer.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1","b":["20","21","22","23","21","23","24","25","26","20","24","20","27","28","29","30","31","24","25","29","31","21","27","28","30","23","32","33","34","20","29","31"]},"A number of program modules may be stored on the hard disk, magnetic disk , optical disk , ROM  or RAM , including an operating system , one or more application programs , other program modules  and program data . A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite disk, scanner or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or universal serial bus (USB). A display  or other type of display device can also be connected to the system bus  via an interface, such as a video adapter . In addition to the display , computers typically include other peripheral output devices (not shown), such as speakers and printers. The system of  also includes a host adapter , Small Computer System Interface (SCSI) bus , and an external storage device  connected to the SCSI bus .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be another computer, a server, a router, a network PC, a peer device or other common network node, a virtual machine, and typically can include many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  can include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  can be connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  can typically include a modem  or other means for establishing communications over the wide area network , such as the Internet. The modem , which may be internal or external, can be connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are examples and other means of establishing a communications link between the computers may be used. Moreover, while it is envisioned that numerous embodiments of the disclosure are particularly well-suited for computer systems, nothing in this document is intended to limit the disclosure to such embodiments.","Referring now to , another embodiment of an exemplary computing system  is depicted. Computer system  can include a logical processor , e.g., an execution core. While one logical processor  is illustrated, in other embodiments computer system  may have multiple logical processors, e.g., multiple execution cores per processor substrate and\/or multiple processor substrates that could each have multiple execution cores. As shown by the figure, various computer readable storage media  can be interconnected by one or more system busses which couples various system components to the logical processor . The system buses may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. In example embodiments the computer readable storage media  can include for example, random access memory (RAM) , storage device , e.g., electromechanical hard drive, solid state hard drive, etc., firmware , e.g., FLASH RAM or ROM, and removable storage devices  such as, for example, CD-ROMs, floppy disks, DVDs, FLASH drives, external storage devices, etc. It should be appreciated by those skilled in the art that other types of computer readable storage media can be used such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges.","The computer readable storage media provide non volatile storage of processor executable instructions , data structures, program modules and other data for the computer . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within the computer system , such as during start up, can be stored in firmware . A number of programs may be stored on firmware , storage device , RAM , and\/or removable storage devices , and executed by logical processor  including an operating system and\/or application programs.","Commands and information may be received by computer  through input devices  which can include, but are not limited to, a keyboard and pointing device. Other input devices may include a microphone, joystick, game pad, scanner or the like. These and other input devices are often connected to the logical processor  through a serial port interface that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or universal serial bus (USB). A display or other type of display device can also be connected to the system bus via an interface, such as a video adapter which can be part of, or connected to, a graphics processor . In addition to the display, computers typically include other peripheral output devices (not shown), such as speakers and printers. The exemplary system of  can also include a host adapter, Small Computer System Interface (SCSI) bus, and an external storage device connected to the SCSI bus.","Computer system  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer. The remote computer may be another computer, a server, a router, a network PC, a peer device or other common network node, and typically can include many or all of the elements described above relative to computer system .","When used in a LAN or WAN networking environment, computer system  can be connected to the LAN or WAN through a network interface card . The NIC , which may be internal or external, can be connected to the system bus. In a networked environment, program modules depicted relative to the computer system , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections described here are exemplary and other means of establishing a communications link between the computers may be used. Moreover, while it is envisioned that numerous embodiments of the present disclosure are particularly well-suited for computerized systems, nothing in this document is intended to limit the disclosure to such embodiments.","A remote desktop system is a computer system that maintains applications that can be remotely executed by client computer systems. Input is entered at a client computer system and transferred over a network (e.g., using protocols based on the International Telecommunications Union (ITU) T.120 family of protocols such as Remote Desktop Protocol (RDP)) to an application on a terminal server. The application processes the input as if the input were entered at the terminal server. The application generates output in response to the received input and the output is transferred over the network to the client computer system. The client computer system presents the output data. Thus, input is received and output presented at the client computer system, while processing actually occurs at the terminal server. A session can include a shell and a user interface such as a desktop, the subsystems that track mouse movement within the desktop, the subsystems that translate a mouse click on an icon into commands that effectuate an instance of a program, etc. In another example embodiment the session can include an application. In this example while an application is rendered, a desktop environment may still be generated and hidden from the user. It should be understood that the foregoing discussion is exemplary and that the presently disclosed subject matter may be implemented in various client\/server environments and not limited to a particular terminal services product.","In most, if not all remote desktop environments, input data (entered at a client computer system) typically includes mouse and keyboard data representing commands to an application and output data (generated by an application at the terminal server) typically includes video data for display on a video output device. Many remote desktop environments also include functionality that extend to transfer other types of data.","Communications channels can be used to extend the RDP protocol by allowing plug-ins to transfer data over an RDP connection. Many such extensions exist. Features such as printer redirection, clipboard redirection, port redirection, etc., use communications channel technology. Thus, in addition to input and output data, there may be many communications channels that need to transfer data. Accordingly, there may be occasional requests to transfer output data and one or more channel requests to transfer other data contending for available network bandwidth.","Referring now to , depicted are high level block diagrams of computer systems configured to effectuate virtual machines. As shown in the figures, computer system  can include elements described in  and components operable to effectuate virtual machines. One such component is a hypervisor  that may also be referred to in the art as a virtual machine monitor. The hypervisor  in the depicted embodiment can be configured to control and arbitrate access to the hardware of computer system . Broadly stated, the hypervisor  can generate execution environments called partitions such as child partition  through child partition N (where N is an integer greater than or equal to 1). In embodiments a child partition can be considered the basic unit of isolation supported by the hypervisor , that is, each child partition can be mapped to a set of hardware resources, e.g., memory, devices, logical processor cycles, etc., that is under control of the hypervisor  and\/or the parent partition and hypervisor  can isolate one partition from accessing another partition's resources. In embodiments the hypervisor  can be a stand-alone software product, a part of an operating system, embedded within firmware of the motherboard, specialized integrated circuits, or a combination thereof.","In the above example, computer system  includes a parent partition  that can also be thought of as domain  in the open source community. Parent partition  can be configured to provide resources to guest operating systems executing in child partitions -N by using virtualization service providers  (VSPs) that are also known as back-end drivers in the open source community. In this example architecture the parent partition  can gate access to the underlying hardware. The VSPs  can be used to multiplex the interfaces to the hardware resources by way of virtualization service clients (VSCs) that are also known as front-end drivers in the open source community. Each child partition can include one or more virtual processors such as virtual processors  through  that guest operating systems  through  can manage and schedule threads to execute thereon. Generally, the virtual processors  through  are executable instructions and associated state information that provide a representation of a physical processor with a specific architecture. For example, one virtual machine may have a virtual processor having characteristics of an Intel x86 processor, whereas another virtual processor may have the characteristics of a PowerPC processor. The virtual processors in this example can be mapped to logical processors of the computer system such that the instructions that effectuate the virtual processors will be backed by logical processors. Thus, in these example embodiments, multiple virtual processors can be simultaneously executing while, for example, another logical processor is executing hypervisor instructions. Generally speaking, and as illustrated by the figures, the combination of virtual processors, various VSCs, and memory in a partition can be considered a virtual machine such as virtual machine  or .","Generally, guest operating systems  through  can include any operating system such as, for example, operating systems from Microsoft\u00ae, Apple\u00ae, the open source community, etc. The guest operating systems can include user\/kernel modes of operation and can have kernels that can include schedulers, memory managers, etc. A kernel mode can include an execution mode in a logical processor that grants access to at least privileged processor instructions. Each guest operating system  through  can have associated file systems that can have applications stored thereon such as terminal servers, e-commerce servers, email servers, etc., and the guest operating systems themselves. The guest operating systems - can schedule threads to execute on the virtual processors - and instances of such applications can be effectuated.","Referring now to , illustrated is an alternative architecture that can be used to effectuate virtual machines.  depicts similar components to those of , however in this example embodiment the hypervisor  can include the virtualization service providers  and device drivers , and parent partition  may contain configuration utilities . In this architecture, hypervisor  can perform the same or similar functions as the hypervisor  of . The hypervisor  of  can be a stand alone software product, a part of an operating system, embedded within firmware of the motherboard or a portion of hypervisor  can be effectuated by specialized integrated circuits. In this example parent partition  may have instructions that can be used to configure hypervisor  however hardware access requests may be handled by hypervisor  instead of being passed to parent partition .","Referring now to , computer  may include circuitry configured to provide remote desktop services to connecting clients. In an example embodiment, the depicted operating system  may execute directly on the hardware or a guest operating system  or  may be effectuated by a virtual machine such as VM  or VM . The underlying hardware , , , , and  is indicated in the illustrated type of dashed lines to identify that the hardware can be virtualized.","Remote services can be provided to at least one client such as client  (while one client is depicted remote services can be provided to more clients.) The example client  can include a computer terminal that is effectuated by hardware configured to direct user input to a remote server session and display user interface information generated by the session. In another embodiment, client  can be effectuated by a computer that includes similar elements as those of computer  . In this embodiment, client  can include circuitry configured to effect operating systems and circuitry configured to emulate the functionality of terminals, e.g., a remote desktop client application that can be executed by one or more logical processors . One skilled in the art can appreciate that the circuitry configured to effectuate the operating system can also include circuitry configured to emulate a terminal.","Each connecting client can have a session (such as session ) which allows the client to access data and applications stored on computer . Generally, applications and certain operating system components can be loaded into a region of memory assigned to a session. Thus, in certain instances some OS components can be spawned N times (where N represents the number of current sessions). These various OS components can request services from the operating system kernel  which can, for example, manage memory; facilitate disk reads\/writes; and configure threads from each session to execute on the logical processor . Some example subsystems that can be loaded into session space can include the subsystems that generates desktop environments, the subsystems that track mouse movement within the desktop, the subsystems that translate mouse clicks on icons into commands that effectuate an instance of a program, etc. The processes that effectuate these services, e.g., tracking mouse movement, are tagged with an identifier associated with the session and are loaded into a region of memory that is allocated to the session.","A session can be generated by a session manager , e.g., a process. For example, the session manager  can initialize and manage each remote session by generating a session identifier for a session space; assigning memory to the session space; and generating system environment variables and instances of subsystem processes in memory assigned to the session space. The session manager  can be invoked when a request for a remote desktop session is received by the operating system .","A connection request can first be handled by a transport stack , e.g., a remote desktop protocol (RDP) stack. The transport stack  instructions can configure logical processor  to listen for connection messages on a certain port and forward them to the session manager . When sessions are generated the transport stack  can instantiate a remote desktop protocol stack instance for each session. Stack instance  is an example stack instance that can be generated for session . Generally, each remote desktop protocol stack instance can be configured to route output to an associated client and route client input to an environment subsystem  for the appropriate remote session.","As shown by the figure, in an embodiment an application  (while one is shown others can also execute) can execute and generate an array of bits. The array can be processed by a graphics interface  which in turn can render bitmaps, e.g., arrays of pixel values, that can be stored in memory. As shown by the figure, a remote display subsystem  can be instantiated which can capture rendering calls and send the calls over the network to client  via the stack instance  for the session.","In addition to remoting graphics and audio, a plug and play redirector  can also be instantiated in order to remote diverse devices such as printers, mp3 players, client file systems, CD ROM drives, etc. The plug and play redirector  can receive information from a client side component which identifies the peripheral devices coupled to the client . The plug and play redirector  can then configure the operating system  to load redirecting device drivers for the peripheral devices of the client . The redirecting device drivers can receive calls from the operating system  to access the peripherals and send the calls over the network to the client .","As discussed above, clients may use a protocol for providing remote presentation services such as Remote Desktop Protocol (RDP) to connect to a resource using terminal services. When a remote desktop client connects to a terminal server via a terminal server gateway, the gateway may open a socket connection with the terminal server and redirect client traffic on the remote presentation port or a port dedicated to remote access services. The gateway may also perform certain gateway specific exchanges with the client using a terminal server gateway protocol transmitted over HTTPS.","Turning to , depicted is a computer system  including circuitry for effectuating remote services and for incorporating aspects of the present disclosure. As shown by the figure, in an embodiment a computer system  can include components similar to those described in  and , and can effectuate a remote presentation session. In an embodiment of the present disclosure a remote presentation session can include aspects of a console session, e.g., a session spawned for a user using the computer system, and a remote session. Similar to that described above, the session manager  can initialize and manage the remote presentation session by enabling\/disabling components in order to effectuate a remote presentation session.","One set of components that can be loaded in a remote presentation session are the console components that enable high fidelity remoting, namely, the components that take advantage of 3D graphics and 2D graphics rendered by 3D hardware.","3D\/2D graphics rendered by 3D hardware can be accessed using a driver model that includes a user mode driver , an API , a graphics kernel , and a kernel mode driver . An application  (or any other process such as a user interface that generates 3D graphics) can generate API constructs and send them to an application programming interface  (API) such as Direct3D from Microsoft\u00ae. The API  in turn can communicate with a user mode driver  which can generates primitives, e.g., the fundamental geometric shapes used in computer graphics represented as vertices and constants which are used as building blocks for other shapes, and stores them in buffers, e.g., pages of memory. In one embodiment the application  can declare how it is going to use the buffer, e.g., what type of data it is going to store in the buffer. An application, such as a videogame, may use a dynamic buffer to store primitives for an avatar and a static buffer for storing data that will not change often such as data that represents a building or a forest.","Continuing with the description of the driver model, the application can fill the buffers with primitives and issue execute commands. When the application issues an execute command the buffer can be appended to a run list by the kernel mode driver  and scheduled by the graphics kernel scheduler . Each graphics source, e.g., application or user interface, can have a context and its own run list. The graphics kernel  can be configured to schedule various contexts to execute on the graphics processing unit . The GPU scheduler  can be executed by logical processor  and the scheduler  can issue a command to the kernel mode driver  to render the contents of the buffer. The stack instance  can be configured to receive the command and send the contents of the buffer over the network to the client  where the buffer can be processed by the GPU of the client.","Illustrated now is an example of the operation of a virtualized GPU as used in conjunction with an application that calls for remote presentation services. Referring to , in an embodiment a virtual machine session can be generated by a computer . For example, a session manager  can be executed by a logical processor  and a remote session that includes certain remote components can be initialized. In this example the spawned session can include a kernel , a graphics kernel , a user mode display driver , and a kernel mode display driver . The user mode driver  can generate graphics primitives that can be stored in memory. For example, the API  can include interfaces that can be exposed to processes such as a user interface for the operating system  or an application . The process can send high level API commands such as such as Point Lists, Line Lists, Line Strips, Triangle Lists, Triangle Strips, or Triangle Fans, to the API . The API  can receive these commands and translate them into commands for the user mode driver  which can then generate vertices and store them in one or more buffers. The GPU scheduler  can run and determine to render the contents of the buffer. In this example the command to the graphics processing unit  of the server can be captured and the content of the buffer (primitives) can be sent to client  via network interface card . In an embodiment, an API can be exposed by the session manager  that components can interface with in order to determine whether a virtual GPU is available.","In an embodiment a virtual machine such as virtual machine  of  or  can be instantiated and the virtual machine can serve as a platform for execution for the operating system . Guest operating system  can embody operating system  in this example. A virtual machine may be instantiated when a connection request is received over the network. For example, the parent partition  may include an instance of the transport stack  and may be configured to receive connection requests. The parent partition  may initialize a virtual machine in response to a connection request along with a guest operating system including the capabilities to effectuate remote sessions. The connection request can then be passed to the transport stack  of the guest operating system . In this example each remote session may be instantiated on an operating system that is executed by its own virtual machine.","In one embodiment a virtual machine can be instantiated and a guest operating system  embodying operating system  can be executed. Similar to that described above, a virtual machine may be instantiated when a connection request is received over the network. Remote sessions may be generated by an operating system. The session manager  can be configured to determine that the request is for a session that supports 3D graphics rendering and the session manager  can load a console session. In addition to loading the console session the session manager  can load a stack instance \u2032 for the session and configure system to capture primitives generated by a user mode display driver .","The user mode driver  may generate graphics primitives that can be captured and stored in buffers accessible to the transport stack . A kernel mode driver  can append the buffers to a run list for the application and a GPU scheduler  can run and determine when to issue render commands for the buffers. When the scheduler  issues a render command the command can be captured by, for example, the kernel mode driver  and sent to the client  via the stack instance \u2032.","The GPU scheduler  may execute and determine to issue an instruction to render the content of the buffer. In this example the graphics primitives associated with the instruction to render can be sent to client  via network interface card .","In an embodiment, at least one kernel mode process can be executed by at least one logical processor  and the at least one logical processor  can synchronize rendering vertices stored in different buffers. For example, a graphics processing scheduler , which can operate similarly to an operating system scheduler, can schedule GPU operations. The GPU scheduler  can merge separate buffers of vertices into the correct execution order such that the graphics processing unit of the client  executes the commands in an order that allows them to be rendered correctly.","One or more threads of a process such as a videogame may map multiple buffers and each thread may issue a draw command. Identification information for the vertices, e.g., information generated per buffer, per vertex, or per batch of vertices in a buffer, can be sent to the GPU scheduler . The information may be stored in a table along with identification information associated with vertices from the same, or other processes and used to synchronize rendering of the various buffers.","An application such as a word processing program may execute and declare, for example, two buffers\u2014one for storing vertices for generating 3D menus and the other one storing commands for generating letters that will populate the menus. The application may map the buffer and; issue draw commands. The GPU scheduler  may determine the order for executing the two buffers such that the menus are rendered along with the letters in a way that it would be pleasing to look at. For example, other processes may issue draw commands at the same or a substantially similar time and if the vertices were not synchronized vertices from different threads of different processes could be rendered asynchronously on the client  thereby making the final image displayed seem chaotic or jumbled.","A bulk compressor  can be used to compress the graphics primitives prior to sending the stream of data to the client . In an embodiment the bulk compressor  can be a user mode (not shown) or kernel mode component of the stack instance  and can be configured to look for similar patterns within the stream of data that is being sent to the client . In this embodiment, since the bulk compressor  receives a stream of vertices, instead of receiving multiple API constructs, from multiple applications, the bulk compressor  has a larger data set of vertices to sift through in order to find opportunities to compress. That is, since the vertices for a plurality of processes are being remoted, instead of diverse API calls, there is a larger chance that the bulk compressor  will be able to find similar patterns in a given stream.","In an embodiment, the graphics processing unit  may be configured to use virtual addressing instead of physical addresses for memory. Thus, the pages of memory used as buffers can be paged to system RAM or to disk from video memory. The stack instance \u2032 can be configured to obtain the virtual addresses of the buffers and send the contents from the virtual addresses when a render command from the graphics kernel  is captured.","An operating system  may be configured, e.g., various subsystems and drivers can be loaded to capture primitives and send them to a remote computer such as client . Similar to that described above, a session manager  can be executed by a logical processor  and a session that includes certain remote components can be initialized. In this example the spawned session can include a kernel , a graphics kernel , a user mode display driver , and a kernel mode display driver .","A graphics kernel may schedule GPU operations. The GPU scheduler  can merge separate buffers of vertices into the correct execution order such that the graphics processing unit of the client  executes the commands in an order that allows them to be rendered correctly.","All of these variations for implementing the above mentioned partitions are just exemplary implementations, and nothing herein should be interpreted as limiting the disclosure to any particular virtualization aspect.","Adaptive Capture","The process of compressing, encoding and decoding graphics data as referring to herein may generally use one or more methods and systems described in commonly assigned U.S. Pat. No. 7,460,725 entitled \u201cSystem And Method For Effectively Encoding And Decoding Electronic Information,\u201d hereby incorporated by reference in its entirety.","In various methods and systems disclosed herein, improvements to the processing and handling of the various processes described above may be used to provide more efficient processing and thus a more timely and rich user experience. The methods and systems also provide for improvements in providing such graphics support when the network and\/or system resources become congested or otherwise less available. The embodiments disclosed herein for rendering, encoding and transmitting graphics data may be implemented using various combinations of hardware and software processes. In some embodiments, functions may be executed entirely in hardware. In other embodiments, functions may be performed entirely in software. In yet further embodiments, functions may be implemented using a combination of hardware and software processes. Such processes may further be implemented using one or more CPUs and\/or one or more specialized processors such as a graphics processing unit (GPU) or other dedicated graphics rendering devices.","Referring to , illustrated is an overview of various functions associated with the rendering and encoding processes discussed herein. Various aspects of the illustrated process may be modified to improve the throughput and efficiency of the processes. Process  illustrates the capturing and buffering of a client frame. Process  illustrates that under certain circumstances it may be advantageous to drop a captured frame. The term dropping may include ignoring the captured data in favor of the next captured frame data, clearing the buffers of the captured data, and the like. Process  illustrates that the captured frame may be analyzed to determine if differences exist compared to the previously captured frame. Process  illustrates the process of encoding the changed tiles of a frame. Process  illustrates that under certain circumstances it may be advantageous to drop a frame that has been encoded and is ready to transmit. The term dropping may include ignoring the encoded data in favor of the next encoded frame, clearing the transmit buffers of the encoded data, and the like. Once transmitted, process  illustrates that the received tiles may be decoded. Process  illustrates that the receive buffers may be managed to track changed tiles. Process  illustrates that the display frame buffers may be used to drive the display controller in an efficient manner.","In an embodiment, the capture rate of the graphics source data may be adjusted in response to current system and network limitations. For example, during the course of a remote desktop application, encoded data queued for transmission may be delayed due to network congestion. The continued queuing and delay of the transmissions may result in data being lost when the transmit buffers become full and new data is not stored. Likewise, if the new data is not merged with existing data, the new data may be lost and the queued data, once transmitted, may be stale due to the transmit delay. When a new frame is transmitted after one or more frames have been lost due to the network congestion, the result may be a jerky or otherwise poor quality video on the client side.","In one embodiment, a capture component may be configured to track changed rectangles and upon receiving an indication to capture, capture the screen. The capture component may be part of a render\/capture\/compress subsystem. In one embodiment, the capture rate may be adjusted as a function of the amount of changes on the user screen. For example, for small screen updates, the capture rate may be set at \u02dc30 captures per second. Keeping in mind that captured screens are analyzed and that only the changed areas are compressed and transmitted, then it can be seen that a captured screen with only a small amount of change will result in, for example, one screen tile being identified as a changed tile. Since the number of tiles to be compressed is small and the resulting latency is expected to be small, then the best user experience may be achieved by using a higher capture rate. An example of when a user screen may exhibit small screen changes is when a user is typing and only a small screen area is being updated to reflect the typed characters.","As the update size increases, the capture rate may be decreased, if necessary, to match the allocated bandwidth. Similarly, the capture rate may be increased if the system determines that more bandwidth is available. For example, if the downstream back pressure results in the client being unable to pull or consume the captured and compressed screen updates, then the capture rate may be decreased.","In various embodiments, the capture rate change may be gradually effected in order to avoid sudden changes and thus cause undesired effects on the user screen such as a jerky image.","The implementation of the disclosed subject matter may allow for an improvement of the user experience by providing the capability of dynamically adjusting the capture rate and minimizing the effects of network constraints on the user experience. For example, the techniques herein may enable audio video synchronization with varying network bandwidth variations.","The capture component of the render\/capture\/compress function may filter calls directed to the video driver and make determinations to capture screen information. Referring to , illustrated is an example scenario describing frame capture events. Depicted are a series of epochs 800 F to FN during which frame data may be captured. At time t, a first capture may be taken. At t, a second capture may be taken. During the first capture at t, the entire screen may be captured. Since no previous captures have been taken, all of the tiles or rectangles that together form the entire screen may be compressed and transmitted. At t only the changes need be captured and\/or compressed and tracked. The list of changed rectangles then define the scope or boundary of the screen update.","In one embodiment, a two-level mechanism may be used to determine the scope of the screen changes and to track the changes. At a first level, the captured screen may be divided into one or more rectangles or tiles of a predetermined size that generally includes a region of the screen that has changed since a previous screen capture. Certain features that change on a screen need not to be captured at every available epoch.","The screen change information may be accumulated and tracked. When a screen update is to be transmitted for rendering, the accumulated changes may be sent to a graphics plug-in which may compress the received data and the compressed data may then be made available to the corresponding virtual machine and ultimately to the client device for rendering on a user screen. By sending only the changed screen areas (or changed rectangles), the required bandwidth for transmitting the screen data to the client may be reduced. Another method may include compressing the data representing the changed rectangles. Finally, within the changed rectangles, only the areas within the rectangle that are changed can be compressed and transmitted.","When sending data to a remote client, it is a common experience that due to network congestion, the client is unable to received the data that is transmitted. In this case it may not be beneficial to capture and compress data that the downstream user is unable to receive and process. The render\/capture\/compress subsystem can stop capturing data and avoid performing compression tasks, freeing up resources for other purposes.","Various methods may be used to determine whether the downstream user is able to receive and process data. For example, if buffers are being used to receive changed rectangle information, then a capture may be initiated when a buffer becomes available for receiving data. By monitoring the client's apparent ability to pull the captured data, decisions can be made as to how to provide good quality images over a connection of varying capacity. It is desirable to minimize the latency between user actions and the resulting screen changes, and in order to facilitate this objective, in some cases it may be preferable to increase the capture rate. For example, if it is determined that the screen changes are small, then one can make certain assumptions about the user's activity. For example, it can be assumed that the user is currently typing and only a small portion of the screen is changing at a given time. In this case, the system can automatically increase the capture rate. If the bounding rectangles that define the scope of changes become larger, then the system can maintain the current capture rate or back off the current capture rate to avoid a particular virtual machine from consuming too much of the total available bandwidth.","In an embodiment, if the bounding rectangle increases in size, a lookup table may be used to determine whether the capture rate should be adjusted and if so, a corresponding new capture frame rate or a target capture rate range. Generally, the periodic capture rate may be increased or decreased based on the pull rate at the user buffer. The lookup table information and the buffer pull rate may be used together to determine a desired capture rate. The capture rate can use a number of predetermined factors such as, for example, policies that balance the needs of the individual users and the overall balance and operation of the system as a whole.","In an embodiment, if the amount of changes on the screen or rectangle are small, then the system may determine to capture frames at a normal or fast rate. In keeping with the objective to minimize user latency, in this case the overall latency may be minimized by skipping the compression step as sending the raw data may be more efficient and consume less end-to-end time compared to the time required to include computational cycles needed to compress the data prior to transmission.","Thus in various embodiments, an adaptive capture rate can be provided in order to provide the best user experience under an available bandwidth. If a network develops congestion issues, then image data and commands may get backlogged and in many cases the system may need discard data until the system can catch up. Undesirable effects may result such as jumping and audio popping which detracts from the user's experience. By intelligently adjusting the capture rate as disclosed herein, such undesirable effects can be minimized or avoided and the user's experience may be enhanced.","Referring to , illustrated is a user screen  including a start button , icons , and one or more user application windows . Various areas of the screen may be updated arbitrarily and various threads may be active for updating various user screens. A capture component  may access the video memory and determine threads that are updating the screen. If it is determined that a screen has been updated, then the current screen can be captured. In an embodiment, a capture thread may be provided that provides a signal when a screen is updated. The signal may also invoke a process that compresses what is captured and places the compressed data into buffers  and . If two buffers are used then the use of the buffers will alternate, in this case between b and b.","A graphic source  may be another thread that can pull from one of the buffers  or  while the other buffer is reserved for receiving data. When a change in a screen is detected, the system may determine whether a buffer available. If there is no buffer available than it may be determined that data is being pushed faster than the buffers are being accessed and their contents processed. In this case, the screen changes need not be compressed and uploaded to the buffers. Changed rectangles may be accumulated and tracked so that the changes may be compressed and uploaded at the next opportunity.","By implementing the above techniques, a remote user's experience may be enhanced during situations in which the network availability varies. The experience of tearing and popping may be avoided, and capture frame rate may be adjusted so that CPU\/GPU cycles will not be wasted.","As discussed above, a throttling mechanism can be provided to maintain the user experience during a remote presentation session. At the point where the data is being provided to the graphic source, the system may track how fast the data is being consumed based on the current settings and determine whether the next batch of updates can be sent. By using such a mechanism, the system needs only to determine how fast the data is being consumed and does not need to look further down the pipeline.","The throttling mechanism may be based on the size of the updates. If a small area of the screen is changed such as the cursor, then the system may determine that it need not compress the data. In such cases the latency of the compressing process may be greater than just sending the raw data. This determination may performed by the compression function. Various other policies can be applied to determine a throttling rate. For example, a limit may be placed on the maximum throttle rate to prevent high power users performing intense graphics applications from using too much of the available total bandwidth.","Thus the snapshot interval may be adjusted wherein the frame update push rate may be dynamically adjusted based on the pull rate by the graphics source. The push rate may be further modified based on a policy. For example, if only a small number of the tiles are changed, then the capture rate can be increased, decreased, or remain unchanged depending on the objectives and needs of the system.","In one embodiment, the image frame capture may be implemented in four stages. In a first stage, cursor shape changes may be tracked. In a second stage, on-screen changes can be tracked as they occur in the host partition. In a third stage, a copy of the screen changes can be saved and transferred to system memory. The data can be compressed if compression is enabled. In a fourth stage, the cursor and graphics updates can be transmitted to the remote presentation graphics source.",{"@attributes":{"id":"p-0090","num":"0089"},"figref":"FIG. 10","b":"1000"},"Buffer  depicts a video memory capture buffer used to hold dirty rectangles accumulated from the primary surface being rendered on the host partition. The buffer may hold the data until the capture thread can process the data in preparation for sending the data back to the remote presentation graphics source.","List  depicts a list of dirty rectangles contained in the video memory capture buffer . Buffers  depict two system memory graphics update buffers in system memory along with the associated dirty rectangle regions. The results may be double buffered in order to provide the remote presentation graphics source one buffer while generating the next buffer.","In one embodiment, the GVM or host partition may be a Direct3D application. The GVM may be viewed as a virtual GPU that natively executes Direct3D commands. When the GVM creates the primary surface for a DVM (or child virtual machine), the GVM may also construct a capture object which is configured to create the video memory capture buffer . The capture buffer  may provide a location from which the capture thread can asynchronously transfer or transfer\/compress a batch of dirty rectangles into one of the system memory graphics update buffers . The results may then be sent to the remote presentation graphics source at a predetermined rate based on the total area of the dirty rectangles. In this way a DVM can be prevented from consuming more than its allocated share of available bandwidth. The system memory graphics update buffers  may be double buffered to allow some overlap in transmitting one set of updates to the remote presentation graphics source while generating the next set of updates.","In the GVM, various Direct3D entry points may be configured to keep track of dirty rectangles on the desktop primary surface. The list of rectangles  may accumulate until an indication to the desktop primary surface is received and a system memory capture buffer is available to receive compressed graphics updates. At the time of the indication to the primary surface, one of the following three states may be active:","1. The video memory capture buffer  is available for use and a system memory graphics update buffer  is available. In this case, the following steps may be performed:\n\n","2. The video memory capture buffer  is marked as \u201cIn Use.\u201d In this case, the system may continue to accumulate dirty rectangles until the next indication to the primary surface.","3. If the video memory capture buffer  is available but neither system memory graphics update buffer  is available, then the system may continue to accumulate dirty rectangles until the next indication to the primary surface.","When the capture thread is invoked, the following actions may be performed:\n\n","When the capture server thread is activated, and if the remote presentation graphics source is ready to accept data, then one of the following actions may be performed:\n\n",{"@attributes":{"id":"p-0100","num":"0114"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},{},"Capture\/Sample rate"]},{"entry":[{},"Screen change","goal"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"right"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"10% or below","~30","fps"]},{"entry":[{},"10%-25%","~12-30","fps"]},{"entry":[{},"25%-50%","~6","fps"]},{"entry":[{},">50%","3+","fps"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"When the capture server thread wakes, and if the remote presentation graphics source is not ready to accept data, then the capture server thread can idle until one of the following occurs:\n\n","A number of methods can be used to determine changed or dirty rectangles. In one embodiment, Direct 3D rendering may be tracked by monitoring API entry points including the following:\n\n","Graphics Device Interface (GDI) rendering may be performed by the CPU on the DVM (child partition) and may arrive at the GVM (host partition) as a list of one or more rectangles. This rectangle list may be added to the list of dirty rectangles.","The above described techniques may be applied to multiple monitor scenarios. The capture component may, for example, determine the number of video presentation paths from the video presentation network information as maintained by the virtual GPU component. Each video presentation source may be provided with a set of capture buffers as described above. Each indication that a screen change has been detected may be associated with a specific video source and may cause the capture component to pass the associated graphics updates through the buffers associated with that video source. Screen change indications for a set of displays may arrive asynchronously. It may also be the case that a particular display has no active applications and receives fewer indications than another display. Graphics updates may be sent to the remote presentation graphics source as they become available rather than waiting for updates to be available for each of the displays.",{"@attributes":{"id":"p-0105","num":"0127"},"figref":["FIG. 11","FIG. 11"],"b":["1100","1102","1104","1106","1100","1102","1104","1106","1108"]},{"@attributes":{"id":"p-0106","num":"0128"},"figref":["FIG. 12","FIG. 12"],"b":["1200","1210","1220","1220","1222","1224","1226"]},"Any of the above mentioned aspects can be implemented in methods, systems, computer readable media, or any type of manufacture. For example, per , a computer readable medium can store thereon computer executable instructions for processing graphics data for transmission to a plurality of client computers. Such media can comprise a first subset of instructions for receiving graphics data representing a client screen associated with a virtual machine session ; a second subset of instructions for tracking which areas of said client screen are changed from a previous set of graphics data representing the client screen and accumulating the changed areas ; and a third subset of instructions for sending the changed areas to a queue for transmission to a graphics source configured to render the changed areas, said sending performed in accordance with a policy based on the relative screen area represented by the changed areas, said sending only performed upon indication that the graphics source is currently capable of receiving graphics data . It will be appreciated by those skilled in the art that additional sets of instructions can be used to capture the various other aspects disclosed herein, and that the three presently disclosed subsets of instructions can vary in detail per the present disclosure.","The foregoing detailed description has set forth various embodiments of the systems and\/or processes via examples and\/or operational diagrams. Insofar as such block diagrams, and\/or examples contain one or more functions and\/or operations, it will be understood by those within the art that each function and\/or operation within such block diagrams, or examples can be implemented, individually and\/or collectively, by a wide range of hardware, software, firmware, or virtually any combination thereof.","It should be understood that the various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the disclosure, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the disclosure. In the case of program code execution on programmable computers, the computing device generally includes a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may implement or utilize the processes described in connection with the disclosure, e.g., through the use of an application programming interface (API), reusable controls, or the like. Such programs are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","While the invention has been particularly shown and described with reference to a preferred embodiment thereof, it will be understood by those skilled in the art that various changes in form and detail may be made without departing from the scope of the present invention as set forth in the following claims. Furthermore, although elements of the invention may be described or claimed in the singular, the plural is contemplated unless limitation to the singular is explicitly stated."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The systems, methods, and computer readable media for altering a view perspective within a virtual environment in accordance with this specification are further described with reference to the accompanying drawings in which:",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIGS. 1 and 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 13","FIGS. 1-12"]}]},"DETDESC":[{},{}]}
