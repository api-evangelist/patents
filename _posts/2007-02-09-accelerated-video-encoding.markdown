---
title: Accelerated video encoding
abstract: A video encoding acceleration service to increase one or more of the speed and quality of video encoding is described. The service acts as an intermediary between an arbitrary video encoder computer program application and arbitrary video acceleration hardware. The service receives one or more queries from the video encoder to identify implementation specifics of the video acceleration hardware. The service interfaces with the video acceleration hardware to obtain the implementation specifics. The service communicates the implementation specifics to the video encoder. The implementation specifics enable the video encoder to: (a) determine whether one or more of speed and quality of software encoding operations associated with the video encoder can be increased with implementation of a pipeline of one or more supported encoding pipeline configurations and capabilities, and (b) implement the pipeline by interfacing with the service.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08654842&OS=08654842&RS=08654842
owner: Microsoft Corporation
number: 08654842
owner_city: Redmond
owner_country: US
publication_date: 20070209
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION","APPENDIX","Exemplary Video Encode Acceleration API","Video Encode"],"p":["This application is a continuation-in-part of co-pending U.S. patent application Ser. No. 11\/276,336 filed on Feb. 24, 2006, titled \u201cAccelerated Video Encoding\u201d, and hereby incorporated by reference.","Multimedia content production and distribution operations typically include video encoding. Video encoding processes are typically very data and computationally intensive. As a result, video encoding processes can be very time consuming. For example, it may take several tens-of hours for a software encoder to encode a high-quality high definition movie. Since quality and speed of video encoding processes are significant factors for successful multimedia content production and distribution pipelines, systems and techniques to increase the speed at which high quality video content can be encoded would be useful.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the detailed description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used as an aid in determining the scope of the claimed subject matter.","In view of the above, a video encoding acceleration service to increase one or more of the speed and quality of video encoding is described. The service acts as an intermediary between an arbitrary video encoder computer program application and arbitrary video acceleration hardware. The service receives one or more queries from the video encoder to identify implementation specifics of the video acceleration hardware. The service interfaces with the video acceleration hardware to obtain the implementation specifics. The service communicates the implementation specifics to the video encoder. The implementation specifics enable the video encoder to: (a) determine whether one or more of speed and quality of software encoding operations associated with the video encoder can be increased with implementation of a pipeline of one or more supported encoding pipeline configurations and capabilities, and (b) implement the pipeline by interfacing with the service.","Overview","Systems and methods for accelerated video encoding provide a video encoding acceleration service. This service allows an arbitrary video encoder application to interface, in a device independent manner, with arbitrary video acceleration hardware to define and implement a substantially optimal video encoding pipeline. To accomplish this, the service exposes video acceleration (VA) application program interfaces (APIs). These APIs encapsulate a model of the video encoding process. To define an encoding pipeline, the video encoder application uses the VA APIs to query implementation specifics (e.g., capabilities, etc.) of available video (graphics) acceleration hardware. The video encoder evaluates these specifics in view of the application's particular video encoding architecture (software-implemented) to identify any encoding operations that could benefit (e.g., speed and\/or quality benefits) from being accelerated in hardware. Such operations include, for example, motion estimation, transform, and quantization operations and inverse operations such as Motion compensation, inverse transforms and inverse quantization. The API also allows the video encoder to design an encoding pipeline that substantially minimizes dataflow transitions across buses and processors associated with the host computing device and the acceleration hardware, and thereby, further increase encoding speeds. The API also allows the acceleration hardware to influence the location of the data to improve local caching (e.g. the video acceleration hardware may functional more efficiently on memory local to the video hardware).","Based on these evaluations the video encoder designs a customized video encoding pipeline that performs some number of encoding operations in software and some number of encoding operations using the acceleration hardware (i.e., at least a subset of the operations that could benefit from being hardware accelerated). The encoder application then uses the API to create the pipeline and encode video content. This customized pipeline is substantially optimized as compared to a completely software-implemented pipeline because certain encoding operations are accelerated and data transitions between the host and the acceleration hardware are minimized. Additionally, processing time freed up by accelerating certain aspects of the encoding process and minimizing data transitions allow the host processor(s) to perform higher-quality encoding operations with freed-up processing cycles. The API is also designed to allow components to operate in parallel so that computational resource usage can be maximized.","These and other aspects of the systems and methods for accelerated video encoding are now described in greater detail.","An Exemplary System","Although not required, the systems and methods for accelerated video encoding are described in the general context of computer-executable instructions (program modules) being executed by a computing device such as a personal computer and graphics (video) encoding acceleration hardware. Program modules generally include routines, programs, objects, components data structures, etc., that perform particular tasks or implement particular abstract data types.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1","b":["100","100","102","102","102","104","103","106","106","108","110","104","108","108","112","114","112","116","118","120"]},"In this implementation, video encoder  is an arbitrary video encoder. This means that the particular architecture, operation, data formats, etc, implemented and\/or utilized by video encoder  are arbitrary. For example, video encoder  may be distributed by a third party, an OEM, etc. Additionally, although  shows video encoding acceleration service  independent of the operating system portion of \u201cother program modules\u201d , in one implementation, video encoding acceleration service  is part of the operating system.","Video processing modules  receive compressed or uncompressed input video data . When input video data  is compressed (already encoded), video processing modules  decode the input video data  to produce decoded source video data. Such decoding operations are performs by a decoder module. In another implementation, partially decoded data could also be retained to farther assist the encoding process. For purposes of exemplary illustration, such a decoder module is shown as a respective portion of \u201cother video processing modules\u201d . Thus, decoded source video data is represented either by input video data  that was received in a decoded state, or represented with results of decoding input video data  that was received in an encoded state. Decoded source video data is shown as a respective portion of \u201cother program data\u201d .","To design and implement a customized video encoding pipeline that can be used to encode decoded source video data into encoded video data , video encoder  interfaces with video encoding acceleration service  via video acceleration (VA) APIs . One exemplary implementation of multiple possible implementations of VA APIs  is described in the Appendix. To define an encoding pipeline, the video encoder application uses respective ones of the VA API  (e.g., please see the Appendix, \u00a73.4, IVideoEncoderService) to obtain implementation specifics of available acceleration hardware . Such implementation specifics include, for example:\n\n","Responsive to receiving such requests from the video encoder , video encoding acceleration service  queries the video acceleration hardware  for the requested implementation specifics and returns information associated with the corresponding responses from the acceleration hardware  to the video encoder . Video encoding acceleration service  interfaces with the video acceleration hardware  using a corresponding device driver. Such a device driver is shown as respective portion of \u201cother program modules\u201d .","Video encoder  evaluates the implementation specifics supported by acceleration hardware  in view of the application's particular video encoding architecture (software-implemented) to identify any encoding operations that could benefit (e.g., speed and\/or quality benefits) from being accelerated in hardware, select a search profile to encapsulate a trade-off between video encoding quality and speed, minimize data transitions across buses and between processors, etc. Exemplary operations that may benefit from hardware acceleration include, for example, motion estimation, transform, and quantization. For example, one reason to perform quantization in hardware is to minimize dataflow between pipeline stages.",{"@attributes":{"id":"p-0028","num":"0032"},"figref":["FIG. 2","FIG. 2","FIG. 1","FIG. 2","FIG. 1","FIG. 2","FIG. 1","FIG. 1"],"b":["200","200","116","118","102","130","130","102","200","204","212"]},"In this example implementation, video encoder  () takes as input some form of compressed or uncompressed video data  (please also see input video data  of ). Please note that the exemplary pipeline configuration of  does not copy input source video  (\u201craw video source\u201d) to the host computing device  if the source  is not originating from the host  and if the host decision making engine (e.g., video encoder ) does not use the source video. For example, if quantization decisions do not require the host to touch the video data, the data will not be transferred. In this example, pipeline  is configured to convert the input data  to another compressed form using the respective operations of blocks ,  and  through .","Such operations may include converting uncompressed (YUV) video data to compressed MPEG-2, or it may include transcoding video data from MPEG-2 data format to WMV data format. For purposes of exemplary illustration, assume that the transcoding operations include a full or partial decompression stage followed by an encode stage (there are more efficient models which by-pass decompression and work purely in the transform (DCT) space). A number of video compression formats make use of motion estimation, transform and quantization to achieve compression. Of the compression stages, motion estimation is typically the slowest step, including a massive search operation where an encoder (e.g., video encoder ) attempts to find the closest matching reference macroblock for macroblocks in a given image.","Once the optimal motion vectors are determined (e.g., via block ) for each of the macroblocks, the encoder  computes the differential residues (e.g., via block ) based on the previously coded image and the optimal motion vector. The motion vector, along with the differential residue is a compact representation of the current image. The motion vector data is further represented differentially. The host encoder can optionally request the re-evaluation of motion vectors by the video acceleration hardware to find a macroblock with a smaller combined motion vector and\/or residual. The resulting differential motion vector data, and the residual data are compacted (e.g., via block ), for example, using techniques like run-length encoding (RLE) and differential coding (e.g.: Huffman and Arithmetic coding) to generate the final coded stream of bits (encoded video data ) to communicate to a destination (block ) for presentation to a user. In this example, the operations of blocks ,  and  through  (e.g., operations such as motion estimation (), mode decision, motion vector (MV) selection and rate control (), prediction formation (), transform and quantization operations (), quantizer inversion and transform and version () and entropy coding ()) are well-known in the art and are thus not described further herein.","Referring again to , in one implementation, video encoder  is a multi-threaded application providing for full utilization of acceleration hardware . In this implementation, when determining which video encoding operations are to be accelerated in hardware, video encoder  may structure the particular pipeline configuration such that both processor  and acceleration hardware  is fully utilized. For example, when video encoding pipeline motion estimation operations are being performed by hardware for a particular frame of video data, the pipeline may be configured to perform entropy (or arithmetic or Huffman) coding operations in software by the host on a different frame of video data. An exemplary single motion vector pipeline representing the particular pipeline configuration selected\/structured is described below in the Appendix in section 5.1.1. Exemplary multiple motion vector (relatively complex) pipelines wherein video encoder  requests multiple motion vectors from acceleration hardware  and selects one motion vector pipeline based on various parameters is described below in the Appendix in section 5.1.2.","With respect to selecting a search profile, the quality of motion vectors refers to a bitrate of a stream generated by the use of the motion vectors. High quality motion vectors are associated with low bitrate streams. The quality is determined by the completeness of the block search, the quality of the algorithm, the distance metric used, etc. High quality motion vectors should be used to perform high quality video encode operations. To address this, video encoding acceleration service  provides a generic construct called a search profile to encapsulate a trade-off between quality and time. The search profile also includes meta-data to identify the search algorithm used by the acceleration hardware , etc. Video encoder  chooses a particular search profile based on the particular requirements of the encoder's implementation.","With respect to minimizing data transitions across buses and between processors, an encode process implemented by a video encoding pipeline configuration will typically include several processing stages, each of which may or may not be accelerated via acceleration hardware . In cases where video encoder  determines to utilize hardware acceleration in successive stages of the encode pipeline, it may not be necessary to move data from acceleration hardware  based memory  to the system memory  associated with the host computing device , and then back to acceleration hardware based memory  for the next stage, and so on.","More particularly, while pointers to various types of video and motion vector data may be transferred back and forth between the host computing device  and the acceleration hardware , in one implementation, actual data is copied to system memory  only when the data pointer (a D3D9 Surface pointer) is explicitly locked using, for example, IDirect3DSurface9::LockRect. Exemplary interfaces for locking a surface are known (e.g., the well-known IDirect3DSurface9::LockRect.interface). Thus, in cases where two encoding pipeline stages follow one another, and host computing device  does not need to do perform any intermediate processing, host computing device  can decide not to \u201cLock\u201d the allocated buffer between the processing stages. This will prevent a redundant memory copy of data, and thereby, avoid unnecessary data movement\/transfers. In this manner, video encoder  design a video encoding pipeline that substantially minimizes data transfers across buses and between processors, and thereby, further increase video encoding speeds.","At this point, video encoder  has evaluated the implementation specifics supported by acceleration hardware  in view of the application's particular video encoding architecture (software-implemented) to identify any encoding operations that could benefit from being accelerated in hardware, selected a search profile, minimized data transitions across buses and between processors, and\/or so on. Based on these determinations, video encoder  selects a particular pipeline configuration to encode decoded source video data, and thereby, generate encoded video data . Next, video encoder  interfaces with video encoding acceleration service  to create an encoder object to implement the selected pipeline (please see the Appendix, CreateVideoEncoder API, \u00a73.4.6). In this implementation, an encoder object (e.g., a regular COM object) is created by identifying the selected pipeline configuration and one or more of the following: a format for the output encoded bitstream, the number of input and output data streams associated with the pipeline configuration, static configuration properties, a suggested number of buffers (surfaces) for association with the different I\/O streams based on the selected pipeline configuration, and a driver specified allocator queue size based on resources a graphics device driver is able to gather, and other parameters. (Queue size and the number of data buffers are essentially referring to the same thing; one is \u201csuggested\u201d, the other is \u201cactual\u201d).","Next, video encoder  uses the created encoder object to interface with the video encoding acceleration service  to encode the decoded source video data. To this end, the encoder object submits execute requests to acceleration hardware  (please see the Appendix, IVideoEncode:Execute API, \u00a73.2.3).","In view of the above, system  allows arbitrary implementations of video encoder applications  to define and create video encoding pipeline configurations during runtime to take full advantage of available video encoding acceleration hardware to increase encoding speed and quality. As part of these runtime configuration operations, the video encoder  can use VA APIs  to specify that the encoding pipeline is to implement iterative directed searching (multiple search passes of increasing refinement), define and use generically selectable search strategies (e.g., selecting a search algorithm based on quality metrics independent of any knowledge of details about the actual algorithm been employed), utilize format independent methodologies (e.g., where a video encoder  is unaware of the particular image format of input video data  and the acceleration hardware  is unaware of the compressed output format for the encoded video data ) to control searching, adapt data sizes (e.g., where the video encoder  selects a macro block size based on a search algorithm), and so on.","An Exemplary Procedure",{"@attributes":{"id":"p-0039","num":"0043"},"figref":["FIG. 3","FIG. 1"],"b":["300","100"]},"At block , video encoder  () receives input video data . If the input video data  is not compressed, the input video data represents decoded source video data. At block , if the input video data  is compressed, video encoder  decompresses the input video data to generate decoded source video data. At block , video encoder  interfaces with VA API  to query acceleration hardware  for capabilities and video encoding pipeline configuration implementation specifics. At block , video encoder  evaluates the supported capabilities and implementation specifics within the context of the implementation of the video encoder , to identify video encoding operations associated with the particular implementation of the video encoder  that may benefit from hardware acceleration, make encoding speed and\/or quality decisions, minimize data transitions across busses and between processors, and\/or so on.","At block , video encoder  creates an encoding object that implements an encoding pipeline configured to execute the identified video encoding operations that may benefit from hardware acceleration in acceleration hardware , implement the speed\/quality tradeoffs (e.g., via a selected search profile), and minimize data flow transitions. At block , video encoder uses the created encoder object to encode the decoded source video data according to the sequence of operations and encoding architecture delineated by the customized video encoding pipeline generated at block . These encoding operations of block  generate encoded video data  ().","Although the systems and methods for accelerated video encoding have been described in language specific to structural features and\/or methodological operations or actions, it is understood that the implementations defined in the appended claims are not necessarily limited to the specific features or actions described.","For example, although API's  of  have been described within the context of encoding video data, APIs  can be used outside of the encoding context for hardware acceleration of other functions such as edge detection, motion-vector based noise reduction, image stabilization, sharpening, frame rate conversion, velocity computation for computer vision applications, etc. For instance with respect to noise reduction, in one implementation video encoder  () computes motion vectors for all macroblocks of decoded source image data. Then, video encoder  utilizes motion magnitude, direction, and correlation to motion vectors of surrounding macroblocks to determine whether there is a local object motion in the input image. In this implementation, the video encoder  of then utilizes the magnitude of the vector to direct object tracking\/filtering aggressiveness or average shifts of a particular object to reduce statically random noise.","In another example with respect to image stabilization, in one implementation video encoder  computes motion vectors for all macroblocks and decoded source data. Video encoder  then determines whether there is global motion in the image. This is accomplished by correlating all motion vector values and determining whether the correlated values are similar. If so, then video encoder  concludes that there is global motion. Alternatively the video encoder  utilizes a large macroblock size and determines if there is overall motion of the large macroblock. After determining whether global motion is present, if video encoder  also finds that the global motion vector tends to be jerky across frames, video encoder  concludes that there is camera jerkiness and compensates for this before starting noise filtering and encoding operations.","Accordingly, the specific features and operations of system  are disclosed as exemplary forms of implementing the claimed subject matter.","This Appendix describes various exemplary aspects of an exemplary implementation of the video encoding acceleration APIs  () for accelerated video encoding, also referred to as Video Acceleration (VA) Encode. This is only one example of API  and other implementations can be implemented in view of this detailed description. In this implementation, and as already described in the detailed description, APIs  allow video encoder module  to leverage acceleration hardware  (e.g., a GPU) support for accelerating Motion Estimation, Residue Computation, Motion Compensation, Transform, and\/or other encoding operations.",{"@attributes":{"id":"p-0047","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"1 Table of Contents"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","Table of Contents","18"]},{"entry":["2","Exemplary Design","20"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"2.1","Encoder Layout","20"]},{"entry":[{},"2.2","Pipeline or Mode Configurations","21"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"2.2.1","VA2_EncodePipe_Full","21"]},{"entry":[{},"2.2.2","VA2_EncodePipe_MotionEstimation","22"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["3","Exemplary API","23"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"3.1","Interface Definition","23"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"3.1.1","IVideoEncoder","23"]},{"entry":[{},"3.1.2","IVideoEncoderService","23"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"3.2","Methods: IVideoEncoder","24"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"3.2.1","GetBuffer","24"]},{"entry":[{},"3.2.2","ReleaseBuffer","25"]},{"entry":[{},"3.2.3","Execute","26"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"3.3","Data Structures: Execute","28"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"3.3.1","VA2_Encode_ExecuteDataParameter","28"]},{"entry":[{},"3.3.2","VA2_Encode_ExecuteConfigurationParameter","28"]},{"entry":[{},"3.3.3","DataParameter_MotionVectors","29"]},{"entry":[{},"3.3.4","DataParameter_Residues","29"]},{"entry":[{},"3.3.5","DataParameter_InputImage","30"]},{"entry":[{},"3.3.6","DataParameter_ReferenceImages","30"]},{"entry":[{},"3.3.7","DataParameter_DecodedImage","30"]},{"entry":[{},"3.3.8","VA2_Encode_ImageInfo","31"]},{"entry":[{},"3.3.9","ConfigurationParameter_MotionEstimation","31"]},{"entry":[{},"3.3.10","VA2_Encode_SearchResolution","32"]},{"entry":[{},"3.3.11","VA2_Encode_SearchProfile","32"]},{"entry":[{},"3.3.12","VA2_Encode_MBDescription","33"]},{"entry":[{},"3.3.13","VA2_Encode_SearchBounds","34"]},{"entry":[{},"3.3.14","VA2_Encode_ModeType","34"]},{"entry":[{},"3.3.15","ConfigurationParameter_Quantization","35"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"3.4","Methods: IVideoEncoderService","35"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"3.4.1","GetPipelineConfigurations","35"]},{"entry":[{},"3.4.2","GetFormats","36"]},{"entry":[{},"3.4.3","GetDistanceMetrics","36"]},{"entry":[{},"3.4.4","GetSearchProfiles","37"]},{"entry":[{},"3.4.5","GetMECapabilities","37"]},{"entry":[{},"3.4.6","CreateVideoEncoder","38"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"3.5","Data Structures: IVideoEncoderService","39"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"3.5.1","VA2_Encode_MECaps","39"]},{"entry":[{},"3.5.2","VA2_Encode_StaticConfiguration","40"]},{"entry":[{},"3.5.3","VA2_Encode_Allocator","40"]},{"entry":[{},"3.5.4","VA2_Encode_StreamDescription","41"]},{"entry":[{},"3.5.5","VA2_Encode_StreamType","41"]},{"entry":[{},"3.5.6","VA2_Encode_StreamDescription_Video","42"]},{"entry":[{},"3.5.7","VA2_Encode_StreamDescription_MV","42"]},{"entry":[{},"3.5.8","VA2_Encode_StreamDescription_Residues","42"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"3.6","Data Structures: Motion Vectors","43"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"3.6.1","Motion Vector Layout","43"]},{"entry":[{},"3.6.2","New D3D Formats","43"]},{"entry":[{},"3.6.3","VA2_Encode_MVSurface","44"]},{"entry":[{},"3.6.4","VA2_Encode_MVType","45"]},{"entry":[{},"3.6.5","VA2_Encode_MVLayout","45"]},{"entry":[{},"3.6.6","VA2_Encode_MotionVector8","45"]},{"entry":[{},"3.6.7","VA2_Encode_MotionVector16","46"]},{"entry":[{},"3.6.8","VA2_Encode_MotionVectorEx8","46"]},{"entry":[{},"3.6.9","VA2_Encode_MotionVectorEx16","46"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"3.7","Data Structures: Residues","47"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"3.7.1","Luma plane","47"]},{"entry":[{},"3.7.2","Chroma 4:2:2","47"]},{"entry":[{},"3.7.3","Chroma 4:2:0","48"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["4","Exemplary DDI Documentation","48"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"4.1","Enumeration and Capabilities","48"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"4.1.1","FND3DDDI_GETCAPS","48"]},{"entry":[{},"4.1.2","VADDI_QUERYEXTENSIONCAPSINPUT","49"]},{"entry":[{},"4.1.3","D3DDDIARG_CREATEEXTENSIONDEVICE","49"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"4.2","Encode Functionality","49"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"4.2.1","VADDI_Encode_Function_Execute_Input","50"]},{"entry":[{},"4.2.2","VADDI_Encode_Function_Execute_Output","50"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"4.3","Extension Device Structures","50"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"4.3.1","VADDI_PRIVATEBUEFER","51"]},{"entry":[{},"4.3.2","D3DDDIARG_EXTENSIONEXECUTE","51"]},{"entry":[{},"4.3.3","FND3DDDI_DESTROYEXTENSIONDEV1CE","51"]},{"entry":[{},"4.3.4","FND3DDDI_EXTENSIONEXECUTE","51"]},{"entry":[{},"4.3.5","D3DDDI_DEVICEFUNCS","51"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"4.4","D3D9 Structures and Functions","52"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["5","Exemplary Programming Model","52"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"5.1","Pipeline Efficiency","52"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"5.1.1","Example: Single Motion Vector (Pipeline Full)","52"]},{"entry":[{},"5.1.2","Example: Multiple Motion Vectors","55"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}]},{"@attributes":{"id":"p-0048","num":"0052"},"figref":["FIG. 4","FIG. 1","FIG. 1","FIG. 4"],"b":["116","118","128","116","128"]},"Block  represents a number n image surfaces of input data. In one implementation, each image surface represents a respective D3D surface. Operations of block  implement noise filtering operations. In this implementation, the noise filtering operations are implemented to by the known IDirectXVideoProcessor interface, although other interfaces could also be used. Block  represents noise filtered image surface data. At block , motion estimation operations are implemented, possibly via acceleration hardware  as described above. The motion vectors are represented in buffer . Operations of block  implement motion compensation. The resulting coded image surfaces are represented at block . Residual data computation operations of block  operate on image data from buffers  and , resulting in residual data in buffer . In view of the residual data, operations of function  perform DCT and quantization processes to generate the residual data of buffer . Entropy coding operations of function  and inverse quantization and IDCT operations of function  operate on this residual data (transformed and quantized data). Function  generates residual data that is quantized and inverse quantized as shown in buffer . In view of the data in buffer , function  implements motion compensation operations.","Significantly, the various data in respective ones of the buffer , , , ,  and  are well-known in the art. Additionally, operations associated with respective ones of the functions , , , , ,  and  are also well-known in the art. Thus it is not the respective data and details of the operations of the video encoder that are novel. In contrast to conventional encoders, encoder  () interfaces with accelerated video encoding service  and corresponding exposed video acceleration APIs  to create a customized encoding pipeline (e.g., a pipeline  of ) configuration that interfaces, in a device independent manner, with arbitrary video acceleration hardware . The customized pipeline may implement at least a subset of the functions illustrated in , and possibly more or different encoding functions. Exemplary such APIs a are described below, although different implementations could also be put into practice.","2.2 Pipeline or Mode Configurations","Acceleration hardware  () is viewed as a pipeline. In this implementation, a pipeline GUID is used to describe the most basic configuration elements of the pipeline. A goal of encode speed-up may be thought of being related to a goal of pipeline efficiency.","The design allows for split (or multi-stage) pipelines where data goes back and forth between the host PC  and the hardware , before the final output is obtained. The following described pipeline configurations represent non-split, single stage pipelines.","2.2.1 VA2_EncodePipe_Full",{"@attributes":{"id":"p-0053","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ {BFC87EA2-63B6-4378-A619-5B451EDCB940}"]},{"entry":[{},"cpp_quote( \u201cDEFINE_GUID(VA2_EncodePipe_Full,"]},{"entry":[{},"0xbfc87ea2, 0x63b6, 0x4378, 0xa6, 0x19, 0x5b,"]},{"entry":[{},"0x45, 0x1e, 0xdc, 0xb9, 0x40);\u201d )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0054","num":"0058"},"figref":"FIG. 5","b":["130","132","103","106"]},"In this implementation, the number of streams (NumStreams) is five, although other numbers of streams could also be used. The actual StreamIds are shown in the diagram in parentheses.","(This is an example of a single stage, non-split pipeline, and hence the Stage parameter of Execute is not used).","Stream Descriptions","Note that StreamType_* is an abbreviation for VA2_Encode_StreamType_*.","Input Image\n\n","Reference Images\n\n","Motion Vectors\n\n","Residues\n\n","Decoded Image\n\n",{"@attributes":{"id":"p-0063","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ {F18B3D19-CA3E-4a6b-AC10-53F86D509E04}"},{"entry":"cpp_quote( \u201cDEFINE_GUID(VA2_EncodePipe_MotionEstimation,"},{"entry":"0xf18b3d19, 0xca3e, 0x4a6b, 0xac,"},{"entry":"0x10, 0x53, 0xf8, 0x6d, 0x50, 0x9e, 0x4);\u201d )"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0064","num":"0073"},"figref":"FIG. 6"},"NumStreams for this pipeline configuration is three. The StreamIds for the various streams are show in the diagram in paranthesis.","This is a single stage, non-split pipeline and the Stage parameter of Execute does not apply.","3 Exemplary API","3.1 Interface Definition","3.1.1 IVideoEncoder",{"@attributes":{"id":"p-0067","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"interface IVideoEncoder : IUnknown"]},{"entry":[{},"{"]},{"entry":[{},"\u2003HRESULT GetBuffer("]},{"entry":[{},"\u2003\u2003[in] UINT8 StreamId,"]},{"entry":[{},"\u2003\u2003[in] UINT32 StreamType,"]},{"entry":[{},"\u2003\u2003[in] BOOL Blocking,"]},{"entry":[{},"\u2003\u2003[out] PVOID pBuffer"]},{"entry":[{},"\u2003\u2003);"]},{"entry":[{},"\u2003HRESULT ReleaseBuffer("]},{"entry":[{},"\u2003\u2003[in] UINT8 StreamId,"]},{"entry":[{},"\u2003\u2003[in] UINT32 StreamType,"]},{"entry":[{},"\u2003\u2003[in] PVOID pBuffer"]},{"entry":[{},"\u2003\u2003);"]},{"entry":[{},"\u2003HRESULT Execute("]},{"entry":[{},"\u2003\u2003[in] UINT8 Stage,"]},{"entry":[{},"\u2003\u2003[in] UINT32 NumInputDataParameters,"]},{"entry":[{},"\u2003\u2003[in, size_is(NumInputDataParameters)]"]},{"entry":[{},"\u2003\u2003\u2003VA2_Encode_ExecuteDataParameter** pInputData,"]},{"entry":[{},"\u2003\u2003[in] UINT32 NumOutputDataParameters,"]},{"entry":[{},"\u2003\u2003[out, size_is(NumOutputDataParameters]"]},{"entry":[{},"\u2003\u2003\u2003VA2_Encode_ExecuteDataParameter** pOutputData,"]},{"entry":[{},"\u2003\u2003[in] UINT32 NumConfigurationParameters,"]},{"entry":[{},"\u2003\u2003[in, size_is(NumConfigurationParameters]"]},{"entry":[{},"\u2003\u2003\u2003VA2_Encode_ExecuteConfigurationParameter**"]},{"entry":[{},"\u2003\u2003\u2003pConfiguration,"]},{"entry":[{},"\u2003\u2003[in] HANDLE hEvent,"]},{"entry":[{},"\u2003\u2003[out] HRESULT* pStatus"]},{"entry":[{},"\u2003\u2003);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0068","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"interface IVideoEncoderService : IVideoAccelerationService"},{"entry":"{"},{"entry":"\u2003HRESULT GetPipelineConfigurations("},{"entry":"\u2003\u2003[out] UINT32* pCount,"},{"entry":"\u2003\u2003[out, unique, size_is(*pCount)] GUID** pGuids"},{"entry":"\u2003\u2003);"},{"entry":"\u2003HRESULT GetFormats("},{"entry":"\u2003\u2003[out] UINT32* pCount,"},{"entry":"\u2003\u2003[out, unique, size_is(*pCount)] GUID** pGuids"},{"entry":"\u2003\u2003);"},{"entry":"\u2003HRESULT GetDistanceMetrics("},{"entry":"\u2003\u2003[out] UINT32* pCount,"},{"entry":"\u2003\u2003[out, unique, size_is(*pCount)] GUID** pGuids"},{"entry":"\u2003\u2003);"},{"entry":"\u2003HRESULT GetSearchProfiles("},{"entry":"\u2003\u2003[out] UINT32* pCount,"},{"entry":"\u2003\u2003[out, unique, size_is(*pCount)] VA2_Encode_SearchProfile**"},{"entry":"\u2003\u2003pSearchProfiles"},{"entry":"\u2003\u2003);"},{"entry":"\u2003HRESULT GetMECapabilities("},{"entry":"\u2003\u2003[out] VA2_Encode_MECaps* pMECaps"},{"entry":"\u2003\u2003);"},{"entry":"\u2003HRESULT CreateVideoEncoder("},{"entry":"\u2003\u2003[in] REFGUID PipelineGuid,"},{"entry":"\u2003\u2003[in] REFGUID FormatGuid,"},{"entry":"\u2003\u2003[in] UINT32 NumStreams,"},{"entry":"\u2003\u2003[in] VA2_Encode_StaticConfiguration* pConfiguration,"},{"entry":"\u2003\u2003[in, size_is(NumStreams)] VA2_Encode_DataDescription*"},{"entry":"\u2003\u2003pDataDescription,"},{"entry":"\u2003\u2003[in, size_is(NumStreams)] VA2_Encode_Allocator*"},{"entry":"\u2003\u2003SuggestedAllocatorProperties,"},{"entry":"\u2003\u2003[out, size_is(NumStreams)] VA2_Encode_Allocator*"},{"entry":"\u2003\u2003pActualAllocatorProperties,"},{"entry":"\u2003\u2003[out] IVideoEncoder** ppEncode"},{"entry":"\u2003\u2003);"},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"This function returns buffers (encode surfaces) for use in the exemplary Execute call described below. The buffers are released promptly after use by calling ReleaseBuffer to avoid stalling the pipeline.",{"@attributes":{"id":"p-0070","num":"0079"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"HRESULT GetBuffer("},{"entry":"\u2003[in] UINT8 StreamId,"},{"entry":"\u2003[in] UINT32 StreamType,"},{"entry":"\u2003[in] BOOL Blocking,"},{"entry":"\u2003[out] PVOID pBuffer"},{"entry":"\u2003);"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define E_NOTAVAILABLE","HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)"]},{"entry":["#define E_INVALIDPARAMETER","HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"StreamId\n\n","StreamType\n\n","Blocking\n\n","pBuffer\n\n","S_OK\n\n","E_NOTAVAILABLE\n\n","E_INVALIDPARAMETER\n\n","VFW_E_UNSUPPORTED_STREAM\n\n","E_FAIL\n\n","Normally, this function returns control very soon as the buffers are already present in the allocator queue. The only conditions under which this function should block (or return E_NOTAVAILABLE) are when all buffers from the allocator queue have been submitted to the device, or being consumed by the application, and hence not released.",{"@attributes":{"id":"p-0081","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Stream Types and Buffer Formats"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["StreamType_Video","IDirect3DSurface9** pBuffer."]},{"entry":["StreamType_MV","IDirect3DSurface9** pBuffer"]},{"entry":["StreamType_Residues","IDirect3DSurface9* pBuffer[3]. i.e. pBuffer is"]},{"entry":[{},"a pointer to three D3D surface pointers."]},{"entry":[{},"pBuffer[0] is a pointer to the luma surface."]},{"entry":[{},"pBuffer[1] is a pointer to the Cb surface, or"]},{"entry":[{},"NULL if not applicable."]},{"entry":[{},"pBuffer[2] is a pointer to the Cr surface, or"]},{"entry":[{},"NULL if not applicable."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"This function is used to release a surface back into the allocator queue for reuse via GetBuffer.",{"@attributes":{"id":"p-0083","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT ReleaseBuffer("]},{"entry":[{},"\u2003[in] UINT8 StreamId,"]},{"entry":[{},"\u2003[in] UINT8 StreamType,"]},{"entry":[{},"\u2003[in] PVOID pBuffer"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"StreamId\n\n","StreamType\n\n","pBuffer\n\n","S_OK\n\n","E_FAIL\n\n","This function is used to submit requests to acceleration hardware . It provides input and output data buffers obtained via GetBuffer, as well as some configuration information. The function is asynchronous and its completion is indicated by the event being signaled. The completion status is indicated using the pStatus parameter which is allocated on the heap, and checked only after the event has been signaled.","The buffers supplied as parameters to this function are not be read from (eg: via LockRect), or written to by the encoding application until the function has truly completed. In this implementation, true completion is implied by an error value being returned by the function, or if this function returns success, then by the signaling of hEvent (parameter to this function). When the same buffer is input to several instances of the Execute call, it is not be accessed until all associated Execute calls have completed. The pointer to a surface in use by Execute may still be supplied as a parameter to VA functions like Execute since this doesn't require the data to be locked. This last rule explains how the same input image may be used in multiple Execute calls at the same time.","The buffers supplied to this call obey the allocator semantics negotiated at creation time. If an external allocator is used when GetBuffer is expected to be used, this function will return E_FAIL.",{"@attributes":{"id":"p-0092","num":"0115"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"HRESULT Execute("},{"entry":"\u2003[in] UINT8 Stage,"},{"entry":"\u2003[in] UINT32 NumInputDataParameters,"},{"entry":"\u2003[in, size_is(NumInputDataParameters)]"},{"entry":"\u2003\u2003VA2_Encode_ExecuteDataParameter** pInputData,"},{"entry":"\u2003[in] UINT32 NumOutputDataParameters,"},{"entry":"\u2003[out, size_is(NumOutputDataParameters)]"},{"entry":"\u2003\u2003VA2_Encode_ExecuteDataParameter** pOutputData,"},{"entry":"\u2003[in] UINT32 NumConfigurationParameters,"},{"entry":"\u2003[in, size_is(NumConfigurationParameters]"},{"entry":"\u2003\u2003VA2_Encode_ExecuteConfigurationParameter** pConfiguration,"},{"entry":"\u2003[in] HANDLE hEvent,"},{"entry":"\u2003[out] HRESULT* pStatus"},{"entry":"\u2003);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Stage\n\n","NumInputDataParameters\n\n","pInputData\n\n","NumOutputDataPararmeters\n\n","pOutputData\n\n","NumConfigurationParameters\n\n","pConfiguration\n\n","hEvent\n\n","pStatus\n\n","S_OK\n\n","E_FAIL\n\n","If the event handle gets signaled, it means that LockRect should complete instantly when called on any of the output surfaces since they are ready. In particular, the LockRect call is expected to not block for any length of time by waiting on any event handles. Nor is it allowed to waste CPU time through busy spins.","3.3 Data Structures: Execute","The Execute call has data parameters and configuration parameters. Specific data parameters can be thought of as deriving from VA2_Encode_ExecuteDataParameter base class (or structure) and specific configuration parameters can be thought of as deriving from VA2_Encode_ExecuteConfigurationParameter base class (or structure).","3.3.1 VA2_Encode_ExecuteDataParameter",{"@attributes":{"id":"p-0106","num":"0140"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct _VA2_Encode_ExecuteDataParameter {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003UINT32","\u2003\u2003Length;"]},{"entry":[{},"\u2003\u2003UINT32","\u2003\u2003StreamId;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} VA2_Encode_ExecuteDataParameter;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"Length\n\n","StreamId\n\n",{"@attributes":{"id":"p-0109","num":"0145"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct _VA2_Encode_ExecuteConfigurationParameter {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003UINT32","\u2003\u2003Length;"]},{"entry":["\u2003\u2003UINT32","\u2003\u2003StreamId;"]},{"entry":["\u2003\u2003UINT32","\u2003\u2003ConfigurationType;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"} VA2_Encode_ExecuteConfigurationParameter;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define VA2_Encode_ConfigurationType_MotionEstimation","0x1"]},{"entry":["#define VA2_Encode_ConfigurationType_Quantization","0x2"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Length\n\n","StreamId\n\n","ConfigurationType\n\n","This structure acts as a base type for more specialized configuration information. The base type is typecast to a more specialized type based on the ConfigurationType parameter. The mapping between ConfigurationType and the specialized structures is described in the table below.",{"@attributes":{"id":"p-0114","num":"0153"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Configuration Types"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ConfigurationType_MotionEstimation","ConfigurationParameter_MotionEstimation"]},{"entry":["ConfigurationType_Quantization","ConfigurationParameter_Quantization"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0115","num":"0154"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct _VA2_Encode_ExecuteDataParameter_MotionVectors {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003UINT32","\u2003\u2003Length;"]},{"entry":["\u2003\u2003UINT32","\u2003\u2003StreamId;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003VA2_Encode_MVSurface* pMVSurface;"},{"entry":"} VA2_Encode_ExecuteDataParameter_MotionVectors;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Length\n\n","StreamId\n\n","pMVSurface\n\n",{"@attributes":{"id":"p-0119","num":"0161"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct _VA2_Encode_ExecuteDataParameter_Residues {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003UINT32","\u2003\u2003Length;"]},{"entry":[{},"\u2003\u2003UINT32","\u2003\u2003StreamId;"]},{"entry":[{},"\u2003\u2003VA2_Encode_ResidueSurface*","pResidueSurfaceY;"]},{"entry":[{},"\u2003\u2003VA2_Encode_ResidueSurface*","pResidueSurfaceCb;"]},{"entry":[{},"\u2003\u2003VA2_Encode_ResidueSurface*","pResidueSurfaceCr;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} VA2_Encode_ExecuteDataParameter_Residues;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"Length\n\n","StreamId\n\n","pResidueSurfaceY\n\n","pResidueSurfaceCb\n\n","pResidueSurfaceCr\n\n",{"@attributes":{"id":"p-0125","num":"0172"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct _VA2_Encode_ExecuteDataParameter_InputImage {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003UINT32","\u2003\u2003\u2003\u2003Length;"]},{"entry":[{},"\u2003\u2003UINT32","\u2003\u2003\u2003\u2003StreamId;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003VA2_Encode_ImageInfo* pImageData;"]},{"entry":[{},"} VA2_Encode_ExecuteDataParameter_InputImage;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"Length\n\n","StreamId\n\n","pImageData\n\n",{"@attributes":{"id":"p-0129","num":"0179"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef"]},{"entry":[{},"struct _VA2_Encode_ExecuteDataParameter_ReferenceImages {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003UINT32","\u2003\u2003\u2003\u2003Length;"]},{"entry":[{},"\u2003\u2003UINT32","\u2003\u2003\u2003\u2003StreamId;"]},{"entry":[{},"\u2003\u2003UINT32","\u2003\u2003\u2003\u2003NumReferenceImages;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003VA2_Encode_ImageInfo* pReferenceImages"]},{"entry":[{},"} VA2_Encode_ExecuteDataParameter_ReferenceImages;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"Length\n\n","StreamId\n\n","DataType","NumReferenceImages\n\n","pReferenceImages\n\n",{"@attributes":{"id":"p-0135","num":"0189"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct _VA2_Encode_ExecuteDataParameter_DecodedImage {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003UINT32","\u2003\u2003\u2003\u2003Length;"]},{"entry":["\u2003\u2003UINT32","\u2003\u2003\u2003\u2003StreamId;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003VA2_Encode_ImageInfo* pYCbCrImage;"},{"entry":"} VA2_Encode_ExecuteDataParameter_DecodedImage;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Length\n\n","StreamId\n\n","DataType","pYCbCrImage\n\n",{"@attributes":{"id":"p-0140","num":"0197"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct _VA2_Encode_ImageInfo {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003IDirect3DSurface9*","pSurface;"]},{"entry":[{},"\u2003\u2003BOOL","Field;"]},{"entry":[{},"\u2003\u2003BOOL","Interlaced;"]},{"entry":[{},"\u2003\u2003RECT","Window;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} VA2_Encode_ImageInfo;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"pSurface\n\n","Field\n\n","Interlaced\n\n","Window\n\n",{"@attributes":{"id":"p-0145","num":"0206"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct"},{"entry":"_VA2_Encode_ExecuteConfigurationParameter_MotionEstimation {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003UINT32","\u2003\u2003\u2003\u2003Length;"]},{"entry":["\u2003\u2003UINT32","\u2003\u2003\u2003\u2003StreamId;"]},{"entry":["\u2003\u2003UINT32","\u2003\u2003\u2003\u2003ConfigurationType;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003VA2_Encode_MEParameters* pMEParams;"},{"entry":"} VA2_Encode_ExecuteConfigurationParameter_MotionEstimation;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Length\n\n","StreamId\n\n","ConfigurationType","pMEParams\n\n",{"@attributes":{"id":"p-0150","num":"0214"},"figref":"FIG. 7"},"3.3.10 VA2_Encode_SearchResolution",{"@attributes":{"id":"p-0151","num":"0215"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum {"]},{"entry":[{},"\u2003\u2003VA2_Encode_SearchResolution_FullPixel,"]},{"entry":[{},"\u2003\u2003VA2_Encode_SearchResolution_HalfPixel,"]},{"entry":[{},"\u2003\u2003VA2_Encode_SearchResolution_QuarterPixel"]},{"entry":[{},"} VA2_Encode_SearchResolution;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"FullPixel\n\n","HalfPixel\n\n","QuarterPixel\n\n","In computing sub-pixel motion vector values, the encoder estimates luma and chroma values using interpolation. The specific interpolation scheme is format dependent, and the following GUIDs (part of static configuration) control the interpolation scheme.",{"@attributes":{"id":"p-0156","num":"0223"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ {E9AF78CB-7A8A-4d62-887F-B6A418364C79}"},{"entry":"cpp_quote( "},{"entry":"\u201cDEFINE_GUID(VA2_Encode_Interpolation_MPEG2Bilinear,"},{"entry":"0xe9af78cb, 0x7a8a, 0x4d62, 0x88, 0x7f, 0xb6, 0xa4, 0x18, 0x36, 0x4c,"},{"entry":"0x79);\u201d )"},{"entry":"\/\/ (A94BBFCB-1BF1-475c-92DE-67298AF56BB0}"},{"entry":"cpp_quote( "},{"entry":"\u201cDEFINE_GUID(VA2_Encode_Interpolation_MPEG2Bicubic,"},{"entry":"0xa94bbfcb, 0x1bf1, 0x475c, 0x92, 0xde, 0x67, 0x29, 0x8a, 0xf5, 0x6b,"},{"entry":"0xb0);\u201d )"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0157","num":"0224"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct _VA2_Encode_SearchProfile {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003UINT8","QualityLevel;"]},{"entry":[{},"\u2003\u2003UINT8","TimeTaken;"]},{"entry":[{},"\u2003\u2003GUID","SearchTechnique;"]},{"entry":[{},"\u2003\u2003GUID","SubpixelInterpolation;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} VA2_Encode_SearchProfile;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"QualityLevel\n\n","Time Taken\n\n","SearchTechnique\n\n","SubpixelInterpolation","A GUID indicating the subpixel interpolation scheme used.","Remarks","There is no universally accepted definition of absolute quality, so we are settling for a relative measure. The values indicated against TimeTaken should follow a strict proportion rule. If profile 1 takes 10 ms and profile 2 takes 20 ms, the TimeTaken values should be in the ratio 20\/10=2.","3.3.12 VA2_Encode_MBDescription",{"@attributes":{"id":"p-0164","num":"0234"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct _VA2_Encode_MBDescription {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003BOOL","ConstantMBSize;"]},{"entry":[{},"\u2003\u2003UINT32","MBWidth;"]},{"entry":[{},"\u2003\u2003UINT32","MBHeight;"]},{"entry":[{},"\u2003\u2003UINT32","MBCount;"]},{"entry":[{},"\u2003\u2003RECT*","pMBRectangles;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} VA2_Encode_MBDescription;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"ConstantMBSize\n\n","MBWidth\n\n","MBHeight\n\n","MBCount\n\n","pMBRectangles\n\n",{"@attributes":{"id":"p-0170","num":"0245"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct _VA2_Encode_SearchBounds {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003BOOL","DetectSceneChange;"]},{"entry":[{},"\u2003\u2003UINT32","MaxDistanceInMetric;"]},{"entry":[{},"\u2003\u2003UINT32","TimeLimit;"]},{"entry":[{},"\u2003\u2003UINT32","MaxSearchWindowX;"]},{"entry":[{},"\u2003\u2003UINT32","MaxSearchWindowY;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} VA2_Encode_SearchBounds;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"DetectSceneChange\n\n","MaxDistanceInMetric\n\n","TimeLimit\n\n","Search WindowX\n\n","SearchWindowY\n\n",{"@attributes":{"id":"p-0176","num":"0256"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct _VA2_Encode_ModeType {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003UINT32","SearchProfileIndex;"]},{"entry":[{},"\u2003\u2003GUID","DistanceMetric;"]},{"entry":[{},"\u2003\u2003INT16","HintX;"]},{"entry":[{},"\u2003\u2003INT16","HintY;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} VA2_Encode_ModeType;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"SearchProfileIndex\n\n","DistanceMetric\n\n","HintX\n\n","HintY\n\n",{"@attributes":{"id":"p-0181","num":"0265"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef"},{"entry":"struct _VA2_Encode_ExecuteConfigurationParameter_Quantization {"},{"entry":"\u2003UINT32 Length;"},{"entry":"\u2003UINT32 StreamId;"},{"entry":"\u2003UINT32 ConfigurationType;"},{"entry":"\u2003UINT32 StepSize;"},{"entry":"} VA2_Encode_ExecuteConfigurationParameter_Quantization;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Length\n\n","StreamId\n\n","ConfigurationType","StepSize\n\n","The methods in this interface allow an application to query the hardware for its capabilities and create an encoder object with a given configuration.","3.4.1 GetPipelineConfigurations",{"@attributes":{"id":"p-0187","num":"0274"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT GetPipelineConfigurations("]},{"entry":[{},"\u2003[out] UINT32* pCount,"]},{"entry":[{},"\u2003[out, unique, size_is(*pCount)] GUID** pGuids"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"pCount\n\n","pGuids\n\n","S_OK\n\n","E_OUTOFMEMORY\n\n","E_FAIL\n\n",{"@attributes":{"id":"p-0193","num":"0285"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT GetFormats("]},{"entry":[{},"\u2003[out] UINT32* pCount,"]},{"entry":[{},"\u2003[out, unique, size_is(*pCount)] GUID** pGuids"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"pCount\n\n","pGuids\n\n",{"@attributes":{"id":"p-0196","num":"0290"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT GetDistanceMetrics("]},{"entry":[{},"\u2003[out] UINT32* pCount,"]},{"entry":[{},"\u2003[out, unique, size_is(*pCount)] GUID** pGuids"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"pCount\n\n","pGuids\n\n","S_OK\n\n","E_OUTOFMEMORY\n\n","E_FAIL\n\n",{"@attributes":{"id":"p-0202","num":"0301"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT GetSearchProfiles("]},{"entry":[{},"\u2003[out] UINT32* pCount,"]},{"entry":[{},"\u2003[out, unique, size_is(*pCount)] VA2_Encode_SearchProfile**"]},{"entry":[{},"\u2003pSearchProfiles"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"pCount\n\n","pSearchProfiles\n\n","S_OK\n\n","E_OUTOFMEMORY\n\n","E_FAIL\n\n",{"@attributes":{"id":"p-0208","num":"0312"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT GetMECapabilities("]},{"entry":[{},"\u2003[out] VA2_Encode_MECaps* pMECaps"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"pMECaps\n\n","S_OK\n\n","E_FAIL\n\n","This function creates an instance of IVideoEncoder.",{"@attributes":{"id":"p-0213","num":"0320"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT CreateVideoEncoder("]},{"entry":[{},"\u2003[in] REFGUID PipelineGuid,"]},{"entry":[{},"\u2003[in] REFGUID FormatGuid,"]},{"entry":[{},"\u2003[in] UINT32 NumStreams,"]},{"entry":[{},"\u2003[in] VA2_Encode_StaticConfiguration* pConfiguration,"]},{"entry":[{},"\u2003[in, size_is(NumStreams)] VA2_Encode_StreamDescription*"]},{"entry":[{},"\u2003pStreamDescription,"]},{"entry":[{},"\u2003[in, size_is(NumStreams)] VA2_Encode_Allocator*"]},{"entry":[{},"\u2003SuggestedAllocatorProperties,"]},{"entry":[{},"\u2003[out, size_is(NumStreams)] VA2_Encode_Allocator*"]},{"entry":[{},"\u2003pActualAllocatorProperties,"]},{"entry":[{},"\u2003[out] IVideoEncoder** ppEncode"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"PipelineGuid\n\n","FormatGuid\n\n","NumStreams\n\n","pConfiguration\n\n","pStreamDescription\n\n","SuggestedAllocatorProperties\n\n","pActualAllocatorProperties\n\n","ppEncode\n\n","S_OK\n\n","E_FAIL\n\n",{"@attributes":{"id":"p-0224","num":"0341"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct _VA2_Encode_MECaps {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003BOOL","VariableMBSizeSupported;"]},{"entry":[{},"\u2003BOOL","MotionVectorHintSupported;"]},{"entry":[{},"\u2003UINT16","MaxSearchWindowX;"]},{"entry":[{},"\u2003UINT16","MaxSearchWindowY"]},{"entry":[{},"\u2003UINT32","MaxImageWidth;"]},{"entry":[{},"\u2003UINT32","MaxImageHeight;"]},{"entry":[{},"\u2003UINT32","MaxMBSizeX;"]},{"entry":[{},"\u2003UINT32","MaxMBSizeY;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} VA2_Encode_MECaps;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"VariableMBSizeSupported\n\n","MotionVectorHintSupported\n\n","MaxSearchWindowX\n\n","MaxSearchWindowY\n\n","MaxImageWidth\n\n","MaxImageHeight\n\n","MaxMBSizeX\n\n","MaxMBSizeY\n\n",{"@attributes":{"id":"p-0233","num":"0358"},"tables":{"@attributes":{"id":"TABLE-US-00034","num":"00034"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct _VA2_Encode_StaticConfiguration {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003GUID","TransformOperator;"]},{"entry":["\u2003GUID","PixelInterpolation;"]},{"entry":["\u2003GUID","Quantization;"]},{"entry":["\u2003UINT8","NumMotionVectorsPerMB;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003VA2_Encode_MVLayout","MVLayout;"]},{"entry":["\u2003VA2_Encode_ResidueLayout","ResLayout;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} VA2_Encode_StaticConfiguration;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"TransformOperator\n\n","PixelInterpolation\n\n","Quantization\n\n","NumMotionVectorsPerMB\n\n","MVLayout\n\n","ResidueLayout\n\n",{"@attributes":{"id":"p-0240","num":"0371"},"tables":{"@attributes":{"id":"TABLE-US-00035","num":"00035"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _VA2_Encode_Allocator {"]},{"entry":[{},"\u2003BOOL ExternalAllocator;"]},{"entry":[{},"\u2003UINT32 NumSurfaces;"]},{"entry":[{},"} VA2_Encode_Allocator;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"ExternalAllocator\n\n","NumSurfaces\n\n",{"@attributes":{"id":"p-0243","num":"0376"},"tables":{"@attributes":{"id":"TABLE-US-00036","num":"00036"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _VA2_Encode_StreamDescription {"]},{"entry":[{},"\u2003UINT32 Length;"]},{"entry":[{},"\u2003UINT32 StreamType;"]},{"entry":[{},"} VA2_Encode_StreamDescription;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Length\n\n","StreamType\n\n","This base structure is typecast to a derived type on the StreamType field. The typecasts are described in the documentation for VA2_Encode_StreamType.","3.5.5 VA2_Encode_StreamType",{"@attributes":{"id":"p-0247","num":"0382"},"tables":{"@attributes":{"id":"TABLE-US-00037","num":"00037"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#define VA2_Encode_StreamType_Video","0x1"]},{"entry":[{},"#define VA2_Encode_StreamType_MV","0x2"]},{"entry":[{},"#define VA2_Encode_StreamType_Residues","0x3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"VA2_Encode_StreamType_Video\n\n","VA2_Encode_StreamType_MV\n\n","VA2_Encode_StreamType_Residues\n\n",{"@attributes":{"id":"p-0251","num":"0389"},"tables":{"@attributes":{"id":"TABLE-US-00038","num":"00038"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _VA2_Encode_StreamDescription {"]},{"entry":[{},"\u2003UINT32 Length;"]},{"entry":[{},"\u2003UINT32 StreamType;"]},{"entry":[{},"\u2003VA2_VideoDesc VideoDescription;"]},{"entry":[{},"} VA2_Encode_StreamDescription;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Length\n\n","StreamType\n\n","VideoDescription\n\n",{"@attributes":{"id":"p-0255","num":"0396"},"tables":{"@attributes":{"id":"TABLE-US-00039","num":"00039"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _VA2_Encode_StreamDescription {"]},{"entry":[{},"\u2003UINT32 Length;"]},{"entry":[{},"\u2003UINT32 StreamType;"]},{"entry":[{},"\u2003VA2_Encode_MVType MVType;"]},{"entry":[{},"\u2003VA2_Encode_MVLayout MVLayout;"]},{"entry":[{},"} VA2_Encode_StreamDescription;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Length\n\n","StreamType\n\n","MVType\n\n","MVLayout\n\n",{"@attributes":{"id":"p-0260","num":"0405"},"tables":{"@attributes":{"id":"TABLE-US-00040","num":"00040"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct _VA2_Encode_StreamDescription {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"UINT32 Length;"]},{"entry":[{},"UINT32 StreamType;"]},{"entry":[{},"VA2_Encode_SamplingType SamplingType;"]},{"entry":[{},"UINT32 LumaWidth;"]},{"entry":[{},"UINT32 LumaHeight;"]},{"entry":[{},"UINT32 ChromaCbWidth;"]},{"entry":[{},"UINT32 ChromaCbHeight;"]},{"entry":[{},"UINT32 ChromaCrWidth;"]},{"entry":[{},"UINT32 ChromaCrHeight;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} VA2_Encode_StreamDescription;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"Length\n\n","StreamType\n\n","SamplingType\n\n","LumaWidth\n\n","LumaHeight\n\n","ChromaCbWidth\n\n","ChromaCbHeight\n\n","ChromaCrWidth\n\n","ChromaCrHeight\n\n",{"@attributes":{"id":"p-0270","num":"0424"},"figref":"FIG. 8"},"3.6.2 New D3D Formats",{"@attributes":{"id":"p-0271","num":"0425"},"tables":{"@attributes":{"id":"TABLE-US-00041","num":"00041"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum _D3DFORMAT"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003D3DFMT_MOTIONVECTOR16 = 105,"]},{"entry":[{},"\u2003\u2003D3DFMT_MOTIONVECTOR32 = 106,"]},{"entry":[{},"\u2003\u2003D3DFMT_RESIDUE16\u2003\u2003\u2003\u2003= 107,"]},{"entry":[{},"} D3DFORMAT;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Motion Vectors Surfaces and Residue Surfaces are associated with the above new D3D Format types which indicate the size of individual Motion Vectors and Residues. This size information is used by the driver when the application creates surfaces using one of the surface or resource creation APIs provided by. The resource flag associated with encode surfaces is VA2_EncodeBuffer.",{"@attributes":{"id":"p-0273","num":"0427"},"tables":{"@attributes":{"id":"TABLE-US-00042","num":"00042"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Buffer Type"]},{"entry":[{},"enum"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003VA2_EncodeBuffer = 7,"]},{"entry":[{},"};"]},{"entry":[{},"typedef struct _D3DDDI_RESOURCEFLAGS"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003union"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003struct"]},{"entry":[{},"\u2003\u2003\u2003\u2003{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003UINT \u2003\u2003TextApi",": 1; \u2003\u2003\/\/ 0x20000000"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003UINT \u2003\u2003EncodeBuffer",": 1; \u2003\u2003\/\/ 0x40000000"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003UINT \u2003\u2003Reserved",": 1; \u2003\u2003\/\/ 0x80000000"]},{"entry":[{},"\u2003\u2003\u2003\u2003};"]},{"entry":[{},"\u2003\u2003\u2003\u2003UINT \u2003\u2003\u2003\u2003Value;"]},{"entry":[{},"\u2003\u2003};"]},{"entry":[{},"} D3DDDI_RESOURCEFLAGS;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"This structure is effectively derived from IDirect3DSurface9, and carries state information that allows one to interpret the contents of the embedded D3D surface.",{"@attributes":{"id":"p-0275","num":"0429"},"tables":{"@attributes":{"id":"TABLE-US-00043","num":"00043"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct _VA2_Encode_MVSurface {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003IDirect3DSurface9*","\u2003\u2003pMVSurface;"]},{"entry":[{},"\u2003\u2003VA2_Encode_MVType","MVType;"]},{"entry":[{},"\u2003\u2003VA2_Encode_MVLayout","MVLayout;"]},{"entry":[{},"\u2003\u2003GUID","\u2003\u2003DistanceMetric;"]},{"entry":[{},"} VA2_Encode_MVSurface;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"pMVSurface\n\n","MVType\n\n","MVLayout\n\n","DistanceMetric\n\n","This enumeration value is used to decode the contents of the Motion Vector D3D9 Surface. Depending on the type of Motion Vector, one of several different Motion Vector structures is used to interpret the contents of the surface.",{"@attributes":{"id":"p-0281","num":"0439"},"tables":{"@attributes":{"id":"TABLE-US-00044","num":"00044"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum {"]},{"entry":[{},"\u2003\u2003VA2_Encode_MVType_Simple8,"]},{"entry":[{},"\u2003\u2003VA2_Encode_MVType_Simple16,"]},{"entry":[{},"\u2003\u2003VA2_Encode_MVType_Extended8,"]},{"entry":[{},"\u2003\u2003VA2_Encode_MVType_Extended16"]},{"entry":[{},"} VA2_Encode_MVType;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"VA2_Encode_MVType_Simple8\n\n","VA2_Encode_MVType_Simple16\n\n","VA2_Encode_MVType_Extended8\n\n","VA2_Encode_MVType_Extended16\n\n",{"@attributes":{"id":"p-0286","num":"0448"},"tables":{"@attributes":{"id":"TABLE-US-00045","num":"00045"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum {"]},{"entry":[{},"\u2003\u2003VA2_Encode_MVLayout_A,"]},{"entry":[{},"\u2003\u2003VA2_Encode_MVLayout_B,"]},{"entry":[{},"\u2003\u2003VA2_Encode_MVLayout_C"]},{"entry":[{},"} VA2_Encode_MVLayout;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Type A\n\n","Type B\n\n","Type C","3.6.6 VA2_Encode_MotionVector8",{"@attributes":{"id":"p-0290","num":"0454"},"tables":{"@attributes":{"id":"TABLE-US-00046","num":"00046"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _VA2_Encode_MotionVector8 {"]},{"entry":[{},"\u2003\u2003INT8 \u2003\u2003x;"]},{"entry":[{},"\u2003\u2003INT8 \u2003\u2003y;"]},{"entry":[{},"} VA2_Encode_MotionVector8;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"x\n\n","y\n\n",{"@attributes":{"id":"p-0293","num":"0459"},"tables":{"@attributes":{"id":"TABLE-US-00047","num":"00047"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _VA2_Encode_MotionVector16 {"]},{"entry":[{},"\u2003\u2003INT16 \u2003\u2003x;"]},{"entry":[{},"\u2003\u2003INT16 \u2003\u2003y;"]},{"entry":[{},"} VA2_Encode_MotionVector16;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"x\n\n","y\n\n",{"@attributes":{"id":"p-0296","num":"0464"},"tables":{"@attributes":{"id":"TABLE-US-00048","num":"00048"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct _VA2_Encode_MotionVectorEx8 {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003INT8","x;"]},{"entry":[{},"\u2003\u2003INT8","y;"]},{"entry":[{},"\u2003\u2003UINT8","ImageIndex;"]},{"entry":[{},"\u2003\u2003UINT8","Distance;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} VA2_Encode_MotionVectorEx8;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"x\n\n","y\n\n","ImageIndex\n\n","Distance\n\n",{"@attributes":{"id":"p-0301","num":"0473"},"tables":{"@attributes":{"id":"TABLE-US-00049","num":"00049"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct _VA2_Encode_MotionVectorEx16 {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003INT16","x;"]},{"entry":[{},"\u2003\u2003INT16","y;"]},{"entry":[{},"\u2003\u2003UINT16","ImageIndex;"]},{"entry":[{},"\u2003\u2003UINT16","Distance;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} VA2_Encode_MotionVectorEx16;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"x\n\n","y\n\n","ImageIndex\n\n","Distance\n\n","In this implementation, a residue surface is an array of signed integer values that are two bytes long\u2014e.g., of type INT16. This scheme is practical. For example, MPEG-2 deals with 9 bit residue values and H.264 deals with 12 bit residues. Also, if the original data was YUY2, the luma values occupy one byte each, and hence the residues use 9 bits (0\u2212255=\u2212255). Further, applying a DCT-type transform increases the data requirement to 11 bits per residue value. All of these cases are adequately addressed by using 2 byte long signed residue values.","The width of a residue surface is the number of residue values in a line. For example, a 640\u00d7480 progressive image with 4:2:2 sampling has 640 luma values and 320 chroma values per line. The size of associated the luma surface is 640\u00d7480\u00d72 and that of the chroma surface is 320\u00d7480\u00d72 bytes.","Residue Surfaces are created using the D3DFMT_RESIDUE16 format flag and VA2_EncodeBuffer resource type.","3.7.1 Luma Plane",{"@attributes":{"id":"p-0309","num":"0485"},"figref":"FIG. 9"},"Plane=VA2_Encode_Residue_Y","Sampling=VA2_Encode_SamplingType_*","3.7.2 Chroma 4:2:2",{"@attributes":{"id":"p-0312","num":"0488"},"figref":"FIG. 10"},"Plane=VA2_Encode_Residue_U or VA_Encode_Residue_V","Sampling=VA2_Encode_SamplingType422","3.7.3 Chroma 4:2:0",{"@attributes":{"id":"p-0315","num":"0491"},"figref":"FIG. 11"},"Plane=VA2_Encode_Residue_U or VA_Encode_Residue_V","Sampling=VA2_Encode_SamplingType420","4 Exemplary DDI Documentation","Extension Devices are a pass-through mechanism provided by the VA Interfaces to add new functionality in addition to Video Decoder and Video Processor functions. For example, in one implementation, such a mechanism is used to support a new Video Encoder function.","Extension Devices are analogous to an untyped funnel through which the application can send\/receive data to\/from the driver. The meaning of the data is unknown to the VA stack, and is interpreted by the driver based on the pGuid parameter of the CreateExtensionDevice call, and the Function parameter of ExtensionExecute.","VA Encode uses the following GUID value (same as the uuid of IVideoEncoder):",{"@attributes":{"id":"p-0321","num":"0497"},"tables":{"@attributes":{"id":"TABLE-US-00050","num":"00050"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{7AC3D93D-41FC-4c6c-A1CB-A875E4F57CA4}"]},{"entry":[{},"DEFINE_GUID(VA_Encoder_Extension, 0x7ac3d93d, 0x41fc,"]},{"entry":[{},"0x4c6c, 0xa1, 0xcb, 0xa8, 0x75, 0xe4, 0xf5, 0x7c, 0xa4);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Extension Devices are enumerated using the FND3DDDI_GETCAPS with the type parameter being set to GETEXTENSIONGUIDCOUNT or GETEXTENSIONGUIDS. The codec application looks for VA_Encoder_Extension in the list of extension guids returned by GETEXTENSIONGUIDS to determine whether VA Encode support is available.","4.1.1 FND3DDDI_GETCAPS",{"@attributes":{"id":"p-0323","num":"0499"},"tables":{"@attributes":{"id":"TABLE-US-00051","num":"00051"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef HRESULT"]},{"entry":[{},"(APIENTRY *PFND3DDDI_GETCAPS)"]},{"entry":[{},"("]},{"entry":[{},"\u2003\u2003HANDLE hAdapter,"]},{"entry":[{},"\u2003\u2003CONST D3DDDIARG_GETCAPS*"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"When querying for capabilities of the extension device (the Encoder device), the GETEXTENSIONCAPS is used with the following structure as pInfo in the D3DDDIARG_GETCAPS structure.","4.1.2 VADDI_QUERYEXTENSIONCAPSINPUT",{"@attributes":{"id":"p-0325","num":"0501"},"tables":{"@attributes":{"id":"TABLE-US-00052","num":"00052"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _VADDI_QUERYEXTENSIONCAPSINPUT"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003CONST GUID*","\u2003\u2003pGuid;"]},{"entry":[{},"\u2003\u2003UINT","\u2003\u2003CapType;"]},{"entry":[{},"\u2003\u2003VADDI_PRIVATEDATA*","pPrivate;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} VADDI_QUERYEXTENSIONCAPSINPUT;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The pGuid parameter of VADDI_QUERYEXTENSIONCAPSINPUT is set to VA_Encoder_Extension.",{"@attributes":{"id":"p-0327","num":"0503"},"tables":{"@attributes":{"id":"TABLE-US-00053","num":"00053"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define VADDI_Encode_Captype_Guids","VADDI_EXTENSION_CAPTYPE_MIN"]},{"entry":["#define VADDI_Encode_Captype_DistanceMetrics","VADDI_EXTENSION_CAPTYPE_MIN + 1"]},{"entry":["#define VADDI_Encode_Captype_SearchProfiles","VADDI_EXTENSION_CAPTYPE_MIN + 2"]},{"entry":["#define VADDI_Encode_Captype_MECaps","VADDI_EXTENSION_CAPTYPE_MIN + 3"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The output of GETEXTENSIONCAPS is encapsulated in the pData parameter of D3DDDIARG_GETCAPS. The pData parameter is interpreted as follows:\n\n","The actual creation happens via a D3DDDI_CREATEEXTENSIONDEVICE call, whose primary argument is shown below:",{"@attributes":{"id":"p-0330","num":"0510"},"tables":{"@attributes":{"id":"TABLE-US-00054","num":"00054"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _D3DDDIARG_CREATEEXTENSIONDEVICE"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003CONST GUID*","\u2003\u2003pGuid;"]},{"entry":[{},"\u2003\u2003VADDI_PRIVATEDATA*","pPrivate;"]},{"entry":[{},"\u2003\u2003HANDLE","\u2003\u2003hExtension;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} D3DDDIARG_CREATEEXTENSIONDEVICE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"The actual extension unit functions are invoked via a D3DDDI_EXTENSIONEXECUTE call. The instance of the Extension Unit is already associated with a GUID, so the type of the extension unit is already known when the execute call is made. The only additional parameter is Function which indicates the particular operation to perform. For example an Extension Device of type Encoder, may support MotionEstimation as one of its functions. Typically, the Extension Device will have a GetCaps function of its own that enumerates the capabilities of the Extension Device.",{"@attributes":{"id":"p-0332","num":"0512"},"tables":{"@attributes":{"id":"TABLE-US-00055","num":"00055"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _D3DDDIARG_EXTENSIONEXECUTE"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HANDLE","hExtension;"]},{"entry":[{},"UINT","Function;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"VADDI_PRIVATEDATA*","pPrivateInput;"]},{"entry":[{},"VADDI_PRIVATEDATA*","pPrivateOutput;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"UINT","NumBuffers;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"VADDI_PRIVATEBUFFER*","pBuffers;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} D3DDDIARG_EXTENSIONEXECUTE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The pBuffers parameter is not used by VA Encode, and should be considered a reserved parameter. The Function parameter takes the following values for VA Encode:","#define VADDI_Encode_Function_Execute 1","The pPrivateInput and pPrivateOutput parameters of D3DDDIARG_EXTENSIONEXECUTE are used to encapsulate the parameters of the Execute API call.","4.2.1 VADDI_Encode_Function_Execute_Input","This parameter contains the input parameters to the Execute API call.",{"@attributes":{"id":"p-0337","num":"0517"},"tables":{"@attributes":{"id":"TABLE-US-00056","num":"00056"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _VADDI_Encode_Function_Execute_Input"]},{"entry":[{},"{"]},{"entry":[{},"\u2003UINT32 NumDataParameters;"]},{"entry":[{},"\u2003VA2_Encode_ExecuteDataParameter** pData;"]},{"entry":[{},"\u2003UINT32 NumConfigurationParameters;"]},{"entry":[{},"\u2003VA2_Encode_ExecuteConfigurationParameter** pConfiguration;"]},{"entry":[{},"} VADDI_Encode_Function_Execute_Input;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"This structure encapsulates the output data from the Execute call.",{"@attributes":{"id":"p-0339","num":"0519"},"tables":{"@attributes":{"id":"TABLE-US-00057","num":"00057"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _VADDI_Encode_Function_Execute_Output"]},{"entry":[{},"{"]},{"entry":[{},"\u2003UINT32 NumDataParameters;"]},{"entry":[{},"\u2003VA2_Encode_ExecuteDataParameter** pData;"]},{"entry":[{},"} VADDI_Encode_Function_Execute_Output;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The following sections describe various structures and function callbacks associated with the VA Extension mechanism.","4.3.1 VADDI_PRIVATEBUFFER",{"@attributes":{"id":"p-0341","num":"0521"},"tables":{"@attributes":{"id":"TABLE-US-00058","num":"00058"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _VADDI_PRIVATEBUFFER"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HANDLE","hResource;"]},{"entry":[{},"UINT","SubResourceIndex;"]},{"entry":[{},"UINT","DataOffset;"]},{"entry":[{},"UINT","DataSize;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} VADDI_PRIVATEBUFFER;"]},{"entry":[{},"typedef struct _VADDI_PRIVATEDATA"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"VOID*","pData;"]},{"entry":[{},"UINT","DataSize;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} VADDI_PRIVATEDATA;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0342","num":"0522"},"tables":{"@attributes":{"id":"TABLE-US-00059","num":"00059"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _D3DDDIARG_EXTENSIONEXECUTE"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HANDLE","hExtension;"]},{"entry":[{},"UINT","Function;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"VADDI_PRIVATEDATA*","pPrivateInput;"]},{"entry":[{},"VADDI_PRIVATEDATA*","pPrivateOutput;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"UINT","NumBuffers;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"VADDI_PRIVATEBUFFER*","pBuffers;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} D3DDDIARG_EXTENSIONEXECUTE;"]},{"entry":[{},"typedef HRESULT"]},{"entry":[{},"\u2002(APIENTRY *PFND3DDDI_CREATEEXTENSIONDEVICE)"]},{"entry":[{},"("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HANDLE hDevice,"]},{"entry":[{},"D3DDDIARG_CREATEEXTENSIONDEVICE*"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The hDevice parameter refers to a D3D9 device, and it is created using a call to D3DDDI_CREATEDEVICE.","4.3.3 FND3DDDI_DESTROYEXTENSIONDEVICE",{"@attributes":{"id":"p-0344","num":"0524"},"tables":{"@attributes":{"id":"TABLE-US-00060","num":"00060"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef HRESULT"]},{"entry":[{},"(APIENTRY *PFND3DDDI_DESTROYEXTENSIONDEVICE)"]},{"entry":[{},"("]},{"entry":[{},"\u2003HANDLE hDevice,"]},{"entry":[{},"\u2003HANDLE hExtension"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0345","num":"0525"},"tables":{"@attributes":{"id":"TABLE-US-00061","num":"00061"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef HRESULT"]},{"entry":[{},"(APIENTRY *PFND3DDDI_EXTENSIONEXECUTE)"]},{"entry":[{},"("]},{"entry":[{},"\u2003HANDLE hDevice,"]},{"entry":[{},"\u2003CONST D3DDDIARG_EXTENSIONEXECUTE*"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0346","num":"0526"},"tables":{"@attributes":{"id":"TABLE-US-00062","num":"00062"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct _D3DDDI_DEVICEFUNCS"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PFND3DDDI_CREATEEXTENSIONDEVICE","pfnCreateExtensionDevice;"]},{"entry":[{},"PFND3DDDI_DESTROYEXTENSIONDEVICE","pfnDestroyExtensionDevice;"]},{"entry":[{},"PFND3DDDI_EXTENSIONEXECUTE","pfnExtensionExecute;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} D3DDDI_DEVICEFUNCS;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The following D3D structures and callback represent a generic D3D mechanism to obtain the capabilities of an extension device.",{"@attributes":{"id":"p-0348","num":"0528"},"tables":{"@attributes":{"id":"TABLE-US-00063","num":"00063"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum _D3DDDICAPS_TYPE"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"D3DDDICAPS_GETEXTENSIONGUIDCOUNT","=31,"]},{"entry":[{},"D3DDDICAPS_GETEXTENSIONGUIDS","=32,"]},{"entry":[{},"D3DDDICAPS_GETEXTENSIONCAPS","=33,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} D3DDDICAPS_TYPE;"]},{"entry":[{},"typedef struct _D3DDDIARG_GETCAPS"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"D3DDDICAPS_TYPE","Type;"]},{"entry":[{},"VOID*","pInfo;"]},{"entry":[{},"VOID*","pData;"]},{"entry":[{},"UINT","DataSize;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} D3DDDIARG_GETCAPS;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}]},"In one implementation, to achieve maximum efficiency, the encoder application  is structured to full utilize processor(s)  and graphics hardware . In one example, while Motion Estimation is in progress for a certain frame, the Quantization Step may be executed on a different frame.","Obtaining full hardware utilization is facilitated with a multi-threaded encoder.","5.1.1 Example: Single Motion Vector (Pipeline Full)","The following 2-threaded application (in pseudo-code) illustrates one way for the encoder  to implement a 2-stage software pipeline, and offers some examples of how to use the VA Encode interfaces  effectively. This particular implementation enforces a buffering of k=AllocatorSize as seen in the software thread. This accounts that there is asynchrony in the submission of a hardware request: the hardware thread submits requests while the software thread picks up the results after a while and processes them.",{"@attributes":{"id":"p-0352","num":"0532"},"tables":{"@attributes":{"id":"TABLE-US-00064","num":"00064"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"HardwareThread( )"},{"entry":"{"},{"entry":"\u2003while (Streaming)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003LoadFrame(ppInputBuffer[n]);"},{"entry":"\u2003\u2003Codec->ProcessInput(ppInputBuffer[n]); \/\/ blocking GetBuffer +"},{"entry":"\u2003\u2003Execute"},{"entry":"\u2003}"},{"entry":"}"},{"entry":"SoftwareThread( )"},{"entry":"{"},{"entry":"\u2003k = AllocatorSize( );"},{"entry":"\u2003while (Streaming)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003\/\/ k represents the buffer between pipeline stages"},{"entry":"\u2003\u2003Codec->ProcessOutput(ppOutputBuffer[n\u2212k]); \/\/ Wait, ReleaseBuffer"},{"entry":"\u2003\u2003VLE( );"},{"entry":"\u2003\u2003Bitstream( );"},{"entry":"\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"ProcessInput above may be considered a wrapper around Execute and GetBuffer, while ProcessOutput may be considered a wrapper around a Wait on the execute event, followed up with appropriate ReleaseBuffer calls.","Parameter k represents the buffer between the pipeline stages. It denotes the allocator size, and as a starting point, we could use the same value used in the allocator negotiation between the Codec and the VA Encoder object (the queue length). If k is larger than the allocator size, then the ProcessInput call is likely to block anyway even before the k buffers get used.","The goal of the application should be to maximize time spent in SoftwareThread without blocking on ProcessOutput. In other words the application should be working on the VLE( ) and Bitstream( ) functions most of the time. If the hardware is very slow, then ProcessOutput( ) will block despite the allocator size of \u201ck\u201d. Software will always be \u201cahead\u201d. The above pipeline is efficient only to the extent that the hardware takes about as much time to process a buffer as software takes to run VLE and Bitstream. All that the buffering of \u201ck\u201d achieves is to pad for jitters.","The following code fragment shows an exemplary pseudocode implementation of GetBuffer and ReleaseBuffer.",{"@attributes":{"id":"p-0357","num":"0537"},"tables":{"@attributes":{"id":"TABLE-US-00065","num":"00065"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IVideoEncoder::GetBuffer(Type, ppBuffer, Blocking)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003if (Empty)"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003if (Blocking) Wait(NotEmptyEvent);"]},{"entry":[{},"\u2003\u2003else return STATUS_EMPTY;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003*ppBuffer = pQueue[Type][Head];"]},{"entry":[{},"\u2003Head++;"]},{"entry":[{},"\u2003if (Head == Tail)"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003Empty = 1;"]},{"entry":[{},"\u2003\u2003ResetEvent(NotEmptyEvent);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003return S_OK;"]},{"entry":[{},"}"]},{"entry":[{},"IVideoEncoder::ReleaseBuffer(Type, pBuffer)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003if ((Tail == Head) && !Empty) return STATUS_FULL;"]},{"entry":[{},"\u2003pQueue[Type][Tail] = pBuffer;"]},{"entry":[{},"\u2003Tail++;"]},{"entry":[{},"\u2003if (Empty)"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003Empty = false;"]},{"entry":[{},"\u2003\u2003SetEvent(NotEmptyEvent);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003return S_OK;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The following sketches out the codec's implementation of ProcessInput and ProcessOutput:",{"@attributes":{"id":"p-0359","num":"0539"},"tables":{"@attributes":{"id":"TABLE-US-00066","num":"00066"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ this implementation is blocking contrary to normal semantics"]},{"entry":[{},"Codec::ProcessInput(IMediaBuffer pInput)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003GetBuffer(TypeUncompressed, pYUVBuffer, true);"]},{"entry":[{},"\u2003GetBuffer(TypeMotionVector, pMVBuffer, true);"]},{"entry":[{},"\u2003GetBuffer(TypeResidues, pResidueBuffer, true);"]},{"entry":[{},"\u2003memcpy(pYUVBuffer, pInput.Image);"]},{"entry":[{},"\u2003Execute(pYUVBuffer, pMVBuffer, pResidueBuffer, pEvent);"]},{"entry":[{},"\u2003CodecQueue.Enqueue(pYUVBuffer, pMVBuffer, pResidueBuffer,"]},{"entry":[{},"\u2003pEvent);"]},{"entry":[{},"}"]},{"entry":[{},"Codec::ProcessOutput(IMediaBuffer pOutput)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003if (CodecQueue.Empty( ))"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003pOutput.dwFlags ="]},{"entry":[{},"\u2003\u2003DMO_OUTPUT_DATABUFFERF_INCOMPLETE;"]},{"entry":[{},"\u2003\u2003return S_FALSE;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003CodecQueue.Dequeue(pYUVBuffer, pMVBuffer, pResidueBuffer,"]},{"entry":[{},"\u2003pEvent);"]},{"entry":[{},"\u2003Wait(pEvent);"]},{"entry":[{},"\u2003memcpy(pOutput.MVBuffer, pMVBuffer);"]},{"entry":[{},"\u2003memcpy(pOutput.ResidueBuffer, pResidueBuffer);"]},{"entry":[{},"\u2003ReleaseBuffer(TypeUncompressed, pYUVBuffer);"]},{"entry":[{},"\u2003ReleaseBuffer(TypeMotionVector, pMVBuffer);"]},{"entry":[{},"\u2003ReleaseBuffer(TypeResidues, pResidueBuffer);"]},{"entry":[{},"\u2003return S_OK;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Here is an alternate implementation of Codec::ProcessInput that is non-blocking as is the norm.",{"@attributes":{"id":"p-0361","num":"0541"},"tables":{"@attributes":{"id":"TABLE-US-00067","num":"00067"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Codec::ProcessInput(IMediaBuffer pInput)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003if (GetBuffer(TypeUncompressed, pYUVBuffer, false) =="]},{"entry":[{},"\u2003STATUS_EMPTY)"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003return DMO_E_NOTACCEPTING;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003if (GetBuffer(TypeMotionVector, pMVBuffer, false) =="]},{"entry":[{},"\u2003STATUS_EMPTY)"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003return DMO_E_NOTACCEPTING;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003if (GetBuffer(TypeResidues, pResidueBuffer, false) =="]},{"entry":[{},"\u2003STATUS_EMPTY)"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003return DMO_E_NOTACCEPTING;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003memcpy(pYUVBuffer, pInput.Image);"]},{"entry":[{},"\u2003Execute(pYUVBuffer, pMVBuffer, pResidueBuffer, pEvent);"]},{"entry":[{},"\u2003CodecQueue.Enqueue(pYUVBuffer, pMVBuffer, pResidueBuffer,"]},{"entry":[{},"\u2003pEvent);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"An exemplary complex pipeline is now described, where the encoder  requests multiple motion vectors from hardware and chooses one based on various parameters and resubmits them for processing. The following code naively continues to use a 2-stage pipeline as before, requests multiple motion vectors and resubmits the best one. There is inherent serialization involved in this.",{"@attributes":{"id":"p-0363","num":"0543"},"tables":{"@attributes":{"id":"TABLE-US-00068","num":"00068"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HardwareThread( )"]},{"entry":[{},"{"]},{"entry":[{},"\u2003while (Streaming)"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003LoadFrame(ppInputBuffer[n]);"]},{"entry":[{},"\u2003\u2003ProcessInput(ppInputBuffer[n]);"]},{"entry":[{},"\u2003\u2003ProcessOutput(ppOutputBuffer[n]);"]},{"entry":[{},"\u2003\u2003SelectMV(ppOutputBuffer[n], ppOutputBuffer2[n]);"]},{"entry":[{},"\u2003\u2003ProcessInput2(ppOutputBuffer2[n]);"]},{"entry":[{},"\u2003\u2003n++;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},"SoftwareThread( )"]},{"entry":[{},"{"]},{"entry":[{},"\u2003while (Streaming)"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003ProcessOutput2(ppOutputBuffer2[n \u2212 k]);"]},{"entry":[{},"\u2003\u2003VLE(ppOutputBuffer2[n \u2212 k]);"]},{"entry":[{},"\u2003\u2003Bitstream(ppOutputBuffer2[n \u2212 k]);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In the above example, software operatios are blocked on ProcessOutput and ProcessOutput2 half of the time, negatively effecting pipeline efficiency. On the other hand CPU utilization will be quite low, and the overall throughput is still higher than non-accelerated encode.","A 3-stage pipeline based on 3 threads will solve the serialization problem as follows:",{"@attributes":{"id":"p-0366","num":"0546"},"tables":{"@attributes":{"id":"TABLE-US-00069","num":"00069"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HardwareThread1( )"]},{"entry":[{},"{"]},{"entry":[{},"\u2003while (Streaming)"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003LoadFrame(ppInputBuffer[n]);"]},{"entry":[{},"\u2003\u2003ProcessInput(ppInputBuffer[n]);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},"HardwareThread2( )"]},{"entry":[{},"{"]},{"entry":[{},"\u2003while (Streaming)"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003ProcessOutput(ppOutputBuffer[n \u2212 k1]);"]},{"entry":[{},"\u2003\u2003SelectMV(ppOutputBuffer[n \u2212 k1], ppOutputBuffer2[n \u2212 k1]);"]},{"entry":[{},"\u2003\u2003ProcessInput2(ppOutputBuffer2[n \u2212 k1]);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},"SoftwareThread( )"]},{"entry":[{},"{"]},{"entry":[{},"\u2003while (Streaming)"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003ProcessOutput2(ppOutputBuffer2[n \u2212 k1 \u2212 k2]);"]},{"entry":[{},"\u2003\u2003VLE(ppOutputBuffer2[n \u2212 k1 \u2212 k2]);"]},{"entry":[{},"\u2003\u2003Bitstream(ppOutputBuffer2[n \u2212 k1 \u2212 k2]);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Since there are 3 pipeline stages, additional buffer is added to pad between the two hardware stages. Hence the two values k1 and k2."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In the Figures, the left-most digit of a component reference number identifies the particular Figure in which the component first appears.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
