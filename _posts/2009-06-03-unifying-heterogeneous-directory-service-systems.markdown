---
title: Unifying heterogeneous directory service systems
abstract: A unification point that federates heterogeneous directory service systems can include an identifier communion table for storing a set of records, each record indexing a unified object ID to a directory object ID and a directory ID. The directory ID can be a unique identifier of a directory service system. The directory object ID can be a unique identifier of a record maintained by the directory service system. The unification point can also include a computer program product for accepting directory service requests including a unified object ID, for using the identifier communion table to look up a corresponding directory object ID and directory ID, for generating a modified directory service requests that substitutes the directory object ID for the unified object ID, for conveying the modified directory service requests to the directory service system, for receiving a response, and for conveying the response to a request issuing entity.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08365204&OS=08365204&RS=08365204
owner: International Business Machines Corporation
number: 08365204
owner_city: Armonk
owner_country: US
publication_date: 20090603
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present invention relates to the field of collaborative computing and, more particularly, to unifying heterogeneous directory service systems.","A directory service is a service of a software system that stores, organizes and provides access to information in a directory. Directory services can look-up a uniquely identified individual and information associated with the individual. Unique directory objects often include users, groups, communities, membership, etc. Increasingly, it is desirable to make directory service information maintained in an enterprise system available to computing systems and applications outside the enterprise. This is especially true with many different types of collaboration applications, business to business applications, and social networking applications. Social networking applications, for example, often rely on directory services to provide account information. This practice contributes to a myriad of aspects of the social networking application\u2014from the security to defining peer groupings and social network relationships.","Few integration problems result when a collaboration application (e.g., LOTUS CONNECTIONS) interfaces with a homogenous directory service system. This is especially true when the homogeneous directory service infrastructure based upon a single, popular standard, such as implementing enterprise-wide Lightweight Directory Access Protocol (LDAP) directory services. Unfortunately, enterprises do not necessarily maintain directory services as a homogenous manner. For instance, multiple different LDAP services can be employed to handle user accounts and groupings for corporate applications among different geographical locations, countries, and cultures with different languages. In many corporate infrastructures, different functional or geographic units of the corporation have local control and responsibility for maintaining information technology (IT) resources, which naturally results in non-uniform handling of IT resources including non-uniform handling of directory services.","Further, there is a growing demand from business partners to have machine-to-machine access to portions of an enterprise's computing environment to conduct business-to-business (B2B), business-to-consumer (B2C), and other e-business transactions. Directory services of an enterprise generally do not maintain unified records in their directory service system for business partners (B2B) and\/or consumers (B2C) even though this information can be highly relevant to a collaboration application that relies upon directory service obtained information. It is expected that collaboration applications that depend upon directory service information (i.e., to determine unique users, groups, community memberships, etc.) will increasingly have to operate in environments that maintains needed information in a heterogeneous set of directory service systems.","Historical attempts to handle problems associated with heterogeneous directory service systems have been directed to consolidating information maintained by the heterogeneous set of systems into a single \u201cmaster\u201d directory management system. Often, a consolidation approach fails or requires significant situation unique work-arounds to be implemented, which are costly to establish, test, and maintain. That is, it is often not possible, by nature of directory services, to perform a straight forward consolidation of heterogeneous systems.","To elaborate, collaboration applications typically access directory services via Application Programming Interfaces (APIs). The core of this type of access requires identifying unique directory objects (e.g., users\/groups) which can be structured in a manner specific to a particular directory service system. Typically, a canonical format for an object ID present in a directory service system is used to access directory objects. This canonical format can vary from system-to-system in a heterogeneous environment. Further, although all records of a discrete directory service system may be unique (as required), this uniqueness can fail when combined with data of other systems. Attempts to adjust data from different systems when forming a consolidated \u201cmaster\u201d directory service system, can cause original object identifiers to change. Thus, a canonical format valid in a homogeneous realm can be unrecognized in the federated realm, due to enforced uniqueness constraints, use non-canonical encoded IDs (e.g., proprietary\/custom ID schema) within discrete ones of the directory service systems, and other such problems.","One aspect of the disclosure includes a method for applications to acquire directory service information from a heterogeneous set of directory service systems. A unification point comprising software executing on hardware having an API interface for accepting and conveying directory service messages can be identified. The unification point can receive a plurality of directory service information requests. Information corresponding to the requests can be maintained in a set of different heterogeneous directory service systems. Each request can include a unique identifier specific to the unification point. For each directory service request, the unification point can query an identification communion table to determine a unique identifier for a unique one of the heterogeneous directory service systems that maintains directory service information able to satisfy the directory service request. Additionally, the unification point can generate a directory service request including the determined unique identifier and can convey the generated directory service request to the determined one of the heterogeneous directory service systems via an API specific to that directory service system. The unification point can receive a response from the determined one of the heterogeneous directory service systems via an API specific to that directory service system. The unification point can generate a directory service response and can conveying the generated directory service response to a requesting entity via the unification point API.","Another aspect of the disclosure includes a unification point for federation of heterogeneous directory systems. The unification point can include an identifier communion table for storing a set of records, each record indexing a unified object ID to a directory object ID and a directory ID. The directory ID can be a unique identifier of a directory service system. The directory object ID can be a unique identifier of a record maintained by the directory service system. The unification point can also include a computer program product for accepting directory service requests including a unified object ID, for using the identifier communion table to look up a corresponding directory object ID and directory ID, for generating a modified directory service requests that substitutes the directory object ID for the unified object ID, for conveying the modified directory service requests to the directory service system indicated by the directory ID, for receiving a response from the directory service system, and for conveying the response to request issuing entity.","The disclosure teaches a unification point for directory services, which utilizes an ID communion table, which obviates problems related to heterogeneous directory systems. The ID communication table can be a very light weight data object, which is able to be implemented in a volatile memory at runtime. In one embodiment, the ID communion table does not need to be persisted to disk or other non-volatile memory. Instead, the ID communion table can maintain the most frequently used entries at a given point in time, which means it can be implemented in a very small buffer providing a lightweight on-demand solution. The ID communication table can include a set of indexed records, which relate a unified object ID to a directory object ID and a directory ID. The unification point can also include a set of formulas to maintain relationships between the unified object ID and the directory object ID, where specifics of the formulas can vary based upon directory object ID. The unifying point can provide a reliable bridge to interface between a set of applications and back-end directory repositories. The applications can rely only on a unified object ID, which functions as a unique identifier to a virtual homogeneous directory system (from a perspective of the application, actually implemented using the unification point). The back-end directory repositories can only rely on a directory object ID, which is specific to that back-end system. Conversions between the application and back-end directory repositories occur at the unification point.","More specifically, applications needing information from the heterogeneous directory systems can direct all directory service communications to the unification point and can receive all responses from the unification point. From the perspective of these applications, directory service information is provided from a single homogenous system. Each time the unification point receives a directory service request, it can determine which of two or more directory systems is to handle the request. It can further determine based upon data in the ID communion table, whether a conversion of an identifier used by the application is needed. The unification point can perform any conversion necessary using a set of formulas that maintain relationship between the unified object ID and the directory object ID. The unification point can convey an equivalent request generated to the appropriate heterogeneous directory system, in a format required by that directory system. Responses from each of the heterogeneous systems are conveyed to the unification point, which thereafter performs any conversions of identifiers as needed, after which the response is directed to the application.","It should be appreciated that the unification point itself does not centrally federate the data into a single data store from multiple different data stores. Each data store instead is independently maintained in a format and structure determined by that particular heterogeneous directory system. Thus, problems with data transformation, migration, synchronization, and the like are avoided by using the unification point. Further, one of ordinary skill should be able to appreciate that in absence of use of the ID communion table (believed to be novel for directory services as implemented), there is no straight forward way for applications to exchange data with a heterogeneous set of directory service applications. The ID communion table can be a very light weight vehicle able to be implemented in memory at runtime, which resolves a historically challenging problem.","As will be appreciated by one skilled in the art, the present invention may be embodied as a system, method or computer program product. Accordingly, the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a \u201ccircuit,\u201d \u201cmodule\u201d or \u201csystem.\u201d Furthermore, the present invention may take the form of a computer program product embodied in any tangible medium of expression having computer usable program code embodied in the medium.","Any combination of one or more computer usable or computer readable medium(s) may be utilized. The computer-usable or computer-readable medium may be, for example but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, device, or propagation medium. More specific examples (a non-exhaustive list) of the computer-readable medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CDROM), an optical storage device, a transmission media such as those supporting the Internet or an intranet, or a magnetic storage device. Note that the computer-usable or computer-readable medium could even be paper or another suitable medium upon which the program is printed, as the program can be electronically captured, for instance, via optical scanning of the paper or other medium, then compiled, interpreted, or otherwise processed in a suitable manner, if necessary, and then stored in a computer memory. In the context of this document, a computer-usable or computer-readable medium may be any medium that can contain, store, communicate, propagate, or transport the program for use by or in connection with the instruction execution system, apparatus, or device. The computer-usable medium may include a propagated data signal with the computer-usable program code embodied therewith, either in baseband or as part of a carrier wave. The computer usable program code may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc.","Computer program code for carrying out operations of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the \u201cC\u201d programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).","The present invention is described below with reference to flowchart illustrations and\/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and\/or block diagrams, and combinations of blocks in the flowchart illustrations and\/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","These computer program instructions may also be stored in a computer-readable medium that can direct a computer or other programmable data processing apparatus to function in a particular manner, such that the instructions stored in the computer-readable medium produce an article of manufacture including instruction means which implement the function\/act specified in the flowchart and\/or block diagram block or blocks.","The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1","b":["100","120","124","110","135","100","110","120","130","160","140","142"]},"The unification point  can function as a centralized point for handling directory service requests  from applications  running on a set of computing devices . From an application  perspective, all service requests  are conveyed to the unification point , which issues back responses, where the unification point  behaves as a homogeneous directory system. That is, requests  can be directory request conveyed to a directory service Application Program Interface (API) . From a perspective of each of the set of heterogeneous directory systems , the unification point  conveys standard, properly formatted requests , to which each of the systems  responds. Each request from the unification point  can be directed to an API  of a corresponding system . Content provided in response to requests ,  can be from data stores  associated with the heterogeneous set of directory systems .","The unification point  can include a converter  and an ID communion table . The ID communication table  can include a set of records providing an index between a unified object identifier , and a directory object identifier , which is an identifier unique to a specific directory system  identified by the directory ID . The unified object identifiers  can be the same (e.g., record ) or different (e.g., record ) from the directory object identifier . When different, the converter  can execute and can converting content of request  from a requesting application  to content of a request  sent to a directory system .","For example, entry ID  having a value of \u201c123456\u201d can be converted into entry ID  having a value of \u201cIZ2Y3Z4\u201d per record . Request  can be sent to an API  of an appropriate directory system  (i.e., DS_AA from record ), which access an associated record  stored in its data store  in accordance with operations of the a directory service application . The application  generates a response from record  information. The response can be conveyed back to unification point . The unification point  reformats the response (e.g., using unified object ID  instead of directory object ID ), which is conveyed back to the requesting computer device .","In one embodiment, the converter  can include a set of formulas . Each formula  can be implemented in a computer program product stored in a physical memory that is able to be executed\/interpreted by a hardware processor. These formulas  can maintain a relationship between a unified object ID  and the directory object ID , where the relationship and\/or formula  used is based upon the directory ID . The formulas  are always available to convert requests and responses back and forth as needed.","In one embodiment, the unification point  need not persist data of the ID communion table , which can be temporarily maintained in a volatile memory  (e.g., RAM), which need not be persisted in all configurations of system . In one embodiment, the ID communion table  can be implemented in a light weight manner using little memory . The converter  and unification point  can also be very light weight components consuming few computing components when run. Thus, in one embodiment, the unification point  can be added to a computing infrastructure (e.g., can even be a functionality added to a router, bridge, or hub, for example) with little additional expense and a minimal impact on system  performance. In another embodiment, the unification point  can be a software implemented component, such as a component of a J2EE application server environment. The unification point  can introduce minimal latency to system  due to its lightweight nature. In one configuration, only the most frequently used entries can be present in the ID communion table  at any point in time. Entries not included in table , which are needed, can be obtained (from a comprehensive database, for example) on demand, at the time requests  are received.","Values of table  are not limited to most frequently used entries in all embodiments, and other embodiments are contemplated. For instance, other optimization algorithms than those based upon the most frequently used entries can be used to determine which values are to populate the table . In one embodiment, values can be temporarily loaded into table , rapidly used thereafter, then discarded, such as during an application start-up. Such an implementation does not require the temporarily loaded values to have been frequently used in the recent past and does not consume great quantities of memory, as table values can be purged after application start-up.","To elaborate upon such an embodiment, during application  start-up, an information request  can be initiated for all directory service data needed by the application . This data can be maintained in multiple ones of the data stores . The unification point  can populate the ID communion table  with values. Requests  can then be sent to each of the heterogeneous directory systems . Responses can be conveyed from each system  to point  and then to data store , where information is maintained for the duration of the application  session, as needed. Once responses to requests  are provided by the unification point , the ID communication table  can be discarded and associated memory cleared.","System  is not limited in to any of the above specific configurations for populating values of the ID communion table . Any of a variety of techniques can be used and still be in scope of system . For example, in one contemplated embodiment, ID communication table  data can be persisted (i.e., memory  can be loaded when unification point  is initialized with all data necessary to anticipated requests ). In one embodiment, a series of one or more swap caches can be used, to maximize a number of entries in an ID communion table, while minimizing a size requirement for memory . In one embodiment, an authorized administrator can adjust behavioral patterns of memory  to optimize how unification point handles a customized load given resources available to the unification point .","Although shown generically in , it should be appreciated that the unified object id  and\/or the directory object id  can be standard or non-standard formats. In one embodiment, for example, each unified object ID  can be in a standard\/canonical GUID format in compliance with an LDAP standard, such as LDAPv3 as specified by the Internet Engineering Task Force (IETF) Requests for comments (RFCs) as detailed in RFC 4510. Further, the directory object ids  can be in a standardized or proprietary format (e.g., raw DominoUNID in byte-string representation used by LOTUS DOMINO; a byte-string representation from an ACTIVE DIRECTORY system stored as binary (Octet) format, etc.). When either ID ,  conforms to an LDAP, the ID value can represent a distinguished Name (DN). Further, the directory ID  can be an IP address, a domain name, or other unique identifier for a directory system . In one embodiment, formulas  can be added to unification point  to extend functionality of unification point  to handle additional formats.","A canonical format can be a globally unique identification number computed based on one or more inputs by an algorithm. Non-canonical formats can include, but are not limited to, base64 encoding, byte-string representation, and the like. A canonical formatted value and non-canonical formatted value can be different representations of an identical value.","The unification point  can handle any format for requests , whether proprietary or standardized. Standardized formats for directory services, which are handled by the unification point , can include, for example, LDAP, X.500 directory service standards (e.g., Directory Access Protocol (DAP), Directory System Protocol (DSP), Directory Information Shadowing Protocol (DISP), Directory Operational Binding Management Protocol (DOP), etc.), XML Enabled Directory (XED), XML Enabled Directory (XED), Directory Service Markup Language (DSML), Service Provisioning Markup Language (SPML), Service Location Protocol (SLP), and the like.","In one embodiment, the unification point  can operate in a fashion transparent to application  (which treats the unification point  as a homogeneous directory system) and transparent to directory system  (which treats the unification point  as a standard request issuing client). In one embodiment, communications to and from the communication point  can occur at the transport layer of the Open Systems Interconnection Reference Model (OSI Model). These communications can be optionally secured using Simple Authentication and Security Layer (SASL), Transport Layer Security (TLS), Secure Sockets Layer (SSL), and other such techniques.","Network  can include any hardware\/software\/and firmware necessary to convey data encoded within carrier waves. Data can be contained within analog or digital signals and conveyed though data or voice channels. Network  can include local components and data pathways necessary for communications to be exchanged among computing device components and between integrated device components and peripheral devices. Network  can also include network equipment, such as routers, data lines, hubs, and intermediary servers which together form a data network, such as the Internet. Network  can also include circuit-based communication components and mobile communication components, such as telephony switches, modems, cellular communication towers, and the like. Network  can include line based and\/or wireless communication pathways.","As used herein, presented data stores  and  can be a physical or virtual storage space configured to store digital information. Data stores  and  can be physically implemented within any type of hardware including, but not limited to, a magnetic disk, an optical disk, a semiconductor memory, a digitally encoded plastic memory, a holographic memory, or any other recording medium. Data stores  and  can be a stand-alone storage unit as well as a storage unit formed from a plurality of physical devices. Additionally, information can be stored within data stores  and  in a variety of manners. For example, information can be stored within a database structure or can be stored within one or more files of a file storage system, where each file may or may not be indexed for information searching purposes. Further, data stores  and\/or  can utilize one or more encryption mechanisms to protect stored information from unauthorized access.","Computing device , directory system , and unification point  can comprise a set of one or more hardware devices, each of which optionally containing software (e.g., an operating system, BIOS, software\/firmware computer program products, etc) and\/or firmware that the hardware is able to execute to perform computing operations. The hardware can include one or more central processing unit, a volatile memory, and a nonvolatile memory, and a network adaptor (for connecting the hardware to network ) interconnected via a bus. Computing device , directory system , and\/or unification point  can each be implemented as a standalone machine or as a set of two or more machines operating in a distributed computing space as a single computing device. Further, a software application ,  can be an application comprising multiple different components, each of which may be executed upon different computing devices.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 2","b":["200","200","100","200","210","214","214"]},"Within the environment, one or more LOTUS Connections applications  can run. When the application  loads, user specific contact information can be gathered and stored in data store  and used for the duration of an application  session. The gathering of contact information can request communications between application  and a unification point (Waltz ), which can occur through API . The unification point (an enhanced implementation of Waltz \/VMM  in one embodiment) can include an ID communion table . The LOTUS Connections application  can exclusively utilize unified object IDs (e.g., Waltz IDs, as shown by column ).","Actual contact information can be maintained by a set of different directory servers, such as TIVOLI directory server , LOTUS DOMINO server , and active directory server . These servers , ,  can, but need not, be hosted within the application environment  (note active directory server  is implemented outside environment  and is communicatively linked to unification point  via network ). Each directory server , ,  can have an API , ,  and a server specific data store , ,  with which contact information is maintained.","Application environment  shows a virtual member manager  of WEBSPHERE APPLICATION SERVER (WAS). The VMM  can be a federated user repository feature that simplifies access and maintenance of user data within multiple repositories. VMM  uses configuration parameters (instead of coding) to perform its functions. VMM  can be a federated user repository for servers , , and\/or . Table  shows an ID unification table having a set of Waltz IDs  (unified object ID), VMM IDs , and repository IDs .","In embodiment , a single LDAP can be configured in a Federated Realm, where Waltz  (Directory Services of Connections) provides conversion routines for every single entry in need in between Waltz  and VMM . That is, a set of formulas can be used that maintain a relationship between the Waltz ID  (e.g., unified object ID) and the VMM ID  (e.g., directory object ID), where the formulas are specific to the Repository ID . Therefore, conversion formulas needed to convert to and from the Waltz ID  and VMM ID  are always available as needed. VMM  can return Waltz  with entries' ID () along with entries' repository ID (). Therefore, Waltz  can maintain repository ID () information for each entry, as shown by table .","A challenge is that when Connections applications  rely on Waltz ID () to look up for entry's attribute value or group membership, the VMM ID () is needed (not Waltz ID) for Waltz  to invoke VMM API . All standard connections features would only give Waltz ID  in standard GUID format such as 924708C0-8F0A-1028-8560-DB07163B51B2. Waltz  must know the repository ID  to know whether this ID  need to be converted into different VMM format or not prior to invoking the VMM API  for a search. The ID communion mapping table  provides Waltz  all the information (Waltz ID , VMM ID , repository ID ) to handle this need. Thus, the ID communion table  combined with the conversion formulas, results in a reliable bridge able to interface between application  and any of the directory servers , , . Without table , it can be impossible to work with multiple LDAPs (or other directory servers) simultaneously.","In one embodiment, Waltz  does not need to persist table  information for a significant time. Instead, the ID communion table  can be implemented in a very lightweight manner, where only the most frequently used entries can be included. Other embodiments exist, however, and the disclosure is not limited in this regard. In embodiment , Connections  can invoke Waltz  to determine user specific patterns. These patterns are assessed during login. That is, end-users login to Connections , which relies on WAS Security module to authenticate users. The WAS Security module brings back the principal name of an entry to Connections  features. Then, Waltz API  calls can be invoked to retrieve profiles and membership data. Once profiles and membership data is returned to Connections' applications , it is applications' responsibility to store acquired information into a local application database table in data store .","Embodiment  provides custom ID support. This negates a need to rely on the almost immutable ID value provided and maintained by an LDAP server. Users can, instead, create and maintain their own employee ID attribute and values via a set of dedicated IT personnel. This can be significant because many B2B and B2C interactions require use of a custom ID, which if not supported can impede business relationships among potential partnering companies.","Conventionally (without using the innovation of table ), a system foundation cannot be leveraged and recognized to use a custom ID attribute. In embodiment , however, Waltz  can use table  to support custom ID. All the applications of Connections  do not need to handle complex mappings, but only need to invoke Waltz API  to gain access as if communications involved a single LDAP configuration. Waltz  can accept both system\/directory ID and custom ID attribute value during search.","Diagram  shows that the table  can maintain any number of attributes per record. The attributes can be maintained in LDAP Data Interchange Format (LDIF), or in any other format depending upon implementation choices. Thus, the Waltz ID  can be given instead of a VMM ID, yet no other changes need be made to query based upon the attributes. Formulas, specific to repository IDs, can be invoked which convert requests back and forth (one type including a Waltz ID , another including a VMM ID ), as needed.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 3","b":"300"},"Method  can begin in step , where a unification point can be established for accepting and conveying directory service messages. In step , an event triggering a creation\/loading of an ID communion table can be detected. In one embodiment (i.e., the ID communion table being a very light weight table maintaining a set of most frequently used values in a volatile memory), a \u201cload\u201d event can one to populate the ID communion table with a needed value on demand. The event of step  can also be an event to update the ID communion table so that it only includes a most frequently used set of values based upon usage patterns, which vary over time. In another embodiment, when a software application (e.g., LOTUS CONNECTIONS) loads, this event (e.g., the event of step ) can be triggered. The ID communion table need not be persisted in such a situation (step  discards table data, for example). In step , the ID communion table can be populated with appropriate values, such as unification object IDs, directory object IDs, and directory IDs, needed to respond to a set of one or more directory service requests.","In step , the unification point can receive a directory service request that utilizes unified object identifiers. In step , a directory object ID and directory ID corresponding to the unified object ID can be determined using the ID communion table. In optional step , a format of the original directory service request can be converted to a target format compatible with a directory service system having the directory ID. In step , a modified directory service request can be generated that includes the directory object ID and that is formatted for the target directory service system . In step , the generated request can be conveyed to the target directory service system, which processes this modified request.","In step , the target directory service system can send a respond to the unification point. In step , the unification point can create and generate a modified response that is formatted for the application that sent the original request. The modified response can use the unified object ID instead of a corresponding directory object ID. The modified response can be conveyed from the unification point to the requesting application, as shown by step .","In step , a triggering event may occur that changes values in the ID communion table. If such a change occurs (step ), it can result in values being added or removed from the table. If values are to be added, the method can progress from step  to step , where the ID communion table can be populated with new values. For example, the ID communion table can concurrently support multiple different applications and users, and the ID communion table may need to be updated to support a new directory service request from a new user (i.e., in one embodiment, another user can instantiate LOTUS CONNECTIONS, which requires values for that user's contacts to be added to the ID communion table). When values are to be removed, unnecessary items can be discarded from the ID communion table, as shown by step . In one implementation, memory (e.g., RAM) can be optionally deallocated, such as deallocating all volatile memory when an ID communion table is empty and no longer needed. If more requests need to be handled, the method can proceed from step  to step . Otherwise, the method can end in step .","The flowchart and block diagrams in the  illustrate the architecture, functionality, and operation of possible implementations of systems, methods and computer program products according to various embodiments of the present invention. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions for implementing the specified logical function(s). It should also be noted that, in some alternative implementations, the functions noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and\/or flowchart illustration, and combinations of blocks in the block diagrams and\/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer instructions."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
