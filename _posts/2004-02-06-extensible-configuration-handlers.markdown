---
title: Extensible configuration handlers
abstract: In accordance with certain aspects of extensible configuration handlers, a method of using a configuration file to generate one or more components that are accessible to an application comprises a two-phase process. In a first phase, a plurality of components defined in a configuration file are created. In the second phase, one or more of the plurality of components are notified of the presence of the other components in the plurality of components. In accordance with certain other aspects of the extensible configuration handlers, the configuration handlers defined in a configuration file are nested configuration handlers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07428735&OS=07428735&RS=07428735
owner: Microsoft Corporation
number: 07428735
owner_city: Redmond
owner_country: US
publication_date: 20040206
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This invention relates to configuration systems and files, and more particularly to extensible configuration handlers.","Today, computer programs are commonly written in what is referred to as a high-level computer language, such as C, C++, Visual Basic, and so forth. The computer program is then compiled into what is commonly referred to as source code, which can be executed or run by a computer. Computer programs are often distributed in this executable source code format, rather than requiring the end user to have the knowledge and resources to compile the high-level computer language into a form that can be run by a computer.","However, there are situations where it is desirable for an end user (e.g., a system administrator) to make changes to a computer program. For example, a particular program may include routing functionality, where the program receives messages from different devices or different components within the same device and forwards those messages to different devices or components based on a set of rules. It is oftentimes desirable to allow the system administrator or end user of the program to alter these routing rules, inserting their own rules and\/or criteria for where particular messages should be forwarded. However, it can be very difficult and time-consuming to make such changes to compiled code.","One solution to allow such changes to compiled computer programs is the use of a configuration system. During execution or runtime of the computer program, a configuration system on the computer can be accessed to obtain custom information identified by the end user through a configuration file. The configuration system accesses the configuration file for the computer program, and creates appropriate objects based on the specified information in the configuration file. These objects can then be accessed by the computer program. Such objects would allow, for example, user-defined routing rules and\/or criteria to be used by the compiled program.","However, certain problems exist in current configuration systems. For example, a configuration file could be written that includes new routing rules and\/or criteria, but the format of those routing rules and\/or criteria must be consistent\u2014new formats for describing the routing rules and\/or criteria cannot be defined. Another problem is that different components or objects generated by the configuration system are typically not aware of one another. So, new components could be created by the configuration system but they would not be able to make use of the functionality provided by one another because they do not know of one another's existence.","Extensible configuration handlers are described herein that solve these and other problems.","Extensible configuration handlers are described herein.","In accordance with certain aspects of the extensible configuration handlers, a method of using a configuration file to generate one or more components that are accessible to an application comprises a two-phase process. In the first phase, a plurality of components defined in a configuration file are created. In the second phase, one or more of the plurality of components are notified of the presence of the other components in the plurality of components.","In accordance with certain aspects of the extensible configuration handlers, the configuration handlers defined in a configuration file are nested configuration handlers.","Extensible configuration handlers are described herein. The extensible configuration handlers defined within a configuration file allow for nested configuration handlers and\/or notification of created objects or components of one another. By allowing nested configuration handlers, each configuration handler responsible for creating one or more objects or components can be further user-configured by addition of a user-defined child handler, and each such user-defined child handler can itself be further user-configured by addition of another user-defined child handler (this nesting of user-defined handlers can continue to any number of nested handlers). By allowing for notification of created objects or components of one another, components or objects created by an extensible configuration handler can be notified of all other components or objects created by that configuration handler as well as other configuration handlers. Each component or object can then use this information they are notified of as they desire (e.g., to access the functionality or services of one or more of the other components or objects).",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1","b":["100","100","100"]},"During operation of device , an application  is running and reaches a point where it needs to access a component or object that is available from a configuration file  associated with application . Application  invokes  configuration system , which in turn accesses the appropriate configuration file  for application . Alternatively, rather than waiting until the application needs to access such a component or object, application  may invoke  configuration system  at some other point (e.g., when application  begins running). Application  represents any of a variety of programs that can be run on device , including operating systems, productivity applications, education applications, recreational or entertainment applications, and so forth.","Multiple configuration files  may be available to device , but typically only one of the configuration files is associated with application . Configuration system  can identify which configuration file is associated with application  in any of a variety of manners (e.g., the configuration file may be stored in a particular location, such as a directory or folder, where executable code for application  also is stored; the location and name of the configuration file may be identified in a central location (e.g., an operating system registry of device ); all configuration files may be stored in the same directory or folder but use a particular naming convention that is based on the name of application ; and so forth). Configuration file  may be initially stored on a local storage device (e.g., a hard drive or flash memory) of device , or alternatively may be stored on a remote device (e.g., a server) and retrieved by device  as needed.","Configuration system  processes configuration file  and creates one or more components (also referred to as objects)  based on the contents of configuration file , the contents including definitions for the one or more components. The components that are created by configuration system  are instantiations of the component definitions included in configuration file , as discussed in more detail below. The components thus created are made available to application  (e.g., returned or passed to application , or exposed to application  so that application  can access the functionality or services of the components), which in turn can access the appropriate data and\/or functionality of these components as desired.","Configuration file  includes various definitions, including definitions for configurable data as well as definitions for one or more configuration handlers (which can include extensible configuration handlers as well as non-extensible configuration handlers, as discussed in more detail below). The configurable data definitions define various settings and\/or data values that can be configured by a user, such as a system administrator, of device . For each configurable data definition in configuration file , a configuration handler is also included in configuration file . A configuration handler, when invoked, is capable of creating a component based on a configurable data definition input to the configuration handler.","The configurable data definitions may be written in any of a variety of languages. For example, the configurable data definitions may be written using a markup language, such as XML (extensible Markup Language). For each such XML definition, a configuration handler can be invoked that is able to parse the XML definition and create a component from the XML definition. This created component is an instantiated object representing the XML definition. The component created by the configuration handler can then be output by configuration system  as a component .","Configuration file  can include extensible configuration handlers and optionally non-extensible configuration handlers. Non-extensible configuration handlers refer to configuration handlers that are designed to create components only from a limited set of configurable data definition formats (e.g., only those configurable data definition formats that are known to the handler as they have been written into (or hard-coded into) the handler and the components created by different configuration handlers have no knowledge of one another). An extensible configuration handler, however, can itself be configured to create components from user-defined configurable data definition formats, and\/or can be notified of the presence of components created by different configuration handlers. Thus, only those configurable data definition formats known at the time the configuration handler is written and placed in the configuration file can be used with non-extensible configuration handlers, whereas other later-defined (and user-defined) configurable data definition formats can be used with extensible configuration handlers. As the definition formats supported by an extensible configuration handler can be customized or changed, such configuration handlers can be viewed as being extensible.","It should be noted that, although such extensible configuration handlers are extensible, they can still implement a known interface. The data format(s) that the extensible configuration handlers define for their values are extensible, as is the code that is used to read such data, but these extensions are still tied to this known interface. Thus, other components or applications need not be altered to make use of components created by such extensible configuration handlers, and configuration system  need not be altered to make use of the extensible configuration handlers.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 2","FIG. 1"],"b":["104","104","150","150","106","104","104","106","106"],"br":[{},{}],"in-line-formulae":[{},{}]},"Configuration file  includes an extensible configuration handler definition  that can be used by the configuration system  of  to instantiate an extensible configuration handler . Although only one extensible configuration handler definition  is illustrated in , two or more extensible configuration handler definitions may be included in configuration file . Extensible configuration handler definition  includes a handler configuration section  and has associated handler data . Handler data  includes the configurable data of configuration file  that is associated with this handler . For example, if extensible handler  were a router handler which allowed users to define their own routings, then handler data  would include those user-defined routings.","Extensible handler definition  is typically written so that handler  is able to understand one or more formats for handler data . For example, if extensible handler  were a router handler, definition  would typically be written so that handler  could understand one or more routing definition formats. However, in alternate embodiments, definition  may be written so that handler  does not understand any formats for handler data , but rather relies on the configuration handler extensibility discussed herein.","Handler configuration section  includes one or more mappings of names to child handlers that can be used to create components for extensible handler . An example child handler definition  is illustrated as part of configuration file , and can be used to instantiate a child handler component . Handler configuration section  is similar to file configuration section , however file configuration section  includes mappings of names to top-level configuration handlers within configuration file . A top-level configuration handler is a configuration handler that is not used by another configuration handler. Handler configuration section , on the other hand, includes mappings of names to child configuration handlers of configuration handler . A child configuration handler is a configuration handler that is used by another configuration handler.","By way of example, assume that extensible handler  were a router handler that understands one routing definition format. If a user, such as a system administrator, desired to define his or her own routing definition format, then the user would write a type definition  that describes a child handler  that can be created by configuration system , and include this type definition in configuration file . Although this definition  is illustrated in  as part of definition , definition  may alternatively be separate from definition . The user would also add a mapping in handler configuration section  that maps the name of this new format to this new type definition. Configuration system  is then able to process this new routing definition because handler  has been extended to have a child configuration handler  instantiated that knows how to process this new routing definition. When the router handler encounters an XML tag with the name of this new routing definition format, then the router handler  passes the XML content associated with that tag to the child handler  (creating the child handler if it has not already been created). The child handler  parses the XML content associated with the new routing definition format, and returns, to the router handler, a component that results from this parsing of the XML content. Router handler  can also expose child handler  as part of a collection of components that handler  exposes.","Thus, it can be seen that extensible handlers, such as handler , are recursive in nature. Any number of extensible handlers, analogous to handler , can be nested within each other, allowing each handler to be extended to understand new user-defined formats. Each such handler would include a handler configuration section analogous to section  that maps the names for these extensible handlers to their definitions.","Configuration file  can also optionally include one or more non-extensible handler definitions , that can be used by the configuration system  of  to instantiate a non-extensible handler . Handler data  is associated with non-extensible handler . Handler  differs from handler  in that handler  is not extensible. No handler configuration section analogous to section  is included in handler definition . Rather, handler  is written so that handler  can process certain formats for data , and those formats cannot be changed.","Table I includes an example of a portion of a configuration file.",{"@attributes":{"id":"p-0035","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE I"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","<configuration>"]},{"entry":["2","\u2003<configSections>"]},{"entry":["3","\u2003\u2003<name=\u201crouter\u201d type=\u201crouterConfigHandler\u201d>"]},{"entry":["4","\u2003\u2003<name=\u201cdataStorage\u201d type=\u201cdataStorageConfigHandler\u201d>"]},{"entry":["5","\u2003<\/configSections>"]},{"entry":["6","\u2003<router>"]},{"entry":["7","\u2003\u2003<configSections>"]},{"entry":["8","\u2003\u2003\u2003<name=\u201cmyRoute\u201d type=\u201cRouter.myRouteConfigHandler\u201d>"]},{"entry":["9","\u2003\u2003<\/configSections>"]},{"entry":["10","\u2003\u2003<route1>"]},{"entry":["11","\u2003\u2003\u2003..."]},{"entry":["12","\u2003\u2003<\/route1>"]},{"entry":["13","\u2003\u2003<myRoute>"]},{"entry":["14","\u2003\u2003\u2003..."]},{"entry":["15","\u2003\u2003<\/myRoute>"]},{"entry":["16","\u2003<\/router>"]},{"entry":["17","\u2003<dataStorage>"]},{"entry":["18","\u2003\u2003<storage location>"]},{"entry":["19","\u2003\u2003\u2003..."]},{"entry":["20","\u2003\u2003<\/storage location>"]},{"entry":["21","\u2003\u2003<format1>"]},{"entry":["22","\u2003\u2003\u2003..."]},{"entry":["23","\u2003\u2003<\/format1>"]},{"entry":["24","\u2003<\/dataStorage>"]},{"entry":["25","<\/configuration>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In the example configuration file of Table I, line 1 defines the beginning of the configuration file while line 25 defines the end of the configuration file. Lines 2-5 are the file configuration section (e.g., file configuration section ), which define a mapping of name \u201crouter\u201d to a type \u201crouterConfigHandler\u201d, and a name \u201cdataStorage\u201d to a type \u201cdataStorageConfigHandler\u201d. When processing the configuration file of Table I, when the configuration system  of  encounters the router tag on line 6, it refers to the mappings of lines 2-5 and passes the content associated with the router tag (e.g., the content of lines 6-16) to the routerConfigHandler configuration handler, creating the routerConfigHandler configuration handler if necessary. In certain implementations, because this is the first time the routerConfigHandler has been accessed, the routerConfigHandler has not yet been created so the definition of the routerConfigHandler, stored elsewhere in the configuration file (not shown in Table I) is used to instantiate the routerConfigHandler configuration handler. In other implementations, each of the configuration handlers identified in the mappings of lines 2-5 (the routerConfigHandler configuration handler and the dataStorageConfigHandler configuration handler) are created when the configuration system  of  first encounters the mappings of lines 2-5 (e.g., the routerConfigHandler configuration handler is created when line 3 is first encountered, rather than waiting until another tag in the configuration file with the name \u201crouter\u201d is encountered).","The router configuration handler is an extensible handler, so a handler configuration section on lines 7-9 is included. This configuration section on lines 7-9 defines a mapping of name \u201cmyRoute\u201d to a type \u201cRouter.myRouteConfigHandler\u201d. The routerConfigHandler configuration handler processes the code of lines 6-16, and was written to understand the routing definition format of the route1 tag. So, the routerConfigHandler configuration handler can create a component that includes the specific routing information included in line 11 (the actual routing information has not been shown so as to avoid cluttering Table I). However, the routerConfigHandler configuration handler was not written to understand the routing definition format of the myRoute tag. So, when the routerConfigHandler configuration handler encounters the tag myRoute in line 13, the routerConfigHandler configuration handler refers to the mappings of lines 7-9 and passes the content associated with the myRoute tag (e.g., the content of lines 13-15) to the Router.myRouteConfigHandler child configuration handler, creating the Router.myRouteConfigHandler child configuration handler if necessary. Analogous to the discussion above regarding the creation of the routerConfigHandler configuration handler, the definition of the Router.myRouteConfigHandler child configuration handler is included in the configuration file (not shown in Table I), and can be instantiated the first time the myRoute tag is encountered or alternatively when the handler configuration section on lines 7-9 is first encountered.","The Router.myRouteConfigHandler child configuration handler was written to understand the format of myRoute routing definitions. So, the Router.myRouteConfigHandler child configuration handler creates a component that includes the specific routing information included in line 14 (the actual routing information has not been shown so as to avoid cluttering Table I). The Router.myRouteConfigHandler child configuration handler then returns this component it created to the routerConfigHandler configuration handler.","The routerConfigHandler configuration handler then makes the two components (the component it created based on lines 10-12, and the component that the Router.myRouteConfigHandler child configuration handler created based on lines 13-15) available to the configuration system  of  (e.g., returns or exposes the components).","When the configuration system  of  encounters the dataStorage tag, it refers to the mappings of lines 2-5 and passes the content associated with the dataStorage tag (e.g., the content of lines 17-24) to the dataStorageConfigHandler configuration handler, creating the securityConfigHandler configuration handler if necessary (analogous to creation of the routerConfigHandler configuration handler discussed above). The dataStorageConfigHandler type is for a non-extensible handler, so no configuration section is included in lines 17-24. The dataStorageConfigHandler configuration handler processes the code of lines 17-24, and was written to understand the definition format of the storage location tag as well as the format1 tag. So, the dataStorageConfigHandler configuration handler can create a component that includes the specific storage location information included in line 19, as well as a component that includes the specific format information included in line 22 (the actual information of lines 19 and 22 has not been shown so as to avoid cluttering Table I). The dataStorageConfigHandler configuration handler then returns the two components (the component it created based on lines 18-20, and the component that it created based on lines 21-23) to the configuration system  of .","The configuration system  of  is finished processing the configuration file when it reaches line 25. The configuration system  of  then makes all four components that have been created (the component created by the routerConfigHandler configuration handler, the component created by the Router.myRouteConfigHandler child configuration handler, and the two components created by the dataStorageConfigHandler configuration handler) available to the application that invoked the configuration system. The components may be returned or passed to the application, or otherwise made available for the application to invoke the functionality exposed by the components.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 3","b":["200","200"]},"Initially, a configuration system, such as configuration system  of , receives a configuration request for an application (act ). This request is typically received from the application itself, but alternatively may be received from elsewhere (e.g., an operating system may submit the request for an application). The configuration system retrieves the appropriate configuration file for the application (act ). The configuration system then selects a component group definition from the configuration file (act ). Component group definitions are typically selected in the order in which they appear in the configuration file, although other orders could alternatively be used. This component group definition is a definition of one or more components to be created, typically by a top-level configuration handler. By way of example, referring back to the example of Table I, lines 6-16 are a component group definition for the router configuration handler (defining the one or more components to be created by the router configuration handler).","The configuration system then accesses the configuration file mapping table to identify a configuration handler to create components from the component group definition selected in act  (act ). This configuration handler is the handler that will create the components defined in the selected component group definition. The configuration system then creates the identified configuration handler, if necessary (act ). If the configuration handler has not been used before by the configuration system, then the configuration handler may not have been created yet. Thus, the configuration system creates the configuration handler if it has not been created yet, as discussed above.","The configuration handler identified in act  then creates the component(s) for the component group definition selected in act  (act ). The creation of these component(s) is discussed in more detail below with reference to .","The configuration system then checks whether there are any additional component group definitions in the configuration file that have not yet been selected (act ). If there are such component group definitions, then process  returns to act  where one such component group definition is selected. However, if there are no such component group definitions, then the configuration system makes the components that were created in act  (act ) available. These components are typically returned or otherwise made available to the application. For example, the configuration system may pass the components back to the application, or may simply expose the components so that they can be invoked by the application. Alternatively, these components may be returned or otherwise made available elsewhere (e.g., to whatever component sent the configuration request in act ).",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 4","FIG. 3"],"b":["240","240","240","240","212"]},"Initially, a component definition from a component group definition passed to the configuration handler is selected (act ). The configuration handler typically selects component definitions in the order in which they appear in the component group definition, although other orders could alternatively be used. This component definition is a definition of a component to be created. By way of example, referring back to the example of Table I, lines 13-15 are a component definition for the myRoute routing definition.","A check is then made as to whether the configuration handler knows how to create the component using the selected component definition (act ). The configuration handler knows how to create the component if it was written to know how to create the component (e.g., if it was written to parse the format of the component definition). If the configuration handler knows how to create the component, then it creates the component for the selected component definition (act ).","However, if the configuration handler does not know how to create the component, then it accesses a handler mapping table to identify a child handler to create the component (act ). The handler then creates the child handler, if necessary (act ). If the child handler has not been used before by the configuration system, then the child handler may not have been created yet. Thus, the handler creates the child handler if it has not been created yet, as discussed above.","The child handler is then used to create a component for the selected component definition (act ). The child handler may be written such that it knows how to parse the component definition itself, and thus can create the component without any additional configuration handlers being involved in the process. Alternatively, there may be one or more definitions in the component definition which the child handler cannot parse, and thus process  may be repeated for the child handler. When the process  is repeated, the child handler is referred to as the handler as discussed in process , and it creates another child handler (if necessary) in act .","When the component is created, a check is then made as to whether there are any additional component definitions in the group that have not yet been selected (act ). If there are such component definitions, then process  returns to act  where one such component definition is selected. However, if there are no such component definitions, then the configuration handler makes the components that were created in act  (act ) available (e.g., returns or exposes the components). These components are typically returned or otherwise made available to the configuration handler from which the group of component definitions was received. Alternatively, these components may be returned or otherwise made available elsewhere.","Thus, as can be seen from , any number of configuration handlers can be nested (e.g., a configuration handler may include a child configuration handler, which in turn includes a child configuration handler, which in turn includes a child configuration handler, and so on). At each level of nesting, there is a parent configuration handler that invokes a child configuration handler to assist in the processing of the data (e.g., the XML component definition). Process  is used recursively to process the configuration handlers.","The child configuration handler is also passed in the instantiation of the parent component (the \u201cparent instance\u201d,) which the child configuration handler can interact with. This allows the child configuration handler to access the interfaces of the parent instance, and thus allows the child configuration handler to add components to a collection of components. For example, for <myRoute> in Table I, the myRouteConfigurationHandler would get passed the instance of the router, which it would then use to do, for example: router.Routes.Add(new MyRoute(\u201cconfiguration-values-that-were-read\u201d)) in order to add the MyRoute component to the instance of the router.","The above discussion of  assumes that there are no errors in the component definitions and that a configuration handler (top-level or child) is always available (identified in a configuration section as appropriate) to generate components as needed. In situations where an error is encountered (e.g., an XML tag is encountered and there is no mapping for that tag in a configuration section), then the configuration process fails. The entire configuration process may fail (e.g., configuration system  of  returns an error but does not return or expose any), or alternatively only the creation of the affected components may fail (e.g., the component(s) for which there is no mapped configuration handler is not created, but other components for which there is a mapped configuration handler are created).","Returning to , an additional aspect of the extensible configuration handlers discussed herein is that the various components  made available by configuration system,  may, in some situations, desire to access the functionality of one another. By way of example, some components  may be related to router functionality, while other components  may be related to security functionality. It may be the situation that some of the router components  may desire to implement some security features by accessing functionality of the security component . The extensible configuration handlers facilitate such accessing across components  by notifying the various components  of one another, as discussed in more detail below.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 5","FIG. 5"],"b":"300"},"Initially, the configuration system receives a configuration request for an application (act ), analogous to act  of . The configuration system then retrieves a configuration file for the application (act ), analogous to act  of .","One or more components are then created based on extensible handler content of the configuration file (act ). These components can be created as discussed above (e.g., with reference to acts - of ). This creation of the components is also referred to as a first pass or first phase. After the components are created, each component created by an extensible configuration handler is then notified of the presence of the other components that were created in act  (act ). What the components do with this information they receive is up to them (e.g., a component can ignore the information if it does not care about the information, or alternatively use the information for those components whose services it desires to access). This notification can take a variety of different forms, and in certain embodiments is performed by invoking a method exposed by the created components (e.g., referred to as a WireUp method). A parameter of this method is the created components or an identification of the created components (e.g., a list or other set of identifiers of the components, a location where such a list or other set of identifiers can be obtained, and so forth). This notification of the components of the existence of one another is also referred to as a second pass or second phase.","In certain embodiments, this notification is performed by each top-level configuration handler invoking a method exposed by each component created by that top-level configuration handler as well as each component created by any other configuration handler nested within that top-level configuration handler. In other embodiments, this notification can be performed by something other than the top-level configuration handlers, such as by configuration system .","When both passes or phases are finished, the components are made available (act ), analogous to act  of . Thus, as can be seen from , the components created and made available (e.g., returns or exposes the components) by the two-pass or two-phase process of  are aware of one another and can access the services or functionality of one another as they desire.","Table II includes another example of a portion of a configuration file. The portion illustrated in Table II is similar to the portion included in Table I discussed above, however in Table II the content associated with the router tag (lines 6-16 of Table I) is part of content associated with a system tag.",{"@attributes":{"id":"p-0063","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE II"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","<configuration>"]},{"entry":["2","\u2003<configSections>"]},{"entry":["3","\u2003\u2003<name=\u201csystem\u201d type=\u201csystemConfigHandler\u201d>"]},{"entry":["4","\u2003\u2003<name=\u201cdataStorage\u201d type=\u201cdataStorageConfigHandler\u201d>"]},{"entry":["5","\u2003<\/configSections>"]},{"entry":["6","\u2003<system>"]},{"entry":["7","\u2003\u2003<configSections>"]},{"entry":["8","\u2003\u2003\u2003<name=\u201crouter\u201d type=\u201cSystem.routerConfigHandler\u201d>"]},{"entry":["9","\u2003\u2003\u2003<name=\u201csecurity\u201d type=\u201cSystem.securityConfigHandler\u201d>"]},{"entry":["10","\u2003\u2003<\/configSections>"]},{"entry":["11","\u2003\u2003<router>"]},{"entry":["12","\u2003\u2003\u2003<configSections>"]},{"entry":["13","\u2003\u2003\u2003\u2003<name=\u201cmyRoute\u201d type="]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cSystem.Router.myRouteConfigHandler\u201d>"]},{"entry":["14","\u2003\u2003\u2003<\/configSections>"]},{"entry":["15","\u2003\u2003\u2003<route1>"]},{"entry":["16","\u2003\u2003\u2003\u2003..."]},{"entry":["17","\u2003\u2003\u2003<\/route1>"]},{"entry":["18","\u2003\u2003\u2003<myRoute>"]},{"entry":["19","\u2003\u2003\u2003\u2003..."]},{"entry":["20","\u2003\u2003\u2003<\/myRoute>"]},{"entry":["21","\u2003\u2003<\/router>"]},{"entry":["22","\u2003\u2003<security>"]},{"entry":["23","\u2003\u2003\u2003\u2003..."]},{"entry":["24","\u2003\u2003<\/security>"]},{"entry":["25","\u2003<\/system>"]},{"entry":["26","\u2003<dataStorage>"]},{"entry":["27","\u2003\u2003<storage location>"]},{"entry":["28","\u2003\u2003\u2003..."]},{"entry":["29","\u2003\u2003<\/storage location>"]},{"entry":["30","\u2003\u2003<format1>"]},{"entry":["31","\u2003\u2003\u2003..."]},{"entry":["32","\u2003\u2003<\/format1>"]},{"entry":["33","\u2003<\/dataStorage>"]},{"entry":["34","<\/configuration>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Referring back to  and the example of Table II, during the first pass when the configuration system  encounters the system tag in line 6, it refers to the mappings of lines 2-5 and passes the content associated with the system tag (e.g., the content of lines 6-25) to the systemConfigHandler configuration handler, creating the systemConfigHandler configuration handler if necessary. When the systemConfigHandler configuration handler encounters the router tag in line 11, it refers to the mappings of lines 7-10 and passes the content associated with the router tag (e.g., the content of lines 11-21) to the System.routerConfigHandler configuration handler, creating the System.routerConfigHandler configuration handler if necessary. When the System.routerConfigHandler configuration handler encounters the tag myRoute in line 18, the System.routerConfigHandler configuration handler refers to the mappings of lines 12-14 and passes the content associated with the myRoute tag (e.g., the content of lines 18-20) to the System.Router.myRouteConfigHandler configuration handler, creating the System.Router.myRouteConfigHandler configuration handler if necessary.","During the second pass, the systemConfigHandler configuration handler invokes method on the components created by the System.routerConfigHandler configuration handler, components created by the System.securityConfigHandler configuration handler, and components created by the System.Router.myRouteConfigHandler. When invoking each of these methods, the systemConfigHandler configuration handler identifies (e.g., as a parameter to the methods), the components that were created by the System.routerConfigHandler configuration handler, the System.securityConfigHandler configuration handler, and the System.Router.myRouteConfigHandler.","It should be noted that in certain situations, depending on the nature of the configuration handlers, the two-pass process described in  may not be used. Rather, the notification of components may be performed as part of the component creation process (e.g., described with reference to ). For example, if some of the created components implement router functionality and others implement security functionality, it may be the situation that some of the router components may desire to implement some security features by accessing functionality of the security components, but that the security components do not desire to access any functionality of the router components. Thus, so long as the security components were created prior to the router components being created, then the created security components could be identified and incorporated into the router components when the router components are being created by the router configuration handler.","In certain embodiments, each component created by an extensible configuration handler exposes a method that can be invoked during the second pass (act  of ) to notify that component of the other components that have been created. This method has a parameter which is the collection of components that were created during the first pass.","One example environment where the extensible configuration handlers discussed herein can be used is in a message bus environment. A message bus environment refers to a messaging framework that allows components on the same or different computing devices to pass data among one another. Some of these components will typically include routing functionality to route data (e.g., data packets) from one device to another.","The following is an example Application Programming Interface (API) which can be used to implement various aspects of the extensible configuration handlers discussed herein. Although discussed with reference to a message bus, it is to be appreciated that analogous APIs can be generated for use with other environments. The example API includes the following four APIs:","(1) MessageBusConfiguration","(2) MessageBusConfigSectionHandler","(3) MessageBusConfigHandlerBase","(4) HandlerTable.","Additional information describing these four APIs follows.","(1) MessageBusConfiguration","public class MessageBusConfiguration: CollectionBase","Namespace: System.MessageBus","Assembly: System.Messagebus",{"@attributes":{"id":"p-0078","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Constructors"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public MessageBusConfiguration( );"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Constructs a default\/empty configuration loader.",{"@attributes":{"id":"p-0080","num":"0079"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Properties"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public object this[int index] {get; set;}"]},{"entry":[{},"public object this[Type type] {get; set;}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Methods to access an object created from the configuration file using the appropriate handler. Access is based on the index of the object in a list or the type of the object being created. Alternatively, access could be based on any other identifier of the object.",{"@attributes":{"id":"p-0082","num":"0081"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Methods"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public int Add(object item);"},{"entry":"Parameters"},{"entry":"\u2002item: System.Object"},{"entry":"Adds an object to the collection of configuration objects."},{"entry":"public bool Contains(object item);"},{"entry":"Parameters"},{"entry":"\u2002item: System.Object"},{"entry":"Returns a value indicating whether an identified object is included in"},{"entry":"a collection of objects."},{"entry":"public void CopyTo(object[ ] array, int index);"},{"entry":"Parameters"},{"entry":"\u2002array: System.Object[ ]"},{"entry":"\u2002index: System.Int32"},{"entry":"In a collection of objects, copies an object to a particular location"},{"entry":"(index) in a list of the objects."},{"entry":"public static MessageBusConfiguration GetFromConfig( );"},{"entry":"This method loads all the objects from the MessageBus section of"},{"entry":"the configuration file. Users of the MessageBus call this method to"},{"entry":"initiate the two-pass configuration loading defined in the rest of this"},{"entry":"document."},{"entry":"public int IndexOf(object item);"},{"entry":"Parameters"},{"entry":"\u2002item: System.Object"},{"entry":"Returns the location (index) in a list of the identified object."},{"entry":"public void Insert(int index, object item);"},{"entry":"Parameters"},{"entry":"\u2002index: System.Int32"},{"entry":"\u2002item: System.Object"},{"entry":"Allows an object to be added to a particular location (index) in a list"},{"entry":"of a collection of objects."},{"entry":"protected override void OnValidate(object value);"},{"entry":"Parameters"},{"entry":"\u2002value: System.Object"},{"entry":"Validates that only 1 object of a particular type is added to the"},{"entry":"collection of configuration objects. E.g. \u2014Only 1 router can be"},{"entry":"added to the configuration system. If there are more than 1 then"},{"entry":"anybody who wants to use the router won't know which one to use."},{"entry":"public void Remove(object item);"},{"entry":"Parameters"},{"entry":"\u2002item: System.Object"},{"entry":"Deletes an object from a collection of objects."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"(2) IMessageBusConfigSectionHandler","public interface IMessageBusConfigSectionHandler:","IConfigurationSectionHandler","Namespace: System.MessageBus.Configuration","Assembly: System.Messagebus","This is the interface that any handler that wants to participate in the extensible part of the configuration system implements. It inherits from the non-extensible interface IConfigurationSectionHandler (which allows non-extensible configuration handlers to be created) and adds the entry point for the 2pass called WireUp.",{"@attributes":{"id":"p-0088","num":"0087"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Methods"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"void WireUp(MessageBusConfiguration messageBusConfiguration);"},{"entry":"Wire up the various components created by config."},{"entry":"Parameters"},{"entry":"\u2002messageBusConfiguration:"},{"entry":"System.MessageBus.MessageBusConfiguration"},{"entry":"This method is called during the 2phase of configuration building. The"},{"entry":"Wireup method on each component is called and the list of components is"},{"entry":"passed in as the parameter to the call. This way the component being"},{"entry":"wired up has access to all other components in the system and can chose"},{"entry":"which ones it needs to do its functionality."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"(3) MessageBusSectionHandlerBase","public class MessageBusSectionHandlerBase:","IMessageBusConfigSectionHandler,","IConfigurationSectionHandler","MessageBusSectionHandlerBase\u2014wrapper for IMessageBusConfigSectionHandler. This implements a base class for storing and parsing an XMLNode Config object (a node in the XML document defining a configuration handler). This is a utility class to help implement extensible configuration handlers. The class implements basic XML parsing and the logic for recursively invoking child handlers.","Namespace: System.MessageBus.Configuration","Assembly: System.Messagebus",{"@attributes":{"id":"p-0096","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Constructors"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public MessageBusSectionHandlerBase( );"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0097","num":"0096"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Properties"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"protected virtual string AddElementName {get;}"},{"entry":"Xml element that is used to initiate an add."},{"entry":"protected virtual string ClearElementName {get;}"},{"entry":"Xml element that is used to initiate a clear. Clear removes all"},{"entry":"previously defined entries. So, if this element was encountered in,"},{"entry":"for example, a routing table, it would remove all previously added"},{"entry":"routes."},{"entry":"protected HandlerTable HandlerTable {get;}"},{"entry":"This is the list of child handlers that can be invoked to handle"},{"entry":"unrecognized XML tags."},{"entry":"protected virtual string KeyAttributeName {get;}"},{"entry":"Make the name of the key attribute configurable by derived classes"},{"entry":"protected MessageBusConfiguration ParentConfiguration {get;}"},{"entry":"Pointer to the parent configuration. For example, for a routing rule"},{"entry":"this points to the router."},{"entry":"protected virtual string RemoveElementName {get;}"},{"entry":"Xml element used to initiate a remove."},{"entry":"protected virtual string ValueAttributeName {get;}"},{"entry":"Make the name of the value attribute configurable by derived"},{"entry":"classes"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0098","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Methods"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"protected virtual void Add(string key, string value);"},{"entry":"\u2002Add - Adds\/Updates the collection"},{"entry":"Parameters"},{"entry":"\u2002key: System.String"},{"entry":"\u2002value: System.String"},{"entry":"protected virtual void Clear( );"},{"entry":"Clear the internal collection"},{"entry":"protected virtual void Create(object parent, object"},{"entry":"createContext);"},{"entry":"Creates an internal representation of the collection object being"},{"entry":"implemented"},{"entry":"Parameters"},{"entry":"\u2002parent: System.Object"},{"entry":"\u2002createContext: System.Object"},{"entry":"public virtual object Create(object parent, object configContext,"},{"entry":"XmlNode section);"},{"entry":"Given a partially composed config object (possibly null)and some"},{"entry":"input from the config system, return a further partially composed"},{"entry":"config object"},{"entry":"Parameters"},{"entry":"\u2002parent: System.Object"},{"entry":"\u2002configContext: System.Object"},{"entry":"\u2002section: System.Xml.XmlNode"},{"entry":"Return Value"},{"entry":"\u2002The object created as a result of this config section"},{"entry":"protected virtual object Get( );"},{"entry":"called before returning to Configuration code, used to generate the"},{"entry":"output collection object"},{"entry":"protected virtual void OnCreateChildObject(object child);"},{"entry":"Handle the creation of a child object"},{"entry":"Parameters"},{"entry":"\u2002child: System.Object"},{"entry":"protected virtual void OnProcessChildElement(XmlNode"},{"entry":"element);"},{"entry":"Process an XML Node that wasn't handled by the other config"},{"entry":"handlers."},{"entry":"Parameters"},{"entry":"\u2002element: System.Xml.XmlNode"},{"entry":"protected virtual void Remove(string key);"},{"entry":"Removes the specified key from the collection"},{"entry":"Parameters"},{"entry":"\u2002key: System.String"},{"entry":"protected virtual void WalkXmlNodeList(object parent, object"},{"entry":"configContext, XmlNode section);"},{"entry":"Walks list of XML nodes, and processes them by calling Add, Clear,"},{"entry":"Remove to cause them to update the config object we are processing"},{"entry":"Parameters"},{"entry":"\u2002parent: System.Object"},{"entry":"\u2002configContext: System.Object"},{"entry":"\u2002section: System.Xml.XmlNode"},{"entry":"public virtual void WireUp(MessageBusConfiguration"},{"entry":"configuration);"},{"entry":"Parameters"},{"entry":"\u2002configuration: System.MessageBus.MessageBusConfiguration"},{"entry":"2stage of processing."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"(4) HandlerTable","public class HandlerTable","Namespace: System.MessageBus.Configuration","Assembly: System.Messagebus","This class implements the mapping from tag to the handler for that class.",{"@attributes":{"id":"p-0104","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Constructors"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public HandlerTable( );"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0105","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Properties"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public IMessageBusConfigSectionHandler this[string tagName] {get;}"},{"entry":"Get the handler for this given tag."},{"entry":"public ICollection Values {get;}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0106","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Methods"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public void Add(string tagName, IMessageBusConfigSectionHandler"},{"entry":"handler);"},{"entry":"Parameters"},{"entry":"\u2002tagName: System.String"},{"entry":"\u2002handler:"},{"entry":"\u2002\u2002System.MessageBus.Configuration.IMessageBusConfigSectionHandler"},{"entry":"Add a mapping from a tag to a handler class."},{"entry":"public void Clear( );"},{"entry":"Delete all tag-handler mapping."},{"entry":"public void Remove(string tagName);"},{"entry":"Parameters"},{"entry":"\u2002tagName: System.String"},{"entry":"Remove a particular tag-handler mapping."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0107","num":"0106"},"figref":"FIG. 6","b":["400","400","400","400"]},"Computer environment  includes a general-purpose computing device in the form of a computer . Computer  can be, for example, a device  of . The components of computer  can include, but are not limited to, one or more processors or processing units , a system memory , and a system bus  that couples various system components including the processor  to the system memory .","The system bus  represents one or more of any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. By way of example, such architectures can include an Industry Standard Architecture (ISA) bus, a Micro Channel Architecture (MCA) bus, an Enhanced ISA (EISA) bus, a Video Electronics Standards Association (VESA) local bus, and a Peripheral Component Interconnects (PCI) bus also known as a Mezzanine bus.","Computer  typically includes a variety of computer readable media. Such media can be any available media that is accessible by computer  and includes both volatile and non-volatile media, removable and non-removable media.","The system memory  includes computer readable media in the form of volatile memory, such as random access memory (RAM) , and\/or non-volatile memory, such as read only memory (ROM) . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within computer , such as during start-up, is stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently operated on by the processing unit .","Computer  may also include other removable\/non-removable, volatile\/non-volatile computer storage media. By way of example,  illustrates a hard disk drive  for reading from and writing to a non-removable, non-volatile magnetic media (not shown), a magnetic disk drive  for reading from and writing to a removable, non-volatile magnetic disk  (e.g., a \u201cfloppy disk\u201d), and an optical disk drive  for reading from and\/or writing to a removable, non-volatile optical disk  such as a CD-ROM, DVD-ROM, or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are each connected to the system bus  by one or more data media interfaces . Alternatively, the hard disk drive , magnetic disk drive , and optical disk drive  can be connected to the system bus  by one or more interfaces (not shown).","The disk drives and their associated computer-readable media provide non-volatile storage of computer readable instructions, data structures, program modules, and other data for computer . Although the example illustrates a hard disk , a removable magnetic disk , and a removable optical disk , it is to be appreciated that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes or other magnetic storage devices, flash memory cards, CD-ROM, digital versatile disks (DVD) or other optical storage, random access memories (RAM), read only memories (ROM), electrically erasable programmable read-only memory (EEPROM), and the like, can also be utilized to implement the example computing system and environment.","Any number of program modules can be stored on the hard disk , magnetic disk , optical disk , ROM , and\/or RAM , including by way of example, an operating system , one or more application programs , other program modules , and program data . Each of such operating system , one or more application programs , other program modules , and program data  (or some combination thereof) may implement all or part of the resident components that support the distributed file system.","A user can enter commands and information into computer  via input devices such as a keyboard  and a pointing device  (e.g., a \u201cmouse\u201d). Other input devices  (not shown specifically) may include a microphone, joystick, game pad, satellite dish, serial port, scanner, and\/or the like. These and other input devices are connected to the processing unit  via input\/output interfaces  that are coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port, or a universal serial bus (USB).","A monitor  or other type of display device can also be connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , other output peripheral devices can include components such as speakers (not shown) and a printer  which can be connected to computer  via the input\/output interfaces .","Computer  can operate in a networked environment using logical connections to one or more remote computers, such as a remote computing device . By way of example, the remote computing device  can be a personal computer, portable computer, a server, a router, a network computer, a peer device or other common network node, and the like. The remote computing device  is illustrated as a portable computer that can include many or all of the elements and features described herein relative to computer .","Logical connections between computer  and the remote computer  are depicted as a local area network (LAN)  and a general wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet.","When implemented in a LAN networking environment, the computer  is connected to a local network  via a network interface or adapter . When implemented in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the wide network . The modem , which can be internal or external to computer , can be connected to the system bus  via the input\/output interfaces  or other appropriate mechanisms. It is to be appreciated that the illustrated network connections are examples and that other means of establishing communication link(s) between the computers  and  can be employed.","In a networked environment, such as that illustrated with computing environment , program modules depicted relative to the computer , or portions thereof, may be stored in a remote memory storage device. By way of example, remote application programs  reside on a memory device of remote computer . For purposes of illustration, application programs and other executable program components such as the operating system are illustrated herein as discrete blocks, although it is recognized that such programs and components reside at various times in different storage components of the computing device , and are executed by the data processor(s) of the computer.","Various modules and techniques may be described herein in the general context of computer-executable instructions, such as program modules, executed by one or more computers or other devices. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments.","An implementation of these modules and techniques may be stored on or transmitted across some form of computer readable media. Computer readable media can be any available media that can be accessed by a computer. By way of example, and not limitation, computer readable media may comprise \u201ccomputer storage media\u201d and \u201ccommunications media.\u201d","\u201cComputer storage media\u201d includes volatile and non-volatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules, or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by a computer.","\u201cCommunication media\u201d typically embodies computer readable instructions, data structures, program modules, or other data in a modulated data signal, such as carrier wave or other transport mechanism. Communication media also includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared, and other wireless media. Combinations of any of the above are also included within the scope of computer readable media.","One or more flowcharts are described herein and illustrated in the accompanying Figures. The ordering of acts in these flowchart(s) are examples only\u2014these orderings can be changed so that the acts are performed in different orders and\/or concurrently.","Although the description above uses language that is specific to structural features and\/or methodological acts, it is to be understood that the invention defined in the appended claims is not limited to the specific features or acts described. Rather, the specific features and acts are disclosed as exemplary forms of implementing the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The same numbers are used throughout the document to reference like components and\/or features.",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
