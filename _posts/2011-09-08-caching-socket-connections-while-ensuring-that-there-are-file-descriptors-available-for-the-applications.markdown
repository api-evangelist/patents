---
title: Caching socket connections while ensuring that there are file descriptors available for the applications
abstract: A method, system and computer program product for caching socket connections while ensuring that there are file descriptors available for the applications. File descriptor references and their referenced objects are stored in a predefined memory region of the heap (“file descriptor heap”). Each time a socket connection is cached, a file descriptor reference may be created to be associated with the socket connection's file descriptor, where the file descriptor reference references the object of the cached socket connection. In order to ensure that there are available file descriptors for the applications, the file descriptor references and their referenced objects are collected by the garbage collector in response to various events (e.g., too many file descriptors are open) thereby freeing the file descriptors that were previously associated with the collected connection objects to be used by the applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08903776&OS=08903776&RS=08903776
owner: International Business Machines Corporation
number: 08903776
owner_city: Armonk
owner_country: US
publication_date: 20110908
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","BRIEF SUMMARY","DETAILED DESCRIPTION"],"p":["The present invention relates to caching socket connections, and more particularly to caching socket connections while ensuring that there are file descriptors available for the applications.","When a socket connection (an endpoint for communication between two machines) is instantiated, such as a Remote Method Invocation (RMI) or an Object Request Broker (ORB) connection, the socket connection may be cached for reuse due to the fact that it is an expensive process in creating a socket connection in terms of time and resources.","Whenever a socket connection is cached though, it reduced the total available file descriptors (an indicator for accessing a file\/socket) to be used by the applications of the system as every end point of the socket connection creates and maintains a socket. If a substantial number of socket connections are cached, and as a result, a substantial number of file descriptors are used, then there may not be any file descriptors available for the applications. For example, if the maximum file descriptor limit is set to 1,024, and the number of file descriptors used to refer to the cached socket connections reaches 1,024, then there will not be any file descriptors available for the applications.","In an attempt to ensure that there will be file descriptors available for the applications, a time out period for which the socket connections are maintained in the cache may be implemented. When the time out period is reached, the socket connections are cleared from the cache, and their file descriptors become available. However, the time period may be set too low thereby clearing the cache pre-maturely defeating the purpose of having a cache. However, if the time period is set too high, then too many socket connections may be cached resulting in few, if any, available file descriptors for the applications.","Another attempt to ensure that there will be file descriptors available for the applications is to use a monitoring tool to monitor file descriptor leaks, referring to the situation when memory is consumed for file descriptors but is unable to be released back to the operating system. However, such a technique does not address the situation of having file descriptors created when socket connections are cached.","As a result, there is not currently an effective technique in caching socket connections while ensuring that there are file descriptors available for the applications in the system.","In one embodiment of the present invention, a method for caching socket connections while ensuring that there are file descriptors available for applications comprises creating a file descriptor reference to be associated with a cached socket connection, where the file descriptor reference references an object of the cached socket connection. The method further comprises storing, by a processor, the file descriptor reference and the object of the cached socket connection in a predefined memory area of a heap.","Other forms of the embodiment of the method described above are in a system and in a computer program product.","The foregoing has outlined rather generally the features and technical advantages of one or more embodiments of the present invention in order that the detailed description of the present invention that follows may be better understood. Additional features and advantages of the present invention will be described hereinafter which may form the subject of the claims of the present invention.","The present invention comprises a method, system and computer program product for caching socket connections while ensuring that there are file descriptors available for the applications. In one embodiment of the present invention, the memory region of the heap is partitioned into at least two memory regions, where one of the memory regions (referred to herein as the \u201cfile descriptor heap\u201d) stores file descriptor references and their referenced objects. Each time a socket connection is cached, a file descriptor reference may be created to be associated with the socket connection's file descriptor, where the file descriptor reference references the object of the cached socket connection. In order to ensure that there are available file descriptors for the applications, the file descriptor references and their referenced objects stored in the file descriptor heap may be collected by the garbage collector in response to various events (e.g., too many file descriptors are open, file descriptor heap reached its storage capacity) thereby freeing the file descriptors that were previously associated with the collected connection objects to be used by the applications. In this manner, socket connections can be cached while ensuring that there are file descriptors available for the applications.","In the following description, numerous specific details are set forth to provide a thorough understanding of the present invention. However, it will be apparent to those skilled in the art that the present invention may be practiced without such specific details. In other instances, well-known circuits have been shown in block diagram form in order not to obscure the present invention in unnecessary detail. For the most part, details considering timing considerations and the like have been omitted inasmuch as such details are not necessary to obtain a complete understanding of the present invention and are within the skills of persons of ordinary skill in the relevant art.","Referring now to the Figures in detail,  illustrates a hardware configuration of a computer system  which is representative of a hardware environment for practicing the present invention. Referring to , computer system  has a processor  coupled to various other components by system bus . An operating system  runs on processor  and provides control and coordinates the functions of the various components of . An application  in accordance with the principles of the present invention runs in conjunction with operating system  and provides calls to operating system  where the calls implement the various functions or services to be performed by application . Application  may include, for example, an application for caching socket connections while ensuring that there are file descriptors available for applications as discussed further below in association with .","Referring again to , read-only memory (\u201cROM\u201d)  is coupled to system bus  and includes a basic input\/output system (\u201cBIOS\u201d) that controls certain basic functions of computer device . Random access memory (\u201cRAM\u201d)  and disk adapter  are also coupled to system bus . It should be noted that software components including operating system  and application  may be loaded into RAM , which may be computer system's  main memory for execution. Disk adapter  may be an integrated drive electronics (\u201cIDE\u201d) adapter that communicates with a disk unit , e.g., disk drive. It is noted that the program for caching socket connections while ensuring that there are file descriptors available for applications, as discussed further below in association with , may reside in disk unit  or in application .","Computer system  may further include a communications adapter  coupled to bus . Communications adapter  interconnects bus  with an outside network thereby enabling computer system  to communicate with other similar devices.","Additionally, computer system  may include a cache , such as a level-1 cache, for caching socket connections. While cache  is shown to be internal within processor , cache  may be located external to processor. Cache  may be any type of cache (e.g., physically indexed, physically tagged; virtually indexed, virtually tagged; virtually indexed, physically tagged).","I\/O devices may also be connected to computer system  via a user interface adapter  and a display adapter . Keyboard , mouse  and speaker  may all be interconnected to bus  through user interface adapter . Data may be inputted to computer system  through any of these devices. A display monitor  may be connected to system bus  by display adapter . In this manner, a user is capable of inputting to computer system  through keyboard  or mouse  and receiving output from computer system  via display  or speaker .","As will be appreciated by one skilled in the art, aspects of the present invention may be embodied as a system, method or computer program product. Accordingly, aspects of the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a \u201ccircuit,\u201d \u2018module\u201d or \u201csystem.\u201d Furthermore, aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.","Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or flash memory), a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain, or store a program for use by or in connection with an instruction execution system, apparatus, or device.","A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein, for example, in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms, including, but not limited to, electro-magnetic, optical, or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate, propagate, or transport a program for use by or in connection with an instruction execution system, apparatus or device.","Program code embodied on a computer readable medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing.","Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the C programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).","Aspects of the present invention are described below with reference to flowchart illustrations and\/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the present invention. It will be understood that each block of the flowchart illustrations and\/or block diagrams, and combinations of blocks in the flowchart illustrations and\/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the function\/acts specified in the flowchart and\/or block diagram block or blocks.","These computer program instructions may also be stored in a computer readable medium that can direct a computer, other programmable data processing apparatus, or other devices to function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function\/act specified in the flowchart and\/or block diagram block or blocks.","The computer program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other devices to cause a series of operational steps to be performed on the computer, other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the function\/acts specified in the flowchart and\/or block diagram block or blocks.","As stated in the Background section, whenever a socket connection is cached, a file descriptor (an indicator for accessing a file) is used to refer to the cached socket connection which reduces the total available file descriptors to be used by the applications of the system. If a substantial number of socket connections are cached, and as a result, a substantial number of file descriptors are used, then there may not be any file descriptors available for the applications. For example, if the maximum file descriptor limit is set to 1,024, and the number of file descriptors used to refer to the cached socket connections reaches 1,024, then there will not be any file descriptors available for the applications. Currently, there is not an effective technique in caching socket connections while ensuring that there are file descriptors available for the applications in the system.","The principles of the present invention provide a technique in caching socket connections while ensuring that there are file descriptors available for the applications as discussed below in connection with .  is a stack model of a Java\u00ae virtual machine with a heap partitioned into memory regions, including a memory region dedicated to store file descriptor references and their referenced objects.  illustrates a heap including a predefined memory region for storing file descriptor references and their referenced objects.  is a flowchart of a method for having a predefined memory region of the heap store file descriptor references and their referenced objects.  is a flowchart of a method for determining when a garbage collection cycle will be implemented for removing file descriptor references and their referenced objects from the predefined memory region of the heap.  is a flowchart of a method for removing selected file descriptor references and their referenced objects from the predefined memory region of the heap during a garbage collection cycle.","As stated above,  is a stack model of a Java\u00ae virtual machine with a heap partitioned into memory regions, including a memory region dedicated to store file descriptor references and their referenced objects in accordance with an embodiment of the present invention.","Referring to , in conjunction with , application  (e.g., Java\u00ae application) can call at runtime a Java\u00ae class library , which is a set of dynamically loadable libraries. Java\u00ae class library  runs on a virtual machine , such as a Java\u00ae Virtual Machine (\u201cJVM\u201d). JVM  is one software application that may execute in conjunction with operating system . JVM  provides a Java\u00ae run-time environment with the ability to execute a Java\u00ae application or applet, which is a program, servlet, or software component written in the Java\u00ae programming language.","JVM  is a virtual computer component that executes Java\u00ae programs . Java\u00ae programs  are not run directly by the central processor (e.g., processor  of ) but instead by JVM , which is itself a piece of software running on the processor. JVM  allows Java\u00ae programs to be executed on different platforms, as opposed to only the one platform for which the code was compiled. Java\u00ae programs are compiled for JVM . In this manner, Java\u00ae is able to support applications for many types of data processing systems, which may contain a variety of central processing units and operating system architectures. To enable a Java\u00ae application to execute on different types of data processing systems, a compiler typically generates an architecture-neutral file format (i.e., the compiled code is executable on many processors, given the presence of the Java\u00ae run-time system). The Java\u00ae compiler generates bytecode instructions that are nonspecific to a particular computer architecture. A bytecode is a machine independent code generated by the Java\u00ae compiler and executed by a Java\u00ae interpreter . Java\u00ae interpreter  is part of JVM  that alternately decodes and interprets a bytecode or bytecodes. These bytecode instructions are designed to be easy to interpret on any computer and easily translated on the fly into native machine code. Bytecodes may be translated into native code by a Just-In-Time (JIT) compiler .","JVM  loads class files and executes the bytecodes within them. JVM  contains a class loader , which loads class files from an application and the class files from the Java\u00ae application programming interfaces (APIs) which are needed by the application.","One type of software-based execution engine is JIT compiler . With this type of execution, the bytecodes of a method are compiled to native machine code upon successful fulfillment of some type of criteria for just-in-time compiling a method.","When an application  is executed on JVM , a Java\u00ae application may interact with the host operating system  by involving native methods. A Java\u00ae method is written in the Java\u00ae language, compiled to bytecodes, and stored in class files. A native method is written in some other language and compiled to the native machine code of a particular processor. Native methods are stored in a dynamically linked library whose exact form is platform specific.","Referring again to , JVM  further includes runtime data areas . Runtime data areas  contain Java\u00ae stacks , Program Counter (PC) registers , native method stacks , a Java\u00ae heap  and memory management . These different data areas represent the organization of memory needed by JVM  to execute a program.","Java\u00ae stacks  are used to store the state of Java\u00ae method invocations. When a new thread is launched, JVM  creates a new Java\u00ae stack for the thread. JVM  performs only two operations directly on Java stacks : it pushes and pops frames. A thread's Java\u00ae stack stores the state of Java\u00ae method invocations for the thread. The state of a Java\u00ae method invocation includes its local variables, the parameters with which it was invoked, its return value, if any, and intermediate calculations. Java\u00ae stacks are composed of stack frames. A stack frame contains the state of a single Java\u00ae method invocation. When a thread invokes a method, JVM  pushes a new frame onto the Java\u00ae stack of the thread. When the method completes, JVM  pops the frame for that method and discards it. JVM  does not have any registers for holding intermediate values; any Java\u00ae instruction that requires or produces an intermediate value uses the stack for holding the intermediate values. In this manner, the Java\u00ae instruction set is well defined for a variety of platform architectures.","PC registers  are used to indicate the next instruction to be executed. Each instantiated thread gets its own PC register (program counter) and Java\u00ae stack. If the thread is executing a JVM method, the value of the PC register indicates the next instruction to execute. If the thread is executing a native method, then the contents of the PC register are undefined.","Native method stacks  store the state of invocations of native methods. The state of native method invocations is stored in an implementation-dependent way in native method stacks, registers, or other implementation-dependent memory areas. In some JVM implementations, native method stacks  and Java\u00ae stacks  are combined.","Java\u00ae heap  contains all instantiated objects. Each time a class instance or array is created, the memory for the new object is allocated from heap . In one embodiment, heap  may be divided into multiple regions, where one region is dedicated to storing file descriptor references and objects referenced by these references, as discussed further below in connection with . In this manner, socket connections may be cached while ensuring that there are file descriptors available for applications as discussed further below.","Memory management  in the depicted example manages memory space within the memory allocated to heap . Memory management  may include a \u201cgarbage collector,\u201d which automatically reclaims memory used by objects that are no longer referenced. Additionally, a garbage collector may also move objects to reduce heap fragmentation.","As stated above,  illustrates a heap  () including a predefined memory region for storing file descriptor references and their referenced objects in accordance with an embodiment of the present invention. Referring to , in conjunction with , heap  includes memory areas or regions for storing instantiated objects. Memory region  (labeled as \u201cGeneral Heap\u201d in ) corresponds to the memory area for storing all instantiated objects besides the file descriptor references and their referenced objects. Memory region  (labeled as \u201cFile Descriptor Heap\u201d in ) corresponds to the memory area for storing file descriptor references and their referenced objects.","As discussed above, when a socket connection is instantiated, a file descriptor (an indicator for accessing a file) is used to refer to the cached socket connection. To ensure that there are file descriptors available to be used by the applications, a new reference type, referred to herein as the \u201cfile descriptor reference,\u201d is created each time a file descriptor is used to refer to the cached socket connection. The file descriptor reference references the cached socket connection. These file descriptor references, along with the objects they reference (i.e., the connection objects), are stored in file descriptor heap  as illustrated in . As will be discussed further below, by having these file descriptor references, it is possible to trace the number of file descriptors being allocated for caching socket connections and to determine if the number of cached socket connections needs to be reduced thereby ensuring that there are available file descriptors for the applications.","Referring again to , file descriptor heap  stores file descriptor references A-C along with their referenced objects A-C. File descriptor references may collectively or individually be referred to as file descriptor references  or file descriptor reference , respectively. Furthermore, objects A-C may collectively or individually be referred to as objects  or object , respectively. While  illustrates three file descriptor references \/objects , file descriptor heap  may store any number of descriptor references \/objects . In one embodiment, the size of the memory region of file descriptor heap  is much smaller than the size of the memory region of general heap  since it serves to only store file descriptor references  and their referenced objects . By having a separate memory region in heap  dedicated to storing file descriptor references  and their referenced objects , a dedicated garbage collection cycle may be used to operate only on the file descriptor heap  and collect the file descriptor references  and referenced objects  as discussed further below in connection with . As a result, those threads that are accessing objects in general heap  will not be stopped when the garbage collection process is in progress for collecting file descriptor references \/objects . Furthermore, since the size of file descriptor heap  is much smaller than the size of the memory region of general heap , the duration of the garbage collection cycle for collecting descriptor references \/objects  will be very small in comparison to the duration of the garbage collection cycle for collecting objects in general heap  thereby not adversely affecting application performance.","A method for having a predefined memory region  in heap  for storing file descriptor references  and their referenced objects  is discussed below in connection with .",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 4","FIG. 3","FIGS. 2 and 3","FIG. 3","FIG. 3"],"b":["400","302","210","303","304"]},"Referring to , in conjunction with , in step , a socket connection is instantiated. In step , the instantiated socket connection is cached in a cache (e.g., cache ).","In step , a file descriptor reference is created to be associated with the cached socket connection. The created file descriptor reference references the object associated with the cached socket connection (i.e., the socket connection object).","In step , the file descriptor reference and the referenced object (i.e., the socket connection object) are stored in file descriptor heap .","In some implementations, method  may include other and\/or additional steps that, for clarity, are not depicted. Further, in some implementations, method  may be executed in a different order presented and that the order presented in the discussion of  is illustrative. Additionally, in some implementations, certain steps in method  may be executed in a substantially simultaneous manner or may be omitted.","In order to ensure that there are available file descriptors for the applications, the file descriptor references  and their referenced connection objects  stored in file descriptor heap  may be collected by the garbage collector at various times thereby freeing the file descriptors that were previously associated with the collected connection objects to be used by the applications. A flowchart of a method for determining when a garbage collection cycle will be implemented for removing file descriptor references  and their referenced objects  from file descriptor heap  is discussed below in connection with .",{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 5","FIG. 3","FIG. 3","FIG. 3"],"b":["500","303","304","302"]},"Referring to , in conjunction with , in step , a determination is made as to whether the number of file descriptors being open exceeds a threshold. File descriptors may be created in connection with the creation of sockets, files, pipes, etc. A threshold may be set as to the number of file descriptors to be open in order to ensure that there remains a sufficient number of file descriptors to be available for the applications.","If the number of file descriptors being open exceeds a threshold, then, in step , a garbage collection cycle for collecting the file descriptor references  and their referenced objects  in file descriptor heap  is triggered. A discussion of the garbage collection cycle is provided below in connection with .","If, however, the number of file descriptors does not exceed a threshold, then, in step , a determination is made as to whether file descriptor heap  has reached its storage capacity.","If file descriptor heap  reaches its storage capacity, then, the garbage collection cycle for collecting the file descriptor references  and their referenced objects  in file descriptor heap  is triggered in step .","If, however, file descriptor heap  has not reached its storage capacity, then, in step , a determination is made as to whether the garbage collection cycle is manually triggered. For example, a function could be defined that triggers the garbage collection cycle upon execution of that function.","If the garbage collection cycle has been manually triggered, then the garbage collection cycle for collecting the file descriptor references  and their referenced objects  in file descriptor heap  is triggered in step .","If, however, the garbage collection cycle has not been manually triggered, then a determination is made as to whether the number of file descriptors being open exceeds a threshold in step .","In some implementations, method  may include other and\/or additional steps that, for clarity, are not depicted. Further, in some implementations, method  may be executed in a different order presented and that the order presented in the discussion of  is illustrative. Additionally, in some implementations, certain steps in method  may be executed in a substantially simultaneous manner or may be omitted.","A method for selecting which file descriptor references  and their referenced objects  to be collected is discussed below in connection with .",{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIG. 6","FIG. 3","FIG. 3","FIG. 3"],"b":["600","303","304","302"]},"Referring to , in conjunction with , in step , for each file descriptor reference , a time that file descriptor reference  was created (see step  of ) is determined.","In step , for each file descriptor reference , a number of times (frequency count) that file descriptor reference  was used after the completion of the previous garbage collection cycle for file descriptor heap  is determined. In one embodiment, a least recently used policy may be used in deciding which file descriptor references  and referenced objects  to be collected. Such a policy may be enacted by determining the number of times that each file descriptor reference  was used. Those file descriptor references  (and their referenced objects ) that were least recently used would be the first to be collected.","In step , the file descriptor references  and their referenced objects  to be collected (i.e., cleaned) by the garbage collector during the garbage collection cycle for file descriptor heap  are identified based on the determinations made in steps  and . For example, a policy for collecting file descriptor references \/objects  may be based on frequency count and the time created. For instance, suppose that there are three file descriptor references  (e.g., file descriptor reference A, file descriptor reference B, file descriptor reference C) residing in file descriptor heap , and file descriptor reference A was first created followed by file descriptor reference B which was followed by file descriptor reference C. If only time was considered as a parameter for the policy as to which file descriptor references  to be collected, and the policy was that the most recently created would be collected, then file descriptor reference C would be collected. However, it may not be desirable to always collect the most recently crated file descriptor reference \/object . Hence, the frequency count may also be considered as a parameter. The policy may include the aspect that those file descriptor references  that are used the most (highest frequency count) should remain stored in file descriptor heap . Since those file descriptor references  that are stored in file descriptor heap  the longest have a greater chance of having a higher frequency count, the time that file descriptor references  were created should also be considered. In this manner, a balanced approach is applied for determining which file descriptor references  and their referenced objects  are to be collected (i.e., cleaned) by the garbage collector during the garbage collection cycle.","In step , the garbage collector removes the identified file descriptor references  and their referenced objects  (those identified in step ) during the garbage collection cycle for file descriptor heap .","In step , upon completion of the garbage collection cycle for file descriptor heap , the frequency count is set to 0 for all file descriptor references  that remain in file descriptor heap . This is to ensure that older file descriptor references  that were used frequently in the initial garbage collection cycle periods, but are not currently being used in the later garbage collection cycle periods, will not continue to survive in file descriptor heap  because of its initial heavy usage. As a result, a more accurate usage of the file descriptor references  during the period between consecutive garbage collection cycles for cleaning file descriptor heap  will be obtained.","In some implementations, method  may include other and\/or additional steps that, for clarity, are not depicted. Further, in some implementations, method  may be executed in a different order presented and that the order presented in the discussion of  is illustrative. Additionally, in some implementations, certain steps in method  may be executed in a substantially simultaneous manner or may be omitted.","The descriptions of the various embodiments of the present invention have been presented for purposes of illustration, but are not intended to be exhaustive or limited to the embodiments disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the described embodiments. The terminology used herein was chosen to best explain the principles of the embodiments, the practical application or technical improvement over technologies found in the marketplace, or to enable others of ordinary skill in the art to understand the embodiments disclosed herein."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":["A better understanding of the present invention can be obtained when the following detailed description is considered in conjunction with the following drawings, in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
