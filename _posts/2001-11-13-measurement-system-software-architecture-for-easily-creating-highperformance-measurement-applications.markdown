---
title: Measurement system software architecture for easily creating high-performance measurement applications
abstract: System and method for creating measurement applications. The system includes a measurement task specifier for generating a measurement task specification (MTS) for a measurement task in response to user input; an expert system for analyzing and validating the generated MTS, and generating a run-time specification (RTS) for the measurement task; a run-time builder for analyzing the RTS, configuring one or more measurement devices according to the RTS, and generating a run-time which is executable to perform the measurement task. The system includes a storage system for storing the generated MTS, the generated RTS, and configuration information for one or more measurement devices. The expert system includes one or more measurement experts which analyze all or part of the MTS and populate complete or partial RTSs. The partial RTSs are iteratively populated by other experts to form complete RTSs. Competing RTSs may be assessed and a final RTS selected based upon user preferences.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06879926&OS=06879926&RS=06879926
owner: National Instruments Corporation
number: 06879926
owner_city: Austin
owner_country: US
publication_date: 20011113
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["PRIORITY CLAIM","FIELD OF THE INVENTION","DESCRIPTION OF THE RELATED ART","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS","Glossary of Terms"],"p":["This application claims benefit of priority of U.S. provisional application Ser. No. 60\/301,785 titled \u201cMeasurement System Software Architecture for Easily Creating High-Performance Measurement Applications\u201d filed Jun. 29, 2001, whose inventors were Geoffrey Schmit, Brent Schwan, Jonathan Brumley, Tom Makowski and Chris Bartz.","The present invention relates to the field of measurement and automation systems, and more particularly to a software architecture for allowing a user to easily create measurement and automation tasks, verify functionality, and easily create application code to implement desired tasks.","Scientists and engineers often use measurement or automation systems to perform a variety of functions, including measurement of a physical phenomena or unit under test (UUT), test and analysis of physical phenomena, simulation, hardware-in-the-loop testing, process monitoring and control, control of mechanical or electrical machinery, data logging, laboratory research, and analytical chemistry, to name a few examples.","A typical measurement system comprises a computer system with a measurement device or measurement hardware. The measurement device may be or include a computer-based instrument, a data acquisition device or board, a programmable logic device (PLD), a sensor, a smart sensor, an actuator, or other type of device for acquiring or generating data. The measurement device may be a card or board plugged into one of the I\/O slots of the computer system, or a card or board plugged into a chassis, or an external device. For example, in a common measurement system configuration, the measurement hardware is coupled to the computer system via other means such as through a VXI (VME eXtensions for Instrumentation) bus, a PXI (PCI eXtensions for Instrumentation) bus, a GPIB (General Purpose Interface Bus), a serial port, or parallel port of the computer system. Optionally, the measurement system includes signal conditioning devices which receive the field signals and condition the signals to be acquired.","A measurement system may also typically include transducers, sensors, actuators or other detecting (or generating) means for providing \u201cfield\u201d electrical signals representing a process, physical phenomena, equipment being monitored or measured, etc. The field signals are provided to the measurement hardware.","The measurement hardware is configured and controlled by measurement software executing on the computer system. The measurement software for configuring and controlling the measurement system typically comprises two portions: the device interface or driver-level software and the application software, or the application. The driver-level software serves to interface the measurement hardware to the application. The driver-level software may be supplied by the manufacturer of the measurement hardware or by some other third party software vendor. An example of measurement or DAQ driver-level software is NI-DAQ from National Instruments Corporation. The application or client is typically developed by the user of the measurement system and is tailored to the particular function which the user intends the measurement system to perform. The measurement hardware manufacturer or third party software vendor sometimes supplies the application software for certain applications which are common, generic or straightforward.","Some comprehensive and complex measurement system architectures, for example, National Instruments' NI-DAQ 6.9, have various drawbacks which limit the effectiveness and ease with which a measurement task may be specified, designed, and implemented. These include performance, ease of use, and engineering efficiencies issues. One performance related inadequacy of some current architectures is a lack of a state model for the system. The absence of a state model results in resources being reserved, programmed, and unreserved continuously, because no component or process is aware of what may have already been done. Ease-of-use issues may range from interface complexities to functionality inconsistencies. For example, some current architectures distinguish between different types of measurement devices, requiring different APIs (Application Programming Interfaces) for each. Thus, a user is required to learn multiple APIs. The use of multiple APIs often results in inconsistent support of key features across product lines, and greatly increases the effort and expense of software maintenance, feature extensions, and product additions.","Another drawback of some current measurement system architectures is that complex measurement tasks involving multiple devices require that each device be programmed separately, and that synchronization signals be explicitly routed. Users must typically specify and configure measurement tasks at an advanced level, which is time consuming, expensive, and prone to error.","Additionally, some current architectures generally do not allow more than one execution thread to be active at a time, which can substantially limit performance of the system.","Also, some current measurement system architectures are largely monolithic, resulting in large disk and run-time footprints, thereby limiting the types of devices suitable for storing and executing the measurement system. For example, large monolithic systems are not typically deployable in PDAs (personal digital assistants) or as embedded systems. Furthermore, monolithic systems often result in software being installed that a customer does not need.","Finally, many current measurement systems require that the user perform a significant amount of programming, either in a text-based programming language such as LabWindows or Visual Basic, or in a graphical programming language such as LabVIEW. It would be desirable for a user to be able to more easily create measurement solutions with reduced programming requirements.","Therefore, it would be desirable to provide new systems and methods for specifying and performing measurement tasks.","Various embodiments of a system and method for creating measurement applications are presented. The system may include a computer system and may also include one or more measurement devices. The one or more measurement devices may comprise a measurement hardware device, a virtual measurement device or other type of device. In one embodiment, the system may further include a device and resource configuration tool which may be operable to receive user input to set system configuration parameters for the one or more measurement devices.","The system may include a measurement task specifier which may be operable to generate a measurement task specification for a measurement task in response to user input. The system may also include an expert system which may be operable to analyze the generated measurement task specification, validate the measurement task specification, and generate a run-time specification for the measurement task. The system may further include a run-time builder that is operable to analyze the run-time specification, configure one or more measurement devices according to the run-time specification, and generate a run-time, wherein the run-time is executable to perform the measurement task. The system may store a plurality of measurement primitives. Each measurement primitive may comprise a software object and corresponding configuration settings, and each measurement primitive may be operable to implement at least a portion of a measurement task. The run-time builder may generate the run-time using one or more of the measurement primitives. The system may also include a memory medium or storage system which is operable to store one or more of the generated measurement task specification, the generated run-time specification, and configuration information for the one or more measurement devices.","In one embodiment, the measurement task specifier may comprise an Application Programming Interface (API) through which the user may make calls to generate the measurement task specification. The measurement task specifier may include, be implemented in, or accessed through, any of various application programming development environments, such as Visual Basic, Visual C++, Visual Studio .NET, LabWindows CVI or LabVIEW, among others. For example, the measurement task specifier may comprise a graphical program, such as a LabVIEW graphical program. The user may place nodes or icons in a graphical diagram and connect the nodes with virtual \u201cwires\u201d to specify a measurement task. The execution of this graphical diagram may generate the measurement task specification.","In another embodiment, the measurement task specifier may comprise a measurement task wizard, i.e., a software program which leads the user through a measurement task specification process, thereby generating the measurement task specification.","In yet another embodiment, the measurement task specifier may include a measurement task configuration tool. The measurement task configuration tool may be an interactive Graphical User Interface (GUI) program which enables the user to select various parameters of the measurement task, such as the type of measurement being performed using voltage, current, etc., and other measurement settings. The measurement task specifier may be operable\n\n","The measurement task specifier may be operable to generate programming code for a measurement task in response to user input. The programming code for a measurement task may include one or more of C code, C++ code, Visual Basic code, C# code, Java code, graphical code (e.g., LabVIEW code) or any other programming code.","Expert System Embodiment #1","In one embodiment, the expert system may comprise a plurality of experts, where the expert system may be operable to create a device expert call tree of one or more experts from the plurality of experts according to a user-specified measurement task configuration, manage the configuration of the measurement task specification, and verify the measurement task specification and compile the measurement task specification into the run-time specification.","The plurality of experts may include device experts, channel experts, timing experts, reader\/writer experts, control experts, and streaming experts. Each class of expert is responsible for managing different aspects of the measurement task specification.","The expert system may create the device expert call tree of associated experts according to the named channels that comprise the measurement task specification. Named channels may be specified by a user with a measurement task specifier or may be automatically specified by a system configuration tool based on the installed measurement devices. The configuration of these named channels may produce fully qualified channel paths and associated channel measurement specification object (MSO) mementos associated with these named channels.","In one embodiment, fully qualified channel paths comprise a series of expert configurations corresponding to the complete topography for the particular channel. Each expert configuration may specify a terminal configuration, the expert associated with that terminal configuration, and a reference to the capabilities of that expert.","In one embodiment, channel MSO mementos are serialized attributes of channel MSOs explicitly configured by a user through a measurement task specifier or by a system configuration tool based on the measurement devices installed in the system. Whenever a channel is added to a measurement task specification, the corresponding channel MSO mementos may be deserialized into the measurement task specification. This allows users to configure default attributes for named channels that span all measurement tasks.","In one embodiment, the first step in the creation of a collection of associated experts according to the user-specified configuration is the construction of the device expert call tree. The expert system may begin the creation of this device expert call tree when the user initializes a new measurement task by providing a list of named channels. A device expert call tree may contain all the experts that will be used to compile a given measurement task specification into a run-time specification. The structure of the tree may determine the order in which the experts are called, as well as the interactions between the experts. The construction of a device expert call tree may be based on the fully qualified channel paths for each channel in the measurement task. Note that additional device experts, associated with channels that were not originally added to the measurement task, may be added after the construction of the device expert call tree.","In the preferred embodiment, the expert call tree is constructed in an in-order, top-down approach. In one embodiment, the general algorithm includes walking (traversing) the series of expert configurations for all of the channels simultaneously. At each point, an expert instance may be created for each unique expert identifier at that level in the fully qualified channel path. Note that if the expert identifier associated with the root entry of the fully qualified channel path is not the same for all named channels in the measurement task, than an expert will be inserted at the root of the expert call tree. This expert may then handle the synchronization between multiple measurement devices or multiple sub-systems on a single measurement device.","After the device expert call tree is built, device experts for each node may be initialized. Initialization information may include the device expert's parent and children in the device expert call tree, a reference to an object that maintains the state of the measurement task, and the hardware capabilities of the device which may be stored in a memory medium, e.g., MXS.","Each device expert may understand or be associated with a specific set of channel experts designed for that device. Once device experts have been created and initialized, the expert system may create channel experts for each specified named channel. The expert system may create channel experts by passing a fully qualified channel path to the leaf (terminal node in the tree structure) device expert in the call tree corresponding to the specific channel. When a device expert's create channel method is invoked, the device expert may first request that its parent device expert create a channel expert as well. The parent channel expert may be created using a version of the fully qualified channel path with the most derived terminal configuration truncated. This sequence may continue up the device expert call tree until all channel experts for a particular fully qualified channel path have been created. Each channel expert may retain a reference to the corresponding parent channel expert for use when the measurement task is configured.","After the expert system creates channel experts for each channel, the corresponding channel MSO mementos may be deserialized from named channels which may be stored in MXS. The expert system may then query channel experts for channel MSOs, and apply the channel MSO mementos to them. This allows users to configure default attributes for named channels that span all tasks.","After the expert system creates the device expert call tree, the user may configure the measurement task specification through the use of a measurement task specifier. The measurement task specifier may rely upon the expert system to manage this configuration of the measurement task specification. The expert system may manage the configuration of the measurement task specification whenever attributes of the measurement task are specified or queried. The specification of the measurement task may occur in any order. The measurement task specification may be modified after the measurement task specification has been verified and compiled. When this occurs, the measurement task specification may be efficiently re-verified and recompiled. Also, the measurement task specification may be modified while the measurement task is executing. When this occurs, the expert system directly and immediately may modify the primitives in the run-time to reflect the modification to the measurement task specification. Configuration of the measurement task specification preferably entails setting various attributes of the MSOs in the measurement task specification.","Root device experts may contain objects implementing specific timing expert interfaces. The expert system may be able to query for these timing experts through an interface. In one embodiment, this query may be done only from the root of device expert tree, with device experts deferring requests to children experts if they are unable to satisfy them. Timing experts may be queried and configured whenever specific timing or triggering attributes are configured. Measurement task specifiers may be able to use specific timing interfaces to configure these attributes.","Channel experts may be configured whenever a measurement task specifier executes a set or get operation on a channel MSO. The first time a set or get is specified for a particular channel MSO, the measurement task specifier may query the appropriate leaf channel expert for that MSO. If a particular channel expert is unable to satisfy that query, the request may be deferred to the channel expert's parent. Sets and gets may then be performed directly on the MSO itself. The measurement task specifier may maintain a cache of any MSOs that have been queried or modified, and so subsequent sets and gets may not require querying the channel expert. The MSO cache may also maintain information about whether each MSO was modified or only queried. During the storage of a measurement task, the measurement task specifier may examine this cache and only store those MSOs actually modified by the customer. This strategy may enable a maximum amount of portability for tasks by not serializing MSO attributes which were only queried, i.e., which were not modified.","The expert system may also verify the measurement task specification and compile the measurement task specification into a run-time specification. The expert system may verify the measurement task specification when, implicitly or explicitly, a measurement task specifier invokes a verify operation for a measurement task. In one embodiment, the verification and compilation of the measurement task specification may consist of three ordered steps, described below.","In one embodiment, the analyze channels step is the first step of the verification and compilation of the measurement task specification. In a post-order (bottom-up) traversal of the device expert call tree, all device experts may be instructed to analyze the properties of all contained channels. During this step, device experts may query channel MSOs from channel experts, analyze their attributes, and produce attributes of channel MSOs for corresponding parent channel experts.","In one embodiment, the second step of the verification and compilation of the measurement task specification is the analysis of timing properties. In a pre-order (top-down) traversal of the device expert call tree, all device experts may be instructed to analyze the properties of all contained timing. During this step, device experts may query timing MSOs from timing experts, analyze their attributes, and produce attributes of timing MSOs for corresponding children timing experts.","The final step of the verification and compilation of the measurement task specification is the compilation into the run-time specification, according to one embodiment. In a pre-order (top-down) traversal of the device expert call tree, some or all of the device experts may be instructed to compile. During this step, device experts may create primitive settings and add them to the run-time specification. Channel MSO attributes or negotiated ranges may also be resolved during this step. Additionally, stream building and signal routing may be executed at this step.","The bottom-up and top-down traversals of the tree are performed to allow attributes to be propagated through all the experts. Channel attributes generally describe an individual measurement or generation at the bottom leaves of the tree which corresponds to where the user has connected his or her signal to the physical measurement system. Attributes, such as physical range, may be inspected and\/or modified by each expert upwards along the channel data path so that each expert can be given derived settings. Timing attributes, on the other hand, generally describe timing for all the measurements in a single task. Attributes, such as rate, may be propagated downwards and derived into the specific settings of multiple devices. These direction generalizations are not strictly true, however. For instance, a scan list MSO can be involved in both the channel and timing analysis steps, acting as a bridge of sorts between the two expert classifications.","In one embodiment, the measurement system may use streaming experts to compile stream specifications in the task specification into stream primitive settings in the task run-time specification. The term \u201cstreaming\u201d refers generally to data transport, e.g., reads and writes, but may also include data processing operations, such as filtering, splitting and combining of signals, and scaling, among others. Streaming experts may collaborate to transfer and process the data between its source(s) and destination(s). Examples of streaming experts may include an environment changer, format changer, linear scaler, splitter, polynomial scaling filter, pattern matching filter, buffer writer, kernel reader proxy and dispatcher, splitting writer, and combining reader, among others. Note that in one embodiment, the components of the class library may be operable to not only move data, but to analyze, transform, split, and\/or combine data, as well.","In one embodiment, a user may modify the measurement task specification incrementally using the task specifier. The expert system may subsequently revalidate the task specification, making incremental changes to the run-time specification. In other words, the expert system may incrementally recompile the modified measurement task specification, thereby updating the run-time specification. Changes to the run-time specification may then be deployed incrementally to reconfigure the run-time. These changes may include adding new primitive settings, modifying existing primitive settings, and removing primitive settings, among others.","In one embodiment, the measurement system may be operable to reserve one or more resources according to the generated run-time specification. In one embodiment, the generated run-time specification may comprise a specification of the parameters of one or more measurement primitives corresponding to rudimentary measurement operations of the measurement task. The measurement system may then instantiate measurement primitives in the form of software objects which may be used to configure one or more measurement devices when the run-time is executed, according to the run-time specification. This may comprise setting the values of parameters or registers of the measurement devices (hardware and\/or software) as appropriate to carry out the specified measurement task. The measurement system may thus generate the run-time by creating instances of the measurement primitives with the specified parameters. The run-time may then be executable to perform the specified measurement task.","In one embodiment, a language compiler, such as a C++, Java, or LabVIEW compiler, may be integrated into the measurement system. Integrating language compilation capabilities with the measurement task compilation capabilities of the expert system may provide \u201cjust in time\u201d (JIT) functionality to the measurement system, thereby increasing the flexibility, as well as the portability of measurement solutions.","Expert System Embodiment #2","In another embodiment, the expert system may comprise a plurality of experts, where the expert system may be operable to analyze the generated measurement task specification, and select and invoke one or more experts to generate a solution suitable for the user's measurement system. The selected experts may each analyze the generated measurement task specification and populate a respective candidate run-time specification, thereby producing one or more further populated candidate run-time specifications, where each respective candidate run-time specification comprises a possible partial or complete solution for the measurement task. The expert system may then calculate one or more metrics for each of the populated candidate run-time specifications, and select one of the populated candidate run-time specifications based on the calculated metrics.","In one embodiment, if the analysis by a respective expert indicates that the expert cannot populate at least a portion of the respective candidate run-time specification, the respective expert indicates to the expert system that it did not populate the candidate run-time specification for the measurement task specification. If the analysis by a respective expert indicates that the expert is operable to populate the respective candidate run-time specification, the expert populates the respective candidate run-time specification, and communicates the respective candidate run-time specification to the expert system. If the analysis by a respective expert indicates that the expert is operable to populate only a first portion of the respective candidate run-time specification corresponding to a first portion of the generated measurement task specification, the expert populates the first portion of the respective candidate run-time specification, communicates the first portion of the respective candidate run-time specification to the expert system, and submits a second portion of the respective measurement task specification to the expert system as a new, second measurement task specification, for which a respective candidate run-time specification portion was not populated.","The expert system may thus be further operable to receive and analyze the second measurement task specification, in the manner described above. For example, the expert system may be further operable to select and invoke one or more other experts to analyze the second measurement task specification and populate the respective candidate run-time specification, thereby producing one or more further populated candidate run-time specifications, where each respective candidate run-time specification comprises a possible partial or complete solution for the measurement task. The expert system may then calculate one or more metrics for each of the candidate run-time specifications, and select one of the candidate run-time specifications based on the calculated metrics.","The expert system may be further operable to iteratively perform the above process on unsolved portions of the measurement task (or sub-tasks) until either the entire measurement task has been solved, or until the expert system determines that a solution may not be found subject to the current system resources. The expert system may then operate to select a run-time specification from the candidates based on user specified and\/or system-specified metrics.","In one embodiment, the system may further include a storage system which is operable to store an expert registry. The expert registry may include information correlating each expert with aspects of one or more respective measurement tasks, and selection of the one or more experts may be performed based on the expert registry.","In one embodiment, the run-time builder may be operable to reserve one or more resources according to the selected run-time specification. In one embodiment, the generated run-time specification may comprise a specification of the parameters of one or more measurement primitives corresponding to rudimentary measurement operations of the measurement task. The run-time builder may then instantiate measurement primitives in the form of software objects which may be used to configure one or more measurement devices when the run-time is executed, according to the run-time specification. This may comprise setting the values of parameters or registers of the measurement devices (hardware and\/or software) as appropriate to carry out the specified measurement task. The run-time builder may thus generate the run-time by creating instances of the measurement primitives with the specified parameters. The run-time may then be executable to perform the specified measurement task.","In one embodiment, the measurement task may comprise a plurality of measurement sub-tasks. In another embodiment, the measurement task may comprise a complex measurement operation using a plurality of measurement devices.","As noted above, the measurement task specifier may comprise an API or an application programming development environment. For example, the user may begin in a text-based application programming development environment such as Visual Basic, Visual C++, Visual Studio .NET, LabWindows CVI or LabVIEW, among others. The user may enter textual source code that forms the measurement task specification. For example, the user may input function calls that correspond to the measurement task specification being created. As another example, the user may begin in a graphical programming application development environment such as LabVIEW. The user may select and configure one or more graphical nodes or icons and interconnect the nodes to represent the measurement task specification. As another example, the user may begin by using an interactive prototyping environment. The user may select measurement functions in the prototyping environment, where the functions are stored in a script or prototype that represents the measurement task specification. At this point, the measurement task specification (the textual code, the graphical program, or the prototype created by the user) is not a working program.","The expert system may analyze the measurement task specification, created by executing the source code created by the user, validate the measurement task specification, and generate a run-time specification. The run-time specification may include a data structure comprising parameter specifications for one or more measurement primitives corresponding to rudimentary measurement operations of the measurement task. The run-time specification may then be interpreted by the run-time builder to generate a run-time which is executable to perform the specified measurement task.","Thus, in various embodiments, the present invention provides systems and method whereby a user may specify a measurement task and generate a corresponding measurement application which may be executed to implement the measurement task using available system resources.","While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and are herein described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.","FIGS. A and B\u2014Instrumentation and Industrial Automation Systems",{"@attributes":{"id":"P-00128","num":"00128"},"figref":["FIGS. 1A and 1B","FIGS. 1A and 1B","FIGS. 1A and 1B"]},"As used herein, the term \u201cmeasurement system\u201d is intended to include an instrumentation system such as that shown in , an industrial automation system such as that shown in , or a modeling or simulation system involved with the design, validation or testing of a product involving \u201creal world I\/O\u201d, i.e., the acquisition or generation of data to\/from a model or simulation of a device or product being designed, validated or tested, such as hardware-in-the loop validation. The term \u201cmeasurement\u201d may include instrumentation measurement, data acquisitions, automation, control, and simulation.",{"@attributes":{"id":"P-00130","num":"00130"},"figref":"FIG. 1A","b":["100","100","102","102","102","150"]},"The host computer  may execute a program which interacts with or controls the one or more instruments. The one or more instruments may include a GPIB instrument  and associated GPIB interface card , a data acquisition board  and associated signal conditioning circuitry , a VXI instrument , a PXI instrument , a video device or camera  and associated image acquisition card , a motion control device  and associated motion control interface card , and\/or one or more computer based instrument cards , among other types of devices. Note that the computer based instrument card  may be a board or card with one or more FPGAs, one or more CPUs and memory, or various combinations of the two.","The GPIB instrument  may be coupled to the computer  via the GPIB interface card  provided by the computer . In a similar manner, the video device  may be coupled to the computer  via the image acquisition card , and the motion control device  may be coupled to the computer  through the motion control interface card . The data acquisition board  may be coupled to the computer , and may interface through signal conditioning circuitry  to the UUT. The signal conditioning circuitry  may comprise an SCXI (Signal Conditioning eXtensions for Instrumentation) chassis comprising one or more SCXI modules .","The GPIB card , the image acquisition card , the motion control interface card , and the DAQ card  are typically plugged in to an I\/O slot in the computer , such as a PCI bus slot, a PC Card slot, or an ISA, EISA or MicroChannel bus slot provided by the computer . However, these cards , ,  and  are shown external to computer  for illustrative purposes. These cards , , ,  may also connected to the computer  through a USB (Universal Serial Bus), IEEE 1394 or 1394.2 bus provided by the computer .","The VXI chassis or instrument  may be coupled to the computer  via a VXI bus, MXI bus, or other serial or parallel bus provided by the computer . The computer  may include VXI interface logic, such as a VXI, MXI or GPIB interface card (not shown), which interfaces to the VXI chassis . The PXI instrument may be coupled to the computer  through the computer's PXI bus. The PXI chassis may be coupled to the computer  via a MXI-3 bus.","A serial instrument (not shown) may also be coupled to the computer  through a serial port, such as an RS-232 port, USB (Universal Serial bus) or IEEE 1394 or 1394.2 bus, provided by the computer .","In typical instrumentation control systems an instrument of each interface type may not be present, and in fact many systems may only have one or more instruments of a single interface type, such as only GPIB instruments. The instruments are coupled to the unit under test (UUT) or process , or are coupled to receive field signals, typically generated by transducers. The system  may be used in a data acquisition and control application, in a test and measurement application, a process control application, a man-machine interface application, or a simulation application.",{"@attributes":{"id":"P-00137","num":"00137"},"figref":["FIG. 1B","FIG. 1A","FIG. 1B"],"b":["160","160","100","1","160","102","102","102","150","102","160"]},"The one or more devices may include a data acquisition board  and associated signal conditioning circuitry , a PXI instrument , a video device  and associated image acquisition card , a motion control device  and associated motion control interface card , a FieldBus device  and associated FieldBus interface card , a PLC (Programmable Logic Controller) , a serial instrument  and associated serial interface card , or a distributed data acquisition system, such as the FieldPoint system available from National Instruments, among other types of devices.","The DAQ card , the PXI chassis , the video device  and image acquisition card , and the motion control device  and motion control interface card  may be coupled to the computer  as described above. The serial instrument  may be coupled to the computer  through a serial interface card , or through a serial port, such as an RS-232 port, provided by the computer . The PLC  may couple to the computer  through a serial port, Ethernet port, or a proprietary interface. The FieldBus interface card  may be comprised in the computer  and interfaces through a FieldBus network to one or more FieldBus devices. Each of the DAQ card , the serial card , the FieldBus card , the image acquisition card , and the motion control card  are typically plugged in to an I\/O slot in the computer  as described above. However, these cards , , , , and  are shown external to computer  for illustrative purposes. In typical industrial automation systems a device will not be present of each interface type, and in fact many systems may only have one or more devices of a single interface type, such as only PLCs. The devices are coupled to the device or process .","Referring again to , the computer system  and\/or one or more of the instruments or devices may include a memory medium (or memory mediums) on which software according to the present invention may be stored. The memory medium may store a measurement task specifier, an expert system, a plurality of experts, a run-time builder, and a plurality of measurement primitives. Additionally, the memory medium(s) may store various products produced by or with these software components, such as a measurement task specification, a run-time specification, and a run-time, all of which are described in more detail below. The memory medium(s) may also store configuration information for one or more of the above software programs.","The term \u201cmemory medium\u201d is intended to include an installation medium, e.g., a CD-ROM, floppy disks , or tape device; a computer system memory or random access memory such as DRAM, SRAM, EDO RAM, RRAM, etc.; or a non-volatile memory such as a magnetic media, e.g., a hard drive, or optical storage. The memory medium may comprise other types of memory as well, or combinations thereof.","In addition, the memory medium may be located in a first computer in which the shared library is stored or executed, or may be located in a second different computer which connects to the first computer over a network, such as the Internet. In the latter instance, the second computer provides the program instructions to the first computer for execution. Also, the computer system  may take various forms, including a personal computer system, mainframe computer system, workstation, network appliance, Internet appliance, personal digital assistant (PDA), television set-top box, instrument, or other device. In general, the term \u201ccomputer system\u201d can be broadly defined to encompass any device having at least one processor which executes instructions from a memory medium.","In one embodiment, the software programs and software architecture as described herein may be designed for measurement systems, including data acquisition\/generation, analysis, and\/or display; automation systems; simulation systems; systems for controlling, modeling, or simulating instrumentation or industrial automation hardware; and systems for controlling, modeling or simulating systems or devices being designed, prototyped, validated or tested. However, it is noted that the present invention can be used for a plethora of applications and is not limited to instrumentation or industrial automation applications. In other words,  are exemplary only, and the software programs and software architecture may be used for any of various purposes and may be stored in and execute on any of various types of systems to perform any of various applications.","FIG. \u2014Computer System Block Diagram",{"@attributes":{"id":"P-00145","num":"00145"},"figref":["FIG. 2","FIGS. 1A and 1B","FIG. 2","FIGS. 1A and 1B"]},"The computer  includes at least one central processing unit or CPU  which is coupled to a processor or host bus . The CPU  may be any of various types, including a x86 processor, e.g., a Pentium class; a PowerPC processor; a CPU from the SPARC family of RISC processors; as well as others. Main memory  is coupled to the host bus  by means of memory controller . The main memory  may store one or more computer programs or libraries according to one embodiment of the present invention. The main memory  also stores operating system software as well as the software for operation of the computer system, as well known to those skilled in the art.","The host bus  is coupled to an expansion or input\/output bus  by means of a bus controller  or bus bridge logic. The expansion bus  is preferably the PCI (Peripheral Component Interconnect) expansion bus, although other bus types can be used. The expansion bus  includes slots for various devices such as the data acquisition board  (of FIG. A), a GPIB interface card  which provides a GPIB bus interface to the GPIB instrument  (of FIG. A), and a reconfigurable instrument . Note that as used herein, the term \u201creconfigurable instrument\u201d refers to an instrument with one or more of:\n\n","For more information on a reconfigurable instrument which includes an embedded processor and embedded memory, please see U.S. Pat. No. 6,173,438 which is hereby incorporated by reference in its entirety as though filly and completely set forth herein. For more information on a reconfigurable instrument which includes reconfigurable hardware, e.g., an FPGA, please see U.S. Pat. No. 6,219,628 which is hereby incorporated by reference in its entirety as though fully and completely set forth herein. The computer  may further comprise a video display subsystem  and hard drive  coupled to the expansion bus .","FIG. \u2014Creating a Measurement Solution",{"@attributes":{"id":"P-00152","num":"00152"},"figref":"FIG. 3","b":["202","202","202","202"]},"As shown, the application  communicates with a measurement driver . The measurement driver  may include a measurement driver application programming interface (API) . As shown, the application program A or B interfaces with the measurement driver API  in order to access capabilities of the measurement driver . In this measurement example, the software architecture may also include interchangeable virtual instrument (IVI) drivers  wherein the application program B may interface through IVI drivers , which interface with the measurement driver API , to interface with the measurement driver .","The measurement driver  interfaces to the one or more various measurement devices  comprised in this system. The measurement devices  may comprise any of the various devices discussed above with respect to  or B and may comprise other devices not shown in  as desired. In one embodiment, at least one of the one or more measurement devices comprises a hardware measurement device. In another embodiment, at least one of the one or more measurement devices comprises a virtual measurement device.","In one embodiment, the present invention provides an improved system and method for creating application programs, such as application programs A and B. The measurement driver  preferably includes various software that may allow creation of an application program A or B using a high-level interface and requiring reduced user effort and coding.","FIG. \u2014Measurement Driver Program Components",{"@attributes":{"id":"P-00157","num":"00157"},"figref":"FIG. 4","b":["400","212","212","730","750","406","780","408","212"]},"As  also illustrates, various of the measurement driver components maybe operable to generate respective products which may be useable by other measurement driver components, by other software programs or systems, or by a user. More specifically, as shown in , in one embodiment, the measurement task specifier  may be operable to generate a measurement task specification . In one embodiment, the measurement task specification  may comprise software objects or data structures, such as C++ objects, which may specify the measurement task. In one embodiment, the measurement task specifier  may be a measurement task wizard, i.e., a software program which leads the user through a measurement task specification process to create the measurement task specification . In another embodiment, the measurement task specifier  may take the form of a measurement task configuration tool, which is a software program invocable by the user under a development environment, such as the National Instruments LabVIEW\u2122 environment or Measurement Studio\u2122 programming development environment (the terms LabVIEW, and Measurement Studio, used throughout this application, are trademarks of National Instruments Corporation). In yet another embodiment, the measurement task specifier  may simply be an API through which the user makes calls to generate the task specification. Thus, in various embodiments, the measurement task specifier  may generate the measurement task specification  in response to user input.","As shown, the expert system  may use the measurement task specification  to generate a run-time specification . The expert system  may include a plurality of experts. The expert system  may include one or more experts for each of the measurement device types shown in , in addition to various other experts, including routing experts, streaming experts, and synchronization experts, among others","In one embodiment, the run-time specification  may similarly comprise software objects or data structures, such as C++ objects, which may specify the run-time parameters for software and\/or hardware used to implement the specified measurement task. The run-time specification  may comprise parameter specifications for one or more measurement primitives  which correspond to rudimentary measurement tasks or operations. Said another way, the run-time specification  may comprise a collection of primitive settings, each of which may comprise a detailed and unambiguous \u201crecipe\u201d for a primitive. For example, primitive settings for a digitizer, such as a National Instruments E-Series\u2122 digitizer, may include: Dither (Yes, No), Polarity (Bi-polar, Uni-polar), Gain, Mode (Calibration, Differential, Non-Referenced Single-Ended, Referenced Single-Ended, Auxillary, Ghost), Generate Trigger (Yes, No), and Last Channel (Yes, No). (The term E-Series, used throughout this application, is a trademark of National Instruments Corporation.)","The run-time specification  may in turn be interpreted by the run-time builder  to generate a run-time , which may be executable to perform the specified measurement task. More details of the operation of the measurement driver program are presented below with reference to the description of FIG. .","FIG. \u2014Method for Performing a Measurement Task",{"@attributes":{"id":"P-00163","num":"00163"},"figref":["FIG. 5","FIG. 5","FIG. 5","FIG. 5"]},"As shown, in step  a user may optionally install measurement hardware within the system. This may comprise connecting a measurement device to the computer system or installing a measurement card or board within a slot of the computer system. This may further comprise installing a measurement card or board in a slot of a chassis, such as a PXI chassis, which itself is coupled to the computer system and\/or which may contain a computer system comprised on a card within the chassis. In one embodiment, the measurement hardware may comprise a \u201creconfigurable measurement device\u201d which may be operable to be reconfigured \u201con the fly\u201d during a measurement task or operation. For example, the reconfigurable measurement device may include a processor and memory or an FPGA that may be reconfigured with different measurement programs or tasks.","In step  the computer system and\/or the user may optionally configure the measurement hardware device(s). This may involve operation of standard Plug & Play software to recognize the measurement device and select setting or parameters for the device. It should be noted that in many instances, the user may not be required to perform  and\/or  before generating the measurement task. In other words, the measurement hardware may already be installed and configured and the user may proceed with the configuration and specification of the measurement task in step .","In step  the user may invoke the measurement task specifier  to configure a desired task in the measurement driver , thereby producing a measurement task specification . In the preferred embodiment, the measurement task specifier  includes an interactive Graphical User Interface (GUI) configuration tool which enables the user to easily and simply configure a desired measurement task. This may involve selecting various parameters of the task such as the type of measurement being performed using voltage, current, etc., and other measurement settings. In the preferred embodiment, the measurement task specifier  also includes an Application Programming Interface (API) which also enables the user to configure a desired measurement task.","In one embodiment, once the task has been specified, the user may add specification objects, modules, or code, specifying start, read\/write, and\/or cleanup operations to the task specification. In one embodiment, once the task has been specified, the user may request the task specifier  to generate code. The task specifier may then programmatically generate code specifying start, read\/write, and cleanup operations, among others. In various embodiments, this generated code may comprise icons in a LabVIEW graphical program (i.e., VIs), and\/or function calls in a text-based program including one or more of C code, C++ code, C# code, Java code, Visual Basic code, or any other form of computer program code, which may specify support operations needed to implement the specified measurement task. In one embodiment, the generated code may comprise icons representing some or all of the specified measurement task operations, including clocking and trigger operations, among others. In one embodiment, the task specifier  may generate the icons and connect them together appropriately. In another embodiment, the task specifier  may generate the icons, but the user may be required to link the icons appropriately. Thus, in one embodiment, the method may include generating a measurement task diagram in response to user input specifying the measurement task. In one embodiment, the measurement task diagram may comprise a graphical program, such as a LabVIEW graphical program.","In another embodiment, the user may specify the task manually. For example, the user may use a graphical programming development environment such as LabVIEW to place one or more icons or nodes on the display and connect them in a desired way to accomplish the desired result. In one embodiment, the user may select a small number of function icons or nodes, such as a measurement read node or measurement write node, to accomplish the configured measurement task. As another example, the user may use the Measurement Studio programming development environment from National Instruments Corporation (e.g., LabWindows\/CVI) to create a text-based program to accomplish the measurement task. This text-based program would typically comprise very few lines of code. Thus, complex measurement procedures may be encapsulated and represented by simple icons or function calls, allowing the user to rapidly and easily create measurement \u201cprograms\u201d to implement or carry out complex measurement operations.","In one embodiment, the measurement task specifier  may comprise a measurement task wizard. In other words, the measurement task specifier  may be a software program which leads the user through a measurement task specification process, thereby generating the measurement task specification . In another embodiment, the measurement task specifier  may comprise a measurement task configuration tool. The measurement task configuration tool may be a software program invocable by the user within a development environment, such as National Instruments' LabVIEW environment, Measurement Studio programming development environment, or any other development environment. In yet another embodiment, the measurement task specifier  may be an API through which the user makes calls to generate the task specification. The measurement task specifier  may thus generate the measurement task specification  in response to user input.","For example, in the case that the measurement task specifier  is invoked by the user from the LabVIEW graphical development environment, the user may specify or configure a measurement task by placing or \u201cdropping\u201d nodes or icons on a graphical diagram and connecting the nodes via virtual \u201cwires\u201d to generate a graphical diagram or model of the measurement task. The graphical development environment program (e.g., LabVIEW) may generate software objects or data structures corresponding to the components of the graphical diagram which specify the measurement task. These data structures may comprise the measurement task specification . In one embodiment, at this stage the measurement task specification  is not executable per se, but provides information which may be used by other components of the system to generate a measurement application suitable to carry out the measurement task, i.e., to implement the specified measurement operation.","As another example, consider the case where the measurement task specifier  is an API in a text-based development environment, such as Microsoft Corporation's Visual C++ development environment. In this embodiment, the user may make API function calls in a C++ application program to specify the various attributes or aspects of the desired measurement task, such as measurement type (voltage, current, pressure, etc.), timing or sampling parameters, or other measurement task specification information. The executed functions may produce corresponding data structures which contain specification information for the measurement task. As mentioned above, the measurement task specification  may itself not be executable, but may provide information which may be used by other components of the system to generate a measurement application to implement the specified measurement task. Thus, when the application program  is executed, the API function calls may generate the measurement task specification , which may then be used later in the execution process to produce the run-time specification, as described below.","In step  an expert system comprised in the measurement driver may operate to receive the measurement task specification , then analyze the measurement task specification , validate the measurement task specification , and create a run-time specification based on the measurement task specification . The run-time specification preferably comprises parameter settings for one or more measurement devices and other hardware comprised within the system, and may also specify software components or software programs which are to be used during execution of the task. In one embodiment, the run-time specification may comprise a specification of the parameters of one or more measurement primitives, where each measurement primitive comprises a software object and corresponding configuration settings, and where each measurement primitive is operable to implement at least a portion of the measurement task. Thus, the run-time specification may be useable to configure one or more measurement devices to perform the measurement task, and may be further useable to generate a run-time which is executable to perform the measurement task using the configured one or more measurement devices. The measurement driver  may include expert system  comprising the plurality of experts  where one or more experts  are available for each of the various types of measurement tasks or sub-tasks. Thus, depending upon the type of measurement task configured by the user in step , one or more corresponding experts  may be invoked to create the run-time specification. In one embodiment, multiple experts may each produce a candidate run-time specification. Thus, the measurement task specification  may be used in step  to ensure that the measurement task can operate as configured by the user.","In one embodiment, one or more of the generated measurement task specification , the generated run-time specification, and configuration information for the one or more measurement devices may be stored, such as in a memory medium, e.g., a computer system's RAM or persistent storage medium.","In one embodiment, the run-time builder may analyze the selected run-time specification, and then reserve one or more resources, such as hardware and\/or software, according to the selected run-time specification. The run-time builder may also unreserve resources if the analysis of the selected run-time specification indicates that previously reserved resources are no longer needed to implement the measurement task. In another embodiment, the run-time builder may handle abnormal process termination and\/or unexpected device removal.","In step  a run-time may be created which embodies or implements the measurement task configured in step  based on the generated (and\/or selected) run-time specification. In one embodiment, the run-time may comprise a collection of measurement operation primitives (or instances of measurement operation primitives) sequenced together which are executable to implement the measurement task.","When the user (or software program) enters input to execute or run the program, the measurement driver  may invoke the run-time builder program. The run-time builder program operates to access the run-time specification and use the parameters and data contained in the run-time specification to assist in creating the run-time at run time. In one embodiment, the run-time builder uses the run-time specification to instantiate instances of various objects or primitives comprised in the measurement driver . After the run-time builder instantiates various instances of objects, the run-time builder may apply various parameters from the run-time specification to these object instances. The run-time builder may also provide various parameters to hardware and\/or software resources or devices comprised in the system to configure the hardware and\/or software devices in the system according to the run-time specification to allow these devices to be used during execution of the run-time. In other words, the run-time builder may configure one or more measurement devices according to the run-time specification. After the run-time builder has completed creating the run-time, the run-time may then be executable to perform the task specified by the user.","After step  the user (or a software program) may execute the run-time to perform the measurement task. In other words, the run-time execution may invoke the various configured hardware and\/or software components to perform the specified measurement task.","Examples of Measurement Problems","Below are listed several example problems suitable for solution by various embodiments of the present invention. It should be noted that these solutions are for example purposes only, and are not intended to limit the domains of application of the present invention.","1. Point of Sale Configuration: Given all the hardware and software in the National Instruments catalog and a single computer, determine a set of hardware, hardware connections, hardware settings, and software configuration that can maintain a level in a tank (whose simulated linear model is specified to be M) by monitoring the present value of the tank level and controlling a valve connected to the tank. The solution should display the tank level and valve position on an HMI. Constraints include cost <$10000 and standard deviation of the tank level <D. Preference is for the lowest cost solution.","2. Out of the Box Configuration: Given 2 thermocouples, a National Instruments SCXI 1102 module, a National Instruments SCXI-1000 chassis, a National Instruments PCI-MIO-XE-50, and a set of appropriate terminal blocks cabling, determine the hardware connections (in the form of a wiring diagram), hardware settings, and software configuration for monitoring the two temperature values at a rate of 10 Hz each, with an accuracy=A and precision=P for each temperature measurement.","3. Run-time Configuration: Given a high-frequency switch connected to three 2-channel scopes, determine the hardware settings and software configuration for measuring the waveform, overshoot, and rise time of a set of five simultaneous 10 MHz digital clock signals connected to the switch. The accuracy and precision of the measurements must meet certain requirements, and all 5 measurements should be synchronized to a start event which is triggered by a high level of the first digital clock. (The solution should take into account the signal delays from various routings through the switch).","In various embodiments, the present invention may include some or all of the following features:","1. Interactive design\u2014the user may not have to specify a complete specification up front. Instead, the system may ask the user for more information as needed. For instance, while the system is building a solution, it may encounter one or more possibilities and may ask the user to specify new preferences at that point.","2. Graphical and visual display of system specifications and realizations (including text-based displays where appropriate)\u2014The system may display realizations so that they can be edited directly.","3. Extensibility\u2014ability to add new measurement methods\/drivers to the system and use those methods in a derived realization as the system evolves over time to include more domains. The user is able to participate in this process by adding custom measurement methods. The system may be extended with new measurement methods\/drivers in multiple independent efforts (i.e. with independent releases). Groups of extensions may be packaged with different products and installed separately.","4. Visibility\u2014ability for the user to see solutions generated by the system and extend and modify those solutions.","5. Robustness\u2014ability to detect and help correct invalid specifications and invalid realizations.","The features mentioned above may allow the user to specify and execute a measurement task in substantially less time and with substantially less effort than previous methods. In addition, the system described may prevent the user from implementing a measurement solution which is inappropriate for the available resources. Further details of the system design and architecture are described below with reference to , A-D, and A-D.","FIG. \u2014High-Level Architecture",{"@attributes":{"id":"P-00191","num":"00191"},"figref":["FIG. 6","FIG. 6","FIG. 6","FIGS. 7A-D"],"b":["700","710","730","730","740","750","770","780","790","8"]},"FIGS. A-D\u2014Static Diagrams of the System",{"@attributes":{"id":"P-00193","num":"00193"},"figref":["FIGS. 7A-D","FIGS. 7A-7D"],"b":"9"},"FIG. A\u2014System for System Configuration and Task Specification",{"@attributes":{"id":"P-00195","num":"00195"},"figref":["FIG. 7A","FIG. 7A"],"b":["700","710","730","740","700","702","704","700","702"]},"As  also shows, once the user has specified a system configuration, the specified system configuration may be stored in system configuration storage . The system configuration storage  may be operable to store a measurements system configuration , as well as an MIO system configuration . In one embodiment, the MIO system configuration  may operate to extend the measurements system configuration . As may be seen, both the measurements system configuration  and the MIO system configuration  may be stored in MAX storage (MXS) .","In one embodiment, interactive and application programming interfaces (IAPIs)  may be used to access various objects and functions of the system. These interfaces may provide mechanisms through which the user, other system components, or other systems, may specify a measurement task. As  shows, the IAPIs  may include a measurements configuration tool  and MIO configuration tool plug-in , which may be operable to extend the measurements configuration tool . In one embodiment, the system configuration information stored in system configuration storage  may be retrieved via the measurements configuration tool .","The IAPIs may further include measurements APIs for various development environments or languages, such as a measurements API for LabVIEW  and MIO extensions to measurements API for LabVIEW , which may be operable to extend the measurements API for LabVIEW ; a measurements API for C  and MIO extensions to measurements API for C , which may be operable to extend the measurements API for C ; a measurements API for Measurement Studio Tools for Visual C++  and MIO extensions to measurements API for Measurement Studio Tools for Visual C++ , which may be operable to extend the measurements API for Measurement Studio Tools for Visual C++ ; and a measurements API for Measurement Studio Tools for Visual Basic  and MIO extensions to measurements API for Measurement Studio Tools for Visual Basic , which may be operable to extend the measurements API for Measurement Studio Tools for Visual Basic . It should be noted that in other embodiments, other interfaces or APIs may be included for other development environments and\/or programming languages.","As  further shows, a task specification  may be generated via the IAPIs . The task specification  may include measurements-wide measurements specification objects (MSOs)  and MIO MSOs , which may be operable to extend the measurements MSOs . Note that both the measurements MSOs  and the MIO MSOs  may be stored in the MXS .","Thus, the system components described above may allow the user to configure the system, as well as to generate a measurement task specification . It should be noted that the system configuration tools , system configuration storage , interactive and application programming interfaces , and task specification  components correspond to a Unverified State  of the system, as described with reference to the state diagram of  below.","FIG. B\u2014System for Compiling a Task Specification to a Task Run-Time Specification",{"@attributes":{"id":"P-00202","num":"00202"},"figref":["FIG. 7B","FIG. 7B","FIG. 7A"],"b":["740","710","750","760","770"]},"In one embodiment, the expert system  may be operable to retrieve system configuration information from the system configuration storage  to make decisions regarding the measurement task specification . The expert system  may be further operable to compile the task specification  to produce the task run-time specification , as shown. As  also shows, the expert system  may refer to the expert registration storage for matching experts to the task specification . In one embodiment, the expert system  may include measurements run-time experts , measurements streaming experts , MIO experts , routing experts , and a measurements expert library . Further examples of experts include sensor experts, smart sensor experts, scaling experts, and system calibration experts, among others. In general, an expert may be defined and used for any device or function. For example, a scaling expert may be operable to make changes to the run-time specification to specify or implement custom scaling operations for a measurement channel. In one embodiment, each of the experts may be operable to register with the measurements expert library  to indicate availability to the system. Further details of the expert system and its use are presented below with reference to  and -, below.","As  shows, the expert registration storage  may include registration components which correspond to each of the experts included in the expert system . For example, the expert registration storage  may include components for MIO expert registrations , measurements run-time expert registrations , routing expert registration , and measurements streaming expert registrations . It should be noted that the expert system  and the expert registration storage  may also respectively use and store other experts and other expert registrations as needed. As shown, each expert registration may be stored in MXS .","As mentioned above, the expert system  may produce the task run-time specification based on the task specification , the system configuration information stored in the system configuration storage , and the various experts comprised in the expert system . In one embodiment, the task run-time specification  may include various primitive settings specified by one or more of the above-mentioned experts. For example, the settings may include measurements run-time primitive settings , measurements streaming primitive settings , routing primitive settings , and MIO primitive settings . The primitive settings may each be stored in MXS , as shown.","Note that when the measurement task specification does not specify any product-specific properties, i.e., any properties or specifications particular to a given device or product, then the measurement task specification may be compiled to various different measurement systems without modification. In other words, to the extent that the measurement task specification is generic, it is also portable, and thus a single measurement task specification may be used or compiled for multiple measurement systems.","It should be noted that the task specification  and the system configuration storage , described above with reference to , as well as the expert system , expert registration storage , and task run-time specification  correspond to a Verified State  in the state diagram of  below.","FIG. C\u2014System for Building a Task Run-Time From a Task Run-Time Specification",{"@attributes":{"id":"P-00209","num":"00209"},"figref":["FIG. 7C","FIG. 7C","FIG. 7B"],"b":["770","780","790","780","712","790"]},"In one embodiment, the run-time builder  may include a measurements run-time builder  which may be operable to create primitive supervisors for each primitive setting in the run-time specification , such as measurements run-time primitive supervisors , MIO primitive supervisors , measurements streaming primitive supervisors , and routing primitive supervisors . As  shows, these primitives and supervisors may be included in the task run-time , described below.","In one embodiment, the task run-time  may include a measurements run-time  which may manage routing primitives and supervisors , MIO primitives and supervisors , measurements streaming primitives and supervisors , and measurements run-time primitives and supervisors . The task run-time  may be operable to be executed by the system to implement the specified measurement task, as described below with reference to FIG. D.","It should be noted that the task run-time specification , described above with reference to , the run-time builder , and task run-time  correspond to a Constructed State  of the system, as described with reference to the state diagram of  below.","FIG. D\u2014System for Executing Tasks",{"@attributes":{"id":"P-00214","num":"00214"},"figref":["FIG. 7D","FIG. 7D","FIG. 7C","FIG. 7D"],"b":["790","7","730","790","730","798","790"]},"It should be noted that the task run-time , described above with reference to , as well as the interactive and application programming interfaces (IAPIs), described above with reference to  correspond to a Reserved State , a Committed State , and a Running State  of the system, as described with reference to the state diagram of  below.","FIGS. A-D\u2014Framework Software Package Diagrams",{"@attributes":{"id":"P-00217","num":"00217"},"figref":["FIGS. 8A-D","FIGS. 8A-D","FIGS. 7A-D"]},"FIG. A\u2014Packages for System Configuration and Task Specification",{"@attributes":{"id":"P-00219","num":"00219"},"figref":["FIG. 8A","FIG. 8A","FIG. 7A"],"b":["810","700","812","814","800","740","710","820","730"]},"As  shows, the data dictionaries package  may include a measurements MSO data dictionary package , an MIO MSO data dictionary package , a measurements system configuration data dictionary package , and an MIO system configuration data dictionary package , all of which may be stored in the MXS package . Each data dictionary may include information or meta-data describing the data related to measurements system configuration data, MIO system configuration data, measurements MSO data, and MIO MSO data.","As further shown in , the API libraries package  may include a plurality of libraries which comprise the various APIs described above with reference to  above. Specifically, the API libraries package  may include a measurements API for LabVIEW library package  and an MIO extensions to measurements API for LabVIEW library package , which may be operable to extend the measurements API for LabVIEW library package ; a measurements API for C package  and MIO extensions to measurements API for C library package , which may be operable to extend the measurements API for C package ; a measurements API for Measurement Studio Tools for Visual C++ library package  and MIO extensions to measurements API for Measurement Studio Tools for Visual C++ library package , which may be operable to extend the measurements API for Measurement Studio Tools for Visual C++ package ; and a measurements API for Measurement Studio Tools for Visual Basic library package  and MIO extensions to measurements API for Measurement Studio Tools for Visual Basic library package , which may be operable to extend the measurements API for Measurement Studio Tools for Visual Basic library package . It should be noted that in other embodiments, other interfaces or API libraries may be included for other development environments and\/or programming languages.","FIG. B\u2014Packages for Compiling a Task Specification to a Task Run-Time Specification",{"@attributes":{"id":"P-00223","num":"00223"},"figref":["FIG. 8B","FIG. 8B"],"b":["830","840","850"]},"In one embodiment, the measurements system data dictionaries package  may include the components of the data dictionaries package  described above with reference to , as well as an expert registration data dictionary package , a measurements run-time primitive settings data dictionary package , a measurements streaming primitive settings data dictionary package , a routine primitive settings data dictionary package , and an MIO primitive settings data dictionary package . As mentioned above, each data dictionary may contain information or meta-data describing the data related to a particular system component. In the preferred embodiment, all of the expert system data dictionaries are stored in the MXS package , as shown.","As  shows, the expert system package  may include library packages corresponding to the various experts described above with reference to FIG. B. Specifically, the expert system package  may include a measurements expert library package , a routing expert library package , an MIO expert library package , a measurements streaming expert library package , an a measurements run-time expert library package , as shown.","As also shown in , the user-mode run-time system package  may include library packages corresponding respectively to each of the sets of primitives composed in the run-time package , the components of which are described above with reference to . Specifically, the user-mode run-time system package  may include a measurements run-time library package , a routing run-time library package  which may include all related primitive settings and user-mode primitive supervisors, a measurements streaming run-time library package , and an MIO run-time library package  which may include all related primitive settings packages and user-mode primitive supervisor packages.","FIG. C\u2014Packages for Building a Task Run-Time From a Task Run-Time Specification",{"@attributes":{"id":"P-00228","num":"00228"},"figref":["FIG. 8C","FIG. 8C"],"b":["860","880"]},"In one embodiment, the primitive settings data dictionaries package  may also include the primitive settings data dictionary packages described above with reference to the expert system data dictionaries package  of FIG. B. Specifically, the primitive settings data dictionaries package  may include the measurements run-time primitive settings data dictionary package , the measurements streaming primitive settings data dictionary package , the routine primitive settings data dictionary package , and the MIO primitive settings data dictionary package , all of which may be stored in the MXS . As mentioned before, each of the primitive settings library component packages may be a user-mode component, as indicated.","In one embodiment, the user- and kernel-mode run-time system package  may include the run-time library component packages of the user-mode run-time system package  described above with reference to , specifically, the measurements run-time library package , the routing run-time library package  which may include related primitive settings packages and primitive supervisor packages, the measurements streaming run-time library package , and the MIO run-time library package  which may include all related primitive settings packages and primitive supervisor packages. The user- and kernel-mode run-time system package  may further include a measurements streaming library package , a routing driver (driver and primitives) package , and an MIO driver (driver and primitives) package . Note that the drivers and library component packages are all dual-mode component packages (UK), meaning that they may be used in either user-mode or kernel-mode.","FIG. D\u2014Packages for Executing a Task Run-Time",{"@attributes":{"id":"P-00232","num":"00232"},"figref":["FIG. 8D","FIG. 8D","FIG. 8C","FIG. 8D"],"b":["880","820","8","880","820"]},"FIG. \u2014State Diagram for Measurement Tasks",{"@attributes":{"id":"P-00234","num":"00234"},"figref":["FIG. 9","FIGS. 7A-D"],"b":"9"},"As  shows, in one embodiment, the first state of the task after creation is the Unverified state , corresponding to the task specification  static diagram of FIG. A. In the Unverified state , all properties of the task may be set.","The Verified state  corresponds to the state of the task at the end of the compiling task specification to run-time specification static diagram of FIG. B. More specifically, in the Verified state , the task may be represented by the run-time specification  of FIG. B. As may be seen, the task enters the Verified state  as a result of verification of the measurement task specification  by the expert system . This verification may also be invoked indirectly by a get operation. In order to modify the properties of the task, a transition back to the Specified state  may be necessary.","The Constructed state  corresponds to the state of the task at the end of the building run-time from run-time specification static diagram of , and results from the build process of the run-time builder . The Reserved state , Committed state , and Running state  correspond to the state of the task during the executing task static diagram of FIG. D. In the Running state , a subset of properties may be accessed by modifying the primitives directly (via set\/get operations) while the measurement hardware is running. As mentioned above, the execution of the run-time  may be controlled through one or more of the APIs , such as via read, write, set, get, start, stop, commit, uncommit, reserve, and unreserve commands or function calls.","It should be noted that state transitions may occur implicitly. For example, if the start action is invoked when the task is in the Constructed state , the task may transition through the Reserved  and Committed  states implicitly when transitioning to the Running state . The implicit state transitions may also be symmetric. In this example, if the stop action is invoked, the task may transition through the Committed  and Reserved  states implicitly when transitioning back to the Constructed state .","FIGS. -\u2014Measurement Task Configuration Tool","As mentioned above, the measurement task specifier  may be implemented in a variety of forms, including an API, a wizard, or a measurement task configuration tool, among others. In a measurement task configuration tool embodiment, the measurement task specifier  may comprise a software program invocable by the user under a development environment. The measurement task configuration tool may comprise an interactive Graphical User Interface (GUI) which may provide an intuitive and powerful way for a user to specify a measurement task.  illustrate various embodiments of the measurement task configuration tool, as described below.","FIG. \u2014Measurement Task Configuration Tool Architecture","In one embodiment, the measurement task configuration tool may be implemented in a graphical programming language, such as National Instruments' LabVIEW graphical programming environment. The GUI of the configuration tool may be a Virtual Instrument (VI) accessed by the user to specify and configure measurement tasks.",{"@attributes":{"id":"P-00243","num":"00243"},"figref":"FIG. 10","b":"1002"},"For example, in one embodiment, the configuration tool (hosted by the Workshops framework) may run stand-alone, launched directly from an ADE, or may be hosted in another application, such as National Instruments' MAX program.","In one embodiment, there may be two parts to the plug-in architecture: plugging-in to Workshops, and plugging-in to a configuration tool framework.","Workshop Plug-In Architecture","In one embodiment, the configuration tool may be written entirely in National Instruments' LabVIEW graphical programming language. Hosting a Virtual Instrument (VI) from the Workshops framework may utilize some or all of the following:","1) A Main State VI  that maintains execution, which is preferably not visible to users.","2) A GUI VI through which a user may configure their task.","3) A Block .INI File  specifying the directory paths of the VI's, block names, help file, etc. .","4) A Block Icon  for the GUI application.","In one embodiment, each .INI file specification may automatically appear as a \u201cblock\u201d in an \u201cAdd\u201d popup palette of the workshops framework (). Clicking on this block may launch a corresponding GUI VI and add an icon and text to a ring control, shown in , as described below.","In one embodiment, the Workshops framework may support \u201cUndo\u201d, \u201cRedo\u201d, and full-state \u201cRestore\u201d commands by automatically copying appropriate controls from the GUI to the State VI, and then storing\/restoring this data. A block VI may be programmed to respond to these events and freely exchange its data to\/from the workshop in order to support these features.","Measurement Task Configuration Tool Plug-In Architecture","To maximize extensibility and development ease of use, and to minimize disk footprint, there may be a single Main Template VI  that dynamically displays only the measurement type\/phenomenon that is being configured. For example, if a user is configuring a voltage measurement, the VI may only display the configuration components necessary for a voltage measurement (See FIG. ). Likewise, the user may add a temperature measurement, and with the exact same VI, configure a temperature measurement. This architecture may greatly shorten development time, since all measurement blocks may share a common interface. Thus, changes to the GUI may need only be made in one location.","In one embodiment, each measurement class component (the piece of the UI that is specific to the measurement type being configured) may be a separate VI, referred to as a Measurement Class VI  that may be dynamically loaded by the main GUI template. A \u201cmeasurement class\u201d ID may be passed to this VI by the Workshop, which tells it what measurement class component VI to load based on which button was selected from the popup palette. Each Measurement Class VI  may be a small state-model VI used for processing events unique to its own front panel, and may have a number of built-in system events for communication to\/from the Main Template VI  for such operations as initialization and data processing. The remainder of events may be user-instantiated events which tell the VI how to act when a user changes a control on the front panel, for example.","FIG. \u2014Measurement Task Configuration Tool Screen: Measurement Setup",{"@attributes":{"id":"P-00258","num":"00258"},"figref":["FIG. 11","FIG. 11"],"b":["1008","11"]},"In one embodiment, the interface may further include tabbed controls for configuring other aspects of the measurement setup, such as \u201cChannels\u201d, \u201cSettings\u201d (as shown selected in FIG. ), and \u201cDetails\u201d, each of which is described below with reference to . Finally, in one embodiment, the interface may also include an \u201cAdvanced\u201d configuration tab control, described below with reference to FIG. .","FIGS. A-D\u2014Measurement Task Configuration Tool Screen: Measurement Blocks","In one embodiment, the configuration tool interface may include an \u201cAdd\u201d button (see ) with corresponding popup palette indicating the various types of measurement the user may configure, such as voltage, temperature, resistance, frequency, and angular displacement, among others, as shown in FIG. A. In one embodiment, the user may select or click a particular block to activate the configuration panels for that type of measurement.","In one embodiment, the configuration tool interface may include a ring control, shown in  adjacent to the \u201cAdd . . . \u201d. menu item. Each icon and text in the ring control represent a configured group of channels corresponding to one measurement type, such as voltage, temperature, frequency, etc. It should be noted that each time a measurement block is selected from the \u201cAdd\u201d popup palette indicating a new measurement group, e.g., a group of voltage measurements, an icon and text may be added to the ring control. The channels in each measurement group may be subject to the specified parameters shown in the panel for that group, such as timing, triggering, etc. If a user specifies multiple voltage measurement groups, then the icon for that measurement type (block) may appear multiple times in the ring control. In one embodiment, when a user selects (clicks) an icon in the ring control, the configuration tool may present one or more panels corresponding to that measurement group, thereby allowing the user to quickly access any measurement group specification for review, revision, replication, or deletion.",{"@attributes":{"id":"P-00263","num":"00263"},"figref":"FIG. 12B"},{"@attributes":{"id":"P-00264","num":"00264"},"figref":["FIG. 12C","FIG. 12C"]},{"@attributes":{"id":"P-00265","num":"00265"},"figref":["FIG. 12D","FIG. 12D"]},"Adding a Block to the Measurement Task Configuration Tool","In one embodiment, when a developer wants to add a new block type that a user can click to configure something, there may be very little work that needs to be done, with little or no duplication of any prior work. For example, to add a CDMA type measurement to the configurator, a block referred to as \u201cCDMA_Test\u201d may be added to the configurator by the following steps:","1) Place a CDMA_Test (.INI format) file (e.g., Block .INI File ) in the appropriate Workshops directory, containing links to the appropriate VI's, icon file, and names, creating the block that a user can now click on from the \u201cAdd\u201d popup palette.","2) Make a block icon (e.g., Block Icon  comprising 1024 pixels) and place it in the \\CDMA_Test directory. This icon will appear in the ring control when a CDMA_Test block is inserted.","3) Using a pre-configured template VI (e.g., ), add controls that a majority of users will need to configure a CDMA type measurement. Save this as CDMA_Test.vi and place it in the \\CDMA_Test directory.","In addition to the Main Template VI , the Workshop may also load a timing configuration VI, described below, as well as one or more advanced configuration VI's, described below with reference to , as needed by the measurement block. All of these VIs may be specified in the .INI file. With the exception of the timing VI, which may be on the same front panel as the Main Template VI , any other VI's may show up as separate tabs at the bottom of the window. In the preferred embodiment, a majority of users should be able to configure their application from a single page without having to navigate through multiple tabular pages. In other words, default values may be provided for parameters which would otherwise require use of the advanced or auxiliary VIs.","User Interaction Requirements","In one embodiment, the configuration tool may allow the user to easily configure almost any number of channels. Default names may be created wherever possible, so minimal user effort is required. In one embodiment, users may begin their configuration tool experience with an HTML help welcome screen in the main window, containing items such as \u201cwhat is the measurement configuration tool?\u201d and \u201cwhere do I get started?\u201d, etc. From there the user may be instructed to tell the configuration tool about the desired application. The user may start by clicking the \u201cAdd\u201d button and selecting one of the measurement\/phenomenon type blocks from the popup palette. This then loads the corresponding components as outlined earlier. From here on, interactive help windows in the right-hand pane may guide the user through building the task. The first step may be to add channels to the task, by selecting the hardware terminals from which measurements are to be made in the \u201cSelection List\u201d. This process may create channels for those hardware terminals and give them default names. Upon adding one or more channels to the Task, the user may be auto-advanced to the \u201cSettings\u201d tab for configuration of these channels.","From here the user may close the configuration tool, in which case the user may be prompted to accept the changes made, or cancel. Alternately, the user may continue, configuring measurement specific settings for their application, for example, using the Input Range and Sensors options shown in FIG. . In one embodiment, clicking the \u201cDetails\u201d tab may allow the user to change the name of a channel or the HW terminal to which it's associated.","In one embodiment, below this main window is the timing configuration VI, shown in  titled \u201cTiming Setup\u201d, through which the timing for this task may be configured. In one embodiment, the timing VI may allow the user to specify sampling parameters, such as number of samples and sample rate, among others. The timing parameters specified here may be common to all measurements in the list.","FIG. \u2014Measurement Task Configuration Tool Screen: Advanced Configuration","As mentioned above, in addition to the two main views (measurement setup and timing configuration), each measurement group may have additional views that may be activated by tabs at the bottom of the display. These tabs may be tied to the current group of channels and may change when a different icon is selected in the ring control. In the case of voltage measurements, shown in , there may be an \u201cAdvanced Configuration\u201d tab. Selecting the tab may activate an advanced configuration panel, as shown in FIG. . Here more advanced settings that apply to the current \u201cVoltage\u201d group may be configured. As  shows, such settings may include triggering, advanced timing, and measurement data operations, among others.","In one embodiment, a measurement data section may allow the user to specify return data type (scaled\/binary), and logging to disk, among others. In another embodiment, the user may specify a URL (Universal Resource Location) to which measurement data may be posted.","In one embodiment, a measurement triggering section may allow the user to specify start, stop, and pause trigger operations, such as trigger type (e.g., analog\/digital), trigger condition (e.g., rising edge), trigger source, and level.","The number of tabs and their content may be specified in the same .INI file for each measurement\/generation block. An \u201cAdvanced Device\u201d configuration tab may also be provided for those boards with extended functionality. This tab would preferably appear automatically when a terminal from one of these type boards is added to the task.","Code Generation","In one embodiment, users may have the ability to generate different levels of code, as well as code for different programming languages from the configuration tool. In one embodiment the configuration tool may be operable to detect from where (i.e., which ADE) it was launched, and to set a default ADE type indicating the type of code to generate.","In the preferred embodiment, there may be three levels of code generation:","1) a single icon or function whose activation causes the execution of the entire measurement application,","2) multiple intermediate icons or functions that use the task as defined and stored (e.g., in MAX), but perform operators on this task (e.g., Configure, Start, Read, and Clear), and","3) low-level code showing what would be required to build this code completely from scratch, having never run the configuration tool.","Exiting, Saving, and Persisting","In the preferred embodiment, a user is not prompted to save or name anything until they exit the configuration tool. Upon exiting, if a new task has been configured, then the user may be prompted to give the task a unique name. If the user was modifying an existing task, then the user may be prompted to save the changes made, or to discard them. The task and all measurements may then be persisted to storage (e.g., MXS) as MSOs ready for execution by any ADE based API.","ADE and Measurement Task Configuration Tool Interaction","In some ADEs, (e.g., LabVIEW\u2122 and LabVIEW Express\u2122), the configuration tool may be represented as a top-level, distinguishable icon in the Data Acquisition palette (The term LabVIEW Express, used throughout this application, is a trademark of National Instruments Corporation.). When dropped on the diagram, the configuration tool may immediately launch, according to one embodiment. Double-clicking the icon later may launch and restore the configuration tool to its last saved state. In other ADEs, (e.g., Measurement Studio) the configuration tool may be launched from a menu item, or a function panel where the task is defined.","Thus, the task configuration tool interface may provide a simple means for the user to create and\/or modify a specified measurement task. It is noted that the configuration tool and interface described herein is but one example of a measurement task specifier, and is not intended to limit the measurement task specifier to any particular form or implementation.","Expert System Embodiment #1",{"@attributes":{"id":"P-00293","num":"00293"},"figref":"FIGS. 14-25","b":"750"},"In one embodiment, the measurement program specification may be a run-time specification, as described above. In one embodiment, the expert system  may include a plurality of measurement expert software programs, where the plurality of measurement expert software programs include the first software program, mentioned above.","FIG. \u2014Generation of the Run-Time Specification With the Expert System",{"@attributes":{"id":"P-00296","num":"00296"},"figref":"FIG. 14","b":["740","750","750","1410","1420","1430","1440"]},"In one embodiment, the expert system may include a plurality of experts including device experts, channel experts, timing experts, reader\/writer experts, control experts, and streaming experts, sensor experts, smart sensor experts, scaling experts, and system calibration experts, among others. As mentioned above, in general, an expert may be defined and used for any device or function. Each class of expert may be responsible for managing different aspects of the measurement task specification. In performing the above mentioned four phases, the expert system may be operable to create a device expert call tree of associated experts according to the configuration specified by the user (i.e., a user-specified measurement task configuration), manage the configuration of a measurement task specification by a measurement task specifier, and verify the measurement task specification and compile the measurement task specification into a run-time specification. Each of these steps is described in more detail below.","The system configuration phase  may be performed or utilized by the expert system  whenever named channels are specified, either by a user via a system configuration tool , automatically at installation-time for a detected device, or programmatically by a user with an interactive or application programming interface . In one embodiment, a primary function of the system configuration phase  is to perform system configuration of one or more channels for the measurement task, i.e., to configure named channels with fully qualified channel paths and channel MSO mementos.","Named channels may be specified by a user with a measurement task specifier or may be automatically specified by a system configuration tool based on the installed measurement devices. The configuration of these named channels may produce fully qualified channel paths and associated channel measurement specification object (MSO) mementos associated with these named channels.","In one embodiment, performing system configuration of channels may include configuring the one or more channels with fully qualified channel paths specifying one or more of a terminal configuration, an expert associated with the terminal configuration, and capabilities of the expert, and setting one or more attributes for the one or more channels based upon installed measurement devices. For example, fully qualified channel paths may comprise a series of expert configurations corresponding to the complete topography for a particular channel. Each expert configuration may specify one or more of a terminal configuration, the expert associated with that terminal configuration, and a reference to the capabilities of that expert, as well as any other appropriate parameters.","In one embodiment, channel MSO mementos may comprise serialized attributes of channel MSOs explicitly configured by a user through the measurement task specifier or by a system configuration tool based on the measurement devices installed in the system. Whenever a channel is added to a measurement task specification, the corresponding channel MSO mementos may be deserialized into the measurement task specification. This may allow users to configure default attributes for named channels that span all measurement tasks.","In one embodiment, the plurality of experts may comprise a plurality of device experts and a plurality of channel experts. Performing the task creation for the measurement task may include building the device expert call tree based on the channel configuration, where the device expert call tree comprises one or more of the plurality of device experts, and where the device expert call tree comprises one or more of the experts used to generate the run-time specification from the measurement task specification.","The task creation may also include initializing the one or more device experts with initialization information, where the initialization information for each device expert includes one or more of the device expert's parent and children in the device expert call tree, information indicating the state of the measurement task, and hardware capabilities of the device.","After the one or more device experts are initialized, one or more channel experts may be created for each of the one or more channels, where each device expert corresponds to at least a subset of the one or more channel experts, and where the subset of the one or more channel experts corresponds to the device expert.","Finally, the task creation may include restoring properties of the one or more channels and the measurement task specification from persistent storage.","Thus, in the task creation phase , the expert system  may create the device expert call tree based on the fully qualified channel paths , initialize the instances of the device experts , create instances of the channel experts for each of the named channels in the measurement task , and restore (set values from persistent storage) the properties of the channels based on the channel MSO mementos , as shown.","Thus, in one embodiment, the first step in the creation of a collection of associated experts according to the user-specified configuration may be the construction of the device expert call tree . The expert system  may begin the creation of the device expert call tree when the user initializes a new measurement task by providing a list of named channels. A device expert call tree may contain all the experts that will be used to compile a given measurement task specification into a run-time specification. The structure of the tree may determine the order in which the experts are called, as well as the interactions between the experts. The construction of a device expert call tree may be based on the fully qualified channel paths for each channel in the measurement task. Note that additional device experts, associated with channels that were not originally added to the measurement task, may be added after the construction of the device expert call tree. Thus, the expert system may create a device expert call tree of device experts according to the named channels that comprise the measurement task specification, i.e., according to the user-specified measurement task configuration.","In the preferred embodiment, the expert call tree is constructed in an in-order, top-down approach. In one embodiment, the general algorithm includes walking (traversing) the series of expert configurations for all of the channels simultaneously. At each point, a device expert instance may be created for each unique device expert identifier at that level in the fully qualified channel path. Note that if the expert identifier associated with the root entry of the fully qualified channel path is not the same for all named channels in the measurement task, than an expert will be inserted at the root of the expert call tree. This expert may then handle the synchronization between multiple measurement devices or multiple sub-systems on a single measurement device. Note that in the preferred embodiment, the device experts are instantiated while building the tree; they are only initialized when the device expert call tree is traversed for the first time.","After the device expert call tree is built, device experts for each node may be initialized with initialization information, as indicated in . Initialization information may include the device expert's parent and children in the device expert call tree, a reference to an object that maintains the state of the measurement task, and the hardware capabilities of the device which may be stored in a persistent memory medium, e.g., MXS.","Each device expert may understand or be associated with a specific set of channel experts designed for that device. Once device experts have been created and initialized, the expert system may create one or more channel experts for each of the one or more channels, i.e., for each specified named channel, as indicated in . The expert system may create channel experts by passing a fully qualified channel path to the leaf (terminal node in the tree structure) device expert in the call tree corresponding to the specific channel. Thus, each device expert may correspond to at least a subset of the one or more channel experts, and the (at least a) subset of the one or more channel experts may correspond to the device expert. When a device expert's create channel method is invoked, the device expert may first request that its parent device expert create a channel expert as well. The parent channel expert may be created using a version of the fully qualified channel path with the most derived terminal configuration truncated. This sequence may continue up the device expert call tree until all channel experts for a particular fully qualified channel path have been created. Each channel expert may retain a reference to the corresponding parent channel expert for use when the measurement task is configured.","As  shows, after the expert system creates channel experts for each channel, the corresponding channel MSO mementos may be deserialized from named channels which may be stored in MXS. Said another way, the properties of the one or more channels and the measurement task specification may be restored from persistent storage. The expert system may then query channel experts for channel MSOs, and apply the channel MSO mementos to them. This allows users to configure default attributes for named channels that span all tasks.","In the task configuration phase , the expert system  may manage the configuration of the measurement task specification. Configuration of the measurement task specification may include storage, verification, and coercion of attributes set through the measurement task specifier. Note that as used herein, the term \u201ccoercion\u201d may refer to the expert system modifying a value of an attribute in order to make the value of that attribute valid. For example, a user may specify a sampling rate of 999 Hz. However, due to the hardware architecture of the measurement device, the measurement device may not be able to sample at a rate of 999 Hz. It may, for example, only support incremental values such as 950 Hz, 1000 Hz, 1050 Hz, etc. In this example, the expert system may coerce the sampling rate to 1000 Hz. The measurement task specifier  may configure the properties of channels of the measurement task specification , as well as the timing properties of the measurement task specification . In other words, performing task configuration for the measurement task may include configuring one or more properties of the one or more channels, and configuring one or more timing properties of the measurement task specification. The configuration of these properties may occur in any order. A customer may use the measurement task specifier to configure the measurement task specification, however, the expert system may store, verify, and coerce the attributes set through the measurement task specifier.","Thus, after the expert system creates and initializes the device expert call tree, the user may configure the measurement task specification through the use of a measurement task specifier. The measurement task specifier may rely upon the expert system to manage this configuration of the measurement task specification. The expert system may manage the configuration of the measurement task specification whenever attributes of the measurement task are specified or queried. The specification of the measurement task may occur in any order. The measurement task specification may be modified after the measurement task specification has been verified and compiled. When this occurs, the measurement task specification may be efficiently re-verified and recompiled. Also, the measurement task specification may be modified while the measurement task is executing. When this occurs, the expert system directly and immediately may modify the primitives in the run-time to reflect the modification to the measurement task specification. Configuration of the measurement task specification preferably entails setting various attributes of the MSOs in the measurement task specification.","Root device experts may contain objects implementing specific timing expert interfaces. The expert system may be able to query for these timing experts through an interface. In one embodiment, this query may be done only from the root of device expert tree, with device experts deferring requests to children experts if they are unable to satisfy them. Timing experts may be queried and configured whenever specific timing or triggering attributes are configured. Measurement task specifiers may be able to use specific timing interfaces to configure these attributes.","Channel experts may be configured whenever a measurement task specifier executes a set or get operation on a channel MSO. The first time a set or get is specified for a particular channel MSO, the measurement task specifier may query the appropriate leaf channel expert for that MSO. If a particular channel expert is unable to satisfy that query, the request may be deferred to the channel expert's parent. Sets and gets may then be performed directly on the MSO itself. The measurement task specifier may maintain a cache of any MSOs that have been queried or modified, and so subsequent sets and gets may not require querying the channel expert. The MSO cache may also maintain information about whether each MSO was modified or only queried. During the storage of a measurement task, the measurement task specifier may examine this cache and only store those MSOs actually modified by the customer. This strategy may enable a maximum amount of portability for tasks by not serializing MSO attributes which were only queried, i.e., which were not modified.","In one embodiment, performing task verification for the measurement task includes invoking one or more device experts to analyze one or more channel properties of the measurement task specification, invoking the one or more device experts to analyze one or more timing properties of the measurement task specification, and compiling the measurement task specification to the run-time specification.","Thus, in one embodiment, in the task verification phase , the expert system  may verify and compile the measurement task specification into a run-time specification. The expert system  may first invoke each of the device experts in the device expert call tree to analyze the channel properties in the measurement task specification . In the preferred embodiment, this invocation occurs in a post-order (bottom-up) fashion. In other words, the expert system  may invoke one or more of the plurality of device experts starting at a corresponding leaf of the device expert call tree.","The expert system  may then invoke each of the device experts in the call tree to analyze the timing properties in the measurement task specification . In the preferred embodiment, this invocation occurs in a pre-order (top-down) fashion, i.e., the expert system  may invoke the one or more device experts starting at the root of the device expert call tree. Finally, the expert system  may invoke each of the device experts in the call tree to compile their associated portion of the measurement task specification into the run-time specification . This invocation also preferably occurs in a pre-order (top-down fashion). Said another way, compiling the measurement task specification to the run-time specification may include invoking each of the device experts in the device expert call tree to compile an associated portion of the measurement task specification into the run-time specification starting at the root of the device expert call tree. A more detailed description of the task verification phase  follows.","The expert system may verify the measurement task specification when, implicitly or explicitly, a measurement task specifier invokes a verify operation for a measurement task. In one embodiment, the verification and compilation of the measurement task specification may consist of three ordered steps, described below.","In one embodiment, the analyze channels step is the first step of the verification and compilation of the measurement task specification. In a post-order (bottom-up) traversal of the device expert call tree, all device experts may be instructed to analyze the properties of all contained channels. During this step, device experts may query channel MSOs from channel experts, analyze their attributes, and produce attributes of channel MSOs for corresponding parent channel experts. This is somewhat analogous to a function taking channel MSOs as inputs, performing some expert-specific transformation on the inputs, and generating channel MSOs as outputs.","In one embodiment, the second step of the verification and compilation of the measurement task specification is the analysis of timing properties. In a pre-order (top-down) traversal of the device expert call tree, all device experts may be instructed to analyze the properties of all contained timing. During this step, device experts may query timing MSOs from timing experts, analyze their attributes, and produce attributes of timing MSOs for corresponding children timing experts.","The final step of the verification and compilation of the measurement task specification is the compilation into the run-time specification, according to one embodiment. In a pre-order (top-down) traversal of the device expert call tree, some or all of the device experts may be instructed to compile. During this step, device experts may create primitive settings and add them to the run-time specification. Channel MSO attributes or negotiated ranges may also be resolved during this step. Additionally, stream building and signal routing may be executed at this step.","The names of the first two steps, analyze channels and analyze timing, are somewhat arbitrary. The importance of these two steps is that bottom-up and top-down traversals of the tree occur to allow attributes to be propagated through all the experts. Channel attributes generally describe an individual measurement or generation at the bottom leaves of the tree, which corresponds to where the user has connected his or her signal to the measurement system. Attributes, such as physical range, may be inspected and\/or modified by each expert upwards along the channel data path so that each expert can be given derived settings. Hence, the name \u201cAnalyze Channels\u201d is used. Timing attributes, on the other hand, generally describe timing for all the measurements in a single task. Attributes, such as rate, may be propagated downwards and derived into the specific settings of multiple devices. Hence, the name \u201cAnalyze Timing\u201d is used. These direction generalizations are not strictly true, however. For instance, a scan list MSO can be involved in both the channel and timing analysis steps, acting as a bridge of sorts between the two expert classifications.","In one embodiment, the measurement system may use streaming experts to compile stream specifications in the task specification into stream primitive settings in the task run-time specification. The term \u201cstreaming\u201d refers generally to data transport, e.g., reads and writes, but may also include data processing operations, such as filtering, splitting and combining of signals, and scaling, among others. Streaming experts may collaborate to transfer and process the data between its source(s) and destination(s). Examples of streaming experts may include an environment changer, format changer, linear scaler, splitter, polynomial scaling filter, pattern matching filter, buffer writer, kernel reader proxy and dispatcher, splitting writer, and combining reader, among others.","In one embodiment, the streaming experts may leverage a class library based on data pipes. This library allows different components in a measurement system to collaborate by providing a hierarchy of well-defined streaming primitives that can be extended and composed into highly specialized solutions. In one embodiment, the class library may leverage compiler-inlining optimizations to generate composites that are comparable in speed to hand-tailored assembly. Note that in one embodiment, the components of the class library may be operable to not only move data, but to analyze, transform, split, and\/or combine data, as well.","As is well known in the art, there are two basic types of streams: readable and writeable, where data is obtained from a readable stream and data is provided to a writeable stream, respectively. In one embodiment, the system may include a well-defined interface to facilitate easy use of stream components by a user or customer.","In one embodiment, a user may modify the measurement task specification incrementally using the task specifier. The expert system may subsequently revalidate the task specification, making incremental changes to the run-time specification. In other words, the expert system may incrementally recompile the modified measurement task specification, thereby updating the run-time specification. Changes to the run-time specification may then be deployed incrementally to reconfigure the run-time. These changes may include adding new primitive settings, modifying existing primitive settings, and removing primitive settings, among others.","In one embodiment, the measurement system may be operable to reserve one or more resources according to the generated run-time specification. In one embodiment, the generated run-time specification may comprise a specification of the parameters of one or more measurement primitives corresponding to rudimentary measurement operations of the measurement task. The measurement system may then instantiate measurement primitives in the form of software objects which may be used to configure one or more measurement devices when the run-time is executed, according to the run-time specification. This may comprise setting the values of parameters or registers of the measurement devices (hardware and\/or software) as appropriate to carry out the specified measurement task. The measurement system may thus generate the run-time by creating instances of the measurement primitives with the specified parameters. The run-time may then be executable to perform the specified measurement task.","Example: Acquire Voltage with an MIO and Two SCXI Modules in Two Chassis","One example that illustrates the phases of the expert system  is the measurement of two voltage phenomena on two channels with two SCXI modules in two SCXI chassis both connected to an MIO DAQ device.","FIG. \u2014Topography Diagram for Multi-Chassis Measurement Task",{"@attributes":{"id":"P-00332","num":"00332"},"figref":"FIG. 15","b":["1","1512","5","1","1100","1504","1","1001","1502","0","4","1510","1100","1504","0","1522","4","1510","0","1518","1","1504","1520","4","1510","1520","1","1504","1","1512","4","0","0","1","5","2","1514","6","3","1102","1508","1","1001","1506","2","4","1510","1102","1508","1","1524","4","1510","0","1518","3","1508","1520","4","1510","1520","3","2","4","1","2","3","6"]},"FIG. \u2014VI Diagram for Multi-Chassis Measurement Task",{"@attributes":{"id":"P-00334","num":"00334"},"figref":["FIG. 16","FIGS. 17-24"],"b":["1","2","1102","750"]},"FIG. \u2014Block Diagram of Creating the Device Expert Call Tree",{"@attributes":{"id":"P-00336","num":"00336"},"figref":"FIG. 17","b":["750","750"]},"In the example in , the task is created when the channels \u201cmyVoltage\u201d and \u201cmyVoltage\u201d are wired into the DAQ Timing VI. As illustrated in , the device expert call tree is constructed based on these channels' fully qualified channel paths. The root of these fully qualified channel paths both refer to dev. Therefore, an instance of the device expert associated with dev, the MIO PCI-6032E AI Device Expert  is created at the root of the device expert call tree. The next level in the fully qualified channel paths refers to difference devices, dev and dev. Therefore, two instances of device experts need to be inserted as children of the MIO PCI-6032E AI Device Expert . Since the device expert associated with dev is a SCXI  Device Expert, an instance of a SCXI  Device Expert B is created as a child of the MIO PCI-6032E AI Device Expert. Since the device expert associated with dev is also a SCXI  Device Expert, another instance of a SCXI  Device Expert A is created as another child of the MIO PCI-6032E AI Device Expert . The final level in the fully qualified channel path of channel \u201cmyVoltage\u201d refers to dev. Therefore, an instance of the device expert associated with dev, the SCXI  Device Expert  is created as a child of the SCXI  Device Expert B associated with channel \u201cmyVoltage.\u201d The final level in the fully qualified channel path of channel \u201cmyVoltage\u201d refers to dev. In a similar manner therefore, an instance of the device expert associated with dev, the SCXI  Device Expert  is created as a child of the SCXI  Device Expert A associated with channel \u201cmyVoltage.\u201d","FIG. \u2014Block Diagram of Creating the Channel Experts",{"@attributes":{"id":"P-00339","num":"00339"},"figref":["FIG. 18","FIG. 16","FIG. 18"],"b":["1","2","1102","1706","750","2","1102","1706","1001","1704","1001","1704","1702","1702","1802","1001","1704","1001","1804","1001","1704","1706","1102","1706","1102","1806","1804","1"]},"FIG. \u2014Block Diagram of Deserializing the Measurement Specification Objects",{"@attributes":{"id":"P-00341","num":"00341"},"figref":["FIG. 19","FIG. 16","FIG. 19"],"b":["1","2","750","1102","1806","1904","2","750","712","1904","1902","1906","2","1904","1902","1906","1"]},"FIG. \u2014Block Diagram of Configuring Timing Properties of the Measurement Task",{"@attributes":{"id":"P-00343","num":"00343"},"figref":["FIG. 20","FIG. 16","FIG. 20"],"b":["750","1702","2004","750","2004","2002","750","2002"]},"FIG. \u2014Block Diagram of Configuring Channel Properties of the Measurement Task",{"@attributes":{"id":"P-00345","num":"00345"},"figref":["FIG. 21","FIG. 16","FIG. 21"],"b":["750","1102","1806","1102","2102","750","2102"]},"FIG. \u2014Block Diagram of the Analysis of Channel Properties",{"@attributes":{"id":"P-00347","num":"00347"},"figref":["FIG. 22","FIG. 16","FIG. 22"],"b":["750","730","750","2","2202","1001","1704","1102","1706","1902","1904","1906","1802","1001","1704","2202","1702","1001","1704","1"]},"FIG. \u2014Block Diagram of the Analysis of Timing Properties",{"@attributes":{"id":"P-00349","num":"00349"},"figref":["FIG. 23","FIG. 16","FIG. 23"],"b":["750","1702","1702","1702"]},"FIG. A\u2014Block Diagram of the Compilation of the Measurement Task Specification into the Run-Time Specification",{"@attributes":{"id":"P-00351","num":"00351"},"figref":["FIG. 24A","FIG. 16","FIG. 24A","FIG. 24A"],"b":["750","1702","1702","750","1001","1704","1001","1704","750"]},"FIGS. B-F\u2014Further Steps of the Measurement Task",{"@attributes":{"id":"P-00353","num":"00353"},"figref":["FIGS. 24B-24F","FIGS. 24B-24F"],"b":["750","1702","24"]},{"@attributes":{"id":"P-00354","num":"00354"},"figref":"FIG. 24B","b":["750","1702","750"]},{"@attributes":{"id":"P-00355","num":"00355"},"figref":"FIG. 24C","b":["750","1702","750"]},{"@attributes":{"id":"P-00356","num":"00356"},"figref":"FIG. 24D","b":["750","1702","750"]},{"@attributes":{"id":"P-00357","num":"00357"},"figref":"FIG. 24E","b":["750","1702","750"]},{"@attributes":{"id":"P-00358","num":"00358"},"figref":"FIG. 24F","b":["750","1702","750"]},"FIG. \u2014Complete Block Diagram of Expert System",{"@attributes":{"id":"P-00360","num":"00360"},"figref":["FIG. 25","FIGS. 17-24"]},"Expert System Embodiment #2",{"@attributes":{"id":"P-00362","num":"00362"},"figref":"FIGS. 26-38","b":"750"},"In one embodiment, the expert system may be operable to receive a measurement task specification specifying a measurement task, analyze the measurement task specification, and populate one or more candidate run-time specifications. The expert system may be further operable to calculate one or more metrics for each of the populated candidate run-time specifications, and select one of the populated candidate run-time specifications based on the calculated metrics to produce a run-time specification. The selected populated candidate run-time specification may comprise at least a portion of the run-time specification, where the run-time specification is useable to configure one or more measurement devices according to the run-time specification, and to generate a run-time which is executable to perform the measurement task using the configured one or more measurement devices. In one embodiment, the configured one or more measurement devices may be operable to respectively perform portions of the measurement task.","In one embodiment, the expert system may comprise a plurality of experts, where populating the one or more candidate run-time specifications includes the expert system selecting and invoking one or more of the plurality of experts to analyze the measurement task specification and populate the one or more candidate run-time specifications. The selected experts may each analyze the measurement task specification and populate a respective candidate run-time specification, thereby producing one or more further populated candidate run-time specifications, where each respective candidate run-time specification comprises a possible partial or complete solution for the measurement task. The expert system may then calculate one or more metrics for each of the populated candidate run-time specifications, and select one of the populated candidate run-time specifications based on the calculated metrics. In one embodiment, for each respective populated candidate run-time specification comprising a partial solution, each selected expert may be operable to generate a respective new measurement task specification comprising an unsolved portion of the measurement task specification.","In one embodiment, if the analysis by a respective expert indicates that the expert cannot populate at least a portion of the respective candidate run-time specification, the respective expert may indicate to the expert system that it did not populate the candidate run-time specification for the measurement task specification. If the analysis by a respective expert indicates that the expert is operable to populate the respective candidate run-time specification, the expert may populate the respective candidate run-time specification, and communicate the respective candidate run-time specification to the expert system. If the analysis by a respective expert indicates that the expert is operable to populate only a first portion of the respective candidate run-time specification corresponding to a first portion of the generated measurement task specification, the expert may populate the first portion of the respective candidate run-time specification, communicate the first portion of the respective candidate run-time specification to the expert system, and submit a second portion of the respective measurement task specification to the expert system as a new, second measurement task specification, for which a respective candidate run-time specification portion was not populated.","The expert system may thus be further operable to receive and analyze the second measurement task specification, in the manner described above. For example, the expert system may be further operable to select and invoke one or more other experts to analyze the second measurement task specification and populate one or more second candidate run-time specifications, thereby producing one or more populated second candidate run-time specifications, where each respective second candidate run-time specification comprises a possible partial or complete solution for the measurement task. The expert system may then calculate one or more metrics for each of the second candidate run-time specifications, and select one of the second candidate run-time specifications based on the calculated metrics, wherein the selected populated second candidate run-time specification comprises at least a second portion of said run-time specification of the measurement task. In one embodiment, for each respective populated second candidate run-time specification comprising a partial solution, the expert may generate a respective new third measurement task specification comprising an unsolved portion of the second measurement task specification.","The expert system may be further operable to iteratively perform the above process on unsolved portions of the measurement task (or sub-tasks) until either the entire measurement task has been solved, or until the expert system determines that a solution may not be found subject to the current system resources, i.e., until either a complete run-time specification is populated, or the expert system determines that population of the complete run-time specification is not possible. The expert system may then operate to select a run-time specification from the candidates based on user specified and\/or system-specified metrics. Thus, in performing the iterative process, each of the one or more experts is operable to analyze at least one of the unsolved measurement sub-task specifications, populate at least one of the one or more respective candidate run-time specifications, thereby producing at least one populated respective candidate run-time specification, where each populated respective candidate run-time specification comprises a partial or complete solution for said at least one of the unsolved measurement sub-task specifications. Additionally, for each populated respective candidate run-time specification comprising a partial solution, each expert may generate a new, fourth respective measurement task specification, where the new, fourth respective measurement task specification comprises an unsolved portion of the unsolved measurement sub-task specification. In this manner, the expert system may recursively apply one or more experts to solve the measurement task specification and generate a complete solution in the form of a run-time specification, as described above.","In one embodiment, the system may further include a storage system which is operable to store an expert registry. The expert registry may include information correlating each expert with aspects of one or more respective measurement tasks, and selection of the one or more experts may be performed based on the expert registry.","As mentioned above, the plurality of experts may include one or more of device experts, channel experts, timing experts, reader\/writer experts, control experts, and streaming experts, among others, where each expert is responsible for managing different aspects of the measurement task specification.","FIG. \u2014Generation of the Run-Time Specification With the Expert System",{"@attributes":{"id":"P-00371","num":"00371"},"figref":["FIG. 26","FIG. 26"],"b":["740","750","2602","750","740","740","750","740","750"]},"In , in response to the above-mentioned analysis, the expert system  may select one or more experts to populate candidate run-time specifications. As mentioned above, each of the one or more experts may be selected based upon properties of the measurement task specification. In one embodiment, there may be more than one way to implement the measurement task, in which case multiple experts may be selected to populate competing candidate run-time specifications, or, as described below, a given expert may populate multiple run-time specifications. In one embodiment, the overall measurement task may be divided into one or more constituent sub-tasks and parceled out to respective experts for population of the respective candidate run-time specifications, as described below.","In  each of the one or more selected experts may analyze the measurement task (or measurement sub-task) specification. In one embodiment, each of the one or more selected experts may analyze the measurement task (or measurement sub-task) specification to verify that it is capable of \u201csolving\u201d the measurement task (or sub-task) problem, i.e., is capable of populating the run-time specification for that measurement task (or sub-task).","In , each expert may populate one or more candidate run-time specifications in response to the analysis of . In one embodiment, if the expert has determined from the analysis that only a portion of the measurement task (or sub-task) may be solved by that expert, then the expert may partially populate a solution for that task (or sub-task), i.e., may partially populate a candidate run-time specification corresponding to the solvable (by that expert) portion of the measure task (or sub-task). Previously, the run-time specification, which the expert is populating, may have been partially populated by another expert in a previous iteration of this method. As mentioned above, the candidate run-time specification may comprise software objects or data structures, such as C++ objects, which may specify the run-time parameters for software and\/or hardware used to implement the measurement task.","In , a determination may be made as to whether the generated candidate run-time specification is complete, i.e., whether the submitted measurement task (or sub-task) has been solved by the expert system . Said another way, the candidate run-time specification may be assessed for completeness.","As indicated in , if the candidate run-time specification is determined to be incomplete, the unsolved portion of the measurement task specification  and the corresponding partially populated run-time specification may be submitted to the expert system  as a new measurement task problem. As  shows, the method may then proceed as described above with reference to - in an iterative fashion, until the candidate run-time specification is complete, i.e., until the submitted measurement task (or sub-task) has been solved, or until the solution fails, i.e., is determined to be unsolvable using the available resources. It should be noted that in some embodiments multiple iterations may be made by this method, decomposing the measurement task into sub tasks, one or more sub tasks into further sub tasks, and so on, such that multiple layers of experts collaborate to populate a set of candidate run-time specifications.","In  the expert system , which may receive multiple competing candidate run-time specifications, may calculate one or more metrics for each candidate run-time specification. Examples of calculated metrics for a given candidate run-time specification may include cost, performance, resource use, or any other metric which quantifies a desirable (or undesirable) aspect of the solution. Thus, depending upon the user's preferences, each candidate solution may be assessed for desirability.","Finally, in  the expert system  may select one candidate run-time specification based on the calculated one or more metrics and the user's preferences. In the preferred embodiment, the calculated metrics reflect the prioritization by the user of various aspects of the solutions, as mentioned above with reference to  above. For example, if the user wishes to implement a solution optimized for performance, then the expert system  may be configured to select a candidate run-time specification which favors the performance metric, such that the solution is optimal with respect to performance. For example, an optimal solution may extremize (maximize or minimize) a particular performance metric, e.g., minimize execution time.","Thus, the method may provide a measurement task implementation which accommodates the user's priorities subject to the resource constraints of the system. In one embodiment, the expert system  may be invoked during the verify transition from the unverified to verified states, as illustrated in , above. Additionally, the expert system  may be invoked before a new task is started for the first time. Finally, the expert system  may be invoked whenever a customer makes major modifications to a task specification and then starts that task. Conversely, in one embodiment, the expert system  may not be invoked in the following circumstances: upon loading of persisted task and run-time specifications; when recent task specifications and run-time specifications have been transparently cached by application development environment APIs; upon deployment of a run-time on an embedded system; and when attributes of a task specification are changed during execution via attribute accessors provided by the system. Attribute accessors may thus circumvent the need to invoke the expert system  for each modification to an attribute. In one embodiment, at least a subset of task specification attributes may be modified while the associated hardware is running, e.g., changing the gain on an arbitrary waveform generator. In one embodiment, at least a subset of task specification attributes may be modified between a stop and a re-start, e.g., changing analog triggering conditions on an MIO device.","As mentioned above, the measurements expert system  may be operable to compile the task specification  to produce the run-time specification . As also mentioned above, the expert system  may include a dynamic collection of measurements experts. The expert system  may interpret a customer's measurement task and use the measurements experts to explore possible solutions and compile the specification for the run-time optimized for the customer's measurement task. In one embodiment, the expert system  may reside and function between the ADE (Application Development Environment) APIs and the run-time, or measurements driver. It should be noted that the run-time, or measurements driver, is actually built by other components of the system, e.g., the run-time builder.","As mentioned above with reference to Expert System Embodiment #1, in one embodiment, a user may modify the measurement task specification incrementally using the task specifier. The expert system may subsequently incrementally recompile the modified measurement task specification, thereby updating the run-time specification. Changes to the run-time specification may then be deployed incrementally to reconfigure the run-time. These changes may include adding new primitive settings, modifying existing primitive settings, and removing primitive settings, among others.","In another embodiment, the expert system may analyze incremental changes made to the measurement task specification and populate one or more run-time specification change lists with measurement primitive settings. These change-lists may then be used to update the run-time specification in accordance with the measurement primitive settings. For example, in order to deploy, modify, and destroy primitive supervisors, an expert responsible for configuring a task may create a run-time specification change list. The run-time specification change list enables efficient reconfiguration of a run-time, in that experts add only those primitive settings which need to be added, modified, or removed from the run-time based on any incremental changes made by the user or customer. The run-time builder efficiently updates the pre-existing run-time based on this run-time specification change list.","In one embodiment, the primary architectural concepts of the expert system  may include measurement specification objects (MSO), registration and matching, a decision tree, a two-phase process, and solution builders. Measurement specification objects may comprise atomic objects in the form of data structures or software classes which reflect the primary concepts and collaborations of the measurements domain, providing a protocol for communication of new or modified problems between measurements experts. The use of these objects by the expert system  may enable complex solutions to be broken down into simpler components in a consistent way. Said another way, the MSOs may describe the customer's measurement task in a device-independent manner, and may also be operable to describe device-specific aspects of the task. In one embodiment, the MSOs may decouple the measurements API from the expert system .","The expert system  may help measurements devices work together in several ways. Measurements experts that perform automatic routing may be provided, and may be leveraged by any other measurements experts. Streaming experts may be provided to build streams involving multiple sources and destinations. Control experts may enable sequencing and may be able to create bridges between operating environments. By binding all of these measurements experts together, the MSOs may provide a means of specifying problems to be solved by other measurements experts. Measurements experts may therefore be able to specify new device-generic problems without any explicit knowledge of the device-specific measurements experts that might solve them.","One example of an MSO corresponds to a measurement. In one embodiment, a measurement MSO may comprise a phenomenon (i.e., a detectable signal), a terminal configuration, a desired resolution, a name, and one or more constraints. The particular values of these fields may thus specify a particular measurement. Measurement specification objects may be linked together to form a measurement task specification.","In one embodiment, each measurements expert may provide a registration specifying characteristics of problems it may be able to solve. The expert system  may then use the registrations to match a current problem to one or more experts. Matching may reduce the number of measurements experts invoked for each problem by not invoking measurements experts that have no possibility of solving a given problem.","In one embodiment, measurements experts may specify which types of problems they might be able to solve by using one of a set of matching patterns specified in a library. The library may define a finite number of general matching patterns representing the most common classifications of problems measurements experts solve. The library may allow developers to specify specific sub-classes of MSOs and attribute values which measurements experts can work with. For example, the registration for an E-series digitizer expert might specify all present value measurements of voltage phenomena on a specific set of terminals.","In addition to determining which measurements experts to invoke for a given problem, matchers may provide measurements experts with direct references to relevant MSOs, dramatically reducing the amount of code which measurements expert developers must write to verify whether a problem can be solved.","Thus registration and matching may function as a filtering mechanism to reduce the number of experts invoked to solve a particular problem, thereby increasing the performance of the expert system . Another benefit of this approach is a reduction in redundant expert verification code. One example of a registration for an MIO AI digitizer expert may include the following information:\n\n","Thus, the MIO AI digitizer expert may be useful in solving problems involving present value measurements of a voltage phenomenon from an MIO device. When the expert system  encounters such a problem, task, or sub-task, this expert may be selected to help populate the run-time specification.","FIG. \u2014Decision Tree","Selected experts may propose one or more decisions for how a particular problem can be solved. Each decision may comprise instructions for building one or more pieces of a final solution, as well as new sub-problems generated for other experts. When multiple decisions are provided by an expert, they may create a tree structure referred to as a decision tree, where each path from the root of the decision tree to a leaf (branch termination) may be considered one solution. The particular solution may be partial, complete, or a failed solution.  illustrates an example of a simple decision tree generated by an MIO AI data transfer expert, according to one embodiment. As  shows, the MIO AI data transfer expert  may receive an MIO AI task specification . The expert may propose more than one solution to the problem represented by the specification. In this example, the expert proposes both DMA (direct memory access)  and interrupt-driven  implementations for transferring data from an MIO device. It should be noted that more complex tree structures with multiple nodes and branches may also be generated. Note also that, because experts may be applied to sub-problems or sub-tasks, multiple decision trees (associated with the sub-tasks of a larger task) may be assembled into larger, more complex trees corresponding to the overall task or problem solution.","Size and growth of decision trees may be controlled by several mechanisms. Because measurements problems are specified using terminals tied to specific devices, the expert system  may attempt to solve each problem using only hardware explicitly specified by the customer. The expert system  may also attempt to identify sub-problems which are independent, eliminating the need for the decision tree to contain all permutations of these sub-problems. In order to further control the growth of the decision tree, the number of decisions proposed by each measurements expert may be limited. In other embodiment, advanced heuristics may be utilized for prioritization, which may enable the expert system  to handle larger decision trees, thereby increasing versatility and accuracy of solutions.","As mentioned above, in the preferred embodiment, a primary aspect of the expert system  is a two-phase approach to generation of the run-time specification. The two phases may comprise a solving phase, and a building phase. In the solving phase experts may be matched to problems, proposing new decisions and expanding the decision tree for a given problem, as described above. The expert system  may then select a solution from among the possible solutions represented by the decision tree. Once a solution has been selected by the expert system , then, in the building phase, solution builders for that solution may be invoked to assemble the run-time specification and finalize the task specification.","Experts may deploy any number of solution builders to each proposed decision. In one embodiment, solution builders for a particular solution may be executed only if that solution is selected by the expert system . Each solution builder may add to the run-time specification and\/or finalize attributes in the task specification. In one respect, the use of the solution builders may be considered an optimization technique, in that the processing of the run-time specification may be performed only for the final solution. However, in another respect, the use of solution builders may be considered a necessity because it may not be possible to generate some portions of the run-time specification until the results of other experts are known.","One example of a solution builder is an MIO AI digitizer solution builder. In one embodiment, the MIO AI digitizer solution builder may be operable to add settings to the run-time specification for an MIO configuration FIFO, such as gain, polarity, channel, mode, dither, etc. The MIO AI digitizer solution builder may also be operable to set input limit attribute in the task specification.","FIG. \u2014Expert Walk-Through: MIO AI Digitizer Expert",{"@attributes":{"id":"P-00401","num":"00401"},"figref":"FIG. 28","b":["750","750","740","2802"]},"Once invoked, in , the MIO AI digitizer expert may verify that it can solve the problem, e.g., may verify that the voltage phenomenon is within a valid range.","After the expert has verified that it may be able to solve the problem, then in  the expert may branch a copy of the problem, also known as a decision (see the description of a decision tree above). As mentioned above, each decision may comprise instructions for building pieces of a final solution, as well as new sub-problems generated by other experts. A copy of the problem or decision may be used because other experts may also provide solutions to the same problem.","In , the expert may replace the branched problem with specifications for sub-problems. In other words, the expert may decompose the problem into various sub-problems. These sub-problems may not only comprise a decomposition of the problem, but may also comprise alternative solutions paths for the problem, as illustrated by  above. Thus, the problem may be replaced by a combination of solution specifications (partial solutions) and sub-problem specifications, which then may be re-submitted to the expert system  for solution by other experts. For example, the MIO AI digitizer expert may replace the present value measurement of a voltage phenomenon on an MIO AI terminal specification with specifications for a timing sub-problem, a data transfer sub-problem, and a linear scaling streaming sub-problem.","Finally, in , the expert may deploy a solution builder to the branched decision. As noted above, in one embodiment, the solution builder may not be deployed unless the decision is selected by the expert system . The deployed solution builder may assemble or add to the run-time specification and\/or finalize attributes in the task specification.","In one embodiment, experts may be organized into sub-architectures, or groups of experts which are dependent upon each other and designed to collaborate to solve a specific type of problem. Sub-architectures may be loosely coupled to one another, facilitating re-use and flexibility. A problem may generally flow between sub-architectures as portions of the problem are solved. Said another way, particular portions of a problem may typically be solved by a sub-architecture of experts specializing in solving that type of problem (portion). Examples of sub-architectures may include routing experts, streaming experts, and device experts, among others.","Thus, the measurements expert system  may interpret a customer's specified measurements task, explore possible solutions, and compile a specification for a run-time optimized for the customer's measurement task. As noted above, in one embodiment, the run-time specification may be used by the run-time builder to build and link a run-time, which may then be executed to perform the specified measurement task, as described above.","FIGS. -\u2014Further Examples of Expert System Applications",{"@attributes":{"id":"P-00409","num":"00409"},"figref":"FIGS. 29-37","b":"750"},"FIG. \u2014Generic Expert Flow Diagram",{"@attributes":{"id":"P-00411","num":"00411"},"figref":["FIG. 29","FIG. 29","FIGS. 26-28"],"b":["2902","2904","2904","2902","2906","2902","2906","2908","2906","750"]},"FIG. \u2014Run-Time Configuration Diagram",{"@attributes":{"id":"P-00413","num":"00413"},"figref":["FIG. 30","FIG. 30"],"b":["3000","3000","3002","3004","3006"]},"Example: Routing","One example of the use of the run-time configuration process involves a routing sub-problem as part of a larger measurement task. In this example, the presented problem includes routing an acquisition timebase signal on a first device (device ) to an acquisition timebase signal on a second device (device ) to synchronize the two devices for a 1 MHz acquisition.","The corresponding routing task specification may be summarized thus: connect terminal \u201cdevice\/timebase_out\u201d to \u201cdevice\/timebase_in\u201d. Additional information in the specification may include the fact that the terminal \u201cdevice\/timebase\u201d is a single-ended TTL digital signal with a bandwidth of 1 MHz.","FIG. \u2014Topography Diagram for Routing Task",{"@attributes":{"id":"P-00418","num":"00418"},"figref":["FIG. 31","FIG. 31"],"b":["1","3102","2","3102","3104","0","7","3104","1","3102","3108","3106","3110","2","3102","0","3104","3106","3104","0","0","0","0"]},"FIG. \u2014Solution Steps Diagram for Routing Task",{"@attributes":{"id":"P-00420","num":"00420"},"figref":["FIG. 32","FIG. 32"],"b":["0","3202","1","3204","1","1","3204","0","3202","1","3206","1","3206","0","3202","1","3206","750","3208","1","3206","2","3210","1","3206","2","3210","3208","2","3210","3","3212","2","3210","3","3212","2","3204","4","3214","4","3214","3216"]},"In one embodiment, the solution steps may respectively specify the following routing operations:\n\n","Note that (1) is a sub-problem generated by the first MUX expert A from the original specification or problem, which was to route from device\/timebase_out to device\/timebase_in. Similarly, (2) is a sub-problem generated by the first connector expert A in response to (1), (3) is a sub-problem generated by the second connector expert B in response to (2), and (4) is a sub-problem generated by the second MUX expert B in response to (3). Finally, (4) may be recognized by the completion expert  as atomistic, meaning that no further decomposition is needed, and so the solution is complete.","The generated solution (run-time specification) resulting from the above process may comprise hardware and software settings which facilitate the implementation of the specified measurement task. In one embodiment, the hardware and software settings may specify the following actions:","1) reserve RTSI on the connected RTSI bus;","2) program device 's multiplexers to route from the external timbase output terminal to RTSI; and","3) program device 's multiplexers to route from RTSI to the external timebase input terminal.","Thus, various routing experts, including multplexor (MUX) experts, inter-component connector experts, bus experts, and a completion expert may collaborate to decompose the original problem (specification) and generate a plurality of partial solutions which together may comprise a solution to the measurement problem.","Example: Multi-Device Synchronization","Another example of the use of the run-time configuration process relates to acquiring synchronized analog voltage data from two devices, device  and device  at 1 MHz. The received task specification corresponding to this measurement task may specify continuous acquisition of two present value voltage measurements on differential terminal \u201cdevice\/ai\u201d and differential terminal \u201cdevice\/ai\u201d at a sample rate of 1 MHz, and, in one embodiment, may include additional information indicating that the user will generate software start and stop events.","FIG. \u2014Topography Diagram for Synchronization Task",{"@attributes":{"id":"P-00435","num":"00435"},"figref":["FIG. 33","FIG. 33","FIG. 33"],"b":["1","3302","3304","0","3306","3302","3104","2","3302","3304","0","3306","3104","0","7","3104","3304","0","3306","0","3104","2","3302","3304","2","3302","0","3306"]},"FIG. \u2014Solution Steps Diagram for Synchronization Task",{"@attributes":{"id":"P-00437","num":"00437"},"figref":["FIG. 34","FIG. 34"],"b":["0","3402","3404","3404","0","3402","1","3406","1","3406","0","3402","1","3406","750","1","3408","1","3406","2","3410","1","3406","2","3410","2","3408","2","3410","3","3412","2","3410","3","3412","3414","4","3416","3","3412","3418","4","3416"]},"In one embodiment, the solution steps described above may operate to perform the following:","1) solve two groups of event specifications, one for each device (a master group and a slave group), with shared events between the two groups;","2) with the master group removed, solve  slave group, where the start, stop, and sample events are replaced with external trigger events generated by the master; and","3) solve three routing problems to route the external events from the master to the slave.","The generated solution (run-time specification) resulting from the above process may comprise hardware and software settings which facilitate the implementation of the specified synchronization task. In one embodiment, the hardware and software settings may specify the following actions:","1) reserve master and slave acquisition devices, and three RTSI lines;","2) program master to acquire a single channel, with software start and stop;","3) program master sample clock to 1 MHz;","4) program master to route acquisition start, stop, and sample signals to RTSI;","5) program slave to acquire a single channel and to receive start, stop, and sample signals from RTSI; and","6) when starting, arm slave before starting master (reverse this sequence when stopping).","Thus, various synchronization experts, including group splitting experts, device-specific acquisition experts, and device-specific timing experts, plus routing experts may collaborate to decompose the original problem (specification) and generate a plurality of partial solutions which together may comprise a solution to the measurement problem.","Example: Transparent Operation of Accessories","Another example of the use of the run-time configuration process relates to transparent operation of accessories, e.g., acquisition of analog voltage data from all 32 channels of a switch using a scanning DMM (Digital Multi-Meter). The received task specification corresponding to this measurement task may specify continuous acquisition of two present value voltage measurements on differential terminals \u201cdevice\/ai:\u201d using \u201cdevice\u201d as the measurement device, wherein \u201cdevice\u201d is a DMM, and \u201cdevice\u201d is a scanning switch with 32 different channels.","FIG. \u2014Topography Diagram for Data Acquisition Task",{"@attributes":{"id":"P-00453","num":"00453"},"figref":["FIG. 35","FIG. 35"],"b":["1","3502","3504","3502","3506","3508","0","3510","3504","3508","3506","3512","3508","3514","0","3510","3504","0","31","3516","3504","3504","3514","0","3510"]},"FIG. \u2014Solution Steps Diagram for Data Acquisition Task",{"@attributes":{"id":"P-00455","num":"00455"},"figref":["FIG. 36","FIG. 36"],"b":["0","3602","3604","3604","0","3602","1","3606","1","3606","0","3602","1","3606","750","3608","1","3606","2","3610","1","3606","2","3610","3612","2","3610","3","3614","2","3610","32","3614","3608","3","3614","4","3616","3","3614","3618","4","3616","3608","3608"]},"The solution steps described above may operate to perform the following:","1) continuously acquire 32 present value voltage measurements all located on \u201cdevice\/com\u201d using \u201cdevice\u201d as the measurement device, generating\/receiving handshaking signals to\/from \u201cdevice\/trig_in\u201d and \u201cdevice3\/trig_out\u201d;","2) same as (1), but measure on \u201cdevice\/AI\u201d; and","3) route from \u201cdevice\/vmc_out\u201d to \u201cdevice \/trig_in\u201d and from \u201cdevice\/trig_out\u201d to \u201cdevice\/trig_in\u201d.","The generated solution (run-time specification) resulting from the above process may comprise hardware and software settings which facilitate the implementation of the specified data acquisition task. In one embodiment, the hardware and software settings may specify the following actions:","1) program a switch scanning FIFO (associated with the scanning switch ) to switch through channels  through  in sequence;","2) program the switch  to advance on a trigger received on trig-in B and to generate a signal on trig_out  after each channel has switched; and","3) program the DMM  to acquire 32 channels in a scan. The DMM  should generate VMC on vmc_out  and receive the scanner advanced trigger on trig_in A.","In various embodiments, run-time configuration tasks may include many other measurement task solutions, including transparent operation of sensors, efficient distributed data streaming and run-time control, stream operations such as messaging and logging, scaling selection and optimization, pattern detection, analysis, and other measurement functions, as well as compiling a graphical diagram, such as a National Instruments LabVIEW diagram, for DAQ execution, among others.","FIG. \u2014Out-of-the-Box Configuration Diagram",{"@attributes":{"id":"P-00466","num":"00466"},"figref":["FIG. 37","FIG. 37"],"b":["3700","3700","3702","3704","3706","3708"]},"Example: Channel Selection","One example of an out-of-the-box configuration process relates to channel selection, i.e., choosing a device and terminal that can be used to take a measurement. In the preferred embodiment, the solution steps may proceed in a similar fashion to those presented in , , and , described above, in that a series of experts may be utilized to solve a task specification to generate a run-time specification. In one embodiment, the task of channel selection may be solved by terminal selection experts and one or more run-time experts. For example, in one embodiment, a terminal selection expert may","1) match a group or sub-group within the task to available group expert registrations;","2) choose terminals specified in the group registration that are not currently in use; and","3) create a sub-problem that attempts to solve the group using the selected terminals.","In one embodiment, the system may provide a list of compatible channels to choose from. It should be noted that more expert registration information will typically facilitate a faster search.","Example: System Wizard","Another example of an out-of-the-box configuration process relates to a system wizard which may be operable to select terminals and connectors appropriate to a particular measurement task, according to one embodiment. In one embodiment, the experts invoked by the expert system  to solve this task may include terminal selection experts and connector selection experts, as well as various run-time configuration experts.","FIG. \u2014Point-of-Sale Configuration Diagram",{"@attributes":{"id":"P-00476","num":"00476"},"figref":["FIG. 38","FIG. 38"],"b":["3800","3800","3802","3804","3806","3808"]},"One example of a point-of-sale configuration system is a DAQ designer, such as National Instruments DAQ Designer system. In this embodiment of the invention, the system may be operable to select products and configure cables and connections for those products to perform a measurement task. For example, if many products are registered with the system, it may be problematic to select the appropriate suite of components to perform the measurement task. In one embodiment, the system may use prioritization and heuristics to direct a search for the components. In one embodiment, the search may be prioritized on desired throughput, acquisition latency, form-factor, and price, among other factors.","Example Solutions to Prior Art Issues","The following sections describe various solutions to a number of issues with some prior art systems, e.g., NI-DAQ 6.9, including performance issues, usability, and engineering efficiency.","Performance","As mentioned above, there are a number of performance related deficiencies in some prior art systems which are addressed by various embodiments of the present invention, described below.","State Model","One important omission of some prior art systems is that there is no state model for the system, resulting in uncoordinated resource management, e.g., resources may be reserved, programmed, and unreserved continuously due to the fact that current state information of the system is unavailable to system processes and components. For example, in an experiment involving one prior art measurement system, a Read One Scan task involved ten kernel transitions; calculating, verifying, and programming a scan list, timing, triggering, and dithering; calculating and verifying input limits multiple times; and checking accessories multiple times, for each read.","In contrast, in one embodiment of the present invention, a state model of the system may be defined and enforced, substantially eliminating unnecessary state transitions, and enabling customers to more finely control state transitions. For example, in one experiment, a single read task, e.g., an Acquire Single Voltage On Demand task, performed by one embodiment of the invention involved one kernel transition per read, and executed approximately twenty times faster than the prior art measurement system mentioned above.","Code Paths","Virtually any function or class-based software system involves program flow through layers of software, i.e., a code path. However, some prior art systems are designed for generality, and so for specific tasks, many layers are superfluous and inefficient. For example, in the prior art system mentioned above, a Read One Scan task involved hundreds of function calls in user-mode. Each traversal of a software boundary requires CPU cycles and stack operations, and so large numbers of these layers can degrade performance substantially.","In contrast, in one embodiment of the present invention, the system may construct code paths customized for the customer's task. For example, an Acquire Single Voltage On Demand task required less than ten function calls in user-mode for each read. Thus, by customizing code paths for the task at hand, improvements on the order of factors of ten may be achieved.","Threads and Polling","Some prior art measurement systems restrict program execution to a single thread, even when accessing different devices, e.g., simultaneous buffered analog input and single point digital output. Limiting execution to a single thread cannot only result in substantial inefficiencies, but can degrade functionality as well. For example, in a single-threaded measurement system, when a customer requests a data read on a device, the one thread continuously polls the device until the data is ready. This polling may, at times, completely consume the CPU resources (cycles), preventing other functions or tasks from being executed. For example, if the device is being polled in the kernel, the user interface may freeze because no CPU cycles are being allocated to the user interface.","In contrast, according to one embodiment of the invention, the measurement system may be multi-threaded, using asynchronous events instead of polling to manage processes and device accesses. In the above read example, the related thread may sleep until the data is available, at which time an event may be sent which awakens the thread. The use of multiple threads also allows other threads to perform processing while the measurement task, e.g., the read, is being performed. Thus, by utilizing multiple threads a plurality of tasks or sub-tasks may be performed simultaneously for greater efficiency and flexibility.","Example Virtual Instrument Diagrams",{"@attributes":{"id":"P-00492","num":"00492"},"figref":"FIGS. 39A-45C"},"FIG. A\u2014Simultaneous Buffered Analog Input and Single-Point Digital Output With Single Threaded Driver (Prior Art)",{"@attributes":{"id":"P-00494","num":"00494"},"figref":["FIG. 39A","FIG. 39A"]},"FIG. B\u2014Simultaneous Buffered Analog Input and Single-Point Digital Output With Multi-Threaded Driver",{"@attributes":{"id":"P-00496","num":"00496"},"figref":["FIG. 39B","FIG. 39A","FIG. 39B"],"b":"39"},"As shown, the VI of  includes various icons representing measurement task operations, including a \u201cclock\u201d icon which denotes timing specifications, and a \u201cplay\u201d icon which denotes an execute function call. In one embodiment, execution of the play node (represented by the play icon) may invoke the expert system , resulting in generation of the run-time specification , as described above. In another embodiment, execution of the play node may further invoke the run-time builder , which may use the run-time specification  to generate the run-time , as described above.","Memory Footprint","One significant improvement of the present system over some prior art systems relates to the memory footprint, i.e., the amount of computer memory required to operate the system. Some prior art measurement systems always load software for all supported devices, using much more memory than would be required by the software actually used to perform a particular task. For example, in one prior art measurement system, a customer may specify use of a particular DAQ device, such as a National Instruments PXI-6070E DAQ device, but the system loads software, not only for the PXI-6070E DAQ device, but for the AT-DIO-32F and all other devices, as well. In contrast, in various embodiments, the present invention may only load software components when needed, and so, may avoid large memory footprints associated with loading extraneous software. In other words, because the present invention may only load software as it is needed, the operational memory footprint may be substantially smaller than some prior art systems.","Robustness in Exceptional Conditions","Some prior art measurement systems provide little or no support for abnormal process termination or unexpected device removal. For example, an abnormal process termination, or device removal or insertion, may cause the measurement system to crash or behave improperly. In contrast, various embodiments of the present invention define and enforce policies specifically for these conditions, substantially improving the customer's experience under these circumstances.","Distributed Measurements","Some prior art measurement systems often provide little or no support for distributed measurements wherein measurements are made with devices on other computers. For example, distributed measurements may be supported only at the level of the public API of the system, using one network protocol for all communications. In contrast, in one embodiment of the present invention, a framework may be provided for communicating and transferring data over IP-based networks, allowing both local and remote devices to be supported in the same task. Additionally, the system may support a variety of protocols, choosing the most efficient protocol for a given task or sub-task. For example, in one embodiment, one protocol, e.g., National Instruments NI-RPC, may be used for functional calls in a DAQ application, while Logos sockets may be used for data movement.","Embedded Devices","One problem with some prior art systems regarding embedded applications relates to monolithic architectures. These systems require that the entire system be installed on an embedded device, effectively requiring the embedded device to have the capabilities of a PC (personal computer). The size and expense of such solutions may make them infeasible for many applications. In contrast, in one embodiment of the present invention, clear functional boundaries may be defined which allow decoupling of software components, including the framework itself. Thus, the entire framework of the system is not required on an embedded device. In one embodiment, only the functions required by the embedded application may be installed on the device. This functional modularity may provide substantial savings in that cheaper processors and less memory may be required for a given application. Such reductions in hardware requirements may also make feasible devices which might not be possible otherwise, such as an Ethernet-based data acquisition device, for example.","Integration of Devices","In some prior art measurement systems, the use of multiple devices in a measurement task can be problematic due to a lack of integration. For example, in an application which utilizes a DMM and a switch, the customer may have to program the DMM and switch separately using two different APIs. In one embodiment of the present invention, this problem may be addressed by defining a protocol which allows software components to work together while remaining decoupled. For example, the customer may have the option to program the DMM and use the switch transparently.","Synchronization","In some prior art measurement systems synchronization issues present difficulties which result in increased complexity of task implementations. For example, it may be difficult to synchronize sub-sections of a device, to synchronize homogeneous devices, or to synchronize between heterogeneous devices.  present example VIs which illustrate improved synchronization capabilities of the present invention as compared to prior art systems.","FIG. A\u2014Simultaneous Triggered Buffered AI\/AO (Prior Art)",{"@attributes":{"id":"P-00511","num":"00511"},"figref":["FIG. 40A","FIG. 40A"]},"FIG. B\u2014Simultaneous Triggered Buffered AI\/AO",{"@attributes":{"id":"P-00513","num":"00513"},"figref":["FIG. 40B","FIG. 40B","FIG. 40A"]},"FIG. A\u2014Sharing a Scan Clock Across Two E-Series Devices (Prior Art)",{"@attributes":{"id":"P-00515","num":"00515"},"figref":["FIG. 41A","FIG. 41A"]},"FIG. B\u2014Sharing a Scan Clock Across Two E-Series Devices",{"@attributes":{"id":"P-00517","num":"00517"},"figref":["FIG. 41B","FIG. 41B","FIG. 41A"]},"FIG. \u2014Buffered AI and DI with Shared Clock and Trigger",{"@attributes":{"id":"P-00519","num":"00519"},"figref":["FIG. 42","FIG. 41B","FIG. 42"]},"Configuration Clutter","One characteristic of graphical diagrams or text-based programs required by some prior art measurement systems is that they are typically cluttered with configuration VIs and (virtual) wiring or configuration functions.  illustrate how the use of a Task Specifier or Measurement Task Configuration Tool may dramatically decrease this clutter.","FIG. A\u2014Acquisition of N Scans with External Scan Clock and Digital Trigger (Prior Art)",{"@attributes":{"id":"P-00523","num":"00523"},"figref":["FIG. 43A","FIG. 43A"]},"FIG. B\u2014Measurement Task Configuration Tool Interface for Acquisition of N Scans with External Scan Clock and Digital Trigger",{"@attributes":{"id":"P-00525","num":"00525"},"figref":["FIG. 43B","FIG. 43B"]},"FIG. C\u2014Measurement Task Configuration Tool Interface for Acquisition of N Scans with External Scan Clock and Digital Trigger",{"@attributes":{"id":"P-00527","num":"00527"},"figref":["FIG. 43C","FIGS. 43A and 43B","FIG. 43C"]},"FIG. D\u2014Acquisition of N Scans with External Scan Clock and Digital Trigger",{"@attributes":{"id":"P-00529","num":"00529"},"figref":["FIG. 43D","FIG. 43D","FIGS. 43B and 43C","FIG. 43D"],"b":"43"},"Scalability of Applications Across Hardware","In some prior art systems, when hardware in a measurement system is replaced with a more powerful device, the customer must rewrite the application, often having to learn a completely different API, such as, for example, when the customer replaces an NI E-Series\u2122 device with a more powerful high-speed digitizer. According to one embodiment of the present invention, device-dependent portions of the API may be isolated, making a significantly larger portion of the API device independent, and thus minimizing the need for customers to develop with multiple APIs. , described below, illustrate VIs which perform a measurement task using three different hardware components.","FIG. A\u2014Triggered Acquisition With E-Series Device",{"@attributes":{"id":"P-00533","num":"00533"},"figref":["FIG. 44A","FIG. 44A"]},"FIG. B\u2014Triggered Acquisition With High Speed Digitizer",{"@attributes":{"id":"P-00535","num":"00535"},"figref":["FIG. 44B","FIG. 44B","FIG. 44A"]},"FIG. C\u2014Triggered Acquisition With High Speed Digitizer With Filtering",{"@attributes":{"id":"P-00537","num":"00537"},"figref":["FIG. 44C","FIG. 44B","FIGS. 44A and 44B","FIGS. 44A-C"]},"API Layers","Some measurement system architectures include multiple software layers. It is sometimes the case in prior art systems that these layers are mutually exclusive, meaning that the APIs of each layer are not interoperable. This restriction may limit the customer's ability to use certain measurement modules in that modules or functionality implemented in different software layers may not be useable together. For example, a customer using an intermediate DAQ layer who wishes to use analog window triggering may find that if the analog window triggering feature is implemented in an advanced layer, part of the customer's application may have to be re-written. Additionally, the use of multiple APIs in a measurement system may result in features which are not accessible or available in some areas of the system. For example, in one prior art system (NI-DAQ 6.9) named channels, integrated SCXI, and RDA are implemented in the NI-DAQ LabVIEW layer and therefore are not accessible in the C programming language.","In one embodiment of the present invention, portions of the APIs for the software layers may be interoperable. Additionally, the API may be decoupled from the software components that implement the features, allowing any customer to use most, if not all, of the system features.  illustrate the need for and some benefits of interoperable software layers in a measurement system architecture.","FIG. A\u2014Intermediate Layer (Prior Art)",{"@attributes":{"id":"P-00542","num":"00542"},"figref":["FIG. 45A","FIG. 45A","FIG. 45B"]},"FIG. B\u2014Changes for Analog Window Triggering (Prior Art)",{"@attributes":{"id":"P-00544","num":"00544"},"figref":["FIG. 45B","FIG. 45A","FIG. 45A","FIG. 45B"],"b":"45"},"FIG. C\u2014Analog Window Triggering",{"@attributes":{"id":"P-00546","num":"00546"},"figref":["FIG. 45C","FIG. 45C"],"b":"45"},"Comparison of the Two Embodiments of the Expert System","Two primary embodiments of the expert system are described above with reference to  and , respectively. The first embodiment, referred to as the \u201cstatic\u201d system, uses a pre-defined expert call tree to deterministically translate the measurement task specification into the run-time specification. In contrast, the second embodiment, referred to as the \u201cdynamic\u201d system, is considered to be an intelligent measurements expert system which is able to interpret a customer's measurements task specification, explore possible solution paths, and compile a solution which is substantially optimized for the customer's measurement system.","The two embodiments of the expert system both address many of the limitations of the prior art, including performance related issues such as the lack of a state model, inefficient code paths, inefficiency and unresponsiveness of reads, single-threaded driver, large memory footprint, lack of robustness in exceptional conditions, limited support for distributed measurements, and limited support for embedded devices, among others. However, there are differences between the two regarding the extent to which various of the issues are addressed, described below.","In general, the dynamic system facilitates more dynamic expert collaborations. These dynamic expert collaborations permit each expert to propose multiple, fine-grained partial solutions. These partial solutions may be combined and prioritized such that the most efficient code path may be utilized. However, the branching and prioritization sub-architectures may introduce significant complexities to the design and implementation of the system which may possibly outweigh the benefits gained by these more efficient code paths.","The static system generally results in a larger memory footprint than the dynamic system. In the static system, the appropriate experts and the expert library are almost always loaded when executing a measurement task. In the dynamic system, the experts and expert library may be unloaded once the task enters the verified state or doesn't need to be loaded at all if a persisted task has been instantiated. Thus, trade-offs may be required between high-performance reconfiguration, and features such as persisting the run-time specification and maintaining a strong distinction between configuration and execution.","Ease of use limitations typical of the prior art, such as poor usability, limited integration of devices, hard to synchronize devices, difficult manual routing, diagram cluttered with configuration, non-scalability of applications across hardware, incompatible API layers, inconsistent feature sets across different application development environments (ADE), inconsistent terminology, and limited support for sensors, among others, may also be addressed at different levels by the two embodiments.","The static system addresses almost all of these ease-of-use issues as well as the dynamic system. In fact, due to the de-emphasis of the distinction between configuration and execution, it may be argued that the static system enables even greater usability. In contrast, the dynamic system addresses the hard-to-synchronize-devices issue more thoroughly than the static system. The dynamic system contains general synchronization experts that support a variety of synchronization scenarios as opposed to the device-specific synchronization experts of the static system, as well as more synchronization use cases, such as stimulus-response use cases. Synchronization is thus more broadly supported by the dynamic system. The static system does not support synchronization to the same degree primarily for two reasons. First, there is a class of use cases that involve heterogeneous timing and triggering for which it is neither appropriate nor reasonable for a non-application-specific measurement architecture to satisfy. Second, since the static system has fewer dynamic interactions between experts, other synchronization applications may require experts with more explicit knowledge of the signals and devices involved to support automatic synchronization.","More generally, the dynamic system makes a strong distinction between configuration and execution of a measurement task. This distinction may require customers to realize that configuration and execution are substantially different and that the specification of properties when configuring a task is different from changing specified properties when executing a task. This distinction provides a very clean programming model. However, this model is different from that to which many users are accustomed. As a result, some users may feel that the static system (which doesn't make a strong distinction between configuration and execution) is more usable.","Engineering efficiency limitations characteristic of the prior art, such as poor engineering efficiency, monolithic architecture and releases, risks associated with addition of new features, and redundant software development between development groups, are addressed roughly equally in the two embodiments. These issues are addressed substantially by having a component-based architecture which provides flexibility for future growth and modification.","Beneficial Elements of the Static System Which are Not in the Dynamic System","In addition to the general differences between the two embodiments described above, there are a number of specific design aspects in which the static system has advantages over the dynamic system, described below.","Decision Tree","In the dynamic system there is a potential for performance problems as the number of nodes in the tree grows. While this may be mitigated to some extent by sequencing expert invocation and reducing the number of branches created by the streaming experts, performance problems may still result. For another example, the number of nodes in the decision tree may explode when trying to use branching to solve exponentially complex problems such as choosing timing protocols or resolving matrix switching. Since the relationships between experts in the static system are much more static, and branching is not permitted, the decision tree is pre-built, and thus avoids these problems of the dynamic system.","Error Propagation","In the dynamic system, with many dynamic collaborations between experts, it may be difficult for one expert to reinterpret an error message from another expert to an error message within its context. This reinterpretation may be necessary in order to provide the customer with understandable error messages. Since the relationships between experts in the static system are more static, this reinterpretation may be easier. Additionally, if a decision tree has many branches, all of which fail to find a solution, it may be difficult to prioritize these failed branches to determine which one is the closest to a solution and, therefore, the best failure from which to return an error message. Since the static system eliminates branching, it avoids this issue altogether.","Prioritization of Branches","Prioritizing multiple potential solutions based on default or customer-specified metrics may be difficult, yet very important if the best solutions are to be chosen by the expert system. Prioritization generally adds complexity to the architecture. Another important aspect of prioritization is ensuring that the prioritization heuristics produce consistent and deterministic solutions as the system is upgraded. These issues are avoided by the static system through the elimination of branching. In the static system, all prioritization decisions are made in a local context of a single expert. While the static system doesn't allow for branching or prioritization of solutions derived from customer-specified metrics, this local approach is itself a powerful technique.","Streaming and Control Experts","The static system sub-architectures that contain the streaming and control experts are higher performing and less complicated than the respective sub-architectures in the dynamic system. In the static system, these experts are not intermixed with the device experts. This separation allows these experts to model the operations that they need to perform in a manner that is more specific and more efficient for their particular operations. For example, the static system streaming expert doesn't leverage MSOs, but rather compiles the streaming portion of the run-time from a stream-specific representation. This representation, along with the separation from the device experts, enables the streaming experts to compile more efficient solutions than the dynamic system while remaining just as flexible as the dynamic system streaming experts. Additionally, the experts are more involved in the streaming and control aspects of the system.","Changing Properties On-the-Fly","The method in which properties are changed on-the-fly in the static system is much more efficient and appropriate than that of the dynamic system. The dynamic system facilitates changing of properties both when the task is and is not in the running state. The static system allows changing properties only when the task is in the running state. This has the advantage that most of the property changes are handled by a single code path through the experts as opposed to two different code paths, one in the experts and one in the code to change the primitive on-the-fly.","Run-Time Rebuilding","The static system run-time architecture enables the run-time to be partially rebuilt and updated. This is accomplished by enabling a subset of the run-time's primitives to transition through different states as required. The expert system can update, add, or remove primitive settings from a pre-existing run-time specification. The run-time builder may then examine the updated run-time specification and only the affected primitives through the required states. The static system thus greatly improves performance by allowing the run-time to be partially updated as opposed to completely destroying and rebuilding the run-time as in the dynamic system.","Beneficial Elements of the Dynamic System that are Not in the Static System","There are a number of elements of the dynamic system that are not present in the static system. These elements are the foundation for a number of innovative features.","Associations Between MSOs","In the dynamic system, the associations between MSOs are the primary method of specifying a task. The group MSOs and their associations define the timing and triggering for the task. Also, complex messaging from one event to another is modeled in a generic manner through MSO associations.","However, many associations are utilized in the static system. Most MSOs are categorized as either channel-related or timing-related. The responsibility for managing events and the messages they send resides within the timing experts. In the static system, many of the associations which in the dynamic system are between MSOs are managed by the associations within and between experts.","Generic Nature of Experts","The dynamic system does not significantly distinguish between different types of experts. From the perspective of the API implementation, all experts are treated identically. In the static system, there are a number of specialized expert interfaces (e.g., device, channel, timing, control, reader\/writer, routing) of which the API implementation and the implementation of experts themselves are aware. The lack of the generic nature of experts in the static system reduces the flexibility of the system and increases the effort required to introduce new expert concepts.","Dynamic Matching of MSOs to Experts","In the dynamic system, the matching library may parse an MSO collection and determine, based on expert registrations, which experts should be invoked to solve the specified task. This dynamic matching enables complex streaming and routing problems to be solved in a generic manner and for non-device related experts to interoperate with device experts to solve problems. For example, the routing expert may route a specified generation through a number of multiplexers and to a specific counter. At this point, the expert registered with the counter may match and implement the specified generation. In the static system, the expert cannot register with the counter but must register with all external terminals that can be routed to the counter. This results in a fatter, less cohesive, single expert which handles counter-based measurements and generations as well as digital measurements and generations. Other examples include the ability to support advanced measurements (e.g., power-spectrum measurements).","The static system performs static matching based on the signal path described by the named channel. This approach allows the expert call tree to be determined when the named channel is created and, therefore, created when the task is instantiated. This approach, while less flexible, greatly improves performance.","Separation of Task Specification from Experts","In the dynamic system, the experts do not interact with the task specification while it is being specified. After the task is completely specified, the experts are passed the entire task specification. This has the advantage that the management of the task specification is completely encapsulated and only the interface is shared with the experts. This makes features such as persistence, versioning, and maintenance easier than in the static system where the MSOs are owned and managed by the individual experts. Another advantage is that this clear separation, both in terms of encapsulation as well as interactions, facilitates features such as client-server applications and simulation.","In the static system, there is some encapsulation. The API implementation only accesses the MSOs through their interfaces. Also, if the experts override the default behavior of the MSOs, they inherit from standard base classes which provide support for versioning, persistence, and storage. Finally, the static system enables experts to be more involved when the task is specified which may lead to improved performance since the experts can leverage specialized knowledge to optimize reconfiguration.","Distinction Between Configuration and Execution","The dynamic system makes a strong distinction between the process of configuration and the process of execution. These two processes are treated as separate processes both in space and time. These two processes are implemented in separate applications and are invoked at different times. This model requires customers to completely specify their measurements tasks and then, later and repeatedly, execute these tasks according to the specification. This distinction between configuration and execution is the key to supporting various manifestations of expert knowledge without sacrificing performance. In other words, through compilation, a customer-defined driver may be compiled that can deliver unsurpassed performance during the execution phase while the intelligence, and the corresponding performance hit, occurs during the compilation phase after the configuration process has completed. This clear division of responsibility also makes supporting of distributed measurements, such as embedded measurement devices, much more straightforward.","In contrast, the static system blurs the distinction between configuration and execution. This increases the complexity of some aspects of the architecture in order to support the required level of performance for reconfiguration.","Classical Expert System","The dynamic system provides the foundation for a classical expert system to evolve over time. Some of the key benefits of a classical expert system are branching, prioritization, and the generic nature of experts. There are a number of additional features that may be implemented in the dynamic system. For example, the prioritization may be based upon customer-defined criteria that are used to weigh the possible solutions. Also, the generic nature of experts allows the tight integration of routing, synchronization, streaming, and control. This integration may avoid the N\u00d7N combinatorial explosion of possibilities encountered with multi-device synchronization experts in the new architecture. The dynamic system may evolve over time to satisfy the out-of-the-box configuration requirement in which the expert system determines which devices to use to implement the measurement task and how to connect the appropriate signals to these devices. A classical expert system provides the infrastructure to provide more detailed feedback and error reporting to customers which would lead them towards solving their problems.","While the static system comprises an expert system, in some ways the static expert system may be considered a \u201csystem of experts,\u201d in that, as mentioned above, prioritization issues are handled locally by each expert, branching is omitted, and the experts are not generic, but specialized for particular devices.","Evolution of the Static system","There are some aspects of the dynamic system that, if desired, may be incorporated into the static system. For example, support for the persistence of run-time specifications, finer-grained matching based on more than just terminals (e.g., advanced measurements, phenomenon, etc.), and range-typed properties in MSOs may be achievable with the static system. However, other aspects may not be readily implementable, such as integrating routing, streaming, and control experts with device-centric experts, branching, and, therefore, prioritization.","Thus, in one embodiment, the present system may provide greater flexibility, robustness, and increased functionality over some prior systems while simplifying the design, development, and testing of measurement task implementations. More specifically, by designing the system in a componential manner, as opposed to a monolithic architecture, time to market for new products and maintenance releases may be greatly reduced, due to the fact that individual software components are much easier to build, test, and debug than monolithic systems. Furthermore, because the present system is component-based and extensible, software components for specific devices may be released independently. The present system may define responsibilities of and communication between its constituent software components. This decoupled architecture may allow a new feature to be added in one place, then leveraged by all measurements devices. For example, software components, which may be shared by multiple development groups, may include data-transfer software, signal-routing software, event-messaging software, and resource-reservation software, among others. Other examples of reusability in the present system may include the expert system framework, routing experts, streaming experts, chip experts and topographies, and shared device experts.","In one embodiment, the customer may be required to specify which hardware product performs a given measurement; however, in other embodiments, customer-defined tasks need not specify which hardware to use, i.e., the system may use heuristics or other techniques to determine appropriate hardware for a given measurement task.","Thus, the systems and methods described above with reference to  may provide an architecture and process whereby the user may easily and quickly specify and perform a measurement task, subject to available resources of the system. Additionally, in various embodiments, the present invention may provide a specific optimized solution to the specified measurement task, which accommodates a particular specification of the user, through the use of an expert system.",{"@attributes":{"id":"P-00594","num":"none"},"ul":{"@attributes":{"id":"ul200007","list-style":"none"},"li":["actuator\u2014device used to convert from one phenomenon to another. Typically, the user will need to use an actuator to convert the phenomenon generated by a device to a more useful phenomenon.","application program\u2014a software program which is executable to perform one or more functions, e.g., a software program that is executable to perform one or more specified measurement tasks.","attribute desirability\u2014expressed by clients of the measurements expert system or measurements experts themselves. Specifies preferences (weighting) for the value of a specification attribute when there exists multiple possibilities.","branch\u2014a proposal made by a measurements expert to extend a partial solution. Measurements experts may present several possibilities for extending one partial solution, effectively branching that partial solution into several independent partial solutions.","channel\u2014hardware and software resources used to make a measurement or a generation. Hardware resources of a channel include I\/O connector resources and internal resources such as filters, ADC, counters, and the like. Software resources of a channel include scaling, analysis, transfer, and the like. Experts may choose the optimal attribute settings for a channel based on the task specification.","compile\u2014the act of the measurements expert system solving a problem, effectively transforming a measurement task specification into a complete run-time specification. The term \u201ccompile\u201d also refers to converting a software program from source code into executable object code.","complete solution\u2014a collection of decisions in which the measurement task specification has been fully solved by measurements experts.","completeness\u2014a quantification of how close a measurement task specification is to being solved. The measurements expert system currently expresses this in the form of an estimate.","connection\u2014a link between a two terminals. Physical manifestation of a connection could be a wire, trace, or infrared link.","constraints\u2014associated Boolean expressions of a solution that must be satisfied for the solution to meet the designer's needs. Example constraints include an attribute expression where measurable attributes include: price, maximum latency, throughput, determinism, accuracy, precision, and mass. An example expression could be (price <$5000). Other constraints may be fixed hardware settings (i.e. jumpered settings), limited resources (memory, computational power, counters, terminals), fixed hardware connectivity or fixed phenomenon connectivity, or artificial user constraints (i.e. gain must be 1)","cost\u2014a composite measurement of attribute desirability, complexity, and resource consumption achieved by a particular solution. The measurements expert system uses costs and estimates to prioritize solutions. When selecting complete solutions, the measurements expert system chooses those complete solutions with the least cost. When selecting partial solutions, the measurements expert system chooses those partial solutions with the least cost and the lowest estimate of work remaining. Also referred to as a metric.","data store\u2014destination specified for samples from a measurement, or source of updates specified for a generation.","decision\u2014encapsulates a single extension of a partial solution. Measurements experts create one or more decisions based on their inputs which may be a measurement task specification. These decisions are either branched or failed","event\u2014used to control the timing and triggering of a measurement, generation, or connection. Users indicate timing and triggering by associating events with measurements, generations, and connections through messages. Users register observers with events to receive notifications while the task is running. The source of the event is often a hardware resource, but may be a software program, as well. Events can also be associated with other events to construct more complex events.","failed solution\u2014a partial solution terminated by a failed decision.","generation\u2014production of a phenomenon, or a process which produces a phenomenon.","generation specification\u2014a specification for the generation of a phenomenon, which might include the type of generation (waveform, sine wave, control function), and other attributes of the generation (amplitude, frequency, etc.)","independent\u2014a specification is considered independent if it can be solved serially with any other specifications in a given measurement task specification.","measurement\u2014the retrieval of one or more characteristics of a phenomenon in order to produce a useful sample of information. For example, measurements may be performed by instruments or other types of devices which acquire real world data. Measurements may be performed for the purposes of simulation, hardware in the loop testing, validation, test, instrumentation, and manufacturing assembly, among other purposes.","measurement device\u2014a hardware or virtual device which is operable to perform a measurement on a phenomenon, a generation of a phenomenon, or a connection. Example measurement devices include any of the devices shown in .","measurement expert registry\u2014a data structure correlating one or more experts with respective types of measurement tasks. The registry may be used by an expert system to select experts to populate run-time specifications for a given measurement task.","measurement expert system\u2014a software program which may compile a measurement task specification into a run-time specification by selecting and invoking one or more experts.","measurement specification\u2014a specification for the measurement of a phenomenon, which may include the type of measurement (e.g., present-value, frequency), other attributes of the measurement, and preferences of the measurement (e.g., accuracy, precision, throughput, latency).","measurement specification object (MSO)\u2014the atomic objects used to describe concepts in the measurements domain. Measurement specification objects are associated to form a measurement task specification.","measurement task\u2014a group of measurements, generations, and connections that share timing, synchronization, and control.","measurement task configuration tool\u2014a software program which may be used to configure measurement tasks; this may be a general purpose development tool or a specific tool; a type of a measurement task specifier, below.","measurement task specification\u2014a set of phenomena specifications, measurement specifications, generation specifications, timing specifications, and program specifications that comprise a measurement and automation application. A collection of one or more related specifications. Conceptually, the contents of a task specification represent one task which a customer would like to solve atomically. The measurements expert system uses measurements experts to compile a task specification into a populated run-time specification.","measurement task specifier\u2014a program which accepts user input and may be used to produce a measurement task specification for a given measurement task; similar to a task configuration tool, below. An example measurement task specifier is a measurement task configuration tool which may be invoked from a graphical or text-based development environment. Other examples of a measurement task specifier include a measurement task wizard, and a measurement task API. Specific examples of a measurement task specifier include LabVIEW, LabWindows\/CVI, DiaDem, DasyLab, Visual Basic, Visual C++, Delphi, Mathwork's Simulink, Agilent Vee, SoftWire, and other similar programming development environments.","measurements expert\u2014a type of expert designed to operate under arbitration of the Measurements Experts Library. The goal of a measurements expert is to compile a portion of a measurement task specification into a populated run-time specification.","partial solution\u2014a collection of decisions for which no complete solution for the measurement task specification has yet been found.","phenomenon\u2014a detectable signal. Users make measurements on phenomena, or generate them. Sensors and actuators convert from one phenomenon to another.","phenomenon specification\u2014a characterization of a phenomenon in the real world, containing information about the type of the phenomenon (such as voltage, temperature, rotation speed, area luminosity, etc.), and characteristics of that phenomenon (such as range, bandwidth, shape, periodicity, etc.).","preferences\u2014a formula that qualifies how well a solution meets a designer's needs. An example formula is f(mass), where f is the square of mass, such that less mass is a better solution. Another example is g(maximum latency, throughput) where g is a formula that calculates the throughput less 1000 times the maximum latency. In this case, a higher value for g is a better solution for the user (an identical concept is the \u201ccost\u201d function of a solution).","primitive\u2014a single, cohesive object implementing a particular aspect of a measurement system. Primitive supervisors broker primitives. A run-time is composed of an aggregation of primitives.","primitive setting\u2014a collection of properties associated with a particular primitive. Primitive settings are configured by measurements experts, and interpreted by primitive supervisors.","primitive supervisor\u2014invoked by run-time builders, primitive supervisors interpret a specific primitive setting, using the contained properties to reserve an associated primitive.","reader\u2014used to retrieve samples from a data source. Readers may be specific to the data source and the attributes will reflect this. For example, a buffer reader may have a parameter to indicate where in the buffer to retrieve data from.","resource\u2014a single, reservable element of the total means available for performing measurements in a measurement system. Examples of resources include a hardware counter, a RTSI line, or a fixed amount of CPU cycles.","run-time\u2014a collection or sequence of primitives in a specific environment implementing a measurement system. Run-times are built by run-time builders, and may be executed to perform a specific measurement task or operation. The term \u201crun-time\u201d may also refer to other forms of a software program that implement a measurement system.","run-time builder\u2014a software program which may analyze a run-time specification, reserve one or more primitives according to the run-time specification, and configure one or more primitives according to the run-time specification. Interprets a particular run-time specification and builds a run-time. Primitive brokering is delegated to primitive supervisors. The term \u201crun-time builder\u201d may also refer to a software program which may analyze a run-time specification and configure other types of software entities, such as by configuring other types of software program(s) or data structures according to the run-time specification.","run-time specification\u2014a set of parameters specifying hardware or software primitive configurations required for a specified measurement task. A collection of primitive settings populated by measurements experts. Run-time specifications are interpreted by run-time supervisors. The term \u201crun-time specification\u201d may also include a data structure or other representation of information that specifies a measurement task.","sensor\u2014device used to convert from one phenomenon type to another. Typically, the user will need to use a sensor to convert the phenomenon to a type the device can sample. Example sensors include thermocouples, pressure transducers, cameras, etc.","solution\u2014a complete solution, failed solution, or partial solution.","solution builder\u2014a self-contained piece of expert logic (\u201cexpertise\u201d) used to perform post-processing on a complete or failed solution. Measurements experts attach solution builders to decisions at solution-time when a partial solution is expanded. Deployed solution builders are invoked when a complete or failed solution is selected by the measurements expert system.","specification attribute\u2014a data member of a measurement specification object. Used to describe some characteristic of a particular object.","terminal\u2014a physical location on a measurement device, cable, terminal block, accessory, or other measurement product where an phenomenon resides. For example, a terminal may be a connector on a terminal block, a pin on an ASIC, or the end of a thermocouple.","terminal configuration\u2014a collection of terminals with a specified usage. Examples of terminal configurations are referenced single-ended, non-referenced single-ended, two-wire differential, and four-wire excitation.","timing specification\u2014a specification for the timing of measurements, generations, and control functions in the systems. Timing can include specification of synchronized measurement and generation, timed sequences and constraints on the completion of tasks.","virtual measurement device\u2014a device which is implemented as a software program, or at least a portion of which is implemented as a software program.","writer\u2014used to write updates to a data store. Writers are generally specific to the data store and the attributes will reflect this. For example, a buffer writer may have a parameter to indicate where in the buffer to write data to."]}},"Although the embodiments above have been described in considerable detail, numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A better understanding of the present invention can be obtained when the following detailed description of the preferred embodiment is considered in conjunction with the following drawings, in which:",{"@attributes":{"id":"P-00060","num":"00060"},"figref":"FIGS. 1A and 1B"},{"@attributes":{"id":"P-00061","num":"00061"},"figref":["FIG. 2","FIGS. 1A and 1B"]},{"@attributes":{"id":"P-00062","num":"00062"},"figref":"FIG. 3"},{"@attributes":{"id":"P-00063","num":"00063"},"figref":"FIG. 4"},{"@attributes":{"id":"P-00064","num":"00064"},"figref":"FIG. 5"},{"@attributes":{"id":"P-00065","num":"00065"},"figref":"FIG. 6"},{"@attributes":{"id":"P-00066","num":"00066"},"figref":"FIG. 7A"},{"@attributes":{"id":"P-00067","num":"00067"},"figref":"FIG. 7B"},{"@attributes":{"id":"P-00068","num":"00068"},"figref":"FIG. 7C"},{"@attributes":{"id":"P-00069","num":"00069"},"figref":"FIG. 7D"},{"@attributes":{"id":"P-00070","num":"00070"},"figref":"FIG. 8A"},{"@attributes":{"id":"P-00071","num":"00071"},"figref":"FIG. 8B"},{"@attributes":{"id":"P-00072","num":"00072"},"figref":"FIG. 8C"},{"@attributes":{"id":"P-00073","num":"00073"},"figref":"FIG. 8D"},{"@attributes":{"id":"P-00074","num":"00074"},"figref":"FIG. 9"},{"@attributes":{"id":"P-00075","num":"00075"},"figref":"FIG. 10"},{"@attributes":{"id":"P-00076","num":"00076"},"figref":"FIG. 11"},{"@attributes":{"id":"P-00077","num":"00077"},"figref":"FIGS. 12A-12D"},{"@attributes":{"id":"P-00078","num":"00078"},"figref":"FIG. 13"},{"@attributes":{"id":"P-00079","num":"00079"},"figref":"FIG. 14"},{"@attributes":{"id":"P-00080","num":"00080"},"figref":"FIG. 15"},{"@attributes":{"id":"P-00081","num":"00081"},"figref":"FIG. 16"},{"@attributes":{"id":"P-00082","num":"00082"},"figref":"FIG. 17"},{"@attributes":{"id":"P-00083","num":"00083"},"figref":"FIG. 18"},{"@attributes":{"id":"P-00084","num":"00084"},"figref":"FIG. 19"},{"@attributes":{"id":"P-00085","num":"00085"},"figref":"FIG. 20"},{"@attributes":{"id":"P-00086","num":"00086"},"figref":"FIG. 21"},{"@attributes":{"id":"P-00087","num":"00087"},"figref":"FIG. 22"},{"@attributes":{"id":"P-00088","num":"00088"},"figref":"FIG. 23"},{"@attributes":{"id":"P-00089","num":"00089"},"figref":"FIG. 24A"},{"@attributes":{"id":"P-00090","num":"00090"},"figref":"FIG. 24B"},{"@attributes":{"id":"P-00091","num":"00091"},"figref":"FIG. 24C"},{"@attributes":{"id":"P-00092","num":"00092"},"figref":"FIG. 24D"},{"@attributes":{"id":"P-00093","num":"00093"},"figref":"FIG. 24E"},{"@attributes":{"id":"P-00094","num":"00094"},"figref":"FIG. 24F"},{"@attributes":{"id":"P-00095","num":"00095"},"figref":"FIG. 25"},{"@attributes":{"id":"P-00096","num":"00096"},"figref":"FIG. 26"},{"@attributes":{"id":"P-00097","num":"00097"},"figref":"FIG. 27"},{"@attributes":{"id":"P-00098","num":"00098"},"figref":"FIG. 28"},{"@attributes":{"id":"P-00099","num":"00099"},"figref":"FIG. 29"},{"@attributes":{"id":"P-00100","num":"00100"},"figref":"FIG. 30"},{"@attributes":{"id":"P-00101","num":"00101"},"figref":"FIG. 31"},{"@attributes":{"id":"P-00102","num":"00102"},"figref":["FIG. 32","FIG. 31"]},{"@attributes":{"id":"P-00103","num":"00103"},"figref":"FIG. 33"},{"@attributes":{"id":"P-00104","num":"00104"},"figref":["FIG. 34","FIG. 33"]},{"@attributes":{"id":"P-00105","num":"00105"},"figref":"FIG. 35"},{"@attributes":{"id":"P-00106","num":"00106"},"figref":["FIG. 36","FIG. 35"]},{"@attributes":{"id":"P-00107","num":"00107"},"figref":"FIG. 37"},{"@attributes":{"id":"P-00108","num":"00108"},"figref":"FIG. 38"},{"@attributes":{"id":"P-00109","num":"00109"},"figref":"FIG. 39A"},{"@attributes":{"id":"P-00110","num":"00110"},"figref":"FIG. 39B"},{"@attributes":{"id":"P-00111","num":"00111"},"figref":"FIG. 40A"},{"@attributes":{"id":"P-00112","num":"00112"},"figref":"FIG. 40B"},{"@attributes":{"id":"P-00113","num":"00113"},"figref":"FIG. 41A"},{"@attributes":{"id":"P-00114","num":"00114"},"figref":"FIG. 41B"},{"@attributes":{"id":"P-00115","num":"00115"},"figref":"FIG. 42"},{"@attributes":{"id":"P-00116","num":"00116"},"figref":"FIG. 43A"},{"@attributes":{"id":"P-00117","num":"00117"},"figref":"FIG. 43B"},{"@attributes":{"id":"P-00118","num":"00118"},"figref":"FIG. 43C"},{"@attributes":{"id":"P-00119","num":"00119"},"figref":"FIG. 43D"},{"@attributes":{"id":"P-00120","num":"00120"},"figref":"FIG. 44A"},{"@attributes":{"id":"P-00121","num":"00121"},"figref":"FIG. 44B"},{"@attributes":{"id":"P-00122","num":"00122"},"figref":"FIG. 44C"},{"@attributes":{"id":"P-00123","num":"00123"},"figref":"FIG. 45A"},{"@attributes":{"id":"P-00124","num":"00124"},"figref":"FIG. 45B"},{"@attributes":{"id":"P-00125","num":"00125"},"figref":"FIG. 45C"}]},"DETDESC":[{},{}]}
