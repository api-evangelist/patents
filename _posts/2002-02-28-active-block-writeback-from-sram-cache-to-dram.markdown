---
title: Active block write-back from SRAM cache to DRAM
abstract: An external cache management unit for use with 3D-RAM and suitable for use in a computer graphics system is described. The unit maintains and tracks the status of level one cache memory in the 3D-RAM. The unit identifies dirty blocks of cache memory and prioritizes block cleansing based on a least used algorithm. Periodic block cleansing during empty memory cycles is provided for, and may also be prompted on demand.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07027064&OS=07027064&RS=07027064
owner: Sun Microsystems, Inc.
number: 07027064
owner_city: Santa Clara
owner_country: US
publication_date: 20020228
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["1. Field of the Invention","This invention relates generally to the field of computer graphics and, more particularly, to graphics frame buffer architecture.","2. Description of the Related Art","With each new generation of graphics system, there is more image data to process and less time in which to process it. This consistent increase in data and data rates places additional burden on the memory systems that form an integral part of the graphics system. Attempts to further improve graphics system performance are now running up against the limitations of these memory systems in general, and memory device limitations in particular.","In order to provide memory systems with increased data handling rates and capacities, system architects may employ consistently higher levels of integration. One example of increased integration is the 3D-RAM family of memories from the Mitsubishi Corporation. The 3D-RAM incorporates four banks of DRAM main storage with level one and level two cache memories, and a bank-swapped shift register capable of providing an uninterrupted stream of sequential data at current pixel clock speeds.","Some previous incarnations of the 3D-RAM architecture have included cache management functions as well. In these older devices, circuitry was integrated to allow for the efficient write-back of modified or \u201cdirty\u201d data in the level one cache to the level two cache, and ultimately back to the DRAM. However, as these devices have grown in capacity and performance, it has become increasingly difficult and costly to integrate these cache management functions. In the most recent 3D-RAM device, the 3D-RAM64 these cache management functions have been abandoned altogether having finally become economically infeasible. Despite exclusion from the 3D-RAM devices, these cache management functions are still desirable as they may significantly increase memory performance by mitigating the penalties associated with level one cache misses. For these reasons, a system and method for externally managing the cache memory of 3D-RAM devices employed in graphics systems is desired.","The problems set forth above may at least in part be solved in some embodiments by a system or method for managing a 3D-RAM cache through the employment of external dirty tag bits and LRU (i.e., least recently used) registers. In one embodiment, the system may include a memory array of 3D-RAM devices configured to receive and store pixel data. A memory request processor may be connected to the memory and may be configured to maintain an array of dirty tag bits (i.e., setting and clearing the logic state of the dirty tag bits in response to cache requests and pixel write operations) and a list of LRU registers. The level one cache of the 3D-RAM may be divided into logical blocks, with one dirty tag bit and one LRU register associated with each block. The memory request processor may be further configured to periodically synchronize the pixel data in the 3D-RAM level two and level one caches by commanding level one cache write-backs of blocks according to the contents of the LRU registers and dirty tag bits.","As noted above, a method for managing 3D-RAM cache through the employment of external dirty tag bits and LRU registers is also contemplated. In one embodiment, the method includes maintaining a set of LRU registers as a part of processing external accesses to the level one cache. The contents of the LRU registers may be used to order the blocks according to recent accesses (i.e., the block or blocks identified as being least recently used are given block cleansing priority). The dirty tag bits may be maintained as a part of processing external writes to the level one cache, and as a part of processing internal cache to cache block transfers. Periodically the blocks may be examined in the order suggested by the LRU registers. Next, blocks indicated by the associated dirty tag bits as dirty may be cleansed by writing-back the blocks to the level two cache during the next empty memory cycle. Next, the dirty tag bits associated with the transferred blocks are returned to a state indicating the blocks are clean, and available for allocation.","In one embodiment, the cache management system may be integrated into a graphics system suitable for creating and displaying graphic images. In other embodiments, the system may be part of an optional assembly, communicating with a host graphics system through the use of a data or control bus specific to the host.","While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents, and alternatives falling within the spirit and scope of the present invention as defined by the appended claims. Please note that the section headings used herein are for organizational purposes only and are not meant to limit the description or claims. The word \u201cmay\u201d is used in this application in a permissive sense (i.e., having the potential to, being able to), not a mandatory sense (i.e., must). Similarly, the word include, and derivations thereof, are used herein to mean \u201cincluding, but not limited to.\u201d","Computer System\u2014","Referring now to , one embodiment of a computer system  that includes a graphics system that may be used to implement one embodiment of the invention is shown. The graphics system may be comprised in any of various systems, including a computer system, network PC, Internet appliance, a television, including HDTV systems and interactive television systems, personal digital assistants (PDAs), virtual reality systems, and other devices which display 2D and or 3D graphics, among others.","As shown, the computer system  comprises a system unit  and a video monitor or display device  coupled to the system unit . The display device  may be any of various types of display monitors or devices (e.g., a CRT, LCD, or gas-plasma display). Various input devices may be connected to the computer system, including a keyboard  and\/or a mouse , or other input device (e.g., a trackball, digitizer, tablet, six-degree of freedom input device, head tracker, eye tracker, data glove, or body sensors). Application software may be executed by the computer system  to display graphical objects on display device .","Computer System Block Diagram\u2014","Referring now to , a simplified block diagram illustrating the computer system of  is shown. Elements of the computer system that are not necessary for an understanding of the present invention are not shown for convenience. As shown, the computer system  includes a central processing unit (CPU)  coupled to a high-speed memory bus or system bus  also referred to as the host bus . A system memory  may also be coupled to high-speed bus .","Host processor  may comprise one or more processors of varying types, e.g., microprocessors, multi-processors and CPUs. The system memory  may comprise any combination of different types of memory subsystems, including random access memories, (e.g., static random access memories or \u201cSRAMs,\u201d synchronous dynamic random access memories or \u201cSDRAMs,\u201d and Rambus dynamic random access memories or \u201cRDRAM,\u201d among others) and mass storage devices. The system bus or host bus  may comprise one or more communication or host computer buses (for communication between host processors, CPUs, and memory subsystems) as well as specialized subsystem buses.","In , a graphics system  is coupled to the high-speed memory bus . The 3-D graphics system  may be coupled to the bus  by, for example, a crossbar switch or other bus connectivity logic. It is assumed that various other peripheral devices, or other buses, may be connected to the high-speed memory bus . It is noted that the graphics system may be coupled to one or more of the buses in computer system  and\/or may be coupled to various types of buses. In addition, the graphics system may be coupled to a communication port and thereby directly receive graphics data from an external source, e.g., the Internet or a network. As shown in the figure, one or more display devices  may be connected to the graphics system  comprised in the computer system .","Host CPU  may transfer information to and from the graphics system  according to a programmed input\/output (I\/O) protocol over host bus . Alternately, graphics system  may access the memory subsystem  according to a direct memory access (DMA) protocol or through intelligent bus mastering.","A graphics application program conforming to an application programming interface (API) such as OpenGL or Java 3D may execute on host CPU  and generate commands and data that define a geometric primitive (graphics data) such as a polygon for output on display device . As defined by the particular graphics interface used, these primitives may have separate color properties for the front and back surfaces. Host processor  may transfer this graphics data to memory subsystem . Thereafter, the host processor  may operate to transfer the graphics data to the graphics system  over the host bus . In another embodiment, the graphics system  may read in geometry data arrays over the host bus  using DMA access cycles. In yet another embodiment, the graphics system  may be coupled to the system memory  through a direct port, such as the Advanced Graphics Port (AGP) promulgated by Intel Corporation.","The graphics system may receive graphics data from any of various sources, including the host CPU  and\/or the system memory , other memory, or from an external source such as a network, e.g., the Internet, or from a broadcast medium, e.g., television, or from other sources.","Note while graphics system  is depicted as part of computer system , graphics system  may also be configured as a stand-alone device (e.g., with its own built-in display). Graphics system  may also be configured as a single chip device or as part of a system-on-a-chip or a multi-chip module. Additionally, in some embodiments, certain elements of the illustrated graphics system  may be implemented in software.","Graphics System\u2014","Referring now to , a functional block diagram illustrating one embodiment of graphics system  is shown. Note that many other embodiments of graphics system  are possible and contemplated. Graphics system  may comprise one or more media processors , one or more hardware accelerators , one or more texture buffers , one or more frame buffers , and one or more video output processors . Graphics system  may also comprise one or more output devices such as digital-to-analog converters (DACs) , video encoders , flat-panel-display drivers (not shown), and\/or video projectors (not shown). Media processor  and\/or hardware accelerator  may be any suitable type of high performance processor (e.g., specialized graphics processors or calculation units, multimedia processors, DSPs, or general purpose processors).","In some embodiments, one or more of these components may be removed. For example, the texture buffer may not be included in an embodiment that does not provide texture mapping. In other embodiments, all or part of the functionality implemented in either or both of the media processor or the graphics accelerator may be implemented in software.","In some embodiments, media processor  and hardware accelerator  may be comprised within the same integrated circuit. In other embodiments, portions of media processor  and\/or hardware accelerator  may be comprised within separate integrated circuits.","As shown, graphics system  may include an interface to a host bus such as host bus  in  to enable graphics system  to communicate with a host system such as computer system . More particularly, host bus  may allow a host processor to send commands to the graphics system . In one embodiment, host bus  may be a bi-directional bus.","Each functional block of graphics system  is described in more detail below.","Media Processor\u2014",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 4","b":["14","14","112","80","112","80","14"]},"Transformation refers to manipulating an object and includes translating the object (i.e., moving the object to a different location), scaling the object (i.e., stretching or shrinking), and rotating the object (e.g., in three-dimensional space, or \u201c3-space\u201d).","Lighting refers to calculating the illumination of the objects within the displayed image to determine what color and or brightness each individual object will have. Depending upon the shading algorithm being used (e.g., constant, Gourand, or Phong), lighting may be evaluated at a number of different locations. For example, if constant shading is used (i.e., each pixel of a polygon has the same lighting), then the lighting need only be calculated once per polygon. If Gourand shading is used, then the lighting is calculated once per vertex. Phong shading calculates the lighting on a per-pixel basis.","As illustrated, media processor  may be configured to receive graphical data via host interface . A graphics queue  may be included in media processor  to buffer a stream of data received via the accelerated port of host interface . The received graphics data may comprise one or more graphics primitives. As used herein, the term graphics primitive may include polygons, parametric surfaces, splines, NURBS (non-uniform rational B-splines), sub-divisions surfaces, fractals, volume primitives, voxels (i.e., three-dimensional pixels), and particle systems. In one embodiment, media processor  may also include a geometry data preprocessor  and one or more microprocessor units (MPUs) . MPUs  may be configured to perform vertex transform and lighting calculations and programmable functions and to send results to hardware accelerator . MPUs  may also have read\/write access to texels (i.e. the smallest addressable unit of a texture map, which is used to \u201cwallpaper\u201d a three-dimensional object) and pixels in the hardware accelerator . Geometry data preprocessor  may be configured to decompress geometry, to convert and format vertex data, to dispatch vertices and instructions to the MPUs , and to send vertex and attribute tags or register data to hardware accelerator .","As shown, media processor  may have other possible interfaces, including an interface to a memory. For example, as shown, media processor  may include direct Rambus interface  to a direct Rambus DRAM (DRDRAM) . A memory such as DRDRAM  may be used for program and data storage for MPUs . DRDRAM  may also be used to store display lists and\/or vertex texture maps.","Media processor  may also include interfaces to other functional components of graphics system . For example, media processor  may have an interface to another specialized processor such as hardware accelerator . In the illustrated embodiment, controller  includes an accelerated port path that allows media processor  to control hardware accelerator . Media processor  may also include a direct interface, such as bus interface unit (BIU) , which provides a direct port path to memory  and to hardware accelerator  and video output processor  via controller .","Hardware Accelerator\u2014","One or more hardware accelerators  may be configured to receive graphics instructions and data from media processor  and then to perform a number of functions on the received data according to the received instructions. For example, hardware accelerator  may be configured to perform rasterization, 2D or 3D texturing, pixel transfers, imaging, fragment processing, clipping, depth cueing, transparency processing, set-up, and\/or screen space rendering of various graphics primitives occurring within the graphics data. Each of these features is described separately below.","Clipping refers to the elimination of graphics primitives or portions of graphics primitives that lie outside of a 3D view volume in world space. The 3D view volume may represent that portion of world space that is visible to a virtual observer (or virtual camera) situated in world space. For example, the view volume may be a solid truncated pyramid generated by a 2D view window and a viewpoint located in world space. The solid truncated pyramid may be imagined as the union of all rays emanating from the viewpoint and passing through the view window. The viewpoint may represent the world space location of the virtual observer. In most cases, primitives or portions of primitives that lie outside the 3D view volume are not currently visible and may be eliminated from further processing. Primitives or portions of primitives that lie inside the 3D view volume are candidates for projection onto the 2D view window.","Set-up refers to mapping primitives to a three-dimensional viewport. This involves translating and transforming the objects from their original \u201cworld-coordinate\u201d system to the established viewport's coordinates. This creates the correct perspective for three-dimensional objects displayed on the screen.","Screen-space rendering refers to the calculation performed to generate the data used to form each pixel that will be displayed. For example, hardware accelerator  may calculate \u201csamples.\u201d Samples are points have color information but no real area. Samples allow hardware accelerator  to \u201csuper-sample,\u201d or calculate more than one sample per pixel. Super-sampling may result in a higher quality image.","Hardware accelerator  may also include several interfaces. For example, in the illustrated embodiment, hardware accelerator  has four interfaces. Hardware accelerator  has an interface  (referred to as the \u201cNorth Interface\u201d) to communicate with media processor . Hardware accelerator  may also be configured to receive commands from media processor  through this interface. Additionally, hardware accelerator  may include an interface  to bus . Bus  may connect hardware accelerator  to boot PROM  and\/or video output processor . Boot PROM  may be configured to store system initialization data and\/or control code for frame buffer . Hardware accelerator  may also include an interface to a texture buffer . For example, hardware accelerator  may interface to texture buffer  using an eight-way interleaved texel bus that allows hardware accelerator  to read from and write to texture buffer . Hardware accelerator  may also interface to a frame buffer . For example, hardware accelerator  may be configured to read from and\/or write to frame buffer  using a four-way interleaved pixel bus.","The vertex processor  may be configured to use the vertex tags received from the media processor  to perform ordered assembly of the vertex data from the MPUs . Vertices may be saved in and\/or retrieved from a mesh buffer .","The render pipeline  may be configured to receive vertices and convert them to fragments. The render pipeline  may be configured to rasterize 2D window system primitives (e.g., dots, fonts, Bresenham lines, polygons, rectangles, fast fills, and BLITs (Bit Block Transfers, which move a rectangular block of bits from main memory into display memory, which may speed the display of moving objects on screen)) and 3D primitives (e.g., smooth and large dots, smooth and wide DDA (Digital Differential Analyzer) lines, triangles, polygons, and fast clear) into pixel fragments. The render pipeline  may be configured to handle full-screen size primitives, to calculate plane and edge slopes, and to interpolate data down to pixel tile resolution using interpolants or components such as r, g, b (i.e., red, green, and blue vertex color); r2, g2, b2 (i.e., red, green, and blue specular color from lit textures); a (alpha); and z, s, t, r, and w (texture components).","In embodiments using supersampling, the sample generator  may be configured to generate samples from the fragments output by the render pipeline  and to determine which samples are inside the rasterization edge. Sample positions may be defined in loadable tables to enable stochastic sampling patterns.","Hardware accelerator  may be configured to write textured fragments from 3D primitives to frame buffer . The render pipeline  may send pixel tiles defining r, s, t and w to the texture address unit . The texture address unit  may determine the set of neighboring texels that are addressed by the fragment(s), as well as the interpolation coefficients for the texture filter, and write texels to the texture buffer . The texture buffer  may be interleaved to obtain as many neighboring texels as possible in each clock. The texture filter  may perform bilinear, trilinear or quadlinear interpolation. The pixel transfer unit  may also scale and bias and\/or lookup texels. The texture environment  may apply texels to samples produced by the sample generator . The texture environment  may also be used to perform geometric transformations on images (e.g., bilinear scale, rotate, flip) as well as to perform other image filtering operations on texture buffer image data (e.g., bicubic scale and convolutions).","In the illustrated embodiment, the pixel transfer MUX  controls the input to the pixel transfer unit . The pixel transfer unit  may selectively unpack pixel data received via north interface , select channels from either the frame buffer  or the texture buffer , or select data received from the texture filter  or sample filter .","The pixel transfer unit  may be used to perform scale, bias, and\/or color matrix operations, color lookup operations, histogram operations, accumulation operations, normalization operations, and\/or min\/max functions. Depending on the source of and operations performed on the processed data, the pixel transfer unit  may then output the data to the texture buffer  (via the texture buffer MUX ), the frame buffer  (via the texture environment unit  and the fragment processor ), or to the host (via north interface ). For example, in one embodiment, when the pixel transfer unit  receives pixel data from the host via the pixel transfer MUX , the pixel transfer unit  may be used to perform a scale and bias or color matrix operation, followed by a color lookup or histogram operation, followed by a min\/max function. The pixel transfer unit  may then output data to either the texture buffer  or the frame buffer .","Fragment processor  may be used to perform standard fragment processing operations such as the OpenGL fragment processing operations. For example, the fragment processor  may be configured to perform the following operations: fog, area pattern, scissor, alpha\/color test, ownership test (WID), stencil test, depth test, alpha blends or logic ops (ROP), plane masking, buffer selection, pick hit\/occlusion detection, and\/or auxiliary clipping in order to accelerate overlapping windows.","Texture Buffer\u2014","Texture buffer  may include several SDRAMs. Texture buffer  may be configured to store texture maps, image processing buffers, and accumulation buffers for hardware accelerator . Texture buffer  may have many different capacities (e.g., depending on the type of SDRAM included in texture buffer ). In some embodiments, each pair of SDRAMs may be independently row and column addressable.","Frame Buffer ","One or more frame buffers  may be configured to receive and store data samples from hardware accelerator . In one embodiment, the frame buffer  may take the form illustrated in . In this example, the frame buffer interface  may be configured to receive requests and data from the fragment processor . These requests may be for the storage, retrieval, or manipulation of pixel data. In processing these requests, the frame buffer interface may determine what portion of the memory array  contains the requested data, test for cache hits, and schedule requests to the memory array , in addition to other functions as explained in greater detail below.","The memory array  may be configured to receive controls from the frame buffer interface . In response to these controls, the memory array  may perform data storage and retrieval, fetches, cache write-backs, and other operations. Pixel data may be transferred bi-directionally between the memory array  and the fragment processor  either as individual pixels or tiles of pixels (i.e., an array of neighboring pixels). The memory array  may also be further configured to output a continuous stream of pixels to the video processor .","In one embodiment, the memory array  may employ one or more 3D-RAM  memory devices. Turning now to , a simplified block diagram of one possible 3D-RAM configuration is illustrated. The total storage capacity of the device may be divided equally among four DRAM banks . Each bank may be further subdivided into a number of pages that represent the smallest unit of data in a DRAM bank  which may be accessed directly. All four DRAM banks  respond to a common page address to form a page group.","To facilitate accessing pixel data within a page, each DRAM bank  may be furnished with a level two cache . In this example, the level two cache  is sized appropriately to hold one entire page of data and may in some cases be referred to as a \u201cpage buffer\u201d. Hence, as commands are issued to the 3D-RAM  that result in the access of pixels within the DRAM, entire pages are transferred between the DRAM and the level two cache . In some embodiments, this level two cache may be configured as a write-through cache (i.e., as data is written to the cache, the data is also written through to the DRAM).","Each page of storage may be further subdivided into blocks that represent the smallest unit of data that may be transferred between the level two cache  and the SRAM pixel cache  (described in detail below). In this example, the global data bus  is connected to the level two cache  and the SRAM pixel cache  and is sized appropriately to allow for the parallel transfer of an entire block of pixels. The global data bus  is bi-directional and transfers blocks of data from the level two cache  to the SRAM pixel cache  during block fetches, and in the opposite direction while performing cache write-backs.","The SRAM pixel cache  may constitute a level one cache memory, configured so that a single cache tag entry corresponds to a block of pixel data. In this configuration, each block in the SRAM pixel cache  contains spatially relevant or contiguous pixel data. The blocks themselves, however, may not be contiguous. Additionally, each block of pixels in the SRAM pixel cache  may correspond to data stored in one and only one DRAM bank .","In one embodiment, the SRAM pixel cache  may be a triple ported memory, with one bidirectional port dedicated to the transfer of data between the SRAM and the level two caches . The second port may be a dedicated input and receive the output of the arithmetic logic unit (ALU)  that is described below. The third port may be a dedicated output that may be utilized to furnish the ALU  with an operand, or to communicate pixel data to circuitry outside the 3D-RAM .","The ALU  receives inbound pixel data communicated from circuitry outside of the 3D-RAM  as one operand. The second operand is fetched from a storage location within the SRAM pixel cache . The ALU may be configured to implement a number of mathematical functions on the operands in order to effect the combination or blending of new pixel data with data existing in the 3D-RAM . An example of one such operation may be a weighted sum, wherein pixel data is weighted and combined according to some level of transparency. The ALU  thus allows the 3D-RAM  to transform many read-modify-write operations into write-mostly operations.","The 3D-RAM  may also be equipped with two video buffer\/shift registers . These shift registers are configured as parallel-in-serial-out devices, which may be broadside loaded with full or partial display lines of pixel data. The shift registers  may then output the data sequentially in response to an external pixel clock. In order to provide for a continuous stream of pixels at the video output, the two shift registers may alternate duty (i.e., one loading data while the other is outputting data). The outputs of the two shift registers may then be combined in to a single stream of video data by a multiplexer .","Turning now to , one embodiment of the memory array  is shown. In this example, 3D-RAM devices  are employed, and the array is segmented to facilitate the storage of tiles of pixels or samples. A tile of pixel data is delivered to the bi-directional data interface  from the fragment processor . Within the data interface  the tile may be buffered and the pixels comprising the tile may be reordered to maintain the spatial interrelationship of the pixels. In this embodiment of the memory array , the tile is assumed to have four pixels. Consequently, the pixel data leaves the data interface  on four bi-directional data buses . These data buses  divide the memory array  into columns of 3D-RAM devices .","In this embodiment of the memory array , inbound pixel data being stored in the array is written into the SRAM  of the 3D-RAM devices . As described earlier, this SRAM acts as a level one cache memory. Pixel cache requests  are received from the pixel request processor  (described in detail below) and may include the target address of the pixel data. Along with the target address, opcodes for ALU  may be sent allowing for the arithmetic combination of the pixel data with data already stored in the memory array .","In performing some operations (e.g., scaling rendered data to change the effective zoom factor of the displayed image), the hardware accelerator  may also request pixel data from the memory array . If the requested pixel data is currently residing in the level one cache memory , then the pixel request processor  issues pixel cache requests  to the memory array . These requests may include the source address of the data to be retrieved, as well as an indication of which 3D-RAM devices  the data is to be found in. The 3D-RAM devices respond by placing the requested data on the data buses  where it is delivered to the data interface . Within the data interface , the pixels may be reordered when recombined into a tile in order to maintain any spatial interrelationships. Once the tile is constructed, the data may be buffered and delivered to the fragment processor .","When pixel data that is requested from the memory array  is not currently residing in the level one cache  (i.e., a level one cache miss), a cache operation may be requested prior to the issuance of any pixel cache requests . If the data is determined to be located in the level two cache  (i.e., a level two cache hit), then the memory request processor  (described in detail below) may request a block transfer by asserting the appropriate memory control signals . In this case, a block of memory within the level one cache  may be allocated, and a block of pixel data may be transferred from the level two cache  to the level one cache . After this transfer is completed, the pixel cache requests  described above may be issued.","If the requested data is not found in the level two cache (i.e., a level two cache miss), then the memory request processor  may request a page fetch by asserting the appropriate memory control signals . In this case, an entire page of pixel data is read from the appropriate DRAM bank  and deposited in the associated level two cache . Once the page fetch is completed, then the block transfer and pixel cache requests  described above may be issued.","The 3D-RAM devices  may also receive requests for video that cause data to be internally transferred from the appropriate DRAM banks  to the shift registers . In the embodiment shown, the video streams from all 3D-RAM devices  in the array are combined into a single video stream through the use of a multiplexer . The output of the multiplexer  may then be delivered to the video output processor  described in more detail below. In other embodiments of the memory array , the video streams from each 3D-RAM may be connected in parallel to form a video bus. In this case, the shift registers  may be furnished with output enable controls, where the assertion of an output enable may cause the associated shift register  to place data on the video bus.","Turning now to , one embodiment of the frame buffer interface  is shown. The request preprocessor  may be configured to receive requests related to pixels contained in the memory array . These requests may represent pixel storage\/retrieval, manipulation, fill, or other operations. The submitted request is examined, and the page and block address of the corresponding pixel in the memory array  is determined. The request preprocessor  may maintain a set of top cache tags  for both the level one and the level two caches. These cache tags  may represent the current state of the caches, as well as any pending cache requests already in the cache queues . The cache tags  are examined against the page and block addresses of the targeted pixel for a hit indicating that the pixel is currently cached. If the examination reveals that the pixel is already in the level one cache, then a request may be placed in the pixel queue . Otherwise, the miss is evaluated as either a level one or level two miss, and a request to the appropriate cache or caches is placed in the cache queue .","In this example, the cache queues  are two small queues that may operate in a first-in-first-out (FIFO) mode and may differ in depth. For example, where the queue for the level two cache may be 4 entries deep, the queue for the level one cache may be 8 entries, or twice as large. The cache queues  receive queue requests from the request preprocessor  and buffers them until the memory request processor  is able to service them. Requests placed in the level two cache queue may include an indication of a page address to fetch and a bank from which to fetch the page. Requests placed in the level one cache may be slightly more complicated, including not only a block address, but also an opcode indicating a fetch, fast fill, memory mode change, or other operation to be performed on the cache.","The pixel queue  is a small FIFO memory, which may be larger than either of the two cache queues . In this example, the pixel queue  may be 16 entries deep and logically divided into a pixel address queue and a pixel data queue. The pixel queue  receives requests to store, fetch or modify pixels from the request preprocessor , and buffers them until the pixel request processor  is able to service them.","The memory request processor  receives requests from both the cache queues  and the pixel queue  and issues the appropriate DRAM controls to the memory array . The memory request processor  maintains a second set of tag lists for the level one and level two caches. Unlike the tag lists that are maintained by the request preprocessor , the tag lists within the memory request processor contain only the current state of the two caches. In evaluating the requests from the queues, page and block addresses are checked against the cache tag lists and misses are translated into the appropriate fetch operations.","The memory request processor  may also be responsible for cleansing blocks within the SRAM pixel cache . Information is maintained within the bottom cache tags  which describes the current status of each block of pixel data currently residing in the level one cache . The status may include a tag indicating the block is \u201cdirty\u201d (i.e., pixel data within the block has been modified) and an LRU count describing the usage. As described above, the LRU count for a block may be equal to zero if the block has just been accessed and may be equal to the maximum value if the block has not been accessed in several memory operations. The memory request processor  may utilize this status information to periodically write back dirty blocks to the level two cache  giving priority to blocks that have high LRU counts. In this manner, least recently used blocks are kept clean, and hence kept available for future allocation.","The pixel request processor  may be configured to receive requests from the pixel queue . In response to these requests, the pixel request processor  may issue commands to the memory array . These commands at least in part may control the way in which the ALU  treats pixel data as the pixel data is routed to the memory for storage. Thus the pixel request processor  not only directs pixel movement through the memory, but also the manipulation of these pixels. The pixel request processor  may be additionally configured to maintain information related to the most recent instructions issued to the memory array , and in this way internally track or predict the progress of pixels through the processing pipeline of the 3D-RAM.","The video request processor  may be configured to receive and process requests for video from the memory array . These requests may contain information describing the page where the desired data is located, and the display scan line desired. These requests may be formatted and stored until the memory request processor  is able to service them. The video request processor  may also employ a video request expiration counter. This expiration counter may be configured to determine deadlines for requests issued to the memory array  in order to produce an uninterrupted stream of video data. In circumstances where a request is not issued within the allotted time, the video request processor may issue an urgent request for video.","Turning now to , one embodiment of the bottom cache tag  structure is illustrated. The bottom cache tags  may comprise a set of tags for the level two cache  and a separate set for the level one cache . The L2 tags  associated with the level two cache  may contain information  regarding the addresses of pages currently cached for each DRAM bank . The L1 tags  associated with the level one cache  may similarly contain information  regarding the addresses of blocks currently cached. Additionally, the L1 tags  may contain information about individual block usage in the form of an LRU (least recently used) count . The information in the LRU count  may be used to relativistically determine how recently a particular block has been accessed. In some embodiments, the LRU count  may have a minimum value of zero and a maximum value of seven. In this example, a value of zero may indicate that the block has just been accessed whereas a value of seven may indicate that the associated block has not been accessed in several memory operations. The memory request processor  may use this information when requesting new block allocations. For example, if a requested pixel is located in a block not currently cached in the level one cache , then a block fetch may be issued. Assuming the level one cache  is currently full, a block of cache memory will be flushed in order to make room for the new fetch. The decision to flush a block of cache memory may be made in accordance with the associated LRU count  (e.g., the most recently used blocks will be kept, whereas the least recently used block may be flushed).","The L1 tags  may also contain a dirty tag bit . As the memory request processor  issues cache requests and the pixel request processor  issues pixel requests as described above, the contents of the dirty tag bit  may be modified. In this example, a block transfer occurring between a level two cache  and a level one cache  may cause the dirty tag bit  associated with the block to be set to a known state indicating that the pixel data is unmodified. In this case, \u201cunmodified\u201d means that the block of data residing in the level one cache  is equivalent to the copy held in the level two cache , and hence the same as the original data stored in the associated DRAM bank . Conversely, a pixel storage operation may cause the dirty tag bit  associated with the affected block to be set to a known state indicating the data is modified. In this case, \u201cmodified\u201d means that the indicated pixel data in the level one cache  may be different from the copy held in the level two cache , and hence different from the original data stored in the associated DRAM bank .","The memory request processor  may periodically copy dirty blocks of pixel data in the level one cache  to the level two cache . Turning now to , a flow diagram representing one embodiment of this \u201cblock cleansing\u201d function is illustrated. In this example, the level one cache  memory blocks are first ordered according to the associated LRU count  (step ). This ordering may be by descending LRU count  meaning the block at the top of the list will have the highest LRU count , and hence will represent the block least recently used. Consequently, the block at the bottom of the list will represent the block most recently used. In this embodiment, a pointer may be used to indicate the block currently under examination. The next step may therefore be the initialization of this pointer so that it indicates the block at the top of the list (step ). Next, the dirty tag bit  associated with the block currently under examination is tested (step ). If the dirty tag bit  indicates that the current block is not dirty, then the pointer is made to point to the next block (step ) and the associated dirty tag bit  is tested. Steps  and  form a loop that steps through the list until a dirty block is found.","Once a dirty block is found, the block cleansing may stall until an empty memory cycle is detected (step ), at which point a command is issued to the memory request processor  (step ). This command may be a request to copy the current level one cache  memory block to the corresponding level two cache . In this embodiment, the level two cache  is configured as a \u201cwrite-through\u201d cache. Consequently, as the block is written to the level two cache  it is also written through to the associated DRAM bank  (step ). Once the block is successfully transferred, the associated dirty tag bit  may be modified to indicate that the block is now clean and available for future allocation (step ). The next block in the list is then indicated (step ), and the process is repeated by branching to step .","Maintaining an LRU count  for each block allows the block cleansing function to prioritize blocks as described above. It may also be facilitate the process of selecting blocks to flush when allocation requests are processed. Turning now to , a flow diagram illustrates one embodiment of a method for maintaining an LRU count. The process first waits for an access to a block of level one cache  memory (step ). Once a block access is detected, the number of the block may be saved in variable n (step ) while the current LRU of the block may be saved in variable x (step ). Next, each of the L1 tags  may be examined by first causing a pointer to indicate the tag corresponding to block 0 (step ). The L1 tag  is retrieved for the block being examined, and the associated LRU  is tested against the variable x (step ). If the LRU  of the block being examined is less than x (i.e., the block being examined has been accessed more recently than the block currently being accessed), then the LRU  may be incremented by one (step ). Next, the pointer is tested to determine if each of the L1 tags  has been examined. If there are blocks remaining to examine, then the pointer is incremented in order to indicate the next block (step ) and the examination is repeated by branching to step . If however, all of the blocks have been examined, then the LRU  of the block currently being accessed may be set to zero (step ), and the process may be exited.","The method described above relies on the assumption that all LRU counts  are initialized to the maximum value prior to any block accesses. An additional constraint of forcing the maximum value of the LRU count  to be equal to the number of available blocks minus one may also be imposed. In this case, as the level one cache  is filled, the LRU counts  of the blocks may become an ordered set with only one least recently used block, and one most recently used block being indicated.","Hence according to the embodiments illustrated above, blocks within the level one cache  are kept \u201cclean\u201d (i.e., free of modified pixel data which does not exist also in the level two cache  and the DRAM bank ) through periodic examination and prioritized write-back. These clean blocks are consequently available for future allocations, whereas a lack of clean blocks could potentially result in a stalled data pipeline of a high performance system.","Video Output Processor\u2014","Turning now to , one embodiment of a video output processor  is shown for thoroughness. Video output processor  may buffer and process pixels output from frame buffer . For example, video output processor  may be configured to read bursts of pixels from frame buffer . Video output processor  may also be configured to perform double buffer selection (dbsel) if the frame buffer  is double-buffered, overlay transparency (using transparency\/overlay unit ), plane group extraction, gamma correction, pseudocolor or color lookup or bypass, and\/or cursor generation. For example, in the illustrated embodiment, the output processor  includes WID (Window ID) lookup tables (WLUTs)  and gamma and color map lookup tables (GLUTs, CLUTs) . In one embodiment, frame buffer  may include multiple 3DRAM64s  that include the transparency overlay  and all or some of the WLUTs . Video output processor  may also be configured to support two video output streams to two displays using the two independent video raster timing generators . For example, one raster (e.g., A) may drive a 1280\u00d71024 CRT while the other (e.g., B) may drive a NTSC or PAL device with encoded television video.","DAC  may operate as the final output stage of graphics system . The DAC  translates the digital pixel data received from GLUT\/CLUTs\/Cursor unit  into analog video signals that are then sent to a display device. In one embodiment, DAC  may be bypassed or omitted completely in order to output digital pixel data in lieu of analog video signals. This may be useful when a display device is based on a digital technology (e.g., an LCD-type display or a digital micro-mirror display).","DAC  may be a red-green-blue digital-to-analog converter configured to provide an analog video output to a display device such as a cathode ray tube (CRT) monitor. In one embodiment, RGB DAC  may be configured to provide a high resolution RGB analog video output at dot rates of 240 MHz. Similarly, encoder  may be configured to supply an encoded video signal to a display. For example, encoder  may provide encoded NTSC or PAL video to an S-Video or composite video television monitor or recording device.","In other embodiments, the video output processor  may output pixel data to other combinations of displays. For example, by outputting pixel data to two DACs  (instead of one DAC  and one encoder ), video output processor  may drive two CRTs. Alternately, by using two encoders , video output processor  may supply appropriate video input to two television monitors. Generally, many different combinations of display devices may be supported by supplying the proper output device and\/or converter for that display device.","Although the embodiments above have been described in considerable detail, other versions are possible. Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications. Note the headings used herein are for organizational purposes only and are not meant to limit the description provided herein or the claims attached hereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing, as well as other objects, features, and advantages of this invention may be more completely understood by reference to the following detailed description when read together with the accompanying drawings in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 5","FIG. 3"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 6","FIG. 3"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 8","FIG. 6"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 9","FIG. 6"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 10","FIG. 9"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 13","FIG. 3"]}]},"DETDESC":[{},{}]}
