---
title: Method, apparatus, and product for leasing of group membership in a distributed system
abstract: A system for leasing a group membership in a distributed processing system is provided. In accordance with this system, a remote object requests from an activation group a membership in the activation group for a period of time. Responsive to this request, the activation group determines an appropriate lease period during which time the remote object becomes a member of the activation group and runs in the same address space as other objects of the activation group.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06925644&OS=06925644&RS=06925644
owner: Sun Microsystems, Inc.
number: 06925644
owner_city: Santa Clara
owner_country: US
publication_date: 20030131
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","A. FIELD OF THE INVENTION","B. DESCRIPTION OF THE RELATED ART","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","(i) Dirty Calls","(ii) Clean Calls","(iii) Garbage Collection","Alternative Embodiment of the Present Invention"],"p":["This is a continuation of U.S. patent application Ser. No. 09\/044,834, filed on Mar. 20, 1998, now U.S. Pat. No. 6,421,704 which is a continuation-in-part of U.S. patent application No., 08\/729,421, filed on Oct. 11, 1996, now U.S. Pat. No. 5,832,529, both of which are incorporated herein by reference.","The following identified U.S. patent applications are relied upon and are incorporated by reference in this application.","Provisional U.S. Application No. 60\/076,048, entitled \u201cDistributed Computing System,\u201d filed on Feb. 26, 1998.","U.S. patent application Ser. No. 09\/044,923, entitled \u201cMethod and System for Leasing Storage,\u201d filed Mar. 20, 1998, now U.S. Pat. No. 6,263,350.","U.S. patent application Ser. No. 09\/044,838, entitled \u201cMethod, Apparatus, and Product for Leasing of Delegation Certificates in a Distributed System,\u201d now U.S. Pat. No. 6,247,026, and filed on Mar. 20, 1998, which is a continuation-in-part of U.S. application Ser. No. 08\/729,421,filed on Oct. 11, 1996, now U.S. Pat. No. 5,832,529.","U.S. patent application Ser. No. 09\/044,926, entitled \u201cLeasing for Failure Detection,\u201d and filed on Mar. 20, 1998, now U.S. Pat. No. 6,016,500, which is a continuation-in-part of U.S. patent application Ser. No. 08\/729,421,filed Oct. 11, 1996, now U.S. Pat. No. 5,832,529.","U.S. patent application Ser. No. 09\/044,933, entitled \u201cMethod for Transporting Behavior in Event Based System,\u201d filed on Mar. 20, 1998, now U.S. Pat. No. 6,463,446.","U.S. patent application Ser. No. 091044,919, entitled \u201cDeferred Reconstruction of Objects and Remote Loading for Event Notification in a Distributed System,\u201d filed on Mar. 20,1998, and now U.S. Pat. No. 6,272,559.","U.S. patent application Ser. No. 09\/044,938, entitled \u201cMethods and Apparatus for Remote Method Invocation,\u201d and filed on Mar. 20, 1998, now U.S. Pat. No. 6,487,607.","U.S. patent application Ser. No. 09\/045,652, entitled \u201cMethod and System for Deterministic Hashes to Identify Remote Methods,\u201d filed on Mar. 20, 1998, and now U.S. Pat. No. 6,134,603.","U.S. patent application Ser. No. 09\/044,790, entitled \u201cMethod and Apparatus for Determining Status of Remote Objects in a Distributed System,\u201d and filed on Mar. 20, 1998,now U.S. Pat. No. 6,598,094.","U.S. patent application Ser. No. 09\/044,930, entitled \u201cDownloadable Smart Proxies for Performing Processing Associated with a Remote Procedure Call in a Distributed System,\u201d and filed on Mar. 20, 1998, now U.S. Pat. No. 6,393,497.","U.S. patent application Ser. No. 09\/044,917, entitled \u201cSuspension and Continuation of Remote Methods,\u201d filed on Mar. 20, 1998, and now U.S. Pat. No. 6,237,024.","U.S. patent application No. 09\/044,835, entitled \u201cMethod and System for Multi-Entry and Multi-Template Matching in a Database,\u201d filed on Mar. 20,1998, and now U.S. Patent No. 6,182,083.","U.S. patent application Ser. No. 09\/044,839, entitled \u201cMethod and System for In-Place Modifications in a Database,\u201d filed on Mar. 20, 1998, now abandoned.","U.S. patent application Ser. No. 09\/044,945, entitled \u201cMethod and System for Typesafe Attribute Matching in a Database,\u201d filed on Mar. 20, 1998, and now U.S. Pat. No. 6,578,044.","U.S. patent application Ser. No. 09\/044,931, entitled \u201cDynamic Lookup Service in a Distributed System,\u201d filed on Mar. 20, 1998, and now U.S. Pat. No. 6,185,611.","U.S. patent application Ser. No. 09\/044,939, entitled \u201cApparatus and Method for Providing Downloadable Code for Use in Communicating with a Device in a Distributed System,\u201d and filed on Mar. 20, 1998, now U.S. Pat. No. 6,560,656.","U.S. patent application Ser. No. 09\/044,826, entitled \u201cMethod and System for Facilitating Access to a Lookup Service,\u201d and filed on Mar. 20,1998.","U.S. patent application Ser. No. 09\/044,932, entitled \u201cApparatus and Method for Dynamically Verifying Information in a Distributed System,\u201d filed on Mar. 20, 1998, now U.S. Pat. No. 6,466,947.","U.S. patent application Ser. No. 09\/044,936, entitled \u201cAn Interactive Design Tool for Persistent Shared Memory Spaces,\u201d filed on Mar. 20, 1998, now abandoned.","U.S. patent application Ser. No. 09\/044,934, entitled \u201cPolymorphic Token-Based Control,\u201d filed on Mar. 20,1998, now U.S. Pat. No. 6,438,614.","U.S. patent application Ser. No. 09\/044,915, entitled \u201cStack-Based Access Control,\u201d filed on Mar. 20, 1998, and now U.S. Pat. No. 6,138,238.","U.S. patent application Ser. No. 09\/044,944, entitled \u201cStack-Based Security Requirements,\u201d filed on Mar. 20, 1998, and now U.S. Pat. No. 6,226,746.","U.S. patent application Ser. No. 09\/044,837, entitled \u201cPer-Method Designation of Security Requirements,\u201d filed on Mar. 20, 1998, and now U.S. Pat. No. 6,282,652.","This invention relates generally to data processing systems and, more particularly, to leasing group memberships for objects in data processing systems.","Proper resource management is an important aspect to efficient and effective use of computers. In general, resource management involves allocating resources (e.g., memory) in response to requests as well as deallocating resources at appropriate times, for example, when the requesters no longer require the resources. In general, the resources contain data referenced by computational entities (e.g., applications, programs, applets, etc.) executing in the computers.","In practice, when applications executing on computers seek to refer to resources, the computers must first allocate or designate resources so that the applications can properly refer to them. When the applications no longer refer to a resource, the computers can deallocate or reclaim the resource for reuse. In computers each resource has a unique \u201chandle\u201d by which the resource can be referenced. The handle may be implemented in various ways, such as an address, array index, unique value, pointer, etc.","Resource management is relatively simple for a single computer because the events indicating when resources can be reclaimed, such as when applications no longer refer to them or after a power failure, are easy to determine. Resource management for distributed systems connecting multiple computers is more difficult because applications in several different computers may be using the same resource.","Disconnects in distributed systems can lead to the improper and premature reclamation of resources or to the failure to reclaim resources. For example, multiple applications operating on different computers in a distributed system may refer to resources located on other machines. If connections between the computers on which resources are located and the applications referring to those resources are interrupted, then the computers may reclaim the resources prematurely. Alternatively, the computers may maintain the resources in perpetuity, despite the extended period of time that applications failed to access the resources.","These difficulties have led to the development of systems to manage network resources, one of which is known as \u201cdistributed garbage collection.\u201d That term describes a facility provided by a language or runtime system for distributed systems that automatically manages resources used by an application or group of applications running on different computers in a network.","In general, garbage collection uses the notion that resources can be freed for future use when they are no longer referenced by any part of an application. Distributed garbage collection extends this notion to the realm of distributed computing, reclaiming resources when no application on any computer refers to them.","Distributed garbage collection must maintain integrity between allocated resources and the references to those resources. In other words, the system must not be permitted to deallocate or free a resource when an application running on any computer in the network continues to refer to that resource. This reference-to-resource binding, referred to as \u201creferential integrity,\u201d does not guarantee that the reference will always grant access to the resource to which it refers. For example, network failures can make such access impossible. The integrity, however, guarantees that if the reference can be used to gain access to any resource, it will be the same resource to which the reference was first given.","Distributed systems using garbage collection must also reclaim resources no longer being referenced at some time in the finite future. In other words, the system must provide a guarantee against \u201cmemory leaks.\u201d A memory leak can occur when all applications drop references to a resource, but the system fails to reclaim the resource for reuse because, for example, of an incorrect determination that some application still refers to the resource.","Referential integrity failures and memory leaks often result from disconnections between applications referencing the resources and the garbage collection system managing the allocation and deallocation of those resources. For example, a disconnection in a network connection between an application referring to a resource and a garbage collection system managing that resource may prevent the garbage collection system from determining whether and when to reclaim the resource. Alternatively, the garbage collection system might mistakenly determine that, since an application has not accessed a resource within a predetermined time, it may collect that resource. A number of techniques have been used to improve the distributed garbage collection mechanism by attempting to ensure that such mechanisms maintain referential integrity without memory leaks. One conventional approach uses a form of reference counting, in which a count is maintained of the number of applications referring to each resource. When a resource's count goes to zero, the garbage collection system may reclaim the resource. Such a reference counting scheme only works, however, if the resource is created with a corresponding reference counter. The garbage collection system in this case increments the resource's reference count as additional applications refer to the resource, and decrements the count when an application no longer refers to the resource.","Reference counting schemes, however, especially encounter problems in the face of failures that can occur in distributed systems. Such failures can take the form of a computer or application failure or network failure that prevent the delivery of messages notifying the garbage collection system that a resource is no longer being referenced. If messages go undelivered because of a network disconnect, the garbage collection system does not know when to reclaim the resource.","To prevent such failures, some conventional reference counting schemes include \u201ckeep-alive\u201d messages, which are also referred to as \u201cping back.\u201d According to this scheme, applications in the network send messages to the garbage collection system overseeing resources and indicate that the applications can still communicate. These messages prevent the garbage collection system from dropping references to resources. Failure to receive such a \u201ckeep-alive\u201d message indicates that the garbage collection system can decrement the reference count for a resource and, thus, when the count reaches zero, the garbage collection system may reclaim the resource. This, however, can still result in the premature reclamation of resources following reference counts reaching zero from a failure to receive \u201ckeep-alive\u201d messages because of network failures. This violates the referential integrity requirement.","Another proposed method for resolving referential integrity problems in garbage collection systems is to maintain not only a reference count but also an identifier corresponding to each computational entity referring to a resource. See A. Birrell, et al., \u201cDistributed Garbage Collection for Network Objects,\u201d No. 116, digital Systems Research Center, Dec. 15, 1993. This method suffers from the same problems as the reference counting schemes. Further, this method requires the addition of unique identifiers for each computational entity referring to each resource, adding overhead that would unnecessarily increase communication within distributed systems and add storage requirements (i.e., the list of identifiers corresponding to applications referring to each resource).","In accordance with the present invention, referential integrity is guaranteed without costly memory leaks by leasing resources for a period of time during which the parties in a distributed system, for example, an application holding a reference to a resource and the garbage collection system managing that resource, agree that the resource and a reference to that resource will be guaranteed. At the end of the lease period, the guarantee that the reference to the resource will continue lapses, allowing the garbage collection system to reclaim the resource. Because the application holding the reference to the resource and the garbage collection system managing the resource agree to a finite guaranteed lease period, both can know when the lease and, therefore, the guarantee, expires. This guarantees referential integrity for the duration of a reference lease and avoids the concern of failing to free the resource because of network errors.","Consistent with an alternative embodiment of the present invention, as embodied and broadly described herein, a method for leasing group membership is provided. This method comprises the steps of receiving a lease request from a remote object specifying an activation group and a lease period and determining a lease period during which the remote object is associated with and runs in the same address space as the other objects, if any, in the activation group.","Reference will now be made in detail to an implementation of the present invention as illustrated in the accompanying drawings. Wherever possible, the same reference numbers will be used throughout the drawings and the following description to refer to the same or like parts.","The present invention may be implemented by computers organized in a conventional distributed processing system architecture. The architecture for and procedures to implement this invention, however, are not conventional, because they provide a distributed garbage collection scheme that ensures referential integrity and eliminates memory leaks.","A. Overview","A method invocation (MI) component located in each of the computers in the distributed processing system implements the distributed garbage collection scheme of this invention. The MI component may consist of a number of software modules preferably written in the JAVA\u2122 programming language.","In general, whenever an application in the distributed processing system obtains a reference to a distributed resource, by a name lookup, as a return value to some other call, or another method, and seeks to access the resource, the application makes a call to the resource or to an MI component managing the resource. That MI component, called a managing MI component, keeps track of the number of outstanding references to the resource. When the number of references to a reference is zero, the managing MI component can reclaim the resource. The count of the number of references to a resource is generally called the \u201creference count\u201d and the call that increments the reference count may be referred to as a \u201cdirty call.\u201d","When an application no longer requires a distributed resource, it sends a different call to the resource or the managing MI component. Upon receipt of this call, the managing MI component decrements the reference count for the resource. This call to drop a reference may be referred to as a \u201cclean call.\u201d","In accordance with an implementation of the present invention, a dirty call can include a requested time interval, called a lease period, for the reference to the resource. Upon receipt of the dirty call, the managing MI component sends a return call indicating a period for which the lease was granted. The managing MI component thus tracks the lease period for those references as well as the number of outstanding references. Consequently, when the reference count for a resource goes to zero or when the lease period for the resource expires, the managing MI component can reclaim the resource.","B. Procedure","An application call processor in an MI component performs the steps of the application call procedure  illustrated in FIG. . The server call processor in the managing MI component performs the steps of the procedures , , and  illustrated in , respectively. The managing MI component's garbage collector performs conventional procedures to reclaim resources previously bound to references in accordance with instructions from the server call processor. Accordingly, the conventional procedures of the garbage collector will not be explained.","1. Application Call Processor",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 1","b":"100"},"After an application has obtained a reference to a resource, the application call processor sends a dirty call, including the resource's reference and a requested lease period to the managing MI component for the resource (step ). The dirty call may be directed to the resource itself or to the managing MI component.","The application call processor then waits for and receives a return call from the managing MI component (step ). The return call includes a granted lease period during which the managing MI component guarantees that the reference of the dirty call will be bound to its resource. In other words, the managing MI component agrees not to collect the resource corresponding to the reference of a dirty call for the grant period. If the managing MI component does not provide a grant period, or rejects the request for a lease, then the application call processor will have to send another dirty call until it receives a grant period.","The application call processor monitors the application's use of the reference and, either when the application explicitly informs the application call processor that the reference is no longer required or when the application call processor makes this determination on its own (step ), the application call processor sends a clean call to the managing MI component (step ). In a manner similar to the method used for dirty calls, the clean call may be directed to the referenced resource and the managing MI component will process the clean call. Subsequently, the application call processor eliminates the reference from a list of references being used by the application (step ).","If the application is not yet done with the reference (step ), but the application call processor determines that the grant period for the reference is about to expire (step ), then the application call processor repeats steps  and  to ensure that the reference to the resource is maintained by the managing MI component on behalf of the application.","2. Server Call Processor","The MI component's server call processor performs three main procedures: (1) handling dirty calls; (2) handling incoming clean calls; and (3) initiating a garbage collection cycle to reclaim resources at the appropriate time.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 2","b":"200"},"First, the server call processor receives a dirty call (step ). The server call processor then determines an acceptable grant period (step ). The grant period may be the same as the requested lease period or some other time period. The server call processor determines the appropriate grant period based on a number of conditions including the amount of resource required and the number of other grant periods previously granted for the same resource.","When the server call processor determines that a resource has not yet been allocated for the reference of a dirty call (step ), the server call processor allocates the required resource (step ).","The server call processor then increments a reference count corresponding to the reference of a dirty call (step ), sets the acceptable grant period for the reference-to-resource binding (step ), and sends a return call to an application call processor with the grant period (step ). In this way, the server call processor controls incoming dirty calls regarding references to resources under its control.","Applications can extend leases by sending dirty calls with an extension request before current leases expire. As shown in procedure , a request to extend a lease is treated just like an initial request for a lease. An extension simply means that the resource will not be reclaimed for some additional interval of time, unless the reference count goes to zero.","The MI component's server call processor also handles incoming clean calls from application call processors. When an application in the distributed processing system no longer requires a reference to a resource, it informs the MI component managing the resource for that reference so that the resource may be reclaimed for reuse.  is a flow diagram of the procedure  with the steps that the MI component's server call processor uses to handle clean calls.","When the server call processor receives a clean call with a reference to a resource that the MI component manages (step ), the server call processor decrements a corresponding reference count (step ). The clean call may be sent to the resource, with the server call processor monitoring the resource and executing the procedure  to process the call. Subsequently, the server call processor sends a return call to the MI component that sent the clean call to acknowledge receipt (step ). In accordance with this implementation of the present invention, a clean call to drop a reference may not be refused, but it must be acknowledged.","The server call processor also initiates a garbage collection cycle to reclaim resources for which it determines that either no more references are being made to the resource or that the agreed lease period for the resource has expired. The procedure  shown in  includes a flow diagram of the steps that the server call processor uses to initiate a garbage collection cycle.","The server call processor monitors reference counts and granted lease periods and determines whether a reference count is zero for a resource managed by the MI component, or the grant period for a reference has expired (step ). When either condition exists, the server call processor initiates garbage collection (step ) of that resource. Otherwise, the server call processor continues monitoring the reference counts and granted lease periods.","C. Call Flow",{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 5","b":["525","530","530","505","525","525"]},{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 5","b":["510","540","515","545","510","540","530","530","510","540","515","545","551","571","525","515","525","530","525","515","545"]},"In response to the dirty calls  and , managing MI component  sends return calls  and , respectively, to each of the MI components  and , respectively. The dirty calls include granted lease periods for the references of the dirty calls  and .","Similarly,  also shows MI components  and  sending clean calls  and , respectively, to managing MI component . Clean calls  and  inform managing MI component  that applications  and , respectively, no longer require access to the resource specified in the clean calls  and . Managing MI component  responds to clean calls  and  with return calls  and , respectively. Return calls  and  differ from return calls  and  in that return calls  and  are simply acknowledgments from MI component  of the received clean calls  and .","Both applications  and  may request access to the same resource. For example, application  may request access to \u201cRESOURCE(1)\u201d while application  was previously granted access to that resource. MI component  handles this situation by making the resource available to both applications  and  for agreed lease periods. Thus, MI component  will not initiate a garbage collection cycle to reclaim the \u201cRESOURCE(1)\u201d until either applications  and  have both dropped their references to that resource or the latest agreed periods has expired, whichever event occurs first.","By permitting more than one application to access the same resource simultaneously, the present invention also permits an application to access a resource after it sent a clean call to the managing MI component dropping the reference to the resource. This occurs because the resource is still referenced by another application or the reference's lease has not yet expired so the managing MI component  has not yet reclaimed the resource. The resource, however, will be reclaimed after a finite period, either when no more applications have leases or when the last lease expires.","D. MI Components",{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 6","b":["600","600","605","640","650","660"]},"Reference component  preferably constitutes a table or comparable structure with reference data portions , reference count , and grant period register . MI component  uses the reference count  and grant period  for each reference specified in a corresponding reference data portion  to determine when to initiate garbage collector  to reclaim the corresponding resource.","Application call processor  is the software module that performs the steps of procedure  in FIG. . Server call processor  is the software module that performs the steps of procedures , , and  in . Garbage collector  is the software module that reclaims resources in response to instructions from the server call processor , as explained above.","E. Distributed Processing System",{"@attributes":{"id":"p-0093","num":"0092"},"figref":["FIG. 7","FIG. 7","FIG. 7"],"b":["50","50","100","200","300","55","55","700","800","900"]},"In the implementation of distributed processing system , platforms ,  and  each include a processor , , and  respectively, and a memory, , , and , respectively. Included within each processor , , and , are applications , , and , respectively, operating systems , , and , respectively, and MI components , , and , respectively.","Applications , , and  can be programs that are either previously written and modified to work with the present invention, or that are specially written to take advantage of the services offered by the present invention. Applications , , and  invoke operations to be performed in accordance with this invention.","MI components , , and  correspond to the MI component  discussed above with reference to FIG. .","Operating systems , , and  are standard operating systems tied to the corresponding processors , , and , respectively. The platforms , , and  can be heterogenous. For example, platform  has an UltraSparc\u00ae microprocessor manufactured by Sun Microsystems Corp. as processor  and uses a Solaris\u00ae operating system . Platform  has a MIPS microprocessor manufactured by Silicon Graphics Corp. as processor  and uses a Unix operating system . Finally, platform  has a Pentium microprocessor manufactured by Intel Corp. as processor  and uses a Microsoft Windows 95 operating system . The present invention is not so limited and could accommodate homogenous platforms as well.","Sun, Sun Microsystems, Solaris, Java, and the Sun Logo are trademarks or registered trademarks of Sun Microsystems, Inc. in the United States and other countries. UltraSparc and all other SPARC trademarks are used under license and are trademarks of SPARC International, Inc. in the United States and other countries. Products bearing SPARC trademarks are based upon an architecture developed by Sun Microsystems, Inc.","Memories , , and  serve several functions, such as general storage for the associated platform. Another function is to store applications , , and , MI components , , and , and operating systems , , and  before execution by the respective processor , , and . In addition, portions of memories , , and  may constitute shared memory available to all of the platforms , , and  in network .","E. MI Services","The present invention may be implemented using a client\/server model. The client generates requests, such as the dirty calls and clean calls, and the server responds to requests.","Each of the MI components ,  and  shown in  preferably includes both client components and server components. , which is a block diagram of a client platform  and a server platform , applies to any two of the platforms , , and  in FIG. .","Platforms  and  contain memories  and , respectively, and processors  and , respectively. The elements in the platforms  and  function in the same manner as similar elements described above with reference to FIG. . In this example, processor  executes a client application  and processor  executes a server application . Processors  and  also execute operating systems  and , respectively, and MI components  and , respectively.","MI components  and  each include a server call processor  and , respectively, an application call processor  and , respectively, and a garbage collector  and , respectively. Each of the MI components  and  also contains reference components, including reference data portions  and , respectively, reference counts  and , respectively, and grant period registers  and , respectively, for each reference that the respective MI component  or  monitors.","Application call processors  and  represent the client service and communicate with server call processors  and , respectively, which represent the server service. Because platforms  and  contain a server call processor, an application call processor, a garbage collector, and reference components, either platform can act as a client or a server.","For purposes of the discussion that follows, however, platform  is designated the client platform and platform  is designated as the server platform. In this example, client application  obtains references to distributed resources and uses MI component  to send dirty calls to the resources managed by MI component  of server platform .","Additionally, server platform  may be executing a server application . Server application  may also use MI component  to send dirty calls, which may be handled by MI component  when the resources of those dirty calls are managed by MI component . Alternatively, server application  may use MI component  to send dirty calls to resources managed by MI component .","Accordingly, server call processor , garbage collector , and reference count  for MI component  of client platform  are not active and are therefore presented in FIG.  as shaded. Likewise, application call processor  of MI component  of the server platform  is shaded because it is also dormant.","When client application  obtains a reference corresponding to a resource, application call processor  sends a dirty call, which server call processor  receives. The dirty call includes a requested lease period. Server call processor  increments the reference count  for the reference in the dirty call and determines a grant period. In response, server call processor  sends a return call to application call processor  with the grant period. Application call processor  uses the grant period to update recorded grant period , and to determine when the resource corresponding to the reference of its dirty call may be reclaimed.","Server call processor  also monitors the reference counts and grant periods corresponding to references for resources that it manages. When one of its reference counts  is zero, or when the grant period  for a reference has expired, whichever event occurs first, server call processor  may initiate the garbage collector  to reclaim the resource corresponding to the reference that has a reference count of zero or an expired grant period.","The leased-reference scheme according to the implementation of the present invention does not require that the clocks on the platforms  and  involved in the protocol be synchronized. The scheme merely requires that they have comparable periods of increase. Leases do not expire at a particular time, but rather expire after a specific time interval. As long as there is approximate agreement on the interval, platforms  and  will have approximate agreement on the granted lease period. Further, since the timing for the lease is, in computer terms, fairly long, minor differences in clock rate will have little or no effect.","The transmission time of the dirty call can affect the protocol. If MI component  holds a lease to reference and waits until just before the lease expires to request a renewal, the lease may expire before the MI component  receives the request. If so, MI component  may reclaim the resource before receiving the renewal request. Thus, when sending dirty calls, the sender should add a time factor to the requested lease period in consideration of transmission time to the platform handling the resource of a dirty call so that renewal dirty calls may be made before the lease period for the resource expires.","F. Conclusion","In accordance with the present invention a distributed garbage collection scheme ensures referential integrity and eliminates memory leaks by providing granted lease periods corresponding to references to resources in the distributed processing system such that when the granted lease periods expire, so do the references to the resources. The resources may then be collected. Resources may also be collected when they are no longer being referenced by processes in the distributed processing system with reference to counters assigned to the references for the resources.","The leasing technique, described above, relates to garbage collection. However, an alternative embodiment of the present invention, as described below, can be used to govern object membership in an activation group.","In a distributed system that utilizes the Java\u2122 programming environment (\u201cthe exemplary distributed system\u201d), objects contain methods that may be invoked remotely. These methods can be invoked by a client using the Java\u2122 remote method invocation system (RMI), sold as part of the Java Software development kit, available from Sun Microsystems, Inc. of Mountain View, Calif. In the exemplary distributed system, when a client invokes a method on a remote object, the object may not already be in memory on the remote machine. In this case, a component of RMI, known as the activation daemon, on the remote machine starts a Java\u2122 virtual machine (JVM) and then activates the object. The Java Virtual Machine is also provided as part of the Java software development kit and is described in greater detail in Lindholm and Yellin, Addison-Wesley (1997), which is incorporated herein by reference. \u201cActivating an object\u201d entails bringing the object into memory from secondary storage and invoking the requested method. It should be noted that both the object and the JVM run in a single address space. This process is repeated each time a method on a remote object not already in memory is called by the client. The exemplary distributed system is described in greater detail in copending U.S. patent application Ser. No. 09\/044,931, entitled \u201cDynamic Lookup Service in a Distributed System,\u201d which has previously been incorporated by reference.","A drawback to bringing objects into their own address space one at a time is that it is inefficient. Since each object is loaded into a separate address space, a loaded object is required to cross process boundaries to access another loaded object, which requires a significant amount of processing time. Accordingly, it is beneficial to load related objects into the same address space to avoid crossing process boundaries and facilitating locality of reference, since related objects tend to access each other often. In the alternative embodiment, related objects are grouped into an object group or a set of objects. Since the objects in a group are related to each other, it is efficient for them to run on the same JVM and, consequently, in the same address space. By running on the same JVM in the same address space, related objects can access each other more efficiently (i.e., directly, without having to cross process boundaries).","In the situation where related objects are grouped, when a client program invokes a method on a remote object, the activation daemon determines if the remote object is a member of a group of remote objects, known as an activation group. If the object belongs to an activation group and the group is not already loaded in memory, the activation daemon will start a JVM and load the object into the address space of the JVM. Subsequent invocations of methods on the other objects in the activation group will cause the activation daemon to load these objects into the same address space. Once the requested object is loaded on the JVM, the activation daemon will activate the object, and the requested method is invoked.","A drawback of grouping related objects together in the JVM is that a particular object could monopolize the activation group's available resources to the detriment of the other group members. For example, in a white-board program with multiple objects wanting to draw to a common area of the display using a cursor object, the cursor object is loaded into an activation group of objects who want to use it. Placing the cursor object in the same address space as the objects who want to use it allows the cursor to respond very quickly to a command because the cursor object is accessed without crossing process boundaries. The problem arises, however, when a particular object monopolizes the cursor object for so long as to negatively affect the other objects who want to use the cursor object.","The alternative embodiment eliminates this threat of monopolization by applying the leasing technique to the objects located in the activation group. Leasing ensures that no object in the activation group could monopolize another object. For instance, each object has to request a lease to join the activation group (i.e., to gain membership into the activation group). The activation group, itself, decides how long to grant the lease. For a white-board program, the activation group would grant very small leases. This ensures that no object could monopolize the cursor object, for when each object's lease expires, it is ejected from the activation group.","In the alternative embodiment, an object requests a lease to be a member of an activation group. The object must specify a period of time (the lease period) for which it desires membership, and the activation group, represented and managed by an object (the activation group object), decides how long to grant the lease. In addition to the period of time, the lease request contains an indication of whether the object wants an exact lease. When requesting a lease, the object may request an exact lease period. In this case, the activation group only grants a lease to the object if the lease period granted would be the entire lease period requested.","Every object is governed by a lease into an activation group. Even if a lease expires, the object is provided with a membership into its own activation group until it requests to be a member of a different activation group.","Once an object requests a lease from an activation group, the activation group returns to the object a lease object, which includes methods for determining the duration of the lease, for renewing the lease, and for canceling the lease. The lease object is an instance of a class that may be extended in many ways to offer more functionality, but the basic class is defined as follows:",{"@attributes":{"id":"p-0124","num":"0123"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"interface Lease {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public long getDuration ( );"]},{"entry":[{},"public void cancel ( ) throws UnknownLeaseException,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"RemoteException;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public void renew (long renewDuration) throws"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LeaseDeniedException,"]},{"entry":[{},"UnknownLeaseException,"]},{"entry":[{},"RemoteException;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"This class contains the getDuration method, the cancel method, and the renew method. Invoking the \u201cgetDuration\u201d method provides an object with the length of the granted lease period. This period represents the most recent lease granted by the activation group. It is the object's responsibility, however, to determine the amount of time outstanding on the lease.","The \u201crenew\u201d method permits the remote object to renew the lease, asking for more time, without having to re-initiate the original lease request. Situations where an object may desire to renew the lease include when the original lease proves to be insufficient (i.e., the remote object requires additional membership), or when only a partial lease (i.e., less than the requested lease) was granted.","An object may use the renew method to request an additional lease period, or the object may continually invoke the renew method multiple times until many additional lease periods are granted. The renew method has no return value; if the renewal is granted, the new lease period will be reflected in the lease object on which the call was made. If the activation group is unable or unwilling to renew the lease, the reason is set forth in the lease object on which the call was made.","An object invokes the \u201ccancel\u201d method when the object wishes to withdraw from the activation group, but there is still time left on the lease. The cancel method allows the activation group to remove the object from the activation group such that the object can no longer access any of the objects in the activation group without crossing process boundaries. In contrast, upon the end of a lease (i.e., natural termination), the activation group knows to eject the object. In this case, the object has no obligation to notify the activation group upon the natural termination of the lease.",{"@attributes":{"id":"p-0129","num":"0128"},"figref":"FIG. 9","b":["9000","9000","9002","9006","9004","9006"]},"The computer system  includes a memory , a secondary storage device , a central processing unit (CPU) , an input device , and a video display . The memory  further includes a Java\u2122 runtime system , which includes a Java virtual machine (JVM) , RMI , and an activation group . The activation group  may have some objects  associated with it which have not been activated and thus still reside on the secondary storage device . In addition, the memory  includes a Java runtime system , which includes a JVM , RMI , and an activation group , and a Java runtime system , including an activation daemon , a JVM , and RMI . The activation daemon  is responsible for activating objects  by bringing them into memory to be part of either activation group  or activation group .","The computer system  includes a memory , a secondary storage device , a CPU , an input device , and a video display . The memory  further includes a Java runtime system , which includes JVM , RMI , and a client program  which can request invocation of a method of a remote object (e.g., one of objects ) via a call to RMI . One skilled in the art will appreciate that data processing system  and computers  and  may contain additional or different components.","Although aspects of the alternative embodiment are described as being stored in memory, one skilled in the art will appreciate that these aspects may also be stored on or read from other computer-readable media, such as secondary storage devices, like hard disks, floppy disks, or CD-Rom; a carrier wave from the Internet, or other forms of RAM or ROM. Additionally, although the alternative embodiment is described as operating in a Java\u2122 programming environment, one skilled in the art will appreciate that the alternative embodiment can operate in other environments as well.",{"@attributes":{"id":"p-0133","num":"0132"},"figref":"FIG. 10","b":["9040","9018","9018","9018","10004"]},"After sending the lease request, the object determines whether the lease was successful by determining whether it received a lease object (step ). If the lease was successful, the object notifies the activation daemon  of its new association with activation group  (step ). When notifying the activation daemon, the object provides a copy of the lease object, which can be used by the activation daemon to determine the length of the lease period. After notifying the activation daemon, the object runs as part of the activation group  (step ). In this step, if the object becomes activated, it will execute on the Java runtime system . At some point later, the object determines whether it needs more time to run as part of the activation group (step ). If the object needs more time, the object invokes the renew method on the lease object returned via the lease request (step ). Then, the object determines if the renew request was successful (step ). If so, processing continues to step . Otherwise, processing ends.","If the object does not need more time, the object invokes the cancel method on the lease object to terminate the lease (step ). This step cancels the lease and, consequently, the object's membership in the activation group. Next, the object obtains a lease to another activation group, perhaps the activation group  from which it came (step ). It should be noted that if the object does not join another activation group, the next time it is activated, the activation daemon will make it a member of its own activation group.",{"@attributes":{"id":"p-0136","num":"0135"},"figref":"FIG. 11","b":["9060","9066","9048","9100","9106","11002","9106","9060","9060","9066","9066","9100","9066","9066","9066","9100","9106"]},"After receiving a request from RMI , the activation daemon determines if the lease for the object has expired (step ). In the alternative embodiment, each object is a member of an activation group and may usually have an outstanding lease. The activation daemon  maintains a mapping of all objects in computer  to the corresponding activation groups with which they are associated. If the activation daemon determines that the lease has expired, the activation daemon places the requested object into its own activation group (step ). In this step, the activation daemon stores an indication that the requested object is a member of its own activation group. After placing the object in its own activation group, the activation daemon starts a JVM and activates the object (step ). In this step, the activation daemon starts a JVM and loads the object into the JVM's address space from secondary storage . Additionally, the activation daemon invokes the requested method on the object.","If the activation daemon determines that the lease has not expired the activation daemon determines if the activation group in which the object is a member is currently running in a JVM (step ). If not, the activation daemon starts a JVM for the activation group (step ), and the activation daemon then activates the object (step ). In this step, the activation daemon brings the object from secondary storage into memory (the address space of the started JVM) and invokes the requested method.",{"@attributes":{"id":"p-0139","num":"0138"},"figref":"FIG. 12","b":["9618","12004"]},"After examining the parameters, the activation group determines if the request is proper (step ). For example, the activation group verifies that a desired lease period is specified, and if an exact lease is requested, the activation group determines if it can grant the request. For example, the activation group may be unwilling to grant a lease for the period of time for which the object has requested an exact lease. If the activation group determines that the lease request is improper, the activation group returns an exception object indicating the error (step ) and processing ends.","If the request is proper, the activation group determines a sufficient lease period (step ). The activation group then creates a lease object and returns it to the remote object (step ).","The foregoing description of an implementation of the invention has been presented for purposes of illustration and description. It is not exhaustive and does not limit the invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practicing of the invention. For example, the described implementation includes software but the present invention may be implemented as a combination of hardware and software or in hardware alone. The scope of the invention is defined by the claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings, which are incorporated in and constitute a part of this specification, illustrate an embodiment of the invention and, together with the description, serve to explain the advantages and principles of the invention. In the drawings,",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 11","FIG. 9"]},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
